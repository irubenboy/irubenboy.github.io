{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenidx al mundo de Java","text":""},{"location":"bloque_ii/tema_10/page-1/","title":"10.1 Introducci\u00f3n a los Gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-1/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Se trata de la implementaci\u00f3n en Java de una de las opciones de C++ m\u00e1s a\u00f1oradas por los programadores que proceden de ese lenguaje; las plantillas (templates). Son similares a las plantillas de C++. Sirven para evitar conversiones de clases.</p> <p>Uno de los motivos de la creaci\u00f3n de los gen\u00e9ricos fueron las colecciones. Sin los gen\u00e9ricos todas las colecciones ser\u00edan de tipo Object, lo que tendr\u00eda una serie de desventajas:</p> <ul> <li>Nada impide crear listas heterog\u00e9neas de objetos. Eso causa problemas evidentes de casting, adem\u00e1s de imposible incoherencias.</li> <li>Si se desea acceder a propiedades espec\u00edficas de otro tipo de clases, ser\u00e1 necesario realizar una cantidad grande de conversiones en el c\u00f3digo, lo que har\u00e1 que sea m\u00e1s pesado de comprender.</li> <li>Los m\u00e9todos de las clases e interfaces de las colecciones no se adaptan al tipo de datos que contienen dificultando su uso.</li> </ul> <p>Por ello aparecieron los tipos gen\u00e9ricos en la versi\u00f3n 1.5 de Java consiguiendo solucionar los problemas anteriores en las colecciones.</p>"},{"location":"bloque_ii/tema_10/page-1/#2-idea-general-de-los-genericos","title":"2. Idea general de los gen\u00e9ricos","text":"<p>Los gen\u00e9ricos permiten crear clases y m\u00e9todos en los que los tipos de datos (las clases) sobre los que act\u00faan son un par\u00e1metro m\u00e1s. Gracias a ello se pueden crear clases y m\u00e9todos que se adaptan a distintos tipos de datos de forma autom\u00e1tica.</p> <p>Anteriormente a la aparici\u00f3n de los gen\u00e9ricos el que las clases y m\u00e9todos se adaptaran autom\u00e1ticamente pasaba por especificar par\u00e1metros de tipo Object, ya que las referencias de tipo Object valen para cualquier otro tipo de objeto.</p> <p>El problema es que la coherencia no est\u00e1 asegurada con los tipos Object, la sintaxis del lenguaje puede provocar excepciones de tipo ClassCastException ante conversiones err\u00f3neas de Object a otro tipo de datos.</p> <p>La idea es:</p> <ol> <li>El programar declara un gen\u00e9rico en un m\u00e9todo de clase, por ejemplo T</li> <li>Cuando se utilice dicha clase o m\u00e9todo se indicar\u00e1 un tipo concreto, entonces se cambia el gen\u00e9rico para que se refiera a ese tipo concreto.</li> </ol>"},{"location":"bloque_ii/tema_10/page-2/","title":"10.2 Uso de gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-2/#1-genericos-en-metodos","title":"1. Gen\u00e9ricos en m\u00e9todos","text":"<p>Se pueden indicar gen\u00e9ricos en los m\u00e9todos. Para indicar que el m\u00e9todo se puede utilizar con cualquier tipo de objeto y que el m\u00e9todo se adaptar\u00e1 a dicho tipo. La sintaxis es: <code>modificadores &lt;Gen\u00e9rico&gt; tipoRetorno nombreM\u00e9todo(...)</code></p> <p>Ejemplo:</p> <pre><code>public class ArrayUtils{\npublic static &lt;T&gt; T getRandom(T a[]){\nint i = new Random().nexInt(a.length-1);\nreturn a[i];\n}\n}\n</code></pre> <p>En el ejemplo anterior, se desea obtener un elemento aleatorio de un array. En el ejemplo la letra T entre los signos &lt; y &gt; indica que se va a utilizar un tipo gen\u00e9rico, el hecho de que le siga otra T significa que el tipo que devuelve el m\u00e9todo tomarAleatorio ser\u00e1 el mismo que el del par\u00e1metro a, y se corresponder\u00e1 al tipo gen\u00e9rico T. Despu\u00e9s cuando se invoque a este m\u00e9todo, la letra gen\u00e9rica T ser\u00e1 traducida por el tipo con el que se invoque al m\u00e9todo. Por ejemplo desde este c\u00f3digo:</p> <pre><code>String a[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString element = ArraysUtils.getRandom(a);\nSystem.out.println(element);\n</code></pre> <p>En ese c\u00f3digo, como se invoca usando un array de Strings, por lo tanto la letra gen\u00e9rica T ser\u00e1 traducida por String. Es decir es como si el c\u00f3digo anterior se tradujera como:</p> <pre><code>public class UtilesArrays {\npublic static String tomarAleatorio(String a[]){\nint i=(int)(Math.random()*a.length);\nreturn a[i];\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#2-genericos-en-las-clases","title":"2. Gen\u00e9ricos en las clases","text":"<p>El m\u00e9todo habitual de utilizar gen\u00e9ricos, debido a su mayor potencia, es declarar el gen\u00e9rico en una clase. De esta forma indicados que el c\u00f3digo de la clase utiliza tipos gen\u00e9ricos que ser\u00e1n traducidos por el tipo de datos que se desee.</p> <p>Por ejemplo una clase pensada para extraer elementos aleatorios de un array del tipo que sea se podr\u00eda declarar as\u00ed:</p> <pre><code>public class RandomElement&lt;T&gt;{\nprivate T element;\npublic RandomElement(T array[]){\nelement = array[new Random(array.length)];\n}\npublic T getElement(){\nreturn element;\n}\n}\n</code></pre> <p>Los tipos se indican tras el nombre de la clase. De esta forma cuando se creen objetos de clase RandomElement habr\u00e1 que indicar la clase por la que se traducir\u00e1 el gen\u00e9rico T. Por ejemplo:</p> <pre><code>public static void main(String[] args){\nString a[] = {\"uno\", \"dos\", \"tres\", \"cuatro\"};\nRandomElement&lt;String&gt; e = new RandomElement&lt;String&gt;(a);\nSystem.out.println(a.getElement());\n}\n</code></pre> <p>Obs\u00e9rvese que tanto al declarar el objeto e hay que concretar el valor del gen\u00e9rico de ah\u00ed que la declaraci\u00f3n sea <code>RandomElement&lt;String&gt; e</code> de ese modo ya queda claro la traducci\u00f3n de <code>T</code>. A partir de ese momento ya todos los m\u00e9todos de clase y propiedades que utilizaran el gen\u00e9rico <code>T</code>, ahora utilizar\u00e1n el tipo <code>String</code>. En definitiva los gen\u00e9ricos de clase marcan las posiciones para la clase concreta que habr\u00e1 que especificar en la creaci\u00f3n del objeto. Lo bueno es que pueden convivir distintas concreciones de gen\u00e9ricos, podr\u00eda ser:</p> <pre><code>RandomElement&lt;String&gt; e1 = new RandomElement&lt;String&gt;(a1);\nRandomElement&lt;Integer&gt; e2 = new RandomElement&lt;Integer&gt;(a2);\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#3-interfaces-con-genericos","title":"3. Interfaces con gen\u00e9ricos","text":"<p>Al igual que las clases, las interfaces pueden utilizar gen\u00e9ricos en las mismas condiciones que en \u00e9stas:</p> <pre><code>public interface Comparable&lt;T&gt;{\nT lower();\nT upper();\n}\n</code></pre> <p>Una clase que implemente la interfaz puede hacerlo as\u00ed:</p> <pre><code>public class Clase1 implements Compar&lt;String&gt;{\n</code></pre> <p>De modo que traduce el gen\u00e9rico de la interfaz por un tipo concreto o bien:</p> <pre><code>public class Clase1 &lt;T&gt; implements Compar&lt;T&gt;{\n</code></pre> <p>De modo que no traduce el gen\u00e9rico y espera a que durante la creaci\u00f3n de objetos de esa clase se indique el tipo concreto para el gen\u00e9rico.</p>"},{"location":"bloque_ii/tema_10/page-2/#4-uso-de-varios-genericos","title":"4. Uso de varios gen\u00e9ricos","text":"<p>Tanto en m\u00e9todos, como en clases o interfaces, es posible utilizar dos tipos gen\u00e9ricos e incluso m\u00e1s. Para ello se separan por comas dentro del operador diamante. Ejemplo:</p> <pre><code>public class CompareObjects&lt;T, U&gt;{\nprotected T object1;\nprotected U object2;\npublic CompareObjects(T object1, U object2){\nthis.object1 = object1;\nthis.object2 = object2;\n}\npublic boolean sameFirstLetter(){\nString letter1 = object1.getClass().getName().substring(1,1);\nString letter2 = object2.getClass().getName().substring(1,1);\nreturn letter1.equalsIgnoreCase(letter2);\n}\n}\n</code></pre> <p>Esta clase (que en realidad no es muy \u00fatil), construye un objeto a partir de otros dos. El primero de tipo gen\u00e9rico <code>T</code>, y el segundo de tipo <code>U</code>. El m\u00e9todo <code>sameFirstLetter</code> devuelve verdadero si el nombre de clase de <code>T</code> empieza por la misma letra que <code>U</code>.</p> <p>Para utilizar esta clase:</p> <pre><code>public static void main(String[] args){\nString s1 = \"Hola\";\nStringBuffer s2 = new StringBuffer(\"Adi\u00f3s\");\nCompareObjects&lt;String, StringBuffer&gt; comp = new CompareObjects&lt;String, StringBuffer&gt;(s1,s2);\nSystem.out.println(comp.sameFirstLetter());\n}\n</code></pre> <p>Devolver\u00e1 verdadero porque tanto <code>String</code> como <code>StringBuffer</code> empiezan por <code>S</code>. En el ejemplo <code>T</code> se convertir\u00e1 en String y <code>U</code> en <code>StringBuffer</code>.</p>"},{"location":"bloque_ii/tema_10/page-3/","title":"10.3 Gen\u00e9ricos avanzados","text":""},{"location":"bloque_ii/tema_10/page-3/#limitacion-de-los-tipos-posibles-en-un-generico","title":"Limitaci\u00f3n de los tipos posibles en un gen\u00e9rico","text":"<p>A veces no interesa que las clases acepten a cualquier tipo de objeto, sino a objetos de un determinado tipo y sus descendientes. Eso es posible indicarlo mediante la palabra <code>extends</code> dentro de la declaraci\u00f3n del gen\u00e9rico. Ejemplo:</p> <pre><code>public class HandlerVehicles &lt;V extends Vehicles&gt;{\nprotected V vehicle;\npublic HandlerVehicles(V vehicle){\nthis.vehicle = vehicle;\n}\npublic void start(){\nvehicle.start();\n}\n}\n</code></pre> <p>En el ejemplo, a la clase se le puede indicar cualquier clase descendiente de <code>Vehicle</code>, pero ninguna otra. Por ejemplo:</p> <pre><code>HandlerVehicle&lt;Car&gt; v1 = new HandlerVehicle&lt;Car&gt;();\nHandlerVehicle&lt;Autocar&gt; v2 = new HandlerVehicle&lt;Autocar&gt;\n</code></pre> <p>Sin embargo, no se podr\u00eda declarar:</p> <pre><code>HandlerVehicle&lt;String&gt; v3 = HandlerVehicle&lt;String&gt;(e);\n</code></pre> <p>No es posible porque la clase String no es heredera de ning\u00fan veh\u00edculo. La raz\u00f3n de utilizar esta cl\u00e1usula tan restrictiva est\u00e1 en el hecho de poder realizar acciones que sabemos que s\u00f3lo son posibles en cierto tipo de objetos. La clase <code>HandlerVehicle</code> necesita arrancar el veh\u00edculo, por ello tenemos que asegurar que el gen\u00e9rico no puede ser ninguna clase incompatible.</p> <p>Por otro lado extends no tiene por qu\u00e9 referirse a clases, tambi\u00e9n puede referirse a interfaces. Ejemplo:</p> <pre><code>public class Clase1 &lt;V extends Comparable&gt;{\n</code></pre> <p>Significa que la Clase1 usa un gen\u00e9rico al que se le puede asignar cualquier clase que implemente la interfaz Comparable.</p>"},{"location":"bloque_ii/tema_10/page-3/#tipos-comodin","title":"Tipos comod\u00edn","text":"<p>Aunque parece que todo est\u00e1 resuelto de esta forma. Hay problemas cuando mezclamos objetos de la misma clase pero distinta traducci\u00f3n de gen\u00e9rico. Es el caso de este ejemplo:</p> <pre><code>public class RandomElement&lt;T&gt;{\nprivate T element;\nprivate int index;\npublic RandomElement(T array[]){\nindex = new Random().nextInt(array.length);\nelement = array[index];\n}\npublic T getElement(){\nreturn element;\n}\npublic int getIndex(){\nreturn index;\n}\npublic boolean sameIndex(RandomElement&lt;T&gt; random){\nreturn random.index = index;\n}\n}\n</code></pre> <p>En este caso la clase RandomElement se le ha a\u00f1adido una propiedad que almacena el \u00edndice aleatorio que obtiene el constructor. Eso permite que construyamos un m\u00e9todo llamado <code>sameIndex</code> que recibe un objeto de clase RandomElement y nos dice si el \u00edndice aleatorio calculado fue el mismo. Para usar este m\u00e9todo:</p> <pre><code>String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString[] s2 = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"};\nRandomElement&lt;String&gt; r1 = new RandomElement&lt;String&gt;(s1);\nRandomElement&lt;String&gt; r2 = new RandomElement&lt;String&gt;(s2);\nSystem.out.println(r1.sameIndex(r2));\n</code></pre> <p>El c\u00f3digo funciona, s\u00f3lo devolver\u00e1 verdadero si tanto el objeto <code>r1</code> como en <code>r2</code>, el \u00edndice tiene el mismo valor. Sin embargo, este otro c\u00f3digo fallara:</p> <p>```java hl_lines= 6 String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}; Integer[] s2 = {1,2,3,4,5,6}; RandomElement r1 = new RandomElement(s1); RandomElement r2 = new RandomElement(s2); <p>System.out.println(r1.sameIndex(r2)); <pre><code>El error ocurre en tiempo de compilaci\u00f3n. La raz\u00f3n, que en la l\u00ednea remarcada, el objeto `r1` es ya de tipo `RandomElement&lt;String&gt;` por lo que el m\u00e9todo `sameIndex` s\u00f3lo puede aceptar objetos de tipo `RandomElement&lt;String&gt;`, ya que el gen\u00e9rico T se tradujo como STring. El problema est\u00e1 en que dicho m\u00e9todo tiene que poder aceptar cualquier tipo de objeto de tipo `RandomElement`.\n\nPara ello se usa el signo `&lt;?&gt;` de ese modo indicamos la posibilidad de aceptar cualquier tipo de clase con gen\u00e9rico. Es decir el m\u00e9todo se reescribir\u00eda as\u00ed:\n\n```java\npublic boolean sameIndex(RandomElement&lt;?&gt; random){\n    return random.getIndex() == index;\n}\n</code></pre></p> <p>De esa forma se indica que random es un objeto de tipo <code>RandomElement</code> tenga el tipo que tenga el gen\u00e9rico.</p> <p>Incluso se puede delimitar el gen\u00e9ricos:</p> <pre><code>public boolean sameIndex(RandomElement&lt;? extends Number&gt; random){\nreturn random.getIndex() == index;\n}\n</code></pre> <p>Ahora el m\u00e9todo acepta cualquier tipo de <code>RandomElement</code> pero siempre y cuando el tipo gen\u00e9rico forme parte de la herencia <code>Number</code></p>"},{"location":"bloque_iii/tema_11/page-1/","title":"1 Introducci\u00f3n a las colecciones","text":""},{"location":"bloque_iii/tema_11/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Una colecci\u00f3n representa un grupo de objetos. Estos objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almac\u00e9n donde poder guardarlos.</p> <p>Las colecciones son estructuras de datos con la peculiaridad de que son estructuras din\u00e1micas. Eso quiere decir que pueden aumentar o disminuir su tama\u00f1o dependiendo de los elementos que almacenan, lo que suponen una mejora respecto a las estructuras de datos est\u00e1ticas cuyo tama\u00f1o se define en su creaci\u00f3n y no se puede alterar en tiempo de ejecuci\u00f3n, como por ejemplo, los arrays.</p> <p>El API de Java nos proporciona en el paquete <code>java.util</code> el framework de las colecciones, que nos permite utilizar diferentes estructuras de datos para almacenar y recuperar objetos de cualquier clase. Java tiene desde la versi\u00f3n 2 todo un juego de clases e interfaces para guardar colecciones de objetos donde todas las entidades conceptuales est\u00e1n representadas por interfaces y las clases se usan para proveer implementaciones de esas interfaces. Estas clases e interfaces est\u00e1n estructuradas en una jerarqu\u00eda.</p> <p>Pero \u00bfqu\u00e9 podemos almacenar dentro de una colecci\u00f3n? Podemos almacenar cualquier objeto que herede de la clase <code>Object</code>. Pero esto presenta ciertos inconvenientes:</p> <ul> <li>Podr\u00edamos tener una colecci\u00f3n con objetos completamente distintos, lo que puede dar lugar a problemas ya que en todo momento deber\u00edamos saber qu\u00e9 tipo de objeto y qu\u00e9 posici\u00f3n de la colecci\u00f3n se encuentra el elementos con el que queremos trabajar, de otro modo podr\u00edamos tener incongruencias en el c\u00f3digo e incluso hacer saltar una excepci\u00f3n.</li> <li>Otro inconveniente es que tendr\u00edamos que hacer continuos castings para poder trabajar con los elementos de la colecci\u00f3n, lo cual resulta tedioso y poco productivo.</li> </ul> <p>Veamos un ejemplo para obtener la suma de los valores almacenados en una lista:</p> <pre><code>int total = 0;\nArrayList numbers = new ArrayList(); // Creaci\u00f3n de la lista\nnumbers.add(1); // Se a\u00f1ade el elemento 1 a la lista utilizando el m\u00e9todo add\nnumbers.add(2);\nnumbers.add(3);\nfor(int i = 0; i &lt; numbers.size(); i++){\n// No vemos obligados a hacer cast, dado que numbers.get(i) retorna un Object:\ntotal += (int) numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>Como vemos en el ejemplo anterior, nos vemos obligados a hacer expl\u00edcitamente un cast cuando obtenemos un elemento de la lista, dado que la lista internamente trabaja con elementos de la clase <code>Object</code>. No hay ning\u00fan contrato que permita a la clase <code>ArrayList</code> saber qu\u00e9 tipo de datos queremos que trabaje.</p> <p>Adem\u00e1s, es posible a\u00f1adir elementos de distinto tipo a la lista, con el agravante de que m\u00e1s adelante cuando se intenta acceder al elemento y se hace cast sobre \u00e9l se producir\u00e1 un error en tiempo de ejecuci\u00f3n. As\u00ed, si modificamos el ejemplo anterior de la siguiente manera:</p> <pre><code>int total = 0;\nArrayList numbers = new ArrayList(); numbers.add(1);\nnumbers.add(2);\nnumbers.add(\"Antonio\");\nfor(int i = 0; i &lt; numbers.size(); i++){\n// Esta l\u00ednea lanza una excepci\u00f3n cuando\n// se trata de convertir a entero el elemento \"Antonio\",\ntotal += (int) numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>As\u00ed pues, para resolver este problema, a partir de la versi\u00f3n 5 de Java empezaron a utilizar los gen\u00e9ricos. Los gen\u00e9ricos nos permiten establecer un tipo con el que vamos a trabajar en esa colecci\u00f3n, de esa manera podemos evitar los problemas mencionados anteriormente.</p> <p>As\u00ed el ejemplo anterior podr\u00edamos modificarlo de la siguiente manera:</p> <pre><code>int total = 0;\nArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); numbers.add(1);\nnumbers.add(2);\n//Esta l\u00ednea da un error de compilaci\u00f3n, dado que el compilador\n// detecta que estamos intentado a\u00f1adir una cadena a la lista de enteros:\nnumbers.add(\"Antonio\");\nfor(int i = 0; i &lt; numbers.size(); i++){\n// Ya no es necesario hacer un cast expl\u00edcito, dado que el compilador\n// lo har\u00e1 internamente por nosotros, al haberle informado de que quer\u00edamos\n// trabajar con una lista de enteros\ntotal += numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>Como vemos en el ejemplo anterior, gracias a la informaci\u00f3n que le suministramos al compilador sobre el tipo de lista con el que queremos trabajar, en este caso <code>Integer</code>, el compilador es capaz de detectar en tiempo de compilaci\u00f3n que no deber\u00eda ser posible a\u00f1adir una cadena a la lista, y adem\u00e1s nos evita tener que hacer expl\u00edcitamente el cast a entero cuando obtenemos los elementos de la lista, porque ya lo puede hacer \u00e9l internamente por nosotros.</p> <p>Lo que se use en un gen\u00e9rico debe ser un objeto, por lo tanto, los gen\u00e9ricos no funcionan con datos primitivos. Para resolver esta situaci\u00f3n, la API de Java incorpora las clases envoltorio (wrapper class) que no son m\u00e1s que dotar a los datos primitivos con un envoltorio que permita tratarlos como objetos. Las clases envoltorios proporcionan m\u00e9todos de utilidad para la manipulaci\u00f3n de datos primitivos (conversiones de / hacia datos primitivos, conversiones a String, etc).</p>"},{"location":"bloque_iii/tema_11/page-2/","title":"2 ArrayList","text":""},{"location":"bloque_iii/tema_11/page-2/#interfaz-collection","title":"Interfaz Collection","text":"<p>Es la interfaz ra\u00edz de la jerarqu\u00eda de las colecciones. Java no proporciona ninguna implementaci\u00f3n directa de esta interfaz, sino que proporciona implementaciones de sub-interfaces m\u00e1s espec\u00edficas como Set y List. Esta interfaz se utiliza normalmente para pasar colecciones y manipularlas cuando se desea la m\u00e1xima generalidad.</p> <p>Veamos algunos de los m\u00e9todos que podemos observar en la API</p> <ul> <li><code>boolean add(E e)</code>: a\u00f1ade el elemento e a la colecci\u00f3n.</li> <li><code>boolean addAll(Collection &lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de la colecci\u00f3n c.</li> <li><code>void clear()</code>: elimina todos los elementos de la colecci\u00f3n.</li> <li><code>boolean contains(Object o)</code>: comprueba si el elemento o est\u00e1 en la colecci\u00f3n.</li> <li>boolean containsAll(Collection&lt;?&gt; c) : comprueba si todos los elementos de c est\u00e1n en la colecci\u00f3n.</li> <li><code>boolean isEmpty()</code>: comprueba si la colecci\u00f3n est\u00e1 vac\u00eda.</li> <li><code>boolean remove(Object o)</code>: elimina de la colecci\u00f3n el elemento o.</li> <li><code>boolean removeAll(Collection&lt;?&gt; c)</code>: elimina de la colecci\u00f3n todos los elementos de c.</li> <li><code>boolean retainAll(Collection&lt;?&gt; c)</code>: elimina de la colecci\u00f3n todos los elementos exceptos los que est\u00e1n en c, es decir, obtiene la intersecci\u00f3n.</li> <li><code>int size()</code>: devuelve el tama\u00f1o de la colecci\u00f3n.</li> </ul>"},{"location":"bloque_iii/tema_11/page-2/#interfaz-list","title":"Interfaz List","text":"<p>Esta interfaz es una sub-interfaz o interfaz hija de Collection, por lo tanto, tiene todos los m\u00e9todos de Collection y adem\u00e1s a\u00f1ade los suyos propios.</p> <p>Este tipo de colecci\u00f3n se refiere a listas en las que los elementos de la colecci\u00f3n tienen un orden, es decir, existe una secuencia de elementos. Cada elemento tiene un \u00edndice o posici\u00f3n. El primer elemento ocupa la posici\u00f3n 0. La interfaz List s\u00ed admite elementos duplicados.</p> <p>Veamos algunos de los m\u00e9todos que podemos observar en la API:</p> <ul> <li><code>void add(int index, E element)</code>: inserta el elemento E en la posici\u00f3n index.</li> <li><code>boolean add(E e)</code>: a\u00f1ade el elemento e al final de la lista.</li> <li><code>boolean addAll(int index, Collection &lt;? extends E&gt; c)</code>: inserta todos los elementos de c en la posici\u00f3n index.</li> <li><code>boolean addAll(Collection &lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de c al final de la lista.</li> <li><code>E get(int index)</code>: devuelve el elemento de la posici\u00f3n index.</li> <li><code>int indexOf(Object o)</code>: devuelve el \u00edndice de la primera ocurrencia del elemento o en la lista, o -1 si la lista no contiene el elemento.</li> <li><code>int lastIndexOf(Object o)</code>: devuelve el \u00edndice de la \u00faltima ocurrencia del elemento o en la lista, o -1 si la lista no contiene el elemento.</li> <li><code>E remove(int index)</code>: elimina el elemento que se encuentra en la posici\u00f3n index. E set(int index, E element): reemplaza el elemento que se encuentra en index por el elemento element.</li> <li><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code>: devuelve la sub-lista comprendida entre las posiciones fromIndex incluida y toIndex excluida.</li> </ul> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java para la interfaz List, como por ejemplo, ArrayList.</p>"},{"location":"bloque_iii/tema_11/page-2/#la-clase-arraylist","title":"La clase ArrayList","text":"<p>Se basa en un array redimensionable que aumenta su tama\u00f1o seg\u00fan crece la colecci\u00f3n de elementos. Lo bueno es que el tiempo de acceso a un elemento en particular es \u00ednfimo. Lo malo es que si queremos eliminar un elemento del principio o del medio, la clase debe mover todos los que le siguen a la posici\u00f3n anterior, para tapar el agujero que deja el elemento removido. Esto hace que sacar elementos del medio o del principio sea costoso.</p> <p>ArrayList mantiene el orden de inserci\u00f3n, es decir, si recorremos la colecci\u00f3n se nos mostrar\u00e1 en el mismo orden en que insertamos los objetos.</p> <p>Veamos un ejemplo de declaraci\u00f3n e inicializaci\u00f3n:</p> <pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n</code></pre> <p>A partir de java7, no es necesario indicar el gen\u00e9rico en la inicializaci\u00f3n:</p> <pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n</code></pre> <p>Para hacer el c\u00f3digo m\u00e1s gen\u00e9rico, se puede definir la variable de tipo interfaz, ya que dicho c\u00f3digo podr\u00eda funcionar con cualquier clase que implemente la interfaz, simplemente habr\u00eda que cambiar el new:</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n</code></pre> <p>Veamos un ejemplo de ArrayList donde utiliza m\u00e9todos tanto de Collection como de List:</p> C\u00f3digoSalida <pre><code>import java.util.ArrayList;\nimport java.util.List;\npublic class ShowArrayList{\npublic void show(){\nList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\nList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\nList&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();\nlist1.add(1);\nlist1.add(2);//Se a\u00f1aden los elementos al final de la lista\nlist1.add(6);\nlist1.add(2, 5);//Se a\u00f1ade el 5 en la posici\u00f3n 2\nfor (Integer i : list1) {//Recorremos la lista con un bucle for-each: 1 2 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist2.add(3);\nlist2.add(4);\nlist1.addAll(2, list2);//Se inserta list2 en la posici\u00f3n 2 de list1\nfor (Integer i : list1) {// 1 2 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist3.add(7);\nlist3.add(8);\nlist1.addAll(list3);//Se inserta list3 al final de list1\nfor (Integer i : list1) {// 1 2 3 4 5 6 7 8\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl elemento 3 de list1 es: %d\", list1.get(3));//4\nSystem.out.printf(\"\\nLa posici\u00f3n del 4 en list1 es: %d\", list1.indexOf(4));//3\nlist1.add(4);//Se a\u00f1ade un 4 al final de list1\nSystem.out.printf(\"\\nLa posici\u00f3n del 4 en list1 por el final es: %d\\n\", list1.lastIndexOf(4));//8\nlist1.remove(8);//Se elimina el elemento de la posici\u00f3n 8, que es el \u00faltimo 4 insertado\nfor (Integer i : list1) {// 1 2 3 4 5 6 7 8\nSystem.out.printf(\" %d \", i);\n}\nlist1.set(6, 8);//Se reemplaza el elemento que se encuentra en la posici\u00f3n 6 por un 8\nSystem.out.println();\nfor (Integer i : list1) {// 1 2 3 4 5 6 8 8\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nLa sub-lista comprendida entre las posiciones 2 y 5 es: \");\nfor (Integer i : list1.subList(2, 6)) {// 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl 4 %s se encuentra en list1\", list1.contains(4) ? \"s\u00ed\" : \"no\");//s\u00ed\nSystem.out.printf(\"\\nEl 9 %s se encuentra en list1\", list1.contains(9) ? \"s\u00ed\" : \"no\");//no\n//list1: 1 2 3 4 5 6 8 8\n//list2: 3 4\n//list3: 7 8\nSystem.out.printf(\"\\nTodos los elementos de list2 %s se encuentran en list1\", list1.containsAll(list2) ? \"s\u00ed\" : \"no\");//s\u00ed\nSystem.out.printf(\"\\nTodos los elementos de list3 %s se encuentran en list1\\n\",\nlist1.containsAll(list3) ? \"s\u00ed\" : \"no\");//no\nlist1.removeAll(list3);//Se eliminan de list1 todos los elementos de list3, es decir, el 8\nfor (Integer i : list1) {// 1 2 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist1.retainAll(list2);//Intersecci\u00f3n entre list1 y list2\nfor (Integer i : list1) {// 3 4\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl tama\u00f1o de list1 es: %d\", list1.size());//2\nSystem.out.printf(\"\\nlist1 %s est\u00e1 vac\u00eda\", list1.isEmpty() ? \"s\u00ed\" : \"no\");//no\nlist1.clear();//Elimina todos los elementos de list1\nSystem.out.printf(\"\\nlist1 %s est\u00e1 vac\u00eda\", list1.isEmpty() ? \"s\u00ed\" : \"no\");//s\u00ed\n}\npublic static void main(String[] args) {\nnew ShowArrayList().show();\n}\n}\n</code></pre> <pre><code>1 2 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6 7 8\nEl elemento 3 de list1 es: 4\nLa posici\u00f3n del 4 en list1 es: 3\nLa posici\u00f3n del 4 en list1 por el final es: 8\n1 2 3 4 5 6 7 8\n1 2 3 4 5 6 8 8\nLa sub-lista comprendida entre las posiciones 2 y 5 es: 3 4 5 6\nEl 4 s\u00ed se encuentra en list1\nEl 9 no se encuentra en list1\nTodos los elementos de list2 s\u00ed se encuentran en list1\nTodos los elementos de list3 no se encuentran en list1\n1 2 3 4 5 6\n3 4\nEl tama\u00f1o de list1 es: 2\nlist1 no est\u00e1 vac\u00eda\nlist1 s\u00ed est\u00e1 vac\u00eda\n</code></pre>"},{"location":"bloque_iii/tema_11/page-2/#iteradores","title":"Iteradores","text":"<p>En dise\u00f1o de software, el patr\u00f3n de dise\u00f1o Iterador (en ingl\u00e9s, Iterator) define una interfaz que declara los m\u00e9todos necesarios para acceder secuencialmente a un grupo de objetos de una colecci\u00f3n.</p> <p>Este patr\u00f3n debe ser utilizado cuando se requiera una forma est\u00e1ndar de recorrer una colecci\u00f3n, es decir, cuando no sea necesario que un cliente sepa el tipo de colecci\u00f3n que est\u00e1 recorriendo.</p> <p>La interfaz <code>Iterable&lt;T&gt;</code> contiene el m\u00e9todo iterator() que devuelve una instancia de alguno clase que implemente la interfaz <code>Iterator&lt;T&gt;</code>:</p> <ul> <li><code>Iterator&lt;T&gt; iterator()</code>: devuelve un iterador al comienzo de la colecci\u00f3n.</li> </ul> <p>La interfaz <code>Iterator&lt;E&gt;</code> permite el acceso secuencial a los elementos de una colecci\u00f3n y realizar recorridos sobre la colecci\u00f3n. Los m\u00e9todos de <code>Iterator&lt;E&gt;</code> son:</p> <ul> <li><code>boolean hasNext()</code>: comprueba si hay siguiente elemento.</li> <li><code>E next()</code>: devuelve el siguiente elemento y mueve el iterador.</li> <li><code>void remove()</code>: se invoca despu\u00e9s de next() para eliminar el \u00faltimo elemento le\u00eddo.</li> </ul> <p>La interfaz <code>Collection&lt;E&gt;</code> es una sub-interfaz o interfaz hija de <code>Iterable&lt;E&gt;</code>, as\u00ed que dispone del m\u00e9todo <code>iterator()</code>. Veamos un ejemplo de un <code>ArrayList&lt;E&gt;</code>utilizando iteradores:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class ShowIterator{\npublic void show(){\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile(it.hashNext()){\nSystem.out.println(it.next());\n}\n}\npublic static void main(String[] args){\nnew ShowIterator().show();\n}\n}\n</code></pre> <pre><code>Juan\nAntonio\nJaime\nVicente\n</code></pre> <p>Si no hay siguiente, <code>next()</code> lanza una excepci\u00f3n <code>NoSuchElementException</code>:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class NextException {\npublic void show() {\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nit = list.iterator();\nSystem.out.println(it.next());\nSystem.out.println(it.next());//(1)!\n}\npublic static void main(String[] args) {\nnew NextException().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n una excepci\u00f3n <code>NoSuchElementException</code></li> </ol> <p>Tal y como vemos en el ejemplo anterior, hay que comprobar si hay siguiente con un <code>hashNext()</code> para que el <code>next()</code> no lance la excepci\u00f3n.</p> <p>No se puede modificar la colecci\u00f3n dentro del bucle for-each porque se lanza en ejecuci\u00f3n la excepci\u00f3n <code>ConcurrentModificationException</code>, ya que estamos recorriendo y modificando la lista a la vez:</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\npublic class ModifyInsideForEach {\npublic void show() {\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nfor (String s : list) {//(1)!\nSystem.out.printf(\" %s \", s);\nif (s.equals(\"Antonio\")) {\nlist.remove(\"Antonio\");\n}\n}\n}\npublic static void main(String[] args) {\nnew ModifyInsideForEach().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n la excepci\u00f3n <code>ConcurrentModificationException</code></li> </ol> <p>Para solucionarlo, podemos utilizar el m\u00e9todo <code>remove()</code>de <code>Iterator&lt;E&gt;</code>. Si se modifica una colecci\u00f3n mientras se recorre, los iteradores quedan invalidados, a excepci\u00f3n del m\u00e9todo <code>remove()</code> de la interfaz <code>Iterator&lt;E&gt;</code>. El m\u00e9todo <code>remove()</code> permite eliminar elementos de la colecci\u00f3n siendo la \u00fanica forma adecuada para eliminar elementos durante la iteraci\u00f3n:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveIterator {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveIterator().show();\n}\n}\n</code></pre> <pre><code>Juan\nJaime\nVicente\n</code></pre> <p>Solo puede haber una invocaci\u00f3n a <code>remove()</code> por cada invocaci\u00f3n <code>next()</code>. Si no cumple, se lanza en ejecuci\u00f3n una excepci\u00f3n <code>IllegalStateException</code>. Por ejemplo, imaginemos que tenemos una lista de personas y queremos eliminar a Antonio y a la persona que venga detr\u00e1s. Si cuando encontramos a Antonio, hacemos dos <code>remove()</code> seguidos, entonces salta la excepci\u00f3n:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveNext1 {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\nit.remove();//(1)!\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveNext1().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n la excepci\u00f3n <code>IllegalStateException</code></li> </ol> <p>Tendr\u00edamos que hacer otro <code>next()</code> para el que venga detr\u00e1s de Antonio:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveNext2 {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\nit.next();\nit.remove();\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveNext2().show();\n}\n}\n</code></pre> <pre><code>Juan\nVicente\n</code></pre> <p>La interfaz <code>ListIterator&lt;E&gt;</code> es una subinterfaz o interfaz hija de <code>Iterator&lt;E&gt;</code>. Es un iterador para listas que permite al programador recorrer la lista hacia delante y hacia atr\u00e1s, modificar la lista durante la iteraci\u00f3n y obtener la posici\u00f3n actual del iterador en la lista.</p> <p>Hereda los m\u00e9todos de <code>Iterador&lt;E&gt;</code> y adem\u00e1s aporta otros m\u00e9todos nuevos:</p> <ul> <li><code>void add(E e)</code>: inserta el elemento en la lista antes del elemento que ser\u00eda devuelto por next(), si lo hubiera, y despu\u00e9s del elemento que ser\u00eda devuelto por previous(), si lo hubiera. Una llamada posterior a next() no se ver\u00eda afectada y una llamada posterior a previous() devolver\u00eda el nuevo elemento.</li> <li><code>boolean hasPrevious()</code>: comprueba si hay un elemento anterior.</li> <li><code>int nextIndex()</code>: devuelve el \u00edndice del elemento que ser\u00eda devuelto por una llamada a next(). El \u00edndice del primer elemento es 0.</li> <li><code>E previous()</code>: devuelve el elemento anterior de la lista y mueve la posici\u00f3n del cursor hacia atr\u00e1s.</li> <li><code>int previousIndex()</code>: devuelve el \u00edndice del elemento que ser\u00eda devuelto por una llamada a previous().</li> <li><code>void set(E e)</code>: sustituye el \u00faltimo elemento devuelto por next() o previous() por elemento e.</li> </ul> <p>En la interfaz <code>List&lt;E&gt;</code>, hay dos m\u00e9todos para crear este iterador:</p> <ul> <li><code>ListIterator&lt;E&gt; listIterator()</code>: se coloca antes del primer elemento para que al hacer el primer next() se devuelva el primer elemento.</li> <li><code>ListIterator&lt;E&gt; listIterator(int index)</code>: se coloca antes del elemento que se encuentra en la posici\u00f3n index para que al hacer un next() se devuelva dicho elemento. Para recorrer la lista al rev\u00e9s, hay que crearlo con el tama\u00f1o de la lista para que el primer previous() devuelva el \u00faltimo.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\npublic class ShowListIterator {\npublic void show() {\nListIterator&lt;Integer&gt; it;\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(1);\nlist.add(2);\nlist.add(4);\nlist.add(6);\n//Recorrido de la lista hacia atr\u00e1s:\nit = list.listIterator(list.size());\nwhile (it.hasPrevious()) {\nSystem.out.printf(\" %d \", it.previous());// 6 4 2 1\n}\nit = list.listIterator(1);//Se coloca antes del elemento que se encuentra en la posici\u00f3n 1\nSystem.out.printf(\"\\n %d \", it.next());//2\nSystem.out.printf(\"\\n %d \", it.nextIndex());//2\nSystem.out.printf(\"\\n %d \", it.previousIndex());//1\nit.add(3);\nSystem.out.printf(\"\\n %d \", it.next());//4 Una llamada posterior a next() no se ve afectada\nit.add(5);\nSystem.out.printf(\"\\n %d \", it.previous());//5 Una llamada posterior a previous() devuelve el nuevo elemento\nSystem.out.printf(\"\\n %d \\n\", it.next());//5\nit.set(7);//sustituye el \u00faltimo elemento devuelto por next() por 7\nfor (Integer i : list) {\nSystem.out.printf(\" %d \", i);//1 2 3 4 7 6\n}\n}\npublic static void main(String[] args) {\nnew ShowListIterator().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/","title":"3 Conjuntos","text":""},{"location":"bloque_iii/tema_11/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Un conjunto es una lista formada por elementos que no se repiten. Para ello, la JVM usar\u00e1 los m\u00e9todos <code>equals</code> y <code>hashCode</code> heredados la clase clase Object para comprobar si dos elementos son iguales.</p> <p>Son m\u00e9todos heredados de la clase <code>Object</code>. Normalmente, hay que sobrescribirlos para adaptarlo de forma adecuada a la clase correspondiente.</p> <p>Sin embargo, debemos tener en cuenta que al sobrescribir todos estos m\u00e9todos debemos seguir cumpliendo con el comportamiento que se espera de ellos, ya que son usados internamente por muchas clases del propio lenguaje. De lo contario, las clases que dependen de ello, como <code>HashMap</code>y <code>HashSet</code> dejar\u00edan de funcionar correctamente.</p> <p>Escribir a mano los m\u00e9todos <code>equals()</code> y <code>hashCode()</code> es bastante tedioso. Para facilitarnos esta tarea tenemos librer\u00edas como la librer\u00eda AutoValue de Google que lo genera autom\u00e1ticamente para nosotros con tan s\u00f3lo usar una determinada anotaci\u00f3n. Otra opci\u00f3n es dejar que el IDE nos genere dichos m\u00e9todos, aunque esto tiene el inconveniente de que no se generan autom\u00e1ticamente de nuevo conforme a\u00f1adimos atributos a nuestro clase, por lo que debemos tener cuidado, algo que s\u00ed hace AutoValue. En todo caso, es mejor usar el IDE que hacerlo nosotros a mano, ya que el humano es m\u00e1s propenso a los errores. En el Eclipse se encuentra en <code>Men\u00fa Source \u2192 Generate hashCode() and equals()</code>.</p>"},{"location":"bloque_iii/tema_11/page-3/#metodo-equals","title":"M\u00e9todo <code>equals</code>","text":"<p>El m\u00e9todo <code>equals()</code> comprueba si dos objetos son iguales.</p> <p>En caso de que no se sobrescriba dicho m\u00e9todo, s\u00f3lo ser\u00e1 igual a s\u00ed misma, es decir, si est\u00e1 situada en la misma posici\u00f3n de memoria.</p> <p>Debemos tener en cuenta que cuando un programador usa el m\u00e9todo <code>equals()</code> sobre un objeto pas\u00e1ndole como argumento otro objeto lo que pretende es descubrir si ambos objetos son equivalentes l\u00f3gicamente(representa el mismo \"valor\"), no si est\u00e1n almacenados en la misma posici\u00f3n de memoria (tienen la misma identidad).</p> <p>No sobrescribir el m\u00e9todo <code>equals()</code> en una determinada clase es la opci\u00f3n recomendada en los siguientes casos:</p> <ul> <li>Cuando cada instancia de la clase es intr\u00ednsecamente \u00fanica, lo cual es cierto para clases como <code>Scanner</code> que representan entidades activas en lugar de valores.</li> <li>Cuando se considera que no hay necesidad de que la clase provea una prueba de equivalencia l\u00f3gica.</li> <li>Cuando una superclase de la clase ya lo ha sobrescrito y el comportamiento de la superclase es apropiado para las subclase.</li> <li>Cuando la clase es privada o friendly, y estamos completamente seguros de que su m\u00e9todo <code>equals()</code> nunca ser\u00e1 invocado, ni expl\u00edcita ni impl\u00edcitamente.</li> </ul> <p>Si nuestra clase no se encuentra en ninguno de los casos anteriores es muy recomendable que sobrescribamos el m\u00e9todo <code>equals()</code>. Un ejemplo muy caracter\u00edstico es cuando la clase corresponda a una entidad que represente un valor.</p> <p>Como hemos comentado, cuando sobrescribamos el m\u00e9todo <code>equals()</code> debemos seguir cumpliendo el comportamiento que el sistema espera de \u00e9l, que incluye las siguientes propiedades:</p> <ul> <li>Reflexiva: Para todo objeto x distinto de null se debe cumplir que <code>x.equals(x)</code> sea true.</li> <li>Sim\u00e9trica: Para todo par de objetos x e y y distintos de null se debe cumplir que <code>x.equals(y)</code> s\u00f3lo debe retornar true si <code>y.equals(x)</code> retorna true.</li> <li>Transitiva: Para todo tr\u00edo de objetos x, y, z distintos de null se debe cumplir que si <code>x.equals(y)</code> retorne true y <code>y.equals(z)</code> retorna true entonces <code>x.equals(z)</code> debe retornar true.</li> <li>Consistente: Para todo par de objetos x e y distintos de null se debe cumplir que <code>x.equals(y)</code>siempre retorne el mismo valor si no hemos cambiado los atributos que se usan para comparar en alguno de los objetos.</li> <li>Para todo objeto x distinto de null se debe cumplir que <code>x.equals(null)</code>debe retornar false.</li> </ul> <p>As\u00ed para sobrescribir el m\u00e9todo <code>equals()</code> cumpliendo con las propiedades anteriores se recomienda seguir los siguientes pasos:</p> <ol> <li>Usar el operador <code>==</code> para comprobar si el argumento corresponde a otra referencia al mismo objeto, en cuyo caso retornar true.</li> <li>Usar el operador <code>instanceof</code> para comprobar si el objeto recibido como argumento no es de la misma clase, en cuyo caso retornar false. Tambi\u00e9n nos sirve para comprobar si dichos argumento es null, ya que en este caso instanceof retornar\u00eda false.</li> <li>Hacer cast del objeto recibido como argumento convirti\u00e9ndolo a la clase correspondiente. Dado que hemos hecho antes instanceof, el cast siempre tendr\u00e1 \u00e9xito.</li> <li>Para cada atributo significativo de la clase, comprobar que dicho atributo en el objeto argumento es equivalente al atributo en el objeto this. Si no tenemos \u00e9xito en alguno de ellos, retornar false. Si todas las comprobaciones se han hecho con \u00e9xito, retornar true. Para realizar las comprobaciones de cada atributo usar:<ul> <li>El operador <code>==</code> para valores primitivos que no sean float ni double.</li> <li>Para los valores float usar <code>Float.compare(value1, value2)</code> y para valores double usar <code>Double.compare(value1, value2)</code>.</li> <li>Para valores correspondientes a objetos llamar a <code>equals()</code> recursivamente. Si es v\u00e1lido que dichos objetos contengan null, entonces debemos usar <code>Objects.equals(object1, object2)</code> para que no se produzca la excepci\u00f3n <code>NullPointerException</code>.</li> <li>Para los valores correspondientes a arrays, compara uno a uno los elementos significativos del array. Si todos los elementos son significativos, usa alguno de las versiones del m\u00e9todo est\u00e1tico <code>Arrays.equals()</code>.</li> </ul> </li> </ol> <p>Veamos un ejemplo:</p> <pre><code>public final class PhoneNumber{\nprivate final short areaCode, prefix, lineNum;\n@Override\npublic boolean equals(Object o){\nif(o == this) return true;\nif(!(o instanceof PhoneNumber)) return false;\nPhoneNumber pn = (PhoneNumber) o;\nreturn pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n}\n//...\n}\n</code></pre> <p>\u00a1CUIDADO!</p> <p>Un aspecto muy importante es que no debemos cambiar el tipo del objeto recibido como argumento, que siempre debe ser <code>Object</code>, o no estaremos sobrescribiendo el m\u00e9todo <code>equals()</code>, sino sobrecarg\u00e1ndolo, lo que puede producir falsos positivos. El compilador no se quejar\u00e1 si no usamos la anotaci\u00f3n <code>@Override</code> (por eso siempre se recomienda usarla). Por ejemplo, nunca hagas esto:</p> <pre><code>public boolean equals(MyClass o){\n//...\n}\n</code></pre> <p>Nota</p> <p>Algunas veces, para comparar que una variable de tipo String es equivalente a una determinada constante de cadena se usa la construcci\u00f3n \"Hello\".equals(message) , ya que dicho construcci\u00f3n no puede lanzar NullPointerException si message es null, sino que tan s\u00f3lo retornar\u00e1 false, mientras que message.equals(\"Hello\") lanzar\u00eda NullPointerException en ese caso.</p>"},{"location":"bloque_iii/tema_11/page-3/#metodo-hashcode","title":"M\u00e9todo <code>hashCode</code>","text":"<p>El m\u00e9todo <code>hashCode()</code> devuelve un n\u00famero entero que identifica al objeto cuando se guarda en algunas estructuras de datos.</p> <p>Un detalla muy importante que no debemos olvidar es que **si en una clase sobrescribimos el m\u00e9todo <code>equals()</code> debemos obligatoriamente sobrescribir tambi\u00e9n el m\u00e9todo <code>hashCode()</code> o de lo contrario no se estar\u00e1 cumpliendo con el comportamiento esperado de este \u00faltimo, lo que impedir\u00e1 que los objetos de dichas clase funcionen correctamente en colecciones como <code>HashMap</code> y <code>HashSet</code>.</p> <p>El comportamiento que se espera de <code>hashCode()</code> es el siguiente:</p> <ul> <li>Debe ser consistente, es decir, que repetidas llamadas al m\u00e9todo <code>hashCode()</code> deben retornar el mismo valor, siempre y cuando no se haya modificado ninguno de los atributos usados para las comparaciones.</li> <li>Si dos objetos son equivalentes, es decir, si <code>x.equals(y)</code> retorna true, entonces <code>x.hashCode()</code> e <code>y.hashCode()</code> deben retornar el mismo valor entero. \u00c9ste ees el motivo por el que siempre que sobrescribamos <code>equals()</code> debemos sobrescribir <code>hashCode()</code>, ya que la implementaci\u00f3n por defecto de <code>hashCode()</code> de la clase <code>Object</code> devuelve una representaci\u00f3n num\u00e9rica de la direcci\u00f3n de memoria en la que se encuentra ubicado el objeto.</li> <li>Si dos objetos no son equivalentes, es decir si <code>x.equals(y)</code> retorna false, no es estrictamente necesario, aunque si recomendable, que <code>x.hashCode()</code> e <code>y.hashCode()</code> retornen valores diferentes, de manera que se mejore el rendimiento de las tablas hash. Idealmente el algoritmo de la funci\u00f3n hash debe distribuir una colecci\u00f3n de instancias de un tama\u00f1o considerable de forma uniforme entre todos los valores enteros.</li> </ul> <p>La implementaci\u00f3n caracter\u00edstica al sobrescribir el m\u00e9todo <code>hashCode()</code> en la clase <code>PhoneNumber</code> es la siguiente, usando los atributos areaCode, prefix, lineNum.</p> <pre><code>public final class PhoneNumber{\nprivate final short areaCode, prefix, lineNum;\n@Override\npublic boolean equals(Object o){\nif(o == this) return true;\nif(!(o instanceof PhoneNumber)) return false;\nPhoneNumber pn = (PhoneNumber) o;\nreturn pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n}\n@Override\npublic int hashCode(){\nint result = Short.hashCode(areaCode);\nresult = 31 * result + Short.hashCode(prefix);\nresult = 31 * result + Short.hashCode(lineNum);\nreturn result;\n}\n//...\n}\n</code></pre> <p>Adem\u00e1s de escribir nosotros a mano el c\u00f3digo del m\u00e9todo <code>hashCode()</code>, podemos usar la implementaci\u00f3n proporcionada por algunas librer\u00edas, como Guava o AutoValue, o usar la implementaci\u00f3n de los IDEs.</p> <p>Por otra parte, podemos usar <code>Objects.hashCode(object...)</code> para sobrescribir el m\u00e9todo con una sola l\u00ednea. Desafortunadamente, este m\u00e9todo es bastante menos eficiente de lo esperado, debido a que recibe un array de atributos y de que realiza boxing y unboxing de los atributos que sean de un tipo primitivo. Por ejemplo:</p> <pre><code>public final class PhoneNumber{\nprivate final short areaCode, prefix, lineNum;\n@Override\npublic boolean equals(Object o){\nif(o == this) return true;\nif(!(o instanceof PhoneNumber)) return false;\nPhoneNumber pn = (PhoneNumber) o;\nreturn pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n}\n@Override\npublic int hashCode(){\nreturn Objects.hash(lineNum, prefix, areaCode);\n}\n//...\n}\n</code></pre> <p>Si una clase es inmutable y el coste de calcular el valor hash es significativo, podr\u00eda considerar almacenar cacheado el c\u00f3digo hash en el propio objecto, en lugar de recalcularlo cada vez que se solicite. Si cree que la mayor\u00eda de los objetos de esta clase se usar\u00e1n como claves hash, entonces deber\u00eda calcular el c\u00f3digo hash cuando se cree la instancia. De lo contario, podr\u00eda elegir calcular perezosamente el c\u00f3digo hash la primera vez que se invoque el m\u00e9todo <code>hash()</code>.</p> <p>Dos consideraciones finales:en primer lugar no excluya atributos significativos del c\u00e1lculo de valor hash, as\u00ed lograr\u00e1 un mejor rendimiento, al no repetir tanto los valores. En segundo lugar, no proporcione a los clientes de la clase demasiada informaci\u00f3n acerca de c\u00f3mo se calcula el valor hash de esta manera el c\u00f3digo no podr\u00e1 depender de c\u00f3mo se calcula, permiti\u00e9ndonos modificar la implementaci\u00f3n del m\u00e9todo en el futuro sin afectar a los clientes.</p>"},{"location":"bloque_iii/tema_11/page-3/#colecciones-sin-duplicados","title":"Colecciones sin duplicados","text":"<p>La interfaz <code>Set</code>, que hereda de Collection, permite implementar listas de elementos sin duplicados, es decir, modela la abstracci\u00f3n matem\u00e1tica de los conjuntos.</p> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java:</p> <ul> <li>HashSet: esta implementaci\u00f3n almacena los elementos de una tabla hash. Es la implementaci\u00f3n con mejor rendimiento de todas pero no garantiza ning\u00fan orden a la hora de realizar iteraciones.</li> <li>LinkedHashSet: est\u00e1 implementaci\u00f3n almacena los elementos en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que HashSet.</li> <li>TreeSet: est\u00e1 implementaci\u00f3n utiliza una estructura de \u00e1rbol para ordenar los elementos. Es bastante m\u00e1s lenta que HashSet.</li> </ul>"},{"location":"bloque_iii/tema_11/page-3/#clase-hashset","title":"Clase HashSet","text":"<p>Implementa la interfaz <code>Set</code>. Es la clase m\u00e1s utilizada para implementar listas sin duplicados. Esta clase permite el elemento nulo. No garantiza ning\u00fan orden a la hora de realizar iteraciones.</p> <p>Utiliza internamente una tabla de tipos hash:</p> <p> Figura 1 - Hashtable</p> <p>Al querer guardar un objeto en esta estructura, se llama al m\u00e9todo hashCode() el cual devuelve un n\u00famero entero que la estructura usar\u00e1 para decidir en qu\u00e9 caj\u00f3n debe recuperar el objeto. El objetivo de guardar los datos de esta forma y de llamar al m\u00e9todo es lograr almacenar y recuperar la informaci\u00f3n en tiempo constante (lo cual no ocurre siempre, pero se acerca). El que no suceda esto depende, casi siempre, del valor que devuelva el m\u00e9todo <code>hashCode()</code> para cada objeto.</p> <p>Supongamos que guardamos 3 objetos en esta estructura y el m\u00e9todo <code>hashCode()</code> de los 3 devuelve 0, esto quiere decir que los 3 objetos se guardar\u00e1n en el caj\u00f3n 0. Cuando se necesite recuperar un objeto, hay que recorrer los objetos del caj\u00f3n 0 para determinar cu\u00e1l es el que se quiere recuperar. Por lo tanto, este m\u00e9todo <code>hashCode()</code> no es \u00fatil ya que lo que se pretende al guardar los elementos es que \u00e9stos queden dispersos de forma uniforme en toda la estructura quedando la menor cantidad de cajones vac\u00edos y que no haya cajones donde se guarden muchos m\u00e1s elementos que en otros.</p> <p>Si dos objetos tiene el mismo <code>hashCode()</code>, ambos objetos se guardar\u00e1n en el mismo caj\u00f3n. La estructura usa entonces el m\u00e9todo <code>equals()</code> dentro de ese caj\u00f3n para determinar cu\u00e1l corresponde con el solicitado y para eso depende de que el programador haya sobrescrito el m\u00e9todo, de lo contrario no garantiza un resultado correcto.</p> <p> Figura 2 - Hash</p> <p>Los objetos HashSet se construyen con un tama\u00f1o inicial de tabla (el tama\u00f1o del array) y un factor de carga que indica cu\u00e1ndo se debe redimensionar el array. Es decir, si se cre\u00f3 un array de 100 elementos y la carga se estableci\u00f3 al 80%, cuando se hayan rellanado 80 valores, se redimensiona el array. Por defecto, el tama\u00f1o del array se toma con 16 y el factor de carga con 0,75 (75%). No obstante, se puede construir una lista HashSet indicando ambos par\u00e1metros.</p> <p>Esta implementaci\u00f3n proporciona tiempos constantes en las operaciones b\u00e1sicas siempre y cuando la funci\u00f3n hash disperse de forma correcta los elementos dentro de la tabla hash. Es importante definir el tama\u00f1o inicial de la tabla ya que este tama\u00f1o marcar\u00e1 el rendimiento de esta implementaci\u00f3n.</p> <p>Veamos un ejemplo de <code>HashSet</code> con la clase <code>Vehicle</code>. Los atributos significativos a tener en cuenta para el <code>equals()</code> y el <code>hashCode()</code> son wheelCount y colour. La velocidad (speed) no se incluye ya que si comparamos el mismo coche pero con velocidades distintas, en realidad, no deja de ser el mismo coche.</p> VehicleMainConsola <pre><code>public class Vehicle {\nprivate int wheelCount;\nprivate double speed;\nprivate String colour;\npublic Vehicle(int wheelCount, String colour) {\nthis.wheelCount = wheelCount;\nthis.colour = colour;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic String getColour() {\nreturn colour;\n}\npublic void setColour(String colour) {\nthis.colour = colour;\n}\npublic void accelerate(double amount) {\nspeed += amount;\n}\npublic void brake(double amount) {\nspeed -= amount;\n}\n@Override\npublic String toString() {\nreturn \"Vehicle [wheelCount=\" + wheelCount + \", speed=\" + speed + \",colour=\" + colour + \"]\";\n}\n@Override\npublic int hashCode() {\nfinal int prime = 31;\nint result = 1;\nresult = prime * result + ((colour == null) ? 0 : colour.hashCode());\nresult = prime * result + wheelCount;\nreturn result;\n}\n@Override\npublic boolean equals(Object obj) {\nif (this == obj)\nreturn true;\nif (obj == null)\nreturn false;\nif (!(obj instanceof Vehicle))\nreturn false;\nVehicle other = (Vehicle) obj;\nif (colour == null) {\nif (other.colour != null)\nreturn false;\n} else if (!colour.equals(other.colour))\nreturn false;\nif (wheelCount != other.wheelCount)\nreturn false;\nreturn true;\n}\n}\n</code></pre> <pre><code>import java.util.HashSet;\nimport java.util.Set;\npublic class ShowHashSet {\npublic void show() {\nSet&lt;Vehicle&gt; set = new HashSet&lt;&gt;();\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"verde\"));\nfor (Vehicle v : set) {\nSystem.out.println(v);//Se llama al toString del objeto\n}\n}\npublic static void main(String[] args) {\nnew ShowHashSet().show();\n}\n}\n</code></pre> <pre><code>Vehicle [wheelCount=4, speed=0.0, colour=verde]\nVehicle [wheelCount=4, speed=0.0, colour=azul]\nVehicle [wheelCount=2, speed=0.0, colour=rojo]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/#clase-linkedhashset","title":"Clase LinkedHashSet","text":"<p>Almacena los elementos en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que HashSet.</p> MainConsola <pre><code>import java.util.LinkedHashSet;\nimport java.util.Set;\npublic class ShowLinkedHashSet {\npublic void show() {\nSet&lt;Vehicle&gt; set = new LinkedHashSet&lt;&gt;();\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"verde\"));\nfor (Vehicle v : set) {\nSystem.out.println(v);//Se llama al toString del objeto\n}\n}\npublic static void main(String[] args) {\nnew ShowLinkedHashSet().show();\n}\n}\n</code></pre> <pre><code>Vehicle [wheelCount=4, speed=0.0, colour=azul]\nVehicle [wheelCount=2, speed=0.0, colour=rojo]\nVehicle [wheelCount=4, speed=0.0, colour=verde]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-7/","title":"Ejercicios","text":""},{"location":"bloque_iii/tema_11/page-7/#ejercicio-1","title":"Ejercicio 1","text":"<p>Utilizando la clase gen\u00e9rica caja del bolet\u00edn de gen\u00e9ricos, haz un programa que haga lo siguiente:</p> <ul> <li>Guardar en una lista 5 cajas de cadenas. Recorrer la lista y mostrar por pantalla el contenido de todas las cajas. Mostrar una concatenaci\u00f3n de todas las cadenas.</li> <li>Guardar en otra lista 5 cajas de long. Recorrer la lista y mostrar por pantalla el contenido de las cajas. Mostrar un resultado de sumarlas todas.</li> </ul>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-2","title":"Ejercicio 2","text":"<p>Realiza una interfaz gen\u00e9rica que contenga dos m\u00e9todo:     T primerContenido();     T ultimoContenido();</p> <p>Realizar una clase Almacen que contenga una lista de cajas. Dicha clase debe implementar esa interfaz. Los m\u00e9todos devolver\u00e1n el contenido de la primera caja y el contenido de la \u00faltima caja respectivamente.</p>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-3","title":"Ejercicio 3","text":"<p>Realiza el siguiente men\u00fa para gestionar una lista simplemente enlazada de cadenas:</p> <ol> <li>Nueva lista</li> <li>N\u00famero de cadenas</li> <li>A\u00f1adir cadena</li> <li>Eliminar cadena</li> <li>Contiene cadena</li> <li>Mostrar lista entera</li> <li>Salir</li> </ol> <p>En la opci\u00f3n 1, se limpiar\u00e1 toda la lista dejando la lista vac\u00eda. En la opci\u00f3n 5, se le pedir\u00e1 una cadena al usuario y se le dir\u00e1 si est\u00e1 o no en la lista.</p>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-4","title":"Ejercicio 4","text":"<p>Rellena una lista simplemente enlazada circular de n\u00fameros decimales de tipo float. A continuaci\u00f3n, presentar el siguiente men\u00fa.</p> <ol> <li>Mostrar la lista</li> <li>Mostrar siguiente</li> <li>Eliminar \u00faltimo mostrado</li> <li>Salir</li> </ol> <p>En la opci\u00f3n 2, la primera vez que se ejecute saldr\u00e1 el primero de la lista. La Siguiente vez el segundo, y as\u00ed sucesivamente. Si el \u00faltimo mostrado ha sido el \u00faltimo y se le vuelve a dar esta opci\u00f3n, entonces se mostrar\u00e1 el primero. En la opci\u00f3n 3, se elimina el \u00faltimo mostrado por la opci\u00f3n 2.</p>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-5","title":"Ejercicio 5","text":"<p>Realiza el mismo ejercicio anterior pero con una lista doblemente enlazada circular. A\u00f1\u00e1dele una opci\u00f3n nueva al men\u00fa que sea 'Mostrar anterior'.</p>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-6","title":"Ejercicio 6","text":"<p>Realiza el siguiente men\u00fa para gestionar una pila de n\u00fameros de tipo byte.</p> <ol> <li>Nueva pila</li> <li>Consultar elemento</li> <li>A\u00f1adir elemento</li> <li>Eliminar elemento</li> <li>Consultar toda la pila</li> <li>Salir</li> </ol>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-7","title":"Ejercicio 7","text":"<p>Realiza el ejercicio anterior pero con una cola.</p>"},{"location":"proyects/cinema/proyecto_v1/","title":"Proyecto V1","text":"<p>Se quiere realizar una aplicaci\u00f3n para realizar la compra de entradas de cine. En este primera parte, se llevar\u00e1 a cabo el inicio de sesi\u00f3n.</p> <p>Se debe tener en cuenta que existen 4 tipos de usuarios diferentes, cliente, administrador, encargado y empleado. De todos los usuarios se desea almacenar las credenciales, que constar\u00e1 de correo, contrase\u00f1a y estado. Pero adem\u00e1s de los clientes se desea almacenar la direcci\u00f3n (compuesta de Nombre de la v\u00eda, n\u00famero, municipio, localidad y c\u00f3digo postal), su nombre completo y una breve biograf\u00eda de 160 caracteres. De los empleados se desea almacenar el a\u00f1o en el que empezaron ser empleados y de los encargados el a\u00f1o en el que se hicieron encargados. De los administradores no se desea conocer nada diferente. </p> <p>Al ejecutar la aplicaci\u00f3n le pedir\u00e1 las credenciales necesarias a un usuario para poder acceder a la aplicaci\u00f3n. Si las credenciales son err\u00f3neas, se las volver\u00e1 a solicitar hasta 3 veces, luego mostrar\u00e1 un mensaje de error y terminar\u00e1 la aplicaci\u00f3n. En caso de las credenciales sean correctas, mostrar\u00e1 un mensaje de bienvenida con el tipo de usuario que ha entrado en la aplicaci\u00f3n.</p> <p>Debes tener en cuenta:</p> <ul> <li>El estado de una credencial puede ser, activo, inactivo, dado de baja, email por confirmar.</li> <li>Al realizarse la petici\u00f3n de iniciar sesi\u00f3n, se deber\u00e1 comprobar si el usuario acreditado es de correo prueba@test.com y de contrase\u00f1a 1234. Este tipo de usuario es administrador</li> <li>La aplicaci\u00f3n se har\u00e1 por completo en INGL\u00c9S, incluyendo los mensajes al usuario.</li> <li>Se deber\u00e1 realizar la entrega a trav\u00e9s de GitHub.</li> <li>Se realizar\u00e1n tantos commits, como se considere, pero siempre m\u00e1s de uno.</li> <li>Se valorar\u00e1 la organizaci\u00f3n de paquetes.</li> <li>Se podr\u00e1 usar la librer\u00eda creada en el proyecto anterior llamada Help, pero ninguna librer\u00eda m\u00e1s. En caso de usarla, se deber\u00e1 hacer la importaci\u00f3n de forma correcta.</li> </ul>"},{"location":"proyects/cinema/proyecto_v2/","title":"Proyecto V2","text":"<p>Los primeros cambios a realizar sobre la aplicaci\u00f3n son los siguientes:</p> <p>Sobre las credenciales de usuarios debes validas:</p> <ul> <li>El email sea correcto, en caso de no serlo, se lanzar\u00e1 una excepci\u00f3n llama <code>EmailMalFormedEXception</code>.</li> <li>La constrase\u00f1a contenga de 8 a 16 caracteres, y como m\u00ednimo una letra min\u00fascula, una may\u00fascula, un d\u00edgito y un car\u00e1cter especial.</li> <li>Si la credencial no es v\u00e1lida, o no es ning\u00fana de las indicadas en la versi\u00f3n anterior, deber\u00e1 obtener por defecto el estado inactivo.</li> </ul> <p>Sobre los clientes se debe tener en cuenta que la bibliograf\u00eda no supere los 160 caracteres, y en caso de superarlo obtener solo los 160 primeros caracteres de la bibliograf\u00eda. Tambi\u00e9n hay que tener en cuenta que los campos num\u00e9ricos de la direcci\u00f3n, no pueden ser negativos, y en caso de serlos, se lanzar\u00e1 un excepci\u00f3n de tipo <code>IllegalArgumentException</code>.</p> <p>Sobre los encargados y los empleados, hay que tener en cuenta, que el a\u00f1o en el que comenzar\u00f3n sus puestos deben ser n\u00fameros positivos y a\u00f1os l\u00f3gicos y v\u00e1lidos, (no ser\u00eda l\u00f3gico que el empleado empezase a trabajar en la empresa en el a\u00f1o 2 a.C)</p> <p>Debe crear una aplicaci\u00f3n llamada SignUpCliente.java, SignUpEmpleado.java, SignUpEmcargado.java, donde se solicite los datos de registro, y en caso de que alguno sea err\u00f3neo debe volver a solicitarselo. Se debe tener en cuenta que el estado de un usuario debe ser EMAIL POR CONFIRMAR, durante su registro, y que no se debe soliciar al usuario.</p> <p>Una vez que el tipo de usuario haya sido creado\u00a1, se mostrar\u00e1 por pantalla con la siguiente estructura:</p> CLIENTEEMPLEADOENCARGADO <pre><code>Cliente Sa\u00fal Benitez\n - Email: saul@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - Direcci\u00f3n: Calle Inventida, n\u00ba 7 - 11300 - La L\u00ednea de la concepci\u00f3n (C\u00e1diz)\n- Bibliograf\u00eda: Soy cin\u00e9filo, en busca de las mejores ofertas para ir al cine.\n   Me gusta mucho las pel\u00edculas de Marvel y DC, aun que a veces tambi\u00e9n me pongo\n   sensibl\u00f3n y me pongo una comedia rom\u00e1ntica.\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> <pre><code>Cliente Rosa Soria\n - Email: rosa@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - A\u00f1o de contrataci\u00f3n: 2015\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> <pre><code>Cliente Marta Dominguez\n - Email: marta@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - A\u00f1o de contrataci\u00f3n: 2012\n- A\u00f1o de subida: 2018\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> Pregunta para pensar <p>\u00bfPor que no fue un error en la primera versi\u00f3n crear una clase exactamente Admin que heredase de la clase base User? Justifica tu respuesta</p>"}]}