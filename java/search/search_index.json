{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenidx al mundo de Java","text":""},{"location":"bloque_i/tema_1/page-1/","title":"1 Introducci\u00f3n","text":""},{"location":"bloque_i/tema_1/page-1/#conceptos-basicos","title":"Conceptos b\u00e1sicos","text":""},{"location":"bloque_i/tema_1/page-1/#computadora","title":"Computadora","text":"<p>Una computadora. o como se le conoce com\u00fan mente, un ordenador, es una m\u00e1quina electr\u00f3nica, anal\u00f3gica o digital, dotada de una memoria de gran capacidad y de m\u00e9todos de tratamiento de la informaci\u00f3n, capaz de resolver problemas matem\u00e1ticos y l\u00f3gicos mediante la utilizaci\u00f3n autom\u00e1tica de programas inform\u00e1ticos.</p>"},{"location":"bloque_i/tema_1/page-1/#informatica","title":"Inform\u00e1tica","text":"<p>Conjunto de conocimientos cient\u00edficos y t\u00e9cnicas que hacen posible el tratamiento autom\u00e1tico de la informaci\u00f3n por medio de ordenadores.</p>"},{"location":"bloque_i/tema_1/page-1/#hardware","title":"Hardware","text":"<p>Componentes f\u00edsicos que conforman parte de un ordenador (o de otro dispositivo electr\u00f3nico): procesador, RAM, impresora, teclado, rat\u00f3n,...</p>"},{"location":"bloque_i/tema_1/page-1/#software","title":"Software","text":"<p>Es el conjunto de programas de c\u00f3mputo, procedimientos, reglas, documentaci\u00f3n y datos asociados, que forman parte de las operaciones de un sistema de computaci\u00f3n.</p>"},{"location":"bloque_i/tema_1/page-1/#sistema-operativo","title":"Sistema Operativo","text":"<p>Se trata del software encargado de gestionar el ordenador. Es la aplicaci\u00f3n que oculta la f\u00edsica real del ordenador para mostrarnos una interfaz que permita al usuario un mejor y m\u00e1s f\u00e1cil manejo de la computadora. Por ejemplo: Windows, Linux, MacOS, etc.</p>"},{"location":"bloque_i/tema_1/page-1/#algoritmo","title":"Algoritmo","text":"<p>Conjunto ordenado y finito de operaciones que permite hallar la soluci\u00f3n de un problema.</p>"},{"location":"bloque_i/tema_1/page-1/#programa-informatico","title":"Programa inform\u00e1tico","text":"<p>Es una secuencia de instrucciones escritas para realizar una tarea espec\u00edfica en una computadora.</p>"},{"location":"bloque_i/tema_1/page-1/#aplicacion-informatica","title":"Aplicaci\u00f3n Inform\u00e1tica","text":"<p>Software formado por uno o m\u00e1s programas, la documentaci\u00f3n de los mismos y los archivos necesarios para su funcionamiento, de modo que el conjunto completo forma una herramienta de trabajo en un ordenador.</p>"},{"location":"bloque_i/tema_1/page-1/#codificacion-de-la-informacion","title":"Codificaci\u00f3n de la informaci\u00f3n","text":"<p>Un ordenador maneja informaci\u00f3n de todo tipo. Nuestra perspectiva humana nos permite r\u00e1pidamente diferenciar lo que no son n\u00fameros, de lo que es texto, imagen, ... Sin embargo al tratarse de una m\u00e1quina digital, el ordenador s\u00f3lo es capaz de representar n\u00fameros en forma binaria. Por ello todos los ordenadores necesitan codificar la informaci\u00f3n del mundo real al equivalente binario entendible por el ordenador.</p>"},{"location":"bloque_i/tema_1/page-1/#sistemas-numericos","title":"Sistemas Num\u00e9ricos","text":"<p>Existen dos tipos de sistemas num\u00e9ricos:</p> <ol> <li>Sistemas no posicionales. En ellos se utilizan s\u00edmbolos cuyo valor num\u00e9rico es siempre el mismo independientemente de donde se sit\u00faen.Es lo que ocurre con la numeraci\u00f3n romana. En esta numeraci\u00f3n el s\u00edmbolo <code>I</code> significa siempre <code>uno</code> independientemente de su posici\u00f3n.</li> <li>Sistemas posicionales. En ellos los s\u00edmbolos num\u00e9ricos cambian de valor en funci\u00f3n de la posici\u00f3n que ocupe. Es el caso de nuestra numeraci\u00f3n, el s\u00edmbolo 2, en la cifra 12 vale 2; mientra que en la cifra 21 vale viente.</li> </ol> <p>La historia ha demostrado que los sistemas posicionales son mucho mejores para los c\u00e1lculos matem\u00e1ticos ya que las operaciones matem\u00e1ticas son m\u00e1s sencillas. Todos los sistemas posicionales tienen una base, que es el n\u00famero total de s\u00edmbolos que utiliza el sistema.</p>"},{"location":"bloque_i/tema_1/page-1/#sistemas-posicionales","title":"Sistemas posicionales","text":"<ul> <li>Sistema decimal: la base es 10, ya que utiliza 10 s\u00edmbolos, desde el 0 hasta el 9.</li> <li>Sistema binario: la base es 2, utiliza 0 y 1.</li> <li>Sistema octal: la base es 8, desde el 0 hasta el 7.</li> <li>Sistema hexadecimal: la base es 16, donde el 0 al 9 y desde la A a la F</li> </ul> <p>Para convertir un n\u00famero octal en binario, se representa cada d\u00edgito en octal por tres d\u00edgitos binarios seg\u00fan la siguiente tabla de conversi\u00f3n:</p> Octal Binario 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 <p>Por lo tanto, el n\u00famero 467 en octal ser\u00eda 100110111 en binario.</p> <p>Los mismo podemos hacer con el binario y el hexadecimal pero con 4 d\u00edgitos.</p> Octal Binario 0 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111 8 1000 9 1001 A 1010 B 1011 C 1100 D 1101 E 1110 F 1111 <p>El n\u00famero B3F en hexadecimal es 1011001111111 en binario</p>"},{"location":"bloque_i/tema_1/page-1/#representacion-de-texto-en-el-sistema-binario","title":"Representaci\u00f3n de texto en el sistema binario","text":"<p>Puesto que una computadora no s\u00f3lo maneja n\u00fameros, habr\u00e1 d\u00edgitos binarios que contengan informaci\u00f3n que no es traducible a decimal. Todo depende de c\u00f3mo se interprete esa traducci\u00f3n. Por ejemplo en el caso del texto, lo que se hace es codificar cada car\u00e1cter en una serie de n\u00fameros binarios. El c\u00f3digo ASCII es un est\u00e1ndar que ha sido durante mucho tiempo el m\u00e1s utilizado. Inicialmente era un c\u00f3digo que utilizaba 7 bits para representar texto, lo que significaba que era capaz de codificar 127 caracteres. Por ejemplo el n\u00famero 65 (1000001 en binario) se utiliza para la A may\u00fascula. Poco despu\u00e9s apareci\u00f3 un problema: este c\u00f3digo es suficiente para los caracteres del ingl\u00e9s, pero no para otras lenguas. Entonces se a\u00f1adi\u00f3 el octavo bit para representar otros 128 caracteres que son distintos seg\u00fan idiomas(Europa Occidental usa unos c\u00f3digos que no utiliza Europa Oriental). Eso provoca que un c\u00f3digo como el 190 signifique cosas diferentes si cambiamos de pa\u00eds. Por ello cuando un ordenador necesita mostrar texto, tiene que saber qu\u00e9 juego de c\u00f3digos debe de utilizar (lo cual supone un tremendo problema). Una ampliaci\u00f3n de este m\u00e9todo de codificaci\u00f3n de caracteres es el est\u00e1ndar Unicode que puede utilizar hasta 4 bytes (32 bits) con lo que es capaz de codificar cualquier car\u00e1cter en cualquier lengua del planeta utilizando el mismo conjunto de c\u00f3digos. Poco a poco es el c\u00f3digo que se va extendiendo, siendo actualmente utilizado en un n\u00famero considerable de tecnolog\u00edas recientes, como XML, Java y sistemas operativos modernos.</p> <p>La descripci\u00f3n completa del est\u00e1ndar est\u00e1 disponible en la p\u00e1gina web de Unicode https://unicode.org/. En <code>Quick Links -&gt; Code Charts</code> encontraremos las tablas de caracteres. Los caracteres b\u00e1sicos del espa\u00f1ol los encontraremos en <code>Latin -&gt; Basic Latin (ASCII)</code> y los caracteres especiales del espa\u00f1ol por ejemplo, las vocales acentuadas y la \u00f1, en <code>Latin1 -&gt; Supplement</code>.</p>"},{"location":"bloque_i/tema_1/page-1/#representacion-binaria-de-datos-no-numericos-ni-de-texto","title":"Representaci\u00f3n binaria de datos no num\u00e9ricos ni de texto","text":"<p>En el caso de datos m\u00e1s complejos (im\u00e1genes, v\u00eddeo, audio) se necesita una codificaci\u00f3n m\u00e1s compleja. En el caso, por ejemplo de las im\u00e1genes, una forma b\u00e1sica de codificarlas en binario es la que graba cada p\u00edxel (cada punto distinguible en la imagen) mediante tres bytes: el primero graba el nivel de rojo, el segundo el nivel de azul y el tercero el nivel de verde. Y as\u00ed por cada p\u00edxel. Esto se conoce como modelo de color RGB donde es posible representar un color mediante la mezcla por adici\u00f3n de los tres colores de luz primarios. Por ejemplo un punto en una imagen de color rojo puro: <code>11111111 00000000 00000000</code>. Naturalmente en una imagen no solo se graban los p\u00edxeles sino el tama\u00f1o de la imagen, el modelo de color,... de ah\u00ed que representar estos datos sea tan complejo para el ordenador (y tan complejo entenderlo para nosotros).</p>"},{"location":"bloque_i/tema_1/page-1/#multiplos-para-medir-digitos-binarios","title":"M\u00faltiplos para medir d\u00edgitos binarios","text":"<p>Puesto que toda la informaci\u00f3n de un ordenador se representa de forma binaria, se hizo indispensable el utilizar unidades de medida para poder indicar la capacidad de los dispositivos:</p> <ul> <li>Bit (de binary digit). Representa un d\u00edgito binario. Por ejemplo, se dice que el n\u00famero binario 1001 tiene cuatro bits.</li> <li>Byte. Es el conjunto de 8 bits.</li> <li>Kilobyte. Son 1024 bytes.</li> <li>Megabyte. Son 1024 Kilobytes.</li> <li>Gigabyte. Son 1024 Megabytes.</li> <li>Terabyte. Son 1024 Gigabytes.</li> <li>Petabyte. Son 1024 Terabytes.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#arquitectura-de-von-newmann","title":"Arquitectura de Von Newmann","text":"<p>La mayor\u00eda de los sistemas inform\u00e1ticos actuales se basan en la arquitectura propuesta por Von Newmann. Esta arquitectura se caracteriza porque el programa que ejecuta el sistema inform\u00e1tico est\u00e1 almacenado internamente en el propio sistema.</p> <p> Figura 1 - Arquitectura de Von Newmann</p> <p>Los buses transportan la informaci\u00f3n entre los diferentes elementos.</p> <p> Figura 2 - Buses</p> <ul> <li>Buses de datos: Como su nombre indica transporta datos. Estos datos pueden ser la informaci\u00f3n que se est\u00e1 procesando o las instrucciones del programa que se ejecuta. El ancho en bits del bus de datos define el tama\u00f1o de la palabra del sistema inform\u00e1tico, por ejemplo, 32 bits \u00f3 64 bits.</li> <li>Bus de direcciones: El bus de direcciones se utiliza para indicar el origen y/o el destino de los datos. En el bus de direcciones se indica la posici\u00f3n de memoria a la que se est\u00e1 accediendo en cada momento. Puede tratarse de una direcci\u00f3n de la memoria principal o puede tratarse de una direcci\u00f3n de memoria de un perif\u00e9rico. El ancho en bits del bus de direcciones determina el tama\u00f1o del espacio de memoria direccionable. Un ancho de 16 bits puede almacenar 2 elevado a 16 (65.536) valores diferentes.</li> <li>Bus de control: El bus de control proporciona se\u00f1ales para coordinar las diferentes tareas que se realizan en el sistema inform\u00e1tico. Por ejemplo, R/W indica si es una operaci\u00f3n de lectura o escritura.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#historia-del-software","title":"Historia del Software","text":"<p>Los primeros ordenadores cumpl\u00edan una \u00fanica programaci\u00f3n que estaba definida en los componentes el\u00e9ctricos que formaban el ordenador. La idea de que el ordenador hiciera varias tareas (ordenador programable o multiprop\u00f3sito) hizo que se idearan las tarjetas perforadas. En ellas se utilizaba c\u00f3digo binario, de modo que se hac\u00edan agujeros en ellas para indicar el c\u00f3digo 1 o el cero. Estos \u201cprimeros programas\u201d l\u00f3gicamente serv\u00edan para hacer tareas muy concretas.</p> <p>La llegada de ordenadores electr\u00f3nicos m\u00e1s potentes hizo que los ordenadores se convirtieran en verdaderas m\u00e1quinas digitales que segu\u00edan utilizando el 1 y el 0 del c\u00f3digo binario pero que eran capaces de leer miles de unos y ceros. Empezaron a aparecer los primeros lenguajes de programaci\u00f3n que escrib\u00edan c\u00f3digo m\u00e1s entendible por los humanos que posteriormente era convertido al c\u00f3digo entendible por la m\u00e1quina.</p> <p>Inicialmente la creaci\u00f3n de aplicaciones requer\u00eda escribir pocas l\u00edneas de c\u00f3digo en el ordenador, por lo que no hab\u00eda una t\u00e9cnica especificar a la hora de crear programas. Cada programador se defend\u00eda como pod\u00eda generando el c\u00f3digo a medida que se le ocurr\u00eda. Poco a poco las funciones que se requer\u00edan a los programas fueron aumentando produciendo miles de l\u00edneas de c\u00f3digo que al estar desorganizada hac\u00edan casi imposible su mantenimiento. S\u00f3lo el programador que hab\u00eda escrito el c\u00f3digo era capaz de entenderlo y eso no era en absoluto pr\u00e1ctico.</p> <p>La llamada crisis del software ocurri\u00f3 cuando se percibi\u00f3 que se gastaba m\u00e1s tiempo en hacer las modificaciones a los programas que en volver a crear el software. La raz\u00f3n era que ya se hab\u00edan codificado millones de l\u00edneas de c\u00f3digo antes de que se definiera un buen m\u00e9todo para crear los programas. La soluci\u00f3n a esta crisis ha sido la definici\u00f3n de la Ingenier\u00eda del software como un oficio que requer\u00eda un m\u00e9todo de trabajo similar al del resto de ingenier\u00edas. La b\u00fasqueda de una metodolog\u00eda de trabajo que elimine esta crisis parece que a\u00fan no est\u00e1 resuelta, de hecho los m\u00e9todos de trabajo siguen redefini\u00e9ndose una y otra vez.</p>"},{"location":"bloque_i/tema_1/page-1/#ciclo-de-vida-de-una-aplicacion","title":"Ciclo de vida de una aplicaci\u00f3n","text":"<p> Figura 3 - Ciclo de vida</p> <p>Una de las cosas que se han definido tras el nacimiento de la ingenier\u00eda del software ha sido el ciclo de vida de una aplicaci\u00f3n. El ciclo de vida define los pasos que sigue el proceso de creaci\u00f3n de una aplicaci\u00f3n desde que se propone hasta que finaliza su construcci\u00f3n. Los pasos son:</p> <ol> <li>An\u00e1lisis. En esta fase se determinan los requisitos que tiene que cumplir la aplicaci\u00f3n. Se anota todo aquello que afecta al futuro funcionamiento de la aplicaci\u00f3n. Este paso le realiza un analista.</li> <li>Dise\u00f1o. Se especifican los esquemas de dise\u00f1o de la aplicaci\u00f3n. Estos esquemas forman los planos del programador, los realiza el analista y representan todos los aspectos que requiere la creaci\u00f3n de la aplicaci\u00f3n.</li> <li>Codificaci\u00f3n. En esta fase se pasa el dise\u00f1o a c\u00f3digo escrito en alg\u00fan lenguaje de programaci\u00f3n. Esta es la primera labor que realiza el programador.</li> <li>Pruebas. Se trata de comprobar que el funcionamiento de la aplicaci\u00f3n es la adecuada. Se realiza en varias fases:<ol> <li>Prueba del c\u00f3digo. Las realizan programadores. Normalmente programadores distintos a los que crearon el c\u00f3digo, de ese modo la prueba es m\u00e1s independiente y generar\u00e1 resultados m\u00e1s \u00f3ptimos.</li> <li>Versi\u00f3n alfa. Es una primera versi\u00f3n terminada que se revisa a fin de encontrar errores. Estas pruebas conviene que sean hechas por personal no inform\u00e1tico. El producto s\u00f3lo tiene cierta apariencia de acabado.</li> <li>Versi\u00f3n beta. Versi\u00f3n casi definitiva del software en la que no se estiman fallos, pero que se distribuye a los clientes para que encuentren posibles problemas. A veces est\u00e1 versi\u00f3n acaba siendo la definitiva.</li> </ol> </li> <li>Mantenimiento. Tiene lugar una vez que la aplicaci\u00f3n ha sido ya distribuida. En esta fase se asegura que el sistema siga funcionando aunque cambien los requisitos o el sistema para el que fue dise\u00f1ado el software. Antes esos cambios se hacen los arreglos pertinentes, por lo que habr\u00e1 que retroceder a fases anteriores del ciclo de vida.</li> </ol>"},{"location":"bloque_i/tema_1/page-1/#errores","title":"Errores","text":"<p>Cuando un programa obtiene una salida que no es la esperada, se dice que posee errores. Los errores son uno de los caballos de batalla de los programadores ya que a veces son muy dif\u00edciles de encontrar (de ah\u00ed que hoy en d\u00eda en muchas aplicaciones se distribuyan parches para subsanar errores no encontrados en la creaci\u00f3n de la aplicaci\u00f3n). Tipos de errores:</p> <ul> <li>Error del usuario. Errores que se producen cuando el usuario realiza algo inesperado y el programa no reacciona apropiadamente (se entiende por usuario la persona que utiliza la aplicaci\u00f3n inform\u00e1tica).</li> <li>Errores de documentaci\u00f3n. Ocurren cuando la documentaci\u00f3n del programa no es correcta y provoca fallos en el manejo.</li> <li>Error de interfaz. Se entiende por interfaz el medio con que el usuario se comunica con la m\u00e1quina, como ventanas, men\u00fas, etc. El error de interfaz ocurre si la interfaz de usuario de la aplicaci\u00f3n es enrevesada para el usuario impidiendo su manejo normal. Tambi\u00e9n se llaman as\u00ed los errores de protocolo entre dispositivos.</li> <li>Error de entrada / salida o de comunicaciones. Ocurre cuando falla la comunicaci\u00f3n entre el programa y un dispositivo (se desea imprimir y no hay papel, falla el teclado,...)</li> <li>Error fatal. Ocurre cuando el hardware produce una situaci\u00f3n inesperada que el software no puede controlar (el ordenador se cuelga, errores en la grabaci\u00f3n de datos,...)</li> <li>Error de sintaxis. Ocurre cuando una instrucci\u00f3n del c\u00f3digo no est\u00e1 bien escrita, es decir, tiene un error de sintaxis. Por lo tanto, no puede ser traducida a c\u00f3digo binario.</li> <li>Error de ejecuci\u00f3n. Se produce cuando el ordenador no puede ejecutar alguna instrucci\u00f3n de forma correcta. Por ejemplo, la instrucci\u00f3n c = 5 / 0; es correcta sint\u00e1cticamente y ser\u00e1 traducida a c\u00f3digo binario. Sin embargo, cuando la computadora intente realizar la divisi\u00f3n 5 / 0 se producir\u00e1 un error de ejecuci\u00f3n, ya que, matem\u00e1ticamente, no se puede dividir entre cero.</li> <li>Error de l\u00f3gica. En cuanto a los errores de l\u00f3gica son los m\u00e1s dif\u00edciles de detectar. Cuando un programa no tiene errores de sintaxis ni de ejecuci\u00f3n, pero a\u00fan as\u00ed, no funciona bien, esto es debido a la existencia de alg\u00fan error l\u00f3gico. De manera que, un error de l\u00f3gica se produce cuando los resultados obtenidos no son los esperados.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-de-programacion","title":"Lenguajes de programaci\u00f3n","text":""},{"location":"bloque_i/tema_1/page-1/#historia","title":"Historia","text":""},{"location":"bloque_i/tema_1/page-1/#inicio-en-la-programacion","title":"Inicio en la programaci\u00f3n","text":"<p>Charles Babbage defini\u00f3 a mediados del siglo XIX lo que \u00e9l llam\u00f3 la m\u00e1quina anal\u00edtica. Se considera a esta m\u00e1quina el dise\u00f1o del primer ordenador. La realidad es que no se pudo construir hasta el siglo siguiente. El caso es que su colaboradora Ada Lovelace escribi\u00f3 en tarjetas perforadas una serie de instrucciones que la m\u00e1quina iba a ser capaz de ejecutar. Se dice que eso signific\u00f3 el inicio de la ciencia de la programaci\u00f3n de ordenadores. En la segunda guerra mundial debido a las necesidades militares, la ciencia de la computaci\u00f3n prospera y con ella aparece el famoso ENIAC (Electronic Numerical Integrator And Calculator), que se programaba cambiando su circuiter\u00eda. Esa es la primera forma de programar (que a\u00fan se usa en numerosas m\u00e1quinas) que s\u00f3lo vale para m\u00e1quinas de \u00fanico prop\u00f3sito. Si se cambia el prop\u00f3sito, hay que modificar la m\u00e1quina.</p>"},{"location":"bloque_i/tema_1/page-1/#codigo-maquina-primera-generacion-de-lenguajes-1gl","title":"C\u00f3digo m\u00e1quina. Primera generaci\u00f3n de lenguajes (1GL)","text":"<p>No mucho m\u00e1s tarde apareci\u00f3 la idea de que las m\u00e1quinas fueran capaces de realizar m\u00e1s de una aplicaci\u00f3n. Para lo cual se ide\u00f3 el hecho de que hubiera una memoria donde se almacenaran esas instrucciones. Esa memoria se pod\u00eda rellenar con datos procedentes del exterior. Inicialmente se utilizaron tarjetas perforadas para introducir las instrucciones. Durante mucho tiempo esa fue la forma de programar, que teniendo en cuenta que las m\u00e1quinas entend\u00edan s\u00f3lo c\u00f3digo binario, consist\u00eda en introducir la programaci\u00f3n de la m\u00e1quina mediante unos y ceros, el llamado c\u00f3digo m\u00e1quina. Todav\u00eda los ordenadores es el \u00fanico c\u00f3digo que entienden, por lo que cualquier forma de programar debe de ser convertida a c\u00f3digo m\u00e1quina. S\u00f3lo se ha utilizado por los programadores en los inicios de la inform\u00e1tica. Su incomodidad de trabajo hace que sea impensable para ser utilizado hoy en d\u00eda. Pero cualquier programa de ordenador debe, finalmente, ser convertido a este c\u00f3digo para que un ordenador puede ejecutar las instrucciones de dicho programa. Un detalle a tener en cuenta es que el c\u00f3digo m\u00e1quina es distinto para cada tipo de procesador. Lo que hace que los programas en c\u00f3digo m\u00e1quina no sean portables entre distintas m\u00e1quinas.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguaje-ensamblador-segunda-generacion-de-lenguajes-2gl","title":"Lenguaje ensamblador. Segunda generaci\u00f3n de lenguajes (2GL)","text":"<p>En los a\u00f1os 40 se intent\u00f3 concebir un lenguaje m\u00e1s simb\u00f3lico que permitiera no tener que programar utilizando c\u00f3digo m\u00e1quina. Poco m\u00e1s tarde se ide\u00f3 el lenguaje ensamblador, que es la traducci\u00f3n del c\u00f3digo m\u00e1quina a una forma m\u00e1s textual. Cada tipo de instrucci\u00f3n se asocia a una palabra mnemotecnia (como SUM para sumar por ejemplo), de forma que cada palabra tiene traducci\u00f3n directa en el c\u00f3digo m\u00e1quina. Tras escribir el programa en c\u00f3digo ensamblador, un programa (llamado tambi\u00e9n ensamblador) se encargar\u00e1 de traducir el c\u00f3digo ensamblador a c\u00f3digo m\u00e1quina. Esta traducci\u00f3n es r\u00e1pida puesto que cada l\u00ednea en ensamblador tiene equivalente directo en c\u00f3digo m\u00e1quina (en los lenguajes modernos no ocurre esto). La idea es la siguiente: si en el c\u00f3digo m\u00e1quina el n\u00famero binario 0000 significa sumar, una instrucci\u00f3n m\u00e1quina que sumara el n\u00famero 8 (00001000 en binario) al n\u00famero 16 (00010000 en binario) ser\u00eda <code>00000000100000010000</code>. El ordenador entender\u00eda que los primeros cuatro bits representan la instrucci\u00f3n y los 8 siguientes el primer n\u00famero y los ocho siguientes el segundo n\u00famero (suponiendo que los n\u00fameros ocupan 8 bits). L\u00f3gicamente trabajar de esta forma es muy complicado. Por eso se podr\u00eda utilizar la siguiente traducci\u00f3n en ensamblador: <code>SUM 8 16</code> , que ya se entiende mucho mejor. Puesto que el ensamblador es una representaci\u00f3n textual pero exacta del c\u00f3digo m\u00e1quina, cada programa s\u00f3lo funcionar\u00e1 para la m\u00e1quina en la que fue concebido el programa, es decir, no es portable. La ventaja de este lenguaje es que se puede controlar absolutamente el funcionamiento de la m\u00e1quina, lo que permite crear programas muy eficientes. Lo malo es precisamente que hay que conocer muy bien el funcionamiento de la computadora para crear programas con esta t\u00e9cnica. Adem\u00e1s las l\u00edneas requeridas para realizar una tarea se disparan ya que las instrucciones de la m\u00e1quina son excesivamente simples.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-de-alto-nivel-lenguajes-de-tercera-generacion-3gl","title":"Lenguajes de alto nivel. Lenguajes de tercera generaci\u00f3n (3GL)","text":"<p>Aunque el ensamblador signific\u00f3 una notable mejora sobre el c\u00f3digo m\u00e1quina, segu\u00eda siendo excesivamente cr\u00edptico. De hecho para hacer un programa sencillo, se necesitaban miles y miles l\u00edneas de c\u00f3digo. Para evitar los problemas del ensamblador apareci\u00f3 la tercera generaci\u00f3n de lenguajes de programaci\u00f3n, la de los lenguajes de alto nivel. En este caso el c\u00f3digo vale para cualquier m\u00e1quina pero deber\u00e1 ser traducido mediante software especial que adaptar\u00e1 el c\u00f3digo de alto nivel al c\u00f3digo m\u00e1quina correspondiente. Esta traducci\u00f3n es necesaria ya que el c\u00f3digo en un lenguaje de alto nivel no se parece en absoluto al c\u00f3digo m\u00e1quina. Tras varios intentos de representar lenguajes, en 1957 aparece el que se considera el primer lenguaje de alto nivel, el FORTRAN (FORmula TRANslation), lenguaje orientado a resolver f\u00f3rmulas matem\u00e1ticas. Poco a poco fueron evolucionando los lenguajes formando lenguajes cada vez mejores. As\u00ed en 1958 se crea LISP como lenguaje declarativo para expresiones matem\u00e1ticas, en 1960 se cre\u00f3 el COBOL como lenguaje de gesti\u00f3n y en 1963 se cre\u00f3 PL/I el primer lenguaje que admit\u00eda la multitarea y la programaci\u00f3n modular. BASIC se cre\u00f3 en el a\u00f1o 1964 como lenguaje de programaci\u00f3n sencillo de aprender y ha sido uno de los lenguajes m\u00e1s populares. En 1968 se crea LOGO para ense\u00f1ar a programar a los ni\u00f1os. Pascal se cre\u00f3 con la misma idea acad\u00e9mica pero siendo ejemplo de lenguaje estructurado para programadores avanzados. El creador del Pascal (Niklaus Wirdth) cre\u00f3 Modula en 1977 siendo un lenguaje estructurado para la programaci\u00f3n de sistemas (intentando sustituir al C). C es un lenguaje de programaci\u00f3n originalmente desarrollado por Dennis Ritchie entre 1969 y 1972 como evoluci\u00f3n del anterior lenguaje B a su vez basado en BCPL. Al igual que B, es un lenguaje orientado a la implementaci\u00f3n de Sistemas operativos, concretamente Unix. C es apreciado por la eficiencia del c\u00f3digo que produce y es el lenguaje de programaci\u00f3n m\u00e1s popular para crear software de sistemas, aunque tambi\u00e9n se utiliza para crear aplicaciones. Es un lenguaje de medio nivel ya que dispone de las estructuras t\u00edpicas de los lenguajes de alto nivel pero a su vez dispone de construcciones del lenguaje que permiten un control a muy bajo nivel pudiendo acceder directamente a memoria o dispositivos perif\u00e9ricos.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-de-cuarta-generacion-4gl","title":"Lenguajes de cuarta generaci\u00f3n (4GL)","text":"<p>En los a\u00f1os 70 se empez\u00f3 a utilizar \u00e9ste t\u00e9rmino para hablar de lenguajes en los que apenas hay c\u00f3digo y en su lugar aparecen indicaciones sobre qu\u00e9 es lo que el programa debe de obtener. Se consideraba que el lenguaje SQL (muy utilizado en las bases de datos) y sus derivados eran de cuarta generaci\u00f3n. Los lenguajes de consulta de datos, creaci\u00f3n de formularios, informes,... son lenguajes de cuarta generaci\u00f3n. Aparecieron con los sistemas de base de datos. Actualmente se consideran lenguajes de \u00e9ste tipo a aquellos lenguajes que se programan sin escribir casi c\u00f3digo (lenguajes visuales), mientras que tambi\u00e9n se propone que este nombre se reserve a los lenguajes orientados a objetos.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguaje-orientado-a-objetos","title":"Lenguaje orientado a objetos","text":"<p>En los 80 llegan los lenguajes preparados para la programaci\u00f3n orientada a objetos todos procedentes de Simula (1964) considerado el primer lenguaje con facilidades de uso de objetos. De estos destac\u00f3 inmediatamente C++. A partir de C++ aparecieron numerosos lenguajes que convirtieron los lenguajes cl\u00e1sicos en lenguajes orientados a objetos y adem\u00e1s con mejoras en el entorno de programaci\u00f3n, son los llamados lenguajes visuales: Visual Basic, Delphi (versi\u00f3n orientada a objetos de Pascal), Visual C++,...En 1995 aparece Java como lenguaje totalmente orientado a objetos y en el a\u00f1o 2000 aparece C# un lenguaje que toma la forma de trabajar de C++ y del propio Java.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-para-la-web","title":"Lenguajes para la web","text":"<p>La popularidad de Internet ha producido lenguajes h\u00edbridos que se mezclan con el c\u00f3digo HTML con el que se crean las p\u00e1ginas web. HTML no es un lenguaje en s\u00ed sino un formato de texto pensado para crear p\u00e1ginas web. Estos lenguajes se usan para poder realizar p\u00e1ginas web m\u00e1s potentes. Son lenguajes interpretados como JavaScript o VB Script, o lenguajes especiales para uso en servidores como ASP, JSP o PHP. Todos ellos permiten crear p\u00e1ginas web usando c\u00f3digo mezcla de p\u00e1ginas web y lenguajes de programaci\u00f3n sencillos.</p>"},{"location":"bloque_i/tema_1/page-1/#tipos-de-lenguajes","title":"Tipos de lenguajes","text":"<p>Seg\u00fan el estilo de programaci\u00f3n se puede hacer esta divisi\u00f3n:</p> <ul> <li>Lenguajes imperativos. Son lenguajes que se centran en c\u00f3mo resolver el problema. Las instrucciones se ejecutan secuencialmente y van modificando la memoria del ordenador para producir las salidas requeridas. La mayor\u00eda de lenguajes (C, Pascal, Basic, Cobol, ...) son de este tipo. Dentro de estos lenguajes est\u00e1n tambi\u00e9n los lenguajes orientados a objetos (C++, Java, C#,...).</li> <li>Lenguajes declarativos. Son lenguajes que se centran en el qu\u00e9 queremos resolver en lugar de en c\u00f3mo resolverlo. El m\u00e1s conocido de ellos es el SQL, lenguaje de consulta de Bases de datos.</li> <li>Lenguajes funcionales. Definen funciones que nos responden a trav\u00e9s de una serie de argumentos. Son lenguajes que usan expresiones matem\u00e1ticas. El m\u00e1s conocido de ellos es el LISP.</li> <li>Lenguajes l\u00f3gicos. Lenguajes utilizados para resolver expresiones l\u00f3gicas. Utilizan la l\u00f3gica para producir resultados. El m\u00e1s conocido es el PROLOG.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#interpretes-y-compiladores","title":"Interpretes y compiladores","text":"<p>A la hora de convertir un programa en c\u00f3digo m\u00e1quina, se pueden utilizar dos tipos de software: int\u00e9rpretes y compiladores.</p>"},{"location":"bloque_i/tema_1/page-1/#interpretes","title":"Int\u00e9rpretes","text":"<p>Se convierte cada l\u00ednea a c\u00f3digo m\u00e1quina y se ejecuta ese c\u00f3digo m\u00e1quina antes de convertir la siguiente l\u00ednea. De esa forma si las dos primeras l\u00edneas son correctas y la tercera tiene un fallo de sintaxis, ver\u00edamos el resultado de las dos primeras l\u00edneas y al llegar a la tercera se nos notificar\u00eda el fallo y finalizar\u00eda la ejecuci\u00f3n. El int\u00e9rprete hace una simulaci\u00f3n de modo que parece que la m\u00e1quina entiende directamente las instrucciones del lenguaje, pareciendo que ejecuta cada instrucci\u00f3n (como si fuese c\u00f3digo m\u00e1quina directo). El BASIC era un lenguaje interpretado, se traduc\u00eda l\u00ednea a l\u00ednea. Hoy en d\u00eda la mayor\u00eda de los lenguajes integrados en p\u00e1ginas web son interpretados, la raz\u00f3n es que como la descarga de Internet es lenta, es mejor que las instrucciones se vayan traduciendo seg\u00fan van llegando en lugar de cargar todas en el ordenador. Por eso lenguajes como JavaScript son interpretados.</p> <p>Un programa que se convierte a c\u00f3digo m\u00e1quina mediante un int\u00e9rprete sigue estos pasos:</p> <ol> <li>Lee la primera instrucci\u00f3n</li> <li>Comprueba si es correcta</li> <li>Convierte esa instrucci\u00f3n al c\u00f3digo m\u00e1quina equivalente</li> <li>Lee la siguiente instrucci\u00f3n</li> <li>Vuelve al paso 2 hasta terminar con todas las instrucciones</li> </ol> <p>Ventajas de los int\u00e9rpretes</p> <ul> <li>Se tarda menos en crear el primer c\u00f3digo m\u00e1quina. El programa se ejecuta antes.</li> <li>No hace falta cargar todas las l\u00edneas para empezar a ver resultados (lo que hace que sea una t\u00e9cnica id\u00f3nea para programas que se cargan desde Internet)</li> </ul> <p>Desventajas de los int\u00e9rpretes:</p> <ul> <li>El c\u00f3digo m\u00e1quina producido es peor ya que no se optimiza al valorar una sola l\u00ednea cada vez. El c\u00f3digo optimizado permite estudiar varias l\u00edneas a la vez para producir el mejor c\u00f3digo m\u00e1quina posible, por ello no es posible mediante el uso de int\u00e9rpretes.</li> <li>Todos los errores son errores en tiempo de ejecuci\u00f3n, no se pueden detectar antes de lanzar el programa. Esto hace que la depuraci\u00f3n de los errores sea m\u00e1s compleja.</li> <li>El c\u00f3digo m\u00e1quina resultante gasta m\u00e1s espacio.</li> <li>Hay errores dif\u00edcilmente detectables, ya que para que los errores se produzcan, las l\u00edneas de errores hay que ejecutarlas. Si la l\u00ednea es condicional, hasta que no probemos todas las posibilidades del programa, no sabremos todos los errores de sintaxis cometidos.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#compiladores","title":"Compiladores","text":"<p>Se trata de software que traduce las instrucciones de un lenguaje de programaci\u00f3n de alto nivel a c\u00f3digo m\u00e1quina. La diferencia con los int\u00e9rpretes reside en que se analizan todas las l\u00edneas antes de empezar la traducci\u00f3n. Durante muchos a\u00f1os, los lenguajes potentes han sido compilados. El uso masivo de Internet ha propiciado que esta t\u00e9cnica a veces no sea adecuada y haya lenguajes modernos interpretados o semi-interpretados, mitad se compila hacia un c\u00f3digo intermedio y luego se interpreta l\u00ednea a l\u00ednea (esta t\u00e9cnica la siguen Java y los lenguajes de la plataforma .NET de Microsoft).</p> <p>Ventajas de los compiladores:</p> <ul> <li>Se detectan errores antes de ejecutar el programa (errores de compilaci\u00f3n).</li> <li>El c\u00f3digo m\u00e1quina generado es m\u00e1s r\u00e1pido (ya que se optimiza).</li> <li>Es m\u00e1s f\u00e1cil hacer procesos de depuraci\u00f3n de c\u00f3digo.</li> </ul> <p>Desventajas de los compiladores:</p> <ul> <li>El proceso de compilaci\u00f3n del c\u00f3digo es lento.</li> <li>No es \u00fatil para ejecutar programas desde Internet ya que hay que descargar todo el programa antes de traducirle, lo que ralentiza mucho su uso.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#tipos-de-paradigmas-de-programacion","title":"Tipos de paradigmas de programaci\u00f3n","text":"<p>Un paradigma de programaci\u00f3n es un modelo b\u00e1sico de dise\u00f1o y desarrollo de programas que permite generar programas con un conjunto de normas espec\u00edficas.</p> <p>En general, la mayor\u00eda de paradigmas son variantes de los dos tipos principales de programaci\u00f3n, imperativa y declarativa. En la programaci\u00f3n imperativa se describe paso a paso un conjunto de instrucciones que deben ejecutarse para variar el estado del programa y hallar la soluci\u00f3n, es decir, un algoritmo en el que se describen los pasos necesarios para solucionar el problema.</p> <p>En la programaci\u00f3n declarativa las sentencias que se utilizan lo que hacen es describir el problema que se quiere solucionar; se programa diciendo lo que se quiere resolver pero no las instrucciones necesarias para solucionarlo. Esto \u00faltimo se realizar\u00e1 mediante mecanismos internos de deducci\u00f3n de informaci\u00f3n a partir de la descripci\u00f3n realizada.</p> <p>A continuaci\u00f3n se describen algunas de las distintas variantes de paradigmas de programaci\u00f3n:</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-imperativa","title":"Programaci\u00f3n imperativa","text":"<p>Es uno de los paradigmas de programaci\u00f3n de computadoras m\u00e1s utilizados. Bajo este paradigma, la programaci\u00f3n se describe en t\u00e9rminos del estado del programa y de sentencias que cambian dicho estado. Java es un lenguaje imperativo, lo que implica que un programa Java est\u00e1 compuesto por una secuencia de instrucciones, que son ejecutadas en el mismo orden en el que se escriben, de manera que al ejecutarla se produce cambios en el estado del programa.</p> <p>Dentro de esta categor\u00eda se engloban la programaci\u00f3n estructurada y la programaci\u00f3n orientada a objetos, las cuales han permitido mejorar la mantenibilidad y la calidad de los programas imperativos.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-estructurada","title":"Programaci\u00f3n estructurada","text":"<p>Est\u00e1 orientada a mejorar la claridad, calidad y tiempo de desarrollo de un programa de computadora recurriendo \u00fanicamente a subrutinas y tres estructuras b\u00e1sicas: secuencia, selecci\u00f3n (if y switch) e iteraci\u00f3n(bucles for y while).</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-orientada-a-objetos","title":"Programaci\u00f3n orientada a objetos","text":"<p>La programaci\u00f3n orientada a objetos encapsula elementos denominados objetos.</p> <p>Bajo este paradigma, la programaci\u00f3n se describe como una serie de objetos independientes que se comunican entre s\u00ed. Java es un lenguaje orientado a objetos.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-orientada-a-eventos","title":"Programaci\u00f3n orientada a eventos","text":"<p>La programaci\u00f3n dirigida por eventos es un paradigma de programaci\u00f3n en el que tanto la estructura como la ejecuci\u00f3n de los programas van determinados por los sucesos que ocurran en el sistema, definidos por el usuario o lo que sea que est\u00e9 accionando el programa.</p> <p>Mientras que en la programaci\u00f3n estructurada es el programador el que define cu\u00e1l va a ser el flujo del programa, en la programaci\u00f3n dirigida por eventos ser\u00e1 el propio usuario, o lo que sea que est\u00e9 accionando el programa, el que dirija el flujo del programa. Aunque en la programaci\u00f3n estructurada puede haber intervenci\u00f3n de un agente externo al programa, estas intervenciones ocurrir\u00e1n cuando el programador lo haya determinado, y no en cualquier momento como puede ser en el caso de la programaci\u00f3n dirigida por eventos.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-declarativa","title":"Programaci\u00f3n declarativa","text":"<p>Est\u00e1 basada en describir el problema declarando propiedades y reglas que deben cumplirse, en lugar de instrucciones. La soluci\u00f3n es obtenida mediante mecanismos internos de control, sin especificar exactamente c\u00f3mo encontrarla (tan solo se le indica a la computadora qu\u00e9 es lo que se desea obtener o qu\u00e9 es lo que se est\u00e1 buscando). Los lenguajes declarativos tienen la ventaja de ser razonados matem\u00e1ticamente, lo que permite el uso de mecanismos matem\u00e1ticos para optimizar el rendimiento de los programas.</p> <p>Dentro de esta categor\u00eda se engloban la programaci\u00f3n funcional y la programaci\u00f3n l\u00f3gica.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-funcional","title":"Programaci\u00f3n funcional","text":"<p>Es un paradigma de programaci\u00f3n en el que el resultado de un programa deriva de la aplicaci\u00f3n de distintas funciones a la entrada, sin cambiar el estado interno del programa. En la programaci\u00f3n funcional los bloques principales de construcci\u00f3n de nuestros programas son las funciones, y no los objetos.</p> <p>Al aplicar programaci\u00f3n funcional se produce normalmente un c\u00f3digo m\u00e1s corto y m\u00e1s sencillo de entender que aplicando programaci\u00f3n imperativa.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-logica","title":"Programaci\u00f3n l\u00f3gica","text":"<p>Es un paradigma de programaci\u00f3n basado en la definici\u00f3n de relaciones l\u00f3gicas.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-multiparadigma","title":"Programaci\u00f3n multiparadigma","text":"<p>Es el uso de dos o m\u00e1s paradigmas dentro de un programa. Por ejemplo, Java es imperativo y orientado a objetos</p>"},{"location":"bloque_i/tema_1/page-10/","title":"10 N\u00fameros aleatorios","text":""},{"location":"bloque_i/tema_1/page-10/#la-clase-random","title":"La clase Random","text":"<p>En java disponemos de la clase Random para generar n\u00fameros aleatorios. La clase dispone de dos constructores, uno sin par\u00e1metros y otro con un par\u00e1metro llamado semilla (seed). Aunque no  podemos  predecir  que  n\u00fameros  se  generar\u00e1n  con  una  semilla  particular,  podemos  sin embargo, duplicar una serie de n\u00fameros aleatorios usando la misma semilla. Es decir, cada vez que  creamos  un  objeto  de  la  clase  Random  con  la  misma  semilla  obtendremos  la  misma secuencia de n\u00fameros aleatorios. Podemos cambiar la semilla de los n\u00fameros aleatorios en cualquier momento utilizando el m\u00e9todo setSeed.</p>"},{"location":"bloque_i/tema_1/page-10/#metodos","title":"M\u00e9todos","text":"<p>Algunos m\u00e9todos de la clase Random para generar n\u00fameros aleatorios:</p> <ul> <li>nextInt(): genera un n\u00famero aleatorio entero de tipo int</li> <li>nextInt(int n): genera un n\u00famero aleatorio entero de tipo int entre 0(incluido) y n(excluido)</li> <li>nextLong(): genera un n\u00famero aleatorio entero de tipo long</li> <li>nextFloat(): genera un n\u00famero aleatorio de tipo float entre 0.0(incluido) y 1.0(excluido)</li> <li>nextDouble():  genera  un  n\u00famero  aleatorio  de  tipo  double  entre  0.0(incluido)  y 1.0(excluido)</li> <li>nextBoolean(): genera un booleano aleatorio</li> </ul>"},{"location":"bloque_i/tema_1/page-10/#numeros-aleatorios-en-un-rango","title":"N\u00fameros aleatorios en un rango","text":"<p>Para generar n\u00fameros aleatorios enteros comprendidos entre un rango de dos n\u00fameros enteros min y max, hay que utilizar la siguiente f\u00f3rmula:</p> <p><code>nextInt(max - min + 1) + min</code></p> <p>Por  ejemplo,  si  queremos  generar  un  n\u00famero  aleatorio  entre  5  y  10:  nextInt(10-5+1)+5  \u2192 nextInt(6)+5</p>"},{"location":"bloque_i/tema_1/page-10/#ejemplo-de-uso","title":"Ejemplo de uso","text":"<p>En el siguiente ejemplo, se puede observar en la ejecuci\u00f3n que utilizando el Random con semilla siempre se generan los mismos n\u00fameros</p> <pre><code>public class RandomClass {\n    public static void main(String[] args) {\n        Random random = new Random(); // Sin semilla\n        Random randomSeed = new Random(3816); // Con semilla. Siempre se generan los mimos n\u00fameros\n\n        System.out.println(random.nextBoolean());\n        System.out.println(random.nextInt());\n        System.out.println(random.nextLong());\n        System.out.println(random.nextFloat());\n        System.out.println(random.nextDouble());\n        System.out.println(random.nextInt(6) + 5); // Genera un n\u00famero aleatorio entre 5 y 10\n\n        System.out.println(randomSeed.nextBoolean());\n        System.out.println(randomSeed.nextInt());\n        System.out.println(randomSeed.nextLong());\n        System.out.println(randomSeed.nextFloat());\n        System.out.println(randomSeed.nextDouble());\n        System.out.println(randomSeed.nextInt(6) + 5); // Genera un n\u00famero aleatorio entre 5 y 10\n    }\n}\n</code></pre> Ejercicio <p>Sacar aleatoriamente lo siguiente:</p> <ul> <li>La cara de una moneda</li> <li>El lanzamiento de un dado</li> <li>Un n\u00famero entre 34 y 68 ambos incluidos</li> <li>Un n\u00famero decimal</li> <li>Un d\u00eda de la semana y mostrar si es fin de semana o no</li> <li>Un mes del a\u00f1o y mostrar si es verano o no (entenderemos como veranos los meses de julio y agosto)</li> </ul>"},{"location":"bloque_i/tema_1/page-11/","title":"11 Lectura por teclado","text":""},{"location":"bloque_i/tema_1/page-11/#la-clase-system","title":"La clase System","text":"<p>Las aplicaciones pueden necesitar acceder a los recursos del sistema, como por ejemplo, a los dispositivos de entrada/salida est\u00e1ndar para recoger datos desde el teclado o mostrar datos por pantalla. En Java, la entrada por teclado y la salida de informaci\u00f3n por pantalla se hace mediante la clase System del paquete java.lang de la biblioteca de clases de Java. Dicha clase contiene el atributo in para el teclado y el atributo out para la pantalla.</p> <p>Dichos atributos son est\u00e1ticos por lo que se accede a ellos con el nombre de la clase System:</p> <ul> <li><code>System.in</code> Entrada est\u00e1ndar: teclado.</li> <li><code>System.out</code> Salida est\u00e1ndar: pantalla.</li> </ul>"},{"location":"bloque_i/tema_1/page-11/#la-clase-scanner","title":"La clase Scanner","text":"<p>El  kit  de  desarrollo  de  Java,  a  partir  de  su  versi\u00f3n  1.5,  incorpora  la  clase  Scanner  del  paquete java.util la cual posee m\u00e9todos para leer valores de entrada que pueden venir de varias fuentes, como por ejemplo, de datos introducidos por teclado o datos almacenados en un archivo. Para leer datos desde el teclado, tenemos que pasarle el  <code>System.in</code>  al constructor del Scanner:</p> <pre><code>Scanner keyboard = new Scanner (System.in);\n</code></pre> <p>Veamos algunos m\u00e9todos de esta clase:</p> <ul> <li>nextByte, nextShort, nextInt y nextLong: para leer datos de tipo entero.</li> <li>nextFloat y nextDouble: para leer n\u00fameros decimales.</li> <li>next: lee una palabra, es decir, hasta que encuentre un espacio.</li> <li>nextLine: lee una l\u00ednea completa, es decir, hasta que encuentre un salto de l\u00ednea (\\n).</li> </ul> <p>Por ejemplo, para leer un dato de tipo int ser\u00eda:</p> <pre><code>int i = keyboard.nextInt ();\n</code></pre> <p>O bien esta otra instrucci\u00f3n para leer una l\u00ednea completa:</p> <pre><code>String string = keyboard.nextLine();\n</code></pre> <p>He aqu\u00ed un ejemplo de entrada de teclado con la clase Scanner:</p> <pre><code>import java.util.Scanner;\n\npublic class ScannerClass {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        String string;\n        int i;\n        float f;\n        boolean b;\n\n        string = keyboard.nextLine();\n        System.out.println(string);\n\n        i = keyboard.nextInt();\n        System.out.println(i);\n\n        b = keyboard.nextBoolean();\n        System.out.println(b);\n\n        f = keyboard.nextFloat();//(1)!\n\n        System.out.println(f);\n    }\n}\n</code></pre> <ol> <li>El s\u00edmbolo separador de decimales ser\u00e1 la coma si nuestro idioma por defecto del sistema operativo est\u00e1 configurado en espa\u00f1ol.</li> </ol> <p>El  s\u00edmbolo  separador  de  decimales  ser\u00e1  la  coma  si  nuestro  idioma  por  defecto  del  sistema operativo  est\u00e1  configurado  en  espa\u00f1ol.  Si  deseamos  que  el  separador  decimal  sea  el  punto  en lugar  de  la  coma,  entonces  tendremos  que  a\u00f1adir <code>useLocale(Locale.US)</code>   cuando  creemos  el Scanner:</p> <pre><code>import java.util.Locale;\nimport java.util.Scanner;\n\npublic class ScannerClassLocale {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in).useLocale(Locale.US);\n\n        float f;\n        // Debido al useLocale(Locale.US), el s\u00edmbolo separador de decimales ser\u00e1 el punto\n        f = keyboard.nextFloat();\n        System.out.println(f);\n    }\n}\n</code></pre> <p>Veamos un ejemplo de lectura de palabras con next():</p> <pre><code>import java.util.Scanner;\n\npublic class Next {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        String string1, string2, string3;\n\n        System.out.println(\"Introduzca 3 palabras separadas por espacio: \");\n        string1 = keyboard.next();\n        string2 = keyboard.next();\n        string3 = keyboard.next();\n\n        System.out.println(\"Primera palabra: \" + string1);\n        System.out.println(\"Segunda palabra: \" + string2);\n        System.out.println(\"Tercera palabra: \" + string3);\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_1/page-11/#buffer-de-datos","title":"Buffer de datos","text":"<p>Un buffer de datos es un espacio de memoria donde se almacenan datos de manera temporal mientras  son  transferidos  o  procesados.  Los  sistemas  de  entrada  de  teclado  poseen  un  buffer que almacena las teclas presionadas.</p> <p>Cuando  introducimos  un  dato  por  teclado,  para  indicar  que  hemos  finalizado  la  introducci\u00f3n pulsamos la tecla Enter. Cuando se ejecuta cualquier next con la clase Scanner(excepto nextLine), se coge el dato correspondiente del buffer pero el Enter se queda guardado como un <code>\\n</code> (salto de l\u00ednea) en el buffer. Si a continuaci\u00f3n se ejecuta un nextLine, lee hasta el salto de l\u00ednea del buffer, es  decir,  lee  cadena  vac\u00eda  y  ya  no  le  da  opci\u00f3n  al  usuario  de  introducir  la  cadena.  Una  posible soluci\u00f3n  ser\u00eda  limpiar  el  buffer  con  un  nextLine  y  luego  realizar  otro  nextLine  para  pedirle  la cadena al usuario.</p> <pre><code>import java.util.Scanner;\n\npublic class NextLine {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        String string;\n        int number;\n        boolean b;\n\n        // El nextLine() toma el salto de l\u00ednea dejado por cualquier otro next\n        System.out.println(\"Introduzca un n\u00famero entero: \");\n        number = keyboard.nextInt();\n        System.out.println(number);\n\n        System.out.println(\"Introduzca una cadena: \");\n        string = keyboard.nextLine();\n        System.out.println(string);\n\n        System.out.println(\"Introduzca un booleano: \");\n        b = keyboard.nextBoolean();\n        System.out.println(b);\n\n        System.out.println(\"Introduzca una cadena: \");\n        string = keyboard.nextLine();\n        System.out.println(string);\n\n        System.out.println(\"Introduzca una cadena con next: \");\n        string = keyboard.next();\n        System.out.println(string);\n\n        System.out.println(\"Introduzca una cadena: \");\n        string = keyboard.nextLine();\n        System.out.println(string);\n\n        // Soluci\u00f3n: poner un nextLine que coja el salto de l\u00ednea. A esto se le conoce\n        // como limpiar el buffer\n        System.out.println(\"Vamos a solucionar el problema.\\nIntroduzca un n\u00famero entero: \");\n        number = keyboard.nextInt();\n        System.out.println(number);\n\n        System.out.println(\"Introduce una cadena: \");\n        keyboard.nextLine(); // Limpieza del buffer\n        string = keyboard.nextLine();\n        System.out.println(string);\n    }\n}\n</code></pre> <p>Otra soluci\u00f3n ser\u00eda indicarle al objeto scanner que como delimitador use el \\n ya que por defecto es el car\u00e1cter espacio. De esta forma, cuando utilicemos next(), leer\u00e1 todos los caracteres hasta el siguiente \\n. El \u00fanico inconveniente de esto es que no podremos leer palabra a palabra.</p> <pre><code>public class NextDelimiter {\n    public static void main(String[] args) {\n        String delimiterWindows = \"\\\\r\\\\n\";\n        String delimiterLinuxMac = \"\\\\n\";\n\n        Scanner keyboard = new Scanner(System.in).useDelimiter(delimiterWindows);\n        String string;\n        int number;\n\n        System.out.println(\"Introduzca un n\u00famero entero: \");\n        number = keyboard.nextInt();\n        System.out.println(number);\n\n        System.out.println(\"Introduzca una cadena: \");\n        string = keyboard.next();\n        System.out.println(string);\n    }\n}\n</code></pre> Ejercicio <p>Solic\u00edtale al usuario los siguientes datos. A continuaci\u00f3n, mu\u00e9stralos por consola:</p> <ol> <li>Nombre</li> <li>Apellidos</li> <li>Edad</li> <li>Direcci\u00f3n<ul> <li>Calle</li> <li>N\u00famero</li> <li>C\u00f3digo postal</li> <li>Provincia</li> </ul> </li> <li>Si es estudiante (boolean)</li> <li>Altura (con decimales)</li> </ol>"},{"location":"bloque_i/tema_1/page-12/","title":"12 Escritura en pantalla","text":""},{"location":"bloque_i/tema_1/page-12/#introduccion","title":"Introducci\u00f3n","text":"<p>La salida por pantalla en Java se hace con el objeto System.out. Este objeto es una instancia de la clase  PrintStream  del  paquete  java.lang.  Si  miramos  la  API  de  PrintStream  obtendremos  la variedad de m\u00e9todos para mostrar datos por pantalla, algunos de estos son:</p> <ul> <li>print y println: muestran los datos por pantalla. Est\u00e1n sobrecargados para varios tipos de datos. El println inserta un salto de l\u00ednea despu\u00e9s de mostrar el dato.</li> <li>printf: escribe una cadena de texto utilizando formato.</li> </ul> <p>En print y println, cuando queramos escribir un mensaje y el valor de una variable debemos utilizar el operador de  <code>concatenaci\u00f3n</code>  de cadenas (+), por ejemplo:</p> <pre><code>System.out.println(\"Bienvenido, \" + nombre);\n</code></pre> <p>Escribe el mensaje de \"Bienvenido, Carlos\", si el valor de la variable nombre es Carlos. En print y println, todas las variables que se muestran se consideran como cadenas de texto sin formato,por ejemplo, no ser\u00eda posible indicar que escriba un n\u00famero decimal con dos cifras decimales.</p> <p>Para ello se utiliza printf</p> Ejercicio 1 <p>Muestra en consola lo siguiente, exactamente igual, utilizando <code>System.out.print</code></p> <pre><code>La letra n\u00famero \"101\" es la:    'e'\n    El car\u00e1cter '\\' es:\n        \"especial\"\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#el-metodo-printf","title":"El m\u00e9todo printf","text":"<p><code>printf(String format, Object... args)</code></p> <p>En <code>String format</code> se coloca la cadena a la cual se le quiere dar formato. Utiliza unos c\u00f3digos de conversi\u00f3n para indicar del contenido a mostrar de qu\u00e9 tipo es. Estos c\u00f3digos se caracterizan porque llevan delante el s\u00edmbolo <code>%</code>, algunos de ellos son:</p> <ul> <li><code>%c</code>: car\u00e1cter.</li> <li><code>%s</code>: cadena de texto.</li> <li><code>%d</code>: entero.</li> <li><code>%f</code>: n\u00famero decimal.</li> </ul> <p>Tambi\u00e9n se pueden usar las secuencias de escape que van precedidas de <code>\\</code>, como por ejemplo <code>\\n</code> y <code>\\t</code>, incluso el salto de l\u00ednea <code>\\n</code> tambi\u00e9n se puede especificar como <code>%n</code> .</p> <p>En <code>Object... args</code> se colocan los valores correspondientes. El primero corresponde al primer %, el segundo al segundo, y as\u00ed sucesivamente. Dichos valores tienen que ser expresiones que devuelvan resultados con tipos compatibles a los % que correspondan.</p> <p>Ejemplos:</p> <pre><code>System.out.printf(\"El car\u00e1cter es %c\", 'a');\n</code></pre> <p>Nos mostrar\u00eda por pantalla: <code>El car\u00e1cter es a</code></p> <pre><code>int integer = 10;\nSystem.out.printf(\"%d\", integer);\n</code></pre> <p>Salida por pantalla: <code>10</code></p> <p>Si queremos mostrar el s\u00edmbolo % se utiliza otro % delante:</p> <pre><code>System.out.printf(\"El 20%% de %d es %d\\n\", 200, 200*20/100);\n</code></pre> <p>Salida por pantalla: <code>El 20% de 200 es 40</code></p>"},{"location":"bloque_i/tema_1/page-12/#decimales","title":"Decimales","text":"<p>Para <code>%f</code> podemos especificar el n\u00famero de decimales escribiendo <code>.n</code> entre % y f, siendo n el n\u00famero de decimales:</p> <pre><code>System.out.printf(\"%.2f\", 12.3698);\n</code></pre> <p>La salida por pantalla es <code>12,37</code> ya que se realiza un redondeo para mostrar los decimales indicados.</p>"},{"location":"bloque_i/tema_1/page-12/#numeros-con-signo","title":"N\u00fameros con signo","text":"<p>Para mostrar n\u00fameros con signo se utiliza el s\u00edmbolo + entre % y d si es un n\u00famero entero o entre % y f si es un n\u00famero decimal.</p> <pre><code>int integer = 10;\nSystem.out.printf(\"%+d\", integer);\n</code></pre> <p>Salida por pantalla: <code>+10</code></p> <pre><code>int integer = -10;\nSystem.out.printf(\"%-d\", integer);\n</code></pre> <p>Salida por pantalla: <code>-10</code></p> <pre><code>double decimal = 3.968;\nSystem.out.printf(\"%+.2f\", decimal);\n</code></pre> <p>Salida por pantalla: <code>+3.97</code></p> <pre><code>double decimal = -3.968;\nSystem.out.printf(\"%+f\", decimal);\n</code></pre> <p>Salida por pantalla: <code>-3.968000</code></p>"},{"location":"bloque_i/tema_1/page-12/#mostrar-mas-de-un-valor","title":"Mostrar m\u00e1s de un valor","text":"<p>Utilizaremos tantos % como valores vamos a formatear. Despu\u00e9s de la primera coma, se van poniendo los valores separados por comas, el primero corresponde al primer %, el segundo al segundo %, y as\u00ed sucesivamente.</p> <pre><code>double decimal = 1.25036;\nint integer = 10;\nSystem.out.printf(\"decimal = %.2f integer = %d\", decimal, integer);\n</code></pre> <p>Salida por pantalla: <code>decimal = 1,25 integer = 10</code></p> <p>Tambi\u00e9n podemos cambiar el orden por defecto de correspondencia entre los valores y los % con el s\u00edmbolo <code>$</code>. Ejemplo: <code>%2$d</code> significa que al n\u00famero entero (%d) se le va a asignar el segundo valor (<code>2$</code>).</p> <pre><code>System.out.printf(\"decimal1 = %2$.2f integer = %1$d decimal2 = %2$+.1f\", integer, decimal);\n</code></pre> <p>Salida por pantalla: <code>decimal1 = 1,25 integer = 10 decimal2 = +1,3</code></p> <p>Ejemplo: mostrar el n\u00fameros 123.4567 y su cuadrado ambos con dos decimales:</p> <pre><code>double decimal = 123.4567;\nSystem.out.printf(\"El cuadrado de %.2f es %.2f\", decimal, decimal * decimal)\n</code></pre> <p>Salida por pantalla: <code>El cuadrado de 123,46 es 15241,56</code></p>"},{"location":"bloque_i/tema_1/page-12/#especificar-un-ancho-de-campo","title":"Especificar un ancho de campo","text":"<p>printf permite tambi\u00e9n mostrar valores con un ancho de campo determinado. Por ejemplo, si queremos mostrar un n\u00famero entero en un ancho de 10 caracteres, escribimos 10 enter % y d:</p> EJEMPLOSALIDA <pre><code>int integer = 1234;\nSystem.out.printf(\"Ancho de 10 caracteres con un entero: %10d\", integer);\n</code></pre> <pre><code>Ancho de 10 caracteres con un entero:      1234\n</code></pre> <p>Otro ejemplo con n\u00fameros decimales: mostrar con dos decimales, con signo y en un ancho de campo de 10 caracteres:</p> EJEMPLOSALIDA <pre><code>double decimal = 1.25036;\nSystem.out.printf(\"Ancho de 10 caracteres con un decimal: %+10.2f\", decimal);\n</code></pre> <pre><code>Ancho de 10 caracteres con un decimal:      +1,25\n</code></pre> <p>En el ancho de 10 caracteres, se cuentan adem\u00e1s de las cifras del n\u00famero, la coma decimal, el signo si lo lleva. En este caso, el n\u00famero ocupa un espacio de 5 caracteres (3 cifras, la coma y el signo), por lo tanto, se a\u00f1aden 5 espacios en blanco al principio para completar el tama\u00f1o de 10.</p> <p>Para completar el ancho de caracteres con ceros en lugar de con espacios, se coloca un 0 delante del ancho de caracteres:</p> EJEMPLOSALIDA <pre><code>double decimal = 1.25036;\nSystem.out.printf(\"Ancho de caracteres rellenado con ceros: %+010.2f\", decimal);\n</code></pre> <pre><code>Ancho de caracteres rellenado con ceros: +000001,25\n</code></pre> <p>Veamos un ejemplo con cadenas: mostrar la cadena \"Manolo\" con un ancho de 10 caracteres:</p> EJEMPLOSALIDA <pre><code>System.out.printf(\"Ancho de caracteres con cadenas:%10s\", \"Manolo\");\n</code></pre> <pre><code>Ancho de caracteres con cadenas:    Manolo\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#alineacion-a-la-izquierda","title":"Alineaci\u00f3n a la izquierda","text":"<p>Con el signo <code>-</code> se indica alineaci\u00f3n a la izquierda.</p> <p>Ejemplo: mostrar un decimal con un ancho de 9 caracteres, con tres decimales y alineado a la izquierda:</p> EJEMPLOSALIDA <pre><code>double decimal = 58.965874f;\nSystem.out.printf(\"decimal=%-9.3fQue ocupe 9 caracteres, con tres decimales y alineado a la izquierda\", decimal);\n</code></pre> <pre><code>decimal=58.966   Que ocupe 9 caracteres, con tres decimales y alineado a la izquierda\n</code></pre> <p>Ejemplo con cadenas: mostrar la cadena \"Manolo\" con un ancho de 10 caracteres y alineada a la izquierda:</p> EJEMPLOSALIDA <pre><code>System.out.printf(\"%-10s:Alineaci\u00f3n a la izquierda con cadenas\", \"Manolo\");\n</code></pre> <pre><code>Manolo    :Alineaci\u00f3n a la izquierda con cadenas\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#ejemplos","title":"Ejemplos","text":"<p>He aqu\u00ed todos los ejemplos de printf vistos en este apartado:</p> <pre><code>public class Printf {\n    public static void main(String[] args) {\n        double decimal;\n        int integer;\n\n        System.out.printf(\"El car\u00e1cter es %c%n\", 'a');\n\n        integer = 10;\n        System.out.printf(\"%d\\n\", integer);\n\n        System.out.printf(\"El 20%% de %d es %d\\n\", 200, 200 * 20 / 100);\n\n        System.out.printf(\"%.2f\\n\", 12.3698);\n\n        decimal = 1.25036;\n        System.out.printf(\"%.3f\\n\", decimal);\n\n        System.out.printf(\"%+d\\n\", integer);\n        integer = -10;\n\n        System.out.printf(\"%+d\\n\", integer);\n        decimal = 3.968;\n\n        System.out.printf(\"%+.2f\\n\", decimal);\n        decimal = -3.968;\n\n        System.out.printf(\"%+f\\n\", decimal);\n        decimal = 1.25036;\n\n        integer = 10;\n        System.out.printf(\"decimal = %.2f integer = %d\\n\", decimal, integer);\n\n        System.out.printf(\"decimal1 = %2$.2f integer = %1$d decimal2 = %2$+.1f\\n\", integer, decimal);\n\n        decimal = 123.4567;\n        System.out.printf(\"El cuadrado de %.2f es %.2f\\n\", decimal, decimal * decimal);\n\n        integer = 1234;\n        System.out.printf(\"Ancho de 10 caracteres con un entero:%10d\\n\", integer);\n\n        decimal = 1.25036;\n        System.out.printf(\"Ancho de 10 caracteres con un decimal:%+10.2f\\n\", decimal);\n\n        decimal = 1.25036;\n        System.out.printf(\"Ancho de caracteres rellenado con ceros:%+010.2f\\n\", decimal);\n\n        System.out.printf(\"Ancho de caracteres con cadenas:%10s\\n\", \"Manolo\");\n\n        decimal = 58.965874f;\n        System.out.printf(\"decimal=%-9.3fQue ocupe 9 caracteres, con tres decimales y alineado a la izquierda\\n\", decimal);\n\n        System.out.printf(\"%-10s:Alineaci\u00f3n a la izquierda con cadenas\\n\", \"Manolo\");\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#ejemplo-de-scanner-y-printf","title":"Ejemplo de Scanner y printf","text":"<p>He aqu\u00ed un ejemplo de entrada/salida de datos utilizando Scanner y printf.</p> <pre><code>import java.util.Scanner;\n\npublic class InputOutput {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        String name;\n        int age;\n        float salary;\n\n        // Entrada de datos\n        System.out.print(\"Nombre: \");\n        name = keyboard.nextLine();\n\n        System.out.print(\"Edad: \");\n        age = keyboard.nextInt();\n\n        System.out.print(\"Salario: \");\n        salary = keyboard.nextFloat();\n\n        // Salida de datos\n        System.out.printf(\"\\nBienvenido: %s\\n\", name);\n        System.out.printf(\"Tienes: %d a\u00f1os\\n\", age);\n        System.out.printf(\"Tu salario es: %.2f euros\\n\", salary);\n    }\n}\n</code></pre> Ejercicio 2     <p>Utilizando las siguientes variables:</p> <pre><code>int x = 10;\nint y = -10;\nfloat n = 13.269834f;\nString cad = \"Ana\";\n</code></pre> <p>Muestra en consola el siguiente resultado, exactamente igual, utilizando <code>System.out.printf</code>, sin utilizar espacios ni tabulaciones en la cadena de formato y utilizando solamente las variables indicadas anteriormente.</p> <pre><code>10\n+10\n-10\n13,27\n  +13,2698\n  13,26983\n+00013,270\nn=13,27   x=10\n      AnaAna  Ana\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#colores","title":"Colores","text":"<p>Para poder utilizar colores en la escritura de datos por pantalla, hay que comprobar si es necesario instalar alg\u00fan plugin en el IDE.</p> <p>Las secuencias de escape ANSI permiten enviar informaci\u00f3n de control a la consola para cambiar los  atributos  del  texto  representado.  Solo  debemos  anteponer  a  la  cadena  que  queremos mostrar en color el c\u00f3digo de escape ANSI referente al color.</p> <p>Cuando aplicamos un color a la salida por consola, el resto de salida por consola seguir\u00e1 saliendo de dicho color hasta que se especifique otro color de salida o finalicemos el texto con el c\u00f3digo RESET, en cuyo caso se vuelve al color por defecto.</p> <pre><code>public class Colors {\n    public static final String RESET = \"\\u001B[0m\";\n    public static final String BLACK = \"\\u001B[30m\";\n    public static final String RED = \"\\u001B[31m\";\n    public static final String GREEN = \"\\u001B[32m\";\n    public static final String YELLOW = \"\\u001B[33m\";\n    public static final String BLUE = \"\\u001B[34m\";\n    public static final String PURPLE = \"\\u001B[35m\";\n    public static final String CYAN = \"\\u001B[36m\";\n    public static final String WHITE = \"\\u001B[37m\";\n    public static final String BLACK_BACKGROUND = \"\\u001B[40m\";\n    public static final String RED_BACKGROUND = \"\\u001B[41m\";\n    public static final String GREEN_BACKGROUND = \"\\u001B[42m\";\n    public static final String YELLOW_BACKGROUND = \"\\u001B[43m\";\n    public static final String BLUE_BACKGROUND = \"\\u001B[44m\";\n    public static final String PURPLE_BACKGROUND = \"\\u001B[45m\";\n    public static final String CYAN_BACKGROUND = \"\\u001B[46m\";\n    public static final String WHITE_BACKGROUND = \"\\u001B[47m\";\n    public static final String BOLD = \"\\u001B[1m\";// Negrita\n    public static final String UNDERLINE = \"\\u001B[4m\";// Subrayado\n    public static final String REVERSED = \"\\u001B[7m\";// Invierte los colores del texto y del fondo\n}\n</code></pre> <pre><code>import static examples.tema_01.Colors.*;\n\npublic class ColorUse {\n    public static void main(String[] args) {\n        System.out.println(RED + \"Este texto es de color rojo\" + RESET);\n        System.out.println(\"Volvemos al color por defecto\");\n        System.out.println(GREEN + \"...y ahora es verde\");\n        System.out.println(PURPLE_BACKGROUND + \"Fondo morado\");\n        System.out.println(CYAN + WHITE_BACKGROUND + \"Fondo blanco con texto celeste\");\n        System.out.println(CYAN + WHITE_BACKGROUND + BOLD + \"Fondo blanco con texto celeste en negrita\");\n        System.out.println(CYAN + WHITE_BACKGROUND + UNDERLINE + \"Fondo blanco con texto celeste subrayado\");\n        System.out.printf(\"%s\\n\", YELLOW + RED_BACKGROUND + (char) 9733); //Estrella\n        System.out.println(YELLOW + GREEN_BACKGROUND + \"Fondo verde con texto amarillo\");\n        System.out.println(REVERSED + \"Fondo amarillo con texto verde usando REVERSED\");\n    }\n}\n</code></pre> Ejercicio 3 <p>Muestra en consola una l\u00ednea de texto con 3 colores y fondos diferentes usando solamente un printf.</p>"},{"location":"bloque_i/tema_1/page-13/","title":"Proyecto","text":"<p>Se desea realizar un proyecto Java en el cu\u00e1l se le solicitar\u00e1 al usuario la siguiente informaci\u00f3n sobre un tri\u00e1ngulo.</p> <ol> <li>Valor de hipotenusa</li> <li>Valor de su base</li> <li>Valor de su altura</li> <li>Nombre</li> </ol> <p>Se mostrar\u00e1 una salida con el siguiente formato, con dicha informaci\u00f3n, usando color de letras azul y un fondo morado:</p> <pre><code>Tri\u00e1ngulo  : Sombra\nHipotenusa : 20,75 cm\nBase       : 15,75 cm\nAltura     : 14.00 cm\n======================\n   \u00c1rea: 189,00 cm\u00b2\n======================\n- No es recto\n- No es equil\u00e1tero\n</code></pre> <p>Para realizar el proyecto se tendr\u00e1 en cuenta los siguientes objeciones:</p> <ol> <li>Se crear\u00e1 un proyecto nuevo cuyo nombre sea el siguiente formato <code>pr01java-NOMBRE-triangulos</code> siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se deber\u00e1 realizar las operaciones pertinentes, incluso si no se han dictado expl\u00edcitamente en el enunciado</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> </ol>"},{"location":"bloque_i/tema_1/page-2/","title":"2 Introducci\u00f3n al lenguaje Java","text":""},{"location":"bloque_i/tema_1/page-2/#historia","title":"Historia","text":"<p>Java es un lenguaje de programaci\u00f3n de prop\u00f3sito general, concurrente, orientado a objetos, que fue dise\u00f1ado espec\u00edficamente para que los desarrolladores de aplicaciones escribieran el programa una vez y lo ejecutaran en cualquier dispositivo, lo que quiere decir que el c\u00f3digo que es ejecutado en una plataforma no tiene que ser recompilado para correr en otra.</p> <p>El lenguaje de programaci\u00f3n Java fue originalmente desarrollado por James Gosling, de Sun Microsystems (constituida en 1982 y posteriormente adquirida el 27 de enero de 2010 por la compa\u00f1\u00eda Oracle). Su sintaxis deriva en gran medida de C y C++, pero tiene menos utilidades de bajo nivel que cualquiera de ellos.</p> <p>El lenguaje Java se cre\u00f3 con cinco objetivos principales:</p> <ol> <li>Deber\u00eda usar el paradigma de la programaci\u00f3n orientada a objetos.</li> <li>Deber\u00eda permitir la ejecuci\u00f3n de un mismo programa en m\u00faltiples sistemas operativos.</li> <li>Deber\u00eda incluir por defecto soporte para trabajo en red.</li> <li>Deber\u00eda dise\u00f1arse para ejecutar c\u00f3digo en sistemas remotos de forma segura.</li> <li>Deber\u00eda ser f\u00e1cil de usar y tomar lo mejor de otros lenguajes orientados a objetos, como C++.</li> </ol>"},{"location":"bloque_i/tema_1/page-2/#bytecode-jvm-jre-jdk","title":"Bytecode, JVM, JRE, JDK","text":"<p>En el mundo de la programaci\u00f3n siempre se ha hablado de lenguajes compilados y de lenguajes interpretados. El resultado del proceso de compilaci\u00f3n (en realidad de compilaci\u00f3n y enlazado) es un archivo ejecutable. Un archivo ejecutable es un programa que se puede lanzar directamente en el sistema operativo; en el caso de Windows o Linux simplemente con hacer doble clic sobre el archivo, se ejecutan sus instrucciones. La ventaja es que los programas ejecutables no necesitan compilarse de nuevo, son programas terminados. El problema es que los sistemas operativos utilizan diferentes tipos de archivos ejecutables: es decir, un archivo ejecutable en Linux no ser\u00eda compatible con Windows.</p> <p>En Java el c\u00f3digo no se traduce a c\u00f3digo ejecutable. En Java el proceso se conoce como precompilaci\u00f3n y sirve para producir un archivo (de extensi\u00f3n class) que contiene c\u00f3digo que no es directamente ejecutable (no es c\u00f3digo Java). Es un c\u00f3digo intermedio llamado bytecode. Al no ser ejecutable, el archivo class no puede ejecutarse directamente con un doble clic en el sistema. El bytecode tiene que ser interpretado (es decir, traducido l\u00ednea a l\u00ednea) por una aplicaci\u00f3n conocida como la m\u00e1quina virtual de Java (JVM).</p> <p>JRE es el Java Runtime Environment o, en espa\u00f1ol, el Entorno de Ejecuci\u00f3n de Java. Contiene a la JVM y otras herramientas que permiten la ejecuci\u00f3n de las aplicaciones Java. La gran ventaja es que el entorno de ejecuci\u00f3n de Java se fabrica para todas las plataformas; lo que significa que un archivo class se puede ejecutar en cualquier ordenador o m\u00e1quina que incorpore el JRE. S\u00f3lo hay una pega, si programamos utilizando por ejemplo la versi\u00f3n 10 de Java, el ordenador en el que queramos ejecutar el programa deber\u00e1 incorporar el JRE al menos de la versi\u00f3n 10.</p> <p>A la forma de producir c\u00f3digo final de Java se la llama JIT (Just In Time,justo en el momento) ya que el c\u00f3digo ejecutable se produce s\u00f3lo en el instante de ejecuci\u00f3n del programa. Es decir, no hay en ning\u00fan momento c\u00f3digo ejecutable.</p> <p>JRE no posee compiladores ni herramientas para desarrollar las aplicaciones Java, solo posee las herramientas para ejecutarlas. JDK es el Java Development Kit o, en espa\u00f1ol, Herramientas de Desarrollo de Java. Sirve para construir programas usando el lenguaje de programaci\u00f3n Java. Trae herramientas \u00fatiles como el compilador (javac), el debugger, herramientas de evaluaci\u00f3n de rendimiento de aplicaciones, etc. Una instalaci\u00f3n de JDK ya contiene un JRE dentro de las carpetas.</p> <p>Para programar en Java, el primer paso que tiene que realizar el alumno es instalarse el JDK de la \u00faltima versi\u00f3n de Java. La descarga la puede efectuar desde la p\u00e1gina web de Oracle https://www.oracle.com/technetwork/java/javase/downloads/index.html/ en la pesta\u00f1a Downloads. Buscar la \u00faltima versi\u00f3n y descargar el JDK del Sistema Operativo con el que el alumno va a trabajar. Pero si al instalar el JDK ya existe una instalaci\u00f3n del JRE en el ordenador de una versi\u00f3n anterior, el JDK no actualizar\u00e1 el JRE a la \u00faltima versi\u00f3n. En este caso, hay que desinstalar primero el JRE y ya despu\u00e9s instalar el JDK de la \u00faltima versi\u00f3n.</p>"},{"location":"bloque_i/tema_1/page-2/#entornos-de-desarrollo-integrado-ide","title":"Entornos de desarrollo integrado (IDE)","text":"<p>El c\u00f3digo en Java se puede escribir en cualquier editor de texto, y para compilar el c\u00f3digo en bytecodes, s\u00f3lo hace falta descargar la versi\u00f3n del JDK deseada. Sin embargo, la escritura y compilaci\u00f3n de programas hecha de esta forma es un poco inc\u00f3moda. Por ello numerosas empresas fabrican sus propios entornos de edici\u00f3n, algunos incluyen el compilador y otras utilizan el propio JDK de Java.</p> <p>Un IDE ( integrated development environment )  es  un  entorno  de  programaci\u00f3n  que  consiste  b\u00e1sicamente en un editor de c\u00f3digo, un compilador y un depurador.</p> <p>Algunas ventajas que ofrecen son</p> <ul> <li>Facilidades  para  escribir  c\u00f3digo:  coloreado  de  las  palabras  clave,  autocorrecci\u00f3n  al  escribir, abreviaturas,...</li> <li>Facilidades de depuraci\u00f3n, para probar el programa.</li> <li>Facilidad de configuraci\u00f3n del sistema.</li> <li>Facilidades para organizar los archivos de c\u00f3digo.</li> <li>Facilidad para exportar e importar proyectos.</li> </ul> <p>Algunos IDEs para programar en Java son Eclipse, Netbeans e IntelliJ IDEA.</p>"},{"location":"bloque_i/tema_1/page-2/#sentencias","title":"Sentencias","text":"<p>Una sentencia es la unidad m\u00ednima de ejecuci\u00f3n de un programa. Un programa se compone de conjunto de sentencias  que  acaban  resolviendo  un  problema.  Al  final  de  cada  una  de  las  sentencias  encontraremos  un punto y coma (<code>;</code>).</p> <p>Veamos algunos ejemplos de sentencias en java:</p> <ul> <li>Sentencias de declaraci\u00f3n:  <code>int x;</code></li> <li>Invocaciones o llamadas a m\u00e9todos de tipo void: <code>System.out.println(\"Bienvenidos a Programaci\u00f3n\");</code></li> <li>Sentencias de control de flujo: alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</li> </ul>"},{"location":"bloque_i/tema_1/page-2/#expresiones","title":"Expresiones","text":"<p>Una  expresi\u00f3n  es  una  combinaci\u00f3n  de  operadores  y  operandos  que  se  eval\u00faa  gener\u00e1ndose  un  \u00fanico resultado de un tipo determinado.</p> <p>La diferencia entre las sentencias y los operadores es que las expresiones devuelven un valor y las sentencias no devuelven nada.</p>"},{"location":"bloque_i/tema_1/page-2/#bloques","title":"Bloques","text":"<p>Un bloque es un conjunto de sentencias las cuales est\u00e1n delimitadas por llaves:</p> <pre><code>{\nsentencias\n}\n</code></pre>"},{"location":"bloque_i/tema_1/page-3/","title":"3 Variables y constantes","text":""},{"location":"bloque_i/tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Las variables son contenedores que sirven para almacenar los datos que utiliza un programa. Dicho m\u00e1s sencillamente, son nombres que asociamos a determinados datos. La realidad es que cada variable ocupa un espacio  en  la  memoria  RAM  del  ordenador  para  almacenar  el  dato  al  que  se  refiere.  Es  decir,  cuando utilizamos el nombre de la variable realmente estamos haciendo referencia a un dato que est\u00e1 en memoria.</p> <p>Las  variables  tienen  un  nombre  (un  identificador)  que  se  escribe  en  min\u00fascula,  y  si  consta  de  varias palabras,  se  utiliza  la  notaci\u00f3n  lowerCamelCase.  Ejemplo:  myFirstVariable.  Adem\u00e1s,  deben  cumplir  lo siguiente:</p> <ul> <li>No deben comenzar con los caracteres guion bajo ( _ ) o el signo de d\u00f3lar ( $ ), aunque ambos se admiten.</li> <li>Se admiten los n\u00fameros pero no como primer car\u00e1cter.</li> <li>Deben ser cortos pero significativos. La elecci\u00f3n de un nombre de variable debe ser mnem\u00f3nico, es decir, dise\u00f1ado para indicar al observador casual la intenci\u00f3n de su uso. Por ejemplo, si queremos usar una variable para almacenar una edad, la llamaremos edad.</li> <li>Se deben evitar los nombres de variables de un solo car\u00e1cter excepto para las variables temporales \"usar y tirar\". Los nombres comunes de las variables temporales son i, j, k, m, y n para enteros; c, d, y e para los caracteres.</li> </ul>"},{"location":"bloque_i/tema_1/page-3/#declaracion-de-variables","title":"Declaraci\u00f3n de variables","text":"<p>Antes de poder utilizar una variable, esta se debe declarar de la siguiente manera: <code>tipo nombreVariable;</code> Donde tipo es el tipo de datos que almacenar\u00e1 la variable (texto, n\u00fameros enteros,...) y nombreVariable es el identificador de la variable. Ejemplos:</p> <pre><code>int days; \nboolean exit;\n</code></pre> <p>Java es un lenguaje muy estricto al utilizar tipos de datos. Variables de datos distintos son incompatibles. Algunos autores hablan de lenguaje fuertemente tipado o incluso lenguaje muy tipificado. Se debe a una traducci\u00f3n muy directa del ingl\u00e9s strongly typed referida a los lenguajes que, como Java, son muy r\u00edgidos en el uso de tipos. El caso contrario ser\u00eda el lenguaje C en el que jam\u00e1s se comprueban de manera estricta los tipos de datos. Parte de le seguridad y robustez de las que hace gala Java se deben a esta caracter\u00edstica.</p> <p>Por convenci\u00f3n de c\u00f3digo, todas las declaraciones de variables se ponen al principio.</p>"},{"location":"bloque_i/tema_1/page-3/#inicializacion-de-variables","title":"Inicializaci\u00f3n de variables","text":"<p>En Java se utiliza el operador asignaci\u00f3n <code>=</code> para inicializar una variable, es decir, para darle un valor inicial.</p> <p>La inicializaci\u00f3n se puede realizar:</p> <ul> <li> <p>En la misma l\u00ednea de c\u00f3digo que la declaraci\u00f3n:</p> <pre><code>int x = 7;\n</code></pre> </li> <li> <p>En cualquier otro momento, pero siempre despu\u00e9s de haberla declarado:</p> <pre><code>int x;\n// ...\nx = 7;\n</code></pre> </li> <li> <p>Tambi\u00e9n se puede utilizar una expresi\u00f3n para asignar un valor a una variable:</p> <pre><code>int x;\n// ...\nx =7;\n//...\nx = x * 2;\n</code></pre> </li> <li> <p>Incluso se puede utilizar una expresi\u00f3n en la misma inicializaci\u00f3n:</p> <pre><code>int a = 13, b = 18;\nint c = a + b;\n</code></pre> </li> <li> <p>Se puede declarar m\u00e1s de una variable a la vez del mismo tipo en la misma l\u00ednea si las separamos con comas:</p> <pre><code>int days, year, weeks;\n</code></pre> </li> <li> <p>Incluso se pueden tambi\u00e9n inicializar:</p> <pre><code>int days = 365, years = 2019, weeks;\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_1/page-3/#ambito-de-vida-de-las-variables","title":"\u00c1mbito de vida de las variables","text":"<p>Toda variable tiene un \u00e1mbito de vida. Esto es la parte del c\u00f3digo en la que una variable se puede utilizar, que es en el bloque donde se ha declarado. De hecho las variables tienen un ciclo de vida:</p> <ol> <li>En la declaraci\u00f3n se reserva el espacio necesario para que se puedan comenzar a utilizar (digamos que se avisa de su futura existencia)</li> <li>Se la asigna su primer valor (la variable nace)</li> <li>Se la utiliza en diversas sentencias. Cuando finaliza el bloque en el que fue declarada, la variable muere. Es decir, se libera el espacio que ocupa esa variable en memoria.</li> <li>Una vez que la variable ha sido eliminada, no se puede utilizar. Dicho de otro modo, no se puede utilizar una variable m\u00e1s all\u00e1 del bloque en el que ha sido definida. Ejemplo:</li> </ol> <pre><code>{ // (1)!\n    int x = 9;\n} // (2)!\nint y = x;\n</code></pre> <ol> <li>Se utiliza <code>{</code> para indicar el comienzo del bloque dde c\u00f3digo</li> <li>Se utiliza <code>}</code> para indicar el fin del bloque de c\u00f3digo</li> </ol>"},{"location":"bloque_i/tema_1/page-3/#constantes","title":"Constantes","text":"<p>Una constante es un valor que no puede ser modificado durante la ejecuci\u00f3n de un programa, \u00fanicamente puede ser le\u00eddo.</p> <p>La forma de declarar constantes es la misma que la de las variables pero hay que anteponer la palabra final que es la que indica que estamos declarando una constante:</p> <pre><code>final double PI = 3.141591;\n</code></pre> <p>Los nombres de las constantes se deben escribir en may\u00fasculas. Pueden contener tambi\u00e9n guiones bajos. Incluso pueden contener d\u00edgitos pero no como primer car\u00e1cter.</p> <p>Ejemplos:</p> <pre><code>final int MAX_PARTICIPANTS = 10;\nfinal int _MIN1 = 1;\n</code></pre> <p>Cuando  un  mismo  valor  se  utilice  en  varias  partes  del  c\u00f3digo,  entonces  hay  que  declararlo  como  una constante ya que si en alg\u00fan momento de la vida de la aplicaci\u00f3n, ese valor var\u00eda, solamente hay que cambiar el valor de la constante y no estar cambi\u00e1ndolo en todos los sitios del c\u00f3digo donde aparezca.</p> Ejercicio 1 <p>Indica cu\u00e1les de los siguientes no son identificadores.</p> <ol> <li>hola</li> <li>\"a\"</li> <li>1nombre</li> <li>mi variable</li> <li>mi_variable</li> <li>esto_es_una_variable</li> <li>nombre1</li> </ol>"},{"location":"bloque_i/tema_1/page-4/","title":"4 Tipos de datos primitivos","text":""},{"location":"bloque_i/tema_1/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Se llaman tipos primitivos a los tipos de datos originales de un lenguaje de programaci\u00f3n, esto es, aquellos que nos proporciona el lenguaje, java posee los siguientes:</p> Tipo de variable Bytes que ocupa Rango de valores boolean 1 true, false char 2 Caracteres en Unicode byte 1 -128 a 127 short 2 -32.768 a 32.767 int 4 -2.147.483.648 a 2.147.483.647 long 8 -9\u00b710<sup>18</sup> a 9\u00b710<sup>18</sup> float 4 -3.4\u00b710<sup>38</sup> a 3.4\u00b710<sup>38</sup> double 8 -3.4\u00b710<sup>308</sup> a 3.4\u00b710<sup>308</sup>"},{"location":"bloque_i/tema_1/page-4/#enteros","title":"Enteros","text":"<p>Los tipos byte, short, int y long sirven para almacenar datos enteros. Los enteros son n\u00fameros sin decimales.</p> <p>Un literal es un elemento de programa que representa directamente un valor:</p> <pre><code>int number = 16; // 16 es un literal\n</code></pre> <p>Los literales se pueden expresar de varias maneras</p> <ul> <li>En decimal, es como se representan por defecto: <code>16</code></li> <li>En binario, anteponiendo 0b: <code>0b10000</code></li> <li>En octal, anteponiendo 0: <code>020</code></li> <li>En hexadecimal, anteponiendo 0x: <code>0x10</code></li> </ul> <p>Por defecto, un literal entero es de tipo int. Si se le coloca detr\u00e1s la letra L, entonces el literal ser\u00e1 de tipo long.</p> <pre><code>int number = 16; //(1)!\nlong number_long = 16L; //(2)!\n</code></pre> <ol> <li>16 es un literal entero</li> <li>16L es un literal de tipo long</li> </ol> <p>No se acepta en general asignar variables de distinto tipo pero existen excepciones. Por ejemplo, si se pueden asignar valores de variables enteras a variables enteras de un tipo superior (por ejemplo, asignar un valor int a una variable long). Pero al rev\u00e9s no se puede:</p> <pre><code>int i = 12;\nbyte b = i; //(1)!\n</code></pre> <ol> <li>Error de compilaci\u00f3n, posible p\u00e9rdida de precisi\u00f3n</li> </ol> <p>La soluci\u00f3n es hacer un casting. Esta operaci\u00f3n permite convertir valores de un tipo a otro tipo, siempre y cuando sea posible:</p> <pre><code>int i = 12;\nbyte b = (byte) i; //(1)!\n</code></pre> <ol> <li>El casting evita el error</li> </ol> <p>Hay que tener en cuenta en estos castings que si el valor asignado sobrepasa el rango del elemento, el valor convertido no tendr\u00e1 ning\u00fan sentido ya que no puede almacenar todos los bits necesarios para representar ese n\u00famero:</p> <pre><code>int i = 1200;\nbyte b = (byte) i; //(1)!\n</code></pre> <ol> <li>El valor de b no tiene sentido</li> </ol> <p>Si lo que asignamos a la variables es un literal, java hace una conversi\u00f3n impl\u00edcita siempre y cuando el literal est\u00e9 dentro del rango permitido para dicho tipo. Por ejemplo, el siguiente c\u00f3digo no da error porque 127 est\u00e1 dentro del rango de los bytes aunque el literal sea por defecto int:</p> <pre><code>byte b = 127;\n</code></pre> <p>Sin embargo, el siguiente c\u00f3digo si da error porque 128 sobrepasa el rango de los tipos byte:</p> <pre><code>byte b = 128; //ERROR\n</code></pre> <p>A partir de Java7, se pueden usar guiones, como separador de miles, para facilitar la lectura al programador:</p> <pre><code>int i = 1_000_000;\n</code></pre> <p>En el siguiente c\u00f3digo de ejemplo, utilizamos <code>System.out.println</code> para escribir en pantalla el valor de las variables:</p> <pre><code>public class Integers {\n    public static void main(String[] args) {\n        int i;\n        long l;\n        byte b;\n        short s;\n\n        i = 16; //(1)!\n        System.out.println(i);\n\n        i = 020; //(2)!\n        System.out.println(i);\n\n        i = 0x10; //(3)!\n        System.out.println(i);\n\n        i = 0b10000; //(4)!\n        System.out.println(i);\n\n        l = 6985742369L; //(5)!\n        System.out.println(l);\n\n        b = 127; //(6)!\n        System.out.println(b);\n\n        s = 32767; //(7)!\n        System.out.println(s);\n\n        i = 1200;\n        System.out.println(i);\n\n        b = (byte) i;\n        System.out.println(b); //(8)!\n\n        System.out.println(1_000_000); //(9)!\n    }\n}\n</code></pre> <ol> <li>16 en decimal</li> <li>20 en octal = 16 decimal</li> <li>10 hexadecimal = 16 decimal</li> <li>10000 binario = 16 decimal</li> <li>Si se le quita la L da error</li> <li>No da error porque est\u00e1 dentro del rango de los bytes aunque su valor por defecto sea int</li> <li>No da error porque est\u00e1 dentro del rango de los shorts aunque su valor por defecto sea int</li> <li>El valor b no tiene sentido</li> <li>Salida por consola: 1000000</li> </ol>"},{"location":"bloque_i/tema_1/page-4/#numeros-decimales","title":"N\u00fameros decimales","text":"<p>Los decimales se almacenan en los tipos float y double. Los decimales no son almacenados de forma exacta por eso siempre hay un posible error y se habla de precisi\u00f3n. Es mucho m\u00e1s preciso el tipo double que el tipo float.</p> <p>Para asignar valores literales a una variable decimal, hay que tener en cuenta que el separador decimal es el punto y no la coma. Es decir para asignar el valor 2,75 a la variable x se har\u00eda: <code>x=2.75;</code></p> <p>A un valor literal (como 1.5 por ejemplo), se le puede indicar con una f al final del n\u00famero que es float (1.5f por ejemplo) o una d para indicar que es double. Si no se indica nada, un n\u00famero literal siempre se entiende que es double, por lo que al usar tipos float hay que convertir los literales:</p> <pre><code>double d = 3.49; //(1)!\nfloat f = 3.49f; //(2)!\n</code></pre> <ol> <li>El literal 3.49 por defecto es double</li> <li>El literal 3.49 se tiene que convertir a float</li> </ol> <p>L\u00f3gicamente no podemos asignar valores decimales a tipos de datos enteros:</p> <pre><code>int x = 9.5; //Error\nint x = (int) 9.5;//(1)!\n</code></pre> <ol> <li>Podemos mediante un casting, pero perderemos los decimales. En este caso, x valdr\u00e1 9.</li> </ol> <p>El caso contrario, sin embargo, si se puede haceR:</p> <pre><code>int x = 9;\ndouble y = z;\n</code></pre> <p>La raz\u00f3n es que los tipos decimales son m\u00e1s grandes que los enteros, por lo que no hay problema de p\u00e9rdida de valores.</p>"},{"location":"bloque_i/tema_1/page-4/#booleanos","title":"Booleanos","text":"<p>Los valores booleanos o l\u00f3gicos se almacenan en el tipo boolean. Sirven para indicar si algo es verdadero (true) o falso (false).</p> <p>Por otro lado, a diferencia del lenguaje C, no se puede en Java asignar n\u00fameros a una variable booleana (en C, el valor false se asocia al n\u00famero 0, y cualquier valor distinto de cero se asocia a true). Tampoco tiene sentido asignar valores de otros tipos de datos a variables booleanas mediante casting:</p> <pre><code>boolean b = (boolean) 9; // no tiene sentido\n</code></pre>"},{"location":"bloque_i/tema_1/page-4/#caracteres","title":"Caracteres","text":"<p>Los valores de tipo car\u00e1cter sirven para almacenar s\u00edmbolos de escritura. En Java se puede almacenar cualquier c\u00f3digo Unicode en el tipo char.</p> <p>Los literales car\u00e1cter van entre comillas simples, como por ejemplo: <code>'a'</code>.</p> <p>En programaci\u00f3n, secuencias de escape es el conjunto de caracteres que en el c\u00f3digo es interpretado con alg\u00fan fin. En Java, la barra invertida <code>\\</code> se denomina car\u00e1cter de escape, el cual indica que el car\u00e1cter puesto a continuaci\u00f3n ser\u00e1 convertido en car\u00e1cter especial o, si ya es especial, dejar\u00e1 de ser especial. Por ejemplo, si el car\u00e1cter <code>n</code> no es especial pero con la <code>\\</code> delante se convierte en especial ya que <code>\\n</code> se interpreta como un salto de l\u00ednea. La <code>\\</code> es un car\u00e1cter especial pero con otra <code>\\</code> delante deja de ser especial y simplemente es una barra invertida.</p> Car\u00e1cter Significado \\t Tabulador \\n Salto de l\u00ednea \" Dobles comillas ' Comillas simples \\ Barra invertida \\udddd Representa el car\u00e1cter Unicode cuyo c\u00f3digo es representado por dddd en hexadecimal <p>Como se vio en el apartado Introducci\u00f3n, la descripci\u00f3n completa del est\u00e1ndar Unicode est\u00e1 disponible en la p\u00e1gina web https://unicode.org/. En dicha p\u00e1gina, encontramos las tablas de caracteres en hexadecimal en el enlace Code Charts. Para saber saber el c\u00f3digo de los caracteres en decimal, podemos acceder al siguiente enlace: https://unicode-table-com/es. Los caracteres imprimibles son del 32 al 126 y del 161 al 255.</p> <p>Para insertar el c\u00f3digo caracteres no disponibles en el teclado, se hace de manera diferente seg\u00fan el Sistema Operativo:</p> <ul> <li>Linux: Ctrl+Shift y luego se pulsa u(para indicar que es Unicode) y el c\u00f3digo Unicode en hexadecimal en el teclado num\u00e9rico desactivado.</li> <li>Windows: Alt y el c\u00f3digo Unicode en hexadecimal.</li> </ul> <p>Tambi\u00e9n se le puede asignar a una variable de tipo char un car\u00e1cter Unicode, ya sea usando el c\u00f3digo decimal o hexadecimal del car\u00e1cter.</p> <pre><code>public class Characters {\n    public static void main(String[] args) {\n        char character;\n\n        character = 'C'; //(1)!\n        System.out.println(character);\n\n        character = 67; // (2)!\n        System.out.println(character);\n\n        character = '\\u0043'; // (3)!\n        System.out.println(character);\n\n        character = '\\n'; // (4)!\n        System.out.println(character);\n\n        character = '\\''; // (5)!\n        System.out.println(character);\n\n        character = '\\\"'; // (6)!\n        System.out.println(character);\n\n        character = '\"'; // (7)!\n        System.out.println(character);\n\n        character = '\\\\'; // (8)!\n        System.out.println(character);\n\n        character = 9752; // (9)!\n        System.out.println(character);\n\n        character = '\\u2618'; // (10)!\n        System.out.println(character);\n\n        character = '\u2618'; // (11)!\n        System.out.println(character);\n    }\n}\n</code></pre> <ol> <li>Los literales car\u00e1cter van entre comillas simples</li> <li>El c\u00f3digo Unicode de la C es el 67</li> <li>El c\u00f3digo Unicode de la C en hexadecimal es el 0043</li> <li>Car\u00e1cter especial salto de l\u00ednea</li> <li>Car\u00e1cter especial Comillas Simples</li> <li>Car\u00e1cter especial Comillas Dobles</li> <li>Car\u00e1cter especial comillas dobles se puede utilizar sin el car\u00e1cter de escape en un literal de car\u00e1cter</li> <li>Car\u00e1cter especial barra inclinada</li> <li>C\u00f3digo decimal del car\u00e1cter tr\u00e9bol</li> <li>C\u00f3digo hexadecimal del car\u00e1cter tr\u00e9bol</li> <li>Car\u00e1cter tr\u00e9bol</li> </ol> <p>Si necesitamos almacenar m\u00e1s de un car\u00e1cter, entonces debemos usar otro tipo de datos que nos permite manejar cadenas de caracteres: String.</p> Ejercicio 1 <p>Muestra en consola los siguientes caracteres</p> <ol> <li>\u2764</li> <li>\u2602</li> <li>\u260e</li> <li>\u265e</li> </ol> <p>En Java, las cadenas no se modelan como un dato de tipo primitivo, sino a trav\u00e9s de la clase String. El texto es uno de los tipos de datos m\u00e1s importantes y por ello java lo trata de manera especial. Para Java, las cadenas de texto son objectos especiales. Los textos deben manejarse creando objetos de tipo String.</p> <p>Los literales cadena se escriben entre comillas dobles: <code>\"Esto es un literal cadena</code>\".</p> <p>Ejemplo:</p> <pre><code>String s = \"Estamos aprendiendo a programar\";\n</code></pre> <p>En Java existe tambi\u00e9n la cadena vac\u00eda o nula(\"\"), es decir, una cadena sin ning\u00fan car\u00e1cter. Ejemplo: <code>String s = \"\";</code> A la variable s se le est\u00e1 asignando la cadena vac\u00eda o nula.</p> Ejercicio 2 <p>Sea MAX una constante que vale 1000, a,b e i variables enteras, x una variable decimal, c una variable car\u00e1cter y s una variable cadena. Indicar las sentencias v\u00e1lidas y su valor, razonando la respuesta. Suponer que a = 3 y b = 4.</p> <ol> <li>i = (900 - MAX) / a</li> <li>i = b / 0</li> <li>i = a % (MAX - 900)</li> <li>i = (MAX - 900) % a</li> <li>i = 3.34 * a</li> <li>x = a / b</li> <li>x = a % (a / b)</li> <li>i = a / b</li> <li>i = ++a</li> <li>i = a++</li> <li>c = '''</li> <li>c = '\"'</li> <li>s = 'c'</li> <li>s = \"'\"</li> <li>s = \"\"\"</li> <li>c = '\\u0041'</li> <li>c = 65</li> </ol>"},{"location":"bloque_i/tema_1/page-5/","title":"5 Operadores","text":""},{"location":"bloque_i/tema_1/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Un operador lleva a cabo operaciones sobre uno (operador unario), dos (operador binario) o tres (operador ternario) datos u operandos de tipo primitivo devolviendo un valor determinado tambi\u00e9n de un tipo primitivo. El tipo de valor devuelto tras la evaluaci\u00f3n depende del operador y del  tipo  de  los  operandos.  Por  ejemplo,  los  operadores  aritm\u00e9ticos  trabajan  con  operandos num\u00e9ricos,  llevan  a  cabo  operaciones  aritm\u00e9ticas  b\u00e1sicas  y  devuelven  el  valor  num\u00e9rico correspondiente. Los operadores se pueden clasificar en distintos grupos seg\u00fan se muestra en los siguientes apartados</p>"},{"location":"bloque_i/tema_1/page-5/#operador-asignacion","title":"Operador asignaci\u00f3n","text":"<p>El operador asignaci\u00f3n <code>=</code> es un operador binario que asigna el valor del t\u00e9rmino de la derecha al operando de la izquierda. El operando de la izquierda es una variable. El t\u00e9rmino de la derecha es una expresi\u00f3n de un tipo de dato compatible.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo = Operador asignaci\u00f3n n = 4 n vale 4 <p>No debe confundirse el operador asignaci\u00f3n (=) con el operador relacional de igualdad (==) que se ver\u00e1 m\u00e1s adelante. Adem\u00e1s Java dispone de otros operadores que combinan la asignaci\u00f3n con otras operaciones (operadores aritm\u00e9ticos combinados).</p>"},{"location":"bloque_i/tema_1/page-5/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>El lenguaje de programaci\u00f3n Java tiene varios operadores aritm\u00e9ticos para los datos num\u00e9ricos enteros y decimales.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo - Operador unario de cambio de signo -4 -4 + Suma 2.5 + 7.1 9.6 - Resta 235.6 - 103.5 132.1 * Multiplicaci\u00f3n 1.2 * 1.1 1.32 / Divisi\u00f3n 0.050 / 0.027 / 2 0.253 % M\u00f3dulo 20 % 714.5 % 2 60.5 <p>El resultado exacto depende de los tipos de operandos involucrados. Es conveniente tener en cuenta las siguientes peculiaridades:</p> <ul> <li> <p>El resultado de una expresi\u00f3n se convierte al tipo m\u00e1s general seg\u00fan el siguiente orden de generalidad:     byte \u2192 short \u2192 int \u2192 long \u2192 float \u2192 double     Teniendo esto en cuenta, tenemos que:</p> <ul> <li>El resultado es de tipo long si, al menos, uno de los operandos es de tipo long y ninguno es decimal. </li> <li>El resultado es de tipo int si ninguno de los operandos es de tipo long ni decimal.</li> <li>El resultado es de tipo double si, al menos, uno de los operandos es de tipo double.</li> <li>El resultado es de tipo float si, al menos, uno de los operandos es de tipo float y ninguno es double.</li> </ul> </li> <li> <p>Con  los  n\u00fameros  enteros,  si  se  divide  entre  cero,  se  genera  la  excepci\u00f3n ArithmeticException. Pero si se realiza la divisi\u00f3n entre cero con decimales, el resultado es infinito (<code>Infinity</code>).</p> </li> <li>El resultado de una expresi\u00f3n inv\u00e1lida, por ejemplo, dividir infinito por infinito, no genera una excepci\u00f3n ni un error de ejecuci\u00f3n: es un valor Not a Number (<code>NaN</code>).</li> </ul> <pre><code>public class ArithmeticOperators {\n    public static void main(String[] args) {\n        int int1 = 100, int2 = 0;\n        double dec1 = 20.36, dec2 = 0;\n\n        System.out.println(int1 / int2); //(1)!\n        System.out.println(dec1 / dec2); //(2)!\n        System.out.println(dec1 % dec2); //(3)!\n    }\n}\n</code></pre> <ol> <li>Genera ArithmeticException</li> <li>Infinity</li> <li>NaN</li> </ol> <p>Hay que tener en cuenta que el resultado de estos operadores var\u00eda notablemente si usamos enteros o si usamos n\u00fameros decimales. Por ejemplo:</p> <pre><code>double result1, d1 = 14, d2 = 5;\nint result2, i1 = 14, i2 = 5;\nresult1 = d1 / d2; // result1 = 2.8\nresult2 = i1 / i2; // result2 = 2\n</code></pre> <p>Es m\u00e1s incluso:</p> <pre><code>double result;\nint i1 = 7, i2 = 2;\nresult = i1 / i2; // resultado = 3.0\nresult = (double) i1 / i2; // resultado 3.5\n</code></pre> <p>El operador del m\u00f3dulo (<code>%</code>) sirve para calcular el resto de una divisi\u00f3n tanto entera como decimal.</p> <pre><code>int remainder, i1 = 14, i2 = 5;\nremainder = i1 % i2; // remainder = 4\n</code></pre> <p>En los decimales, el resto se calcula asumiendo que la divisi\u00f3n produce un resultado entero:</p> <pre><code>double remainder, d1 = 7.5, d2 = 2;\nremainder = d1 % d2; // remainder = 1.5\n</code></pre>"},{"location":"bloque_i/tema_1/page-5/#operadores-aritmeticos-incrementales","title":"Operadores aritm\u00e9ticos incrementales","text":"<p>Los  operadores  aritm\u00e9ticos  incrementales  son  operadores  unarios  (un  \u00fanico  operando).  El operando puede ser num\u00e9rico o de tipo char y el resultado es del mismo tipo que el operando.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo ++ Incremento 4++ 5 -- Decremento 4-- 3 <p>En el caso de los caracteres, el incremento/decremento se realiza a su c\u00f3digo Unicode. Es decir, si  una  variable  char  tiene  el  valor  'C',  su  c\u00f3digo  Unicode  es  67.  Si  se  incrementa,  su  c\u00f3digo Unicode pasa a valer 68 que corresponde al valor 'D'.</p> <p>Estos operadores pueden emplearse de dos formas dependiendo de su posici\u00f3n con respecto al operando:</p> <ul> <li>si  el  operador  est\u00e1  detr\u00e1s  del  operando,  primero  se  utiliza  la  variable  y  luego  se incrementa/decrementa su valor:<ul> <li>Post-incremento: a++</li> <li>Post-decremento: a- -</li> </ul> </li> <li>si el operador est\u00e1 delante del operando, primero se incrementa/decrementa el valor de la variable y luego se utiliza.<ul> <li>Pre-incremento: ++a</li> <li>Pre-decremento: - -a</li> </ul> </li> </ul> <pre><code>public class IncrementalArithmeticOperators {\n    public static void main(String[] args) {\n\n        int integer1, integer2;\n        char character1, character2;\n        character1 = 'C'; //(1)!\n        character1++;\n        System.out.println(character1); //(2)!\n\n        //(3)!\n\n        character2 = (char) (character1 + 6);\n        System.out.println(character2); //(4)!\n\n        integer1 = character2 + 2;\n        System.out.println(integer1); //(5)!\n\n        character2++;\n        System.out.println(character2); //(6)!\n\n        integer1 = character2;\n        System.out.println(integer1); //(7)!\n\n        integer1 = 5;\n        integer2 = integer1++;\n        System.out.println(integer1); //(8)!\n        System.out.println(integer2); //(9)!\n\n        integer1 = 5;\n        integer2 = ++integer1;\n        System.out.println(integer1); //(10)!\n        System.out.println(integer2); //(11)!\n    }\n}\n</code></pre> <ol> <li>Unicode 67</li> <li>Al incrementarse vale 'D', Unicode 68</li> <li>Tambi\u00e9n se pueden utilizar los caracteres con los operadores aritm\u00e9ticos, pero entonces hace falta usar casting</li> <li>character2 vale 'J', Unicode 74</li> <li>integer1 vale 76</li> <li>character2 vale 'K', Unicode 75</li> <li>integer1 vale 75</li> <li>integer1 vale 6</li> <li>integer2 vale 5</li> <li>integer1 vale 6</li> <li>integer2 vale 6</li> </ol>"},{"location":"bloque_i/tema_1/page-5/#operadores-aritmeticos-combinados","title":"Operadores aritm\u00e9ticos combinados","text":"<p>Combinan  un  operador  aritm\u00e9tico  con  el  operador  asignaci\u00f3n.  Como  en  el  caso  de  los operadores  aritm\u00e9ticos,  pueden  tener  operandos  num\u00e9ricos  enteros  o  decimales  y  el  tipo espec\u00edfico del resultado num\u00e9rico depender\u00e1 del tipo de \u00e9stos.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo += Suma combinada a+=b a=a+b -= Resta combinada a-=b a=a-b *= Multiplicaci\u00f3n combinada a*=b a=a*b /= Divisi\u00f3n combinada a/=b a=a/b %= Resto combinado a%=b a=a%b <p>Tambi\u00e9n se pueden utilizar con caracteres:</p> <pre><code>char character='a';\ncharacter+=2; //character vale 'c'\n</code></pre>"},{"location":"bloque_i/tema_1/page-5/#operadores-relacionales","title":"Operadores relacionales","text":"<p>Realizan  comparaciones  entre  datos  compatibles  de  tipos  primitivos  (num\u00e9ricos,  car\u00e1cter  y booleanos)  teniendo  siempre  un  resultado  booleano.  Los  operandos  booleanos  s\u00f3lo  pueden emplear los operadores de igualdad y desigualdad.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo == Igual que 7 == 3 false != Distinto que 'a' != 'k' true &lt; Menor que 'G' &lt; 'B' false &gt; Mayor que 'b' &gt; 'a' true &lt;= Menor o igual que 7.5 &lt;= 7.38 false &gt;= Mayor o igual que 38 &gt;= 7 true"},{"location":"bloque_i/tema_1/page-5/#operadores-logicos-o-booleanos","title":"Operadores l\u00f3gicos o booleanos","text":"<p>Las puertas l\u00f3gicas son circuitos electr\u00f3nicos capaces de realizar operaciones l\u00f3gicas b\u00e1sicas:</p> <ul> <li> <p>Puerta NOT: la salida es la inversa de la entrada. Se corresponde con la siguiente tabla de verdad:</p> A (entrada) S (salida) 0 1 1 0 </li> <li> <p>Puerta AND:  la  se\u00f1al  de  salida  se  activa  solo  cuando  se  activan  todas  las  se\u00f1ales  de entrada. Equivale al producto l\u00f3gico S = A \u00b7 B y se corresponde con la siguiente tabla de verdad:</p> A (entrada1) B (entrada 2) S (salida) 0 0 0 0 1 0 1 0 0 1 1 1 </li> <li> <p>Puerta OR: la salida se activa cuando cualquiera de las entradas est\u00e1 activada. Equivale a la suma l\u00f3gica S = A + B y se corresponde con la siguiente tabla de verdad:</p> A (entrada1) B (entrada 2) S (salida) 0 0 0 0 1 1 1 0 1 1 1 1 </li> </ul> <p>Los operadores l\u00f3gicos o booleanos realizan operaciones sobre datos booleanos y tienen como resultado un valor booleano:</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo ! Negaci\u00f3n - NOT (unario) !false!(5 == 5) truefalse || Suma l\u00f3gica - OR (binario) true || false(5 == 5) || (5 &lt; 4) truetrue &amp;&amp; Producto l\u00f3gico - AND (binario) false &amp;&amp; true(5 == 5) &amp;&amp; (5 &lt; 4) falsefalse <p>El producto l\u00f3gico se realiza con cortocircuito, es decir, si el primer operando es false entonces el segundo operando no se eval\u00faa ya que el resultado va a ser de todas maneras false. En este caso es conveniente situar la condici\u00f3n m\u00e1s propensa a ser falsa en el t\u00e9rmino de la izquierda.</p> <p>La suma l\u00f3gica tambi\u00e9n  se  realiza  con  cortocircuito,  es  decir,  si  el  primer  operando  es  true entonces el segundo operando no se eval\u00faa ya que el resultado va a ser de todas maneras true. En este caso es conveniente colocar la condici\u00f3n m\u00e1s propensa a ser verdadera en el t\u00e9rmino de la izquierda.</p> <p>Estas t\u00e9cnicas reducen el tiempo de ejecuci\u00f3n del programa y ayudan al programador a evitar ciertos  errores.  Por  ejemplo,  <code>5/b==2</code> , si b es  una  variable  de  tipo  entero y  su  valor es 0,  se genera la excepci\u00f3n ArithmeticException. Para evitar este problema, el programador puede hacer lo siguiente: <code>b!=0 &amp;&amp; 5/b==2</code>.Si b contiene el valor 0, <code>b!=0</code> dar\u00e1 false, entonces <code>5/b==2</code> no se eval\u00faa, evitando as\u00ed la generaci\u00f3n de la excepci\u00f3n.</p> <p>Ejemplos de uso de operadores l\u00f3gicos o booleanos:</p> <pre><code>boolean adult, younger;\nint age = 21;\nadult = age &gt;= 18; //adult ser\u00e1 true\nyounger = !adult; //younger ser\u00e1 false\n</code></pre> <pre><code>boolean drivingLicense=true;\nint age=20;\nboolean canDrive= (age&gt;=18) &amp;&amp; drivingLicense;\n/*Si la edad es de al menos 18 a\u00f1os y tiene carnet de conducir,\n  entonces puede conducir*/\n</code></pre> <pre><code>boolean snow =true, rain=false, hail=false;\nboolean badWeather= snow || rain || hail;\n//Si nieva o llueve o graniza, hace mal tiempo\n</code></pre>"},{"location":"bloque_i/tema_1/page-5/#operador-condicional","title":"Operador condicional","text":"<p>Este operador ternario permite devolver valores en funci\u00f3n de una expresi\u00f3n l\u00f3gica. Su sintaxis es la siguiente:</p> <p><code>expresionLogica ? expresion_1 : expresion_2</code></p> <p>Si el resultado de evaluar la expresi\u00f3n l\u00f3gica es verdadero, devuelve el valor de la primera expresi\u00f3n, y en caso contrario, devuelve el valor de la segunda expresi\u00f3n.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo ?: Operador condicional a = 4;b = a == 4 ? a+5 : 6-a;b = a &gt; 4 ? a*7 : a+8; b vale 9 b vale 12 <p>Ejemplo:</p> <pre><code>pay = (age &gt; 18) ? 6000 : 3000;\n</code></pre> <p>En este caso, si la variable edad es mayor de 18, la paga ser\u00e1 de 6000, sino ser\u00e1 de 3000.</p>"},{"location":"bloque_i/tema_1/page-5/#operador-de-concatenacion-de-cadenas","title":"Operador de concatenaci\u00f3n de cadenas","text":"<p>El operador concatenaci\u00f3n <code>+</code> es un operador binario que devuelve una cadena resultado de concatenar dos cadenas que act\u00faan como operando. Si solo uno de los operandos es de tipo cadena, el otro se convierte impl\u00edcitamente en tipo cadena.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo + Operador concatenaci\u00f3n \"Hola\" + \"Juan\"\"Hola\" + 5 \"HolaJuan\"\"Hola5\""},{"location":"bloque_i/tema_1/page-5/#operador-a-nivel-de-bits","title":"Operador a nivel de bits","text":"<p>Manipulan los bits de los n\u00fameros.</p> Operador Descripci\u00f3n &amp; AND | OR ~ NOT ^ XOR &gt;&gt; Desplazamiento a la derecha &lt;&lt; Desplazamiento a la izquierda &gt;&gt;&gt;&gt; Desplazamiento a la derecha con relleno de ceros &lt;&lt;&lt;&lt; Desplazamiento a la izquierda con relleno de ceros Ejercicio <p>De las siguientes asignaciones, \u00bfcu\u00e1les son v\u00e1lidas? \u00bfCu\u00e1l es el efecto de su ejecuci\u00f3n? \u00bfDe qu\u00e9 tipo deben ser las variables?</p> <ol> <li>z = 2 &lt; 1</li> <li>a = a + 1</li> <li>sqrt(3) = 32717</li> <li>'x' = 'y'</li> <li>x = 'y'</li> <li>a = b</li> <li>precio = precio - precio * (30/100)</li> </ol>"},{"location":"bloque_i/tema_1/page-6/","title":"6 Sentencias y Expresiones","text":""},{"location":"bloque_i/tema_1/page-6/#sentencias","title":"Sentencias","text":"<p>Una sentencia es la unidad m\u00ednima de ejecuci\u00f3n de un programa. Un programa se compone de un  conjunto  de  sentencias  que  acaban  resolviendo  un  problema.  Al  final  de  cada  una  de  las sentencias encontraremos un punto y coma (<code>;</code>).</p> <p>Veamos algunos ejemplos de sentencias en java:</p> <ul> <li>Sentencias de declaraci\u00f3n:  int x;</li> <li>Invocaciones o llamadas a m\u00e9todos de tipo void: <code>System.out.println(\"Bienvenidos a Programaci\u00f3n\");</code></li> <li>Sentencias de control de flujo: alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</li> </ul>"},{"location":"bloque_i/tema_1/page-6/#expresiones","title":"Expresiones","text":"<p>Una expresi\u00f3n es una combinaci\u00f3n de operadores y operandos que se eval\u00faa gener\u00e1ndose un \u00fanico resultado de un tipo determinado.</p> <p>La diferencia entre las sentencias y las expresiones es que las expresiones devuelven un valor y las sentencias no devuelven nada.</p>"},{"location":"bloque_i/tema_1/page-6/#prioridad-entre-operadores","title":"Prioridad entre operadores","text":"<p>A veces hay expresiones con operadores que resultan confusas. Por ejemplo:</p> <p><code>resultado=8+4/2;</code></p> <p>Es  dif\u00edcil  saber  el  resultado.  \u00bfCu\u00e1l  es?  \u00bfseis  o  diez?  La  respuesta  es  10  y  la  raz\u00f3n  es  que  el operador de divisi\u00f3n siempre precede en el orden de ejecuci\u00f3n al de la suma. Es decir, siempre se ejecuta antes la divisi\u00f3n que la suma. Siempre se pueden usar par\u00e9ntesis para forzar el orden deseado:</p> <p><code>resultado=(8+4)/2;</code></p> <p>Ahora no hay duda, el resultado es seis.</p> <p>\u00bfC\u00f3mo podemos saber en qu\u00e9 orden se van a ejecutar los operadores en una expresi\u00f3n en Java? Pues se ejecutan en funci\u00f3n de una prioridad, es decir, primero se ejecuta el que tenga m\u00e1s prioridad. La siguiente tabla muestra todos los operadores Java ordenados de mayor a menor prioridad. La primera l\u00ednea de la tabla contiene los operadores de mayor prioridad y la \u00faltima los de menor prioridad. Los operadores que aparecen en la misma l\u00ednea tienen la misma prioridad.</p> <p>Cuando una expresi\u00f3n tenga dos operadores con la misma prioridad, la expresi\u00f3n se eval\u00faa seg\u00fan su asociatividad.</p> Nivel Operador Descripci\u00f3n Asociatividad 1 [].() acceso elementos arrayacceso miembros objetospar\u00e9ntesis de izquierda a derecha 2 ++-- unario post-incrementounario post-incremento no asociativos 3 ++--+-!~ unario pre-incrementounario pre-decrementounario m\u00e1sunario menosunario l\u00f3gico NOTunario NOT a nivel de bits de derecha a izquierda 4 ()new castcreaci\u00f3n objetos de derecha a izquierda 5 */% multiplicaci\u00f3ndivisi\u00f3nm\u00f3dulo de izquierda a derecha 6 +-+ sumarestaconcatenaci\u00f3n cadenas de izquierda a derecha 7 &lt;&lt;&gt;&gt;&gt;&gt;&gt; desplazamiento a nivel de bits de izquierda a derecha 8 &lt;&lt;=&gt;&gt;=instanceof relacionales no asociativos 9 ==!= igualdistinto de izquierda a derecha 10 &amp; AND nivel de bits de izquierda a derecha 11 ^ XOR nivel de bits de izquierda a derecha 12 | OR nivel de bits de izquierda a derecha 13 &amp;&amp; AND de izquierda a derecha 14 || OR de izquierda a derecha 15 ?: ternario condicional de derecha a izquierda 16 =+=-=*=/=%=&amp;=^|=&lt;&lt;&lt;=&gt;&gt;=&gt;&gt;= asignaciones de derecha a izquierda <p>Por ejemplo:<code>resultado = 9 / 3 * 3;</code> En este caso, la multiplicaci\u00f3n y la divisi\u00f3n tienen la misma prioridad y su asociatividad es de izquierda a derecha por lo que se realiza primero la operaci\u00f3n que est\u00e9 m\u00e1s a la izquierda, que en este caso es la divisi\u00f3n. El resultado por lo tanto es nueve.  Si  se  desea  que  se  haga  primero  la  multiplicaci\u00f3n,  habr\u00eda  que  utilizar  un  par\u00e9ntesis: <code>resultado = 9 / (3 * 3);</code> En este caso, el resultado ser\u00eda 1.</p> <p>Otro  ejemplo: <code>x  =  y  =  z  =  17;</code> Como  la  asociatividad  de  la  asignaci\u00f3n  es  de  derecha a izquierda, primero se asigna el valor 17 a <code>z</code>, luego a <code>y</code> y por \u00faltimo a <code>x</code>.Esto se puede realizar porque el operador de asignaci\u00f3n devuelve el valor asignado.</p> <p>Algunos operadores son no asociativos, por ejemplo, la expresi\u00f3n  <code>x &lt;= y &lt;= z</code> es inv\u00e1lida ya que  el  valor  devuelto  por  estos  operadores  es  de  un  tipo  diferente  (booleano)  al  de  los operandos que necesita (num\u00e9rico o car\u00e1cter).</p>"},{"location":"bloque_i/tema_1/page-6/#evaluacion-de-cortocircuito","title":"Evaluaci\u00f3n de cortocircuito","text":"<p>La evaluaci\u00f3n de cortocircuito denota la sem\u00e1ntica de algunos operadores booleanos en algunos lenguajes  de  programaci\u00f3n  en  los  cuales  si  con  la  evaluaci\u00f3n  de  la  primera  expresi\u00f3n  ya  se conoce el resultado, ya no se eval\u00faan el resto de expresiones. En Java, se utiliza la evaluaci\u00f3n de cortocircuito.</p> <p>Por ejemplo, veamos la siguiente expresi\u00f3n que utiliza operadores <code>AND</code>:</p> <pre><code>12 &lt; 9 &amp;&amp; 5 &gt; 1 &amp;&amp; 8 &lt;= 13\n</code></pre> <p>Se  eval\u00faa  la  primera  expresi\u00f3n <code>12  &lt;  9</code>   dando  false.  Como  el  resultado  va  a  ser  false independientemente del resultado de la segunda y tercera expresi\u00f3n, entonces no se eval\u00faan ni la segunda <code>5 &gt; 1</code> ni la tercera expresi\u00f3n <code>8&lt;= 13</code>, sino que solamente se eval\u00faa la primera, dando como resultado false. Lo mismo ocurre con el operador <code>OR</code>:</p> <pre><code>8 &lt;= 13 || 12 &lt; 9 || 5 &gt; 1\n</code></pre> <p>Se  eval\u00faa  la  primera  expresi\u00f3n <code>8  &lt;=  13</code>   dando true.  Como  el  resultado  va  a  ser  true independientemente del resultado de la segunda y tercera expresi\u00f3n, entonces no se eval\u00faan ni la segunda <code>12 &lt; 9</code> ni la tercera expresi\u00f3n <code>5 &gt; 1</code>, sino que solamente se eval\u00faa la primera, dando como resultado true.</p> Ejercicio 1 <p>Suponiendo realizadas las siguientes sentencias de asignaci\u00f3n: lado1 = 3; precio = 325,6; lado2 = 4; comprar = false; hipotenusa = 5; ch = '7'. Determinar cu\u00e1les de las expresiones siguientes dan un resultado booleano y cu\u00e1les no. Para aquellas que produzcan un resultado booleano determinar si el resultado es verdadero o falso. Para las que no lo sean, explicar la raz\u00f3n. Indicar tambi\u00e9n si existe alguna expresi\u00f3n err\u00f3nea, y crea una aplicaci\u00f3n Java para comprobar los resultados.</p> <ol> <li>5 * precio - 1.50</li> <li>(precio &lt; 300 + 0.1 * precio) ||comprar</li> <li>sqrt(lado1) + sqrt(lado2) = sqrt(hipotenusa)</li> <li>(!comprar) &amp;&amp; (precio + 125.3)</li> <li>(ch &lt;= 'A') &amp;&amp; comprar</li> <li>ch = '7' || !comprar</li> </ol> Ejercicio 2 <p>Calcula el resultado de las siguientes expresiones de forma manual, y luego creando un programa JAVA:</p> <ol> <li>3 * 5 - 4 / 2</li> <li>3 - (3*5)<sup>2</sup> / 4</li> <li>3<sup>2</sup> - 5 * 2</li> <li>7 - 4 * 2 - 5 * 2</li> <li>5 + 4 &lt; 7 + 8</li> <li>4 &lt; 5 * 4 / 2 - 7</li> <li>3 + 6 * 14</li> <li>8 + 7 * 3 + 4 * 6</li> <li>-4 * 7 + 2<sup>3</sup> / 4 - 5</li> <li>12 + 3 * 7 + 5 * 4</li> <li>!(4 &gt; 6)</li> <li>7<sup>3</sup> / 2 + 6</li> </ol> Ejercicio 3 <p>Dados los siguientes valores para las variables booleanas a,b y c (a = true, b = false y c = true), evaluar las expresiones que aparecen a continuaci\u00f3n y crear un programa JAVA para comprobar las soluciones:</p> <ol> <li>a &amp;&amp; b || a &amp;&amp; c</li> <li>(a || b) &amp;&amp; (!a || c)</li> <li>a || b &amp;&amp; c</li> <li>!(a || b) &amp;&amp; c</li> </ol> Ejercicio 4 <p>Dado los siguientes valores de las variables x, y, j y k, a\u00f1adir los par\u00e9ntesis que sean necesarios para que las expresiones que las siguen eval\u00faen a verdadero: x = 10; y = 19; j = true; k = false.</p> <ol> <li>x == y || j</li> <li>x &gt;= y || x &lt;=y &amp;&amp; j</li> <li>!j || j</li> <li>!k &amp;&amp; k</li> </ol> Ejercicio 5 <p>Sea n un dato de tipo Entero que suponemos positivo. Empareja las expresiones con la descripci\u00f3n que les corresponda:</p> <p>a) El mayor n\u00famero par no superior a n.</p> <p>b) El primer n\u00famero par mayor o igual que n</p> <p>c) El primer impar mayor o igual que n</p> <p>1) (n / 2)*2</p> <p>2) n + (n+1) % 2</p> <p>3) ((n+1)/2)*2</p>"},{"location":"bloque_i/tema_1/page-7/","title":"7 Introducci\u00f3n a las funciones","text":""},{"location":"bloque_i/tema_1/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ol> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ol>"},{"location":"bloque_i/tema_1/page-7/#construccion","title":"Construcci\u00f3n","text":"<p>Una funci\u00f3n se construye de la siguiente manera:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro\nnombre_par\u00e1metro, ... ) {\n   instrucciones\n   return expresi\u00f3n;\n}\n</code></pre> <ul> <li>modificador_acceso: es la visibilidad que posee la funci\u00f3n (Lo veremos m\u00e1s adelante. De momento, lo utilizaremos como public).</li> <li>tipo_resultado: es el tipo del resultado que devuelve la funci\u00f3n.</li> <li>nombre_funci\u00f3n:  es  el  nombre  que  identifica  a  la  funci\u00f3n.  Utiliza  la  notaci\u00f3n lowerCamelCase. Ejemplo: imprimirResultadoDecimal.</li> <li>tipo_par\u00e1metro nombre_par\u00e1metro,...:  puede  ocurrir  que  la  funci\u00f3n  necesite  ciertos valores para efectuar la misi\u00f3n para la que ha sido creada. Por ejemplo, la funci\u00f3n suma necesitar\u00eda  los  valores  que  tiene  que  sumar.  En  este  caso,  se  deben  indicar  cada  uno  de dichos  valores  con  sus  tipos  correspondientes. A  estos  valores  se  les  conoce como par\u00e1metros  de  la  funci\u00f3n.  Si  la  funci\u00f3n  no  necesita  par\u00e1metros,  entonces  solamente se ponen los par\u00e9ntesis:  <code>nombre_funcion( )</code></li> </ul> <p>A todo esto se le conoce como la firma (signature) de la funci\u00f3n:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro\nnombre_par\u00e1metro, ... )\n</code></pre> <ul> <li>instrucciones: instrucciones que conforman el algoritmo de la funci\u00f3n, para que realice la misi\u00f3n para la que ha sido creada.</li> <li>return expresi\u00f3n;: el return es el que nos devuelve el resultado, por lo tanto la expresi\u00f3n que  acompa\u00f1a  al  return  tiene  que  devolver  un  valor  correspondiente  al  tipo_resultado indicado en la firma de la funci\u00f3n.</li> </ul> <p>Ejemplo de funci\u00f3n con dos par\u00e1metros:</p> <pre><code>public static int add(int sum1,int sum2) {\n    return sum1+sum2;\n}\n</code></pre> <p>Puede  ser  tambi\u00e9n  que  haya  m\u00e1s  de  un  return.  En  ese  caso,  el  flujo  de  ejecuci\u00f3n  abandona  la funci\u00f3n en cuanto ejecute el primer return. Ejemplo:</p> <pre><code>public static boolean isPar(int n){\n    if(n%2==0){\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n</code></pre> <p>En  el  caso  de  que  estemos  definiendo  un  procedimiento,  no  tendremos  return  ya  que  no devuelve ning\u00fan resultado y el tipo_resultado es void. Como por ejemplo <code>System.out.println</code>, que escribe en pantalla lo que recibe por par\u00e1metro pero no devuelve nada.</p>"},{"location":"bloque_i/tema_1/page-7/#llamada-a-la-funcion","title":"Llamada a la funci\u00f3n","text":"<p>Una  funci\u00f3n  permite  que  reutilicemos  un  algoritmo  ya  que  se  puede  utilizar  cuando  nos  haga falta.  Para  ello,  solamente  tendremos  que  llamar  a  la  funci\u00f3n  por  su  nombre  y  pasarle  los par\u00e1metros en el mismo orden que se han definido y pertenecientes al mismo tipo de dato. En la llamada, dichos par\u00e1metros se llaman argumentos.</p> <pre><code>public class Functions {\n    public static void main(String[] args) {\n        boolean par;\n        int result;\n        par = isPar(5);//(1)!\n        System.out.println(par);//(2)!\n        par = isPar(4);//(3)!\n        System.out.println(par);//(4)!\n        result = add(5, 2);//(5)!\n        System.out.println(result);//(6)!\n    }\n    public static boolean isPar(int n) {\n        if (n % 2 == 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    public static int add(int sum1, int sum2) {\n        return sum1 + sum2;\n    }\n}\n</code></pre> <ol> <li>Se llama a la funci\u00f3n isPar con un valor de 5 en el argumento</li> <li>Mostrar\u00e1 false</li> <li>Se llama a la funci\u00f3n isPar con un valor de 4 en el argumento</li> <li>Mostrar\u00e1 true</li> <li>Se llama a la funci\u00f3n add con los valores 5 y 2 en los argumentos</li> <li>Mostrar\u00e1 7</li> </ol>"},{"location":"bloque_i/tema_1/page-8/","title":"8 Tipos enumerados simples","text":""},{"location":"bloque_i/tema_1/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Los tipos enumerados sirven para restringir el contenido de una variable a una serie de valores predefinidos. Esto suele ayudar a reducir los errores en nuestro c\u00f3digo.</p> <p>En  las  versiones  anteriores  a  la  versi\u00f3n  5  de  Java  no  exist\u00edan  los  tipos  de  datos  enumerados  con  lo  que deb\u00edamos usar constantes de la siguiente forma:</p> <pre><code>final String RED_COLOR = \"rojo\";\nfinal String GREEN_COLOR = \"verde\";\nfinal String BLUE_COLOR = \"azul\";\n</code></pre> <p>A partir de la versi\u00f3n 5 de Java se incorporaron al lenguaje los tipos de datos enumerados con el objetivo de mejorar varios aspectos sobre el uso de las constantes. B\u00e1sicamente, un enumerado en Java es un conjunto fijo  y  relacionado  de  constantes  y deben  usarse  siempre  que  se  necesite  representar  un  conjunto  de constantes con esas caracter\u00edsticas.</p>"},{"location":"bloque_i/tema_1/page-8/#definicion","title":"Definici\u00f3n","text":"<p>Los  enumerados  se  definen  con  la  palabra  enum, el nombre del enumerado  y  luego  el  conjunto  de  las constantes, que por las convenciones del lenguaje se escriben en may\u00fascula. Ejemplo:</p> <pre><code>public enum DayOfWeek {\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n</code></pre> <p>En Java, los tipos enumerados se pueden definir dentro de una clase o como una clase independiente. Si varias clases  van  a  utilizar  el  enum,  entonces  se  define  como  una  clase  independiente.  Si  por  el  contrario,  es solamente una clase la que lo utiliza, entonces se define dentro de dicha clase.</p> <ul> <li> <p>Dentro de una clase:</p> <pre><code>public class SimpleEnum {\n    public enum DayOfWeek {\n        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n    }\n\n    public static void main(String[] args) {\n        DayOfWeek d;\n        d = DayOfWeek.MONDAY;\n        System.out.println(d == DayOfWeek.MONDAY ? true:false);\n        d = DayOfWeek.SUNDAY;\n        System.out.println(d == DayOfWeek.MONDAY ? true:false);\n    }\n}\n</code></pre> </li> <li> <p>Como  una  clase  independiente: hay  que  colocarse  en  el  paquete donde se quiera crear el enum. Luego se pulsa el bot\u00f3n derecho del rat\u00f3n y New \u2192 Enum.</p> <pre><code>public enum DayOfWeeks {\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n</code></pre> <pre><code>public class EnumSimple {\n    public static void main(String[] args) {\n        DayOfWeeks d;\n        d = DayOfWeeks.MONDAY;\n        System.out.println(d == DayOfWeeks.MONDAY ? true:false);\n        d = DayOfWeeks.SUNDAY;\n        System.out.println(d == DayOfWeeks.MONDAY ? true:false);\n    }\n}\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_1/page-9/","title":"9 Iniciaci\u00f3n a la Programaci\u00f3n Orientada a Objetos","text":""},{"location":"bloque_i/tema_1/page-9/#introduccion","title":"Introducci\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es una t\u00e9cnica de programar aplicaciones basada en una serie de objetos independientes que se comunican entre s\u00ed.</p> <p>A Java se le considera un lenguaje orientado a objetos ya que siempre que se crea un programa en Java, por simple que sea, se necesita declarar una clase, y el concepto de clase pertenece a la programaci\u00f3n orientada a objetos.</p> <p>Un  objeto  es  un  elemento  del  programa  que  integra  sus  propios  datos  y  su  propio funcionamiento. Es decir, un objeto est\u00e1 formado por datos (atributos o propiedades) y por las funciones que es capaz de realizar el objeto (m\u00e9todos). Esta forma de programar se asemeja m\u00e1s al pensamiento humano. La cuesti\u00f3n es detectar adecuadamente los objetos necesarios para una aplicaci\u00f3n. De hecho hay que detectar las distintas clases de objetos.</p> <p>Una clase es lo que define a un tipo de objeto. Al definir una clase lo que se hace es indicar como funciona un determinado tipo de objeto. Luego, a partir de la clase, podremos crear objetos de esa  clase, es  decir,  la  clase  es  como  un  molde  a  partir  del  cual  se  crean  los  objetos  que pertenecen  a  ella.  Realmente  la  programaci\u00f3n  orientada  a  objetos  es  una  programaci\u00f3n orientada a clases. Es decir, lo que necesitamos programar es como funcionan las clases de objetos.</p> <p>Por ejemplo, una clase podr\u00eda ser la clase Coche. Cuando se defina esta clase, indicaremos los atributos o propiedades (como el color, modelo, marca, velocidad m\u00e1xima,...) y los m\u00e9todos (arrancar, parar, repostar, acelerar, frenar...). Todos los coches, es decir, todos los objetos de la clase Coche, tendr\u00e1n esas propiedades y esos m\u00e9todos. Para explicar la diferencia entre clase y objeto:</p> <ul> <li>la clase Coche representa a todos los coches.</li> <li>un coche concreto es un objeto, es decir, un ejemplar de una clase es un objeto. Tambi\u00e9n se le llama a los objetos instancias de la clase. Este t\u00e9rmino procede del ingl\u00e9s, instance, que realmente significa ejemplar.</li> </ul> <p>Por ejemplo, si quisi\u00e9ramos crear el juego del parch\u00eds en Java, una clase ser\u00eda la casilla, otra las fichas,  otra  el  dado,  etc.  En  el  caso  de  la  casilla,  se  definir\u00eda  la  clase  para  indicar  su funcionamiento y sus propiedades, y luego se crear\u00edan tantos objetos casilla como casillas tenga el juego. Lo mismo ocurrir\u00eda con las fichas, la clase ficha definir\u00eda las propiedades de la ficha (color  y  posici\u00f3n  por  ejemplo)  y  su  funcionamiento  mediante  sus  m\u00e9todos  (por  ejemplo  un m\u00e9todo ser\u00eda mover, otro llegar a la meta, etc), luego se crear\u00edan tantos objetos ficha como fichas tenga el juego.</p>"},{"location":"bloque_i/tema_1/page-9/#creacion-de-objetos","title":"Creaci\u00f3n de objetos","text":"<p>Una vez definida la clase, ya se pueden crear objetos de la misma. Para crear un objeto, hay que declarar una variable cuyo tipo ser\u00e1 la propia clase.</p> <p>Si por ejemplo defini\u00e9ramos una clase llamada Vehicle para modelar veh\u00edculos, para crear un objeto tendr\u00edamos que declarar una variable de tipo Vehicle:</p> <pre><code>Vehicle car; // car es una variable de tipo Vehicle\n</code></pre> <p>Una vez definida la variable, se le crea el objeto llamando a un m\u00e9todo que se llama constructor. Un constructor es un m\u00e9todo que se invoca cuando se crea un objeto y que sirve para inicializar los atributos del objeto y para realizar las acciones pertinentes que requiera el mismo para ser creado. El constructor tiene el mismo nombre que la clase y para invocarlo se utiliza el operador new.</p> <pre><code>car = new Vehicle(); // Vehicle() es un m\u00e9todo constructor\n</code></pre> <p>Tambi\u00e9n se puede hacer todo en la misma l\u00ednea:</p> <pre><code>Vehicle car = new Vehicle();\n</code></pre>"},{"location":"bloque_i/tema_1/page-9/#acceso-a-los-atributos-y-metodos-del-objeto","title":"Acceso a los atributos y m\u00e9todos del objeto","text":"<p>Una  vez  creado  el  objeto,  se  puede  acceder  a  sus  atributos  de  la  siguiente  manera: <code>objeto.atributo</code>.</p> <pre><code>car.wheelCount = 4; //(1)!\n</code></pre> <ol> <li>Se le asigna 4 al atributo de ruedas de la variable car.</li> </ol> <p>Los m\u00e9todos se utilizan de la misma forma que los atributos, a excepci\u00f3n de que los m\u00e9todos poseen  siempre  par\u00e9ntesis  ya  que  son  funciones  que  pertenecen  a  un  objeto: <code>objeto.m\u00e9todo(argumentos)</code>.</p> <pre><code>car.accelerate(30); //(1)!\n</code></pre> <ol> <li>El coche incrementa su velocidad en 30. Es decir, si iba a 90km/h, despu\u00e9s de ejecutar el m\u00e9todo, el coche va a 120km/h.</li> </ol>"},{"location":"bloque_i/tema_1/page-9/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<p>Java admite sobrecargar los m\u00e9todos, es decir, crear distintas variantes del mismo m\u00e9todo con el mismo nombre pero que se diferencien en el orden, tipo o n\u00famero de los par\u00e1metros. Por ejemplo, tenemos el m\u00e9todo para <code>sumar  add(int x,double y)</code>:</p> <ul> <li>S\u00ed  podr\u00edamos  definir  el  m\u00e9todo <code>add(double  x,int  y)</code> porque  var\u00eda  el  orden  de  los par\u00e1metros.</li> </ul> <p>Otro ejemplo donde tenemos el m\u00e9todo <code>add(int x,int y)</code>:</p> <ul> <li>No  podr\u00edamos  definir  otro  m\u00e9todo <code>add(int  a,int  b)</code>porque  no  var\u00eda  el  tipo  ni  el n\u00famero de par\u00e1metros.</li> <li>S\u00ed podr\u00edamos definir <code>add(int a)  y  add(int  a,int  b,int  c)</code> porque  el  n\u00famero  de par\u00e1metros var\u00eda. Tambi\u00e9n podr\u00edamos definir `add(int x,double y)p porque aunque no var\u00ede el n\u00famero de par\u00e1metros, s\u00ed var\u00eda uno de los tipos.</li> </ul>"},{"location":"bloque_i/tema_1/page-9/#metodos-estaticos-y-dinamicos","title":"M\u00e9todos est\u00e1ticos y din\u00e1micos","text":"<p>A los m\u00e9todos asociados a los objetos se les conoce como m\u00e9todos din\u00e1micos. Pero puede ocurrir que tengamos m\u00e9todos que no est\u00e9n asociados a ning\u00fan objeto, por ejemplo, m\u00e9todos de utilidad general. Dichos m\u00e9todos se les conoce como m\u00e9todos est\u00e1ticos y se definen con la palabra static. Al no estar asociados a ning\u00fan objeto, se utilizan con el nombre de la clase: <code>Clase.metodoEst\u00e1tico(argumentos)</code>. Ejemplos de llamadas a m\u00e9todos din\u00e1micos y est\u00e1ticos:</p> <ul> <li>Llamada a m\u00e9todo din\u00e1mico: <code>car.accelerate(30);</code></li> <li>Llamada a m\u00e9todo est\u00e1tico: <code>Math.pow(2,3);</code></li> </ul>"},{"location":"bloque_i/tema_1/page-9/#api-de-java","title":"Api de Java","text":"<p>La API de Java es una interfaz de programaci\u00f3n de aplicaciones (API, por sus siglas del ingl\u00e9s: Application Programming Interface) provista por los creadores del lenguaje de programaci\u00f3n Java, que da a los programadores los medios para desarrollar aplicaciones Java.</p> <p>Al instalar Java (el paquete JDK) en nuestro ordenador, adem\u00e1s del compilador y la m\u00e1quina virtual de Java se instalan bastantes m\u00e1s elementos. Entre ellos, una cantidad muy importante de clases que ofrece la multinacional desarrolladora de Java y que est\u00e1n a disposici\u00f3n de todos los programadores listas para ser usadas.  Estas clases junto a otros elementos forman lo que se denomina API de Java.</p> <p>Los paquetes donde se encuentran dichas clases los podemos encontrar en https://docs.oracle.com/  \u2192 Java \u2192 Java SE Documentation \u2192 JDK  de  la  versi\u00f3n  deseada  \u2192  Specifications \u2192 API Documentation \u2192 Module: java.base.</p> <p>Otra manera de acceder r\u00e1pido es poniendo en un buscador de Internet <code>Api  Java  Version Clase</code>, como por ejemplo: Api Java 12 Math.</p>"},{"location":"bloque_i/tema_1/page-9/#la-clase-math","title":"La clase Math","text":"<p>La  clase  Math  contiene  los  m\u00e9todos  para  realizar  operaciones  matem\u00e1ticas  b\u00e1sicas,  como potencias, logaritmos, ra\u00edces cuadradas y funciones trigonom\u00e9tricas.</p> <p>Si observamos esta clase en la API, todos los m\u00e9todos tienen al principio la palabra static, ya que son m\u00e9todos est\u00e1ticos porque son funciones de utilidad que no se utilizan asociadas a un objeto. Despu\u00e9s de la palabra static nos encontramos con el tipo del resultado que devuelve el m\u00e9todo. Y  a  continuaci\u00f3n,  nos  encontramos  con  el  nombre  del  m\u00e9todo  y  sus  par\u00e1metros.  Ejemplo:</p> <p><code>static double abs(double a)</code>Esto se conoce como la firma del m\u00e9todo (signature en ingl\u00e9s).</p> <pre><code>public class MathClass {\n    public static void main(String[] args) {\n        System.out.println(Math.abs(-3.2));\n        System.out.println(Math.pow(2,3));\n        System.out.println(Math.sqrt(16));\n        System.out.println(Math.min(20,5));\n    }\n}\n</code></pre> Ejercicio 1 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Math. Realiza un programa Java donde uses cada uno de esos m\u00e9todos realizando comentarios explicando cada uno de ellos. (Hacer ejemplo con n\u00fameros positivos y negativos)</p> <ol> <li><code>static float abs(float a)</code></li> <li><code>static int addExact(int x, int y)</code></li> <li><code>static double ceil(double a)</code></li> <li><code>static int decrementExact(int a)</code></li> <li><code>static double floor(double a)</code></li> <li><code>static int incrementExact(int a)</code></li> <li><code>static double max(double a, double b)</code></li> <li><code>static int multiplyExact(int x, int y)</code></li> <li><code>static int negateExact(int a)</code></li> </ol> <p>Obs\u00e9rvese en la API la sobrecarga de los m\u00e9todos abs y min.</p>"},{"location":"bloque_i/tema_1/page-9/#la-clase-string","title":"La clase String","text":"<p>El texto es uno de los tipos de datos m\u00e1s importantes y por ello Java lo trata de manera especial. Para Java, las cadenas de texto son objetos especiales. Los textos deben manejarse creando objetos de tipo String. Las cadenas se pueden inicializar de dos maneras:</p> <ul> <li>Usando el operador asignaci\u00f3n: <code>String s=\"hola\";</code></li> <li>Usando el constructor: <code>String s=new String(\"hola\");</code></li> </ul> <p>Los literales cadena se escriben entre comillas dobles: <code>\"Esto es un literal cadena\"</code>.</p> <p>En java existe tambi\u00e9n la cadena vac\u00eda o nula, es decir, una cadena sin ning\u00fan car\u00e1cter. Ejemplo: <code>String s=\"\";</code> A la variable s se le est\u00e1 asignando la cadena vac\u00eda o nula.</p> <p>Como vimos en el tema 1.5 Operadores, el operador concatenaci\u00f3n <code>+</code>  es un operador binario que devuelve una cadena resultado de concatenar las dos cadenas que act\u00faan como operandos. Si s\u00f3lo uno de los operandos es de tipo cadena, el otro operando se convierte impl\u00edcitamente en tipo cadena.</p> <p>Obs\u00e9rvese en la API el m\u00e9todo valueOf: es est\u00e1tico y est\u00e1 sobrecargado. Sirve para obtener la representaci\u00f3n String de un valor u objeto.</p> <pre><code>public class StringClass {\n    public static void main(String[] args) {\n        int i = 100;\n        String string1, string2, string3, string4;\n\n        string1 = \"Esto es un literal cadena\"; //(1)!\n        System.out.println(string1);\n\n        System.out.println(string1 + \" al cual le hemos concatenado este literal cadena\"); //(2)!\n\n        string2 = \"hola\";\n        string3 = \" que tal\";\n        string4 = string2 + string3;\n\n        System.out.println(string4);\n\n        System.out.println(i + 100); //(3)!\n        System.out.println(String.valueOf(i) + 100); //(4)!\n    }\n}\n</code></pre> <ol> <li>Se le da el valor inicial con el operador asignaci\u00f3n =</li> <li>Se concatena otra cadena con el operador +</li> <li>suma de enteros</li> <li>Concatenaci\u00f3n de cadenas</li> </ol> <p>Otros m\u00e9todos de las cadenas muy \u00fatiles son:</p> <ul> <li>charAt: devuelve el car\u00e1cter de la cadena del especificado \u00edndice. Dicho \u00edndice empieza en cero, es decir, con el cero se obtiene el primer car\u00e1cter de la cadena.</li> <li>length: devuelve la longitud de la cadena.</li> <li>equals: compara si dos cadenas son iguales.</li> </ul> <pre><code>public class StringClass2 {\n    public static void main(String[] args) {\n        String string = \"hola\";\n        System.out.println(string.charAt(0)); //h\n        System.out.println(string.charAt(1)); //o\n        System.out.println(string.charAt(2)); //l\n        System.out.println(string.charAt(3)); //a\n\n        System.out.println(string.length()); //4\n\n        System.out.println(string.equals(\"hola\")); //true\n        System.out.println(string.equals(\"hola\")); //false\n    }\n}\n</code></pre> Ejercicio 2 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase String. Realiza un programa Java con ejemplos de cada uno de ellos comentando su uso.</p> <ol> <li><code>char charAt(int index)</code></li> <li><code>int length()</code></li> <li><code>boolean equals(Object anObject)</code><ul> <li>Compara dos cadenas</li> <li>Compara tres cadenas</li> </ul> </li> <li><code>int codePointAt(int index)</code></li> <li><code>int compareTo(String anotherString)</code></li> <li><code>int compareToIgnoreCase(String str)</code></li> <li><code>String concat(String str)</code></li> <li><code>boolean endsWith(String suffix)</code></li> <li><code>boolean equalsIgnoreCase(String anotherString)</code></li> <li><code>int indexOf(int ch)</code></li> <li><code>int indexOf(int ch, int fromIndex)</code></li> <li><code>boolean isEmpty()</code></li> <li><code>int lastIndexOf(int ch)</code></li> <li><code>int lastIndexOf(int ch, int fromIndex)</code></li> <li><code>String replace(char oldChar, char newChar)</code></li> <li><code>String toUpperCase()</code></li> <li><code>String trim()</code></li> </ol>"},{"location":"bloque_i/tema_1/page-9/#wrappers","title":"Wrappers","text":"<p>En ocasiones es muy conveniente poder tratar los datos primitivos (int, boolean, etc.) como objetos. Pero los datos primitivos no son objetos. Para resolver esta situaci\u00f3n, la API de Java incorpora las clases envoltorio (wrapper class), que no son m\u00e1s que dotar a los datos primitivos con  un  envoltorio  que  permita  tratarlos  como  objetos.  Las  clases  envoltorio  proporcionan m\u00e9todos de utilidad para la manipulaci\u00f3n de datos primitivos (conversiones de / hacia datos primitivos, conversiones a String, etc).</p> <p>La siguiente tabla muestra los tipos primitivos y sus wrappers asociados:</p> Tipo primitivo Wrapper asociado byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean <p>Todos estos wrappers los encontraremos en la API de Java. Por ejemplo, si observamos en la API la clase Integer, podemos ver la siguiente firma de m\u00e9todo: <code>static int parseInt(String s)</code> que convierte la cadena pasada por par\u00e1metro a entero.</p> <pre><code>public class IntegerClass {\n    public static void main(String[] args) {\n        Integer integer1, integer2;\n        int i;\n\n        integer1 = 5;\n        System.out.println(integer1);\n\n        i = Integer.parseInt(\"7\"); //(1)!\n        System.out.println(i);\n\n        integer2 = Integer.valueOf(i); //(2)!\n        System.out.println(integer2);\n\n        i = integer1.intValue(); //(3)!\n        System.out.println(i);\n    }\n</code></pre> <ol> <li>Convierte la cadena a int. M\u00e9todo est\u00e1tico por lo que se utiliza con Integer</li> <li>Convierte el int a Integer. Tambi\u00e9n es est\u00e1tico</li> <li>Convierte el integer a int. M\u00e9todo din\u00e1mico por lo que se utiliza con el objeto</li> </ol>"},{"location":"bloque_i/tema_1/page-9/#encadenamiento-de-llamadas-a-metodos","title":"Encadenamiento de llamadas a m\u00e9todos","text":"<p>Se emplea cuando invocamos a un m\u00e9todo de un objeto que nos devuelve como resultado otro objeto al que podemos volver a invocar otro m\u00e9todo y as\u00ed encadenar varias operaciones.</p> <pre><code>public class CallsToMethods {\n    public void showCallsToMethods(){\n        Boolean b;\n        String string;\n\n        string = \"EntornoDeDesarrollo\";\n        System.out.println(string.substring(10).toUpperCase()); // DESARROLLO\n\n        b = Boolean.TRUE;\n        System.out.println(b.toString().charAt(2)); //u\n    }\n    public static void main(String[] args) {\n        new CallsToMethods().showCallsToMethods();\n    }\n}\n</code></pre> <p>En este ejemplo, el m\u00e9todo <code>substring(10)</code>  est\u00e1 devolviendo una subcadena de la cadena string a partir del car\u00e1cter 10 empezando en 0, es decir, \"Desarrollo\", al que se le invoca luego el m\u00e9todo <code>toUpperCase</code> devolviendo como resultado la cadena \"DESARROLLO\".</p> <p>Y el m\u00e9todo <code>toString()</code> de la variable b de tipo Boolean est\u00e1 devolviendo la cadena \"true\" a la que se le encadena el m\u00e9todo <code>charAt(2)</code>  devolviendo el car\u00e1cter 'u'.</p> Ejercicio 3 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Character. Realiza un programa Java donde realices ejemplos us\u00e1ndolos y comentando su uso.</p> <ol> <li><code>char charValue()</code></li> <li><code>static int compare(char x, char y)</code></li> <li><code>boolean equals(Object obj)</code></li> <li><code>static boolean isDigit(char ch)</code></li> <li><code>static boolean isLetter(char ch)</code></li> <li><code>static boolean isLowerCase(char ch)</code></li> <li><code>static boolean isSpaceChar(char ch)</code></li> <li><code>static boolean isUpperCase(char ch)</code></li> <li><code>static char toLowerCase(char ch)</code></li> <li><code>static char toUpperCase(char ch)</code></li> <li><code>static Character valueOf(char c)</code></li> </ol> Ejercicio 4 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Integer. Realiza un programa Java donde realices ejemplos us\u00e1ndolos y comentando su uso.</p> <ol> <li><code>byte byteValue()</code></li> <li><code>static int compare(int x, int y)</code></li> <li><code>int compareTo(Integer anotherInteger)</code></li> <li><code>double doubleValue()</code></li> <li><code>boolean equals(Object obj)</code></li> <li><code>int intValue()</code></li> <li><code>static int max(int a, int b)</code></li> <li><code>static int min(int a, int b)</code></li> <li><code>static int parseInt(String s)</code></li> <li><code>static int sum(int a, int b)</code></li> <li><code>static Integer valueOf(int i)</code></li> <li><code>static Integer valueOf(String s)</code></li> </ol> Ejercicio 5 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Double. Realiza un programa Java donde realices ejemplos us\u00e1ndolos y comentando su uso.</p> <ol> <li><code>static int compare(double d1, double d2)</code></li> <li><code>int compareTo(Double anotherDouble)</code></li> <li><code>double doubleValue()</code></li> <li><code>boolean equals(Object obj)</code></li> <li><code>float floatValue()</code></li> <li><code>int intValue()</code></li> <li><code>boolean isInfinite()</code></li> <li><code>static boolean isInfinite(double v)</code></li> <li><code>boolean isNaN()</code></li> <li><code>static boolean isNaN(double v)</code></li> <li><code>static double max(double a, double b)</code></li> <li><code>static double min(double a, double b)</code></li> <li><code>static double parseDouble(String s)</code></li> <li><code>static double sum(double a, double b)</code></li> <li><code>static Double valueOf(double i)</code></li> <li><code>static Double valueOf(String s)</code></li> </ol> Ejercicio 6 <p>Declara un booleano, un entero, un car\u00e1cter y un decimal, inicial\u00edzalas. Luego, transforma todas las variables a variable cadena. Luego, obtener una cadena resultante de concatenar todas las cadenas obtenidas anteriormente. Muestra esta cadena resultante por pantalla.</p>"},{"location":"bloque_i/tema_2/page-1/","title":"1 Condicionales","text":""},{"location":"bloque_i/tema_2/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Los  programas  se  construyen  para  procesar  datos,  manipul\u00e1ndolos  de  formas diferentes  dependiendo  de  los  valores  que  tengan.  Los  lenguajes  de  programaci\u00f3n deben proveer estructuras que les permitan a los  programadores controlar el flujo de ejecuci\u00f3n  de  un  programa  dependiendo  de  los  datos  que  procesan.  Para  ello,  se incluyen las sentencias de control de flujo, que alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</p> <p>La programaci\u00f3n estructurada es un paradigma de programaci\u00f3n orientado a mejorar la claridad, calidad y tiempo  de  desarrollo  de  un  programa  de  computadora  recurriendo  \u00fanicamente  a subrutinas y tres estructuras b\u00e1sicas: secuencia, sentencias condicionales y bucles.</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo  principal,  el  cual  permite  resolver  una  tarea  espec\u00edfica.  Por  ejemplo,  los m\u00e9todos en Java.</p>"},{"location":"bloque_i/tema_2/page-1/#secuencia","title":"Secuencia","text":"<p>La  ejecuci\u00f3n  secuencial  es  el  m\u00e1s  b\u00e1sico  de  los  mecanismos  de  control  de  flujo  y consiste en la ejecuci\u00f3n de instrucciones en el orden en que se encuentran en el c\u00f3digo fuente del programa.</p> <p>Hasta  ahora  las  instrucciones  que  hemos  visto,  son  instrucciones  que  se  ejecutan secuencialmente; es decir, podemos saber lo que hace el programa leyendo las l\u00edneas de izquierda a derecha y de arriba abajo.</p>"},{"location":"bloque_i/tema_2/page-1/#sentencias-condicionales","title":"Sentencias condicionales","text":"<p>La sentencia condicional consiste en ejecutar instrucciones diferentes dependiendo del resultado de evaluar una expresi\u00f3n l\u00f3gica. Una expresi\u00f3n l\u00f3gica es cualquier tipo de expresi\u00f3n que devuelva un resultado booleano (true o false). Las expresiones l\u00f3gicas se construyen  por  medio  de  variables  booleanas  o  bien  a  trav\u00e9s  de  los  operadores relacionales (==, &gt;, &lt;,...) y/o l\u00f3gicos (&amp;&amp;,||, !).</p>"},{"location":"bloque_i/tema_2/page-1/#condicional-simple","title":"Condicional simple","text":"<p>Se ejecutan una serie de instrucciones en el caso de que la expresi\u00f3n l\u00f3gica sea verdadera:</p> EstructuraEjemplo <pre><code>if(expresi\u00f3nL\u00f3gica){\n    // instrucciones\n}\n</code></pre> <pre><code>import java.util.Scanner;\n\npublic class If {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int age;\n        String name;\n\n        System.out.print(\"Introduce tu nombre: \");\n        name = keyboard.nextLine();\n\n        System.out.print(\"Introduce tu edad: \");\n        age = keyboard.nextInt();\n\n        if(age &gt;= 18){\n            System.out.printf(\"Bienvenido/a %s\\n\", name);\n            System.out.println(\"Eres mayor de edad\");\n        }\n    }\n}\n</code></pre> Ejercicio 1 <p>Dada una cantidad, si es mayor que 1000, que muestre el 15% de dicha cantidad. Si no, que no haga nada.</p>"},{"location":"bloque_i/tema_2/page-1/#condicional-doble","title":"Condicional doble","text":"<p>Es igual que la anterior, s\u00f3lo que se a\u00f1ade un apartado else que contiene instrucciones que se ejecutar\u00e1n si la expresi\u00f3n evaluada por el if es falsa.</p> EstructuraEjemplo <pre><code>if(expresi\u00f3nL\u00f3gica){\n    // instrucciones si la expresi\u00f3n l\u00f3gica es verdadera\n} else {\n    // expresiones si la expresi\u00f3n l\u00f3gica es falsa\n}\n</code></pre> <pre><code>import java.util.Scanner;\n\npublic class IfElse {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int age;\n        String name;\n\n        System.out.print(\"Introduce tu nombre: \");\n        name = keyboard.nextLine();\n\n        System.out.print(\"Introduce tu edad: \");\n        age = keyboard.nextInt();\n\n        System.out.printf(\"Bienvenido/a %s\\n\", name);\n\n        if(age &gt;= 18){\n            System.out.println(\"Eres mayor de edad\");\n        } else {\n            System.out.println(\"Eres menor de edad\");\n        }\n    }\n}\n</code></pre> Ejercicio 2 <p>Dada una edad, que te muestre por pantalla si es mayor de edad o no.</p> Ejercicio 3 <p>Dado un n\u00famero, indicar si es par o impar.</p> Ejercicio 4 <p>Pedir dos n\u00fameros por teclado e indicar si el primer n\u00famero es m\u00faltiplo del segundo.</p>"},{"location":"bloque_i/tema_2/page-1/#condicional-multiple","title":"Condicional M\u00faltiple","text":""},{"location":"bloque_i/tema_2/page-1/#anidacion","title":"Anidaci\u00f3n","text":"<p>Dentro  de  una  sentencia  if  se  puede  colocar  otra  sentencia  if.  A  esto  se  le  llama anidaci\u00f3n  y  permite  crear  programas  donde  se  valoren  expresiones  complejas.  La nueva sentencia puede ir tanto en la parte if como en la parte else.</p> <p>Las anidaciones se utilizan much\u00edsimo al programar. Solo hay que tener en cuenta que siempre se debe cerrar primero el \u00faltimo if que se abri\u00f3. Es muy importante tambi\u00e9n tabular el c\u00f3digo correctamente para que las anidaciones sean legibles.</p> <p>Ejemplo:</p> <pre><code>if(x == 1){\n    // instrucciones\n} else {\n    if(x == 2){\n        // instrucciones\n    } else {\n        if(x == 3){\n            // instrucciones\n        }\n    }\n}\n</code></pre> <p>Una forma m\u00e1s legible de escribir ese mismo c\u00f3digo dando lugar a la llamada estructura if-else-if ser\u00eda:</p> <pre><code>if(x == 1){\n    // instrucciones\n} else if(x == 2){\n    // instrucciones\n} else if(x == 3){\n    // instrucciones\n}\n</code></pre> <p>Cuando  se  cumpla  alguna  de  las  condiciones,  se  ejecutan  sus  instrucciones correspondientes y despu\u00e9s ya se sale de la estructura if-else-if ya que las condiciones son autoexcluyentes, es decir, solamente se va a cumplir una. Por eso, no estar\u00eda bien hacer lo siguiente:</p> <pre><code>if(x == 1){ // Forma incorrecta de programar\n    // instrucciones\n}\n\nif(x == 2){\n    // instrucciones\n}\n\nif(x == 3){\n    // instrucciones\n}\n</code></pre> <p>El motivo de que no sea adecuado es porque se pierde tiempo en comprobar todas las condiciones. Por ejemplo, si x vale 1, se ejecutan sus instrucciones correspondientes y luego se comprobar\u00eda si x vale 2, si x vale 3, etc. cuando no se va a cumplir ninguna m\u00e1s ya que si x vale 1 no puede valer ni 2 ni 3.</p> <pre><code>import java.util.Scanner;\n\npublic class IfElseIf {\n    public static void main(String[] args) {         \n        Scanner keyboard = new Scanner(System.in);\n        int age;\n\n        System.out.print(\"Introduce tu edad: \");\n        age = keyboard.nextInt();\n\n        if (age &gt;= 18) {\n            System.out.println(\"Eres mayor de edad\");\n        } else if (age &gt;= 16 &amp;&amp; age &lt; 18) {\n            System.out.println(\"Eres menor de edad pero tienes ciertos privilegios\");\n        } else if (age &gt;= 14 &amp;&amp; age &lt; 16) {\n            System.out.println(\"Eres menor de edad y adem\u00e1s no tienes privilegios\");\n        } else {\n            System.out.println(\"Eres menor de edad\");\n        }     \n    }\n}\n</code></pre> Ejercicio 5 <p>Dada una nota, que te muestre lo siguiente:</p> <ul> <li>0, 1, 2: Muy deficiente</li> <li>3, 4: Insuficiente</li> <li>5: Suficiente</li> <li>6: Bien</li> <li>7, 8: Notable</li> <li>9, 10: Sobresaliente</li> </ul> Ejercicio 6 <p>Hacer un programa que lea por teclado un n\u00famero entero y nos diga si el n\u00famero es positivo, negativo o cero.</p> Ejercicio 7 <p>Realiza un programa que lea tres n\u00fameros positivos y compruebe si son iguales. Por ejemplo: Si la entrada fuese 5 5 5, la salida deber\u00eda ser \u201chay tres n\u00fameros iguales a 5\u201d. Si la entrada fuese 4 6 4, la salida deber\u00eda ser \u201chay dos n\u00fameros iguales a 4\u201d. Si la entrada fuese 0 1 2, la salida deber\u00eda ser \u201cno hay n\u00fameros iguales\u201d.</p>"},{"location":"bloque_i/tema_2/page-1/#switch","title":"Switch","text":"<p>El cuerpo de una sentencia switch se conoce como bloque switch.</p> <p>Esta  sentencia  eval\u00faa  una  expresi\u00f3n  y  cada  case  contiene  un  posible  valor  del resultado  de  dicha  expresi\u00f3n;  si  efectivamente  el  resultado  equivale  a  ese  valor,  se ejecutan las instrucciones de ese case y de los siguientes.</p> <p>La instrucci\u00f3n break se utiliza para salir del switch. De tal modo que si queremos que para un determinado valor se ejecuten las instrucciones de un apartado case y solo las de ese apartado, entonces habr\u00e1 que finalizar ese case con un break. Cuando se alcanza una sentencia break, el switch termina y el flujo de control salta a la siguiente l\u00ednea que sigue a la sentencia switch.</p> <p>Fall through condition (condici\u00f3n de ca\u00edda): esta condici\u00f3n se produce en la sentencia switch cuando no se utiliza  break en un case y causa la ejecuci\u00f3n de los siguientes case hasta que no se produce un break o se sale de la sentencia switch.</p> <p>El  bloque  default  sirve  para  ejecutar  instrucciones  para  los  casos  en  los  que  la expresi\u00f3n no se ajuste a ning\u00fan case. T\u00e9cnicamente, el break del default no es necesario porque el flujo se sale de la sentencia switch, pero se recomienda utilizarlo para que la modificaci\u00f3n del c\u00f3digo sea m\u00e1s f\u00e1cil y menos propensa a errores.</p> <p>Funciona con los tipos de datos primitivos, con los tipos enumerados, con las cadenas(a partir de Java 7) y con los wrappers.</p> EstructuraEjemplo 1Ejemplo 2 <pre><code>switch(expresi\u00f3n) {\n   case valor1 :\n      instrucciones\n      break; // opcional\n\n   case valor2 :\n      instrucciones\n      break; // opcional\n   //....\n   //....\n   default : // opcional\n      instrucciones\n      break; // opcional\n}\n</code></pre> <pre><code>import java.util.Scanner;\n\npublic class Switch1 {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int weekday;\n\n        System.out.print(\"Introduce un n\u00famero del 1 al 7 correspondiente al d\u00eda de la semana: \");\n        weekday = keyboard.nextInt();\n        switch (weekday) {\n            case 1:\n                System.out.println(\"Lunes\");\n                break;\n            case 2:\n                System.out.println(\"Martes\");\n                break;\n            case 3:\n                System.out.println(\"Mi\u00e9rcoles\");\n                break;\n            case 4:\n                System.out.println(\"Jueves\");\n                break;\n            case 5:\n                System.out.println(\"Viernes\");\n                break;\n            case 6:\n                System.out.println(\"S\u00e1bado\");\n                break;\n            case 7:\n                System.out.println(\"Domingo\");\n                break;\n            default:\n                System.out.println(\"D\u00eda incorrecto\");\n                break;\n        }\n    }\n}\n</code></pre> <pre><code>import java.util.Scanner;\n\npublic class Switch2 {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int month, year, numDays = 0;\n\n        System.out.print(\"Introduce un n\u00famero del 1 al 12 correspondiente a un mes: \");\n        month = keyboard.nextInt();\n\n        System.out.print(\"Introduce un a\u00f1o: \");\n        year = keyboard.nextInt();\n\n        switch (month) {\n            case 1:\n            case 3:\n            case 5:\n            case 7:\n            case 8:\n            case 10:\n            case 12:\n                numDays = 31;\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                numDays = 30;\n                break;\n            case 2://Se calcula si es un a\u00f1o bisiesto\n                if (((year % 4 == 0) &amp;&amp; !(year % 100 == 0)) || (year % 400 == 0)) {\n                    numDays = 29;\n                } else {\n                    numDays = 28;\n                }\n                break;\n            default:\n                System.out.println(\"Mes inv\u00e1lido\");\n                break;\n        }\n        if (month &gt;= 1 &amp;&amp; month &lt;= 12) {\n            System.out.printf(\"N\u00famero de d\u00edas del mes %d del a\u00f1o %d: %d\", month, year, numDays);\n        }\n    }\n}\n</code></pre> <p>La  decisi\u00f3n  de  utilizar  sentencias  if-then-else  o  una  sentencia  switch  se  basa  en  la legibilidad y en la expresi\u00f3n que la sentencia est\u00e1 probando. Una sentencia if-then-else puede comprobar expresiones basadas en rangos de valores o condiciones, mientras que una sentencia switch comprueba expresiones basadas s\u00f3lo en un \u00fanico valor.</p> Ejercicio 8 <p>Realiza el ejercicio 4, haciendo uso de la estructura Switch.</p>"},{"location":"bloque_i/tema_2/page-1/#nuevo-switch","title":"Nuevo Switch","text":"<p>Desde la versi\u00f3n de Java 14, hay una nueva estructura de la sentencia switch, que la hace m\u00e1s \"elegante\" pero sobretodo legible.</p> EstructuraEjemplo 1Ejemplo 2 <pre><code>switch(expresi\u00f3n){\n    case valor1 -&gt; /* instrucci\u00f3n de una l\u00ednea*/;\n    case valor2 -&gt; {\n        // instrucciones de m\u00e1s de una l\u00ednea\n    }\n    // ...\n    default -&gt; /* instrucci\u00f3n de una l\u00ednea */;\n}\n</code></pre> <pre><code>import java.util.Scanner;\n\npublic class NewSwitch1 {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int weekday;\n\n        System.out.print(\"Introduce un n\u00famero del 1 al 7 correspondiente al d\u00eda de la semana: \");\n        weekday = keyboard.nextInt();\n        switch (weekday) {\n            case 1 -&gt; System.out.println(\"Lunes\");\n            case 2 -&gt; System.out.println(\"Martes\");\n            case 3 -&gt; System.out.println(\"Mi\u00e9rcoles\");\n            case 4 -&gt; System.out.println(\"Jueves\");\n            case 5 -&gt; System.out.println(\"Viernes\");\n            case 6 -&gt; System.out.println(\"S\u00e1bado\");\n            case 7 -&gt; System.out.println(\"Domingo\");\n            default -&gt; System.out.println(\"D\u00eda incorrecto\");\n        }\n    }\n}\n</code></pre> <pre><code>import java.util.Scanner;\n\npublic class NewSwitch2 {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int month, year, numDays = 0;\n\n        System.out.print(\"Introduce un n\u00famero del 1 al 12 correspondiente a un mes: \");\n        month = keyboard.nextInt();\n\n        System.out.print(\"Introduce un a\u00f1o: \");\n        year = keyboard.nextInt();\n\n        switch (month) {\n            case 1, 3, 5, 7, 8, 10, 12 -&gt; numDays = 31;\n            case 4, 6, 9, 11 -&gt; numDays = 30;\n            case 2 -&gt; {\n                //Se calcula si es un a\u00f1o bisiesto\n                if (((year % 4 == 0) &amp;&amp; !(year % 100 == 0)) || (year % 400 == 0)) {\n                    numDays = 29;\n                } else {\n                    numDays = 28;\n                }\n            }\n            default -&gt; System.out.println(\"Mes inv\u00e1lido\");\n        }\n        if (month &gt;= 1 &amp;&amp; month &lt;= 12) {\n            System.out.printf(\"N\u00famero de d\u00edas del mes %d del a\u00f1o %d: %d\", month, year, numDays);\n        }\n    }\n}\n</code></pre> Ejercicio 9 <p>Realiza el ejercicio 4, haciendo uso de la nueva estructura Switch</p>"},{"location":"bloque_i/tema_2/page-1/#ejercicios","title":"Ejercicios","text":"Ejercicio 10 <p>Realiza un programa que calcule el precio de un billete de ida y vuelta por avi\u00f3n, conociendo la distancia a recorrer, el n\u00famero de d\u00edas de estancia y sabiendo que si la distancia es superior a 1.000 Km y el n\u00famero de d\u00edas de estancia es superior a 7, la l\u00ednea a\u00e9rea le hace un descuento del 30 %. (Precio por kil\u00f3metro = 0,35 \u20ac).</p> Ejercicio 11 <p>Los empleados de una f\u00e1brica trabajan en dos turnos: diurno y nocturno. Se desea calcular el jornal diario de acuerdo con los siguientes tarifas: la tarifa de las horas diurnas es de 3 \u20ac por hora, mientras que el de las nocturnas es de 4,80 \u20ac po hora. Cuando se trata de un d\u00eda festivo, la tarifa se incrementa en 1,20 \u20ac por hora en el turno diurno y 1,80 \u20ac por hora en el nocturno.</p> Ejercicio 12 <p>Realiza un programa que dados tres n\u00fameros, los devuelva en orden ascendente.</p> Ejercicio 13 <p>Dada una cadena solicitada al usuario, obtener y mostrar uno de sus caracteres elegidos aleatoriamente. Mostrar tambi\u00e9n en qu\u00e9 posici\u00f3n se encuentra dicho car\u00e1cter.</p> Ejercicio 14 <p>Realiza un programa que saque una carta aleatoria de una baraja con 4 palos y 13 cartas por cada palo. Los palos son Picas \u2660, Corazones \u2665, Diamantes \u2666 y Tr\u00e9boles \u2663. Las 13 cartas por cada palo ir\u00e1n del as al diez y adem\u00e1s tres figuras: jota, reina y rey. Mostrar la carta incluyendo el s\u00edmbolo del palo(\u2660,\u2665,\u2666,\u2663).</p>"},{"location":"bloque_i/tema_2/page-2/","title":"2 Bucles","text":""},{"location":"bloque_i/tema_2/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>En programaci\u00f3n, un bucle o instrucci\u00f3n de control repetitiva (o iterativa)  permite  ejecutar  una  o m\u00e1s  instrucciones  varias  veces,  es  decir,  permite  ejecutar  un  bloque  de  instrucciones repetidamente, escribi\u00e9ndolas una sola vez en el programa, reduciendo de este modo el c\u00f3digo del mismo. Cada vuelta que da el bucle se conoce como iteraci\u00f3n.</p> <p>Las variables que se utilizan en los bucles pueden tener distintas funciones:</p> <ul> <li>\u00edndice: es una variable que apunta a un recurso concreto. En los bucles, apunta al n\u00famero de iteraci\u00f3n. Se suelen utilizar por convenio los identificadores de variables i, j y k.</li> <li>contador: cuenta cu\u00e1ntas veces ocurre algo.</li> <li>acumulador: acumula operaciones parciales.</li> </ul> <p>Las instrucciones b\u00e1sicas que permiten construir este tipo de estructuras son while, do-while y for.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-while","title":"Bucle while","text":"<p>El bucle while agrupa instrucciones las cuales se ejecutan continuamente mientras una condici\u00f3n que se eval\u00faa sea verdadera. La condici\u00f3n se eval\u00faa antes de entrar dentro del while y cada vez que se termina de ejecutar las instrucciones del while.</p> <p>El programa se ejecuta siguiendo estos pasos:</p> <ol> <li>Se eval\u00faa la expresi\u00f3n l\u00f3gica.</li> <li>Si  la  expresi\u00f3n  es  verdadera  ejecuta  las  instrucciones,  sino  el  programa  abandona  la sentencia while.</li> <li>Tras ejecutar las instrucciones, volvemos al paso 1.</li> </ol> EstructuraEjemplo <pre><code>while(expresi\u00f3nL\u00f3gica){\n    //instrucciones\n}\n</code></pre> <pre><code>import java.util.Random;\n\npublic class While1 {\n    public static void main(String[] args) {\n        int number;\n        Random random = new Random();\n\n        /*\n         * Se obtiene un n\u00famero aleatorio entre 1 y 500.\n         * Mientras dicho n\u00famero sea par, continuamos en el bucle while\n         */\n        while ((number = random.nextInt(500)+1) % 2 == 0){\n            System.out.println(number);\n        }\n    }\n}\n</code></pre> Ejercicio 1 <p>Dados dos n\u00fameros n1 y n2, tal que n1 &lt;= n2, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle while.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-do-while","title":"Bucle do-while","text":"<p>La \u00fanica diferencia respecto al while est\u00e1 en que la expresi\u00f3n l\u00f3gica se eval\u00faa despu\u00e9s de haber ejecutado  las  instrucciones.  Es  decir,  el  bucle  al  menos  se  ejecuta  una  vez.  Los  pasos  son  los siguientes:</p> <ol> <li>Ejecutar instrucciones.</li> <li>Evaluar expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera, volver al paso 1. Si es falsa, salir del do-while.</li> </ol> <p>Ejemplo que muestra n\u00fameros aleatorios entre 1 y 500 hasta que salga uno m\u00faltiplo de 7:</p> EstructuraEjemploEjemplo 2Ejemplo 3Ejemplo 4 <pre><code>do{\n    // instrucciones\n} while(expresi\u00f3nL\u00f3gica)\n</code></pre> <pre><code>import java.util.Random;\n\npublic class DoWhile1 {\n    public static void main(String[] args) {\n        boolean exit = false;\n        int number;\n        Random random = new Random();\n\n        do{\n            number = random.nextInt(500) + 1; //(1)!\n            System.out.println(number);\n            exit = (number % 7 == 0); //(2)!\n        } while (!exit); //(3)!\n    }\n}\n</code></pre> <ol> <li>Se calcula un n\u00famero aleatorio entre 1 y 500</li> <li>exit se pone a true si el n\u00famero es m\u00faltiplo de 7</li> <li>Condici\u00f3n de repetici\u00f3n: que exit sea false</li> </ol> <p>Si le a\u00f1adimos al ejemplo anterior que solamente haya 5 posibilidades para encontrar el m\u00faltiplo de 7, eso significa que necesitamos una variable que apunte al n\u00famero de iteraci\u00f3n del bucle para poder controlar que solamente se ejecute 5 veces, es decir, necesitamos un \u00edndice:</p> <pre><code>import java.util.Random;\n\npublic class DoWhile2 {\n    public static void main(String[] args) {\n        boolean exit = false;\n        int number, i = 1; //(1)!\n        Random random = new Random();\n\n        do{\n            number = random.nextInt(500) + 1;\n            System.out.println(number);\n            exit = (number % 7 == 0);\n            i++;\n        } while (!exit &amp;&amp; i &lt;= 5); //(2)!\n\n        if(!exit){\n            System.out.println(\"No se encontr\u00f3 el m\u00faltiplo de 7\");\n        }\n    }\n}\n</code></pre> <ol> <li>i es un \u00edndice porque apunta al n\u00famero de iteraci\u00f3n del bucle</li> <li>Mientras exit sea false y adem\u00e1s i sea menor o igual que 5</li> </ol> <p>El  bucle  do-while  se  utiliza  cuando  se  sabe  que  las  instrucciones  del  bucle  se  van  a  ejecutar  al menos  una  vez.  En  el  bucle  while  puede  ser  que  no  se  ejecuten  nunca  si  la  condici\u00f3n  es  falsa desde un principio. Las peticiones de usuario se realizan con bucles do-while, ya que la petici\u00f3n del  dato  al  usuario  siempre  se  realiza,  y  si  el  usuario  no  introduce  lo  que  le  hemos  pedido, entonces utilizamos el bucle para volv\u00e9rselo a pedir.</p> <pre><code>import java.util.Scanner;\n\npublic class DoWhile3 {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int number;\n\n        do{\n            System.out.print(\"Introduzca un n\u00famero del 1 al 5: \");\n            number = keyboard.nextInt();\n            System.out.printf(\"Has introducido un %d\\n\", number);\n        }while (number &lt; 1 || number &gt; 5);\n    }\n}\n</code></pre> <pre><code>import java.util.Scanner;\n\npublic class DoWhile4 {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int number, counter = 0, sum = 0, index = 0;\n\n        /*\n         * index: es un \u00edndice porque apunta al n\u00famero de iteraci\u00f3n del bucle\n         * counter: es un contador para contar el n\u00famero de pares\n         * sum: es un acumulador donde se acumula la suma de los n\u00fameros pares\n         */\n        do{\n            System.out.print(\"Introduzca un n\u00famero \u00f3 0 para terminar: \");\n            number = keyboard.nextInt();\n\n            if(number != 0){\n                index++; // Se incrementa el n\u00famero de iteraciones del bucle\n                System.out.printf(\"El n\u00famero introducido en la iteraci\u00f3n %d es %d\\n\", index, number);\n\n                if(number % 2 == 0){ // si el n\u00famero es par\n                    counter++; // Se incrementa el contador\n                    sum += number; // Se acumula la suma en el acumulador\n                }\n            }\n        }while (number != 0);\n\n        System.out.printf(\"En %d iteraciones se han introducido %d n\u00fameros pares cuya suma vale %d\", index, counter, sum);\n    }\n}\n</code></pre> Ejercicio 2 <p>Dados dos n\u00fameros n1 y n2, tal que n1 &lt;= n2, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle do-while.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-for","title":"Bucle for","text":"<p>El funcionamiento es el siguiente:</p> <ol> <li>Se ejecuta la instrucci\u00f3n de inicializaci\u00f3n.</li> <li>Se comprueba la condici\u00f3n.</li> <li>Si la condici\u00f3n es cierta, entonces se ejecutan las instrucciones. Si la condici\u00f3n es falsa, se abandona el bloque for.</li> <li>Tras ejecutar las instrucciones, se ejecuta la instrucci\u00f3n de incremento y se vuelve al paso</li> </ol> EstructuraEjemploEjemplo con While <pre><code>for(inicializaci\u00f3n;condici\u00f3n;incremento){\n    // instrucciones\n}\n</code></pre> <p>Escribir n\u00fameros del 1 al 100:</p> <pre><code>public class For1 {\n    public static void main(String[] args) {\n        int i;\n\n        for (i = 1; i &lt;= 100; i ++){ //(1)!\n            System.out.println(i);\n        }\n    }\n}\n</code></pre> <ol> <li>i es un \u00edndice porque apunta al n\u00famero de iteraci\u00f3n del bucle</li> </ol> <p>Los bucles for tambi\u00e9n se pueden hacer con while o do-while pero los for tienen una sintaxis m\u00e1s abreviada. Veamos el ejemplo For1 hecho con un while:</p> <pre><code>public class While2 {\n    public static void main(String[] args) {\n        int i = 1;\n\n        while (i &lt;= 100){\n            System.out.println(i);\n            i++;\n        }\n    }\n}\n</code></pre> <p>Todos los bucles se pueden hacer con for, while y do-while, entonces, \u00bfcu\u00e1l se debe usar? Es importante que le programador utilice la estructura m\u00e1s adecuada en cada caso:</p> <ul> <li> <p>Un bucle for se utiliza cuando se conozca el n\u00famero de veces que se va a ejecutar el bucle, es decir, cuando se conozcan el n\u00famero de iteraciones de antemano.</p> </li> <li> <p>Si no se sabe de antemano el n\u00famero de iteraciones, entonces hay que utilizar while o do-while</p> <ul> <li>Un bucle do-while se utiliza cuando las instrucciones del bucle se van a ejecutar al menos una vez.</li> <li>Un bucle while se utiliza, entonces, cuando las instrucciones del bucle pueden no ejecutarse nunca si la condici\u00f3n es falsa desde un principio.</li> </ul> </li> </ul> <p>Tambi\u00e9n es posible declarar la variable dentro del propio bucle for, pero su \u00e1mbito de vida se reduce exclusivamente al bucle for, es decir, no se conoce fuera del for ya que muere en cuando el bucle se finalice.</p> <pre><code>public class For2 {\n    public static void main(String[] args) {\n        for (int i = 1; i &lt;= 100; i++) { //(1)!\n            System.out.println(i);\n        }\n\n        i = 1; //(2)!\n    }\n}\n</code></pre> <ol> <li>Se declara la variable i como int dentro del for</li> <li> Error de compilaci\u00f3n: <code>i cannot be resolved to a variable</code></li> </ol> <p>El bucle for tambi\u00e9n admite m\u00e1s de una variable, en cuyo caso, en las partes de inicializaci\u00f3n e incremento, se utiliza como separador la coma <code>,</code>:</p> <pre><code>public class For3 {\n    public static void main(String[] args) {\n        for(int i = 0, j = 10; i &lt;= j; i++, j--){\n            System.out.printf(\"i: %d j: %d\\n\", i, j);\n        }\n    }\n}\n</code></pre> <p>CUIDADO</p> <p>En los IDEs, se puede seleccionar variables l\u00edneas de c\u00f3digos y se puede insertar f\u00e1cilmente en un if o en un bucle.</p> <p>Por motivos de legibilidad de c\u00f3digo, es muy importante que las variables del for aparezcan en las  3  partes  del  for,  es  decir,  en  la  inicializaci\u00f3n,  en  la  condici\u00f3n  y  en  el  incremento,  ya  que  el programador  que  quiera  saber  cu\u00e1ntas  iteraciones  realiza  el  bucle,  solamente  con  fijarse  en  la l\u00ednea de c\u00f3digo donde se encuentra el for, pueda saberlo. Si las variables del for no aparecen en las 3 partes, eso nos indica que es m\u00e1s conveniente realizar un while o un do-while.</p> <p>Veamos el ejemplo que muestra n\u00fameros aleatorios entre 1 y 500 hasta que salga uno m\u00faltiplo de 7:</p> <pre><code>import java.util.Random;\n\npublic class For4 {\n    public static void main(String[] args) {\n        boolean exit = false;\n        int number = 0, i;\n        Random random = new Random();\n\n        for(i = 1; !exit; i++){ // Este for no es legible, se debe sustituir por un do-while\n            number = random.nextInt(500)+1;\n            System.out.printf(\"Iteraci\u00f3n %d, n\u00famero: %d\\n\", i, number);\n            exit = (number % 7 == 0);\n        }\n\n        System.out.printf(\"El m\u00faltiplo de 7 con valor %d se ha encontrado en la iteraci\u00f3n %d\", number, i - 1);\n    }\n}\n</code></pre> <p>Si le a\u00f1adimos al ejemplo anterior que solamente haya 5 posibilidades para encontrar el m\u00faltiplo de 7:</p> <pre><code>import java.util.Random;\n\npublic class For5 {\n    public static void main(String[] args) {\n        boolean exit = false;\n        int number = 0, i;\n        Random random = new Random();\n\n        /*\n         * Ahora el for s\u00ed es legible porque la variable i aparece en las 3 partes:\n         * en la inicializaci\u00f3n, en la condici\u00f3n y en el incremento\n         */\n        for(i = 1; i &lt;= 5 &amp;&amp; !exit; i++){\n            number = random.nextInt(500) + 1;\n            System.out.printf(\"Iteraci\u00f3n: %d, n\u00famero: %d\\n\", i, number);\n            exit = (number % 7 == 0);\n        }\n\n        if(exit){\n            System.out.printf(\"El m\u00faltiplo de 7 con valor de %d se ha encontrado en la iteraci\u00f3n %d\", number, i - 1);\n        } else {\n            System.out.println(\"El m\u00faltiplo de 7 no se ha encontrado\");\n        }\n    }\n}\n</code></pre> <p>Tambi\u00e9n  es  muy  importante  por  motivos  de  legibilidad  del  c\u00f3digo,  que  el  \u00fanico  sitio  donde  se modifiquen  los  valores  de  las  variables  del  for  sea  en  la  zona  del  incremento  ya  que  el programador que quiera saber cu\u00e1ntas iteraciones realiza el bucle, solamente con ver la l\u00ednea de c\u00f3digo del for, pueda saberlo. Por ejemplo, este c\u00f3digo no es adecuado ya que para salirse del bucle del for, se est\u00e1 modificando la variable i.</p> <pre><code>import java.util.Random;\n\npublic class For6 {\n    public static void main(String[] args) {\n        int number = 0, i;\n        Random random = new Random();\n\n        for(i = 1; i &lt; = 5; i++){\n            number = random.nextInt(500) + 1;\n            System.out.printf(\"Iteraci\u00f3n %d, n\u00famero: %d\\n\", i, number);\n            if(number % 7 == 0){\n                i = 5; // No se pueden modificar las variables del for, solamente en el incremento\n            }\n        }\n\n        if(number % 7 == 0){\n            System.out.printf(\"El m\u00faltiplo de 7 encontrado vale %d\", number);\n        } else {\n            System.out.println(\"El m\u00faltiplo de 7 no se ha encontrado\");\n        }\n    }\n}\n</code></pre> Ejercicio 3 <p>Dados dos n\u00fameros n1 y n2, tal que n1 &lt;= n2, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle for.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-for-each","title":"Bucle for-each","text":"<p>Una de las cosas que incorpor\u00f3 Java 5 fue el bucle for-each. Esta estructura nos permite recorrer una colecci\u00f3n o un array de elementos de una forma sencilla, evitando el uso de iteradores o de un bucle for normal.</p> <p>Tambi\u00e9n se usa el for-each para recorrer los valores de un enum. Para ello, se utiliza el m\u00e9todo values() de los enum que est\u00e1 impl\u00edcitamente declarado por el compilador:</p> EstructuraEjemplo <pre><code>for(TipoVariable variable : values){\n    //instrucciones\n}\n</code></pre> <pre><code>public class ForEachEnum {\n    public enum DayOfWeek{\n        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n    }\n\n    public static void main(String[] args) {\n        for (DayOfWeek d : DayOfWeek.values()) {\n            System.out.println(d);\n        }\n    }\n}\n</code></pre> Ejercicio 4 <p>Crea un enum con los meses del a\u00f1o, y haciendo uso de un bucle for-each, muestra aquellos meses de verano.</p>"},{"location":"bloque_i/tema_2/page-2/#ejercicios","title":"Ejercicios","text":"Ejercicio 5 <p>Haz un programa para simular 20 lanzamientos de un dado.</p> Ejercicio 6 <p>Genera 15 n\u00fameros aleatorios entre el rango de dos n\u00fameros solicitados al usuario.</p> Ejercicio 7 <p>Dados dos n\u00fameros enteros positivos, calcula su producto utilizando solo sumas.</p> Ejercicio 8 <p>Solic\u00edtale al usuario un n\u00famero entre 0 y 10 ambos incluidos:</p> <ul> <li>Si el usuario introduce un n\u00famero que no est\u00e9 dentro de ese rango, vuelve a ped\u00edrselo tantas veces como sea necesario, ese decir, hasta que introduzca un n\u00famero entre 0 y 10.</li> <li>Una vez obtenido el n\u00famero dentro de ese rango, muestra la tabla de multiplicar de dicho n\u00famero.</li> </ul> Ejercicio 9 <p>Realiza un programa que solicite al usuario un n\u00famero entero positivo n y dibuje un tri\u00e1ngulo de asteriscos. El tri\u00e1ngulo debe contener un asterisco en la primera l\u00ednea, dos en la segunda, etc.; es decir, en la fila en\u00e9sima deben aparecer n asteriscos. Ejemplo para n=5.</p> <pre><code>    *\n   * *\n  * * *\n * * * *\n* * * * *\n</code></pre> Ejercicio 10 <p>Realiza un programa que solicite al usuario un n\u00famero entero positivo n y dibuje un rombo de asteriscos. Por ejemplo, si n = 5 deber\u00eda dibujarse:</p> <pre><code>    *\n   * *\n  * * *\n * * * *\n* * * * *\n * * * *\n  * * *\n   * *\n    *\n</code></pre> Ejercicio 11 <p>Realiza un programa que dibuje el tri\u00e1ngulo hasta un valor dado. El tri\u00e1ngulo contiene los n\u00fameros naturales correlativos, uno en la primera l\u00ednea, dos en la segunda, etc,; es decir, en la fila en\u00e9sima aparecen n valores. Ejemplo para n=5</p> <pre><code>        1\n      1   2\n    1   2   3\n  1   2   3   4\n1   2   3   4   5\n</code></pre> Ejercicio 12 <p>Realiza un programa que dibuje una pir\u00e1mide de d\u00edgitos como la de la figura, pidiendo por teclado el n\u00famero de filas de la misma. Ejemplo para n = 5:</p> <pre><code>            1\n         1  2  1\n      1  2  3  2  1\n   1  2  3  4  3  2  1\n1  2  3  4  5  4  3  2  1\n</code></pre> Ejercicio 13 <p>Crea un programa que dibuje un table de ajedrez.</p> Ejercicio 14 <p>Solic\u00edtale al usuario una casilla de un tablero de ajedrez. Dibuja el tablero de ajedrez con el alfil colocado en dicha casilla y marca con un color diferente en el tablero las casillas a las que puede mover dicho alfil.</p> Ejercicio 15 <p>Realiza un dibujo de una estrella de 6 puntas. Solic\u00edtale al usuario:</p> <ul> <li>La altura de las puntas, como m\u00ednimo 2.</li> <li>El color de la estrella: rojo o verde.</li> </ul> <p> Figura 1 - Salida del ejercicio 15 </p> Ejercicio 16 <p>Realiza un dibujo de un c\u00edrculo rojo con fondo amarillo. Solic\u00edtale al usuario el n\u00famero de l\u00edneas. </p> <p>Ejemplo con 13 l\u00edneas</p> <p> Figura 2 - Salida del ejercicio 16 </p> <p>Ejemplo con 21 l\u00edneas:</p> <p> Figura 3 - Salida del ejercicio 16 </p>"},{"location":"bloque_i/tema_2/page-3/","title":"3 Funciones","text":""},{"location":"bloque_i/tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ol> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ol> <p>Dichas  funciones  se  pueden  utilizar  desde  muchos  sitios  diferentes,  por  lo  que  de  manera general, no se suelen poner mensajes en consola en las funciones ya que puede ser que dichos mensajes no interesen en todos los sitios donde se utilice dicha funci\u00f3n. A no ser que la funci\u00f3n se haya creado espec\u00edficamente para dar mensajes informativos en consola.</p>"},{"location":"bloque_i/tema_2/page-3/#construccion","title":"Construcci\u00f3n","text":"<p>Una funci\u00f3n se construye de la siguiente manera:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro nombre_par\u00e1metro, ...){\n    // instrucciones\n    return expresi\u00f3n;\n}\n</code></pre> <ul> <li>modificador_acceso: es la visibilidad que posee la funci\u00f3n (Lo veremos m\u00e1s adelante. De momento, lo utilizaremos como public).</li> <li>tipo_resultado: es el tipo del resultado que devuelve la funci\u00f3n.</li> <li>nombre_funci\u00f3n:  es  el  nombre  que  identifica  a  la  funci\u00f3n.  Utiliza  la  notaci\u00f3n lowerCamelCase. Ejemplo: imprimirResultadoDecimal.</li> <li>tipo_par\u00e1metro  nombre_par\u00e1metro,  ...:  puede  ocurrir  que  la  funci\u00f3n  necesite  ciertos valores para efectuar la misi\u00f3n para la que ha sido creada. Por ejemplo, la funci\u00f3n suma necesitar\u00eda los valores que tiene que sumar. En este caso, se deben indicar cada uno de dichos  valores  con  sus  tipos  correspondientes.  A  estos  valores  se  les  conoce  como par\u00e1metros de la funci\u00f3n. Si la funci\u00f3n no necesita par\u00e1metros, entonces solamente se ponen los par\u00e9ntesis: <code>nombre_funci\u00f3n( )</code>.</li> </ul> <p>A todo esto se le conoce como firma (signature) de la funci\u00f3n:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro nombre_par\u00e1metro, ...)\n</code></pre> <ul> <li>instrucciones: instrucciones que conforman el algoritmo de la funci\u00f3n, para que realice la misi\u00f3n para la que ha sido creada.</li> <li>return expresi\u00f3n: con el return se termina la ejecuci\u00f3n de la funci\u00f3n y si va acompa\u00f1ado de una expresi\u00f3n, la funci\u00f3n devuelve como resultado el valor de dicha expresi\u00f3n. Dicho valor tiene que ser del tipo_resultado indicado en la firma de la funci\u00f3n.</li> </ul> <p>Ejemplo de la funci\u00f3n con dos par\u00e1metros:</p> <pre><code>public static int add(int sum1, int sum2){\n    return sum1 + sum2;\n}\n</code></pre> <p>Puede ser tambi\u00e9n que haya m\u00e1s de un return. En ese caso, el flujo de ejecuci\u00f3n abandona la funci\u00f3n en cuanto ejecute el primer return. Ejemplo:</p> <pre><code>public static boolean isPair(int n){\n    if(n % 2 == 0){\n        return true;\n    } else {\n        return false;\n    }\n}\n</code></pre> <p>En el caso de que estemos definiendo un procedimiento, no tendremos <code>return expresi\u00f3n</code> ya que no devuelve ning\u00fan resultado y el tipo_resultado es void. Como por ejemplo <code>System.put.println</code>, que escribe en pantalla lo que recibe por par\u00e1metro pero no devuelve nada.</p>"},{"location":"bloque_i/tema_2/page-3/#llamada-a-la-funcion","title":"Llamada a la funci\u00f3n","text":"<p>Una funci\u00f3n permite que reutilicemos un algoritmo ya que se puede utilizar cuando nos haga falta.  Para  ello,  solamente  tendremos  que  llamar  a  la  funci\u00f3n  por  su  nombre  y  pasarle  los par\u00e1metros en el mismo orden que se han definido y pertenecientes al mismo tipo de dato o compatible. En la llamada, dichos par\u00e1metros se llaman argumentos, es decir, los argumentos son los valores iniciales de los par\u00e1metros.</p> <pre><code>public class Functions1 {\n    public static void main(String[] args) {\n        boolean pair;\n        int result;\n\n        /*\n         * Se llama a la funci\u00f3n isPair con un valor de 5 en el argumento, es decir,\n         * el valor inicial del par\u00e1metro n es 5:\n         */\n        pair = isPair(5);\n        System.out.println(pair); // false\n\n        /*\n         * Se lla a la funci\u00f3n isPair con un valor de 4 en el argumento, es decir,\n         * ahora el valor inicial del par\u00e1metro n es 4.\n         */\n        pair = isPair(4);\n        System.out.println(pair); // true\n\n        /*\n         * Se llama a la funci\u00f3n add con los valores 5 y 2 en los argumentos, es decir,\n         * los valores iniciales de los par\u00e1metros sum1 y sum2 son 5 y 2 respectivamente.\n         */\n        result = add(5,2);\n        System.out.println(result); // 7\n    }\n\n    public static int add(int sum1, int sum2){\n        return sum1 + sum2;\n    }\n\n    public static boolean isPair(int n){\n        if(n % 2 == 0){\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n</code></pre> Ejercicio 1 <p>Realiza una funci\u00f3n que reciba la base y el exponente y devuelva la potencia base<sup>exponente</sup> sin utilizar Math.pow</p>"},{"location":"bloque_i/tema_2/page-3/#ambito-de-vida-de-los-parametros","title":"\u00c1mbito de vida de los par\u00e1metros","text":"<p>A nivel de visibilidad y de \u00e1mbito de vida, los par\u00e1metros funcionan como las variables locales (Ver tema 1.3 Variables y constantes 4. \u00c1mbito de vida de las variables), por lo tanto el \u00e1mbito de vida de los par\u00e1metros es el bloque donde han sido definidos, es decir, la propia funci\u00f3n. Cada vez  que  se  llame  a  la  funci\u00f3n,  los  par\u00e1metros  nacen,  se  ejecuta  la  funci\u00f3n  y  una  vez  que  la funci\u00f3n ha terminado de ejecutarse, los par\u00e1metros mueren.</p> <pre><code>public class Functions2 {\n    public static void main(String[] args) {\n        boolean pair;\n        int result;\n\n        pair = isPair(5); //(1)!\n\n        //(2)!\n\n        System.out.println(pair);\n        pair = isPair(4); //(3)!\n\n        //(4)!\n\n        System.out.println(pair);\n\n        result = add(5, 2); //(5)!\n\n        //(6)!\n\n        System.out.println(result);\n    }\n\n    public static int add(int sum1, int sum2){ //(7)!\n        return sum1 + sum2;\n    } //(8)!\n\n    public static boolean isPair(int n){ //(9)!\n        if(n % 2 == 0){\n            return true;\n        } else {\n            return false;\n        }\n    } //(10)!\n}\n</code></pre> <ol> <li>Nace el par\u00e1metro n con el valor 5</li> <li>Aqu\u00ed n ya no existe porque la funci\u00f3n isPair ya ha terminado de ejecutarse</li> <li>Vuelve a nacer n pero esta vez con un valor de 4</li> <li>Aqu\u00ed n ya no existe porque la funci\u00f3n isPair ya ha terminado de ejecutarse</li> <li>Nacen los par\u00e1metros sum1 y sum2 con los valores 5 y 2 respectivamente</li> <li>Aqu\u00ed sum1 y sum2 ya no existen porque la funci\u00f3n add ha terminado de ejecutarse</li> <li>Comienzo del \u00e1mbito de vida de los par\u00e1metros sum1 y sum2</li> <li>Fin del \u00e1mbito de vida de los par\u00e1metros sum1 y sum2</li> <li>Comienzo del \u00e1mbito de vida del par\u00e1metro n</li> <li>Fin del \u00e1mbito de vida del par\u00e1metro n</li> </ol> Ejercicio 2 <p>Realiza una funci\u00f3n que reciba 3 par\u00e1metros: dos de tipo entero y uno de tipo car\u00e1cter. La funci\u00f3n deber\u00e1 sumar, restar, multiplicar o dividir los valores de los dos primeros par\u00e1metros dependiendo de la operaci\u00f3n indicada en el tercer par\u00e1metro, y devolver el resultado</p> Ejercicio 3 <p>Sobrecarga la funci\u00f3n del ejercicio anterior para que se pueda operar con enteros y con decimales. Haz un programa que utilice las dos funciones, con enteros y con decimales</p>"},{"location":"bloque_i/tema_2/page-3/#ejemplo-de-funcion-el-factorial-de-un-numero","title":"Ejemplo de funci\u00f3n: el factorial de un n\u00famero","text":"<p>El factorial de un entero positivo n, tambi\u00e9n indicado como n!, se define como el producto de todos los n\u00fameros enteros positivos desde 1 hasta n. Por ejemplo:</p> <p>5! = 1 x 2 x 3 x 4 x 5 = 120</p> <p>La  operaci\u00f3n  de  factorial  aparece  en  muchas  \u00e1reas  de  las  matem\u00e1ticas,  particularmente  en combinatoria  y  an\u00e1lisis  matem\u00e1tico.  De  manera  fundamental,  el  factorial  de  n  representa  el n\u00famero de formas distintas de ordenar n objetos distintos (elementos sin repetici\u00f3n). Este hecho ha sido conocido desde hace varios siglos, en el siglo XII, por los hind\u00faes.</p> <p>Veamos  c\u00f3mo  se  programar\u00eda  dicha  funci\u00f3n  factorial  y  las  llamadas  con  distintos  tipos  de argumentos:</p> <pre><code>import java.util.Scanner;\n\npublic class Factorial {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int n, variable;\n\n        System.out.println(\"Llamada a la funci\u00f3n con argumentos literales: \");\n        System.out.printf(\"El factorial de 5 es %d\\n\", factorial(5));\n\n        System.out.println(\"Llamada a la funci\u00f3n usando una variable como argumento: \");\n        variable = 5;\n        System.out.printf(\"El factorial de %d es %d\\n\", variable, factorial(variable));\n\n        System.out.println(\"Llamada a la funci\u00f3n usando una expresi\u00f3n como argumento: \");\n        variable = 3;\n        System.out.printf(\"El factorial de %d es %d\\n\", variable + 2, factorial(variable + 2));\n\n        System.out.println(\"Llamada a la funci\u00f3n con argumentos introducidos por el usuario: \");\n        do {\n            System.out.println(\"Introduzca un n\u00famero entero positivo: \");\n            n = keyboard.nextInt();\n        } while (n &lt;= 0);\n        System.out.printf(\"El factorial de %d es %d\", n, factorial(n));\n    }\n\n    public static int factorial(int n) {\n        int result = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n</code></pre> <p>El concepto del factorial se aplica a los n\u00fameros enteros positivos, pero como los int admiten n\u00fameros  negativos,  se  podr\u00eda  llamar  a  la  funci\u00f3n  con  un  n\u00famero  negativo  aunque  no  tenga sentido:</p> <pre><code>int result = factorial(-5); //(1)!\nSystem.out.println(\"El factorial de %d es %d\\n\", -5, result); //(2)!\n</code></pre> <ol> <li>No tiene mucho sentido porque el factorial se aplica a n\u00fameros positivos</li> <li>El factorial de -5 es 1</li> </ol> <p>Es decir, cuando programamos una funci\u00f3n, no podemos dar por hecho que el programador que la vaya a utilizar lo haga de manera adecuada con la l\u00f3gica que representa su funcionalidad. As\u00ed que  siempre  que  programemos  una  funci\u00f3n,  debemos  asegurarnos  que  va  a  funcionar correctamente para todos los valores posibles del par\u00e1metro. En nuestro caso, no podemos dar un  resultado  coherente  para  los  n\u00fameros  negativos  puesto  que  no  tiene  sentido matem\u00e1ticamente el factorial de un n\u00famero negativo, as\u00ed que lo m\u00e1s conveniente es lanzar un error cuando llamen a la funci\u00f3n con un n\u00famero negativo.</p> <pre><code>import java.util.Scanner;\n\npublic class Factorial {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int n, variable;\n\n        System.out.println(\"Llamada a la funci\u00f3n con argumentos literales: \");\n        System.out.printf(\"El factorial de 5 es %d\\n\", factorial(5));\n\n        System.out.println(\"Llamada a la funci\u00f3n usando una variable como argumento: \");\n        variable = 5;\n        System.out.printf(\"El factorial de %d es %d\\n\", variable, factorial(variable));\n\n        System.out.println(\"Llamada a la funci\u00f3n usando una expresi\u00f3n como argumento: \");\n        variable = 3;\n        System.out.printf(\"El factorial de %d es %d\\n\", variable + 2, factorial(variable + 2));\n\n        System.out.println(\"Llamada a la funci\u00f3n con argumentos introducidos por el usuario: \");\n        do {\n            System.out.println(\"Introduzca un n\u00famero entero positivo: \");\n            n = keyboard.nextInt();\n        } while (n &lt;= 0);\n        System.out.printf(\"El factorial de %d es %d\", n, factorial(n));\n\n        System.out.println(\"Llamada a la funci\u00f3n con argumentos negativos\");\n        variable = - 5;\n        System.out.printf(\"El factorial %d es %d\\n\", variable, factorial(variable));\n    }\n\n    public static int factorial(int n) {\n        int result = 1;\n\n        if(n &lt; 0){\n            throw new IllegalArgumentException(\"El factorial se aplica a n\u00fameros positivos\");\n        }\n\n        for (int i = 2; i &lt;= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n</code></pre> <p>Salida por consola:</p> <pre><code>Exception in thread \"main\" java.lang.IllegalArgumentException: El factorial se \naplica a n\u00fameros positivos\n    at tema2_3_Funciones.Factorial3.factorial(Factorial3.java:19)\n    at tema2_3_Funciones.Factorial3.main(Factorial3.java:9)\n</code></pre> Ejercicio 4 <p>Realiza una funci\u00f3n que encuentre el primer valor N para el que la suma <code>1 + 2 + 3 + .. + N</code> exceda a un valor M que se introduce por par\u00e1metro. Es decir, si M vale:</p> <ul> <li>1: devuelve 2</li> <li>3: devuelve 3</li> <li>7: devuelve 4</li> <li>10: devuelve 5</li> <li>15: devuelve 6</li> </ul> Ejercicio 5 <p>El m\u00e1ximo com\u00fan divisor de dos enteros es el entero m\u00e1s grande que es divisor exacto de los dos n\u00fameros. Realiza una funci\u00f3n que devuelva el m\u00e1ximo com\u00fan divisor de dos enteros. Por ejemplo, 12 es el mcd de 36 y 60.</p>"},{"location":"bloque_i/tema_2/page-3/#ejemplo-de-procedimiento","title":"Ejemplo de Procedimiento","text":"<p>No tendremos  <code>return expresi\u00f3n</code>  ya que no devuelve ning\u00fan resultado y el <code>tipo_resultado</code> es void:</p> <pre><code>import java.util.Scanner;\n\nimport static examples.tema_01.Colors.GREEN;\nimport static examples.tema_01.Colors.RESET;\n\npublic class Procedure {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        String string;\n\n        System.out.print(\"Introduce una cadena: \");\n        string = keyboard.nextLine();\n        paintGreen(string);\n    }\n\n    private static void paintGreen(String string) {\n        System.out.printf(\"La cadena que has introducido en verde: %s\", GREEN + string + RESET);\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#resultado-de-las-funciones","title":"Resultado de las funciones","text":"<p>En las llamadas a funciones, no hay que obligatoriamente utilizar el valor devuelto:</p> <pre><code>import java.util.Scanner;\n\nimport static examples.tema_01.Colors.GREEN;\nimport static examples.tema_01.Colors.RESET;\n\npublic class Result {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        String string, stringGreen;\n\n        System.out.print(\"Introduce una cadena: \");\n        string = keyboard.nextLine();\n\n        /*\n         * En la llamada a la funci\u00f3n turnGreen, no estamos utilizando el valor devuelto\n         */\n        turnGreen(string);\n\n        /*\n         * En la siguiente llamada, s\u00ed lo vamos a utilizar\n         */\n        stringGreen = turnGreen(string);\n        System.out.printf(\"La cadena %s convertida a verde: %s\", string, stringGreen);\n    }\n\n    private static String turnGreen(String string) {\n        String result = String.format(\"%s\", GREEN + string + RESET);\n        System.out.println(result);\n        return result;\n    }\n}\n</code></pre> Ejercicio 6 <p>Se dice que un n\u00famero entero es primo si s\u00f3lo es divisible entre 1 y entre s\u00ed mismo. Por ejemplo, 2, 3, 5 y 7 son primos, pero 4, 6, 8 y 9 no lo son.</p> <ol> <li>Realiza una funci\u00f3n que determine si un n\u00famero es primo o no.</li> <li>Realiza una funci\u00f3n que muestre todos los n\u00fameros primos comprendidos entre 1 y 10.000</li> <li>Realiza una funci\u00f3n que descomponga un n\u00famero en factores primos. Ejemplo:<ul> <li>18 = 2 x 3 x 3</li> <li>11 = 11</li> <li>35 = 5 x 7</li> <li>40 = 2 x 2 x 2 x 5</li> </ul> </li> </ol> Ejercicio 7 <p>Se dice que un n\u00famero entero es un n\u00famero perfecto si la suma de sus divisores propios (incluyendo el 1 y sin incluirse \u00e9l mismo) da como resultado el mismo n\u00famero. Por ejemplo, 6 es un n\u00famero perfecto, porque sus divisores propios son 1, 2 y 3; y 6 = 1 + 2 + 3. Los siguientes n\u00fameros perfectos son 28, 496 y 8128.</p> <ol> <li>Realiza una funci\u00f3n que determine si el par\u00e1metro es perfecto o no.</li> <li>Realiza una funci\u00f3n que dado un n\u00famero perfecto, imprima los divisores para confirmar que el n\u00famero es perfecto. Si no lo es, que no haga nada.</li> <li>Realiza una funci\u00f3n que muestre todos los n\u00fameros perfectos entre 1 y 10.000 con sus correspondientes factores.</li> </ol> Ejercicio 8 <p>La serie Fibonacci se define mediante: a<sub>0</sub> = 0 a<sub>1</sub> = 1 a<sub>n</sub> = a<sub>n-1</sub> + a<sub>n-2</sub>, es decir, la serie Fibonacci ser\u00eda la siguiente 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p> <ol> <li>Realiza una funci\u00f3n que devuelva el elemento en\u00e9simo de la serie Fibonacci. Es decir, si recibe:<ul> <li>0: devuelve 0</li> <li>1: devuelve 1</li> <li>4: devuelve 3</li> <li>7: devuelve 13</li> </ul> </li> <li>Realiza una funci\u00f3n que muestre los 30 primeros n\u00fameros de la serie de Fibonacci</li> <li>Realiza una funci\u00f3n que calcule el primer elemento de la serie Fibonacci que se mayor o igual que un valor introducido por par\u00e1metro. Por ejemplo, si recibe 20, devolver\u00e1 21, ya que es el primer elemento de la serie mayor o igual que 20.</li> </ol> Ejercicio 9 <p>Realiza una funci\u00f3n que reciba un n\u00famero entero positivo de n cifras y devuelva el n\u00famero con sus cifras en orden inverso. No utilizar String ni calcular previamente el n\u00famero de cifras. Ej: 24.321 debe devolver 12.345</p>"},{"location":"bloque_i/tema_2/page-3/#recursividad","title":"Recursividad","text":"<p>La recursividad es una t\u00e9cnica de escritura de funciones pensada para problemas complejos. La idea parte de que una funci\u00f3n pueda invocarse a s\u00ed misma.</p> <p>Esta t\u00e9cnica es peligrosa ya que se pueden generar f\u00e1cilmente llamadas infinitas (la funci\u00f3n se llama a s\u00ed misma, tras la llamada se vuelve a llamar a s\u00ed misma, y as\u00ed sucesivamente sin freno ni control).  Por  lo  tanto,  es  muy  importante  tener  en  cuenta  cu\u00e1ndo  la  funci\u00f3n  debe  dejar  de llamarse.</p> <p>Hay  que  ser  muy  cauteloso  cuando  se  utiliza  la  recursividad,  pero  permite  soluciones  muy originales y abre la posibilidad de solucionar problemas muy complejos.</p> <p>Veamos como ejemplo la versi\u00f3n recursiva del factorial:</p> <pre><code>import java.util.Scanner;\n\npublic class RecursiveFactorial {\n    public static void main(String[] args) {\n        Scanner keyboard = new Scanner(System.in);\n        int n;\n\n        do{\n            System.out.println(\"Introduce un n\u00famero entero positivo: \");\n            n = keyboard.nextInt();\n        } while (n &lt;= 0);\n\n        System.out.printf(\"El factorial de %d es %d\\n\", factorial(n));\n    }\n\n    private static int factorial(int n) {\n        int result;\n        if(n == 1){ // Caso base: devuelve 1\n            result = 1;\n        } else { // Caso recursivo\n            result = n * factorial(n-1);\n        }\n\n        /*\n         * Mensaje intermedio para comprobar\n         * como funciona\n         */\n        System.out.printf(\"Factorial de %d  Resultado: %d\\n\", n, result);\n\n        return result;\n    }\n}\n</code></pre> <p>\u00bfRecursividad o iteraci\u00f3n? Hay otra versi\u00f3n del factorial resuelto mediante un bucle for (soluci\u00f3n iterativa) en lugar de utilizar la recursividad. La cuesti\u00f3n es \u00bfcu\u00e1l es mejor? Ambas implican sentencias repetitivas hasta llegar a una determinada condici\u00f3n, por lo que ambas pueden generar programas que no finalizan si la condici\u00f3n nunca se cumple. En el caso de la iteraci\u00f3n es una condici\u00f3n la que permite determinar el final, la recursividad lo que hace es ir simplificando el problema hasta generar una llamada a la funci\u00f3n que devuelva un valor y no se vuelva a llamar. Para un ordenador es m\u00e1s costosa la recursividad ya que implicar realizar muchas llamadas a funciones, es decir, es m\u00e1s r\u00e1pida la soluci\u00f3n iterativa. Entonces, \u00bfpor qu\u00e9 elegir recursividad? La recursividad se utiliza s\u00f3lo s\u00ed:</p> <ul> <li>No encontramos la soluci\u00f3n iterativa a un problema.</li> <li>El c\u00f3digo es mucho m\u00e1s claro en su versi\u00f3n recursiva.</li> </ul> Ejercicio 10 <p>Realiza el ejercicio 1, haciendo uso de la recursividad</p> Ejercicio 11 <p>El m\u00e1ximo com\u00fan divisor de los enteros a y b es el entero m\u00e1s grande que es divisor exacto de a y de b. Escribe una funci\u00f3n recursiva llamada gcd que devuelva el m\u00e1ximo com\u00fan divisor de a y b. El m\u00e1ximo com\u00fan divisor de a y b se define recursivamente como sigue:</p> <ul> <li>si b = 0 \u2192 gcd(a, b) = a</li> <li>si b \u2260 0 \u2192 gcd(a, b) = gcd(b, a % b)</li> </ul> Ejercicio 12 <p>Realiza el ejercicio 4 haciendo uso de la recursividad</p> Ejercicio 13 <p>Realiza el ejercicio 8 haciendo uso de la recursividad</p>"},{"location":"bloque_i/tema_2/page-3/#la-pila","title":"La pila","text":"<p>Una pila(stack) es una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del ingl\u00e9s Last In, First Out, \u00faltimo en entrar,  primero  en  salir) de  supuestos  en  el  \u00e1rea  de inform\u00e1tica debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.</p> <p>Para el manejo de los datos cuenta con dos operaciones b\u00e1sicas: apilar (push), que coloca un objeto en la pila, y su operaci\u00f3n inversa, desapilar (pop), que retira el \u00faltimo elemento apilado.</p> <p>En cada momento s\u00f3lo se tiene acceso a la parte superior de la pila, es decir, al \u00faltimo objeto apilado  (denominado  TOS,  Top of Stack).  La  operaci\u00f3n  desapilar  permite  la  obtenci\u00f3n  de  este elemento, que es retirado de la pila permitiendo el acceso al anterior (apilado con anterioridad), que pasa a ser el \u00faltimo, el nuevo TOS.</p> <p>Para las llamadas entre funciones, se utiliza una estructura de tipo pila: supongamos que se est\u00e1 procesando  una  funci\u00f3n  y  en  su  interior  llama  a  otra  funci\u00f3n.  La  funci\u00f3n  se  abandona  para procesar la funci\u00f3n de la llamada, pero antes se almacena en una pila la direcci\u00f3n que apunta a la funci\u00f3n. Ahora supongamos que esa nueva funci\u00f3n llama a su vez a otra funci\u00f3n. Igualmente, se almacena su direcci\u00f3n, se abandona y se atiende la petici\u00f3n. As\u00ed en tantos casos como existan peticiones.  La  ventaja  de  la  pila  es  que  no  requiere  definir  ninguna  estructura  de  control  ni conocer las veces que el programa estar\u00e1 saltando entre funciones para despu\u00e9s retomarlas, con la \u00fanica limitaci\u00f3n de la capacidad de almacenamiento de la pila. Conforme se van cerrando las funciones, se van rescatando las funciones precedentes mediante sus direcciones almacenadas en la pila y se va concluyendo su proceso, esto hasta llegar a la primera.</p> <p>En el caso de una funci\u00f3n recursiva, esto es posible implementarlo con sencillez mediante una pila. La funci\u00f3n se llama a s\u00ed misma tantas veces como sea necesario hasta que el resultado de la funci\u00f3n cumpla la condici\u00f3n de retorno; entonces, todas las funciones abiertas van completando su proceso en cascada. No se necesita saber cuantas veces se anidar\u00e1 y, por tanto, tampoco cuando  se  cumplir\u00e1  la  condici\u00f3n,  con  la  \u00fanica  limitaci\u00f3n  de  la  capacidad  de  la  pila.  De sobrepasarse ese l\u00edmite, normalmente porque se entra en un bucle sin final, se produce el error de desbordamiento de la pila (stack overflow).</p> Ejercicio 15 <p>Realiza una funci\u00f3n recursiva que invierta los caracteres de una cadena. Por ejemplo, si la funci\u00f3n recibe \"Hola a todos\", devuelve \"sodot a aloH\".</p> Ejercicio 14 <p>Realiza  un  programa  para  resolver  el  juego  de  las  Torres de Hanoi.  El  juego  consiste  en  tres  varillas verticales. En una de las varillas se apila un n\u00famero indeterminado de discos. Los discos se apilan sobre una varilla en tama\u00f1o decreciente. No hay dos discos iguales, y todos ellos est\u00e1n apilados de mayor a menor radio en una de las varillas, quedando las otras dos varillas vacantes. El juego consiste en pasar todos los discos de la varilla ocupada a una de las otras varillas vacantes. Para realizar este objetivo, es necesario seguir estas simples reglas:</p> <ul> <li>Solo se puede mover un disco cada vez.</li> <li>Un disco de mayor tama\u00f1o no puede descansar sobre uno m\u00e1s peque\u00f1o que \u00e9l mismo.</li> <li>Solo puedes desplazar el disco que se encuentre arriba en cada varilla.</li> </ul> <p>El movimiento de n discos se puede visualizar en t\u00e9rminos de mover s\u00f3lo n-1 discos (y de ah\u00ed la recursividad) como sigue:</p> <ol> <li>Pasar n-1 discos de la varilla 1 a la 2, usando la varilla 3 como \u00e1rea de retenci\u00f3n temporal.</li> <li>Pasar el \u00faltimo disco (el m\u00e1s grande) de la varilla 1 a la 3.</li> <li>Pasar los n-1 discos de la varilla 2 a la 3, empleando la varilla 1 como \u00e1rea de retenci\u00f3n temporal.</li> </ol> <p>El  proceso  termina  cuando  la  \u00faltima  tarea  implica  pasar  n=1  disco,  esto  es,  el  caso  base.  Esto  se  logra transfiriendo  el  disco  sin  necesidad  de  un  \u00e1rea  de  retenci\u00f3n  temporal.  Escribe  una  funci\u00f3n  recursiva  con cuatro par\u00e1metros:</p> <ol> <li>El n\u00famero de discos por transferir.</li> <li>La varilla en la que est\u00e1n colocados inicialmente esos discos.</li> <li>La varilla a la que debe pasarse esa pila de discos.</li> <li>La varilla que se usar\u00e1 como \u00e1rea de retenci\u00f3n temporal.</li> </ol> <p>El programa deber\u00e1 imprimir las instrucciones precisas requeridas para pasar los discos de la varilla inicial a  la varilla de destino. Por ejemplo, para pasar una pila de tres discos de la varilla 1 a la varilla 3, el programa deber\u00e1 imprimir la siguiente serie de movimientos:</p> <pre><code>1 \u2192 3\n1 \u2192 2\n3 \u2192 2\n1 \u2192 3\n2 \u2192 1\n2 \u2192 3\n1 \u2192 3\n</code></pre>"},{"location":"bloque_i/tema_2/page-4/","title":"Proyecto","text":"<p>Se desea realizar un proyecto Java en el cu\u00e1l se le mostrar\u00e1 al usuario un men\u00fa d\u00f3nde se le solicitar\u00e1 una de las siguiente figuras, teniendo en cuenta que cada vez que acceda a una de ellas, se les solicitar\u00e1 los datos pertinentes para el calculo de su \u00e1rea. Las figuras son las siguientes:</p> <ol> <li>Tri\u00e1ngulo (solicitar base y altura)</li> <li>Cuadrado (solicitar lado)</li> <li>Rect\u00e1ngulo (solicitar base y altura)</li> <li>Rombo (solicitar diagonal mayor y menor)</li> <li>Romboide (solicitar base y altura)</li> <li>Trapecio (solicitar base mayor, base menor y altura)</li> <li>C\u00edrculo (solicitar di\u00e1metro)</li> </ol> <p>Una vez realizado el \u00e1rea se deber\u00e1 comprobar sin hacer uso del resto de la divisi\u00f3n si el \u00e1rea (solo la parte entera) es m\u00faltiplo de 3 y de 9.</p> <p>Adem\u00e1s se le dar\u00e1 una opci\u00f3n al usuario para salir del men\u00fa, ya que aunque el usuario elija una opci\u00f3n se le volver\u00e1 a mostrar el men\u00fa de opciones una vez finalizada la operaci\u00f3n.</p> <p>Para realizar el proyecto se tendr\u00e1 en cuenta los siguientes objeciones:</p> <ol> <li>Se crear\u00e1 un proyecto nuevo cuyo nombre sea el siguiente formato pr02java-NOMBRE-geometria siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>Se har\u00e1 uso de la recursividad donde sea necesario.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ol>"},{"location":"bloque_i/tema_3/page-1/","title":"1 Cadenas","text":""},{"location":"bloque_i/tema_3/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>El texto es uno de los tipos de datos m\u00e1s importantes y por ello java lo trata de manera especial. Las cadenas deben manejarse creando objetos de tipo String. Se pueden inicializar de dos maneras:</p> <ul> <li>Usando el operador asignaci\u00f3n como los primitivos: <code>String s = \"hola\"</code></li> <li>Usando el constructor como los objetos: <code>String s = new String(\"hola\");</code></li> </ul> <p>Los literales cadena se escriben entre comillas dobles: <code>\"Esto es un literal cadena\"</code>.</p> <p>En Java existe tambi\u00e9n la cadena vac\u00eda o nula(\"\"), es decir, una cadena sin ning\u00fan car\u00e1cter.</p> <p>Ejemplo: <code>String s = \"\";</code> A la variable s se le est\u00e1 asignando la cadena vac\u00eda o nula.</p>"},{"location":"bloque_i/tema_3/page-1/#inmutabulidad","title":"Inmutabulidad","text":"<p>Uno  de  los  conceptos  que  suele  venir  asociado  a  la  programaci\u00f3n  funcional  es  el  de  la inmutabilidad.  Si  bien  es  cierto  que  la  inmutabilidad  es  una  idea  que  no  es  exclusiva  de  la programaci\u00f3n  funcional,  s\u00ed  que  cobra  una  importancia  vital  en  este  tipo  de  lenguajes.  La programaci\u00f3n funcional se asienta sobre muchos conceptos matem\u00e1ticos que requieren de la inmutabilidad para seguir siendo v\u00e1lidos. A\u00fan as\u00ed, es un concepto que es interesante conocer independientemente del tipo de paradigma de programaci\u00f3n que se utilice.</p>"},{"location":"bloque_i/tema_3/page-1/#que-es-la-inmutabilidad","title":"\u00bfQu\u00e9 es la inmutabilidad?","text":"<p>La idea es muy sencilla de entender: algo es inmutable cuando no se puede modificar. En el contexto de la programaci\u00f3n, una variable es inmutable cuando su valor no se puede modificar. Y un objeto lo es cuando su estado no puede ser actualizado tras la creaci\u00f3n del objeto. Es por tanto una forma de asegurar que los objetos no se modifican en lugares inesperados afectando con ello la ejecuci\u00f3n de nuestro programa.</p> <p>La inmutabilidad genera muchas ventajas en las aplicaciones multihilo, donde la inmutabilidad simplifica mucho el tratamiento de la concurrencia. Si algo no se puede modificar, da igual que se acceda a ello desde distintos hilos a la vez, as\u00ed como el orden en que se haga.</p> <p>La inmutabilidad hace que el c\u00f3digo sea mucho m\u00e1s predecible y m\u00e1s f\u00e1cil de testear, porque se acota mucho m\u00e1s los lugares donde se producen modificaciones de estado.</p> <p>La inmutabilidad tiene el sobrecoste de la generaci\u00f3n de objetos nuevos cada vez que cambia el estado, as\u00ed que esto puede penalizar bastante en el rendimiento. As\u00ed como gu\u00eda muy general, es recomendable usar objetos mutables en cualquier situaci\u00f3n que requiera de un estado que se modifica a menudo y/o la duplicaci\u00f3n de ese estado sea costosa.</p> <p>La inmutabilidad, por el contrario, presenta ventajas en las siguientes situaciones:</p> <ul> <li>En objetos que no vayan a requerir modificaciones de estado.</li> <li>En objetos que sean simples de duplicar.</li> <li>En situaciones de concurrencia.</li> </ul> <p>As\u00ed que hay que hacer inmutable todo el c\u00f3digo que sea posible ya que es un concepto muy potente que nos puede ayudar a simplificar la complejidad de comprensi\u00f3n de nuestro c\u00f3digo y, por tanto, a disminuir las probabilidades de que se produzcan errores inesperados.</p> <p>En java, los objetos String son inmutables.</p>"},{"location":"bloque_i/tema_3/page-1/#formatos-de-codificacion-de-caracteres","title":"Formatos de codificaci\u00f3n de caracteres","text":"<p>En  el  Unicode,  el  Plano  Multiling\u00fce  B\u00e1sico  (Basic  Multilingual  Plane,  BMP)  incluye  los  65.536 caracteres  cuyos  c\u00f3digos  van  desde  U+0000  a  U+FFFF,  que  son  la  mayor\u00eda  de  los  caracteres utilizados m\u00e1s frecuentemente.</p> <p>El n\u00famero 65.536 es 2 elevado a 16, es decir, la cantidad m\u00e1xima de combinaciones de bits que se pueden obtener en dos bytes.</p> <p>El resto de caracteres se denominan caracteres complementarios.</p> <p>Los formatos de codificaci\u00f3n que se pueden usar con Unicode se denominan UTF-8, UTF-16 y UTF-32:</p> <p>UTF-8  utiliza  1  byte  para  representar  caracteres  ASCII,  dos  bytes  para  caracteres  en  otros bloques alfab\u00e9ticos y tres bytes para el resto del BMP. Para los caracteres complementarios se utilizan 4 bytes.</p> <p>UTF-16  utiliza  2  bytes  para  cualquier  car\u00e1cter  en  el  BMP  y  4  bytes  para  los  caracteres complementarios.</p> <p>UTF-32 emplea 4 bytes para todos los caracteres.</p> <p> Figura 1 - Encodings</p> <p>En Java, las cadenas utilizan el formato de codificaci\u00f3n UTF-16.</p>"},{"location":"bloque_i/tema_3/page-1/#formateo-de-cadenas","title":"Formateo de cadenas","text":"<p>Hay un m\u00e9todo est\u00e1tico en la clase String que sirve para construir una cadena con cierto formato. Funciona de la misma manera que el m\u00e9todo <code>printf</code> que vimos en el tema 1.12. Escritura en pantalla.</p> <pre><code>public class StringFormat {\n    public static void main(String[] args) {\n        String formattedString;\n        formattedString = String.format(\"Nombre: %s Edad: %d Sueldo: %.2f\", \"Juan\", 20, 1896.23);\n        System.out.println(formattedString);\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#metodos-de-la-clase-string","title":"M\u00e9todos de la clase String","text":"<p>Si observamos en la API la clase String, incluye m\u00e9todos para examinar los caracteres individuales de una cadena, para comparar cadenas, para buscar cadenas, para extraer subcadenas, para convertir cadenas a may\u00fasculas o min\u00fasculas, etc.</p> <p>Como vimos en el Tema 1.5 - Operadores, el operador concatenaci\u00f3n <code>+</code> es un operador binario que devuelve una cadena resultado para concatenar las dos cadenas que act\u00faan como operandos. Si s\u00f3lo uno de los operandos es de tipo cadena, el otro operando se convierte impl\u00edcitamente en tipo cadena.</p> <p>Obs\u00e9rvese en la API en el m\u00e9todo valueOf, es est\u00e1tico y est\u00e1 sobrecargado. Sirve para obtener la representaci\u00f3n String de un valor u objeto.</p> <pre><code>public class StringConcatPlus {\n    public static void main(String[] args) {\n        int i = 100;\n        String string1, string2, string3, string4;\n\n        string1 = \"Esto es un literal cadena\"; //(1)!\n        System.out.println(string1);\n        System.out.println(string1 + \" al cual le hemos concatenado este literal cadena\"); //(2)!\n\n        string2 = \"hola\";\n        string3 = \" que tal\";\n        string4 = string2 + string3;\n        System.out.println(string4);\n\n        System.out.println(i + 100);\n        System.out.println(String.valueOf(i) + 100);\n    }\n}\n</code></pre> <ol> <li>Se le da un valor inicial con el operador asignaci\u00f3n</li> <li>Se concatena otra cadena con el operador +</li> </ol> <p>Otros m\u00e9todos de las cadenas muy \u00fatiles son:</p> <ul> <li>charAt: devuelve el car\u00e1cter de la cadena del especificado \u00edndice. Dicho \u00edndice empieza en cero, es decir, con el cero se obtiene el primer car\u00e1cter de la cadena.</li> <li>length: devuelve la longitud de la cadena.</li> <li>equals: compara si dos cadenas son iguales. Las cadenas se comparan con equals como los objetos y los primitivos se comparan con <code>==</code>.</li> <li>equalsIgnoreCase: hace lo mismo que el anterior pero no tiene en cuenta las may\u00fasculas y min\u00fasculas.</li> </ul> <pre><code>public class StringMethods {\n    public static void main(String[] args) {\n        String string = \"hola\";\n        System.out.println(string.charAt(0));//h\n        System.out.println(string.charAt(1));//o\n        System.out.println(string.charAt(2));//l\n        System.out.println(string.charAt(3));//a\n        System.out.println(string.length());//4\n        System.out.println(string.equals(\"hola\"));//true\n        System.out.println(string.equals(\"Hola\"));//false\n        System.out.println(string.equals(\"adi\u00f3s\"));//false\n        System.out.println(string.equalsIgnoreCase(\"Hola\"));//true\n        System.out.println(string.equalsIgnoreCase(\"HOLA\"));//true\n\n        //Tambi\u00e9n se le pueden aplicar m\u00e9todos a un literal cadena:\n        System.out.println(\"hola\".equals(\"hola\")); //true\n        System.out.println(\"adios\".equals(\"hola\"));//false\n    }\n}\n</code></pre> <p>M\u00e1s m\u00e9todos de cadenas interesantes:</p> <ul> <li>compareTo: compara dos cadenas lexicogr\u00e1ficamente. La comparaci\u00f3n se basa en el valor Unicode de cada car\u00e1cter de las cadenas. <code>s1.compareTo(s2)</code> devuelve un n\u00famero negativo si s1 es menor, un n\u00famero positivo si s1 es mayor o cero si son iguales.</li> <li>compareToIgnoreCase: hace lo mismo que el anterior pero no tiene en cuenta may\u00fasculas y min\u00fasculas.</li> <li>concat: se utiliza para concatenar cadenas, como el operador <code>+</code>.</li> <li>endsWith: devuelve true si la cadena termina con un determinado texto.</li> <li>startsWith: devuelve true si la cadena empieza con un determinado texto.</li> <li>indexOf: devuelve la primera posici\u00f3n en la que aparece un determinado texto en la cadena. En el caso de que el texto buscado no se encuentre, devuelve -1. Este m\u00e9todo est\u00e1 sobrecargado para que el texto a buscar pueda ser char o String.</li> <li>lastIndexOf: es como el anterior pero busca desde el final.</li> <li>isEmpty: devuelve true si la cadena est\u00e1 vac\u00eda, es decir, si su longitud es cero.</li> <li>repeat: devuelve una cadena cuyo valor es la concatenaci\u00f3n de la cadena repetida varias veces.</li> <li>replace: reemplaza todas las apariciones de un texto por otro texto. Este m\u00e9todo est\u00e1 sobrecargado para que el texto pueda ser char o String.</li> <li>substring: obtiene una subcadena.</li> <li>toLowerCase: devuelve la cadena en min\u00fasculas.</li> <li>toUpperCase: devuelve la cadena en may\u00fasculas.</li> <li>trim: elimina los espacios en blanco del principio y del final de la cadena.</li> </ul> <pre><code>public class StringOtherMethods {\n    public static void main(String[] args) {\n        String string1 = \"hola\", string2 = \"adios\", string3 = \"Hola\", string4;\n\n        //hola es mayor que adios\n        System.out.println(string1.compareTo(string2) &gt; 0 ? String.format(\"%s es mayor que %s\", string1, string2)\n                : String.format(\"%s es menor que %s\", string1, string2));\n\n        //adios es menor que hola\n        System.out.println(string2.compareTo(string1) &gt; 0 ? String.format(\"%s es mayor que %s\", string2, string1)\n                : String.format(\"%s es menor que %s\", string2, string1));\n\n        //En el Unicode, las may\u00fasculas est\u00e1n antes: Hola es menor que adios\n        System.out.println(string3.compareTo(string2) &gt; 0 ? String.format(\"%s es mayor que %s\", string3, string2)\n                : String.format(\"%s es menor que %s\", string3, string2));\n\n        //Hola es mayor que adios si no tenemos en cuenta las may\u00fasculas y min\u00fasculas\n        System.out.println(string3.compareToIgnoreCase(string2) &gt; 0\n                ? String.format(\"%s es mayor que %s si no tenemos en cuenta las may\u00fasculas y min\u00fasculas\", string3, string2)\n                : String.format(\"%s es menor que %s si no tenemos en cuenta las may\u00fasculas y min\u00fasculas\", string3, string2));\n\n        System.out.println(string4 = string1.concat(\" que tal\"));//string4=\"hola que tal\"\n        System.out.println(string4.endsWith(\"tal\"));//true\n        System.out.println(string4.endsWith(\"hola\"));//false\n        System.out.println(string4.startsWith(\"hola\"));//true\n        System.out.println(string4.startsWith(\"tal\"));//false\n        System.out.println(string4.indexOf(\"hola\"));//0\n        System.out.println(string4.indexOf(\"tal\"));//9\n        System.out.println(string4.indexOf(\"que\"));//5\n        System.out.println(string4.indexOf(string2));//-1\n        System.out.println(string4.indexOf(string3));//-1\n        System.out.println(string4.indexOf('a'));//3\n        System.out.println(\"hola que tal hola que tal\".lastIndexOf(\"tal\"));//22\n        System.out.println(string4.isEmpty());//false\n        System.out.println(\"\".isEmpty());//true\n\n        System.out.println(\"ole \".repeat(6));//ole ole ole ole ole ole \n        System.out.println(string4.replace('a', '*'));//hol* que t*l\n        System.out.println(\"hola que tal hola que tal\".replace(\"hola\",\n                \"buenas\"));//buenas que tal buenas que tal\n\n        //Para hacer desaparecer partes de una cadena, se reemplazan por cadena vac\u00eda\n        System.out.println(\"hola que tal hola que tal\".replace(\" \",\"\"));//holaquetalholaquetal\n\n        System.out.println(string4.substring(9));//tal\n        System.out.println(string4.substring(5, 8));//que\n        System.out.println(\"HOLA QUE TAL\".toLowerCase());//hola que tal\n        System.out.println(\"hola que tal\".toUpperCase());//HOLA QUE TAL\n        System.out.println(\"       Hola que tal      \".trim());//Hola que tal\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza una funci\u00f3n que reciba una cadena y devuelva el n\u00famero de vocales que tiene.</p> Ejercicio 2 <p>Realiza una funci\u00f3n que reciba una cadena y devuelva otra cadena igual pero sin espacios en blanco. No se pueden utilizar m\u00e9todos replace.</p> Ejercicio 3 <p>Realiza una funci\u00f3n que reciba una cadena y un car\u00e1cter y devuelva otra cadena igual pero con todas las apariciones del car\u00e1cter reemplazadas por un asterisco. No se pueden utilizar m\u00e9todos replace.</p> Ejercicio 4 <p>Realiza una funci\u00f3n que reciba una cadena y un car\u00e1cter y devuelva el n\u00famero de apariciones del car\u00e1cter en la cadena. No se pueden utilizar los m\u00e9todos indexOf ni contains.</p> Ejercicio 5 <p>Realiza una funci\u00f3n que reciba una cadena y un car\u00e1cter y devuelva el n\u00famero de caracteres que hay entre la primera y la \u00faltima aparici\u00f3n del car\u00e1cter en la cadena. No se pueden utilizar los m\u00e9todos indexOf ni contains.</p> Ejercicio 6 <p>Realiza una funci\u00f3n que reciba dos cadenas y devuelva la concatenaci\u00f3n de ambas. El m\u00e9todo concat o el operador + solamente se pueden utilizar a nivel de car\u00e1cter.</p> Ejercicio 7 <p>Realiza una funci\u00f3n que reciba una cadena y un n\u00famero y devuelva otra cadena con los primeros caracteres de cadena, tantos como indique el par\u00e1metro. No se puede utilizar el m\u00e9todo substring. Por ejemplo, si recibe \"Programaci\u00f3n\" y 5, devuelve \"Progr\".</p> Ejercicio 8 <p>Realiza una funci\u00f3n que reciba una cadena y un n\u00famero y devuelva otra cadena con los \u00faltimos caracteres de la cadena, tantos como indique, el par\u00e1metro. No se puede utilizar el m\u00e9todo substring. Por ejemplo, si recibe \"Programaci\u00f3n\" y 5, devuelve \"aci\u00f3n\".</p> Ejercicio 9 <p>Realiza una funci\u00f3n que reciba una cadena y devuelva otra cadena con los caracteres en orden inverso. Por ejemplo, si recibe \"hola\", devuelve \"aloh\".</p> Ejercicio 10 <p>Realiza una funci\u00f3n que reciba una cadena y devuelva la suma de todos los d\u00edgitos que hay en ella. Por ejemplo, si recibe \"abc12de3f4gh\", devuelve 10.</p> Ejercicio 11 <p>Realiza una funci\u00f3n que reciba dos cadenas y devuelva el n\u00famero de apariciones de una de ellas en la otra. No se pueden utilizar los m\u00e9todos indexOf, contains ni substring. Hacer las comparaciones a nivel de car\u00e1cter. Por ejemplo, si recibe \"Estoy matriculado en Programaci\u00f3n, en Entornos y en Marcas\" y \"en\", devuelve 3. Si recibe \"hola que tal, hola que pasa, hola\" y \"hola\", devuelve 3.</p> Ejercicio 12 <p>Realiza  una  funci\u00f3n  que  reciba  una  cadena  y  devuelva  el  n\u00famero  de  palabras  que  tiene.  Hacer  las comparaciones a nivel de car\u00e1cter. No se pueden utilizar m\u00e9todos replace, indexOf ni trim. Las palabras dentro de la cadena est\u00e1n separadas por un espacio. Por ejemplo, si recibe \"Estoy matriculado en Programaci\u00f3n en Entornos y en Marcas\", devuelve 9. Si recibe \" Estoy matriculado en Programaci\u00f3n en Entornos y en Marcas \", es decir, con un espacio al principio y otro al final, devuelve 9.</p> Ejercicio 13 <p>Realiza  una  funci\u00f3n  que  reciba  una  cadena  y  devuelva  el  n\u00famero  de  palabras  que  tiene.  Hacer  las comparaciones a nivel de car\u00e1cter. No se pueden utilizar m\u00e9todos replace ni indexOf. Las palabras dentro de la cadena pueden estar separadas por m\u00e1s de un espacio. No se pueden eliminar los espacios de la cadena. Por ejemplo, si recibe \"Estoy         matriculado      en        Programaci\u00f3n       en         Entornos         y        en           Marcas\", devuelve 9.</p>"},{"location":"bloque_i/tema_3/page-2/","title":"2 StringBuilder y StringBuffer","text":""},{"location":"bloque_i/tema_3/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Como se ha dicho en el apartado anterior, las cadenas son objetos constantes e inmutables, es decir, una vez que son creadas no pueden ser modificadas. Por ejemplo:</p> <pre><code>String s = \"hello\";\ns += \" world\";\nSystem.out.println(s); // Hello world\n</code></pre> <p>En primer lugar, se ha creado un objeto String y se ha referenciado a \u00e9l n the first line, a String \"Hello\" object is created and a reference to it, is stored in the s variable.</p> <p>En la segunda l\u00ednea otro objeto \"world\" es creado y despu\u00e9s viene una concatenaci\u00f3n de objetos (\"Hello\" y \"world\"). La concatenaci\u00f3n produce un nuevo objeto cadena \"Hello world\" cuya referencia ser\u00e1 almacenada en la variable s.</p> <p>Los objetos \"Hello\" y \"world\" son objetos obsoletos porque nadie usa su referencia, as\u00ed que no son usados. La JVM tiene un recolector de basura el cu\u00e1l limpia esos objetos de la memoria.</p> <p>Cuando manipulamos cadenas, ya sea concatenando, insertando o remplazando caracteres, muchos objetos son creados y r\u00e1pidamente descartados. Esta creaci\u00f3n de objetos de forma masiva puede provocar un incremento del uso de la memoria.</p> <p>El recolector de basura de Java limpia la memoria, pero dicha operaci\u00f3n tiene un tiempo costoso. Si nosotros creamos y destruimos muchos objetos, la ejecuci\u00f3n de nuestro programa puede ser poco eficiente.</p> <p>StringBuffer y StringBuilder son clases que nos permite crear objetos que almacenan cadenas que pueden ser modificadas sin necesidad de crear nuevos objetos.</p> <p>Ambas clases, tienen m\u00e9todos que nos permite manipular cadenas, como append, insert, etc.</p> <p>StringBuilder y StringBuffer son muy parecidos, pero StringBuffer puede ser usado en programas concurrentes con el uso de m\u00faltiples hilos de forma que sea thread safe (seguro para hilos), lo que hace que StringBuilder sea mucho m\u00e1s eficientes para programas no concurrentes.</p>"},{"location":"bloque_i/tema_3/page-2/#stringbuilder","title":"StringBuilder","text":"<p>StringBuilder es una clase de Java que nos permite manipular cadenas evitando la problem\u00e1tica de la creaci\u00f3n de objetos innecesarios. Algunos m\u00e9todos de esta clase son:</p> <ul> <li>StringBuilder append(String s). A\u00f1ade la cadena pasada por par\u00e1metro a la secuencia de caracteres. Este m\u00e9todo esta sobrescrito para a\u00f1adir cualquier tipo primitivo (int, boolean, char, etc.), para a\u00f1adir Object o un StringBuffer</li> <li>int capacity(). Retorna el n\u00famero de caracteres actuales que hay almacenados.</li> <li>StringBuilder delete(int start, int end). Elimina la subcadena en la secuencia de caracteres.</li> <li>StringBuilder deleteCharAt(). Elimina el car\u00e1cter especificado en la secuencia de caracteres.</li> <li>StringBuilder insert(int offset, String str). Inserta la cadena especificada a la secuencia de caracteres en la posici\u00f3n indicada, moviendo, si es necesario, el resto de caracteres. Este m\u00e9todo est\u00e1 sobrescrito para los tipos primitivos y el tipo Object.</li> <li>StringBuilder reverse(). Reemplaza la secuencia de caracteres actual por la secuencia de caracteres invertida.</li> <li>String toString(). Devuelve la secuencia de caracteres como String.</li> </ul> <p>Adem\u00e1s de estos m\u00e9todos, tambi\u00e9n tiene m\u00e9todos parecidos de la clase String como charAt(), indexOf(), lastIndexOf(), length(), subString().</p> <pre><code>import java.util.Scanner;\n\npublic class StringBuilderExample {\n    public static void main(String[] args) {\n        StringBuilder builder = new StringBuilder();\n        Scanner scanner = new Scanner(System.in);\n\n        for(int i = 1; i &lt;= 10; i++){\n            System.out.print(\"Introduce una cadena: \");\n            builder.append(scanner.nextLine());\n        }\n\n        System.out.printf(\"Capacidad actual: %d\\n\", builder.capacity());\n\n        builder.insert(5, \"String insertada en el car\u00e1cter 5\");\n        builder.insert(0, true);\n\n        System.out.printf(\"Cadena actual: %s\\n\", builder);\n\n        System.out.printf(\"Primer car\u00e1cter: %s\\n\", builder.charAt(0));\n        System.out.printf(\"Tama\u00f1o de la cadena: %d\\n\", builder.length());\n        System.out.printf(\"La letra 'A' se encuentra en: %d\\n\", builder.indexOf(\"A\"));\n\n        System.out.printf(\"Cadena invertida: %s\\n\", builder.reverse());\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#stringbuffer","title":"StringBuffer","text":"<p>La clase StringBuffer funciona de forma muy similar a la clase StringBuilder pero con la diferencia que \u00e9sta es thread-safe, segura para trabajar con hilos. Algunos m\u00e9todos de esta clase son:</p> <ul> <li>StringBuffer append(String s). A\u00f1ade la cadena pasada por par\u00e1metro a la secuencia de caracteres. Este m\u00e9todo esta sobrescrito para a\u00f1adir cualquier tipo primitivo (int, boolean, char, etc.), para a\u00f1adir Object u otro StringBuffer</li> <li>int capacity(). Retorna el n\u00famero de caracteres actuales que hay almacenados.</li> <li>StringBuffer delete(int start, int end). Elimina la subcadena en la secuencia de caracteres.</li> <li>StringBuffer deleteCharAt(). Elimina el car\u00e1cter especificado en la secuencia de caracteres.</li> <li>StringBuffer insert(int offset, String str). Inserta la cadena especificada a la secuencia de caracteres en la posici\u00f3n indicada, moviendo, si es necesario, el resto de caracteres. Este m\u00e9todo est\u00e1 sobrescrito para los tipos primitivos y el tipo Object.</li> <li>StringBuffer reverse(). Reemplaza la secuencia de caracteres actual por la secuencia de caracteres invertida.</li> <li>String toString(). Devuelve la secuencia de caracteres como String.</li> </ul> <p>Adem\u00e1s de estos m\u00e9todos, tambi\u00e9n tiene m\u00e9todos parecidos de la clase String como charAt(), indexOf(), lastIndexOf(), length(), subString().</p>"},{"location":"bloque_i/tema_3/page-2/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Crea un m\u00e9todo que reciba una cadena de s\u00f3lo d\u00edgitos, y devolver la misma cadena pero con separadores de miles, si es posible. Por ejemplo, si recibe la cadena 3456 devolver\u00e1 3.456, si recibe 123456789, devolver\u00e1 123.456.789 y si recibe 123 devolver\u00e1 123. Hacer uso de la clase StringBuilder.</p> Ejercicio 2 <p>Realiza el ejercicio anterior, pero ahora haciendo uso de la clase StringBuffer.</p>"},{"location":"bloque_i/tema_3/page-3/","title":"3 Expresiones regulares","text":""},{"location":"bloque_i/tema_3/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Una  expresi\u00f3n regular  es  una  secuencia  de  caracteres  que  forma  un  patr\u00f3n  de  b\u00fasqueda proporcionando una manera muy flexible de buscar o reemplazar cadenas de texto.</p> <p>En la clase String hay un m\u00e9todo llamado matches que indica si la cadena coincide o no con la expresi\u00f3n regular que se le pasa por par\u00e1metro . He aqu\u00ed algunas de las construcciones de expresiones regulares que se encuentran en la API de Java en la clase Pattern:</p> <ul> <li> <p>Characters</p> Construct Matches x The character x \\ The backslash character \\u*hhhh* The character with hexadecimal value 0x*hhhh* \\t The tab character (\\u0009) \\n The newline (line feed) character (\\u000A) <pre><code>public class Characters {\n    public static void main(String[] args) {\n        System.out.println(\"a\".matches(\"a\")); //true\n        System.out.println(\"b\".matches(\"a\")); //false\n        System.out.println(\"A\".matches(\"\\u0041\")); //true\n        System.out.println(\"\\n\".matches(\"\\n\")); //true\n        System.out.println(\"\\t\".matches(\"\\t\")); //true\n        System.out.println(\"\\\\\".matches(\"\\\\\\\\\")); //true\n    }\n}\n</code></pre> <p>Tal  y  como  vimos  en  el  tema  1.4  Tipos  de  datos  primitivos  en  el  apartado  de  los  caracteres, secuencias de escape es el conjunto de caracteres que en el c\u00f3digo es interpretado con alg\u00fan fin. En Java, la barra invertida <code>\\</code> se denomina car\u00e1cter de escape, el cual indica que el car\u00e1cter puesto  a  continuaci\u00f3n  ser\u00e1  convertido  en  car\u00e1cter  especial  o,  si  ya  es  especial,  dejar\u00e1  de  ser especial.  Por  ejemplo,  el  car\u00e1cter <code>n</code> no es especial  pero  con  la <code>\\</code> delante  se  convierte  en especial ya que <code>\\n</code> se interpreta como un salto de l\u00ednea. La <code>\\</code>  es un car\u00e1cter especial pero con otra <code>\\</code> delante deja de ser especial y simplemente es una barra invertida.</p> <p>En las expresiones regulares tambi\u00e9n se utiliza la barra invertida <code>\\</code>  como car\u00e1cter de escape.</p> <p>Veamos la \u00faltima l\u00ednea del c\u00f3digo anterior  <code>\"\\\\\".matches(\"\\\\\\\\\")</code>: la cadena <code>\"\\\\\"</code> es una barra  invertida,  y  el  argumento  del  matches  <code>\"\\\\\\\\\"</code>   son  dos  barras  invertidas  ya  que  la expresi\u00f3n regular de la barra invertida son dos barras tal y como podemos observar en la tabla anterior.</p> </li> <li> <p>Logical Operators</p> Construct Matches XY X seguido Y X Y <pre><code>public class LogicalOperators {\n    public static void main(String[] args) {\n        System.out.println(\"hola\".matches(\"hola\")); //true\n        System.out.println(\"hol\".matches(\"hola\")); //false\n        System.out.println(\"hola\".matches(\"hola|adios\")); //true\n        System.out.println(\"adios\".matches(\"hola|adios\")); //true\n        System.out.println(\"hol\".matches(\"hola|adios\")); //false\n        System.out.println(\"Adios\".matches(\"hola|adios\")); //false\n    }\n}\n</code></pre> </li> <li> <p>Character classes</p> Construct Matches [abc] a, b, o c (simple class) [^abc] Cualquier car\u00e1cter excepto a, b o c (negaci\u00f3n) [a-zA-Z] Desde la a hasta la z o desde la A hasta la Z, ambos incluidos (rango) [a-d[m-p]] Desde la a hasta la d o desde la m hasta la p (union) [a-z&amp;&amp;[def]] d, e o f (intersecci\u00f3n) [a-z&amp;&amp;[^bc]] Desde la a a la z, excepto b y c (subtracci\u00f3n) [a-z&amp;&amp;[^m-p]] Desde la a a la z, excepto los caracteres que van de la m a la p (subtracci\u00f3n) <pre><code>public class CharactersClasses {\n    public static void main(String[] args) {\n        System.out.println(\"a\".matches(\"[abc]\")); //true\n        System.out.println(\"d\".matches(\"[abc]\")); //false\n        System.out.println(\"a\".matches(\"[abc][abc]\")); //false\n        System.out.println(\"ac\".matches(\"[abc][abc]\")); //true\n        System.out.println(\"ad\".matches(\"[abc][abc]\")); //false\n        System.out.println(\" a\".matches(\"[abc ][abc]\")); //true\n        System.out.println(\"d\".matches(\"[^abc]\")); //true\n        System.out.println(\"a\".matches(\"[^abc]\")); //false\n        System.out.println(\"d\".matches(\"[^abc][^abc]\")); //false\n        System.out.println(\"de\".matches(\"[^abc][^abc]\")); //true\n        System.out.println(\"da\".matches(\"[^abc][^abc]\")); //false\n        System.out.println(\"A\".matches(\"[a-zA-Z]\")); //true\n        System.out.println(\"9\".matches(\"[a-zA-Z]\")); //false\n        System.out.println(\"A\".matches(\"[a-zA-Z][a-zA-Z]\")); //false\n        System.out.println(\"Az\".matches(\"[a-zA-Z][a-zA-Z]\")); //true\n        System.out.println(\"A9\".matches(\"[a-zA-Z][a-zA-Z]\")); //false\n        System.out.println(\"b\".matches(\"[a-d[m-p]]\")); //true\n        System.out.println(\"n\".matches(\"[a-d[m-p]]\")); //true\n        System.out.println(\"s\".matches(\"[a-d[m-p]]\")); //false\n        System.out.println(\"d\".matches(\"[a-z&amp;&amp;[def]]\")); //true\n        System.out.println(\"a\".matches(\"[a-z&amp;&amp;[def]]\")); //false\n        System.out.println(\"d\".matches(\"[a-z&amp;&amp;[^bc]]\")); //true\n        System.out.println(\"b\".matches(\"[a-z&amp;&amp;[^bc]]\")); //false\n        System.out.println(\"d\".matches(\"[a-z&amp;&amp;[^m-p]]\")); //true\n        System.out.println(\"n\".matches(\"[a-z&amp;&amp;[^m-p]]\")); //false\n    }\n\n}\n</code></pre> </li> <li> <p>Predefined character clasess</p> Construct Matches . Cualquier car\u00e1cter (puede o no ser determinadores de l\u00ednea) \\d Un d\u00edgito: [0-9] \\D Un no d\u00edgito: [^0-9] \\s Un car\u00e1cter de espacio en blanco: [\\t\\n\\x0B\\f\\r] \\S Un no car\u00e1cter de espacio en blanco: [^\\s] \\w Un car\u00e1cter de palabra: [a-zA-Z_0-9] \\W Un no car\u00e1cter de palabra: [^\\w] <p>Estas  expresiones  regulares  van  contenidas  en  una  cadena.  Entonces,  aquellas  expresiones regulares que lleven una barra invertida, como por ejemplo  <code>\\d</code>, tienen que llevar otra barra invertida <code>\\</code> delante ya que en las cadenas una barra invertida se expresa como <code>\\\\</code>.</p> </li> <li> <p>POSIX character classes (US-ASCII only)</p> Construct Matches \\p{Lower} Un car\u00e1cter alfab\u00e9tico en min\u00fascula: [a-z] \\p{Upper} Un car\u00e1cter alfab\u00e9tico en may\u00fasculas: [A-Z] \\p{ASCII} Todo caracteres ASCII: [\\x00-\\x7F] \\p{Alpha} Un car\u00e1cter alfab\u00e9tico: [\\p{Lower}\\p{Upper}] \\p{Digit} Un car\u00e1cter decimal: [0-9] \\p{Alnum} Un car\u00e1cter alfanum\u00e9rico: [\\p{Alpha}\\p{Digit}] \\p{Punct} Puntuaci\u00f3n: !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{}~ \\p{Graph} Un car\u00e1cter visible: [\\p{Alnum}\\p{Punct}] \\p{Print} Un car\u00e1cter imprimible: [\\p{Graph}\\x20] \\p{Blank} Un espacio o una tabulaci\u00f3n: [ \\t] \\p{Cntrl} Un car\u00e1cter de control: [\\x00-\\x1F\\x7F] \\p{XDigit} Un d\u00edgito hexadecimal: [0-9a-fA-F] \\p{Space} Un car\u00e1cter de espacio en blanco: [\\t\\n\\x0B\\f\\r] <p>En los caracteres imprimibles (\\p{Print}), \\x20 es el car\u00e1cter espacio.</p> <pre><code>public class PosixCharactersClasses {\n    public static void main(String[] args) {\n        System.out.println(\"a\".matches(\"\\\\p{Lower}\"));//true\n        System.out.println(\"A\".matches(\"\\\\p{Lower}\"));//false\n        System.out.println(\"A\".matches(\"\\\\p{Upper}\"));//true\n        System.out.println(\"a\".matches(\"\\\\p{Upper}\"));//false\n        System.out.println(\"aC\".matches(\"\\\\p{Lower}\\\\p{Upper}\"));//true\n        System.out.println(\"a\".matches(\"\\\\p{Alpha}\"));//true\n        System.out.println(\"A\".matches(\"\\\\p{Alpha}\"));//true\n        System.out.println(\"8\".matches(\"\\\\p{Alpha}\"));//false\n        System.out.println(\"8\".matches(\"\\\\p{Digit}\"));//true\n        System.out.println(\"A\".matches(\"\\\\p{Digit}\"));//false\n        System.out.println(\"8A\".matches(\"\\\\p{Digit}\\\\p{Alpha}\"));//true\n        System.out.println(\"A\".matches(\"\\\\p{Alnum}\"));//true\n        System.out.println(\"8\".matches(\"\\\\p{Alnum}\"));//true\n        System.out.println(\"a\".matches(\"\\\\p{Alnum}\"));//true\n        System.out.println(\"\\n\".matches(\"\\\\p{Alnum}\"));//false\n        System.out.println(\"?\".matches(\"\\\\p{Punct}\"));//true\n        System.out.println(\"!\".matches(\"\\\\p{Punct}\"));//true\n        System.out.println(\";\".matches(\"\\\\p{Punct}\"));//true\n        System.out.println(\"a\".matches(\"\\\\p{Punct}\"));//false\n        System.out.println(\" \".matches(\"\\\\p{Blank}\"));//true\n        System.out.println(\"\\t\".matches(\"\\\\p{Blank}\"));//true\n        System.out.println(\"\\n\".matches(\"\\\\p{Blank}\"));//false\n        System.out.println(\" \".matches(\"\\\\p{Space}\"));//true\n        System.out.println(\"\\t\".matches(\"\\\\p{Space}\"));//true\n        System.out.println(\"\\n\".matches(\"\\\\p{Space}\"));//true\n        System.out.println(\"a\".matches(\"\\\\p{Space}\"));//false\n    }\n\n}\n</code></pre> </li> <li> <p>Boundary matchers</p> Construct Matches ^ Principio de una l\u00ednea $ Final de una l\u00ednea \\b L\u00edmite de una palabra \\B L\u00edmite de una no-palabra <pre><code>public class BoundaryMatchers {\n    public static void main(String[] args) {\n        System.out.println(\"hola\".matches(\"^hola\"));//true\n        System.out.println(\"hola9\".matches(\"^hola\"));//false\n        System.out.println(\"hola9\".matches(\"^hola\\\\d\"));//true\n        System.out.println(\"ab\".matches(\"^[aA]\\\\p{Lower}\"));//true\n        System.out.println(\"bA\".matches(\"^[aA]\\\\p{Upper}\"));//false\n        System.out.println(\"hhola\".matches(\".hola$\"));//true\n        System.out.println(\"hola\".matches(\".hola$\"));//false\n        System.out.println(\"9hola\".matches(\"\\\\dhola$\"));//true\n        System.out.println(\"hc\".matches(\".[abc]$\"));//true\n        System.out.println(\"ch\".matches(\".[abc]$\"));//false\n\n        // (1)!\n        System.out.println(\"hola\".matches(\"\\\\bhol.\"));//true, hol est\u00e1 al principio de una palabra\n        System.out.println(\"hola\".matches(\".ola\\\\b\"));//true, ola est\u00e1 al final de una palabra\n\n        //(2)!\n        System.out.println(\"hola\".matches(\"\\\\bhola\\\\b\"));//true, hola est\u00e1 al principio y al final\n        // \\B es justo lo contrario que \\b\n        System.out.println(\"abc\".matches(\".\\\\Bb\\\\B.\"));//true, b no est\u00e1 al principio ni al final\n        System.out.println(\"abc\".matches(\"a\\\\B..\"));//true, a no est\u00e1 al final\n    }\n\n}\n</code></pre> <ol> <li>La expresi\u00f3n regular \\b se llama l\u00edmite de palabra ya que busca en los l\u00edmites de una palabra, al principio o al final.</li> <li>Para realizar una b\u00fasqueda de palabras espec\u00edficas se coloca la palabra entre dos l\u00edmites de palabra:</li> </ol> </li> </ul>"},{"location":"bloque_i/tema_3/page-3/#la-clase-pattern","title":"La clase Pattern","text":"<p>En Java disponemos de las clases Pattern y Matcher para poder hacer uso de las expresiones regulares. Ambas se encuentran en el paquete <code>java.util.regex</code>.</p> <p>La  clase  Pattern  nos  permite  definir  el  patr\u00f3n,  es  decir,  representa  a  la  expresi\u00f3n  regular. Veamos algunos m\u00e9todos de esta clase:</p> <ul> <li>compile: crea un patr\u00f3n a partir de una expresi\u00f3n regular.</li> <li>pattern: devuelve la expresi\u00f3n regular a partir de la cual se cre\u00f3 el patr\u00f3n.</li> <li>matches: indica si la cadena coincide o no con la expresi\u00f3n regular.</li> </ul> <pre><code>import java.util.regex.Pattern;\n\npublic class PatternClass {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(\"\\\\p{Upper}\\\\p{Lower}\");\n        System.out.println(pattern.pattern());\n        System.out.println(Pattern.matches(\"\\\\p{Upper}\\\\p{Lower}\",\n                \"Ho\"));//true\n        System.out.println(Pattern.matches(\"\\\\p{Upper}\\\\p{Lower}\",\n                \"ho\"));//false\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-3/#la-clase-matcher","title":"La clase Matcher","text":"<p>La clase Matcher realiza operaciones de coincidencia del patr\u00f3n en una secuencia de caracteres.</p> <p>Se puede crear un objeto de tipo Matcher mediante el m\u00e9todo matcher de la clase Pattern. Una vez creado, un matcher puede ser utilizado para realizar tres tipos diferentes de operaciones:</p> <ul> <li>matches: intenta hacer coincidir toda la secuencia de entrada con el patr\u00f3n.</li> <li>lookingAt: intenta hacer coincidir el principio de la secuencia de entrada con el patr\u00f3n.</li> <li>find: intenta encontrar la pr\u00f3xima secuencia de entrada que coincide con el patr\u00f3n. Si hay varias coincidencias con el patr\u00f3n dentro del mismo texto, cada llamada a find devolver\u00e1 la siguiente coincidencia.</li> <li>start: devuelve el \u00edndice de la secuencia de entrada donde empieza la coincidencia del \u00faltimo find</li> <li>end: devuelve el \u00edndice de la secuencia de entrada el car\u00e1cter que est\u00e1 justo despu\u00e9s del \u00faltimo de la coincidencia del \u00faltimo find.</li> <li>reset: resetea el matcher.</li> </ul> <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MatcherClass {\n    public static void main(String[] args) {\n        int count;\n\n        Pattern pattern = Pattern.compile(\"es\", Pattern.CASE_INSENSITIVE);//(1)!\n        Matcher matcher = pattern.matcher(\"Estoy en Espa\u00f1a\");\n        System.out.println(matcher.matches());//false   \n        System.out.println(matcher.lookingAt());//true\n        matcher.reset(\"Esto es un escrito en espa\u00f1ol\");\n        count = 0;\n        while (matcher.find()) {\n            count++;\n            System.out.printf(\"Coincidencia n\u00famero %d: empieza en %d y termina en %d\\n\", count, matcher.start(), matcher.end() - 1);\n        }\n    }\n}\n</code></pre> <ol> <li>Con Pattern.CASE_INSENSITIVE, no se distingue entre may\u00fasculas y min\u00fasculas</li> </ol> <p>La expresi\u00f3n regular . coincide con cualquier car\u00e1cter excepto un terminador de l\u00ednea, a menos que se especifique la bandera DOTALL.</p> <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Point {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(\".\", Pattern.DOTALL);\n        Matcher matcher = pattern.matcher(\"\\n\");\n        System.out.println(matcher.matches());//true\n        System.out.println(\"\\n\".matches(\".\"));//false\n    }\n}\n</code></pre> <p>Veamos m\u00e1s ejemplos de boundary matchers utilizando objetos de tipo Matcher:</p> <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class BoundaryMatchersAvanzed {\n    public static void main(String[] args) {\n        String text = \"Esto es un texto escrito en espa\u00f1ol\";\n        Pattern pattern;\n        Matcher matcher;\n\n        pattern = Pattern.compile(\"\\\\be\", Pattern.CASE_INSENSITIVE);\n        matcher = pattern.matcher(text);\n        System.out.println(\"Las palabras que empiezan por e o por E se  encuentran en las siguientes posiciones:\");\n        while (matcher.find()) {\n            System.out.println(matcher.start());\n        }\n\n        pattern = Pattern.compile(\"\\\\Be\");\n        matcher = pattern.matcher(text);\n        System.out.println(\"Las e que no son comienzos de palabra se encuentran en las siguientes posiciones:\");\n        while (matcher.find()) {\n            System.out.println(matcher.start());\n        }\n\n        pattern = Pattern.compile(\"o\\\\b\");\n        matcher = pattern.matcher(text);\n        System.out.println(\"Las o que son finales de palabras se encuentran en las siguientes posiciones:\");\n        while (matcher.find()) {\n            System.out.println(matcher.start());\n        }\n\n        pattern = Pattern.compile(\"o\\\\B\");\n        matcher = pattern.matcher(text);\n        System.out.println(\"Las o que no son finales de palabras se encuentran en las siguientes posiciones:\");\n        while (matcher.find()) {\n            System.out.println(matcher.start());\n        }\n\n        /*\n         * Para realizar una b\u00fasqueda de palabras espec\u00edficas se coloca la palabra entre\n         * dos l\u00edmites de palabra:\n         */\n        pattern = Pattern.compile(\"\\\\btexto\\\\b\");\n        matcher = pattern.matcher(text);\n        System.out.println(\"La palabra texto se encuentra en las siguientes posiciones:\");\n        while (matcher.find()) {\n            System.out.println(matcher.start());\n        }\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-3/#quantifiers-cuantificadores","title":"Quantifiers (cuantificadores)","text":"<ul> <li> <p>Greedy quantifiers</p> <p>Por defecto los cuantificadores son greedy. Se llaman greedy (glot\u00f3n) porque tratan de coger lo m\u00e1ximo posible de la cadena pero siempre intentando que el patr\u00f3n completo se cumpla.</p> Construct Matches X? X, una vez o ninguna X* X, ninguna o m\u00e1s veces X+ X, una o m\u00e1s veces X{n} X, exactamente n veces X{n,} X, al menos n veces X{n,m} X, al menos n pero no m\u00e1s de m <pre><code>public class GreedyQuantifiers {\n    public static void main(String[] args) {\n\n        System.out.println(\"a\".matches(\"a?\"));//true\n        System.out.println(\"\".matches(\"a?\"));//true\n        System.out.println(\"b\".matches(\"a?\"));//false\n\n        System.out.println(\"a\".matches(\"a*\"));//true\n        System.out.println(\"\".matches(\"a*\"));//true\n        System.out.println(\"aaaa\".matches(\"a*\"));//true\n        System.out.println(\"b\".matches(\"a*\"));//false\n\n        System.out.println(\"a\".matches(\"a+\"));//true\n        System.out.println(\"aaaa\".matches(\"a+\"));//true\n        System.out.println(\"\".matches(\"a+\"));//false\n        System.out.println(\"b\".matches(\"a+\"));//false\n\n        System.out.println(\"aaa\".matches(\"a{3}\"));//true\n        System.out.println(\"aaa\".matches(\"a{4}\"));//false\n\n        System.out.println(\"aaa\".matches(\"a{3,}\"));//true\n        System.out.println(\"aaaaa\".matches(\"a{3,}\"));//true\n        System.out.println(\"aa\".matches(\"a{3,}\"));//false\n\n        System.out.println(\"aaa\".matches(\"a{3,6}\"));//true\n        System.out.println(\"aaaaaa\".matches(\"a{3,6}\"));//true\n        System.out.println(\"aa\".matches(\"a{3,6}\"));//false\n        System.out.println(\"aaaaaaa\".matches(\"a{3,6}\"));//false\n    }\n\n}\n</code></pre> </li> <li> <p>Reluctant quantifiers</p> <p>Otro posible comportamiento es reluctant (reacio, reticente). Este comportamiento es el contrario de greedy, trata de coger lo menos posible pero siempre intentando que se cumpla el patr\u00f3n.</p> Construct Matches X?? X, una vz o ninguna X*? X, cero o m\u00e1s veces X+? X, una o m\u00e1s veces X{n,}? X, al menos n veces X{n,m}? X, al menos n veces pero no m\u00e1s que m veces <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ReluctantQuantifiers {\n    public static void main(String[] args) {\n        Pattern patternGreedy = Pattern.compile(\"a+\");\n        Pattern patternReluctant = Pattern.compile(\"a+?\");\n\n        Matcher matcherGreedy = patternGreedy.matcher(\"aaaa\");\n        Matcher matcherReluctant = patternReluctant.matcher(\"aaaa\");\n\n        while (matcherGreedy.find()) {\n            System.out.printf(\"Greedy: coincidencia desde %d hasta %d\\n\",\n                    matcherGreedy.start(), matcherGreedy.end() - 1);\n        }\n\n        while (matcherReluctant.find()) {\n            System.out.printf(\"Reluctant: coincidencia desde %d hasta %d\\n\",\n                    matcherReluctant.start(), matcherReluctant.end() - 1);\n        }\n    }\n}\n</code></pre> </li> <li> <p>Possessive quantifiers</p> <p>Tratan  de  coger  lo  m\u00e1ximo  posible  de  la  cadena  pero  no  se  preocupan  de  que  se  cumpla  el patr\u00f3n. Este comportamiento se usa \u00fanicamente por motivos de eficiencia. Si en la cadena hay un trozo que queramos quitar y que podamos distinguir con una expresi\u00f3n regular, podemos ponerlo con este modo possessive. De esta forma, el possessive se comer\u00e1 directamente ese trozo de cadena y no perder\u00e1 el tiempo tratando de hacer casar ese trozo con el patr\u00f3n de alguna u otra forma.</p> <p>Se escriben como los greedy pero a\u00f1adiendo un + detr\u00e1s.</p> Construct Matches X?+ X, una vz o ninguna X*+ X, cero o m\u00e1s veces X++ X, una o m\u00e1s veces X{n,}+ X, al menos n veces X{n,m}+ X, al menos n veces pero no m\u00e1s que m veces <pre><code>public class PossessiveQuantifiers {\n    public static void main(String[] args) {\n        Pattern patternGreedy = Pattern.compile(\"a+a\");\n        Pattern patternPossessive = Pattern.compile(\"a++a\");\n        Matcher matcherGreedy = patternGreedy.matcher(\"aaaa\");\n        Matcher matcherPossessive = patternPossessive.matcher(\"aaaa\");\n\n        while (matcherGreedy.find()) {\n            System.out.printf(\"Greedy: coincidencia desde %d hasta %d\\n\",\n                    matcherGreedy.start(), matcherGreedy.end() - 1);\n        }\n        while (matcherPossessive.find()) {\n            System.out.printf(\"Possessive: coincidencia desde %d hasta %d\\n\",\n                    matcherPossessive.start(), matcherPossessive.end() - 1);\n        }\n    }\n\n}\n</code></pre> <p>En el modo possessive, con la primera parte del patr\u00f3n a++ ya coge la cadena completa <code>\"aaaa\"</code>. Como no se preocupa de que el patr\u00f3n se cumpla, entonces la \u00faltima <code>a</code> del patr\u00f3n ya no tiene coincidencia con lo que el find devuelve false.</p> </li> </ul>"},{"location":"bloque_i/tema_3/page-3/#grupos","title":"Grupos","text":"<p>Los grupos sirven para extraer partes de una cadena y se marcan con un par\u00e9ntesis en la expresi\u00f3n regular. Cuando se encuentra una coincidencia en un texto, se puede acceder a la parte que se encuentra dentro del grupo a trav\u00e9s del m\u00e9todo group. Una expresi\u00f3n regular puede tener m\u00e1s de un grupo, en cuyo caso cada uno lleva sus propios par\u00e9ntesis. El grupo con n\u00famero 0 es toda la expresi\u00f3n regular y los grupos marcados con par\u00e9ntesis empiezan a enumerarse a partir del 1. Tambi\u00e9n puede hacer grupos dentro de otros grupos, como en el siguiente ejemplo, donde el grupo 2 y grupo 3 est\u00e1n dentro del grupo 1.</p> <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Group {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(\"((\\\\d+)\\\\+(\\\\d+))=(\\\\d+)\");\n        Matcher matcher = pattern.matcher(\"23+56=79;15+13=28;30+60=90\");\n        while (matcher.find()) {\n            System.out.println(matcher.group(0));\n            System.out.printf(\"Sumandos: %s\\n\", matcher.group(1));\n            System.out.printf(\"Sumando 1: %s\\n\", matcher.group(2));\n            System.out.printf(\"Sumando 2: %s\\n\", matcher.group(3));\n            System.out.printf(\"Resultado: %s\\n\\n\", matcher.group(4));\n        }\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-3/#reemplazar-partes-de-una-cadena","title":"Reemplazar partes de una cadena","text":"<p>La clase Matcher tiene m\u00e9todos para reemplazar partes de la cadena que cumplan con el patr\u00f3n:</p> <ul> <li>replaceAll: reemplaza todas las coincidencias.</li> <li>replaceFirst: reemplaza solamente la primera coincidencia.</li> </ul> <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Replace {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(\"\\\\d\");\n        Matcher matcher = pattern.matcher(\"Tengo 20 a\u00f1os y vivo en la calle Puerto Real 15\");\n\n        String replaceAll = matcher.replaceAll(\"*\");\n        String replaceFirst = matcher.replaceFirst(\"*\");\n\n        System.out.printf(\"replaceAll: %s\\n\", replaceAll);\n        System.out.printf(\"replaceFirst: %s\\n\", replaceFirst);\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-3/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Crea y comprueba las siguientes expresiones regulares:</p> <ol> <li>que la cadena sea exactamente \u201ctrue\u201d.</li> <li>que la cadena sea de tres letras, may\u00fasculas o min\u00fasculas.</li> <li>que la cadena contenga 5 o m\u00e1s caracteres que no sean la \u00f1, la z ni la x.</li> <li>que la cadena no empiece con un n\u00famero.</li> <li>que la cadena tenga varios caracteres excepto la b.</li> <li>que la cadena sea un n\u00famero de tel\u00e9fono.</li> <li>que la cadena sea un DNI.</li> <li>que la cadena sea un nombre, es decir, que no tenga espacios, que no sea una cadena vac\u00eda y que empiece por may\u00fasculas.</li> <li>que la cadena empiece con vocal y luego tenga varias consonantes o ninguna.</li> <li>que la cadena tenga un n\u00famero positivo m\u00e1s peque\u00f1o que 300.</li> </ol> Ejercicio 2 <p>Dada una cadena que contiene c\u00f3digo en Java, mostrar lo siguiente:</p> <ol> <li>En qu\u00e9 car\u00e1cter empiezan los comentarios de una l\u00ednea.</li> <li>En qu\u00e9 car\u00e1cter empiezan los bloques de c\u00f3digo.</li> <li>En qu\u00e9 car\u00e1cter empiezan y terminan los comentarios de m\u00e1s de 1 l\u00ednea.</li> <li>En qu\u00e9 car\u00e1cter empiezan y terminan las declaraciones de variables de tipo int. Ejemplos:<ul> <li>int a;</li> <li>int number=5;</li> <li>int i=0,j=10,k;</li> </ul> </li> </ol> Ejercicio 3 <p>Dada una cadena que contiene c\u00f3digo en Java, mostrar lo siguiente utilizando grupos:</p> <ol> <li>El nombre del paquete.</li> <li>Las clases que se importan con sus rutas de paquetes. Ejemplo: java.util.regex.Pattern</li> <li>Las condiciones de los while.</li> </ol> Ejercicio 4 <p>Dada una cadena que contiene c\u00f3digo en Java, reemplazar los int por byte y los double por float</p>"},{"location":"bloque_i/tema_3/page-4/","title":"Proyecto","text":"<p>Se va a realizar un proyecto que va a contener una librer\u00eda con m\u00e9todos y clases \u00fatiles para facilitar ciertas operaciones.</p> <p>En esta primera parte se llevar\u00e1 a cabo la creaci\u00f3n de la clase de utilidad Strings que contendr\u00e1 los m\u00e9todos de utilidad para mejorar y facilitar el trabajo con cadenas.</p> <p>Realiza los m\u00e9todos que consideres para realizar estas operaciones:</p> <ul> <li>Comprobar si una cadena no est\u00e1 vac\u00eda.</li> <li>Comprobar si una cadena no es una cadena compuesta solamente por espacios.</li> <li>Comprobar si una cadena es num\u00e9rica.</li> <li>Comprobar si una cadena es alfab\u00e9tica.</li> <li>Comprobar si una cadena es alfanum\u00e9rica.</li> <li>Comprobar si una cadena es \u00fanicamente contiene caracteres especiales: !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{}~</li> <li>Comprobar si una cadena es un espacio en blanco.</li> <li>Convertir una cadena en Upper Camel case. Ejemplo Hola mundo -&gt; \"Hola Mundo\"</li> <li>Convertir la primera letra de una cadena en may\u00fasculas. Ejemplo: hola mundo -&gt; Hola mundo</li> <li>Convertir la primera letra de una cadena en min\u00fasculas. Ejemplo: Hola mundo -&gt; hola mundo</li> <li>Centrar una cadena dada una tama\u00f1o m\u00e1ximo de pantalla.</li> <li>Mostrar una cadena con ellipsis dado un tama\u00f1o m\u00e1ximo.</li> <li>Mostrar una cadena con saltos dado un tama\u00f1o m\u00e1ximo</li> <li>Comprobar si una cadena es pal\u00edndroma, es decir, que se pueda leer exactamente igual del derecho que del rev\u00e9s. Por ejemplo: Roma ni se conoce sin oro, ni se conoce sin amor</li> <li>Contar el n\u00famero de palabras de una cadena.</li> <li>Contar el n\u00famero de veces que aparece una subcadena en una cadena.</li> <li>Contar el n\u00famero de veces que una cadena cumple un patr\u00f3n.</li> <li>Comprobar si una cadena cumple una expresi\u00f3n.</li> <li>Comprobar si una cadena tiene un formato email.</li> <li>Comprobar si una cadena tiene un formato telef\u00f3nico.</li> <li>Comprobar si una cadena tiene un formato de contrase\u00f1a b\u00e1sica, es decir, que tenga como m\u00ednimo 8 caracteres.</li> <li>Comprobar si una cadena tiene un formato de contrase\u00f1a compleja, es decir, que tenga como m\u00ednimo 8 caracteres, una min\u00fascula, una may\u00fascula, un d\u00edgito y un car\u00e1cter especial.</li> <li>Comprobar si una cadena es un DNI o NIE v\u00e1lido.</li> <li>Comprobar si una cadena es una matr\u00edcula de coche v\u00e1lido.</li> </ul> <p>Adem\u00e1s se crear\u00e1 una clase de utilidad Maths que contendr\u00e1 m\u00e9todos que facilite trabajar con operaciones matem\u00e1ticas:</p> <ul> <li>Comprobar si un n\u00famero es par.</li> <li>Comprobar si un n\u00famero es impar.</li> <li>Calcular el m\u00ednimo com\u00fan m\u00faltiplo de dos n\u00fameros.</li> <li>Calcular el m\u00ednimo com\u00fan m\u00faltiplo de tres n\u00fameros.</li> <li>Calcular el m\u00e1ximo com\u00fan divisor de dos n\u00fameros.</li> <li>Calcular el m\u00e1ximo com\u00fan divisor de tres n\u00fameros.</li> <li>Invertir un n\u00famero.</li> <li>Contar el n\u00famero de cifras que tiene.</li> <li>Comprobar si un n\u00famero es perfecto.</li> <li>Comprobar si un n\u00famero es primo.</li> <li>Comprobar si un n\u00famero es compuesto.</li> <li>Calcular el factorial de un n\u00famero.</li> </ul> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ol> <li>Se crear\u00e1 un paquete principal llamado <code>com.NOMBRE.common</code> donde nombre ser\u00e1 el nombre del alumno y common el nombre del proyecto.</li> <li>Se crear\u00e1 una clase Main, donde se ponga en pr\u00e1ctica los usos de la librer\u00eda y se valorar\u00e1 la complejidad de dicho Main.</li> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>Sobrescribe los m\u00e9todos que consideres oportunos.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre pr03java-NOMBRE-strings siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>Se har\u00e1 uso de la recursividad donde sea necesario.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ol>"},{"location":"bloque_i/tema_4/page-1/","title":"1 Clases vs Objetos","text":""},{"location":"bloque_i/tema_4/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es una t\u00e9cnica de programar aplicaciones basada en una serie de objetos independientes que se comunican entre s\u00ed.</p> <p>A Java se le considera un lenguaje orientado a objetos ya que siempre que se crea un programa en Java, por simple que sea, se necesita declarar una clase, y el concepto de clase pertenece a la programaci\u00f3n orientada a objetos.</p> <p>Un  objeto  es  un  elemento  del  programa  que  integra  sus  propios  datos  y  su  propio funcionamiento. Es decir, un objeto est\u00e1 formado por datos (atributos o propiedades) y por las funciones que es capaz de realizar el objeto (m\u00e9todos). Esta forma de programar se asemeja m\u00e1s al pensamiento humano. La cuesti\u00f3n es detectar adecuadamente los objetos necesarios para una aplicaci\u00f3n. De hecho hay que detectar las distintas clases de objetos.</p> <p>Una clase es lo que define a un tipo de objeto. Al definir una clase lo que se hace es indicar como funciona un determinado tipo de objeto. Luego, a partir de la clase, podremos crear objetos de esa  clase,  es  decir,  la  clase  es  como  un  molde  a  partir  del  cual  se  crean  los  objetos  que pertenecen  a  ella.  Realmente  la  programaci\u00f3n  orientada  a  objetos  es  una  programaci\u00f3n orientada a clases. Es decir, lo que necesitamos programar es como funcionan las clases de objetos.</p> <p>Por ejemplo, una clase podr\u00eda ser la clase Coche. Cuando se defina esta clase, indicaremos los atributos o propiedades (como el color, modelo, marca, velocidad m\u00e1xima,...) y los m\u00e9todos (arrancar, parar, repostar, acelerar, frenar...). Todos los coches, es decir, todos los objetos de la clase Coche, tendr\u00e1n esas propiedades y esos m\u00e9todos. Para explicar la diferencia entre clase y objeto:</p> <ul> <li>la clase Coche representa a todos los coches.</li> <li>un coche concreto es un objeto, es decir, un ejemplar de una clase es un objeto. Tambi\u00e9n se le llama a los objetos instancias de la clase. Este t\u00e9rmino procede del ingl\u00e9s, instance, que realmente significa ejemplar.</li> </ul> <p>Por ejemplo, si quisi\u00e9ramos crear el juego del parch\u00eds en Java, una clase ser\u00eda la casilla, otra las fichas,  otra  el  dado,  etc.  En  el caso de la  casilla,  se  definir\u00eda  la  clase  para  indicar  su funcionamiento y sus propiedades, y luego se crear\u00edan tantos objetos casilla como casillas tenga el juego. Lo mismo ocurrir\u00eda con las fichas, la clase ficha definir\u00eda las propiedades de la ficha (color  y  posici\u00f3n  por  ejemplo)  y  su  funcionamiento  mediante  sus  m\u00e9todos  (por  ejemplo  un m\u00e9todo ser\u00eda mover, otro llegar a la meta, etc), luego se crear\u00edan tantos objetos ficha como fichas tenga el juego.</p>"},{"location":"bloque_i/tema_4/page-1/#creacion-de-clases","title":"Creaci\u00f3n de clases","text":"<p>Una clase sirve para definir una serie de objetos con propiedades (atributos), comportamientos (m\u00e9todos)  y  sem\u00e1ntica  comunes.  Hay  que  pensar  en  una  clase  como  un  molde  para  crear objetos.</p> <p>La definici\u00f3n de una clase incluye lo siguiente:</p> <ul> <li>El nombre o identificador de clase. Debe empezar con letra may\u00fascula y seguir letras min\u00fasculas,  y  si  consta  de  varias palabras,  se  utiliza  la  notaci\u00f3n  UpperCamelCase. Tambi\u00e9n pueden contener n\u00fameros pero no como primer car\u00e1cter. Por ejemplo, <code>1Coche</code> no  es  un  identificador  v\u00e1lido  de  clase,  pero <code>Coche1</code> s\u00ed  ser\u00eda  v\u00e1lido.  Veamos  algunos consejos a la hora de elegir los identificadores de las clases:<ul> <li>Evitar abreviaturas a favor de la legibilidad del c\u00f3digo. Es muy importante que el nombre de las clases sea claro y simbolice perfectamente al tipo de objetos que representa.</li> <li>Evitar  nombres  excesivamente  largos.Aunque  parece  que  se  contradice  con  la norma anterior, se trata de que los nombres sean concisos. No es conveniente que sean descripciones de clase, para eso ya est\u00e1n los comentarios javadoc.</li> <li>Utilizar nombres ya reconocidos. Hay abreviaturas reconocidas como por ejemplo TCP,  por  eso  el  nombre  de  clase  <code>ManejadorTCP</code> es  mejor  que <code>ManejadorProtocoloControlTransmision</code> .</li> </ul> </li> <li>Los atributos, tambi\u00e9n llamados propiedades o campos. Los atributos son variables que poseer\u00e1 cada objeto de la clase y por lo tanto marcar\u00e1n el estado de los mismos. Por ejemplo, un coche puede estar parado, en marcha, estropeado, funcionando, sin gasolina, etc. El estado lo marca el valor que tengan los atributos del objeto.</li> <li>Los m\u00e9todos. Son las acciones que pueden realizar los objetos de la clase, es decir, lo que determina el comportamiento de los objetos.</li> </ul> <p>En Java, cada clase se define en un archivo. Adem\u00e1s, el nombre de la clase y el del archivo tiene que ser el mismo. Es decir, si queremos definir la clase Vehicle, tendremos que hacerlo en un archivo llamado Vehicle.java. Dicho archivo contiene la definici\u00f3n de la clase Vehicle:</p> <pre><code>public class Vehicle {\n    int wheelCount; // N\u00ba ruedas\n    double speed; // Velocidad\n    String color; // Color del veh\u00edculo\n    void accelerate(double amount){ // acelerar\n        speed += amount;\n    }\n    void brake(double amount){ // frenar\n        speed -= amount;\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-1/#creacion-de-objetos","title":"Creaci\u00f3n de objetos","text":"<p>Una vez definida la clase, ya se pueden crear objetos de la misma. Para crear un objeto, hay que declarar una variable cuyo tipo ser\u00e1 la propia clase:</p> <pre><code>Vehicle car; //(1)!\n</code></pre> <ol> <li><code>car</code> es una variable de tipo Vehicle</li> </ol> <p>Una vez definida la variable, se le crea el objeto llamando a un m\u00e9todo que se llama constructor. Un constructor es un m\u00e9todo que se invoca cuando se crea un objeto y que sirve para inicializar los atributos del objeto y para realizar las acciones pertinentes que requiera el mismo para ser creado. El constructor tiene el mismo nombre que la clase y para invocarlo se utiliza el operador new.</p> <pre><code>car = new Vehicle(); //(1)!\n</code></pre> <ol> <li>Vehicle() es un m\u00e9todo constructor</li> </ol> <p>Tambi\u00e9n se puede hacer todo en la misma l\u00ednea:</p> <pre><code>Vehicle car = new Vehicle();\n</code></pre>"},{"location":"bloque_i/tema_4/page-1/#acceso-a-los-atributos-y-metodos-del-objeto","title":"Acceso a los atributos y m\u00e9todos del objeto","text":"<p>Una  vez  creado  el  objeto,  se  puede  acceder  a  sus  atributos  de  la  siguiente  manera: <code>objeto.atributo</code></p> <pre><code>car.wheelCount = 4; //(1)!\n</code></pre> <ol> <li>Se le asigna 4 al atributo n\u00famero de ruedas de la variable car-</li> </ol> <p>Los m\u00e9todos se utilizan de la misma forma que los atributos, a excepci\u00f3n de que los m\u00e9todos poseen  siempre  par\u00e9ntesis  ya  que  son  funciones  que  pertenecen  a  un  objeto: <code>objeto.m\u00e9todo(argumentos)</code>.</p> <pre><code>car.accelerate(30); //(1)!\n</code></pre> <ol> <li>El coche incrementa su velocidad a 30, es decir, si iba a 90km/h, despu\u00e9s de ejecutar el m\u00e9todo el coche va a 120km/h.</li> </ol> Ejercicio 1 <p>Crea un paquete llamado exercise01 el cual contenga una clase llamada Persona con los atributos: nombre, edad, altura y ocupaci\u00f3n. Crea una clase Main donde se le solicite al usuario el nombre de la persona, modif\u00edquelo y mu\u00e9strelo por pantalla.</p>"},{"location":"bloque_i/tema_4/page-10/","title":"Proyecto","text":"<p>Se va a realizar un proyecto para almacenar la informaci\u00f3n referente al usuario sobre su cuenta bancaria.</p> <p>La informaci\u00f3n se escribir\u00e1 en una clase llamada Account y contendr\u00e1 los siguientes atributos, m\u00e9todos y restricciones:</p> <ul> <li>Un titular, que por ninguna circunstancia podr\u00e1 faltar.</li> <li>N\u00famero de la cuenta, que debe tener 24 caracteres, siendo los dos primeros caracteres el pa\u00eds al que pertenece y los dos siguientes n\u00fameros el n\u00famero de la entidad en la cu\u00e1l se creo la cuenta. Los 8 primeros caracteres (incluido el pa\u00eds y la entidad) hacen referencia al c\u00f3digo IBAN.</li> <li>Saldo de la cuenta, puede ser negativo.</li> <li>M\u00e9todos para mostrar informaci\u00f3n de la cuenta (N\u00ba de la cuenta, IBAN, etc).</li> <li>M\u00e9todos para sacar e ingresar dinero en la cuenta.</li> <li>M\u00e9todo para consultar el saldo.</li> </ul> <p>Crea una clase App que contenga el main del proyecto, solicit\u00e1ndole al usuario los datos necesarios para crear una cuenta si no la tiene creada ya, y luego se le mostrar\u00e1 las siguientes opciones de forma infinita hasta que desee salir de la app:</p> <ol> <li>Ver cuenta</li> <li>Ver saldo</li> <li>Retirar dinero</li> <li>Ingresar dinero</li> <li>Salir</li> </ol> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ol> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>Se har\u00e1 uso del encapsulamiento y de todo las formas \u00f3ptimas vista durante la unidad</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre pr04-java-NOMBRE-poo siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ol>"},{"location":"bloque_i/tema_4/page-2/","title":"2 Acceso y sobrecarga","text":""},{"location":"bloque_i/tema_4/page-2/#modificadores-de-acceso","title":"Modificadores de acceso","text":"<p>Los modificadores de acceso son palabras reservadas del lenguaje Java que determinan \u00e1mbitos de visibilidad de los atributos y   m\u00e9todos de una clase.</p> <p>Los modificadores de acceso son los siguientes:</p> <ul> <li>Private: el modificador private en Java es el m\u00e1s restrictivo de todos, cualquier elemento de una clase que sea privado puede ser accedido \u00fanicamente por la propia clase. Ninguna otra clase, sin importar la relaci\u00f3n que tengan, podr\u00e1 tener acceso a elementos privados.</li> <li>El modificador por defecto: Java nos da la opci\u00f3n de no usar un modificador de acceso y al no hacerlo, el elemento tendr\u00e1 un acceso conocido como default o friendly, que permite que tanto la propia clase como las clases del mismo paquete accedan a dichos elementos.</li> <li>Protected: lo veremos en el tema donde se explica el funcionamiento de la herencia en Java.</li> <li>Public: el modificador de acceso public es el m\u00e1s permisivo de todos, nos permite acceso a los elementos desde cualquier clase incluso de otros paquetes.</li> </ul> <p>Veamos una tabla que resume el funcionamiento de los modificadores de acceso en Java:</p> Private Friendly Public Misma clase x x x Mismo paquete x x Otro paquete x <p>El modificador se indica:</p> <ul> <li>Delante de class en la clase.</li> <li>Delante del tipo de datos en los atributos y m\u00e9todos.</li> </ul> <p>Veamos la clase Vehicle con los modificadores de acceso:</p> <pre><code>public class Vehicle {\n    private int wheelCount; // N\u00ba ruedas\n    private double speed; // Velocidad\n    private String color; // Color del veh\u00edculo\n    public void accelerate(double amount){ // acelerar\n        speed += amount;\n    }\n    public void brake(double amount){ // frenar\n        speed -= amount;\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-2/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<p>Java admite sobrecargar los m\u00e9todos, es decir, crear distintas variantes del mismo m\u00e9todo con el mismo nombre pero que se diferencien en el orden, tipo o n\u00famero de los par\u00e1metros.</p> <p>Por ejemplo, tenemos el m\u00e9todo para sumar <code>add(int x,int y)</code>:</p> <ul> <li>No  podr\u00edamos  definir  otro  m\u00e9todo <code>add(int  a,int  b)</code> porque  no  var\u00eda  el  tipo  ni  el n\u00famero de par\u00e1metros.</li> <li>S\u00ed podr\u00edamos definir <code>add(int a)</code> y <code>add(int  a,int  b,int  c)</code> porque  el  n\u00famero  de par\u00e1metros var\u00eda.</li> <li>Tambi\u00e9n podr\u00edamos definir <code>add(int x,double y)</code> porque aunque no var\u00ede el n\u00famero de par\u00e1metros, s\u00ed var\u00eda uno de los tipos.</li> </ul> <p>Otro ejemplo donde tenemos el m\u00e9todo <code>add(int x,double y)</code>:</p> <ul> <li>S\u00ed  podr\u00edamos  definir  el  m\u00e9todo <code>add(double  x,int  y)</code> porque  var\u00eda  el  orden  de  los par\u00e1metros.</li> </ul> <p>El tipo resultado de los m\u00e9todos sobrecargados puede ser igual o diferente.</p>"},{"location":"bloque_i/tema_4/page-2/#atributos-metodos-y-bloques-estaticos","title":"Atributos, m\u00e9todos y bloques est\u00e1ticos","text":"<p>El concepto de est\u00e1tico es que pertenece a la clase, por lo tanto, puede ser accedido o invocado sin la necesidad de tener que instanciar un objeto de la clase. Se indica con la palabra clave static.</p> <p>Los atributos y m\u00e9todos asociados a los objetos se les conoce como din\u00e1micos.</p> <p>Los atributos est\u00e1ticos son variables que pertenecen a la clase y son compartidos por todos los objetos  de  la  clase.  Son  inicializados  en  el  momento  en  que  se  carga  la  clase  en  memoria, respetando  el  orden  de  declaraci\u00f3n.  Para  acceder  a  un  atributo  est\u00e1tico,  hay  que  indicar  el nombre de la clase: <code>Clase.AtributoEst\u00e1tico</code></p> <p>Los m\u00e9todos est\u00e1ticos son m\u00e9todos que pertenecen a la clase y no al objeto por lo que pueden llamarse sin tener que crear un objeto de dicha clase. Para llamar a un m\u00e9todo est\u00e1tico, hay que indicar el nombre de la clase:  Clase.M\u00e9todoEst\u00e1tico(Argumentos) . Un m\u00e9todo est\u00e1tico solo puede acceder a datos est\u00e1ticos y llamar a m\u00e9todos est\u00e1ticos. No pueden utilizar el operador this ni super ya que son conceptos din\u00e1micos. Los m\u00e9todos est\u00e1ticos es lo m\u00e1s parecido a lo que son las funciones en los lenguajes estructurados con la diferencia que se encuentran encapsulados en una clase.</p> <p>Cada vez que creamos un programa en Java debemos especificar el m\u00e9todo main:</p> <pre><code>public static void main(String[] args)\n</code></pre> <p>El m\u00e9todo main es est\u00e1tico para que la m\u00e1quina virtual de Java pueda llamarlo directamente sin tener que crear un objeto de la clase que lo contiene.</p> <p>Ejemplos de llamadas a m\u00e9todos din\u00e1micos y est\u00e1ticos:</p> <ul> <li>Llamada a m\u00e9todo din\u00e1mico: <code>car.accelerate(30)</code>;</li> <li>Llamada a m\u00e9todo est\u00e1tico: <code>Math.pow(2,3);</code></li> </ul> <p>El bloque est\u00e1tico es un bloque de instrucciones dentro de una clase Java que se ejecutar\u00e1 cuando una clase se cargue por primera vez en la JVM.</p> <pre><code>class MyClass{\n    static{\n        //instrucciones\n    }\n}\n</code></pre> MyClassMainConsola <pre><code>public class MyClass {\n    static int a;\n    static int b;\n\n    static {\n        a = 10;\n        b = 20;\n    }\n}\n</code></pre> <pre><code>public class Main {\n    private void showStatic() {\n        System.out.printf(\"Valor de a: %d\\n\", MyClass.a);\n        System.out.printf(\"Valor de b: %d:\\n\", MyClass.b);\n    }\n\n    public static void main(String[] args) {\n        new Main().showStatic();\n    }\n}\n</code></pre> <pre><code>Valor de a: 10\nValor de b: 20\n</code></pre>"},{"location":"bloque_i/tema_4/page-3/","title":"3 Convenciones","text":""},{"location":"bloque_i/tema_4/page-3/#javabean","title":"JavaBean","text":"<p>Los JavaBeans son un modelo de componentes para la construcci\u00f3n de aplicaciones en Java. Se usan para encapsular varios objetos en un \u00fanico objeto (la vaina o Bean en ingl\u00e9s), para hacer uso de un solo objeto en lugar de varios m\u00e1s simples. La especificaci\u00f3n de JavaBeans los define como \"componentes de software reutilizables que se puedan manipular visualmente en una herramienta de construcci\u00f3n\".</p> <p>Para funcionar como una clase JavaBean, una clase debe obedecer ciertas convenciones sobre nomenclatura de m\u00e9todos, construcci\u00f3n y comportamiento. Estas convenciones permiten tener herramientas que puedan utilizar, reutilizar, sustituir y conectar JavaBeans.</p> <p>Las convenciones requeridas son:</p> <ul> <li>Debe tener un constructor sin argumentos.</li> <li>Sus atributos de clase deben ser privados.</li> <li>Sus  propiedades  deben  ser  accesibles  mediante  m\u00e9todos  get  y  set  que  siguen  una convenci\u00f3n de nomenclatura est\u00e1ndar.</li> <li>Debe ser serializable.</li> </ul> <p>Dentro de un JavaBean podemos distinguir tres partes:</p> <ul> <li>Propiedades: Los atributos que contiene.</li> <li>M\u00e9todos: Se establecen los m\u00e9todos get y set para acceder y modificar los atributos.</li> <li>Eventos: Permiten comunicar con otros JavaBeans</li> </ul>"},{"location":"bloque_i/tema_4/page-3/#metodos-get-y-set","title":"M\u00e9todos get y set","text":"<p>Los m\u00e9todos get y set son m\u00e9todos de las clases para mostrar o modificar el valor de un atributo. Para mostrar se utiliza el m\u00e9todo get y para modificar el m\u00e9todo set.</p> <p>Seg\u00fan las convenciones JavaBean, la nomenclatura de ambos debe ser la siguiente:</p> <ul> <li>get:         - Debe ser declarado con el modificador de acceso public.         - El  nombre  del  m\u00e9todo  comienza  con  get  y  le  sigue  el  nombre  del  atributo  en UpperCamelCase. En el caso de los booleanos, el nombre del m\u00e9todo comienza con is.         - El tipo de retorno del m\u00e9todo debe ser el mismo que el tipo del atributo.</li> <li>set:         - Debe ser declarado con el modificador de acceso public.         - El  nombre  del  m\u00e9todo  comienza  con  set  y  le  sigue  el  nombre  del  atributo  en UpperCamelCase.         - El tipo de retorno del m\u00e9todo debe ser void.         - El tipo del par\u00e1metro del m\u00e9todo debe ser el mismo que el tipo del atributo.</li> </ul> <p>Hacer uso de este convenio nos facilitar\u00e1 trabajar con el resto del mundo y nos permitir\u00e1 ampliar las capacidades de nuestro c\u00f3digo utilizando frameworks existentes que hacen uso del convenio y que si no seguimos no podremos utilizar.</p> <p>En los IDEs, se pueden generar de forma autom\u00e1tica.</p> <p>Vamos a incluir en la clase Vehicle los getters y setters. Para ello, nos tenemos que plantear qu\u00e9 atributos vamos a permitir consultar y modificar. En cuanto a la consulta, vamos a permitir consultar  todos  los  atributos  por  lo  que  tendremos  que  realizar  3  getters.  En  cuanto  a  las modificaciones, el n\u00famero de ruedas de un veh\u00edculo no cambia a lo largo del tiempo por lo que no hace falta ponerle un m\u00e9todo set. La velocidad se va modificando con los m\u00e9todos de acelerar y frenar por lo que tampoco le vamos a poner un m\u00e9todo set. En cuanto al color, vamos a permitir que un veh\u00edculo pueda cambiar de color por lo que s\u00ed vamos a hacerle un m\u00e9todo set al color.</p> <pre><code>public class Vehicle {\n    private int wheelCount; // N\u00ba ruedas\n    private double speed; // Velocidad\n    private String color; // Color del veh\u00edculo\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public void setWheelCount(int wheelCount) {\n        this.wheelCount = wheelCount;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public void accelerate(double amount){ // acelerar\n        speed += amount;\n    }\n    public void brake(double amount){ // frenar\n        speed -= amount;\n    }\n}\n</code></pre> <p>Fij\u00e9monos en el m\u00e9todo setColor:</p> <pre><code>public void setColor(String color) {\n    this.color = color;\n}\n</code></pre> <p>Tenemos dos variables que se llaman igual: color. Una es un par\u00e1metro y otra es un atributo. Para  diferenciarlas,  el  atributo  se  utiliza  con  la  palabra  this.  El  uso  de  this  se  explica  con detenimiento m\u00e1s adelante.</p> <p>En el caso de los booleanos, el getter comienza por is. Si la clase Vehicle tuviera un atributo booleano llamado empty para detectar cu\u00e1ndo est\u00e1 vac\u00edo el dep\u00f3sito de gasolina, el getter se llamar\u00eda isEmpty():</p> <pre><code>private boolean empty;\npublic boolean isEmpty(){\n    return empty;\n}\n</code></pre> Ejercicio 2 <p>Cree un paquete llamado exercise02 y copie la clase Persona del ejercicio anterior. Luego, realice las modificaciones necesarias para poder modificar y acceder a los atributos sin necesidad de usar directamente el atributo. Crea un m\u00e9todo Main donde le solicite al usuario todos los atributos y mu\u00e9strelos por pantalla haciendo uso de dichos m\u00e9todos.</p>"},{"location":"bloque_i/tema_4/page-3/#constructores","title":"Constructores","text":"<p>Un constructor es un m\u00e9todo que se invoca cuando se crea un objeto y que sirve para inicializar los atributos del objeto y para realizar las acciones pertinentes que requiera el mismo para ser creado. El constructor tiene el mismo nombre que la clase y para invocarlo se utiliza el operador new.</p> <pre><code>Vehicle car = new Vehicle(); //(1)!\n</code></pre> <ol> <li>Vehicle() es un constructor de la clase Vehicle</li> </ol> <p>En los constructores no se especifica tipo de retorno:</p> VehicleMainConsola <pre><code>public class Vehicle {\n    private int wheelCount; // N\u00ba ruedas\n    private double speed; // Velocidad\n    private String color; // Color del veh\u00edculo\n\n    public Vehicle(){\n        wheelCount = 4;\n        speed = 0;\n        color = \"blanco\";\n    }\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public void setWheelCount(int wheelCount) {\n        this.wheelCount = wheelCount;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public void accelerate(double amount){ // acelerar\n        speed += amount;\n    }\n    public void brake(double amount){ // frenar\n        speed -= amount;\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public void showDefaultConstructor(){\n        Vehicle car1, car2;\n        car1 = new Vehicle();\n        car2 = new Vehicle();\n\n        System.out.printf(\"Coche1: %d ruedas y de color %s\\n\", car1.getWheelCount(), car1.getColor());\n        System.out.printf(\"Coche2: %d ruedas y de color %s\\n\", car2.getWheelCount(), car2.getColor());\n\n        System.out.printf(\"Velocidad del coche1: %.2f km/h\\n\", car1.getSpeed());\n        System.out.printf(\"Velocidad del coche2: %.2f km/h\\n\", car2.getSpeed());\n\n        System.out.println(\"Aceleramos el coche1 a 90,50km/h\");\n        car1.accelerate(90.50);\n        System.out.printf(\"Velocidad del coche1: %.2f km/h\\n\", car1.getSpeed());\n\n        System.out.println(\"Aceleramos el coche2 a 20,30km/h\");\n        car2.accelerate(20.30);\n        System.out.printf(\"Velocidad del coche2: %.2f km/h\\n\", car2.getSpeed());\n    }\n\n    public static void main(String[] args) {\n        new Main().showDefaultConstructor();\n    }\n}\n</code></pre> <pre><code>Coche1: 4 ruedas y de color blanco\nCoche2: 4 ruedas y de color blanco\nVelocidad del coche1: 0,00 km/h\nVelocidad del coche2: 0,00 km/h\nAceleramos el coche1 a 90,50km/h\nVelocidad del coche1: 90,50 km/h\nAceleramos el coche2 a 20,30km/h\nVelocidad del coche2: 20,30 km/h\n</code></pre> <p>El constructor que no tiene par\u00e1metros se llama constructor  por  defecto, como por ejemplo Vehicle(). Si nos fijamos en la salida por consola, los dos coches tienen los mismos datos ya que el constructor por defecto crea todos los objetos de la misma manera. Para poder crear objetos diferentes, tendremos que usar un constructor con par\u00e1metros:</p> VehiclesMainConsola <pre><code>public class Vehicle {\n    private int wheelCount; // N\u00ba ruedas\n    private double speed; // Velocidad\n    private String color; // Color del veh\u00edculo\n\n    public Vehicle(){\n        wheelCount = 4;\n        speed = 0;\n        color = \"blanco\";\n    }\n\n    public Vehicle(int wheelCount, String color) {\n        this.wheelCount = wheelCount;\n        this.color = color;\n        speed = 0;\n    }\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public void setWheelCount(int wheelCount) {\n        this.wheelCount = wheelCount;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public void accelerate(double amount){ // acelerar\n        speed += amount;\n    }\n    public void brake(double amount){ // frenar\n        speed -= amount;\n    }\n}\n</code></pre> <pre><code>public class ConstructorParameterized {\n    public void show(){\n        Vehicle car, moto;\n        car = new Vehicle(4, \"azul\");\n        moto = new Vehicle(2, \"rojo\");\n\n        System.out.printf(\"Coche: %d ruedas y de color %s\\n\", car.getWheelCount(), car.getColor());\n        System.out.printf(\"Moto: %d ruedas y de color %s\\n\", moto.getWheelCount(), moto.getColor());\n    }\n\n    public static void main(String[] args) {\n        new ConstructorParameterized().show();\n    }\n}\n</code></pre> <pre><code>Coche: 4 ruedas y de color azul\nMoto: 2 ruedas y de color rojo\n</code></pre> <p>Al tener par\u00e1metros el constructor, esto nos permite poder crear objetos diferentes.</p> <p>En los IDEs, se puede generar el constructor con par\u00e1metros de forma autom\u00e1tica.</p> <p>Los constructores se pueden sobrecargar, por lo tanto una clase puede tener varios constructores, en el ejemplo anterior la clase Vehicle mantiene el constructor por defecto, adem\u00e1s del constructor con par\u00e1metros.</p> <pre><code>public class ShowConstructors {\n    public void show(){\n        Vehicle car, moto;\n        car = new Vehicle();\n        moto = new Vehicle(2, \"rojo\");\n\n        System.out.printf(\"Coche: %d ruedas y de color %s\\n\", car.getWheelCount(), car.getColor());\n        System.out.printf(\"Moto: %d ruedas y de color %s\\n\", moto.getWheelCount(), moto.getColor());\n    }\n}\n</code></pre> <p>Si una clase no tiene constructor, Java crea uno por defecto. Los atributos se inicializan a su valor por defecto en funci\u00f3n del tipo que posean:</p> <ul> <li>Tipos num\u00e9ricos enteros: 0</li> <li>Tipos num\u00e9ricos decimales: 0</li> <li>Caracteres: Car\u00e1cter nulo (C\u00f3digo Unicode 0)</li> <li>Booleanos: false</li> <li>Referencias a objetos: null</li> </ul> <p>Solo se inicializan los atributos, las variables locales de los m\u00e9todos no son inicializados por defecto.</p> <p>\u00a1OJO!</p> <p>Java solamente crea un constructor cuando la clase no tiene ninguno, pero si la clase tiene un constructor, aunque sea con par\u00e1metros, Java ya no crea ninguno por defecto.</p> <p>Si la clase posee alg\u00fan constructor con par\u00e1metros pero se usa Class() el compilador nos da un mensaje de error de que el constructor no est\u00e1 definido.</p> Ejercicio 3 <p>Crea un paquete llamado exercise03 y copia la clase persona del ejercicio anterior. Crea un m\u00e9todo constructor para dicha clase que asigne los siguientes valores a sus atributos:</p> <p>nombre = \"Sin nombre\" edad = 0 altura = 0.0f ocupacion = \"sin ocupaci\u00f3n\"</p> <p>Crea un Main que declare un objeto de tipo persona utilizando el constructor, para posteriormente mostrar el contenido de sus atributos por pantalla.</p> Ejercicio 4 <p>Crea un paquete llamado exercise04 y copie la clase persona del ejercicio anterior. Crea un m\u00e9todo constructor con par\u00e1metros sin anular el ya creado. Realiza un Main que declare un objeto tipo persona utilizando dicho constructor y muestre el contenido posteriormente por pantalla.</p>"},{"location":"bloque_i/tema_4/page-3/#visibilidad","title":"Visibilidad","text":"<p>La visibilidad de los atributos y m\u00e9todos de una clase se establece utilizando los modificadores de acceso.</p> <p>Los modificadores de acceso permiten dar un nivel de seguridad mayor a nuestras aplicaciones restringiendo el acceso a diferentes atributos y m\u00e9todos asegur\u00e1ndonos que el cliente no va a consultar el valor de un atributo que no debe, no va a modificar incorrectamente el valor de un atributo o que no va a utilizar un m\u00e9todo que no le est\u00e9 permitido. Cuando nos referimos al t\u00e9rmino cliente es cualquier programador que utilice nuestras clases.</p> <p>Tal y como vimos en el apartado 2. Modificadores de acceso, se resume su funcionamiento en la siguiente tabla:</p> Private Friendly Public Misma clase x x x Mismo paquete x x Otro paquete x <p>Veamos un ejemplo de la clase Vehicle que est\u00e1 en el mismo paquete que una clase cliente Main.</p> <p>Vamos a comprobar la visibilidad que tiene la clase Main sobre la clase Vehicle en funci\u00f3n de los modificadores de acceso. Tal y como podemos observar en la tabla anterior, tendr\u00e1 acceso a public y a friendly pero no a private</p> VehicleMain <pre><code>public class Vehicle {\n    private int wheelCount; // N\u00ba ruedas\n    private double speed; // Velocidad\n    private String color; // Color del veh\u00edculo\n    public Vehicle(int wheelCount, String color) {\n        this.wheelCount = wheelCount;\n        this.color = color;\n        speed = 0;\n    }\n    int getWheelCount() {\n        return wheelCount;\n    }\n    public void setWheelCount(int wheelCount) {\n        this.wheelCount = wheelCount;\n    }\n    public String getColor() {\n        return color;\n    }\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public void accelerate(double amount){ // acelerar\n        speed += amount;\n    }\n    public void brake(double amount){ // frenar\n        speed -= amount;\n    }\n}\n</code></pre> <pre><code>public class Main {\n    public void showVisibility(){\n        Vehicle car = new Vehicle(4, \"azul\");\n\n        System.out.printf(\"El coche tiene %d ruedas\\n\", car.getWheelCount()); //(1)!\n\n        car.accelerate(100); //(2)!\n\n        System.out.printf(\"El coche va a %.2f km/h\\n\", car.speed); //(3)!\n    }\n}\n</code></pre> <ol> <li>getWheelCount es visible porque es friendly y la clase Main est\u00e1 en el mismo paquete que la clase Vehicle.</li> <li>accelerate es visible porque es public.</li> <li>Error de compilaci\u00f3n: speed no es visible porque es private</li> </ol> Ejercicio 5 <p>Cree un paquete exercise05 copiando la clase Persona del exercise04 y modifica al acceso a algunos de sus m\u00e9todos, haci\u00e9ndolos public, private o friendly y realiza las siguientes operaciones y observa si da o no error, justificando sus respuesta con comentarios:</p> <ul> <li>Crea un m\u00e9todo main dentro de la clase Persona y crea un objeto persona, intente acceder a todos sus m\u00e9todos.</li> <li>Crea una clase Main dentro del paquete exercise_05 y realice la misma operaci\u00f3n anterior</li> <li>Crea un paquete llamado exercise05_bis y una clase Main realizando la misma operaci\u00f3n anterior</li> </ul>"},{"location":"bloque_i/tema_4/page-3/#instanceof","title":"instanceof","text":"<p>El operador instanceof permite comprobar si un determinado objeto pertenece a una clase concreta. Se utiliza de esta forma:</p> <pre><code>object instanceof class\n</code></pre> <p>Devuelve true si el objeto pertenece a dicha clase.</p> <pre><code>public class InstanceOf {\n    public void show(){\n        Vehicle vehicle = new Vehicle();\n        System.out.println(vehicle instanceof  Vehicle);\n    }\n\n    public static void main(String[] args) {\n        new InstanceOf().show();\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/","title":"4 Referencias","text":""},{"location":"bloque_i/tema_4/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Una referencia en cualquier lenguaje de programaci\u00f3n hace alusi\u00f3n a la posici\u00f3n en memoria RAM que tiene una variable.</p> <p>Una variable es conceptualmente un recipiente donde guardamos un dato. Java es un lenguaje fuertemente tipado. Las variables se definen siempre con un tipo asociado. No se puede meter en una variable ning\u00fan dato que no sea del tipo con que se defini\u00f3.</p> <p>Una variable es un lugar en la memoria donde se guarda un dato. Para ser exacto, este lugar en la memoria es la Pila o Stack. En el caso de los datos primitivos, como en <code>int i = 5;</code> hay cuatro bytes en la Pila donde se almacena el n\u00famero 5. Pero cuando se crea un objeto en Java, el objeto se guarda en una parte de la memoria llamada Heap. Cuando asignamos el objeto a una variable como en <code>Vehicle car=new Vehicle();</code>, lo que guardamos en car es la direcci\u00f3n de memoria Heap donde est\u00e1 el objeto.</p> <p>Stack en java es una secci\u00f3n de memoria que contiene m\u00e9todos, variables locales y variables de referencia. La memoria de pila siempre se referencia en el orden de \u00faltimo en entrar primero en salir. Las variables locales se crean en la pila.</p> <p>Heap es una secci\u00f3n de memoria que contiene objetos y tambi\u00e9n puede contener variables de referencia. Los atributos se crean en el heap.</p>"},{"location":"bloque_i/tema_4/page-4/#representacion-en-memoria-de-tipos-primitivos","title":"Representaci\u00f3n en memoria de tipos primitivos","text":"<p>Veamos paso a paso un ejemplo:</p> <ul> <li> <p>Cuando se declara una variable de un tipo primitivo, el compilador reserva un \u00e1rea de memoria para ella:</p> <pre><code>int i, j;\n</code></pre> <p> Figura 1 - Referencia de primitivos </p> </li> <li> <p>Cuando se asigna un valor, \u00e9ste es escrito en el \u00e1rea reservada:</p> <pre><code>i = 16;\nj = 3;\n</code></pre> <p> Figura 2 - Referencia de primitivos </p> </li> <li> <p>La asignaci\u00f3n entre variables significa copiar el contenido de una variable en la otra:</p> <pre><code>i = j;\n</code></pre> <p> Figura 3 - Referencia de primitivos </p> </li> <li> <p>La comparaci\u00f3n entre variables compara los contenidos de las mismas:</p> <pre><code>i == j; // true porque 3 es igual a 3\n</code></pre> </li> </ul> PrimitivesConsola <pre><code>public class Primitives {\n    public void show(){\n        int i = 10, j = 20;\n\n        System.out.printf(\"Valor de la variable i: %d\\n\", i);\n        System.out.printf(\"Valor de la variable j: %d\\n\", j);\n\n        i = j;\n\n        System.out.printf(\"Valor de la variable i: %d\\n\", i);\n        System.out.printf(\"Valor de la variable j: %d\\n\", j);\n\n        System.out.printf(\"i y j%s tiene el mismo contenido\", i == j ? \"\" : \" no\");\n    }\n\n    public static void main(String[] args) {\n        new Primitives().show();\n    }\n}\n</code></pre> <pre><code>Valor de la variable i: 10\nValor de la variable j: 20\nValor de la variable i: 20\nValor de la variable j: 20\ni y j tiene el mismo contenido\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#representacion-en-memoria-de-objetos","title":"Representaci\u00f3n en memoria de objetos","text":"<p>Supongamos que tenemos una clase Complex con dos atributos: r, i.</p> <ul> <li> <p>Cuando se declara una variable de un objeto, el compilador reserva un \u00e1rea de memoria para ella. Mientras no se cree ning\u00fan objeto con el operador new, lo que contendr\u00e1 ser\u00e1 null. La palabra reservada null indica que una variable que referencia a un objeto se encuentra de momento sin referenciar a ninguno:</p> <pre><code>Complex cl;\n</code></pre> <p> Figura 4 - Referencia de objetos </p> </li> <li> <p>Cuando se crea el objeto llamando la constructor con el operador new, lo que se guarda en la variable c1 es la direcci\u00f3n de memoria donde se ha almacenado el objeto en el heap, es decir, la diferencia entre los tipos primitivos y los objetos es que en los primitivos la variable almacena el valor y en los objetos, la variable almacena la direcci\u00f3n de memoria donde se encuentra el objeto.</p> <pre><code>c1 = new Complex(7.2, 2.4);\n</code></pre> <p> Figura 5 - Referencia de objetos </p> </li> <li> <p>La asignaci\u00f3n entre variables de objetos significa copiar la direcci\u00f3n de memoria donde se encuentra el objeto:</p> <pre><code>Complex c2 = c1;\n</code></pre> <p>En este caso, el valor de la variable c2 es 0x2A18, por lo tanto, ambas variables apuntan al mismo objeto. Si una de ellas modifica alg\u00fan valor del objeto, tambi\u00e9n le afectar\u00e1 a la otra variable. Por ejemplo, si a c2 le cambiamos el valor de r a 9.7, si consultamos el valor de r de c1, tambi\u00e9n valdr\u00e1 9.7, en lugar de 7.2.</p> </li> <li> <p>La comparaci\u00f3n entre referencias no compara los contenidos de los objetos sino las direcciones de memoria, es decir, si apuntan al mismo sitio.</p> <pre><code>c2 == c1; // true porque apuntan al mismo sitio\nComplex c3 = new Complex(7.2, 2.4);\nc3 == c1; // false porque aunque tengan los mismos valores, no apuntan al mismo sitio\n</code></pre> <p>Para comparar el contenido de los objetos, se utiliza el m\u00e9todo equals:</p> <pre><code>c3.equals(c1); // true porque los contenidos de los objetos son los mismos\n</code></pre> </li> </ul> ComplexMainConsole <pre><code>public class Complex {\n    double r;\n    double j;\n\n    public Complex(double r, double j) {\n        this.r = r;\n        this.j = j;\n    }\n}\n</code></pre> <pre><code>public class Objects {\n    public void show(){\n        Complex c1 = new Complex(7.2, 2.3);\n        Complex c2 = c1;\n\n        System.out.printf(\"C1 -&gt; r: %.2f j: %.2f\\n\", c1.r, c1.j);\n        System.out.printf(\"C2 -&gt; r: %.2f j: %.2f\\n\", c2.r, c2.j);\n\n        c1.r = 10;\n        c2.j = 7.6;\n\n        System.out.printf(\"C1 -&gt; r: %.2f j: %.2f\\n\", c1.r, c1.j);\n        System.out.printf(\"C2 -&gt; r: %.2f j: %.2f\\n\", c2.r, c2.j);\n\n        Complex c3 = new Complex(10, 7.6);\n        System.out.printf(\"C3 -&gt; r: %.2f j: %.2f\\n\", c3.r, c3.j);\n\n        System.out.printf(\"c1 == c2 -&gt; %b\\n\", c1 == c2);\n        System.out.printf(\"c1 == c3 -&gt; %b\\n\", c1 == c3);\n        System.out.printf(\"c1 equals c3 -&gt; %b\\n\", c1.equals(c3));\n    }\n\n    public static void main(String[] args) {\n        new Objects().show();\n    }\n}\n</code></pre> <pre><code>C1 -&gt; r: 7,20 j: 2,30\nC2 -&gt; r: 7,20 j: 2,30\nC1 -&gt; r: 10,00 j: 7,60\nC2 -&gt; r: 10,00 j: 7,60\nC3 -&gt; r: 10,00 j: 7,60\nc1 == c2 -&gt; true\nc1 == c3 -&gt; false\nc1 equals c3 -&gt; false\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#garbage-collector","title":"Garbage Collector","text":"<p>Garbage Collector (recolector de basura) es un programa que se ejecuta en el Java Virtual Machine que elimina los objetos que ya no est\u00e1n siendo utilizados por una aplicaci\u00f3n Java. Es una forma de gesti\u00f3n autom\u00e1tica de la memoria.</p> <p>Un objeto es elegible para el recolector de basura cuando deja de existir alguna referencia hacia \u00e9l. Veamos algunos ejemplos.</p> <pre><code>Complex c1 = new Complex(7.2, 2.4);\n//...\nc1 = null;\n//...\n</code></pre> <p>Existe un objeto referenciado por la variable c1. Cuando la variable c1 pierde la referencia porque se le asigna el null, se pierde cualquier forma de acceder al objeto, de modo que pasa a ser elegible para el recolector de basura.</p> <pre><code>Complex c1 = new Complex(7.2, 2.4);\nComplex c2 = c1;\n// ...\nc1 = null;\n// ...\n</code></pre> <p>En este segundo ejemplo, el objeto no pasa a ser elegible para ser recolectado pues aunque la variable c1 haya perdido la referencia porque se le asigna el null, todav\u00eda existe una referencia hacia el objeto por la variable c2</p> <pre><code>Complex c1 = new Complex(7.2, 2.4);\n//...\nc1 = new Complex(8.3, 2.7);\n//...\n</code></pre> <p>En este otro ejemplo, la variable c1 es reasignada, es decir, se le asigna otro objeto mediante el operador  new, por  lo  tanto  se  pierde  cualquier  referencia  al  objeto  creado  al  principio  <code>new Complex(7.2 , 2.4)</code> por lo que dicho objeto pasa a ser elegible para el recolector de basura.</p>"},{"location":"bloque_i/tema_4/page-5/","title":"5 This","text":""},{"location":"bloque_i/tema_4/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Cuando se llama a un m\u00e9todo, se pasa autom\u00e1ticamente un argumento impl\u00edcito que es una referencia al objeto invocado, es decir, el objeto sobre el que se llama el m\u00e9todo. Esta referencia se llama this, es decir, this es una variable que hace referencia al objeto actual.</p> <p>Veamos los distintos usos que puede tener:</p>"},{"location":"bloque_i/tema_4/page-5/#para-acceder-a-un-atributo-del-objeto-actual","title":"Para acceder a un atributo del objeto actual","text":"<p>Centr\u00e9monos en el getter del atributo color de la clase Vehicle:</p> <pre><code>public String getColor(){\n    return color;\n}\n</code></pre> <p>color es un atributo de la clase Vehicle. El m\u00e9todo getColor() de la clase Vehicle puede acceder perfectamente al atributo color  ya  que  cuando  el  m\u00e9todo  getColor()  es  llamado,  recibe  de forma impl\u00edcita el objeto actual, es decir, el objeto sobre el que se llama el m\u00e9todo. Esto le permite al m\u00e9todo getColor() poder acceder a todos los atributos de la clase y llamar a cualquier m\u00e9todo de la misma.</p> <p>Como color es un atributo de la clase Vehicle, tambi\u00e9n pod\u00edamos haber accedido a \u00e9l como this.colour. Pero en realidad, cuando desde un m\u00e9todo se accede a un atributo, se usa this de forma impl\u00edcita, es decir, que aunque no escribamos this, el compilador lo sobreentiende. Por eso  en  la  pr\u00e1ctica,  solo  se  indica  si  es  imprescindible.  Veamos  un  ejemplo  en  el  que  sea imprescindible:</p> <pre><code>public void setColor(String color){\n    this.color = color;\n}\n</code></pre> <p>En este caso, nos encontramos con dos variables que se llaman color: el atributo y el par\u00e1metro del m\u00e9todo. El shadow (sombra) de variables se refiere a la pr\u00e1ctica en programaci\u00f3n de utilizar dos variables con el mismo nombre dentro de \u00e1mbitos que se superponen. La variable con el alcance de nivel superior se oculta porque la variable con el alcance de nivel inferior la anula. La variable de nivel superior se dice entonces que es \"sombreada\". En nuestro ejemplo, el atributo es  \"sombreado\" por  el  par\u00e1metro,  es  decir,  cuando  en  el  m\u00e9todo  accedemos  a  colour,  es  el par\u00e1metro al que nos estamos refiriendo. Para poder acceder al atributo, necesitamos utilizar la palabra this: <code>this.colour</code>. \u00bfQu\u00e9 es lo que estamos haciendo entonces con esta l\u00ednea de c\u00f3digo: <code>this.colour = colour</code>? Pues le estamos asignando el valor del par\u00e1metro al atributo, es decir, estamos actualizando el color del objeto actual con el color pasado por par\u00e1metro al m\u00e9todo setColor.</p>"},{"location":"bloque_i/tema_4/page-5/#para-invocar-un-constructor","title":"Para invocar un constructor","text":"<p>Un constructor puede llamar a otro constructor de la clase utilizando this, pero esta llamada solamente puede estar en la primera linea de c\u00f3digo.</p> <pre><code>public class Vehicle{\n\n    //...\n\n    public Vehicle(){\n        this(4, \"Blanco\");\n    }\n\n    public Vehicle(int wheelCount, String color) {\n        this.wheelCount = wheelCount;\n        this.color = color;\n        speed = 0;\n    }\n\n    //...\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-5/#como-referencia-al-objeto-actual","title":"Como referencia al objeto actual","text":"<p>Dentro de la clase, siempre que queramos obtener una referencia al objeto actual, podemos utilizar this.</p> <p>Supongamos que queremos modificar el m\u00e9todo acelerar los veh\u00edculos para que devuelvan el objeto actual con la velocidad modificada por la aceleraci\u00f3n:</p> <pre><code>public Vehicle accelerate(double amount){\n    speed += amount;\n    return this;\n}\n</code></pre> <p>Veamos m\u00e1s ejemplos del uso de this como referencia al objeto actual. Vamos a a\u00f1adir los m\u00e9todo nuevos a la clase Vehicle:</p> <ul> <li>addSpeeds: devuelve la suma de dos velocidades, la del objeto actual y la del veh\u00edculo pasado como par\u00e1metro.</li> <li>doubleSpeed: dobla la velocidad del objeto actual utilizando el m\u00e9todo addSpeeds.</li> </ul> <pre><code>public double addSpeeds(Vehicle vehicle){\n    return speed + vehicle.speed;\n}\n\npublic void doubleSpeed(){\n    speed = addSpeeds(this);\n}\n</code></pre> <p>Para doblar la velocidad utilizando el m\u00e9todo addSpeeds, tenemos que pasarle a este m\u00e9todo la referencia al objeto actual para que sume la velocidad consigo mismo, doblando de esta forma su propia velocidad.</p> MainConsola <pre><code>public class Main{\n    public void showThisCurrentObject(){\n        Vehicle car1, car2;\n        car1 = new Vehicle(4, \"azul\");\n        car2 = new Vehicle(2, \"rojo\");\n\n        car1.accelerate(90.3);\n        car2.accelerate(120.5);\n\n        System.out.printf(\"Velocidad del coche1: %.2f\\n\", car1.getSpeed());\n        System.out.printf(\"Velocidad del coche2: %.2f\\n\", car2.getSpeed());\n\n        System.out.printf(\"Suma de las velocidades de los dos coches: %.2f\\n\", car1.addSpeeds(car2));\n\n        car1.doubleSpeed();\n        System.out.printf(\"El coche1 ha doblado su velocidad: %.2f\\n\", car1.getSpeed());\n    }\n\n    public static main(String[] args){\n        new Main().showThisCurrentObject();\n    }\n}\n</code></pre> <pre><code>Velocidad del coche1: 90,30\nVelocidad del coche2: 120,50\nSuma de las velocidades de los dos coches: 210,80\nEl coche1 ha doblado su velocidad: 180,60\n</code></pre> <p>El m\u00e9todo doubleSpeed de la clase Vehicle puede llamar perfectamente al m\u00e9todo addSpeeds ya que cuando el m\u00e9todo doubleSpeed es llamado, recibe de forma impl\u00edcita el objeto actual, es decir, el objeto sobre el que se llama el m\u00e9todo. Esto le permite al m\u00e9todo doubleSpeed poder acceder a todos los atributos de la clase y llamar a cualquier m\u00e9todo de la misma.</p> <p>Como addSpeeds es un m\u00e9todo de la clase Vehicle, el m\u00e9todo doubleSpeed pod\u00eda haberlo llamado tambi\u00e9n utilizando el this: <code>this.addSpeeds(this)</code>, pero en realidad, cuando desde un m\u00e9todo se llama a otro de la clase, se usa this de forma impl\u00edcita, es decir, que aunque no escribamos this, el compilador lo sobreentiende. Por eso en la pr\u00e1ctica, solo se indica si es imprescindible.</p> Ejercicio 6 <p>Crea un paquete llamado exercise06 y copia la clase Persona del paquete exercise04 y crea un constructor que reciba todos los par\u00e1metros excepto la ocupaci\u00f3n, siendo su valor por defecto \"sin ocupaci\u00f3n\". Realice dicho constructor y los ya creados haciendo uso de la referencia this. Crea una clase Main para probar todos los constructores.</p> Ejercicio 7 <p>Crea un paquete llamado exercise07 y copia la clase Persona del ejercicio anterior y crea un atributo decimal para almacenar el sueldo. Crea un m\u00e9todo sumarSueldo que reciba una persona por par\u00e1metro. Dicho m\u00e9todo tiene que incrementar el sueldo con el sueldo de la persona recibida como par\u00e1metro. Crear otro m\u00e9todo, doblarSueldo, que doble el sueldo utilizando el m\u00e9todo sumarSueldo y this. Crea un main para probarlos.</p>"},{"location":"bloque_i/tema_4/page-6/","title":"6 T\u00e9cnicas","text":""},{"location":"bloque_i/tema_4/page-6/#encadenamiento-de-llamadas-a-metodos","title":"Encadenamiento de llamadas a m\u00e9todos","text":"<p>Se emplea cuando invocamos a un m\u00e9todo de un objeto que nos devuelve como resultado otro objeto al que podemos volver a invocar otro m\u00e9todo y as\u00ed encadenar varias operaciones:</p> <pre><code>public class CallsToMethods {\n    public void show(){\n        Boolean b;\n        String string;\n\n        string = \"EntornosDeDesarrollo\";\n        System.out.println(string.substring(10).toUpperCase()); //DESARROLLO\n\n        b = Boolean.TRUE;\n        System.out.println(b.toString().charAt(2));\n    }\n\n    public static void main(String[] args) {\n        new CallsToMethods().show();\n    }\n}\n</code></pre> <p>En este ejemplo, el m\u00e9todo <code>substring(10)</code>  est\u00e1 devolviendo una subcadena de la cadena string a partir del car\u00e1cter 10 empezando en 0, es decir, \"Desarrollo\", al que se le invoca luego el m\u00e9todo  <code>toUpperCase</code>  devolviendo como resultado la cadena \"DESARROLLO\".</p> <p>Y el m\u00e9todo <code>toString()</code> de la variable b de tipo Boolean est\u00e1 devolviendo la cadena \"true\" a la que se le encadena el m\u00e9todo  <code>charAt(2)</code> devolviendo el car\u00e1cter 'u'.</p>"},{"location":"bloque_i/tema_4/page-6/#sintaxis-fluida","title":"Sintaxis fluida","text":"<p>Cuando un m\u00e9todo modifica alg\u00fan atributo del objeto, se puede devolver el objeto con un return para  que  dicho  m\u00e9todo  pueda  insertarse  en  una  expresi\u00f3n.  Esto  permite  encadenar  otras llamadas de m\u00e9todos consiguiendo que el c\u00f3digo sea m\u00e1s corto, m\u00e1s legible y m\u00e1s f\u00e1cil de manejar para los programadores.</p> <p>Veamos un ejemplo de clases, una con sintaxis fluida y otra sin ella para ver la diferencia.</p> Vehicle sin fluidezVehicle con sintaxis fluidaMainConsola <pre><code>public class Vehicle {\n    private int wheelCount; // N\u00ba ruedas\n    private double speed; // Velocidad\n    private String color; // Color del veh\u00edculo\n\n    public Vehicle(){\n        this(4, \"Blanco\");\n    }\n\n    public Vehicle(int wheelCount, String color) {\n        this.wheelCount = wheelCount;\n        this.color = color;\n        speed = 0;\n    }\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public void setWheelCount(int wheelCount) {\n        this.wheelCount = wheelCount;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public void accelerate(double amount){ // acelerar\n        speed += amount;\n    }\n    public void brake(double amount){ // frenar\n        speed -= amount;\n    }\n}\n</code></pre> <pre><code>public class Vehicle2 {\n    private int wheelCount; // N\u00ba ruedas\n    private double speed; // Velocidad\n    private String color; // Color del veh\u00edculo\n\n    public Vehicle2(){\n        this(4, \"Blanco\");\n    }\n\n    public Vehicle2(int wheelCount, String color) {\n        this.wheelCount = wheelCount;\n        this.color = color;\n        speed = 0;\n    }\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public void setWheelCount(int wheelCount) {\n        this.wheelCount = wheelCount;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public Vehicle2 setColor(String color) {\n        this.color = color;\n        return this;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public Vehicle2 accelerate(double amount){ // acelerar\n        speed += amount;\n        return this;\n    }\n    public Vehicle2 brake(double amount){ // frenar\n        speed -= amount;\n        return this;\n    }\n}\n</code></pre> <pre><code>public class FluidSyntax {\n    public void show(){\n        Vehicle car1;\n        Vehicle2 car2;\n\n        car1 = new Vehicle(4, \"rojo\");\n        car2 = new Vehicle2(4, \"azul\");\n\n        car1.accelerate(120.55);\n        car1.brake(20.32);\n\n        System.out.printf(\"Velocidad del coche1: %.2f\\n\", car1.getSpeed());\n\n        System.out.printf(\"Velocidad del coche2: %.2f\\n\", car2.accelerate(120.55).brake(20.32).getSpeed());\n    }\n\n    public static void main(String[] args) {\n        new FluidSyntax().show();\n    }\n}\n</code></pre> <pre><code>Velocidad del coche1: 100,23\nVelocidad del coche2: 100,23\n</code></pre>"},{"location":"bloque_i/tema_4/page-6/#invariante-de-una-clase","title":"Invariante de una clase","text":"<p>El invariante de una clase es el conjunto de restricciones que deben cumplir todos los objetos que se instancien de dicha clase, como por ejemplo:</p> <ul> <li>Restricciones sobre los valores que pueden tomar los atributos de la clase. Ejemplo: el atributo wheelCount de la clase Vehicle tiene que ser mayor que 0.</li> <li>Restricciones que afecten a m\u00e1s de un atributo. Por ejemplo, si una clase modela un rango de valores, el atributo que corresponda al l\u00edmite superior del rango debe ser forzosamente mayor o igual que el atributo que corresponda al l\u00edmite inferior del rango, dada la definici\u00f3n matem\u00e1tica del rango.</li> <li>Restricciones con respecto a los objetos con los que se relaciona. Ejemplo: un empleado tiene un atributo que es objeto de la clase Empresa donde trabaja. Una restricci\u00f3n posible ser\u00eda que dicha empresa no pueda ser nula.</li> </ul> <p>Los m\u00e9todos constructores de una clase deben respetar el invariante de la clase a la hora de construir los objetos.</p> <p>Los m\u00e9todos p\u00fablicos de la clase tambi\u00e9n deben respetar el invariante. Un m\u00e9todo puede no respetar el invariante en el transcurso de la ejecuci\u00f3n, pero cuando el m\u00e9todo finalice, el invariante se tiene que cumplir, es decir, es perfectamente viable que un m\u00e9todo para alcanzar su objetivo pueda perder de forma temporal el invariante pero siempre y cuando finalice con el invariante cumplido, es decir, antes de la llamada el invariante se debe cumplir y despu\u00e9s de la llamada tambi\u00e9n, durante la ejecuci\u00f3n del mismo puede no satisfacerse.</p> <p>\u00danicamente se deben satisfacer los invariantes en las llamadas a m\u00e9todos p\u00fablicos, la ejecuci\u00f3n de m\u00e9todos privados de la misma clase pueden saltarse esta norma aunque no es aconsejable.</p> <p>Definir invariantes de clase puede ayudar a los programadores y controladores de calidad a localizar m\u00e1s errores durante las pruebas de software.</p>"},{"location":"bloque_i/tema_4/page-6/#encapsulamiento","title":"Encapsulamiento","text":"<p>La encapsulaci\u00f3n es un principio fundamental de la programaci\u00f3n orientada a objetos que consiste en ocultar el estado o los atributos de un objeto y obligar a que toda interacci\u00f3n se realice a trav\u00e9s de los m\u00e9todos del objeto definidos en su clase para conservar su invariante.</p> <p>El encapsulamiento se consigue utilizando los modificadores de acceso. Se recomienda que los atributos de una clase sean privados, por lo tanto, aquellos atributos que se permitan consultar deben tener sus propios m\u00e9todos get, y los que se permitan modificar, deben tener sus propios m\u00e9todos set. Hacer uso de este convenio nos facilitar\u00e1 trabajar con el resto del mundo y nos permitir\u00e1 ampliar las capacidades de nuestro c\u00f3digo utilizando frameworks existentes que hacen uso del convenio y que si no seguimos no podremos utilizar.</p> VehicleMain <pre><code>public class Vehicle {\n    public int wheelCount; // N\u00ba ruedas\n    public double speed; // Velocidad\n    public String color; // Color del veh\u00edculo\n\n    public Vehicle(int wheelCount, String color) {\n        this.wheelCount = wheelCount;\n        this.color = color;\n        speed = 0;\n    }\n\n    public void accelerate(double amount){ // acelerar\n        speed += amount;\n    }\n    public void brake(double amount){ // frenar\n        speed -= amount;\n    }\n}\n</code></pre> <pre><code>public class NoEncapsulation {\n    public void show(){\n        Vehicle car = new Vehicle(4, \"azul\");\n\n        car.accelerate(90.54);\n        System.out.printf(\"Velocidad: %.2f\\n\", car.speed);\n\n        car.speed = 120; // Se accede directamente\n        System.out.printf(\"Velocidad: %.2f\\n\", car.speed);\n    }\n\n    public static void main(String[] args) {\n        new NoEncapsulation().show();\n    }\n}\n</code></pre> <p>Podemos observar que no se est\u00e1 cumpliendo el principio de encapsulamiento ya que el cliente est\u00e1 accediendo directamente al atributo speed modificando incorrectamente su valor ya que la velocidad solamente se debe modificar acelerando o frenando el veh\u00edculo.</p> <p>El ejemplo anterior pero cumpliendo encapsulamiento ocultando el estado o los atributos del objeto y obligando a toda interacci\u00f3n se realice a trav\u00e9s de los m\u00e9todos del objeto definidos en su clase, ser\u00eda tal y como hemos estado viendo en ejemplos anteriores, es decir, haciendo privado sus atributos y creando los m\u00e9todos getters y setters necesarios.</p> Vehicle <pre><code>public class Vehicle{\n    private int wheelCount; // N\u00ba ruedas\n    private double speed; // Velocidad\n    private String color; // Color del veh\u00edculo\n\n    public Vehicle(){\n        this(4, \"Blanco\");\n    }\n\n    public Vehicle(int wheelCount, String color) {\n        this.wheelCount = wheelCount;\n        this.color = color;\n        speed = 0;\n    }\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public void setWheelCount(int wheelCount) {\n        this.wheelCount = wheelCount;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public void accelerate(double amount){ // acelerar\n        speed += amount;\n    }\n    public void brake(double amount){ // frenar\n        speed -= amount;\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-6/#metodo-tostring","title":"M\u00e9todo toString","text":"<p>El m\u00e9todo <code>toString()</code> se utiliza para obtener una cadena de texto que represente al objeto. Lo veremos en m\u00e1s profundidad en el tema de herencia. Veamos su uso:</p> VehicleMain <pre><code>public class Vehicle {\n    //...\n\n    @Override\n    public String toString() {\n        return \"Vehicle [wheelCount =\" + wheelCount + \", speed=\" + speed + \", color =\" + color + \"]\";\n    }\n}\n</code></pre> <pre><code>public static void main(String[] args){\n    Vehicle car = new Vehicle(4, \"rojo\");\n\n    System.out.println(car.toString());\n}\n</code></pre> <p>Algunos IDEs pueden generar toString() de forma autom\u00e1tica.</p> <p>El m\u00e9todo <code>System.out.println</code> y sus derivados llaman autom\u00e1ticamente al m\u00e9todo toString si se le pasa el objeto</p> <pre><code>public static void main(String[] args){\n    Vehicle car = new Vehicle(4, \"rojo\");\n\n    System.out.println(car); // Es lo mismo que car.toString()\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-7/","title":"7 Records","text":""},{"location":"bloque_i/tema_4/page-7/#patron-de-diseno-dto","title":"Patr\u00f3n de dise\u00f1o DTO","text":"<p>Una de las problem\u00e1ticas m\u00e1s comunes cuando desarrollamos aplicaciones, es dise\u00f1ar la forma en que la informaci\u00f3n debe viajar desde una capa de la aplicaci\u00f3n a otra capa, ya que muchas veces por desconocimiento o pereza, utilizamos las clases de entidades para retornar los datos, lo que ocasiona que retornemos m\u00e1s datos de los necesarios, o incluso, tengamos que ir en m\u00e1s de una ocasi\u00f3n a la capa de servicios para recuperar los datos requeridos.</p> <p>El patr\u00f3n de dise\u00f1o DTO (Data Transfer Object) tiene como finalidad la creaci\u00f3n de objetos planos (POJO) con una serie de atributos que puedan ser enviados o recuperados del servidor en una sola invocaci\u00f3n, de tal forma que un DTO puede contener informaci\u00f3n de m\u00faltiples fuentes o tablas y concentrarlas en una \u00fanica clase simple.</p> <p>Supongamos que tenemos dos tablas en la base de datos, una de clientes (Customers) y otra con su direcci\u00f3n (Address). En esta \u00faltima, se hace referencia a la tabla clientes, pero en clientes no existe una referencia a la tabla direcci\u00f3n, por lo que nos encontrados en una relaci\u00f3n 1:N.</p> <p> Figura 6 - DTO database</p> <p>El problema con esta relaci\u00f3n viene cuando queremos crear un servicio que retorne al cliente con su direcci\u00f3n, pues la entidad <code>Customer</code> no tendr\u00e1 una relaci\u00f3n al objeto <code>Adress</code>, lo que nos obligar\u00e1 a hacer dos llamadas al backend para recuperar al cliente y la direcci\u00f3n por separado o terminar contaminando la entidad al agregar el campo address que no es necesario para la persistencia.</p> <p>Como vemos, utilizar una Entity o cualquier otro objeto que all\u00e1 sido creado para otro prop\u00f3sito diferente que el de ser usado para transmisi\u00f3n de datos puede tener complicaciones, por lo que el patr\u00f3n DTO propone que en lugar de usar estas clases, creemos clases especiales para transmitir los datos, de esta forma, podemos controlar los datos que enviamos, el nombre, el tipo de datos, etc, adem\u00e1s, si estos necesitan cambiar, no tiene impacto sobre la capa de servicios o datos, pues solo se utilizan para transmitir la respuesta. Dicho lo anterior, retornemos al ejemplo anterior, pero utilizando un DTO:</p> <p> Figura 7 - DTO</p> <p>Para que una clase sea considera DTO debe cumplir algunas reglas:</p> <ul> <li>Debe ser una clase solo de lectura, es decir, no deben de crearse los m\u00e9todos setters ni otros m\u00e9todos que modifiquen directamente el valor de un atributo. Adem\u00e1s, dichos atributos deben ser constantes por lo que deber\u00edan usar el modificador de acceso final.</li> <li>Tambi\u00e9n, deben ser serializables, tanto la clase, como cada uno de sus objetos.</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>public class CustomerDTO implements Serializable{\n\n    private final int id;\n    private final String fullName;\n    private final String country;\n    private final Address address; // !(1)\n    private final int cp;\n    private final String date;\n\n    public CustomerDTO(int id, String fullName, String country, Address address, int cp, String date){\n        this.id = id;\n        this.fullName = fullName;\n        this.country = country;\n        this.address = address;\n        this.cp = cp;\n        this.date = date;\n    }\n\n    public int getId(){\n        return id;\n    }\n\n    public String getFullName(){\n        return fullName;\n    }\n\n    public String getCountry(){\n        return country;\n    }\n\n    public Address getAddress(){\n        return address;\n    }\n\n    public int getCp(){\n        return cp;\n    }\n\n    public String getDate(){\n        return date;\n    }\n\n    @Override\n    public boolean equals(Object o){\n        /* ... */\n    }\n\n    @Override\n    public boolean hashCode(){\n        /* ... */\n    }\n\n    @Override\n    public String toString(){\n        /* ... */\n    }\n}\n</code></pre> <ol> <li>La clase <code>Address</code> debe ser tambi\u00e9n serializable, as\u00ed como, todos los atributos de la misma.</li> </ol> Ejercicio 1 <p>Haciendo uso del patr\u00f3n de dise\u00f1o DTO, crea las clases necesarias para almacenar los autores y libros de una biblioteca.</p> <p>De loas autores se desea almacenar:</p> <ul> <li>C\u00f3digo identificativo.</li> <li>Nombre del autor</li> <li>A\u00f1o de nacimiento</li> <li>A\u00f1o de defunci\u00f3n (si procede)</li> </ul> <p>De los libros se desea almacenar:</p> <ul> <li>C\u00f3digo ISBN en base 13</li> <li>C\u00f3digo ISBN en base 10</li> <li>Nombre del libro</li> <li>El autor que ha escrito el libro</li> <li>A\u00f1o de publicaci\u00f3n</li> <li>Nombre de la editorial</li> </ul>"},{"location":"bloque_i/tema_4/page-7/#records","title":"Records","text":"<p>Los registros o records son una caracter\u00edstica nueva de Java incorporada inicialmente como previa en la versi\u00f3n 14, y posteriormente movida a estable en el 17. Se trata de una implementaci\u00f3n del patr\u00f3n DTO, de otros lenguajes de programaci\u00f3n. Son clases que se usan para almacenar valores y poder agruparlos en un \u00fanico identificador, de manera fundamental.</p> <p>Por lo general \u00fanicamente se especifica qu\u00e9 atributos se interesa que tenga un registro, y al compilar un registro, el compilador se ocupar\u00e1 de generar constructores, getters y m\u00e9todos, as\u00ed como <code>toString()</code>, <code>equals()</code> o <code>hashCode()</code> de forma autom\u00e1tica. En definitiva, parte del atractivo de los registros es permitir conseguir algo parecido a lo que podemos hacer con clases tradicionales de Java, pero utilizando mucho menos c\u00f3digo.</p> <p>La estructura de un record es la siguiente:</p> <pre><code>public record MyRecord(type1 attribute1, type2 attribute2, ..., typeN attributeN){\n\n}\n</code></pre> <p>Como se puede observar es una estructura muy parecida a las clases, pero con dos diferencias cruciales:</p> <ul> <li>Se utiliza la palabra reservada <code>record</code> en lugar de la palabra reservada <code>class</code>. De esta manera, el compilador ser\u00e1 consciente de cuando una clase es una clase normal o es una clase que implementa el patr\u00f3n DTO.</li> <li>Por otro lado, la declaraci\u00f3n de los atributos de la clase se realizan en la firma de la misma, utilizando los par\u00e9ntesis <code>()</code> como si fuese una especie de constructor. Estos atributos se crean directamente con el modificador de acceso <code>private final</code>.</li> </ul> <pre><code>public record Customer(int id, String fullName, String country, Address address, int cp, String date){\n\n}\n</code></pre> <p>Por defecto, la clase record se traducir\u00eda a algo, tal que as\u00ed:</p> <pre><code>public class Customer implements Serializable{\n\n    private final int id;\n    private final String fullName;\n    private final String country;\n    private final Address address;\n    private final int cp;\n    private final String date;\n\n    public CustomerDTO(int id, String fullName, String country, Address address, int cp, String date){\n        this.id = id;\n        this.fullName = fullName;\n        this.country = country;\n        this.address = address;\n        this.cp = cp;\n        this.date = date;\n    }\n\n    public int id(){\n        return id;\n    }\n\n    public String fullName(){\n        return fullName;\n    }\n\n    public String country(){\n        return country;\n    }\n\n    public Address address(){\n        return address;\n    }\n\n    public int cp(){\n        return cp;\n    }\n\n    public String date(){\n        return date;\n    }\n\n    @Override\n    public boolean equals(Object o){\n        if(this == 0) return true;\n        if(o == null || getClass() != o.getClass()) return false;\n        Customer customer = (Customer) o;\n        return id == o.id &amp;&amp; fullName.equals(o.fullName) \n            &amp;&amp; country.equals(o.country) &amp;&amp; address.equals(o.address)\n            &amp;&amp; cp.equals(o.cp) &amp;&amp; date.equals(o.date);\n    }\n\n    public boolean hashCode(){\n        return Objects.hash(id, fullName, country, address, cp, date);\n    }\n\n    public String toString(){\n        return \"Customer[id=\"+id+\", fullName=\"+fullName+\", country=\"+country+\" address=\"+address+\", cp=\"+cp+\", date=\"+date+\"]\";\n    }\n}\n</code></pre> <p>Observe que los m\u00e9todos getters no son convencionales, es decir, no empiezan con el prefijo get seguido del nombre del atributo, si no que directamente es el nombre del atributo.</p> Ejercicio 2 <p>Realiza el ejercicio anterior, haciendo uso de records.</p>"},{"location":"bloque_i/tema_4/page-7/#metodos-adicionales","title":"M\u00e9todos adicionales","text":"<p>Adem\u00e1s de los m\u00e9todos que el record te crea por defecto, tambi\u00e9n se pueden crear m\u00e9todos adicionales:</p> <pre><code>public record Customer(/*...*/){\n\n    public String username(){\n        return '@' + fullName;\n    }\n}\n</code></pre> <p>Una limitaci\u00f3n importante a tener en cuenta, es que los m\u00e9todos creados no deben modificar los valores de los atributos, ya que \u00e9stos por defectos son <code>final</code>, es decir, constantes. Por consecuencia, no se pueden crear m\u00e9todos setters.</p> <pre><code>public record Customer(/*...*/){\n\n    public String username(){\n        return '@' + fullName;\n    }\n\n    public void setFullName(String fullName) { // \u274c ERROR COMPILACI\u00d3N \u274c\n      this.fullName = fullName;\n    }\n}\n</code></pre> Ejercicio 3 <p>A las clases anteriores, creales los m\u00e9todos siguientes que sean posible:</p> <ul> <li>M\u00e9todo para modificar el nombre del libro</li> <li>M\u00e9todo que devuelva el valor de ISBN13 o 10 con el siguiente formato: <code>ISBN13:XXXX-XXXX-XXXX-XXXX-X</code></li> <li>M\u00e9todo que a\u00f1ada 10 a\u00f1os a la fecha de la publicaci\u00f3n, para en caso de que haya habido un error al crearlo.</li> <li>M\u00e9todo que muestre la informaci\u00f3n del libro en forma de tabla.</li> </ul>"},{"location":"bloque_i/tema_4/page-7/#constructores-auxiliares","title":"Constructores auxiliares","text":"<p>Tambi\u00e9n es posible crear constructores adicionales para un record. No obstante, existe la obligaci\u00f3n de llamar en alg\u00fan momento al constructor completo, porque todos los atributos del record deben recibir un valor inicial. Por lo que no se podr\u00eda crear un constructor vac\u00edo:</p> <pre><code>public record Customer(/* ... */){\n    public Customer(){ // \u274c ERROR COMPILACI\u00d3N \u274c\n        System.out.println('Creating empty record...');\n    }\n}\n</code></pre> <p>Tampoco se debe crear un constructor, el cual se de valores a unos atributos y otros no. En ese caso, ser\u00e1 necesario indicar un valor por defecto:</p> <pre><code>public record Customer(/* ... */){\n    public Customer(int id, String fullName, String country, Address address, int cp){ \n        this(id, fullName, country, address, cp, '2024-06-06');\n    }\n}\n</code></pre> <p>Como vemos en el ejemplo anterior, se ha a\u00f1adido un constructor d\u00f3nde no se pasa la fecha, pero tiene por defecto la fecha actual.</p> Ejercicio 4 <p>A\u00f1ade un constructor a la clase libro, que reciba todos los par\u00e1metros, excepto el a\u00f1o de publicaci\u00f3n, para aquellos libros que a\u00fan no han sido publicados. Cuando un libro no ha sido publicado se almacenar\u00e1 en una base de datos el valor -1.</p>"},{"location":"bloque_i/tema_4/page-8/","title":"8 Clases e interfaces selladas","text":""},{"location":"bloque_i/tema_4/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Una jerarqu\u00eda de clases nos permite reutilizar el c\u00f3digo mediante la herencia. Sin embargo, la jerarqu\u00eda de clases tambi\u00e9n puede cumplir otros prop\u00f3sitos. La reutilizaci\u00f3n del c\u00f3digo es excelente, pero no siempre es nuestro objetivo principal.</p> <p>Un prop\u00f3sito alternativo de una jerarqu\u00eda de clases puede ser modelar varias posibilidades que existen en un dominio.</p> <p>Como ejemplo, imaginemos un dominio empresarial que solo trabaja con autom\u00f3viles y camiones, no con motocicletas. Al crear la clase abstracta <code>Vehicle</code> en Java, deber\u00edamos poder permitir que solo las clases <code>Car</code> y <code>Truck</code> la extiendan. Por lo tanto, queremos asegurarnos de que no se haga un uso indebido de la clase abstracta <code>Vehicle</code> dentro de nuestro dominio.</p> <p>En este ejemplo, nos interesa m\u00e1s la claridad del c\u00f3digo que maneja subclases conocidas que la defensa contra todas las subclases desconocidas .</p> <p>En versiones anteriores, Java proporcionaba opciones limitadas en el \u00e1rea de control de herencia.</p> <p>Una clase <code>final</code> no puede tener subclases. Una clase <code>friendly</code> solo puede tener subclases en el mismo paquete.</p> <p>Una superclase desarrollada con un conjunto de sus subclases deber\u00eda poder documentar su uso previsto, sin restringir sus subclases. Adem\u00e1s, tener subclases restringidas no deber\u00eda limitar la accesibilidad de su superclase.</p>"},{"location":"bloque_i/tema_4/page-8/#sealed","title":"Sealed","text":"<p>Una clase o interfaz sellada (sealed) permite crear una clase o interfaz que solo puedan ser heredadas por las clases que el mismo programador que las crea, permite.</p> <p>Las clases e interfaces selladas, fueron a\u00f1adidas en su versi\u00f3n alpha en la versi\u00f3n 15 de Java, y de forma estable en la versi\u00f3n 17.</p> <p>Para crear una clase o interfaz sellada, se usa el modificador de acceso <code>sealed</code> seguido del nombre la clase o interfaz. Luego, se usa el modificar <code>permit</code> seguido del nombre de las clases o interfaces que pueden heredar o implementar dicha clase.</p> <p>Veamos un ejemplo</p> Clase selladaInterfaz sellada <pre><code>public abstract sealed class Vehicle permits Car, Truck {\n\n    protected final String registrationNumber;\n\n    public Vehicle(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public String getRegistrationNumber() {\n        return registrationNumber;\n    }\n\n}\n</code></pre> <pre><code>public sealed interface Service permits Car, Truck {\n\n    int getMaxServiceIntervalInMonths();\n\n    default int getMaxDistanceBetweenServicesInKilometers() {\n        return 100000;\n    }\n\n}\n</code></pre> <p>Ahora, al crear la clase <code>Car</code> o <code>Truck</code> ambas pueden heredar de la clase <code>Vehicle</code> y/o implementar la interface <code>Service</code>:</p> <pre><code>public final class Car extends Vehicle{\n    //...\n}\n</code></pre> <p>Sin embargo, una clase diferente a <code>Car</code> o <code>Truck</code> no podr\u00e1 ni heredar ni implementar la clase o interfaz sellada:</p> <pre><code>public class OtherClass implements Service{ // \u274c ERROR DE COMPILACI\u00d3N \u274c\n    // ...\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-8/#clase-permitida","title":"Clase permitida","text":"<p>Una clase o interfaz permitida es aquella a la que se le permite heredar o implementar una clase o interfaz sellada. Sin embargo, esto debe tener una restricci\u00f3n, ya que si <code>Vehicle</code> permite que la clase <code>Car</code> pueda heredar de ella, no es una buena pr\u00e1ctica que cualquier otra clase pueda heredar de la clase <code>Car</code>.</p> <p>Para ello, la sealed class o sealed interface requieren de forma obligatoria que la clase o interfaz heredada o implementada utilice un modificador de acceso, <code>final</code>, <code>sealed</code> o <code>non-sealed</code>.</p> <p>Si la clase o interfaz permitida utiliza el modificador de acceso <code>final</code>, esta clase no puede tener herencia. Por lo que, estar\u00edamos evitando que cualquier otra clase o interfaz no permitida herede o implemente de nuestra clase o interfaz sellada.</p> <pre><code>public final class Car extends Vehicle implements Service{\n    //...\n}\n</code></pre> <p>Por otro lado, si una clase o interfaz utiliza el modificar <code>sealed</code> tambi\u00e9n quedar\u00e1 sellada, por lo que podr\u00e1n heredar o implementar de ella, las clases que \u00e9sta permite.</p> <pre><code>public sealed class Car extends Vehicle implements Service permits Class1{\n    // ...\n}\n</code></pre> <p>Tambi\u00e9n se puede utilizar el modificador <code>non-sealed</code>. En este caso, la clase permitida tambi\u00e9n permite su implementaci\u00f3n y su extensi\u00f3n:</p> <pre><code>public non-sealed class Car extends Vehicle implements Service{\n    // ...\n}\n</code></pre> Ejercicio <p>Crea una clase sellada <code>Shape</code> que permita su implementaci\u00f3n en la clase <code>Circle</code>, <code>Square</code> y <code>Triangle</code>. Teniendo en cuenta las siguientes restricciones:</p> <ul> <li>La clase <code>Circle</code> no permitir\u00e1 ninguna tipo de herencia.</li> <li>La clase <code>Square</code> permitir\u00e1 herencia \u00fanicamente de la clase <code>Rectangle</code>.</li> <li>Cualquier clase puede heredar de la clase <code>Triangle</code>.</li> </ul>"},{"location":"bloque_i/tema_4/page-9/","title":"Ejercicios","text":"Ejercicio 8 <p>Crea un paquete llamado exercise08 y realiza una clase de nombre Alumno que cumpla estas especificaciones:</p> <ul> <li>El constructor admite como argumentos el n\u00famero de matr\u00edcula y el nombre y almacena \u00e9stos en los correspondientes atributos.</li> </ul> <p>Contiene los siguientes m\u00e9todos:</p> <ul> <li>ponNota: con dos argumentos de tipo double que corresponden a dos notas de su examen. El m\u00e9todo almacena \u00e9stos en dos atributos de tipo double.</li> <li>dameMedia: retorna la media de las notas.</li> <li>toString: retorna una descripci\u00f3n del alumno con todos sus datos, incluida la nota media</li> </ul> <p>Realiza una aplicaci\u00f3n de nombre VerAlumno que solicite los datos de un alumno y sus notas, construya un objeto de la clase Alumno y muestre los datos de \u00e9ste.</p> Ejercicio 9 <p>Crea un paquete llamado exercise09 y realiza una clase que represente una pel\u00edcula en DVD de nombre DVDCine con los atributos necesarios para mostrar su ficha. La pel\u00edcula tiene dos nombres, el original y el traducido. Esta clase contar\u00e1 con un constructor que admite como argumentos todos los atributos de la clase.</p> <p>Escribe los siguientes m\u00e9todos para la clase DVDCine:</p> <ul> <li>esThriller: este m\u00e9todo devuelve cierto si la pel\u00edcula pertenece a este g\u00e9nero cinematogr\u00e1fico (tratar los g\u00e9neros de las pel\u00edculas como enum)</li> <li>tieneResumen: devuelve cierto si la ficha de la pel\u00edcula tiene el resumen escrito.</li> <li>muestraDuracion: devuelve una cadena con la duraci\u00f3n en minutos. Ejemplo: 114 min.</li> <li> <p>toString: este m\u00e9todo devuelve una descripci\u00f3n completa de la pel\u00edcula de la siguiente manera:</p> <p>UN FINAL MADE IN HOLLYWOOD (HOLLYWOOD ENDING) De: Woody Allen Con: Woody Allen y George Hamilton Comedia - 114 min Resumen: Los Oscars ganados en el pasado por el ex-genio del cine Val Waxman...</p> </li> </ul> <p>Si la pel\u00edcula no tiene resumen, la \u00faltima l\u00ednea no aparece. Escribe una aplicaci\u00f3n que solicite los datos de una pel\u00edcula, genere un objeto DVD y pruebe todos los m\u00e9todos.</p> Ejercicio 10 <p>Realizar una clase de nombre Alimento en el paquete exercise10 cuyos objetivos representen alimentos. \u00c9stos tendr\u00e1n los atributos siguientes:</p> <ul> <li>Nombre</li> <li>Contenido en l\u00edpidos expresado en tanto por ciento</li> <li>Contenido en hidratos de carbono expresado en tanto por ciento</li> <li>Contenido en prote\u00ednas expresado en tanto por ciento</li> <li>Si es o no de origen animal</li> <li>Contenido en vitaminas expresado mediante un enum ALTO, MEDIO y BAJO.</li> <li>Contenido en minerales expresado con el mismo enum que las vitaminas.</li> </ul> <p>La clase tiene dos constructores: uno que admite como argumentos el nombre del alimento y otro que admite todos los atributos. La clase contiene los siguientes m\u00e9todos:</p> <ul> <li>esDietetico. Este m\u00e9todo retorna cierto si el alimento contiene menos del 20% de l\u00edpidos y el contenido en vitaminas no es bajo.</li> <li>toString. Retorna una descripci\u00f3n del alimentos, mostrando el contenido de vitaminas y minerales solo la inicial, es decir, si es ALTO solo muestra A.</li> <li>calculaContenidoEnergetico. Este m\u00e9todo retorna el contenido en Kcal de un gramo de alimento, considerando que un gramo de l\u00edpidos contiene 9.4Kcal, un gramo de prote\u00ednas contiene 5.3 y un gramo de hidratos de carbono contiene 4.1 Kcal.</li> <li>esRecomendableParaDeportistas. Este m\u00e9todo retorna cierto si el alimento cumple la siguiente lista: prote\u00ednas: 10-15%, l\u00edpidos: 30-35%, hidratos de carbono: 55-65%.</li> </ul> <p>Hacer una aplicaci\u00f3n en la que se creen dos alimentos usando los dos constructores. Mostrar los datos de los alimentos, sus contenidos energ\u00e9ticos, si son diet\u00e9ticos y recomendables para deportistas.</p> Ejercicio 11 <p>Realiza una clase de nombre Veh\u00edculo en el paquete exercise11 que contenga como atributos el modelo de tipo  String, la potencia de tipo double y la tracci\u00f3n a las cuatro ruedas(cRuedas) de tipo boolean. El constructor de la clase admitir\u00e1 como argumento el modelo. La clase tendr\u00e1 como m\u00e9todos de tipo get y set para la potencia y para la tracci\u00f3n a las cuatro ruedas. La clase contar\u00e1 con el m\u00e9todo toString el cual retorna los datos de cada veh\u00edculo y si tiene tracci\u00f3n a las cuatro ruedas. Realiza una aplicaci\u00f3n que solicite al usuario los datos de varios veh\u00edculos hasta que el usuario escriba como modelo la cadena \u201cfin\u201d en may\u00fascula o en min\u00fascula, en cuyo caso no se generar\u00e1 el objeto de la clase Veh\u00edculo. Una vez introducidos todos los veh\u00edculos, la aplicaci\u00f3n terminar\u00e1 mostrando los datos de todos los veh\u00edculos y emitiendo un mensaje de despedida.</p> Ejercicio 12 <p>Una tienda de inform\u00e1tica nos ha contratado para hacerle una aplicaci\u00f3n en java. De los  productos que tiene, quiere almacenar el modelo, el stock, el procesador y el precio, con las siguientes caracter\u00edsticas:</p> <ul> <li>El modelo tiene el siguiente formato: tres d\u00edgitos, guion y cuatro letras may\u00fasculas(incluida la \u00f1). Ejemplos:  112-ACER,334-HHPP,435-ASUS</li> <li>El procesador solamente puede ser de dos tipos: Intel o Amd. Los intel traen una memoria de 8Gb y los Amd de 4Gb.</li> <li>El precio en formato decimal y el stock. Ambos deben ser positivos.</li> </ul> <p>Crea la clase Producto en el paquete exercise12 haciendo lo siguiente:</p> <ul> <li>Los atributos no ser\u00e1n visibles desde fuera de la clase.</li> <li>Crea un m\u00e9todo para consultar el modelo que solamente sea visible para las clases del mismo paquete.</li> <li>Crea un m\u00e9todo para consultar el stock visible para todas las clases.</li> <li>Crea m\u00e9todos para actualizar los atributos que sean visibles tambi\u00e9n para las clases de otro paquete. Se encargar\u00e1n de hacer las comprobaciones necesarias para garantizar que el   formato o los rangos de valores son correctos y lanzar\u00e1n la excepci\u00f3n IllegalArgumentException cuando no sean v\u00e1lidos.</li> <li>Crea un constructor con par\u00e1metros que inicialice los atributos del objeto con los valores indicados en los par\u00e1metros. El constructor no construir\u00e1 el objeto si alg\u00fan atributo no es v\u00e1lido. Para ello, utilizar\u00e1 los m\u00e9todos anteriores para garantizar que los valores de los atributos sean correctos.</li> <li>Crea un constructor que inicialice los atributos del objeto con los siguientes valores. Utiliza el this(par\u00e1metros).<ul> <li>Modelo: 000-NNNN</li> <li>Stock: 0</li> <li>Procesador Intel</li> <li>Precio: 0</li> </ul> </li> <li>Crea el m\u00e9todo toString(). Muestra el precio con 2 decimales.</li> <li>Crea el m\u00e9todo disminuirStock() que decremente en 1 el stock del producto</li> </ul>"},{"location":"bloque_i/tema_5/page-1/","title":"1 Excepciones","text":""},{"location":"bloque_i/tema_5/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Uno de los problemas m\u00e1s importantes al escribir aplicaciones es el tratamiento de los errores. Los  errores  detienen  la  ejecuci\u00f3n  del  programa  e  impiden  su  desarrollo  normal  y,  lo  peor, adem\u00e1s provocan que el usuario est\u00e9 desinformado. Los programadores tiene que reconocer las situaciones que pueden provocar el fin de la ejecuci\u00f3n normal del programa por un error no controlado.  Dicho  de  otra  forma,  todos  los  posibles  errores  en  un  programa  deben  de  estar controlados. A veces es imposible evitarlos (por ejemplo no hay papel en la impresora, o falla el disco  duro),  pero  s\u00ed  reaccionar  de  forma  l\u00f3gica  para  que  el  usuario  reconozca  lo  que  est\u00e1 ocurriendo</p> <p>Java nos echa una mano para ello a trav\u00e9s de las excepciones. Se denomina excepci\u00f3n a un hecho que podr\u00eda provocar la detenci\u00f3n del programa; es decir una condici\u00f3n de error en tiempo de ejecuci\u00f3n pero que puede ser controlable (a trav\u00e9s de los mecanismos adecuados). En java sin embargo se denomina error a una condici\u00f3n de error incontrolable (ejemplos son el error que ocurre cuando no se dispone de m\u00e1s memoria o errores de sintaxis). Los  errores  de  sintaxis  son  detectados  durante  la  compilaci\u00f3n,  pero  los  errores  de  ejecuci\u00f3n pueden  provocar  situaciones  irreversibles,  su  control  debe  hacerse  tambi\u00e9n  en  tiempo  de ejecuci\u00f3n y eso siempre ha sido problem\u00e1tico para la programaci\u00f3n de aplicaciones.</p> <p>En Java se puede preparar el c\u00f3digo susceptible a provocar excepciones de modo que si ocurre una excepci\u00f3n, el c\u00f3digo es lanzado (throw) a una determinada rutina previamente preparada por el programador, que permite manipular esa excepci\u00f3n. Si la excepci\u00f3n no fuera capturada, la ejecuci\u00f3n del programa se detendr\u00eda irremediablemente (en muchas ocasiones la propia sintaxis de Java impide que la excepci\u00f3n no sea controlada; es decir, obliga a controlarla)</p>"},{"location":"bloque_i/tema_5/page-1/#try-catch","title":"Try-catch","text":"<p>El control de las excepciones se realiza mediante las sentencias try y catch.</p> <pre><code>try{\n    // instrucciones que puedan provocar la excepci\u00f3n\n} catch(ClassException1 objetoQueLoCaptura){\n    // instrucciones que se ejecutan si hay un error de tipo ClassException1\n} catch(ClassException2 objetoQueLoCaptura){\n    // instrucciones que se ejecutan si hay un error de tipo ClassException2\n}\n// ...\n</code></pre> <p>Como se puede observar, puede haber m\u00e1s de una sentencia catch para un mismo bloque try debido a que un bloque de c\u00f3digo puede ser susceptible a provocar varios tipos diferentes de excepciones.</p> <p>Dentro del bloque try se colocan las instrucciones susceptibles de provocar una excepci\u00f3n, el bloque catch sirve para capturar esa excepci\u00f3n y evitar el fin de la ejecuci\u00f3n del programa. Desde el bloque catch se maneja, en definitiva, la excepci\u00f3n.</p> <p>Cada catch maneja un tipo de excepci\u00f3n. Cuando se produce una excepci\u00f3n, se busca el catch que posea el manejador de excepci\u00f3n adecuado, ser\u00e1 el que utilice el mismo tipo de excepci\u00f3n que se ha producido. La b\u00fasqueda del catch se realiza en el orden en que se han escrito. Si se produce una excepci\u00f3n, primero se mira si cuadra en el primer catch. Si no cuadra, se pasa al siguiente, y as\u00ed sucesivamente. Por este motivo, es importante el orden en que se coloquen los bloques catch.</p> <p>Cuando acaba la ejecuci\u00f3n del bloque catch, el programa contin\u00faa con la ejecuci\u00f3n del c\u00f3digo que le sigue al bloque del try-catch.</p> <pre><code>public class TryCatch {\n    public void show(){\n        final String FIN = \"fin\";\n        int base, exponent;\n        String baseString;\n        Scanner keyboard = new Scanner(System.in);\n\n        try{\n            System.out.println(\"Bienvenido al programa para calcular la potencia\");\n            System.out.print(\"Introduce la base o fin para terminar\");\n            baseString = keyboard.nextLine();\n            if(!baseString.equalsIgnoreCase(FIN)){\n                base = Integer.parseInt(baseString);\n                System.out.print(\"Introduce el exponente: \");\n                exponent = keyboard.nextInt();\n                System.out.printf(\"%d elevado a %d es igual a %d\\n\", base, exponent, (int) Math.pow(base, exponent));\n            }\n        } catch (NumberFormatException e){\n            System.out.println(\"Error en la base\");\n        } catch (InputMismatchException e){\n            System.out.println(\"Error en el exponente\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new TryCatch().show();\n    }\n}\n</code></pre> <p>Para  la  base,  si  el  usuario  no  introduce  fin  y  tampoco  introduce  un  n\u00famero  entero,  el <code>Integer.parseInt</code> al  intentar  convertir  la  cadena  a  n\u00famero  lanzar\u00e1  una  excepci\u00f3n  de  tipo <code>NumberFormatException</code> y ser\u00e1 manejada por el catch correspondiente. Para el exponente, si se introduce algo que no sea un n\u00famero (una letra, un s\u00edmbolo...), se producir\u00e1 una excepci\u00f3n de tipo <code>InputMismatchException</code> y se manejar\u00e1 por su correspondiente catch. Si se produce un error de otro tipo, el programa se detendr\u00e1.</p> <p>Puede  ser  que  el  programador  quiera  mostrar  el  mismo  mensaje  de  error  para  ambas excepciones. En este caso se utiliza el multi-catch, incorporado en Java desde la versi\u00f3n 7:</p> <pre><code>public class MultiCatch {\n    public void show(){\n        final String FIN = \"fin\";\n        int base, exponent;\n        String baseString;\n        Scanner keyboard = new Scanner(System.in);\n\n        try{\n            System.out.println(\"Bienvenido al programa para calcular la potencia\");\n            System.out.print(\"Introduce la base o fin para terminar\");\n            baseString = keyboard.nextLine();\n            if(!baseString.equalsIgnoreCase(FIN)){\n                base = Integer.parseInt(baseString);\n                System.out.print(\"Introduce el exponente: \");\n                exponent = keyboard.nextInt();\n                System.out.printf(\"%d elevado a %d es igual a %d\\n\", base, exponent, (int) Math.pow(base, exponent));\n            }\n        } catch (NumberFormatException | InputMismatchException e){\n            System.out.println(\"Error en la base o en el exponente\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new MultiCatch().show();\n    }\n}\n</code></pre> <p>En la programaci\u00f3n de aplicaciones en general siempre ha habido dos formas de manejar una excepci\u00f3n:</p> <ul> <li>Interrupci\u00f3n: en este caso se asume que el programa ha encontrado un error irrecuperable. La operaci\u00f3n que dio lugar a la excepci\u00f3n se anula y se entiendo que no hay manera de regresar al c\u00f3digo que provoc\u00f3 la excepci\u00f3n.</li> <li>Reanudaci\u00f3n: se puede manejar el error y regresar al c\u00f3digo que provoc\u00f3 el error.</li> </ul> <p>La filosof\u00eda de Java es del tipo interrupci\u00f3n, pero se puede intentar emular la reanudaci\u00f3n encerrando el bloque try en un bucle que se repetir\u00e1 hasta que el error deje existir:</p> <pre><code>public class Resumption {\n    public void show(){\n        byte number = 0;\n        Scanner keyboard = new Scanner(System.in);\n        boolean error = false;\n\n        do{\n            try{\n                System.out.print(\"Introduce un n\u00famero de tipo byte, es decir, entre -128 y 127: \");\n                number = keyboard.nextByte();\n                System.out.printf(\"Valor del n\u00famero: %d\\n\", number);\n                error = false; // Si se ha entrado antes en el catch, error est\u00e1 a true\n            } catch (InputMismatchException e){\n                System.out.println(\"Error\");\n                error = true;\n                keyboard.nextLine(); // Limpieza de buffer\n            }\n        } while (error);\n    }\n\n    public static void main(String[] args) {\n        new Resumption().show();\n    }\n}\n</code></pre> <p>Si el usuario introduce cualquier cosa que no sea un n\u00famero, el m\u00e9todo <code>nextByte()</code> lanza la excepci\u00f3n <code>InputMismatchException</code> y lo que ha metido el usuario se queda en el buffer. Para solucionarlo, se realiza una limpieza del buffer con <code>keyboard.nextLine()</code>.</p>"},{"location":"bloque_i/tema_5/page-1/#metodos-de-las-excepciones","title":"M\u00e9todos de las excepciones","text":"<ul> <li>getMessage: obtiene el mensaje descriptivo de la excepci\u00f3n.</li> <li>toString: devuelve una cadena sobre la situaci\u00f3n de la excepci\u00f3n. Suele indicar la clase de excepci\u00f3n y el texto de getMessage.</li> <li>printStackTrace: escribe el m\u00e9todo y mensaje de la excepci\u00f3n (la llamada informaci\u00f3n de pila). El resultado es el mismo mensaje que muestra el ejecutor (la m\u00e1quina virtual de Java) cuando no se controla la excepci\u00f3n.</li> </ul> <pre><code>public class MethodsOfExceptions {\n    public void show(){\n        final String FIN = \"fin\";\n        int base, exponent;\n        String baseString;\n        Scanner keyboard = new Scanner(System.in);\n\n        try{\n            System.out.println(\"Bienvenido al programa para calcular la potencia\");\n            System.out.print(\"Introduce la base o fin para terminar\");\n            baseString = keyboard.nextLine();\n            if(!baseString.equalsIgnoreCase(FIN)){\n                base = Integer.parseInt(baseString);\n                System.out.print(\"Introduce el exponente: \");\n                exponent = keyboard.nextInt();\n                System.out.printf(\"%d elevado a %d es igual a %d\\n\", base, exponent, (int) Math.pow(base, exponent));\n            }\n        } catch (NumberFormatException e){\n            System.out.println(GREEN + e.getMessage() + RESET);\n            System.out.println(CYAN + e + RESET); // e.toString()\n            e.printStackTrace();\n        } catch (InputMismatchException e){\n            System.out.println(GREEN + e.getMessage() + RESET);\n            System.out.println(CYAN + e + RESET); // e.toString()\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new MethodsOfExceptions().show();\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-1/#cuando-se-debe-capturar-una-excepcion","title":"Cuando se debe capturar una excepci\u00f3n","text":"<p>Una excepci\u00f3n se debe capturar cuando no sea un error de programaci\u00f3n, es decir, el programador debe distinguir si esa excepci\u00f3n es un error suyo de programaci\u00f3n o no, poeque si es un error de programaci\u00f3n, no debe capturar el error sino solucionarlo.</p> <p>Por ejemplo, cuando se intenta acceder a una parte de la cadena que no existe, por ejemplo, si la cadena hola le hacemos charAt(4), Java nos lanza la excepci\u00f3n StringIndexOutOfBoundsException. El programador no debe capturar con un try-catch, sino que debe corregir el error de programaci\u00f3n que ha producido dicha excepci\u00f3n.</p>"},{"location":"bloque_i/tema_5/page-2/","title":"2 Throws, throws y finally","text":""},{"location":"bloque_i/tema_5/page-2/#tipos-de-excepciones","title":"Tipos de excepciones","text":"<p>En Java, la herencia define una relaci\u00f3n entre clases en la cual una clase posee caracter\u00edsticas (m\u00e9todos y propiedades) que proceden de otra. A la clase que posee las caracter\u00edsticas a heredar se la llama superclase o clase padre y la clase que las hereda se llama subclase o clase hija. Lo beneficioso de este tipo de relaciones es que los hijos pueden heredar las caracter\u00edsticas de los padres y luego aportar caracter\u00edsticas propias convirti\u00e9ndose en una manera de reutilizar c\u00f3digo muy eficiente.</p> <p>Java  utiliza  much\u00edsimo  la  herencia  en  las  clases  que  conforman  su  API.  En  cuanto  a  las excepciones se refiere, existen tres tipos de excepciones que Java maneja a trav\u00e9s de la herencia: errores,  comprobadas  (checked)  y  no  comprobadas  (unchecked).  El  gr\u00e1fico  que  se  muestra  a continuaci\u00f3n muestra el \u00e1rbol de herencia de las excepciones en Java. El paquete de todas es java.lang:</p> <pre><code>classDiagram\n    Throwable &lt;|-- Error\n    Throwable &lt;|-- Exception\n    Error &lt;|-- Error Exception\n    Exception &lt;|-- OtrasExceptions\n    Exception &lt;|-- RuntimeExceptions\n    RuntimeExceptions &lt;|-- OtrasRuntimeExceptions</code></pre> <p>La clase principal de la cual heredan todas las excepciones Java es Throwable. De ella nacen dos ramas: Error y Exception. Error representa errores de una magnitud tal que una aplicaci\u00f3n nunca deber\u00eda intentar realizar nada con ellos (como errores de la JVM, desbordamientos de buffer, etc). La segunda rama, encabezada por Exception, representa aquellos errores que normalmente s\u00ed solemos gestionar, y a los que com\u00fanmente solemos llamar excepciones.</p> <p>De  Exception  nacen  m\u00faltiples  ramas:  ClassNotFoundException,  IOException,  ParseException, SQLException y otras  muchas,  todas  ellas  de  tipo  checked.  La  \u00fanica  excepci\u00f3n  es RuntimeException que es de tipo unchecked y encabeza todas las de este tipo.</p>"},{"location":"bloque_i/tema_5/page-2/#excepciones-checked","title":"Excepciones checked","text":"<p>Una  excepci\u00f3n  de  tipo  checked  representa  un  error  del  cual  t\u00e9cnicamente  podemos recuperarnos. En ciertos momentos, a pesar de la promesa de recuperabilidad, nuestro c\u00f3digo no  estar\u00e1  preparado  para  gestionar  la  situaci\u00f3n  de  error,  o  simplemente  no  ser\u00e1  su responsabilidad. En estos casos lo m\u00e1s razonable es relanzar la excepci\u00f3n y confiar en que un m\u00e9todo superior en la cadena de llamadas sepa gestionarla.</p> <p>Por  tanto,  todas  las  excepciones  de  tipo  checked  deben  ser  capturadas  o  relanzadas.  En  el primer caso, utilizamos el bloque try-catch. En caso de querer relanzar la excepci\u00f3n, debemos declarar dicha intenci\u00f3n en la firma de la funci\u00f3n que contiene las sentencias que lanzan la excepci\u00f3n, y lo hacemos mediante la clausula throws.</p> <p>Hay que tener presente que cuando se relanza una excepci\u00f3n estamos forzando al c\u00f3digo cliente de nuestro m\u00e9todo a capturarla o relanzarla. Una excepci\u00f3n que sea relanzada una y otra vez hacia arriba terminar\u00e1 llegando al m\u00e9todo primigenio y, en caso de no ser capturada por \u00e9ste, producir\u00e1 la finalizaci\u00f3n de su hilo de ejecuci\u00f3n (thread).</p> <p>La  dos  preguntas  que  debemos  hacernos  en  este  momento  es:  \u00bfCu\u00e1ndo  capturar  una excepci\u00f3n? \u00bfCu\u00e1ndo relanzarla? La respuesta es muy simple. Capturamos una excepci\u00f3n cuando: - - Podemos recuperarnos del error y continuar con la ejecuci\u00f3n.</p> <ul> <li>Queremos registrar el error.</li> <li>Queremos relanzar el error con un tipo de excepci\u00f3n distinto.</li> </ul> <p>En  definitiva,  cuando  tenemos  que  realizar  alg\u00fan  tratamiento  del  propio  error.  Por  contra, relanzamos una excepci\u00f3n cuando:</p> <ul> <li>No es competencia nuestra ning\u00fan tratamiento de ning\u00fan tipo sobre el error que se ha producido.</li> <li>Para centralizar el control de excepciones y facilitar el mantenimiento del c\u00f3digo.</li> </ul>"},{"location":"bloque_i/tema_5/page-2/#excepciones-unchecked","title":"Excepciones unchecked","text":"<p>Son excepciones de tipo RuntimeException o de cualquiera de sus subclases. El aspecto m\u00e1s destacado de las excepciones de tipo unchecked es que no deben ser forzosamente declaradas ni capturadas (en otras palabras, no son comprobadas). Por ello no son necesarios bloques try-catch ni declarar formalmente en la firma de la funci\u00f3n el lanzamiento de excepciones de este tipo. \u00c9sto, por supuesto, tambi\u00e9n afecta a funciones y/o clases m\u00e1s hacia arriba en la cadena invocante.</p>"},{"location":"bloque_i/tema_5/page-2/#throws","title":"Throws","text":"<p>En caso de querer relanzar la excepci\u00f3n, debemos declarar dicha intenci\u00f3n en la firma de la funci\u00f3n que contiene las sentencias que lanzan la excepci\u00f3n, y lo hacemos mediante la clausula throws.</p> <p>\u00bfTiene obligaci\u00f3n de tener un try-catch el que llame a la funci\u00f3n? Si la excepci\u00f3n es de tipo RuntimeException o cualquiera de sus hijas, no existe la obligaci\u00f3n de poner un try-catch. En cualquier  otro  caso,  s\u00ed  existe  dicha  obligaci\u00f3n,  de  hecho  si  no  se  hace,  Java  da  un  error  de compilaci\u00f3n.</p> <pre><code>public class Throws {\n    public void show(){\n        final String FIN = \"fin\", SIGUIENTE = \"siguiente\";\n        int number;\n        String string;\n        Scanner keyboard = new Scanner(System.in);\n\n        try{\n            System.out.print(\"Introduce un n\u00famero o siguiente para pasar al siguiente n\u00famero: \");\n            string = keyboard.nextLine();\n\n            if(!string.equalsIgnoreCase(SIGUIENTE)){\n                /*\n                 * Aqu\u00ed no estamos obligados a poner un try-catch porque\n                 * NumberFormatException es hija de RuntimeException\n                 */\n                number = convertirNumero(string);\n                System.out.printf(\"Valor del n\u00famero introducido: %d\\n\", number);\n            }\n        } catch (NumberFormatException e){\n            System.out.println(\"Error en el n\u00famero\");\n        }\n\n        try {\n            System.out.print(\"Introduce un n\u00famero o fin para terminar: \");\n            string = keyboard.nextLine();\n\n            if(!string.equalsIgnoreCase(FIN)){\n                /*\n                 * Aqu\u00ed estamos obligados a poner un try-catch porque\n                 * Exception no es hija de RuntimeException\n                 */\n                number = convertirNumero2(string);\n                System.out.printf(\"Valor del n\u00famero introducido: %d\\n\", number);\n            }\n        } catch (Exception e){\n            System.out.println(\"Error en el n\u00famero\");\n        }\n    }\n\n    private int convertirNumero2(String string) {\n        return Integer.parseInt(string);\n    }\n\n    private int convertirNumero(String string) throws NumberFormatException {\n        return Integer.parseInt(string);\n    }\n\n    public static void main(String[] args) {\n        new Throws().show();\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-2/#orden-de-los-catch","title":"Orden de los catch","text":"<p>Cuando se tienen varios catch para el mismo try, hay que tener la precauci\u00f3n de poner los catch de las subclases antes que los de las superclases porque si no, los catch de las subclases nunca se capturar\u00edan. Ejemplo:</p> <pre><code>public class CatchOrder1 {\n    public void show(){\n        final String FIN = \"fin\";\n        String string;\n        byte number = 0;\n        Scanner keyboard = new Scanner(System.in);\n\n        try {\n            System.out.print(\"Introduce un n\u00famero de tipo byte, es decir, entre -128 y 127: \");\n            number = keyboard.nextByte();\n            keyboard.nextLine(); //Limpieza del buffer\n            System.out.printf(\"Valor del n\u00famero introducido: %d\\n\", number);\n            System.out.print(\"Introduzca otro n\u00famero de tipo byte o fin para terminar: \");\n            string = keyboard.nextLine();\n            if (!string.equalsIgnoreCase(FIN)) {\n                number = Byte.parseByte(string);\n                System.out.printf(\"Valor del otro n\u00famero introducido: %d\\n\", number);\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error: no ha introducido un n\u00famero entre -128 y 127\");\n        } catch (InputMismatchException e) { //Error de compilaci\u00f3n:inalcanzable bloque catch\n            System.out.println(\"Error\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new CatchOrder1().show();\n    }\n}\n</code></pre> <p>En  este  caso,  Java  da  un  error  de  compilaci\u00f3n  ya  que  InputMismatchException  es  hija  de Exception. Si el usuario no introduce un n\u00famero de tipo byte, se lanza una excepci\u00f3n de tipo InputMismatchException.  Dicho  objeto  tambi\u00e9n  es  un  objeto  de  tipo  Exception,  ya  que  los objetos de tipo hijo, tambi\u00e9n son objetos de tipo padre.  Entonces, nunca entrar\u00eda en el catch del InputMismatchException. La soluci\u00f3n es cambiar el orden de los catch:</p> <pre><code>public class CatchOrder2 {\n    public void show(){\n        final String FIN = \"fin\";\n        String string;\n        byte number = 0;\n        Scanner keyboard = new Scanner(System.in);\n\n        try {\n            System.out.print(\"Introduce un n\u00famero de tipo byte, es decir, entre -128 y 127: \");\n            number = keyboard.nextByte();\n            keyboard.nextLine(); //Limpieza del buffer\n            System.out.printf(\"Valor del n\u00famero introducido: %d\\n\", number);\n            System.out.print(\"Introduzca otro n\u00famero de tipo byte o fin para terminar: \");\n            string = keyboard.nextLine();\n            if (!string.equalsIgnoreCase(FIN)) {\n                number = Byte.parseByte(string);\n                System.out.printf(\"Valor del otro n\u00famero introducido: %d\\n\",\n                        number);\n            }\n        } catch (InputMismatchException e) {\n            System.out.println(\"Error: no ha introducido un n\u00famero entre -128 y 127\");\n        } catch (Exception e) {\n            System.out.println(\"Error\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new CatchOrder2().show();\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-2/#throw","title":"Throw","text":"<p>Esta instrucci\u00f3n le permite al programador lanzar una excepci\u00f3n. Por ejemplo: <code>throw new Exception();</code>. El flujo del programa se dirigir\u00e1 a la instrucci\u00f3n try-catch m\u00e1s cercana.</p> <p>Se pueden utilizar constructores en esta llamada (el formato de los constructores depende de la clase que se utilice): <code>throw new Exception(\"Error grave\");</code> Esto construye una excepci\u00f3n con el mensaje indicado. Ese mensaje se puede obtener en el catch con el m\u00e9todo <code>getMessage()</code> del objeto que contiene la excepci\u00f3n.</p> <pre><code>public class Throw {\n    public void show() {\n        double n;\n        Scanner keyboard = new Scanner(System.in);\n        try {\n            System.out.println(\"Introduce un n\u00famero: \");\n            n = keyboard.nextDouble();\n            division(n);\n        } catch (ArithmeticException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public void division(double n) {\n        /*\n         * float y double admiten Infinity por lo que no se lanza\n         * una excepci\u00f3n cuando se divide entre cero.\n         * Podemos lanzar la excepci\u00f3n usando throw\n         * */\n        if (n == 0) {\n            throw new ArithmeticException(\"Error: no se puede dividir entre cero\");\n        }\n        System.out.printf(\"500 entre %.2f: %.2f\\n\", n, 500 / n);\n    }\n    public static void main(String[] args) {\n        new Throw().show();\n    }\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-2/#finally","title":"Finally","text":"<p>Las instrucciones que se encuentran en el finally se ejecutan independientemente de si hubo o no excepci\u00f3n. Es decir, esas sentencias se ejecutan siempre. Si el c\u00f3digo del try ha ido bien y no se ha lanzado ninguna excepci\u00f3n, despu\u00e9s se ejecutan las instrucciones del finally y luego se contin\u00faa  por  el  c\u00f3digo  que  le  sigue  al  bloque  del  try-catch.  Pero  si  se  ha  lanzado  alguna excepci\u00f3n,  se  ejecutan  las  instrucciones  del  catch  correspondiente,  luego  se  ejecutan  las instrucciones del finally y luego se contin\u00faa por el c\u00f3digo que le sigue al bloque del try-catch. Por ello se coloca en el bloque finally c\u00f3digo com\u00fan para todas las excepciones y tambi\u00e9n para cuando no hay excepciones. Normalmente se suelen poner instrucciones de limpieza. Ejemplo:</p> <pre><code>public class Finally {\n    public void show() {\n        int number = 0;\n        String string;\n        boolean error = false;\n        Scanner keyboard = new Scanner(System.in);\n        try {\n            System.out.print(\"Introduce un n\u00famero: \");\n            number = keyboard.nextInt();\n        } catch (InputMismatchException e) {\n            System.out.println(\"Error\");\n            error = true;\n        } finally {\n            keyboard.nextLine();//Limpieza del buffer\n        }\n        System.out.print(\"Introduce una cadena: \");\n        string = keyboard.nextLine();\n        System.out.printf(\"El n\u00famero introducido ha sido: %s\\n\", error ? \"error\" : number);\n        System.out.printf(\"La cadena introducida ha sido: %s\", string);\n    }\n    public static void main(String[] args) {\n        new Finally().show();\n    }\n}\n</code></pre> <p>En el ejemplo, hay que limpiar el buffer haya o no una excepci\u00f3n, por lo tanto, se limpia en el finally.</p> <p>Pero \u00bfqu\u00e9 diferencia hay entre poner c\u00f3digo en el finally o ponerlo despu\u00e9s del bloque try-catch? Pues que en el finally siempre se va a ejecutar aunque se rompa el flujo de ejecuci\u00f3n, es decir, aunque exista por ejemplo un  <code>return</code>  en el try  o  un  <code>throw</code>   en  el  catch.  El  c\u00f3digo  que  se encuentre despu\u00e9s del bloque try-catch, no se ejecutar\u00eda en esos casos</p>"},{"location":"bloque_i/tema_5/page-3/","title":"Ejercicios","text":"Ejercicio 1 <p>Escribe un programa que juegue con el usuario a adivinar un n\u00famero. El ordenador debe generar un n\u00famero entre 1 y 500, y el usuario tiene que intentar adivinarlo. Para ello, cada vez que el usuario introduce un valor, el ordenador debe decirle al usuario si el n\u00famero que tiene  que adivinar es mayor o menor que el que ha introducido el usuario. Cuando consiga adivinarlo, debe indic\u00e1rselo e imprimir en pantalla el n\u00famero de veces que el usuario ha intentado adivinar el n\u00famero. Si el usuario introduce algo que no es un n\u00famero, debe indicarlo en pantalla, y contarlo como un intento.</p> Ejercicio 2 <p>Crea un m\u00e9todo que se llame readInt() que se encargue de leer un n\u00famero introducido por teclado teniendo en cuentas las excepciones que puede provocar. Crea un main para probarlo.</p>"},{"location":"bloque_i/tema_5/page-4/","title":"Proyecto","text":"<p>Se va a continuar el proyecto que contiene una librer\u00eda con m\u00e9todos y clases \u00fatiles para facilitar ciertas operaciones.</p> <p>En esta versi\u00f3n, se crear\u00e1 una clase ConsoleInput que trabajar\u00e1 con m\u00e9todos para facilitar la lectura por teclado.</p> <p>La clase contendr\u00e1 una serie de m\u00e9todos que permitan solicitar al usuario distintos datos y que gestionen el hecho de que los datos introducidos no correspondan a los tipos esperados o que no sean valores v\u00e1lidos, de  manera que se les vuelva a solicitar de nuevo, hasta que los valores introducidos sean v\u00e1lidos. Internamente un m\u00e9todo puede llamar a otro m\u00e9todo de la clase.</p> <p>Info</p> <p>SE PODR\u00c1N CREAR ADEM\u00c1S LOS M\u00c9TODOS Y ATRIBUTOS QUE SE CONSIDEREN NECESARIOS</p> <p>\u00a1OJO!</p> <p>Se deber\u00e1 de tratar con minuciosidad todas las posibilidades haciendo uso de estructuras de control de excepciones.</p> <p>Los m\u00e9todos que aparecen a continuaci\u00f3n se refieren al tipo byte. Realizarlos tambi\u00e9n para los tipos short, int,long, float y double:</p> <ul> <li><code>readByte()</code>: retorna un byte introducido por el usuario.</li> <li><code>readByteUnsigned()</code>: lo mismo que el anterior, pero n\u00fameros sin signos.</li> <li><code>readByteLessThan(byte upperBound)</code>: retorna un byte introducido por el usuario inferior al par\u00e1metro.</li> <li><code>readByteUnsignedLessThan(byte upperBound)</code>: lo mismo que el anterior, pero n\u00fameros sin signos.</li> <li><code>readByteLessOrEqualThan(byte upperBound)</code>: retorna un byte introducido por el usuario inferior igual al par\u00e1metro.</li> <li><code>readByteUnsignedLessOrEqualThan(byte upperBound)</code>: lo mismo que el anterior, pero n\u00fameros sin signos</li> <li><code>readByteGreaterThan(byte lowerBound)</code>: retorna un byte introducido por el usuario superior al par\u00e1metro.</li> <li><code>readByteUnsignedGreaterThan(byte lowerBound)</code>: lo mismo que el anterior, pero n\u00fameros sin signos.</li> <li><code>readByteGreaterOrEqualThan(byte lowerBound)</code>: retorna un byte introducido por el usuario superior o igual al par\u00e1metro.</li> <li><code>readByteUnsignedGreaterOrEqualThan(byte lowerBound)</code>: Lo mismo que el anterior, pero n\u00fameros sin signos.</li> <li><code>readByteInRangeInclusive(byte lowerBound, byte upperBound)</code>: retorna un byte introducido por el usuario cuyo valor est\u00e9 en el rango [lowerBound, upperBound], ambos incluidos.</li> <li><code>readByteInRangeExclusive(byte lowerBound, byte upperBound)</code>: retorna un byte introducido por  el usuario cuyo valor est\u00e9 en el rango [lowerBound, upperBound], donde upperBound no est\u00e9 incluido.</li> </ul> <p>Adem\u00e1s, realizar los m\u00e9todos siguientes:</p> <ul> <li><code>readChar()</code>: retorna un car\u00e1cter introducido por el usuario. Si \u00e9ste introduce m\u00e1s de un car\u00e1cter, se le vuelve a solicitar.</li> <li><code>readChar(String validCharacters)</code>: retorna un car\u00e1cter introducido por el usuario. El par\u00e1metro validCharacters contiene los posibles caracteres v\u00e1lidos.</li> <li><code>readVowel()</code>: retorna una vocal introducida por el usuario.</li> <li><code>readDigit()</code>: retorna un car\u00e1cter d\u00edgito introducido por el usuario.</li> <li><code>readConsonant()</code>: retorna una consonante introducida por el usuario.</li> <li><code>readLowerCase()</code>: retorna una letra min\u00fascula introducida por el usuario.</li> <li><code>readUpperCase()</code>: retorna una letra may\u00fascula introducida por el usuario.</li> <li><code>readString()</code>: retorna una cadena de caracteres introducida por el usuario.</li> <li><code>readString(int maxLength)</code>: retorna una cadena de caracteres de como m\u00e1ximo maxLength caracteres.</li> <li><code>readBooleanUsingChar(char affirmativeValue)</code>: retorna un booleano a partir de un car\u00e1cter introducido por el usuario, de manera que si coincide con affirmativeValue (en may\u00fasculas o min\u00fasculas) retornar\u00e1 true, y si se trata de cualquier otro car\u00e1cter retornar\u00e1 false.</li> <li><code>readBooleanUsingChar()</code>: retorna un booleano a partir de un car\u00e1cter introducido por el usuario, de manera que si coincide con s o S retornar\u00e1 true y en caso contrario retornar\u00e1 false.</li> <li><code>readBooleanUsingInt(int affirmativeValue)</code>: retorna un booleano a partir de un entero introducido por el usuario, de manera que si coincide con el valor proporcionado retornar\u00e1 true, y si se trata de cualquier otro valor entero retornar\u00e1 false.</li> <li><code>readBooleanUsingInt()</code>: retorna un booleano a partir de un entero introducido por el usuario, de manera que si coincide con 1 retornar\u00e1 true, y si se trata de cualquier otro valor entero retornar\u00e1 false.</li> </ul> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ol> <li>NO se realizar\u00e1 una versi\u00f3n sobre el proyecto 3, sino que se realizar\u00e1 un copia de dicho proyecto en esta versi\u00f3n</li> <li>Se mantendr\u00e1 el paquete principal llamado <code>com.NOMBRE.common</code> donde nombre ser\u00e1 el nombre del alumno y common el nombre del proyecto.</li> <li>Se crear\u00e1 una clase Main, donde se ponga en pr\u00e1ctica los usos de la librer\u00eda y se valorar\u00e1 la complejidad de dicho Main.</li> <li>Se deber\u00e1n respetar el nombre de las funciones as\u00ed como el nombre de los par\u00e1metros.</li> <li>El nombre del resto de funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre <code>pr05java-NOMBRE-console</code>siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ol>"},{"location":"bloque_ii/tema_10/page-1/","title":"10.1 Introducci\u00f3n a los Gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-1/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Se trata de la implementaci\u00f3n en Java de una de las opciones de C++ m\u00e1s a\u00f1oradas por los programadores que proceden de ese lenguaje; las plantillas (templates). Son similares a las plantillas de C++. Sirven para evitar conversiones de clases.</p> <p>Uno de los motivos de la creaci\u00f3n de los gen\u00e9ricos fueron las colecciones. Sin los gen\u00e9ricos todas las colecciones ser\u00edan de tipo Object, lo que tendr\u00eda una serie de desventajas:</p> <ul> <li>Nada impide crear listas heterog\u00e9neas de objetos. Eso causa problemas evidentes de casting, adem\u00e1s de imposible incoherencias.</li> <li>Si se desea acceder a propiedades espec\u00edficas de otro tipo de clases, ser\u00e1 necesario realizar una cantidad grande de conversiones en el c\u00f3digo, lo que har\u00e1 que sea m\u00e1s pesado de comprender.</li> <li>Los m\u00e9todos de las clases e interfaces de las colecciones no se adaptan al tipo de datos que contienen dificultando su uso.</li> </ul> <p>Por ello aparecieron los tipos gen\u00e9ricos en la versi\u00f3n 1.5 de Java consiguiendo solucionar los problemas anteriores en las colecciones.</p>"},{"location":"bloque_ii/tema_10/page-1/#2-idea-general-de-los-genericos","title":"2. Idea general de los gen\u00e9ricos","text":"<p>Los gen\u00e9ricos permiten crear clases y m\u00e9todos en los que los tipos de datos (las clases) sobre los que act\u00faan son un par\u00e1metro m\u00e1s. Gracias a ello se pueden crear clases y m\u00e9todos que se adaptan a distintos tipos de datos de forma autom\u00e1tica.</p> <p>Anteriormente a la aparici\u00f3n de los gen\u00e9ricos el que las clases y m\u00e9todos se adaptaran autom\u00e1ticamente pasaba por especificar par\u00e1metros de tipo Object, ya que las referencias de tipo Object valen para cualquier otro tipo de objeto.</p> <p>El problema es que la coherencia no est\u00e1 asegurada con los tipos Object, la sintaxis del lenguaje puede provocar excepciones de tipo ClassCastException ante conversiones err\u00f3neas de Object a otro tipo de datos.</p> <p>La idea es:</p> <ol> <li>El programar declara un gen\u00e9rico en un m\u00e9todo de clase, por ejemplo T</li> <li>Cuando se utilice dicha clase o m\u00e9todo se indicar\u00e1 un tipo concreto, entonces se cambia el gen\u00e9rico para que se refiera a ese tipo concreto.</li> </ol>"},{"location":"bloque_ii/tema_10/page-2/","title":"10.2 Uso de gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-2/#1-genericos-en-metodos","title":"1. Gen\u00e9ricos en m\u00e9todos","text":"<p>Se pueden indicar gen\u00e9ricos en los m\u00e9todos. Para indicar que el m\u00e9todo se puede utilizar con cualquier tipo de objeto y que el m\u00e9todo se adaptar\u00e1 a dicho tipo. La sintaxis es: <code>modificadores &lt;Gen\u00e9rico&gt; tipoRetorno nombreM\u00e9todo(...)</code></p> <p>Ejemplo:</p> <pre><code>public class ArrayUtils{\n    public static &lt;T&gt; T getRandom(T a[]){\n        int i = new Random().nexInt(a.length-1);\n        return a[i];\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se desea obtener un elemento aleatorio de un array. En el ejemplo la letra T entre los signos &lt; y &gt; indica que se va a utilizar un tipo gen\u00e9rico, el hecho de que le siga otra T significa que el tipo que devuelve el m\u00e9todo tomarAleatorio ser\u00e1 el mismo que el del par\u00e1metro a, y se corresponder\u00e1 al tipo gen\u00e9rico T. Despu\u00e9s cuando se invoque a este m\u00e9todo, la letra gen\u00e9rica T ser\u00e1 traducida por el tipo con el que se invoque al m\u00e9todo. Por ejemplo desde este c\u00f3digo:</p> <pre><code>String a[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString element = ArraysUtils.getRandom(a);\nSystem.out.println(element);\n</code></pre> <p>En ese c\u00f3digo, como se invoca usando un array de Strings, por lo tanto la letra gen\u00e9rica T ser\u00e1 traducida por String. Es decir es como si el c\u00f3digo anterior se tradujera como:</p> <pre><code>public class UtilesArrays {\n    public static String tomarAleatorio(String a[]){\n        int i=(int)(Math.random()*a.length);\n        return a[i];\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#2-genericos-en-las-clases","title":"2. Gen\u00e9ricos en las clases","text":"<p>El m\u00e9todo habitual de utilizar gen\u00e9ricos, debido a su mayor potencia, es declarar el gen\u00e9rico en una clase. De esta forma indicados que el c\u00f3digo de la clase utiliza tipos gen\u00e9ricos que ser\u00e1n traducidos por el tipo de datos que se desee.</p> <p>Por ejemplo una clase pensada para extraer elementos aleatorios de un array del tipo que sea se podr\u00eda declarar as\u00ed:</p> <pre><code>public class RandomElement&lt;T&gt; {\n    private final T element;\n\n    public RandomElement(T[] array){\n        element = array[new Random().nextInt(array.length - 1)];\n    }\n\n    public T getElement(){\n        return element;\n    }\n}\n</code></pre> <p>Los tipos se indican tras el nombre de la clase. De esta forma cuando se creen objetos de clase RandomElement habr\u00e1 que indicar la clase por la que se traducir\u00e1 el gen\u00e9rico T. Por ejemplo:</p> <pre><code>public static void main(String[] args) {\n    String[] a = {\"uno\", \"dos\", \"tres\", \"cuatro\"};\n    RandomElement&lt;String&gt; e = new RandomElement&lt;String&gt;(a);\n\n    System.out.println(e.getElement());\n}\n</code></pre> <p>Obs\u00e9rvese que tanto al declarar el objeto e hay que concretar el valor del gen\u00e9rico de ah\u00ed que la declaraci\u00f3n sea <code>RandomElement&lt;String&gt; e</code> de ese modo ya queda claro la traducci\u00f3n de <code>T</code>. A partir de ese momento ya todos los m\u00e9todos de clase y propiedades que utilizaran el gen\u00e9rico <code>T</code>, ahora utilizar\u00e1n el tipo <code>String</code>. En definitiva los gen\u00e9ricos de clase marcan las posiciones para la clase concreta que habr\u00e1 que especificar en la creaci\u00f3n del objeto. Lo bueno es que pueden convivir distintas concreciones de gen\u00e9ricos, podr\u00eda ser:</p> <pre><code>RandomElement&lt;String&gt; e1 = new RandomElement&lt;String&gt;(a1);\nRandomElement&lt;Integer&gt; e2 = new RandomElement&lt;Integer&gt;(a2);\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#3-interfaces-con-genericos","title":"3. Interfaces con gen\u00e9ricos","text":"<p>Al igual que las clases, las interfaces pueden utilizar gen\u00e9ricos en las mismas condiciones que en \u00e9stas:</p> <pre><code>public interface Comparable&lt;T&gt;{\n    T lower();\n    T upper();\n}\n</code></pre> <p>Una clase que implemente la interfaz puede hacerlo as\u00ed:</p> <pre><code>public class Clase1 implements Compar&lt;String&gt;{\n</code></pre> <p>De modo que traduce el gen\u00e9rico de la interfaz por un tipo concreto o bien:</p> <pre><code>public class Clase1 &lt;T&gt; implements Compar&lt;T&gt;{\n</code></pre> <p>De modo que no traduce el gen\u00e9rico y espera a que durante la creaci\u00f3n de objetos de esa clase se indique el tipo concreto para el gen\u00e9rico.</p>"},{"location":"bloque_ii/tema_10/page-2/#4-uso-de-varios-genericos","title":"4. Uso de varios gen\u00e9ricos","text":"<p>Tanto en m\u00e9todos, como en clases o interfaces, es posible utilizar dos tipos gen\u00e9ricos e incluso m\u00e1s. Para ello se separan por comas dentro del operador diamante. Ejemplo:</p> <pre><code>public class CompareObjects&lt;T, U&gt;{\n    protected T object1;\n    protected U object2;\n\n    public CompareObjects(T object1, U object2){\n        this.object1 = object1;\n        this.object2 = object2;\n    }\n\n    public boolean sameFirstLetter(){\n        String letter1 = object1.getClass().getName().substring(1,1);\n        String letter2 = object2.getClass().getName().substring(1,1);\n        return letter1.equalsIgnoreCase(letter2);\n    }\n}\n</code></pre> <p>Esta clase (que en realidad no es muy \u00fatil), construye un objeto a partir de otros dos. El primero de tipo gen\u00e9rico <code>T</code>, y el segundo de tipo <code>U</code>. El m\u00e9todo <code>sameFirstLetter</code> devuelve verdadero si el nombre de clase de <code>T</code> empieza por la misma letra que <code>U</code>.</p> <p>Para utilizar esta clase:</p> <pre><code>public static void main(String[] args){\n    String s1 = \"Hola\";\n    StringBuffer s2 = new StringBuffer(\"Adi\u00f3s\");\n    CompareObjects&lt;String, StringBuffer&gt; comp = new CompareObjects&lt;String, StringBuffer&gt;(s1,s2);\n\n    System.out.println(comp.sameFirstLetter());\n}\n</code></pre> <p>Devolver\u00e1 verdadero porque tanto <code>String</code> como <code>StringBuffer</code> empiezan por <code>S</code>. En el ejemplo <code>T</code> se convertir\u00e1 en String y <code>U</code> en <code>StringBuffer</code>.</p>"},{"location":"bloque_ii/tema_10/page-3/","title":"10.3 Gen\u00e9ricos avanzados","text":""},{"location":"bloque_ii/tema_10/page-3/#limitacion-de-los-tipos-posibles-en-un-generico","title":"Limitaci\u00f3n de los tipos posibles en un gen\u00e9rico","text":"<p>A veces no interesa que las clases acepten a cualquier tipo de objeto, sino a objetos de un determinado tipo y sus descendientes. Eso es posible indicarlo mediante la palabra <code>extends</code> dentro de la declaraci\u00f3n del gen\u00e9rico. Ejemplo:</p> <pre><code>public class HandlerVehicle &lt;V extends Vehicle&gt;{\n    protected V vehicle;\n    public HandlerVehicle(V vehicle){\n        this.vehicle = vehicle;\n    }\n\n    public void start(){\n        vehicle.accelerate(100);\n    }\n}\n</code></pre> <p>En el ejemplo, a la clase se le puede indicar cualquier clase descendiente de <code>Vehicle</code>, pero ninguna otra. Por ejemplo:</p> <pre><code>HandlerVehicle&lt;Car&gt; v1 = new HandlerVehicle&lt;Car&gt;();\nHandlerVehicle&lt;Autocar&gt; v2 = new HandlerVehicle&lt;Autocar&gt;\n</code></pre> <p>Sin embargo, no se podr\u00eda declarar:</p> <pre><code>HandlerVehicle&lt;String&gt; v3 = HandlerVehicle&lt;String&gt;(e);\n</code></pre> <p>No es posible porque la clase String no es heredera de ning\u00fan veh\u00edculo. La raz\u00f3n de utilizar esta cl\u00e1usula tan restrictiva est\u00e1 en el hecho de poder realizar acciones que sabemos que s\u00f3lo son posibles en cierto tipo de objetos. La clase <code>HandlerVehicle</code> necesita arrancar el veh\u00edculo, por ello tenemos que asegurar que el gen\u00e9rico no puede ser ninguna clase incompatible.</p> <p>Por otro lado extends no tiene por qu\u00e9 referirse a clases, tambi\u00e9n puede referirse a interfaces. Ejemplo:</p> <pre><code>public class Clase1 &lt;V extends Comparable&gt;{\n</code></pre> <p>Significa que la Clase1 usa un gen\u00e9rico al que se le puede asignar cualquier clase que implemente la interfaz Comparable.</p>"},{"location":"bloque_ii/tema_10/page-3/#tipos-comodin","title":"Tipos comod\u00edn","text":"<p>Aunque parece que todo est\u00e1 resuelto de esta forma. Hay problemas cuando mezclamos objetos de la misma clase pero distinta traducci\u00f3n de gen\u00e9rico. Es el caso de este ejemplo:</p> <pre><code>public class RandomElement&lt;T&gt; {\n    private final T element;\n    private final int index;\n\n    public RandomElement(T[] array){\n        index = new Random().nextInt(array.length - 1);\n        element = array[index];\n    }\n\n    public T getElement(){\n        return element;\n    }\n\n    public static void main(String[] args) {\n        String[] a = {\"uno\", \"dos\", \"tres\", \"cuatro\"};\n        RandomElement&lt;String&gt; e = new RandomElement&lt;String&gt;(a);\n\n        System.out.println(e.getElement());\n    }\n\n    public int getIndex(){\n        return index;\n    }\n\n    public boolean sameIndex(RandomElement&lt;T&gt; random){\n        return random.index == index;\n    }\n}\n</code></pre> <p>En este caso la clase RandomElement se le ha a\u00f1adido una propiedad que almacena el \u00edndice aleatorio que obtiene el constructor. Eso permite que construyamos un m\u00e9todo llamado <code>sameIndex</code> que recibe un objeto de clase RandomElement y nos dice si el \u00edndice aleatorio calculado fue el mismo. Para usar este m\u00e9todo:</p> <pre><code>String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString[] s2 = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"};\n\nRandomElement&lt;String&gt; r1 = new RandomElement&lt;String&gt;(s1);\nRandomElement&lt;String&gt; r2 = new RandomElement&lt;String&gt;(s2);\n\nSystem.out.println(r1.sameIndex(r2));\n</code></pre> <p>El c\u00f3digo funciona, s\u00f3lo devolver\u00e1 verdadero si tanto el objeto <code>r1</code> como en <code>r2</code>, el \u00edndice tiene el mismo valor. Sin embargo, este otro c\u00f3digo fallara:</p> <pre><code>String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nInteger[] s2 = {1,2,3,4,5,6};\nRandomElement&lt;String&gt; r1 = new RandomElement&lt;String&gt;(s1);\nRandomElement&lt;Integer&gt; r2 = new RandomElement&lt;Integer&gt;(s2);\n\nSystem.out.println(r1.sameIndex(r2));\n</code></pre> <p>El error ocurre en tiempo de compilaci\u00f3n. La raz\u00f3n, que en la l\u00ednea remarcada, el objeto <code>r1</code> es ya de tipo <code>RandomElement&lt;String&gt;</code> por lo que el m\u00e9todo <code>sameIndex</code> s\u00f3lo puede aceptar objetos de tipo <code>RandomElement&lt;String&gt;</code>, ya que el gen\u00e9rico T se tradujo como STring. El problema est\u00e1 en que dicho m\u00e9todo tiene que poder aceptar cualquier tipo de objeto de tipo <code>RandomElement</code>.</p> <p>Para ello se usa el signo <code>&lt;?&gt;</code> de ese modo indicamos la posibilidad de aceptar cualquier tipo de clase con gen\u00e9rico. Es decir el m\u00e9todo se reescribir\u00eda as\u00ed:</p> <pre><code>public boolean sameIndex(RandomElement&lt;?&gt; random){\n    return random.getIndex() == index;\n}\n</code></pre> <p>De esa forma se indica que random es un objeto de tipo <code>RandomElement</code> tenga el tipo que tenga el gen\u00e9rico.</p> <p>Incluso se puede delimitar el gen\u00e9ricos:</p> <pre><code>public boolean sameIndex(RandomElement&lt;? extends Number&gt; random){\n    return random.getIndex() == index;\n}\n</code></pre> <p>Ahora el m\u00e9todo acepta cualquier tipo de <code>RandomElement</code> pero siempre y cuando el tipo gen\u00e9rico forme parte de la herencia <code>Number</code></p>"},{"location":"bloque_ii/tema_10/page-4/","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza una clase gen\u00e9rica Caja que pueda guardar un objeto de cualquier tipo. Realiza para dicha clase los m\u00e9todos get y  set. Haz un programa para probar dichos m\u00e9todos.</p> Ejercicio 2 <p>Realiza una clase gen\u00e9rica Pareja que contenga dos elementos de cualquier tipo. Realiza los siguientes m\u00e9todos:</p> <ul> <li>M\u00e9todo get para ambos.</li> <li>M\u00e9todo mostrarTipos que muestre el tipo de ambos elementos. Ejemplo: java.lang.String</li> <li>M\u00e9todo mismoTipo que devuelva true si ambos elementos tienen el mismo tipo.</li> </ul> Ejercicio 3 <p>Realiza la clase anterior con la restricci\u00f3n de que el segundo elemento pertenezca a una subclase del primero. (Probar con Number que es padre de todos los wrappers de n\u00fameros: Integer, Short, etc)</p> Ejercicio 4 <p>Realiza una clase gen\u00e9rica OperaMate que tenga un elemento de cualquier tipo num\u00e9rico. Realiza los siguientes m\u00e9todos:</p> <ul> <li>M\u00e9todo rec\u00edproco para obtener el el rec\u00edproco del n\u00famero (se obtiene dividiendo 1 entre el n\u00famero)</li> <li>M\u00e9todo fracci\u00f3n para obtener la parte fraccionaria.</li> </ul>"},{"location":"bloque_ii/tema_10/page-5/","title":"Proyecto","text":"<p>En este proyecto se va a realiza clases wrappers de Arrays, para manejarlos en diferentes situaciones. Para ello se va a crear una interfaz llamada Collection con los siguientes m\u00e9todos:</p> <ul> <li>first(): devuelve el primer elemento de la colecci\u00f3n</li> <li>last(): devuelve el \u00faltimo elemento de la colecci\u00f3n</li> <li>isEmpty(): comprueba si la colecci\u00f3n est\u00e1 vac\u00eda</li> <li>get(): devuelve el primer elemento de la colecci\u00f3n y lo elimina</li> <li>pop(): devuelve el \u00faltimo elemento de la colecci\u00f3n y lo elimina</li> <li>add(element): a\u00f1ade el elemento a la colecci\u00f3n</li> </ul> <p>Los tipos de colecciones que se quieren tratar son las siguientes:</p> <ul> <li>Cola. Este tipo de colecci\u00f3n funciona como la cola de un supermercado y sigue el proceso de una cola FIFO (First In, First Out), es decir, el primero en entrar en la cola, es el primero en salir.</li> <li>Pila. Este tipo de colecci\u00f3n funciona como una pila platos y sigue el proceso de una cola LIFO (Last In, First Out), es decir, el \u00faltimo que ha entrado es el primero en salir.</li> <li>Conjunto. Funciona exactamente igual que una cola, pero con la caracter\u00edstica de que no puede contener elementos repetidos. En caso de que se intentase a\u00f1adir un elemento repetido, \u00e9ste se lo saltar\u00eda.</li> <li>Entradas. Es una cola de elementos de pares clave-valor, donde la clave representada el identificador del valor. Al igual que los conjuntos, en una entrada no puede haber dos elementos iguales con la misma clave. En caso de que se intentase a\u00f1adir un elemento repetido, \u00e9ste se lo saltar\u00eda.</li> </ul> <p>Crea las clases necesarias para representar todas las colecciones, que deben implementar la interfaz creada.</p> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>Se deber\u00e1 hacer uso de Gen\u00e9ricos donde sea requerido.</li> <li>Se deber\u00e1 entregar un diagrama de clase que represente las relaciones entre las clases y las interfaces.</li> <li>Se valorar\u00e1 la complejidad de un Main que ponga aprueba los m\u00e9todos y clases creadas.</li> <li>Se podr\u00e1 usar la librer\u00eda common realiza en proyectos anteriores, haciendo uso de JARs.</li> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre pr10java-NOMBRE-collections siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_ii/tema_6/page-1/","title":"1 Arrays unidimensionales","text":""},{"location":"bloque_ii/tema_6/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Los tipos de datos que conocemos hasta ahora no permiten solucionar problemas que requieren gestionar muchos datos a la vez. Por ejemplo, imaginemos que deseamos almacenar las notas de  una  clase  de  25  alumnos,  para  ello,  con  lo  que  conocemos  hasta  ahora,  no  habr\u00e1  m\u00e1s remedio que declarar 25 variables. Eso es tremendamente pesado de programar. Manejar esos datos  significar\u00eda  estar  continuamente  manejando  25  variables.  Por  ello,  en  casi  todos  los lenguajes se pueden agrupar una serie de variables del mismo tipo en una misma estructura que com\u00fanmente se conoce como array. Esa estructura permite referirnos a todos los elementos, pero tambi\u00e9n nos permite acceder individualmente a cada uno de ellos.</p> <p>Los arrays son una colecci\u00f3n de datos del mismo tipo al que se le pone un nombre. Para acceder a  un  dato  individual  de  la  colecci\u00f3n  hay  que  utilizar  su  posici\u00f3n.  La  posici\u00f3n  es  un  n\u00famero entero, normalmente se le llama \u00edndice. Hay que tener en cuenta que en los arrays el primer elemento tiene como \u00edndice el n\u00famero cero, el segundo el uno y as\u00ed sucesivamente.</p> <p>Un  array  unidimensional  es  aquel  que  tiene  una  \u00fanica  dimensi\u00f3n,  es  decir,  un  \u00fanico  \u00edndice. Tambi\u00e9n se le suele llamar vector</p>"},{"location":"bloque_ii/tema_6/page-1/#declaracion","title":"Declaraci\u00f3n","text":"<p>Existen dos formas de declarar un array unidimensional:</p> <ul> <li><code>tipo nombre_array[];</code></li> <li><code>tipo[] nombre_array;</code></li> </ul> <p>tipo declara el tipo de elemento del array, es decir, el tipo de datos de cada elemento que comprende el array. Dicho tipo de datos puede ser un tipo primitivo o un objeto.</p> <p>Esta declaraci\u00f3n le dice al compilador que dicha variable va a contener un array con elementos de dicho tipo pero todav\u00eda no se reserva espacio en la memoria RAM ya que no se conoce el tama\u00f1o del mismo.</p>"},{"location":"bloque_ii/tema_6/page-1/#creacion","title":"Creaci\u00f3n","text":"<p>Se realiza con el operador new, que es el que realmente crea el array indicando un tama\u00f1o. Cuando se usa new es cuando se reserva el espacio necesario en memoria para el array.</p> <p>Se crea un array de la siguiente manera:  <code>nombre_array = new tipo[tama\u00f1o];</code></p> <p>Ejemplo:</p> <pre><code>int[] grades; //(1)!\ngrades = new int[3]; //(2)!\n</code></pre> <ol> <li>Declaraci\u00f3n del array de enteros llamado grades</li> <li>Creaci\u00f3n del array grades reservando en memoria espacio para 3 enteros</li> </ol> <p>Se puede realizar lo mismo en una \u00fanica l\u00ednea de c\u00f3digo:</p> <pre><code>int[] grades = new int[3];\n</code></pre>"},{"location":"bloque_ii/tema_6/page-1/#referencia-a-los-elementos-del-array","title":"Referencia a los elementos del array","text":"<p>Para referencias los elementos del array se utiliza el \u00edndice de los mismos entre corchetes:</p> <ul> <li><code>grades[0]</code>: es el primer elemento del array, es decir, la primera nota.</li> <li><code>grades[1]</code>: es el segundo elemento del array, es decir, la segunda nota.</li> <li><code>grades[2]</code>: es el tercer elemento del array, es decir, la tercera nota.</li> </ul>"},{"location":"bloque_ii/tema_6/page-1/#asignacion-de-valores","title":"Asignaci\u00f3n de valores","text":"<p>Se puede asignar valores a los elementos del array utilizando el signo =:</p> <pre><code>grades[2] = 8; // Se le asigna un 8 a la tercera nota.\n</code></pre> <p>Tambi\u00e9n se pueden asignar valores a todos los elementos del array utilizando literales array:</p> <pre><code>int[] grades = new int[] {8, 7, 9};\n</code></pre> <p>No es necesario escribir new int[] en las \u00faltimas versiones de Java:</p> <pre><code>int[] grades = {8, 7, 9}; \n</code></pre> <p>En este caso, se est\u00e1 asignando un 8 a la primera nota, un 7 a la segunda nota y un 9 a la tercera.</p>"},{"location":"bloque_ii/tema_6/page-1/#el-atributo-length","title":"El atributo length","text":"<p>Los arrays poseen el atributo length que contiene el tama\u00f1o del array:</p> <pre><code>System.out.println(grades.length); // 3\n</code></pre>"},{"location":"bloque_ii/tema_6/page-1/#utilizando-el-bucle-for","title":"Utilizando el bucle for","text":"<p>La ventaja de usar arrays es que gracias a un simple bucle for se pueden recorrer f\u00e1cilmente todos los elementos de un array:</p> <pre><code>public class ArrayFor {\n    public void show(){\n        int[] grades = {8, 7, 9};\n\n        for(int i = 0; i &lt; grades.length; i++){\n            System.out.printf(\"Nota del \u00edndice %d: %d\\n\", i, grades[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        new ArrayFor().show();\n    }\n}\n</code></pre> <p>\u00a1CUIDADO!</p> <p>Los \u00edndices del array van desde el 0 hasta length-1. Si un array es de tama\u00f1o 3, sus \u00edndices son 0, 1 y 2. Por eso en la condici\u00f3n del for se debe iterar mientras i sea menor que array.length, y no menor o igual, de esta forma toma como \u00faltimo \u00edndice el length-1. Si pusi\u00e9ramos la condici\u00f3n menor o igual, nos lanzar\u00eda la excepci\u00f3n ArrayIndexOutOfBoundsException ya que estar\u00edamos accediendo al array con el \u00edndice 3, el cual es un \u00edndice no v\u00e1lido.</p> <pre><code>for(int i = 0; i &lt;= grades.length; i++){ // Lanza ArrayIndexOutOfBoundsException\n    //...\n}\n</code></pre> <p>Tambi\u00e9n se pueden utilizar con los arrays los bucles for-each:</p> <pre><code>public class ArraysForEach {\n    public void show(){\n        int[] grades = {8, 7, 9};\n\n        for (int grade : grades) {\n            System.out.printf(\"Nota: %d\\n\", grade);\n        }\n    }\n\n    public static void main(String[] args) {\n        new ArraysForEach().show();\n    }\n}\n</code></pre> Ejercicio 1 <p>Dado un array de 10 n\u00fameros, realiza la suma de los n\u00fameros pares.</p>"},{"location":"bloque_ii/tema_6/page-1/#metodo-split","title":"M\u00e9todo split","text":"<p>Las clases String y Pattern poseen el m\u00e9todo split que divide una cadena en subcadenas en funci\u00f3n de una expresi\u00f3n regular y devuelve un array con las subcadenas restantes.</p> <pre><code>public class Split {\n    public void show(){\n        String string = \"Esto:es:una:cadena:dividida:por:split\";\n        String[] stringArray = string.split(\":\");\n        System.out.println(Arrays.toString(stringArray)); // [Esto, es, una, cadena, dividida, por, split]\n    }\n\n    public static void main(String[] args) {\n        new Split().show();\n    }\n}\n</code></pre> <p>Tip</p> <p>F\u00edjense en el m\u00e9todo est\u00e1tico toString de la clase Arrays. Devuelve una cadena con los elementos del array entre corchetes y separados por comas.</p> Ejercicio 2 <p>Realiza un programa que solicite al usuario una frase. Transforma esa frase en un array que cuyo valores sean las palabras de la frase, luego recorre el array.</p>"},{"location":"bloque_ii/tema_6/page-1/#los-arrays-se-implementan-como-objetos","title":"Los arrays se implementan como objetos","text":"<p>En Java, los arrays se implementan como objetos. Una de las ventajas que tiene esto es que los arrays que pierden la referencia pueden ser recolectados. (Ver el apartado referencias del tema 4 Programaci\u00f3n Orientada a Objetos)</p> <p>En la perspectiva de Java, un array es una referencia a una serie de valores que se almacenan en la memoria. El operador new en realidad lo que hace es devolver dicha referencia para poder leer y escribir esos valores.</p> <p>Veamos el efecto del uso operador new en los arrays y c\u00f3mo afectan en la memoria:</p> <p> Figura 1 - Referencia arrays</p> <p>Vemos como el anterior array se ha quedado sin referencia y se marca como elegible para el recolector de basura.</p>"},{"location":"bloque_ii/tema_6/page-1/#que-puede-contener-un-array","title":"\u00bfQu\u00e9 puede contener un array?","text":"<p>El array puede contener objetos o tipos de datos primitivos. En el caso de los tipos de datos primitivos, los valores reales se almacenan en ubicaciones de memoria contigua. En el caso de los objetos de una clase, los objetos reales se almacenan en heap.</p>"},{"location":"bloque_ii/tema_6/page-1/#arrays-de-tipos-primitivos","title":"Arrays de tipos primitivos","text":"<ul> <li> <p>Crear una variable de tipo array s\u00f3lo crea una referencia:</p> <pre><code>int[] a;\n</code></pre> <p> Figura 2 - Declaraci\u00f3n de arrays de tipo primitivos </p> </li> <li> <p>El espacio en memoria para el array se crea con new. Cuando se trata de un array de un tipo primitivo, se crean los elementos del array y se inicializan sus valores por defecto:</p> <pre><code>a = new int[5];\n</code></pre> <p> Figura 3 - Inicializaci\u00f3n de arrays de tipo primitivos </p> </li> </ul>"},{"location":"bloque_ii/tema_6/page-1/#array-de-objetos","title":"Array de objetos","text":"<ul> <li> <p>Crear una variable de tipo array de objetos s\u00f3lo crea la referencia:</p> <pre><code>Complejo[] a;\n</code></pre> <p> Figura 4 - Declaraci\u00f3n de arrays de objetos </p> </li> <li> <p>Con new se reserva el espacio para el array de referencias pero no los objetos a los que apuntar\u00e1n esas referencias. Las referencias se inicializan a su valor por defecto (null):</p> <pre><code>a = new Complejo[4];\n</code></pre> <p> Figura 5 - Inicializaci\u00f3n de arrays de objetos </p> </li> <li> <p>Los objetos hay que crearlos posteriormente:</p> <p> Figura 6 - Creaci\u00f3n de objetos de objetos </p> </li> </ul>"},{"location":"bloque_ii/tema_6/page-1/#asignacion-de-arrays","title":"Asignaci\u00f3n de arrays","text":"<p>Como en Java los arrays son objetos, la asignaci\u00f3n se realiza como los objetos (Ver el apartado referencias del tema 4 Programaci\u00f3n Orientada a Objetos)</p> <p>Un array se puede asignar a otro array (si son del mismo tipo). La asignaci\u00f3n solo copia referencias, es decir, la direcci\u00f3n de memoria. Por lo tanto, ambos arrays apuntar\u00e1n al mismo sitio:</p> <pre><code>int[] a;\nint[] b = {3, 4, 5, 6, 7, 8};\n\na = b;\n</code></pre> <p> Figura 7 - Referencia array</p> <p>Esta asignaci\u00f3n provoca que cualquier cambio en a tambi\u00e9n cambie el array b ya que de hecho, son el mismo array:</p> <pre><code>public class Assignment {\n    public void show(){\n        int[] a;\n        int[] b = {3, 4, 5, 6, 7, 8};\n        a = b;\n\n        System.out.println(Arrays.toString(b)); // [3, 4, 5, 6, 7, 8]\n        a[0] = 1;\n        System.out.println(Arrays.toString(b)); // [1, 4, 5, 6, 7, 8]\n    }\n\n    public static void main(String[] args) {\n        new Assignment().show();\n    }\n}\n</code></pre> Ejercicio 3 <p>Realiza un programa que contenga un m\u00e9todo que calcule los n primeros m\u00faltiplos de un n\u00famero. Luego realiza otro m\u00e9todo donde calcule la mitad de esos n\u00fameros. NO SE PUEDEN UTILIZAR PAR\u00c1METROS DE TIPO ARRAY</p>"},{"location":"bloque_ii/tema_6/page-1/#comparacion-de-arrays","title":"Comparaci\u00f3n de arrays","text":"<p>Como en Java los arrays son objetos, la comparaci\u00f3n se realiza como los objetos (Ver el apartado referencias del tema 4 Programaci\u00f3n Orientada a Objetos).</p> <p>El operador de igualdad <code>==</code> cuando se utiliza con arrays, no compara el contenido de los arrays sino sus direcciones de memoria o referencias, es decir, si apuntan al mismo array. Lo mismo ocurre con el m\u00e9todo equals de los arrays, que compara las direcciones de memoria. Si queremos comparar el contenido de los arrays, tendremos que utilizar el m\u00e9todo est\u00e1tico equals de la clase Arrays.</p> <pre><code>public class Comparison {\n    public void show(){\n        int[] array1;\n        int[] array2 = {3, 4, 5, 6, 7, 8};\n        int[] array3 = {3, 4, 5, 6, 7, 8};\n        array1 = array2;\n\n        System.out.println(array1 == array2); //(1)!\n        System.out.println(array2 == array3); //(2)!\n        System.out.println(array1.equals(array2)); //(3)!\n        System.out.println(array2.equals(array3)); //(4)!\n        System.out.println(Arrays.equals(array1, array2)); //(5)!\n        System.out.println(Arrays.equals(array2, array3)); //(6)!\n    }\n\n    public static void main(String[] args) {\n        new Comparison().show();\n    }\n}\n</code></pre> <ol> <li>true porque apuntan al mismo array</li> <li>false porque no apuntan al mismo array</li> <li>true porque apuntan al mismo array</li> <li>false porque apuntan al mismo array</li> <li>true porque el contenido es el mismo ya que apuntan al mismo array</li> <li>true porque el contenido es el mismo</li> </ol>"},{"location":"bloque_ii/tema_6/page-1/#arrays-como-parametros","title":"Arrays como par\u00e1metros","text":"<p>Al igual que las variables, tambi\u00e9n podemos pasar arrays a los m\u00e9todos, es decir, se pueden definir par\u00e1metros del tipo array. En la llamada al m\u00e9todo, lo que el m\u00e9todo recibe como argumento es la direcci\u00f3n de memoria del array, por lo que si el m\u00e9todo modifica el array, el array del m\u00e9todo que efect\u00faa la llamada tambi\u00e9n se ve afectado por dichos cambios.</p> <pre><code>public class ArraysAsParameters {\n    public void show(){\n        int[] array = {3, 4, 5, 6, 7, 8};\n        System.out.println(Arrays.toString(array)); // [3, 4, 5, 6, 7, 8]\n        method(array);\n        System.out.println(Arrays.toString(array)); // [6, 8, 10, 12, 14, 16]\n    }\n\n    public void method(int[] array){\n        for (int i = 0; i &lt; array.length; i++) {\n            array[i] *= 2;\n        }\n    }\n    public static void main(String[] args) {\n        new ArraysAsParameters().show();\n    }\n}\n</code></pre> Ejercicio 4 <p>Realiza un aplicaci\u00f3n que contenga un m\u00e9todo que reciba un array de cadenas y una palabra. El m\u00e9todo localizar\u00e1 dicha palabra en el array, y devolver\u00e1 true en caso de encontrarla, y false en cualquier otro caso.</p>"},{"location":"bloque_ii/tema_6/page-1/#como-retornar-un-array","title":"C\u00f3mo retornar un array","text":"<p>Un m\u00e9todo tambi\u00e9n puede devolver un array, en cuyo caso, lo que retorna es la direcci\u00f3n de dicho array.</p> <pre><code>public class ReturningAnArray {\n    public void show(){\n        int[] a;\n        a = method();\n        System.out.println(Arrays.toString(a)); // [3, 4, 5, 6, 7, 8]\n    }\n\n    public int[] method(){\n        return new int[]{3, 4, 5, 6, 7, 8};\n    }\n\n    public static void main(String[] args) {\n        new ReturningAnArray().show();\n    }\n}\n</code></pre> <p>En este caso, el main define una variable a de tipo array de enteros pero no hace el new del array, sino que recibe la direcci\u00f3n de memoria que le devuelve el m\u00e9todo method. Sin embargo, el m\u00e9todo method s\u00ed que hace el new del array porque su responsabilidad es crear el array, darle valores y devolverlo.</p> Ejercicio 5 <p>Realiza un programa con un m\u00e9todo que dado un n\u00famero positivo, devuelva sus divisores.</p>"},{"location":"bloque_ii/tema_6/page-1/#excepcion-arrayindexoutofboundsexception","title":"Excepci\u00f3n ArrayIndexOutOfBoundsException","text":"<p>Cuando se intenta acceder a un elemento del array que no existe, Java nos lanza una excepci\u00f3n ArrayIndexOutOfBoundsException. El programador no debe capturar con un try-catch la excepci\u00f3n sino que debe corregir el error de programaci\u00f3n que ha producido dicha excepci\u00f3n. Veamos un ejemplo:</p> <pre><code>public class ArrayIndexOutOfBoundsException1 {\n    public void show(){\n        int[] grades = {8, 7, 9};\n\n        for (int i = 0; i &lt;= grades.length; i++) {\n            System.out.printf(\"Nota en el \u00edndice %d: %d\\n\", i, grades[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        new ArrayIndexOutOfBoundsException1().show();\n    }\n}\n</code></pre> <p>Como vemos en el ejemplo, al usar <code>&lt;=</code>, se lanzar\u00e1 una excepci\u00f3n al intentar acceder al valor de la posici\u00f3n <code>grades[3]</code>, que es el valor de grades.length, que es inexistente. No se debe usar un try-catch para manejar este error, sino que el programador debe corregir el error.</p>"},{"location":"bloque_ii/tema_6/page-2/","title":"2 Arrays Multidimensionales","text":""},{"location":"bloque_ii/tema_6/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Los arrays multidimensionales son aquellos que tienen m\u00e1s de una dimensi\u00f3n, es decir, son arrays que contienen otros arrays. Tienen m\u00e1s de un \u00edndice, uno por cada dimensi\u00f3n.</p> <p>Un array con dos dimensiones es un array bidimensional y tambi\u00e9n se le suele llamar matriz. Si adem\u00e1s, la matriz tiene el mismo n\u00famero de filas que de columnas, entonces se llama matriz cuadrada.</p>"},{"location":"bloque_ii/tema_6/page-2/#declaracion","title":"Declaraci\u00f3n","text":"<p>Se declaran como los arrays unidimensionales a\u00f1adiendo tantos corchetes <code>[ ]</code> como dimensiones haya. Por ejemplo, veamos las dos formas de declarar un array bidimensional:</p> <ul> <li><code>tipo nombre_array[][];</code></li> <li><code>tipo[][] nombre_array:</code></li> </ul> <p>tipo declara el tipo de elemento del array, es decir, el tipo de datos de cada elemento que comprende el array. Dicho tipo de datos puede ser un tipo primitivo o un objeto.</p> <p>Esta declaraci\u00f3n le dice al compilador que dicha variable va a contener un array con elementos de dicho tipo pero todav\u00eda no se reserva espacio en la memoria RAM ya que no se conoce el tama\u00f1o del mismo.</p>"},{"location":"bloque_ii/tema_6/page-2/#creacion","title":"Creaci\u00f3n","text":"<p>Se realiza con el operador new, que es realmente crea el array indicando un tama\u00f1o. Cuando se usa un new es cuando se reserva el espacio necesario en memoria para el array.</p> <p>Se crea un array bidimensional de la siguiente manera: <code>nombre_array = new tipo[filas][columnas]</code></p> <pre><code>int[] a = new int[10]; // Array de una dimensi\u00f3n\nint[][] b = new int[3][5]; // Array bidimensional (dos dimensiones)\nint[][][] c = new int[4][6][2]; // Array tridimensional (tres dimensiones)\n</code></pre> <p> Figura 8 - Array multidimensionales</p> <p>Los arrays multidimensionales son arrays que contienes arrays, por lo tanto un array bidimensional se puede representar de la siguiente manera</p> <p> Figura 9 - Array bidimensional</p>"},{"location":"bloque_ii/tema_6/page-2/#referencia-a-los-objetos-del-array","title":"Referencia a los objetos del array","text":"<p>Para referencias los elementos del array se utiliza el \u00edndice de los mismos entre corchetes:</p> <ul> <li><code>a[9]</code>: es el \u00faltimo elemento unidimensional de a.</li> <li><code>b[1][2]</code>: es el elemento que est\u00e1 justo en medio del array bidimensional b.</li> <li><code>c[0][0][0]</code>: es el primer elemento del array tridimensional c.</li> </ul> <p>Supongamos que tenemos el siguiente array bidimensional:</p> <pre><code>int[][] = new int[5][4];\n</code></pre> <p>Es un array que contiene 5 arrays unidimensionales de 4 posiciones cada uno. Veamos en la imagen la referencia de sus elementos:</p> <p> Figura 10 - Referencia a un array multidimensional</p> <ul> <li>m: contiene la referencia al array completo.</li> <li>m[0]: contiene la referencia del primer array unidimensional.</li> <li>m[4]: contiene la referencia del quinto array unidimensional.</li> <li>m[0] [0]: contiene el primer elemento del primer array unidimensional.</li> <li>m[0] [3]: contiene el \u00faltimo elemento del primer array unidimensional.</li> <li>m[4] [3]: contiene el \u00faltimo elemento del \u00faltimo array unidimensional.</li> </ul>"},{"location":"bloque_ii/tema_6/page-2/#asignacion-de-valores","title":"Asignaci\u00f3n de valores","text":"<p>Se pueden asignar valores a los elementos del array utilizando el signo <code>=</code>.</p> <pre><code>a[9] = 8; //(1)!\nb[1][2] = 9; //(2)!\nc[0][0][0] = 1; //(3)!\n</code></pre> <ol> <li>Se asigna un 8 al \u00faltimo elemento del array unidimensional a.</li> <li>Se asigna un 9 al elemento que est\u00e1 justo en medio del array bidimensional b.</li> <li>Se asigna un 1 al primer elemento del array tridimensional c.</li> </ol> <p>Tambi\u00e9n se pueden asignar valores a todos los elementos del array utilizando literales array:</p> <pre><code>// Array de dos dimensiones [3][5]\nint[][] twoDimensions = {\n    {0, 1, 2, 3, 4},\n    {5, 6, 7, 8, 9},\n    {10, 11, 12, 13, 14}\n}\n\n// Array de tres dimensiones [2][3][2]\nint[][][] threeDimensions = {\n    { {0, 1}, {2, 3}, {4, 5}},\n    { {6, 7}, {8, 9}, {10, 11}}\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-2/#el-atributo-length","title":"El atributo length","text":"<p>Los arrays poseen el atributo length que contiene el tama\u00f1o del array. Como los arrays multidimensionales son arrays de arrays, se puede aplicar a cualquier posici\u00f3n que contenga una referencia. Si se aplica a una posici\u00f3n que contenga un elemento, entonces da error de compilaci\u00f3n.</p> <pre><code>public class LengthMultidimensional {\n    public void show(){\n        // Array de dos dimensiones [3][5]\n        int[][] twoDimensions = {\n                {0, 1, 2, 3, 4},\n                {5, 6, 7, 8, 9},\n                {10, 11, 12, 13, 14}\n        };\n\n        // Array de tres dimensiones [2][3][2]\n        int[][][] threeDimensions = {\n                { {0, 1}, {2, 3}, {4, 5}},\n                { {6, 7}, {8, 9}, {10, 11}}\n        };\n\n        System.out.println(twoDimensions.length); // 3\n        System.out.println(twoDimensions[0].length); // 5\n        System.out.println(twoDimensions[1].length); // 5\n        System.out.println(twoDimensions[2].length); // 5\n\n        System.out.println(threeDimensions.length); // 2\n        System.out.println(threeDimensions[0].length); // 3\n        System.out.println(threeDimensions[1].length); // 3\n        System.out.println(threeDimensions[0][0].length); // 2\n        System.out.println(threeDimensions[1][2].length); // 2\n        System.out.println(threeDimensions[1][2][0].length); // Error\n    }\n\n    public static void main(String[] args) {\n        new LengthMultidimensional().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-2/#utilizacion-del-bucle-for","title":"Utilizaci\u00f3n del bucle for","text":"<p>La ventaja de usar arrays es que gracias a un simple bucle for se pueden recorrer f\u00e1cilmente todos los elementos de un array multidimensional.</p> <pre><code>public class ForMultidimensional {\n    public void show(){\n        // Array de dos dimensiones [3][5]\n        int[][] twoDimensions = {\n                {0, 1, 2, 3, 4},\n                {5, 6, 7, 8, 9},\n                {10, 11, 12, 13, 14}\n        };\n\n        // Array de tres dimensiones [2][3][2]\n        int[][][] threeDimensions = {\n                { {0, 1}, {2, 3}, {4, 5}},\n                { {6, 7}, {8, 9}, {10, 11}}\n        };\n\n        for(int i = 0; i &lt; twoDimensions.length; i++){\n            for(int j = 0; j &lt; twoDimensions[0].length; j++){\n                System.out.printf(\"%2d \", twoDimensions[i][j]);\n            }\n            System.out.println();\n        }\n\n        System.out.println();\n\n        for (int i = 0; i &lt; threeDimensions.length; i++) {\n            for (int j = 0; j &lt; threeDimensions[i].length; j++) {\n                for (int k = 0; k &lt; threeDimensions[i][j].length; k++) {\n                    System.out.printf(\"%2d \", threeDimensions[i][j][k]);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new ForMultidimensional().show();\n    }\n}\n</code></pre> <p>Tambi\u00e9n se pueden utilizar los bucles for-each pero solamente con arrays unidimensionales. En un array multidimensional, se puede utilizar un for-each en cualquiera de los arrays unidimensionales que forman parte del array multidimensional</p> <p>Para mostrar un array multidimensional, tambi\u00e9n se puede utilizar el m\u00e9todo est\u00e1tico deepToString de la clase Arrays. Devuelve una cadena con los elementos del array entre corchetes y separados por comas. Se utiliza con arrays multidimensionales. Para los arrays unidimensionales se usa el m\u00e9todo Arrays.toString.</p> <pre><code>public class DeepToString {\n    public void show(){\n        int[][] twoDimensions = {\n                {0, 1, 2, 3, 4},\n                {5, 6, 7, 8, 9},\n                {10, 11, 12, 13, 14}\n        };\n\n        System.out.println(Arrays.deepToString(twoDimensions)); // [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]\n    }\n\n    public static void main(String[] args) {\n        new DeepToString().show();\n    }\n}\n</code></pre> Ejercicio 1 <p>Realiza un programa que solicite las 3 notas de 5 alumnos, hallando la nota mayor, y a qui\u00e9n pertenece, la nota inferior, y a qui\u00e9n pertenece, y la nota mayor e inferior de cada alumno.</p>"},{"location":"bloque_ii/tema_6/page-2/#comparacion-de-arrays","title":"Comparaci\u00f3n de arrays","text":"<p>Como en Java los arrays son objetos, la comparaci\u00f3n se realiza como los objetos (Ver el apartado referencias del tema 4 Programaci\u00f3n Orientada a Objetos).</p> <p>El operador de igualdad <code>==</code> cuando se utiliza con arrays, no compara el contenido de los arrays sino sus direcciones de memoria o referencias, es decir, si apuntan al mismo array. Lo mismo ocurre cuando el m\u00e9todo equals de los arrays, que compara las direcciones de memoria. Si queremos comparar el contenido de los arrays, tendremos que utilizar el m\u00e9todo est\u00e1tico equals de la clase Arrays para los unidimensionales y el m\u00e9todo deepEquals para los multidimensionales.</p> <pre><code>public class ComparisonMultidimensional {\n    public void show(){\n        int[][] twoDimension1;\n        int[][] twoDimension2 = {\n                {0, 1, 2, 3, 4},\n                {5, 6, 7, 8, 9},\n                {10, 11, 12, 13, 14}\n        };\n        int[][] twoDimension3 = {\n                {0, 1, 2, 3, 4},\n                {5, 6, 7, 8, 9},\n                {10, 11, 12, 13, 14}\n        };\n\n        twoDimension1 = twoDimension2;\n\n        System.out.println(twoDimension1 == twoDimension2); // true porque apuntan al mismo array\n        System.out.println(twoDimension2 == twoDimension3); // false porque no apuntan al mismo array\n        System.out.println(twoDimension1.equals(twoDimension2)); // true porque apuntan al mismo array\n        System.out.println(twoDimension2.equals(twoDimension3)); // false porque no apuntan al mismo array\n        System.out.println(Arrays.deepEquals(twoDimension1, twoDimension2)); // true porque el contenido es el mismo ya que apuntan al mismo array\n        System.out.println(Arrays.deepEquals(twoDimension2, twoDimension3)); // true porque el contenido es el mismo\n        System.out.println(Arrays.equals(twoDimension2, twoDimension3)); // false porque para arrays multidimensionales es deepEquals en lugar de equals\n    }\n\n    public static void main(String[] args) {\n        new Comparison().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-2/#arrays-irregulares","title":"Arrays irregulares","text":"<p>Los arrays unidimensionales que forman un array multidimensional no tienen porqu\u00e9 tener todos el mismo tama\u00f1o.</p> <p> Figura 11 - Arrays Irregulares</p> <pre><code>public class IrregularArrays {\n    public void show(){\n        int[][] b = { {1,2,3}, {4,5,6,7}, {8,9}};\n\n        for (int i = 0; i &lt; b.length; i++) {\n            for (int j = 0; j &lt; b[i].length; j++) {\n                System.out.printf(\"%2d \", b[i][j]);\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        new IrregularArrays().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-3/","title":"3 Argumentos variables","text":""},{"location":"bloque_ii/tema_6/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Se puede dar el caso de que se necesite crear un m\u00e9todo que tome una cantidad variable de argumentos, seg\u00fan su uso preciso. Por ello, Java en su versi\u00f3n 5 incorpor\u00f3 los llamados varargs que es la abreviatura de argumentos de longitud variable (Variable - Length Arguments). Un m\u00e9todo que toma una cantidad variable de argumentos se denomina m\u00e9todos varargs.</p>"},{"location":"bloque_ii/tema_6/page-3/#sintaxis-de-varargs","title":"Sintaxis de Varargs","text":"<p>Un par\u00e1metro de longitud variable se espec\u00edfica por tres punts(...).</p> <pre><code>public static int add(int... nums)\n</code></pre> <p>Esta sintaxis le dice al compilador que se puede llamar al m\u00e9todo add con cero o m\u00e1s argumentos . Adem\u00e1s hace que nums se declare impl\u00edcitamente como un array de tipo int[]. Por lo tanto, dentro del m\u00e9todo add se accede a nums usando la sintaxis de array normal:</p> <pre><code>public class Varargs1 {\n    public void show(){\n        System.out.println(add());\n        System.out.println(add(1));\n        System.out.println(add(new int[]{1}));\n        System.out.println(add(1,2));\n        System.out.println(add(1,2,3));\n        System.out.println(add(1,2,3,4));\n        System.out.println(add(new int[]{1, 2, 3, 4}));\n    }\n\n    private int add(int... nums) {\n        int sum = 0;\n\n        for (int i = 0; i &lt; nums.length; i++) {\n            sum += nums[i];\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        new Varargs1().show();\n    }\n}\n</code></pre> <p>Si nos fijamos en el ejemplo, el m\u00e9todo add se llama con diferentes n\u00fameros de argumentos, incluyendo ning\u00fan argumento. Los argumentos se colocan autom\u00e1ticamente en un array y se pasan nums. En el caso de que no haya argumentos, la longitud del array es cero.</p> Ejercicio 1 <p>Realiza un programa que contenga un m\u00e9todo que pueda recibir todos los par\u00e1metros que desee. Halla la suma de esos n\u00fameros</p>"},{"location":"bloque_ii/tema_6/page-3/#metodos-con-parametros-normales-y-parametros-variables","title":"M\u00e9todos con par\u00e1metros normales y par\u00e1metros variables","text":"<p>Un m\u00e9todo puede tener par\u00e1metros normales junto con un par\u00e1metro de longitud variable. Sin embargo, el par\u00e1metro de longitud variable debe ser el \u00faltimo par\u00e1metro declarado por el m\u00e9todo y solamente se acepta un varargs por m\u00e9todo. Por ejemplo, esta declaraci\u00f3n de m\u00e9todo es perfectamente aceptable:</p> <pre><code>int compute(int x, int y, double x, int... values)\n</code></pre> <p>En este caso, los tres primeros argumentos utilizados en una llamada al m\u00e9todo compute se corresponden con los primeros tres par\u00e1metros. Entonces, se supone que los argumentos restantes pertenecen a values.</p> <pre><code>public class Varargs2 {\n    public void show(){\n        System.out.println(operate(2));\n        System.out.println(operate(2, 1));\n        System.out.println(operate(2, 1, 2));\n        System.out.println(operate(2, 1, 2, 3));\n        System.out.println(operate(2, 1, 2, 3, 4));\n    }\n\n    public int operate(int mult, int... summands){\n        int sum = 0;\n\n        for (int i = 0; i &lt; summands.length; i++) {\n            sum += summands[i];\n        }\n\n        return sum * mult;\n    }\n\n    public static void main(String[] args) {\n        new Varargs2().show();\n    }\n}\n</code></pre> <p>Recuerda, el par\u00e1metro varargs debe ser el \u00faltimo. Por ejemplo, la siguiente declaraci\u00f3n es incorrecta:</p> <pre><code>int compute(int x, int y, double z, int... values, boolean exit); //error\n</code></pre> <p>Adem\u00e1s, solamente se acepta un varargs por m\u00e9todo. Por ejemplo, esta declaraci\u00f3n tampoco es v\u00e1lida:</p> <pre><code>int compute(int x, int y, double z, int... values, double... nums); //error\n</code></pre> Ejercicio 2 <p>Realiza un m\u00e9todo que reciba un par\u00e1metro num\u00e9rico y pueda recibir varios n\u00fameros. Devuelve el resultado de sumar cada n\u00famero multiplicado por el par\u00e1metro.</p>"},{"location":"bloque_ii/tema_6/page-4/","title":"4 La clase Arrays","text":""},{"location":"bloque_ii/tema_6/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>En el paquete java.utils se encuentra la clase Arrays. Esta clase contiene m\u00e9todos est\u00e1ticos para manipular arrays, como por ejemplo, b\u00fasquedas, comparaciones, copias y ordenaciones.</p>"},{"location":"bloque_ii/tema_6/page-4/#contenido-de-un-array","title":"Contenido de un array","text":"<ul> <li> <p>M\u00e9todo toString: devuelve una representaci\u00f3n en cadena del contenido del array especificado. Dicha cadena est\u00e1 formada por los elementos del array entre corchetes y separados por comas. Es muy \u00fatil para sacar por consola la informaci\u00f3n sobre el array. Se utiliza con arrays unidimensionales.</p> <pre><code>public class ToString {\n    public void show(){\n        int[] array = {3, 4, 5, 6, 7, 8};\n        System.out.printf(\"La informaci\u00f3n del array es %s\", Arrays.toString(array));\n    }\n\n    public static void main(String[] args) {\n        new ToString().show();\n    }\n}\n</code></pre> </li> <li> <p>M\u00e9todo deepToString: igual que el anterior pero para arrays multidimensionales:</p> <pre><code>public class DeepToString {\n    public void show(){\n        int[][] twoDimensions = {\n                {0, 1, 2, 3, 4},\n                {5, 6, 7, 8, 9},\n                {10, 11, 12, 13, 14}\n        };\n\n        System.out.println(Arrays.deepToString(twoDimensions)); // [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]\n    }\n\n    public static void main(String[] args) {\n        new DeepToString().show();\n    }\n}\n</code></pre> </li> </ul>"},{"location":"bloque_ii/tema_6/page-4/#rellenar-un-array","title":"Rellenar un array","text":"<p>El m\u00e9todo fill permite rellenar todo un array unidimensional con un determinado valor. Tambi\u00e9n tiene una versi\u00f3n sobrecargado para especificar un rango.</p> <pre><code>public class Fill {\n    public void show(){\n        int[] array = new int[6];\n        Arrays.fill(array, 1);\n        System.out.println(Arrays.toString(array)); // [1, 1, 1, 1, 1, 1]\n        Arrays.fill(array, 2, 5, 0);\n        System.out.println(Arrays.toString(array)); // [1, 1, 0, 0, 0, 1]\n    }\n\n    public static void main(String[] args) {\n        new Fill().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-4/#busquedas","title":"B\u00fasquedas","text":"<p>El m\u00e9todo binarySearch:</p> <ul> <li>permite buscar un elemento de forma ultra r\u00e1pida en un array ordenado (en un array desordenado, sus resultados son impredecibles)</li> <li>Devuelve el \u00edndice en el que est\u00e1 colocado el elemento.</li> <li>Si el elemento no se encuentra, devuelve un n\u00famero negativo.</li> <li>Si el array contiene m\u00faltiples elementos con el valor especificado, no hay garant\u00eda de cu\u00e1l ser\u00e1 encontrado.</li> <li>Est\u00e1 sobrecargado para buscar en un determinado rango del array. Se proporcionan dos par\u00e1metros m\u00e1s para especificar el rango:<ul> <li>fromIndex: el \u00edndice (incluido) de la parte inferior del rango.</li> <li>toIndex: el \u00edndice (excluido) de la parte superior del rango.</li> </ul> </li> </ul> <pre><code>public class BinarySearch {\n    public void show(){\n        int lowerRange, higherRange;\n        int[] array = {3, 4, 5, 6, 7, 8};\n        int number = 9;\n        int index = Arrays.binarySearch(array, number);\n        if(index &gt;= 0){\n            System.out.printf(\"El n\u00famero %d se encuentra en el \u00edndice %d\\n\", number, index);\n        } else {\n            System.out.printf(\"El n\u00famero %d no se encuentra en el array\\n\", number);\n        }\n\n        lowerRange = 3;\n        higherRange = 6; // Como est\u00e1 excluido, se busca hasta el \u00edndice 5\n        index = Arrays.binarySearch(array, lowerRange, higherRange, number);\n\n        if(index &gt;= 0){\n            System.out.printf(\"El n\u00famero %d se encuentra en el \u00edndice %d\\n\", number, index);\n        } else {\n            System.out.printf(\"El n\u00famero %d no se encuentra en el array\\n\", number);\n        }\n    }\n\n    public static void main(String[] args) {\n        new BinarySearch().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-4/#comparaciones","title":"Comparaciones","text":"<p>Adem\u00e1s de los m\u00e9todos, equals para los arrays unidimensionales, y deepEquals para los multidimensionales, existen otros m\u00e9todos para comparar:</p> <ul> <li> <p>M\u00e9todo compare: compara dos arrays lexicogr\u00e1ficamente. Tambi\u00e9n tiene una versi\u00f3n sobrecargada para especificar un rango. Devuelve:         - el valor 0: si los dos arrays son iguales y contienen los mismos elementos en el mismo orden.         - un n\u00famero negativo: si el primer array es lexicogr\u00e1ficamente inferior al segundo.         - un n\u00famero positivo: si el primer array es lexicogr\u00e1ficamente superior al segundo.</p> <pre><code>public class Compare {\n    public void show(){\n        int result;\n        boolean[] arrayBoolean1 = {true, true, false};\n        boolean[] arrayBoolean2 = {true, true, false};\n        char[] arrayChar1 = {'m', 'n', 't'};\n        char[] arrayChar2 = {'m', 'n', 'a'};\n        char[] arrayChar3 = {'M', 'n', 't'};\n        int[] arrayInt1 = {3, 4, 5};\n        int[] arrayInt2 = {3, 4, 5};\n        int[] arrayInt3 = {3, 4, 5, 6};\n\n        result = Arrays.compare(arrayBoolean1, arrayBoolean2);\n        System.out.printf(\"El resultado de comparar %s y %s es: \",\n                Arrays.toString(arrayBoolean1), Arrays.toString(arrayBoolean2));\n        comparison(result);\n\n        result = Arrays.compare(arrayChar1, arrayChar2);\n        System.out.printf(\"El resultado de comparar %s y %s es: \",\n                Arrays.toString(arrayChar1), Arrays.toString(arrayChar2));\n        comparison(result);\n\n        result = Arrays.compare(arrayChar3, arrayChar2);\n        System.out.printf(\"El resultado de comparar %s y %s es: \",\n                Arrays.toString(arrayChar3), Arrays.toString(arrayChar2));\n        comparison(result);\n\n        result = Arrays.compare(arrayInt1, arrayInt2);\n        System.out.printf(\"El resultado de comparar %s y %s es: \",\n                Arrays.toString(arrayInt1), Arrays.toString(arrayInt2));\n        comparison(result);\n\n        result = Arrays.compare(arrayInt1, arrayInt3);\n        System.out.printf(\"El resultado de comparar %s y %s es: \",\n                Arrays.toString(arrayInt1), Arrays.toString(arrayInt3));\n        comparison(result);\n\n        result = Arrays.compare(arrayInt1,0, 3 ,arrayInt3, 0, 3);\n        System.out.printf(\"El resultado de comparar %s y %s en el rango 0-2 es: \",\n                Arrays.toString(arrayInt1), Arrays.toString(arrayInt3));\n        comparison(result);\n    }\n\n    public void comparison(int result){\n        if(result == 0){\n            System.out.println(\"los arrays son iguales\");\n        } else if(result &lt; 0){\n            System.out.println(\"el primer array es menor\");\n        } else {\n            System.out.println(\"el primer array es mayor\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Compare().show();\n    }\n}\n</code></pre> </li> <li> <p>M\u00e9todo mismatch: encuentra y devuelve el \u00edndice de la primera diferencia entre dos arrays. Si no encuentra ninguna diferencia, devuelve -1. Tambi\u00e9n tiene una versi\u00f3n sobrecargada para especificar un rango.</p> </li> </ul> <pre><code>public class Mismatch {\n    public void show(){\n        int[] array1 = {3, 4, 5, 6, 7, 8};\n        int[] array2 = {3, 4, 5, 6, 7, 8};\n        int[] array3 = {3, 4, 5, 6, 7, 8, 9, 10, 11};\n        int indexMismatch;\n\n        indexMismatch = Arrays.mismatch(array1, array2);\n\n        if(indexMismatch == -1){\n            System.out.printf(\"%s y %s son iguales\\n\", Arrays.toString(array1), Arrays.toString(array2));\n        } else {\n            System.out.printf(\"%s y %s tienen su primera diferencia en el elemento %d\\n\",\n                    Arrays.toString(array1), Arrays.toString(array2), indexMismatch);\n        }\n\n        indexMismatch = Arrays.mismatch(array1, array3);\n\n        if(indexMismatch == -1){\n            System.out.printf(\"%s y %s son iguales\\n\", Arrays.toString(array1), Arrays.toString(array3));\n        } else {\n            System.out.printf(\"%s y %s tienen su primera diferencia en el elemento %d\\n\",\n                    Arrays.toString(array1), Arrays.toString(array3), indexMismatch);\n        }\n\n        indexMismatch = Arrays.mismatch(array1, 2, 6, array3, 2, 6);\n\n        if(indexMismatch == -1){\n            System.out.printf(\"%s y %s son iguales en el rango 2-5\\n\", Arrays.toString(array1), Arrays.toString(array2));\n        } else {\n            System.out.printf(\"%s y %s tienen su primera diferencia en el elemento %d en el rango 2-5\\n\",\n                    Arrays.toString(array1), Arrays.toString(array2), indexMismatch);\n        }\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-4/#copias","title":"Copias","text":"<ul> <li> <p>M\u00e9todo copyOf: obtiene una copia de un array. Recibe dos par\u00e1metros, el array a copiar y el tama\u00f1o del array resultante. De mode que:         - si el tama\u00f1o es menor que el del array original: s\u00f3lo obtiene una copia de los primeros elementos, tantos como indique el tama\u00f1o.         - si el tama\u00f1o es mayor que el original: devuelve un array en el que los elementos superan al original se rellenaran con el valor por defecto seg\u00fan el tipo de datos del array.</p> <pre><code>public class CopyOf {\n    public void show(){\n        int[] array1 = {3, 4, 5, 6, 7, 8, 9, 10};\n        int[] array2 = Arrays.copyOf(array1, 5);\n        int[] array3 = Arrays.copyOf(array1, 10);\n\n        System.out.println(Arrays.toString(array2)); // [3, 4, 5, 6, 7]\n        System.out.println(Arrays.toString(array3)); // [3, 4, 5, 6, 7, 8, 9, 10, 0, 0]\n    }\n\n    public static void main(String[] args) {\n        new CopyOf().show();\n    }\n}\n</code></pre> </li> <li> <p>M\u00e9todo copyOfRange: obtiene una copia de un array especificando el rango, es decir, de qu\u00e9 elemento a qu\u00e9 elemento se hace la copia.</p> <pre><code>public class CopyOfRange {\n    public void show(){\n        int[] array1 = {3, 4, 5, 6, 7, 8, 9, 10};\n        int[] array2 = Arrays.copyOfRange(array1, 2, 6);\n        System.out.println(Arrays.toString(array2)); // [5, 6, 7, 8]\n    }\n\n    public static void main(String[] args) {\n        new CopyOfRange().show();\n    }\n}\n</code></pre> </li> </ul>"},{"location":"bloque_ii/tema_6/page-4/#ordenaciones","title":"Ordenaciones","text":"<p>El m\u00e9todo sort ordena un array de forma ascendente. Tambi\u00e9n tiene una versi\u00f3n sobrecargada para especificar un rango.</p> <pre><code>public class Sort {\n    public void show(){\n        int[] array1 = {8, 4, 3, 7, 5, 6};\n        int[] array2 = {8, 4, 3, 7, 5, 6};\n\n        Arrays.sort(array1);\n        System.out.println(Arrays.toString(array1)); // [3, 4, 5, 6, 7, 8]\n\n        Arrays.sort(array2,1 ,5);\n        System.out.println(Arrays.toString(array2)); // [8, 3, 4, 5, 7, 6]\n    }\n\n    public static void main(String[] args) {\n        new Sort().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-5/","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza una funci\u00f3n que reciba varios n\u00fameros enteros y devuelva la multiplicaci\u00f3n de todos los n\u00fameros enteros.</p> Ejercicio 2 <p>Realiza una funci\u00f3n que reciba un array y devuelva otro array con sus elementos invertidos. Por ejemplo, si recibe {1, 2, 3} devuelve {3, 2, 1}.</p> Ejercicio 3 <p>Realiza el mismo ejercicio anterior pero haciendo uso de una funci\u00f3n recursiva.</p> Ejercicio 4 <p>Crea un array de caracteres que contengan de la 'A' a la 'Z' (solo may\u00fasculas). Despu\u00e9s, ve pidiendo posiciones de array por teclado y si la posici\u00f3n es correcta, se a\u00f1adir\u00e1 a una cadena que se mostrar\u00e1 al final. Se dejar\u00e1 de insertar cuando se introduzca -1.</p> Ejercicio 5 <p>Realiza el juego del ahorcado. El programa tendr\u00e1 un array con varias palabras y elegir\u00e1 de forma aleatoria una al azar.</p> <p>Se le solicitar\u00e1 al usuario si quiere completar la palabra o escribir un car\u00e1cter. Si elige la primera opci\u00f3n se le solicitar\u00e1 la palabra, en caso de coincidir con la elegida, mostrar\u00e1 un mensaje de ganador, en caso de fallarla, se le mostrar\u00e1 un mensaje de perdedor y se terminar\u00e1 el juego.</p> <p>En caso de elegir la segunda opci\u00f3n, se le solicitar\u00e1 al usuario un car\u00e1cter y se comprobar\u00e1 si forma parte de la palabra, mostrando el avance de la siguiente forma \"_ _ _ _ A\"</p> Ejercicio 6 <p>Crea una aplicaci\u00f3n de Java con los siguientes m\u00e9todos:</p> <ul> <li><code>int[] fillRandomArray(int length)</code>: Devuelve un array con los elementos aleatorio.</li> <li><code>void fillRandomArray(int[] array)</code>: Recibe un array que va a ser rellenado con elementos aleatorios.</li> <li><code>int[] statistics(int[] array)</code>: Recibe un array y devuelve otro de 3 posiciones, donde la primera posici\u00f3n se encontrar\u00e1 el elemento del array pasado como par\u00e1metro que sea el m\u00e1ximo, en la segunda posici\u00f3n se encontrar\u00e1 el m\u00ednimo y la tercera posici\u00f3n se encontrar\u00e1 la suma del array.</li> </ul> <p>Explica las diferencias entre los dos m\u00e9todos.</p> Ejercicio 7 <p>Realiza un programa que cree un array bidimensional rellen\u00e1ndolo de valores aleatorios comprendidos entre 1 y 10. Luego crea un array con el mismo array, y el valor de la suma de filas y columnas y el tama\u00f1o total. Solicita el tama\u00f1o de la matriz por consola.</p> Ejercicio 8 <p>Realiza una funci\u00f3n que reciba un array de tres dimensiones de n\u00fameros decimales y muestre cu\u00e1l es el elemento mayor y su posici\u00f3n</p> Ejercicio 8 <p>Realiza una funci\u00f3n que reciba un array bidimensional de enteros y devuelva otro array bidimensional con los elementos copiados pero con el doble de columnas. Los elementos nuevos se rellenan con ceros. Por ejemplo, si recibe <code>{{1,2}, {3, 4}, {5, 6}}</code> devuelve <code>{{1, 2, 0, 0}, {3,4, 0, 0}, {5, 6, 0, 0}}</code></p> Ejercicio 9 <p>Se desea realizar una encuesta a varias personas, en la cu\u00e1l se quiere conocer su sexo (1 si es Hombre, 2 si es mujer), si trabaja (1 si trabaja o 2 si no), y su sueldo (comprendido entre 600 y 2000, siendo 0 en caso de que no trabaje). Crea un array bidimensional aleatorio y calcula:</p> <ul> <li>Porcentaje de hombre</li> <li>Porcentaje de mujeres</li> <li>Porcentaje de hombres que trabajan</li> <li>Porcentaje de mujeres que trabajan</li> <li>El sueldo promedio de los hombres que trabajan</li> <li>El sueldo promedio de las mujeres que trabajan</li> </ul> Ejercicio 10 <p>Crea una clase llamada <code>DynamicArray</code>, que sea un array din\u00e1mico de n\u00fameros, es decir, que se le pueda cambiar el tama\u00f1o. Por ejemplo, si tenemos un array de <code>[1,2,3]</code> estamos ante un array de 3 elementos, y si quieres a\u00f1adir el n\u00famero <code>4</code>, el tama\u00f1o pasar\u00e1 de 3 a 4. Si quisi\u00e9ramos eliminar el n\u00famero <code>1</code>, pasar\u00eda de 4 a 3 nuevamente. Dicha clase tendr\u00e1 los siguientes constructores:</p> <ul> <li>Sin par\u00e1metros: Crea un array vac\u00edo (sin ning\u00fan tipo de valores).</li> <li>Con un par\u00e1metro: Recibe el tama\u00f1o inicial del array y crear\u00e1 un array vac\u00edo con esos tama\u00f1os, sin rellenar.</li> <li>Con par\u00e1metros infinitos: Recibe un varargs de n\u00fameros y crear\u00e1 un array con dichos n\u00fameros.</li> <li>Con un par\u00e1metro y par\u00e1metros infinitos. Recibe el tama\u00f1o del array y un varargs con los n\u00fameros a introducir en el array. Si el tama\u00f1o es inferior al tama\u00f1o de el varargs, \u00e9ste ser\u00e1 omitido y se tendr\u00e1 como tama\u00f1o principal el de varargs.</li> </ul> <p>Adem\u00e1s, tendr\u00e1 los siguientes elementos:</p> <ul> <li><code>void add(int... elements)</code>: A\u00f1ade todos los elementos de la lista.</li> <li><code>void remove(int element)</code>: Elimina el elemento si existe.</li> <li><code>int[] slice(int start, int end)</code>: Devuelve un sub-array din\u00e1mico desde el \u00edndice indicado <code>start</code> hasta el \u00edndice indicado <code>end</code>.</li> <li><code>int[] slice(int start)</code>: Devuelve un sub-array din\u00e1mico desde el \u00edndice indicado <code>start</code> hasta el final.</li> <li><code>void sort()</code>: Haciendo uso del algoritmo quick sort, ordenar\u00e1 el array din\u00e1mico.</li> <li><code>int[] sorted()</code>: Igual que al anterior, pero retornar\u00e1 una copia segura del array en lugar de modificar el array.</li> <li><code>int search(int element)</code>: Haciendo uso de la b\u00fasqueda binaria, se localizar\u00e1 el elemento dentro del array, en caso de que no exista, se devolver\u00e1 -1.</li> <li><code>boolean equals(int[] array)</code>: Devuelve <code>true</code> si ambos array tienen el mismo contenido, por el contrario devuelve <code>false</code>.</li> <li><code>String toString()</code>: Devuelve una cadena con el array, con el siguiente formato: <code>[0, 1, 2, 3, 4]</code>.</li> </ul> <p>Para este ejercicio, queda completamente prohibido utilizar los m\u00e9todos similares a los solicitados dentro de la clase <code>Arrays</code>.</p>"},{"location":"bloque_ii/tema_6/page-6/","title":"Proyecto","text":"<p>En este proyecto se va a realizar cambios en el proyecto conocido como common.</p> <p>Para ello, se debe modificar todas las funciones que se crean oportunas de la clase Strings y Maths haciendo uso de arrays, o de m\u00e9todos que devuelvan arrays si es necesario.</p> <p>Por otro lado, se a\u00f1adir\u00e1 los siguientes m\u00e9todos a la clase Maths:</p> <ul> <li>multiple(n, num): devolver\u00e1 los n m\u00faltiplos de un n\u00famero</li> <li>dividers(num): devolver\u00e1 los divisores de un n\u00fameros.</li> <li>primes(n): devolver\u00e1 los n primeros n\u00fameros primos comprendidos entre 0 y 100.</li> <li>primes(n, from, to): devolver\u00e1 los n primeros n\u00fameros primos comprendidos entre from, inclusivo, y end, exclusivo</li> <li>max(nums): obtiene el m\u00e1ximo valor de los n\u00fameros pasados por par\u00e1metros</li> <li>min(nums): obtiene el m\u00ednimo valor de los n\u00fameros pasados por par\u00e1metros.</li> <li>avg(nums): devolver\u00e1 la media de los n\u00fameros pasados como par\u00e1metros. Crear las versiones sobrecargadas para cada tipo de dato posible</li> <li>mode(nums): devolver\u00e1 la moda de los n\u00fameros pasados como par\u00e1metros. Crear las versiones sobrecargadas para cada tipo de dato posible</li> <li>median(nums): devolver\u00e1 la mediana de los n\u00fameros pasados como par\u00e1metros. Crear las versiones sobrecargadas para cada tipo de dato posible</li> <li>typicalDeviation(nums): devolver\u00e1 la desviaci\u00f3n t\u00edpica de los n\u00fameros pasados como par\u00e1metros. Crear las versiones sobrecargadas para cada tipo de dato posible</li> <li>variance(nums): devolver\u00e1 la varianza de los n\u00fameros pasados como par\u00e1metros. Crear las versiones sobrecargadas para cada tipo de dato posible</li> </ul> <p>Adem\u00e1s, en esta versi\u00f3n, se crear\u00e1 la clase Arrays que contendr\u00e1n m\u00e9todos de utilidad para trabajar con arrays:</p> <ul> <li>randomArray(n): devolver\u00e1 un array rellenado con n\u00fameros aleatorios entre el 0 y el 10 tantas veces como indique n. Comprobar que la capacidad indicada sea un n\u00famero positivo</li> <li>randomArray(n, fromIndex, toIndex): devolver\u00e1 un array rellenado con n\u00fameros aleatorios entre los indicados por par\u00e1metros, ambos inclusivos, tantas veces como indique n. Comprobar que la capacidad indicada sea un n\u00famero positivo</li> <li>add(array, element): a\u00f1adir\u00e1 el elemento al final del array. Crear las versiones sobrecargadas para cada tipo de dato.</li> <li>add(array, index, element): a\u00f1adir\u00e1 el elemento en el \u00edndice indicado del array, comprobando que el \u00edndice no supere el tama\u00f1o del array, y desplazando el resto de elementos, eliminando si fuese necesario el \u00faltimo valor. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>remove(array, index): elimina el elemento en el \u00edndice indicado, comprobando que el \u00edndice no supere el tama\u00f1o del array.</li> <li>set(array, index, element): reemplaza el elemento en el \u00edndice especificado de la lista con el nuevo elemento proporcionado, comprobando que el \u00edndice no supere el tama\u00f1o del array. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>indexOf(array, element): devuelve el primer \u00edndice del array que contenga el elemento indicado, en caso de no encontrarlo devolver\u00e1 -1. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>lastIndexOf(array, element): devuelve el \u00faltimo \u00edndice del array que contenga el elemento indicado, en caso de no encontrarlo devolver\u00e1 -1. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>isEmpty(array): retorna si el array est\u00e1 vac\u00edo, es decir, si no ha sido inicializado o todos sus valores son por defecto. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>isNotEmpty(array): retorna si el array no est\u00e1 vac\u00edo, es decir, si ha sido inicializado y adem\u00e1s tiene alg\u00fan valor que no sea el de por defecto. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>contains(array, element): retorna true si en el array se encuentra el elemento especificado, por el contrario devuelve false. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>notContains(array, element): retorna true si en el array no se encuentra el elemento indicado, por el contrario devuelve true. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>clear(array): vac\u00eda el array, dejando todos sus valor por defecto. Crear las versiones sobrecargadas para cada tipo de dato.</li> <li>addAll(array1, array2): A\u00f1ade todos los elementos del array2 en array1, retornando un nuevo array. Crear las versiones sobrecargadas para cada tipo de dato.</li> <li>subArray(array, fromIndex, toIndex): devuelve un nuevo array con los elementos del array desde el \u00edndice indicado (inclusivo) hasta el \u00edndice especificado (exclusivo), comprobando previamente, que los \u00edndices no superen el tama\u00f1o del array.</li> <li>reverse(array): Invierte el array. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>plus(arrayA, arrayB): suma ambos array retornando el resultado.</li> <li>minus(arrayA, arrayB): resta ambos array retornando el resultado.</li> <li>scalarProduct(n, arrayA): devuelve el array A multiplicando cada uno de sus elementos por n</li> <li>product(arrayA, arrayB): devuelve la multiplicaci\u00f3n de ambos arrays multiplicando cada elemento de A por cada elemento de B.</li> </ul> <p>Tambi\u00e9n se crear\u00e1 la clase Matrixs que contendr\u00e1 los m\u00e9todos de utilidad para trabajar con arrays bidimensionales:</p> <ul> <li>isRegular(array): devolver\u00e1 true si el array bidimensional es regular, false si no lo es. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>isIrregular(array): devolver\u00e1 true si el array bidimensional es irregular, false si no lo es.Crear las versiones sobrecargadas para cada tipo de dato</li> <li>randomMatrix(n, m): devolver\u00e1 una matriz rellenada con n\u00fameros aleatorios entre el 0 y el 10 tantas veces como indique n y m.</li> <li>randomMatrix(n, m, fromIndex, toIndex): devolver\u00e1 un array rellenado con n\u00fameros aleatorios entre los indicados por par\u00e1metros, ambos inclusivos, tantas veces como indique n y m.</li> <li>sum(matrix): devolver\u00e1 la suma de todos los elementos de la matriz.</li> <li>sumFiles(matrix): devolver\u00e1 la suma de todas las filas de la matriz.</li> <li>sumColumns(matrix): devolver\u00e1 la suma de todas las columnas de la matriz.</li> <li>sumDiagonal(matrix): devolver\u00e1 la suma de la diagonal de la matriz</li> <li>sumDiagonalReverse(matrix): devolver\u00e1 la suma de la diagonal inversa de la matriz.</li> <li>transpose(matrix): devolver\u00e1 la matriz transpuesta de la matriz indicada.</li> <li>isSymmetric(matrix): devolver\u00e1 true si la matriz indicada es sim\u00e9trica, o false si no lo es.</li> <li>determinant(matrix): calcula el determinante de la matriz.</li> <li>add(matrixA, matrixB): suma ambas matrices retornando el resultado.</li> <li>minus(matrixA, matrixB): resta ambas matrices retornando el resultado.</li> <li>scalarProduct(n, matrixA): devuelve la matriz A multiplicando cada uno de sus elementos por n</li> <li>product(matrixA, matrixB): devuelve la multiplicaci\u00f3n de ambas matrices multiplicando cada elemento de A por cada elemento de B.</li> </ul> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>NO se realizar\u00e1 una versi\u00f3n sobre el proyecto 5, sino que se realizar\u00e1 un copia de dicho proyecto en esta versi\u00f3n</li> <li>Se mantendr\u00e1 el paquete principal llamado <code>com.NOMBRE.common</code> donde nombre ser\u00e1 el nombre del alumno y common el nombre del proyecto.</li> <li>Se crear\u00e1 una clase Main, donde se ponga en pr\u00e1ctica los usos de la librer\u00eda y se valorar\u00e1 la complejidad de dicho Main.</li> <li>Se deber\u00e1n respetar el nombre de las funciones.</li> <li>El nombre del resto de funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre <code>pr06java-NOMBRE-arrays</code> siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_ii/tema_7/page-1/","title":"1 Introducci\u00f3n a la herencia","text":""},{"location":"bloque_ii/tema_7/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La herencia permite definir una clase tomando como base a otra clase ya existente. Dicha clase base se conoce como superclase o clase padre y la clase que hereda se denomina subclase o clase hija. Por lo tanto, una subclase es una versi\u00f3n especializada de una superclase, ya que hereda tanto los atributos como los m\u00e9todos definidos por la superclase y adem\u00e1s a\u00f1ade los suyos propios.</p> <p>Esto es una de las bases de la reutilizaci\u00f3n de c\u00f3digo ya que cuando se quiere crear una clase nueva y ya existe una clase que incluye parte del c\u00f3digo que queremos, podemos heredar nuestra nueva clase de la clase existente reutilizando los atributos y m\u00e9todos de la misma. La herencia facilita el trabajo del programador porque permite crear clases est\u00e1ndar y a partir de ellas crear nuestras propias clases personales. Esto es m\u00e1s c\u00f3modo que tener que crear todas las clases desde cero.</p> <p>Por ejemplo, si quisi\u00e9ramos realizar una aplicaci\u00f3n de veh\u00edculos, definir\u00edamos una superclase o clase padre con lo com\u00fan a todos los veh\u00edculos y luego definir\u00edamos una subclase o clase hija para cada tipo de veh\u00edculo donde se a\u00f1adir\u00eda lo particular de cada uno.</p> <p>En  java,  la  herencia  se  especifica  en  la  subclase  a\u00f1adiendo  la  palabra  extends  seguida  del nombre de la superclase. Por ejemplo, as\u00ed ser\u00eda para indicar que Coche es hija de Veh\u00edculo:</p> <pre><code>public class Car extends Vehicle{\n    // ...\n}\n</code></pre> <p>En Java, solamente se puede tener un padre pero puede hacer varios niveles de herencia, es decir, clases hijas que a su vez son padres de otras clases. Por ejemplo, el Car es hija de Vehicle pero puede ser padre de otra clase, como por ejemplo TodoTerreno:</p> <pre><code>public class TodoTerreno extends Car{\n    // ...\n}\n</code></pre> <p>Si  el  padre  tiene  alg\u00fan  atributo  est\u00e1tico,  tambi\u00e9n  lo  pueden  usar  los  hijos. <code>ClasePadre.AtributoEst\u00e1tico</code> y  <code>ClaseHijo.AtributoEst\u00e1tico</code> acceden a la misma variable porque es el mismo atributo est\u00e1tico.</p>"},{"location":"bloque_ii/tema_7/page-1/#modificadores-de-acceso","title":"Modificadores de acceso","text":"<p>En  el  tema  4.  Programaci\u00f3n  Orientada  a  Objetos  vimos  los  modificadores  de  acceso  y  c\u00f3mo afectaban a la visibilidad. En este tema vamos a incorporar el modificador de acceso protected que es el que est\u00e1 pensado para la herencia.</p> <p>Los modificadores de acceso afectan a la visibilidad y tambi\u00e9n afectan a la herencia. Visibilidad es lo que una clase puede ver de otra clase y herencia es lo que una clase hereda de otra clase. He aqu\u00ed dos tablas con los modificadores de acceso, una para la visibilidad y otra para la herencia</p> <p>Tabla de visibilidad</p> Private Friendly Protected Public Misma clase x x x x Mismo paquete x x x Otro paquete x Subclase en el mismo paquete x x x Subclase en distinto paquete x <p>Tabla de herencia</p> Private Friendly Protected Public Subclase en el mismo paquete x x x Subclase en distinto paquete x <p>Si las clases est\u00e1n en un subpaquete, a efectos de visibilidad y herencia se considera que est\u00e1n en otro paquete.</p> <p>Las conclusiones que se pueden obtener a partir de las dos tablas son las siguientes:</p> <ul> <li>La visibilidad es la misma independientemente de que la clase sea hija o no.</li> <li>En herencia, siempre se hereda el protected independientemente del paquete donde se encuentre  la  clase  hija.  Por  lo  tanto,  cuando  dise\u00f1emos  una  clase  que  vaya  a  tener descendientes, es conveniente declarar sus atributos como protected.</li> </ul> <p>Un atributo private no se hereda pero si los getters y setters del padre tienen un modificador distinto de private, s\u00ed puede el hijo utilizar dicho atributo a trav\u00e9s de dichos m\u00e9todos. Pero no es conveniente programar de esta manera, es m\u00e1s adecuado utilizar el modificador protected.</p> VehicleCarMainSalida <pre><code>public class Vehicle {\n    protected int wheelCount;\n    protected double speed;\n    protected String color;\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public void accelerate(double amount){\n        speed += amount;\n    }\n\n    public void brake(double amount){\n        speed -= amount;\n    }\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n    /*\n     * Car hereda de Vehicle los atributos wheelCount, speed y color porque\n     son protected\n     * Tambi\u00e9n hereda todos los m\u00e9todos de Vehicle, ya que son public\n     * Adem\u00e1s, puede tener atributos y m\u00e9todos propios\n     */\n    private double gasoline;\n\n    public double getGasoline() {\n        return gasoline;\n    }\n\n    public void refuel(double liters) {\n        gasoline += liters;\n    }\n}\n</code></pre> <pre><code>public class MainProtected {\n    public void show(){\n        Car car = new Car();\n\n        car.accelerate(100);\n        System.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\n\n        car.refuel(40.35);\n        System.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\n    }\n\n    public static void main(String[] args) {\n        new MainProtected().show();\n    }\n}\n</code></pre> <pre><code>La velocidad del coche es 100,00 km/h\nEl coche tiene 40,35 litros de gasolina\n</code></pre>"},{"location":"bloque_ii/tema_7/page-1/#sobrecarga-y-anulacion-de-metodos","title":"Sobrecarga y anulaci\u00f3n de m\u00e9todos","text":"<p>Se puede sobrecargar un m\u00e9todo heredado para proporcionar una versi\u00f3n del mismo adaptado a las necesidades de la subclase.</p> CarMainSalida <pre><code>public class Car extends Vehicle {\n    private double gasoline;\n\n    public double getGasoline() {\n        return gasoline;\n    }\n\n    public void refuel(double liters) {\n        gasoline += liters;\n    }\n\n    public void accelerate(){\n        speed += 10;\n    }\n}\n</code></pre> <pre><code>public class Overload {\n    public void show(){\n        Car car = new Car();\n\n        car.accelerate(100); // Heredado\n        System.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\n\n        car.accelerate(); // sobrecargado\n        System.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\n    }\n\n    public static void main(String[] args) {\n        new Overload().show();\n    }\n}\n</code></pre> <pre><code>La velocidad del coche es 100,00 km/h\nLa velocidad del coche es 110,00 km/h\n</code></pre> <p>Si la subclase define un m\u00e9todo con la misma firma que un m\u00e9todo heredado, entonces anula o sobrescribe el m\u00e9todo de la superclase. Veamos un ejemplo donde el coche ha anulado el m\u00e9todo heredado de acelerar para a\u00f1adirle el consumo de gasolina:</p> CarMainSalida <pre><code>public class Car extends Vehicle {\n    private double gasoline;\n\n    public double getGasoline() {\n        return gasoline;\n    }\n\n    public void refuel(double liters) {\n        gasoline += liters;\n    }\n\n    @Override\n    public void accelerate(double amount){\n        speed += amount;\n        gasoline *= 0.9;\n    }\n}\n</code></pre> <pre><code>public class MainOverride {\n    public void show(){\n        Car car = new Car();\n\n        car.refuel(40.35);\n        System.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\n\n        car.accelerate(100);\n\n        System.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\n    }\n\n    public static void main(String[] args) {\n        new MainOverride().show();\n    }\n}\n</code></pre> <pre><code>El coche tiene 40,35 litros de gasolina\nEl coche tiene 36,32 litros de gasolina\n</code></pre> <p>En  la  clase Car,  se  puede  observar  la  anotaci\u00f3n  @Override  antes  de  la  firma  del  m\u00e9todo accelerate.</p> <p>Las anotaciones de Java comienzan con @ y permiten incrustar informaci\u00f3n suplementaria en un programa para que pueda ser utilizada por varias herramientas.</p> <p>La anotaci\u00f3n @Override le indica al compilador que el m\u00e9todo debe sobrescribir un m\u00e9todo de la superclase.  Si  no  lo  hace,  el  compilador  generar\u00e1  un  error.  Se  utiliza  para  asegurar  que  un m\u00e9todo  de  superclase  est\u00e9  anulado,  y  no  simplemente  sobrecargado.  Es  una  manera  de comprobar en tiempo de compilaci\u00f3n que se est\u00e1 anulando correctamente un m\u00e9todo, y de este modo evitar errores en tiempo de ejecuci\u00f3n los cuales ser\u00edan mucho m\u00e1s dif\u00edciles de detectar.</p> <p>La visibilidad de lo que se hereda es con respecto al paquete de la superclase, no con respecto al paquete de la subclase. Si no interesa, la subclase tendr\u00e1 que sobrescribir lo heredado aunque no  haga  ning\u00fan  cambio  para  que  la  visibilidad  sea  con  respecto  al  paquete  de  la  subclase.</p> <p>Veamos un ejemplo donde Vehicle est\u00e1 en un paquete distinto que Car. Vehicle tiene el m\u00e9todo accelerate  como  protected,  por  lo  tanto  Car  lo  hereda  aunque  est\u00e9  en  otro  paquete  como podemos observar en la tabla de herencia. La clase Main se encuentra en el mismo paquete que Car y quiere acceder al m\u00e9todo accelerate del mismo. Pero la visibilidad de accelerate  es  con respecto al paquete de Vehicle  ya  que  la  visibilidad  de  lo  que  se  hereda  es  con  respecto  al paquete de la superclase, no con respecto al paquete de la subclase. Dicho m\u00e9todo es protected y si nos fijamos en la tabla de visibilidad, un protected no es visible desde otro paquete, por lo que no se le va a permitir dando un error de compilaci\u00f3n:</p> VehicleCarMain <pre><code>public class Vehicle {\n    protected int wheelCount;\n    protected double speed;\n    protected String color;\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    protected void accelerate(double amount){\n        speed += amount;\n    }\n\n    public void brake(double amount){\n        speed -= amount;\n    }\n}\n</code></pre> <pre><code>public class Car extends Vehicle {\n\n    private double gasoline;\n\n    public double getGasoline() {\n        return gasoline;\n    }\n\n    public void refuel(double liters) {\n        gasoline += liters;\n    }\n}\n</code></pre> <pre><code>public class Visibility {\n    public void show(){\n        exercises.bloque_ii.tema_07.modifier_protected.Car car = new Car();\n\n        car.accelerate(100); // Error de compilaci\u00f3n porque no es visible\n        System.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\n\n        car.refuel(40.35);\n        System.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\n    }\n\n    public static void main(String[] args) {\n        new Visibility().show();\n    }\n}\n</code></pre> <p>La soluci\u00f3n es que Car anule el m\u00e9todo accelerate heredado de Vehicle para que la visibilidad de dicho m\u00e9todo sea con respecto al paquete de Car. Car no va a realizar ning\u00fan cambio en dicho m\u00e9todo, es decir, lo va a anular para dejarlo exactamente igual, pero de esta forma modifica el paquete para la visibilidad:</p> <pre><code>public class Car extends Vehicle{\n    // ...\n    @Override\n    protected void accelerate(double amount){\n        speed += amount;\n    }\n}\n</code></pre> <p>Pero, \u00bfqu\u00e9 ocurrir\u00eda si la clase Main estuviera en un paquete distinto a Car? Dar\u00eda un error de compilaci\u00f3n porque un protected no es visible desde otro paquete.</p> <p>La soluci\u00f3n ser\u00eda que Car cambiara la visibilidad del m\u00e9todo. Si una subclase quiere anular alg\u00fan m\u00e9todo  de  la  superclase  para  cambiar  la  visibilidad,  se  permite  \u00fanicamente  si  amplia  la visibilidad, no si la reduce. La escala de valores de m\u00e1s restrictivo a menos es: private, friendly, protected y public. Por ejemplo, no se puede cambiar de protected a friendly pero s\u00ed al rev\u00e9s. Solucionemos el ejemplo anterior para que la clase Main pueda acceder al m\u00e9todo accelerate de Car. Si nos fijamos en la tabla de visibilidad, el \u00fanico modificador que nos permite visibilidad desde  otro  paquete  es  public.  Entonces,  tendr\u00edamos  que  cambiar  el  protected  a  public  y  se permite porque se amplia la visibilidad, no se reduce:</p> <pre><code>public class Car extends Vehicle{\n    // ...\n    @Override\n    public void accelerate(double amount){\n        speed += amount;\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-2/","title":"2 Constructores","text":""},{"location":"bloque_ii/tema_7/page-2/#super","title":"Super","text":"<p>A veces se requiere llamar a un m\u00e9todo de la superclase. Eso se realiza con la palabra reservada super. En el tema 4. Programaci\u00f3n Orientada a Objetos vimos que this es una variable que hace referencia al objeto actual, pues super es una variable que hace referencia a la superclase del objeto actual, por lo tanto es un m\u00e9todo imprescindible para poder acceder a m\u00e9todos anulados por herencia.</p> CarMainSalidas <pre><code>public class Car extends Vehicle {\n    private double gasoline;\n\n    public double getGasoline() {\n        return gasoline;\n    }\n\n    public void refuel(double liters) {\n        gasoline += liters;\n    }\n\n    @Override\n    public void accelerate(double amount){\n        super.accelerate(amount); // Llamo al accelerate del padre\n        gasoline *= 0.9;\n    }\n}\n</code></pre> <pre><code>public class Super {\n    public void show(){\n        Car car = new Car();\n\n        car.refuel(40.35);\n\n        System.out.printf(\"El coche tiene %.2f litros de gasolina, y va a %.2f km/h\\n\",\n                car.getGasoline(), car.getSpeed());\n\n        car.accelerate(100);\n\n        System.out.printf(\"El coche tiene %.2f litros de gasolina, y va a %.2f km/h\\n\",\n                car.getGasoline(), car.getSpeed());\n    }\n\n    public static void main(String[] args) {\n        new Super().show();\n    }\n}\n</code></pre> <pre><code>El coche tiene 40,35 litros de gasolina y va a 0,00 km/h\nEl coche tiene 36,32 litros de gasolina y va a 100,00 km/h\n</code></pre> <p>En el ejemplo anterior, super.accelerate(amount) llama al m\u00e9todo accelerate de la clase Vehicle el cual acelerar\u00e1 la marcha. Es necesario redefinir el m\u00e9todo accelerate en la clase Car  ya  que aunque la velocidad var\u00eda igual que en la superclase, hay que tener en cuenta el consumo de gasolina.</p>"},{"location":"bloque_ii/tema_7/page-2/#constructores","title":"Constructores","text":"<p>Los constructores no se heredan de la superclase a las subclases pero s\u00ed se pueden invocar los constructores de la superclase desde los constructores de las subclases mediante super:</p> VehicleCarMainSalida <pre><code>public class Vehicle{\n    // ...\n    public Vehicle(int wheelCount, String color) {\n        this.wheelCount = wheelCount;\n        this.color = color;\n        speed = 0;\n    }\n    // ...\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n    //...\n    public Car(int wheelCount, String color){\n        super(wheelCount, color); // Llama constructor del padre\n        gasoline = 0;\n    }\n    // ...\n}\n</code></pre> <pre><code>public class Constructors {\n    public void show(){\n        Vehicle vehicle = new Vehicle(2, \"azul\");\n        Car car = new Car(4, \"rojo\");\n\n        System.out.printf(\"Veh\u00edculo: %d ruedas y de color %s\\n\", vehicle.getWheelCount(), vehicle.getColor());\n        System.out.printf(\"Coche: %d ruedas y de color %s\\n\", car.getWheelCount(), car.getColor());\n    }\n\n    public static void main(String[] args) {\n        new Constructors().show();\n    }\n}\n</code></pre> <pre><code>Veh\u00edculo: 2 ruedas y de color azul\nCoche: 4 ruedas y de color rojo\n</code></pre> <p>Si una clase no tiene constructor, Java crea uno por defecto. Pero en el caso de que sea una subclase, Java lo crea con la l\u00ednea de c\u00f3digo super(), es decir, con una llamada al constructor de la superclase.</p> <p>Pero si la superclase tuviera un constructor con par\u00e1metros, Java ya no crear\u00eda el constructor por defecto Vehicle() y a las subclases les dar\u00eda un error de compilaci\u00f3n con la llamada del super():</p> VehicleCar <pre><code>public class Vehicle{\n    // ...\n    /*\n     * Tiene un constructor con par\u00e1metros, por lo tanto, Java\n     * no crea el constructor por defecto\n     * Vehicle()\n    */\n    public Vehicle(int wheelCount, String color) {\n        this.wheelCount = wheelCount;\n        this.color = color;\n        speed = 0;\n    }\n    // ...\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n    //...\n    /* \n     * No tiene constructor. Java lo crea por defecto con la l\u00ednea de c\u00f3digo \n     * super(), es decir, con una llamada al constructor por defecto de la\n     * superclase. Por lo tanto, est\u00e1 llamando a Vehicle(), dando un error \n     * de compilaci\u00f3n ya que no se ha creado. \n     */\n    // ...\n}\n</code></pre> <p>Incluso aunque se defina un constructor con par\u00e1metros en la clase Car, Java sigue a\u00f1adiendo de manera impl\u00edcita la llamada super() en el constructor y como no hay constructor por defecto en la clase Vehicle, contin\u00faa dando error de compilaci\u00f3n</p> <pre><code>public class extends Vehicle{\n    //...\n\n    /*\n     * Java sigue a\u00f1adiendo de manera impl\u00edcita la llamada super()\n     * en el constructor y como no hay constructor por defecto en\n     * la clase Vehicle, da un error de compilaci\u00f3n\n     */\n    public Car(int wheelCount, String color){\n        this.wheelCount = wheelCount;\n        this.color = color;\n        speed = 0;\n        gasoline = 0;\n    }\n    // ...\n}\n</code></pre> <p>Se  puede  arreglar  realizando  una  llamada  expl\u00edcita  al  constructor  con  par\u00e1metros  de  la superclase:</p> <pre><code>public class Car extends Vehicle{\n    //...\n    public Car(int wheelCount, String color){\n        super(wheelCount, color); // Llama constructor del padre\n        gasoline = 0;\n    }\n    // ...\n}\n</code></pre> <p>Si una subclase tiene m\u00e1s constructores, este problema habr\u00eda que arreglarlo en cada uno de ellos:</p> <pre><code>public class Car extends Vehicle{\n    //...\n    public Car(int wheelCount, String color){\n        super(wheelCount, color); // Llama constructor del padre\n        gasoline = 0;\n    }\n\n    public Car(int wheelCount){ // ERROR\n        this.wheelCount = count;\n        this.color = \"blanco\";\n        speed = 0;\n        gasoline = 0;\n    }\n    // ...\n}\n</code></pre> <p>Se puede solucionar de dos maneras:</p> <ol> <li>Haciendo una llamada a un constructor de la superclase mediante super.</li> <li>Haciendo una llamada a un constructor de la propia clase mediante this.</li> </ol> <p>En ambos casos, tienen que ser la primera instrucci\u00f3n del constructor, por lo que el uso de super y this no puede ser simult\u00e1neo, lo que significa que hay que elegir entre ambas.</p> Primera Soluci\u00f3nSegunda Soluci\u00f3n <pre><code>public class Car extends Vehicle{\n    //...\n    public Car(int wheelCount, String color){\n        super(wheelCount, color); // Llama constructor del padre\n        gasoline = 0;\n    }\n\n    public Car(int wheelCount){ \n        super(wheelCount, \"blanco\")\n        speed = 0;\n        gasoline = 0;\n    }\n    //...\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n    //...\n    public Car(int wheelCount, String color){\n        super(wheelCount, color); // Llama constructor del padre\n        gasoline = 0;\n    }\n\n    public Car(int wheelCount){ \n        this(wheelCount, \"blanco\")\n    }\n    //...\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-3/","title":"3 Polimorfismo","text":""},{"location":"bloque_ii/tema_7/page-3/#casting-de-objetos","title":"Casting de objetos","text":"<p>Como ocurre con los tipos primitivos, tambi\u00e9n es posible realizar casting entre objetos siempre y cuando est\u00e9 dentro de la estructura jer\u00e1rquica en su herencia.</p> <p>Para crear un objeto, hay que declarar una variable cuyo tipo es una clase:</p> <pre><code>Vehicle vehicle; // vehicle es una variable de tipo Vehicle\n</code></pre> <p>Eso significa que vehicle es de tipo Vehicle y que nunca va a cambiar de tipo, siempre va a ser de tipo Vehicle</p> <p>Creemos ahora una variable de tipo Car:</p> <pre><code>Car car; // car es una variable de tipo car.\n</code></pre> <p>Lo mismo que antes, car es una variable de tipo Car y nunca va a cambiar de tipo, siempre va a ser de tipo Car.</p> <p>A la variable vehicle se le puede asignar un objeto de tipo Vehicle y tambi\u00e9n se le puede asignar objetos cuyo tipo sean una subclase de Vehicle:</p> <pre><code>vehicle = car; // A vehicle se le est\u00e1 asignando un objeto de tipo Car, que es una subclase de Vehicle\n</code></pre> <p>La variable vehicle contiene un objeto de tipo Car pero su tipo es Vehicle, entonces solamente podr\u00e1 acceder a los atributos y m\u00e9todos de Vehicle:</p> <pre><code>vehicle.refuel(50); // Error de compilaci\u00f3n: el m\u00e9todo refuel no est\u00e1 definido para el tipo Vehicle\n</code></pre> <p>La variable vehicle no puede acceder al m\u00e9todo refuel porque dicho m\u00e9todo est\u00e1 definido en la clase Car. Es decir, una variable padre puede contener un objeto de tipo hijo pero solamente podr\u00e1 acceder a los atributos y m\u00e9todos definidos en el padre.</p> <p>\u00bfy si la asignaci\u00f3n la hici\u00e9ramos al rev\u00e9s, es decir, a car le asignamos vehicle?</p> <pre><code>car = vehicle; // Error de compilaci\u00f3n\n</code></pre> <p>Dar\u00eda un error de coincidencia de tipos, pero se podr\u00eda solucionar con un casting:</p> <pre><code>car = (Car) vehicle; // Solucionado con un casting ya que Vehicle contiene un Car\n</code></pre> <p>Hay que tener en cuenta que para que el casting funciones, la variable vehicle debe contener objeto de tipo Car, porque si no, dar\u00e1 un error de ejecuci\u00f3n ClassCastException.</p> <pre><code>vehicle = new Vehicle(2, \"blanco\");\ncar = (Car) vehicle; // Error de ejecuci\u00f3n: ClassCastException ya que Vehicle no contiene un objeto de tipo car\n</code></pre>"},{"location":"bloque_ii/tema_7/page-3/#modificador-final","title":"Modificador final","text":"<p>El modificador final tiene varios usos en funci\u00f3n de d\u00f3nde se utilice:</p> <ul> <li> <p>Delante de una variable en su declaraci\u00f3n, crea una constante. La constante puede recibir el valor en tiempo de compilaci\u00f3n o en tiempo de ejecuci\u00f3n.</p> Compilaci\u00f3nEjecuci\u00f3n <pre><code>final double PI = 3.141591;\n</code></pre> <p><pre><code>public class MyClass{\n    private final int NUMBER;\n\n    public MyClass(int n){\n        NUMBER = n;\n    }\n}\n</code></pre> La constante NUMBER recibe el valor en la construcci\u00f3n del objeto.</p> </li> <li> <p>Delante de una variable que referencia a un objeto: dicha variable no puede referenciar a otro objeto.</p> <pre><code>final Car car = new Car(4, \"rojo\");\ncar = new Car(4, \"blanco\"); //ERROR: no puede referencias a otro objeto\n</code></pre> </li> <li> <p>En la declaraci\u00f3n de un m\u00e9todo: dicho m\u00e9todo no se puede anular por las subclases:</p> VehicleCar <pre><code>public class Vehicle{\n    //...\n    final public void accelerate(double amount){\n        speed += amount;\n    }\n    //...\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n    //...\n    @Override\n    public void accelerate(double amount){ // ERROR, no se puede anular el m\u00e9todo\n        super.accelerate(amount);\n        gasoline *= 0.5;\n    }\n    // ...\n}\n</code></pre> <ul> <li>En la definici\u00f3n de una clase: significa que ese clase no puede tener descendencia.</li> </ul> </li> </ul>"},{"location":"bloque_ii/tema_7/page-3/#polimorfismo","title":"Polimorfismo","text":"<p>Polimorfismo es la capacidad de un objeto de adquirir varias formas.</p> <p>La sobrecarga de m\u00e9todos es un tipo de polimorfismo est\u00e1tico porque se resuelve en tiempo de compilaci\u00f3n el m\u00e9todo apropiado a ser llamado basado en la lista de argumentos.</p> <p>La anulaci\u00f3n de m\u00e9todos es un tipo de polimorfismo din\u00e1mico porque se resuelve en tiempo de ejecuci\u00f3n atendiendo al tipo del objeto. Con una variable de tipo padre, si se utiliza un objeto del padre para invocar al m\u00e9todo, entonces se ejecutar\u00e1 el m\u00e9todo de la clase padre, pero si se utiliza un objeto de la clase hija para invocar al m\u00e9todo, entonces se ejecutar\u00e1 el m\u00e9todo de la clase hija</p> <pre><code>public class Polimorfismo {\n    public void show(){\n        Vehicle vehicle = new Vehicle(2, \"azul\");\n        vehicle.accelerate(100.39); // M\u00e9todo del padre\n        System.out.printf(\"La velocidad del veh\u00edculo es %.2f km/h\\n\", vehicle.getSpeed());\n\n        vehicle = new Car(4, \"rojo\");\n        vehicle.accelerate(50.89); // M\u00e9todo del hijo\n        System.out.printf(\"La velocidad del veh\u00edculo es %.2f km/h\\n\", vehicle.getSpeed());\n    }\n\n    public static void main(String[] args) {\n        new Polimorfismo().show();\n    }\n}\n</code></pre> <p>Otro de las ventajas del polimorfismo es poder tener un m\u00e9todo que solicite un padre, y poder pasarle un hijo:</p> <pre><code>public class Polimorfismo2 {\n    public void show(){\n        accelerateVehicle(new Car(4, \"rojo\"));\n    }\n\n    private void accelerateVehicle(Vehicle vehicle) {\n        vehicle.accelerate(100.39); // M\u00e9todo del padre\n        System.out.printf(\"La velocidad del veh\u00edculo es %.2f km/h\\n\", vehicle.getSpeed());s\n    }\n\n    public static void main(String[] args) {\n        new Polimorfismo2().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-3/#instanceof","title":"instanceof","text":"<p>El  operador  instanceof  permite  comprobar  si  un  determinado  objeto  pertenece  a  una  clase concreta. Se utiliza de esta forma:</p> <pre><code>object instanceof class\n</code></pre> <p>Devuelve true si el objeto pertenece a dicha clase.</p> <pre><code>public class InstanceOf {\n    public void show(){\n        Vehicle vehicle = new Vehicle(2, \"azul\");\n        Car car = new Car(4, \"rojo\");\n\n        System.out.println(vehicle instanceof Vehicle); // true\n        System.out.println(vehicle instanceof Car); // false\n        System.out.println(car instanceof Vehicle); // true\n        System.out.println(car instanceof Car); // true\n    }\n\n    public static void main(String[] args) {\n        new InstanceOf().show();\n    }\n}\n</code></pre> <p>Tal y como podemos observar en el ejemplo, car tambi\u00e9n devuelve true con Vehicle ya que los objetos de las subclases tambi\u00e9n devuelven true con la superclase.</p>"},{"location":"bloque_ii/tema_7/page-3/#tostring","title":"toString","text":"<p>La clase Object es la clase ra\u00edz de todo el \u00e1rbol de la jerarqu\u00eda de clases Java, es decir, es una superclase impl\u00edcita de todas las dem\u00e1s clases. En otras palabras, todas las dem\u00e1s clases son subclases de Object. Esto significa que una variable de referencia de tipo Object puede referirse a un objeto de cualquier otra clase.</p> <p>La clase Object proporciona un cierto n\u00famero de m\u00e9todos de utilidad general que pueden utilizar todos  los  objetos  ya  que  los  heredan.  Pero  normalmente  hay  que  sobrescribirlos  para  que funcionen adecuadamente adapt\u00e1ndolos a la clase correspondiente. Esto se hace con la idea de que todas las clases utilicen el mismo nombre y prototipo de m\u00e9todo para hacer operaciones comunes. Como por ejemplo, <code>toString()</code> que se utiliza para obtener una cadena de texto que represente al objeto. El m\u00e9todo toString() de la clase Object devuelve una cadena que consiste en el nombre de la clase del objeto, el car\u00e1cter arroba \u2018@\u2019 y la representaci\u00f3n hexadecimal sin signo del c\u00f3digo hash del objeto. Siempre se recomienda sobrescribir el m\u00e9todo toString() para obtener nuestra propia representaci\u00f3n del objeto.</p> <pre><code>public class Vehicle{\n    //...\n    @Override\n    public String toString() {\n        return \"Vehicle [wheelCount=\" + wheelCount+ \", speed=\" + speed + \", color=\" + color + \"]\";\n    }\n}\n</code></pre> <p>Algunos entornos IDEs, puede autogenerar el c\u00f3digo del m\u00e9todo toString.</p> <p>Haciendo uso del m\u00e9todo para sacar por consola un objeto no es necesario hacer toString de forma expl\u00edcita, ya que dicho m\u00e9todo lo llama de forma impl\u00edcita.</p> <pre><code>public class ToString {\n    public void show(){\n        Vehicle vehicle = new Vehicle(2, \"azul\");\n\n        System.out.println(vehicle);\n    }\n\n    public static void main(String[] args) {\n        new ToString().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-4/","title":"4 Clases abstractas e interfaces","text":""},{"location":"bloque_ii/tema_7/page-4/#clases-abstractas","title":"Clases abstractas","text":"<p>Cuando se crea una estructura con herencia, puede darse el caso de que alg\u00fan m\u00e9todo del padre no se pueda implementar porque los detalles de la implementaci\u00f3n dependan de cada uno de los hijos. Entonces, dicho m\u00e9todo se declara como abstracto en el padre y solamente se define su firma, no se implementa c\u00f3digo en \u00e9l. Los hijos pueden hacer dos cosas:</p> <ol> <li>Implementar el c\u00f3digo de dicho m\u00e9todo.</li> <li>Declararlo tambi\u00e9n como abstracto.</li> </ol> <p>Si  la  clase  contiene  alg\u00fan  m\u00e9todo  abstracto,  se  convierte  en  una  clase  abstracta.  Una  clase abstracta puede contener m\u00e9todos no abstractos pero al menos uno de los m\u00e9todos debe ser abstracto.</p> <p>Para indicar en Java que un m\u00e9todo o una clase son abstractos, se utiliza la palabra reservada abstract.</p> VehicleCarMainSalida <pre><code>public abstract class Vehicle {\n    // ...\n    public abstract void accelerate(double amount);\n    //..\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n    // ...\n    @Override\n    public void accelerate(double amount){\n        speed += amount;\n        gasoline *= 0.9;\n    }\n}\n</code></pre> <pre><code>public class AbstractClass {\n    public void show(){\n        Car car = new Car(4, \"rojo\");\n\n        System.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\n\n        car.refuel(40.35);\n        System.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\n\n        car.accelerate(100);\n        System.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\n        System.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\n    }\n\n    public static void main(String[] args) {\n        new AbstractClass().show();\n    }\n}\n</code></pre> <pre><code>La velocidad del coche es 0,00 km/h\nEl coche tiene 40,35 litros de gasolina\nLa velocidad del coche es 100,00 km/h\nEl coche tiene 36,32 litros de gasolina\n</code></pre> <p>Una clase abstracta no se puede instanciar, es decir, no se pueden crear objetos de ella haciendo uso del new:</p> <pre><code>Vehicle = new Vehicle(2, \"azul\"); // Error de compilaci\u00f3n\n</code></pre> <p>Haciendo  uso  del  polimorfismo,  se  puede  declarar  una  variable  de  una  clase  abstracta  que referencie a un objeto hijo, de tal forma que si se invoca el m\u00e9todo abstracto, se ejecutar\u00e1 la implementaci\u00f3n realizada por el hijo de dicho m\u00e9todo abstracto:</p> <pre><code>Vehicle vehicle = new Car(4, \"rojo\");\n\nvehicle.accelerate(50.89); //(1)!\nSystem.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\n</code></pre> <ol> <li>Se ejecuta la implementaci\u00f3n realizada en Car del m\u00e9todo abstracto accelerate</li> </ol>"},{"location":"bloque_ii/tema_7/page-4/#interfaces","title":"Interfaces","text":"<p>Una  interfaz  en  Java  es  una  colecci\u00f3n  de  m\u00e9todos  abstractos,  es  decir,  en  una  interfaz  se especifica qu\u00e9 se debe hacer pero no c\u00f3mo hacerlo. Ser\u00e1n las clases que implementen estas interfaces las que describen la l\u00f3gica del comportamiento de los m\u00e9todos.</p> <p>Una clase puede implementar m\u00e1s de una interfaz, lo que implica que debe realizar todos los m\u00e9todos de cada una de ellas. Si alg\u00fan m\u00e9todo lo deja como abstracto, entonces se convierte en una clase abstracta.</p> <p>En una interfaz tambi\u00e9n se pueden declarar constantes que luego puedan ser utilizadas por las clases que implementen dicha interfaz.</p> <p>Una interfaz se define en un archivo con el mismo nombre de la interfaz y con extensi\u00f3n .java.</p> <p>Las clases que quieran implementarla, tienen que a\u00f1adir la palabra reservada implements detr\u00e1s del nombre de la clase.</p> <p>Veamos un ejemplo de una interfaz que va a contener acciones que pueda realizar un veh\u00edculo, como por ejemplo, acelerar y frenar:</p> InterfazVehicle <pre><code>public interface ActionVehicle {\n    void accelerate(double amount);\n    void brake(double amount);\n}\n</code></pre> <pre><code>public class Vehicle implements ActionVehicle{\n    @Override\n    public void accelerate(double amount){\n        speed += amount;\n    }\n\n    @Override\n    public void brake(double amount){\n        speed -= amount;\n    }\n}\n</code></pre> <p>Para comprobar si una clase implementa una interfaz se puede usar <code>instanceof</code>:</p> <pre><code>Vehicle vehicle = new Vehicle(2, \"rojo\");\nvehicle instanceof Vehicle; // true\n</code></pre>"},{"location":"bloque_ii/tema_7/page-4/#herencia-entre-interfaces","title":"Herencia entre interfaces","text":"<p>Las  interfaces  tambi\u00e9n  pueden  heredar  de  otras  interfaces.  En  este  caso,  la  clase  que implemente la interfaz hija tendr\u00e1 que realizar los m\u00e9todos de la interfaz hija y los m\u00e9todos de la interfaz  padre.  Por  ejemplo,  vamos  a  crear  una  interfaz  GasolineMotor  que  va  a  contener m\u00e9todos de un veh\u00edculo con motor de gasolina y que herede de la interfaz ActionsVehicle:</p> GasolineMotorCar <pre><code>public interface GasolineMotor extends ActionVehicle {\n    double getGasoline();\n    void refuel(double liters);\n}\n</code></pre> <pre><code>public class Car extends Vehicle implements GasolineMotor {\n    //...\n    @Override\n    public double getGasoline() {\n        return gasoline;\n    }\n\n    @Override\n    public void refuel(double liters) {\n        gasoline += liters;\n    }\n    //...\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-4/#metodos-por-defecto","title":"M\u00e9todos por defecto","text":"<p>A partir de Java 8, se pueden definir m\u00e9todos con una implementaci\u00f3n por defecto dentro de las interfaces. Las clases que implementan la interfaz pueden usar dicho m\u00e9todo o anularlo si les interesa otra implementaci\u00f3n diferente.</p> <p>Para indicar que un m\u00e9todo es por defecto se utiliza la palabra reservada default.</p> <p>Por ejemplo, si definimos la siguiente interfaz con el siguiente m\u00e9todo por defecto:</p> <pre><code>public interface Interfaz1{\n    default void method(String str){\n        // Implementaci\u00f3n del m\u00e9todo\n    }\n}\n</code></pre> <p>y ahora queremos crear una clase que implemente la interfaz, dicha clase no estar\u00e1 obligada a implementar el m\u00e9todo  <code>method()</code>. Por ejemplo, el siguiente c\u00f3digo es totalmente v\u00e1lido:</p> <pre><code>public class Class1 implements Interfaz1{\n    // No estamos obligados a implementar method(), aunque\n    // tenemos la posibilidad de anularlo\n}\n</code></pre> <p>Pero  \u00bfqu\u00e9  ocurre  si  una  clase  implementa  dos  interfaces  que  tienen  el  mismo  m\u00e9todo  con implementaci\u00f3n por defecto? En ese caso la clase estar\u00e1 obligada a anular dicho m\u00e9todo, porque no se puede decidir qu\u00e9 implementaci\u00f3n por defecto usar. Por ejemplo:</p> <pre><code>public interface Interfaz1{\n    default void method1(String str){\n        //Implementaci\u00f3n\n    }\n}\n\npublic interface Interfaz2{\n    default void method1(String str){\n        //Implementaci\u00f3n\n    }\n}\n\npublic class Class1 implements Interfaz1, Interfaz2{\n\n    @Override // Estamos oblogado a deshacer la ambig\u00fcedad\n    void method1(String str){\n        //Implementaci\u00f3n en Clase1\n    }\n}\n</code></pre> <p>\u00a1Cuidado!</p> <p>Un m\u00e9todo con implementaci\u00f3n por defecto no puede anular a un m\u00e9todo de la clase  <code>java.lang.Object</code>, ya que es la clase base de todas las clases.</p>"},{"location":"bloque_ii/tema_7/page-4/#metodos-estaticos","title":"M\u00e9todos est\u00e1ticos","text":"<p>A partir de Java 8, las interfaces tambi\u00e9n puede contener m\u00e9todos est\u00e1ticos con implementaci\u00f3n por  defecto,  cuya  caracter\u00edstica  principal  es  que  pueden  ser  anulados  por  las  clases  que implementan la interfaz para evitar implementaciones no correctas en dichas clases. Se usan sobre todo para m\u00e9todos de utilidad. Veamos un ejemplo:</p> <pre><code>public interface Interfaz3 {\n    default void print(String str){\n        // Se llama al m\u00e9todo est\u00e1tico de la interfaz desde otro\n        // m\u00e9todo default de la interfaz\n        if(!isNull(str)){\n            System.out.println(\"Cadena: \" + str);\n        }\n    }\n\n    static boolean isNull(String str){\n        System.out.println(\"Interface Null Check\");\n        return str == null ? true : \"\".equals(str) ? true : false;\n    }\n}\n</code></pre> <p>Un m\u00e9todo est\u00e1tico con implementaci\u00f3n por defecto de una interfaz, como el m\u00e9todo <code>isNull()</code> anterior, puede ser llamado desde otro m\u00e9todo de la propia interfaz , por ejemplo desde el m\u00e9todo <code>print()</code>.</p> <p>Tambi\u00e9n puede ser llamado est\u00e1ticamente usando el nombre de la interfaz, como en:</p> <pre><code>boolean resultado = Interfaz3.isNull(\"abc\");\n</code></pre> <p>Pero no puede ser llamado a trav\u00e9s de una instancia de una clase que implemente la interfaz. Por ejemplo, el siguiente c\u00f3digo da un error de compilaci\u00f3n:</p> <pre><code>Class1 myObject = new Class1();\nmyObject.isNull(\"hola\"); // ERROR de compilaci\u00f3n\n</code></pre> <p>No  se  pueden  definir  en  una  interfaz  m\u00e9todos  est\u00e1ticos  con  implementaci\u00f3n  que  tengan  la misma firma que m\u00e9todos de la clase  java.lang.Object , ya que es la clase base de todas las clases.</p>"},{"location":"bloque_ii/tema_7/page-4/#metodos-privados","title":"M\u00e9todos privados","text":"<p>A  partir  de  Java  9,  las  interfaces  pueden  contener  m\u00e9todos  privados,  que  s\u00f3lo  pueden  ser llamados desde m\u00e9todos default de dicha interfaz u otros m\u00e9todos privados de la misma. Sirven, b\u00e1sicamente,  para  poder  separar  el  c\u00f3digo  de  m\u00e9todos  con  implementaci\u00f3n  por  defecto. Veamos un ejemplo:</p> <pre><code>public interface Interfaz4{\n    // Este m\u00e9todo privado s\u00f3lo puede ser llamado por m\u00e9todos default\n    // de la misma interfaz.\n    private int getNumeroAleatorio(){\n        return (new Random()).nextInt(100);\n    }\n\n    default String method1(String s){\n        // Un m\u00e9todo default puede llamar a un m\u00e9todo privado de la interfaz\n        return s + getNumeroAleatorio();\n    }\n}\n</code></pre> <p>A partir de Java 9 tambi\u00e9n podemos definir en una interfaz m\u00e9todos est\u00e1ticos privados, que s\u00f3lo podr\u00e1n ser llamados desde otros m\u00e9todos est\u00e1ticos de la interfaz. Sirven, b\u00e1sicamente, para poder separar el c\u00f3digo de m\u00e9todos est\u00e1ticos de la interfaz. Por ejemplo:</p> <pre><code>public interface Interfaz5{\n    private static String getPrefix(String p){\n        return p.equals(\"male\") ? \"Mr. \" : \"Ms. \"\n    }\n\n    public static String getName(String n, String p){\n        return getPrefix(p) + n;\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-4/#diferencias-entre-una-interfaz-y-una-clase-abstracta","title":"Diferencias entre una interfaz y una clase abstracta","text":"<p>Pero  entonces,  si  las  interfaces  pueden  tener  m\u00e9todos  con  implementaci\u00f3n  por  defecto  y m\u00e9todos privados \u00bfqu\u00e9 diferencia hay entre una interfaz con m\u00e9todos por defecto y una clase abstracta? La diferencia principal es que una interfaz no tiene estado, es decir no podemos almacenar atributos en ella, mientras que una clase abstracta s\u00ed.</p>"},{"location":"bloque_ii/tema_7/page-4/#utilizacion-de-una-interfaz-como-un-tipo-de-dato","title":"Utilizaci\u00f3n de una interfaz como un tipo de dato","text":"<p>Al declarar una interfaz, se declara un nuevo tipo de datos, lo que significa que se puede declarar una variable cuyo tipo es una interfaz. Pero, \u00bfqu\u00e9 va a contener dicha variable? Puede contener un objeto de cualquier clase que implemente dicha interfaz. Con dicha variable, las acciones que se pueden realizar son los m\u00e9todos de la interfaz.</p> <pre><code>public class Interfaces {\n\n    public void show(){\n        Vehicle vehicle = new Vehicle(2, \"rojo\");\n        ActionVehicle actionVehicle;\n\n        System.out.printf(\"La velocidad del veh\u00edculo es %.2f km/h\\n\", vehicle.getSpeed());\n\n        actionVehicle = vehicle;\n        actionVehicle.accelerate(100.30);\n        System.out.printf(\"La velocidad del veh\u00edculo es %.2f km/h\\n\", vehicle.getSpeed());\n    }\n\n    public static void main(String[] args) {\n        new Interfaces().show();\n    }\n}\n</code></pre> <p>\u00a1OJO!</p> <p>Con una variable de tipo interfaz, las acciones que se pueden realizar son los m\u00e9todos de la interfaz, es decir, con una variable de tipo ActionsVehicle lo que se puede realizar son los m\u00e9todos accelerate y brake que son los m\u00e9todos que pertenecen a la interfaz. Si intent\u00e1ramos realizar un getSpeed que pertenece a la clase Vehicle y no se encuentra entre los m\u00e9todos de la interfaz, nos dar\u00eda un error de compilaci\u00f3n.</p> <pre><code>ActionVehicle actionVehicle = vehicle;\nvehicle.getSpeed(); // ERROR\n</code></pre>"},{"location":"bloque_ii/tema_7/page-5/","title":"5 Clases anidadas","text":""},{"location":"bloque_ii/tema_7/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>En Java se permite escribir una clase dentro de otra clase. La clase de dentro se llama clase anidada y la que la contiene, clase contenedora o externa.</p> <p>Estas clases se utilizan con los siguientes prop\u00f3sitos:</p> <ul> <li>Agrupaci\u00f3n de clases relacionadas.</li> <li>Control de visibilidad de las clases.</li> <li>Proximidad entre la definici\u00f3n y el uso de las clases.</li> <li>Definici\u00f3n de clases simples de ayuda o adaptaci\u00f3n.</li> <li>C\u00f3digo m\u00e1s claro que evita el exceso de clases muy peque\u00f1as que no necesitan conocer los usuarios de un paquete.</li> </ul> <p>Las  clases  anidadas  se  dividen  en  dos  categor\u00edas:  las  clases  anidadas  est\u00e1ticas  y  las  clases anidadas no est\u00e1ticas o clases internas.</p>"},{"location":"bloque_ii/tema_7/page-5/#clases-anidadas-estaticas","title":"Clases anidadas est\u00e1ticas","text":"<p>Son clases declaradas de tipo static que se comportan como una clase normal de Java pero que se encuentran dentro de otra clase. Tambi\u00e9n se pueden usar dentro de una interfaz.</p> <p>Desde la clase anidada est\u00e1tica solamente se pueden acceder a los atributos est\u00e1ticos de la clase contenedora.</p> <p>Se pueden crear objetos sin crear ning\u00fan objeto de la clase contenedora.</p> <p>Para hacer referencia a una clase anidada est\u00e1tica hay que indicar tambi\u00e9n la clase contenedora: <code>ClaseContenedora.ClaseAnidada</code>.</p> ContainerClassMainSalida <pre><code>public class ContainerClass {\n    public static class StaticNestedClass{\n        public void staticNestedMethod(){\n            System.out.println(\"Clase anidada est\u00e1tica\");\n        }\n    }\n\n    public void containerMethod(){\n        System.out.println(\"Clase externa o contenedora\");\n    }\n}\n</code></pre> <pre><code>public class ShowStaticNestedClass {\n    public void show(){\n        ContainerClass.StaticNestedClass nested = new ContainerClass.StaticNestedClass();\n        nested.staticNestedMethod();\n\n        ContainerClass container = new ContainerClass();\n        container.containerMethod();\n    }\n\n    public static void main(String[] args) {\n        new ShowStaticNestedClass().show();\n    }\n}\n</code></pre> <pre><code>Clase anidada est\u00e1tica\nClase externa o contenedora\n</code></pre>"},{"location":"bloque_ii/tema_7/page-5/#clases-anidadas-no-estaticas-o-clases-internas","title":"Clases anidadas no est\u00e1ticas o clases internas","text":"<p>Las clases anidadas no est\u00e1ticas o clases internas tienen acceso a todos los atributos y m\u00e9todos de la clase contenedora, por lo tanto, para que exista un objeto de una clase interna es necesario que exista un objeto de la clase contenedora.</p> ContainerMainSalida <pre><code>public class ContainerClass {\n    private int numContainer = 10;\n\n    public class InnerClass{\n        public void innerMethod(){\n            System.out.printf(\"Clase interna. Puede acceder a la numContainer: %d\\n\", numContainer);\n        }\n    }\n\n    public void containerMethod(){\n        InnerClass innerClass = new InnerClass();\n        innerClass.innerMethod();\n    }\n}\n</code></pre> <pre><code>public class ShowInnerClass {\n    private void show() {\n        ContainerClass container = new ContainerClass();\n        container.containerMethod();\n    }\n\n    public static void main(String[] args) {\n        new ShowInnerClass().show();\n    }\n}\n</code></pre> <pre><code>Clase interna. Puede acceder a numContainer: 10\n</code></pre> <p>Tambi\u00e9n se puede crear un objeto de la clase interna desde fuera de la clase externa siempre y cuando la clase interna sea visible:</p> <pre><code>ContainerClass container = new ContainerClass();\nContainerClass.InnerClass inner = container.new InnerClass();\ninner.innerMethod();\n</code></pre> <p>Se puede hacer una clasificaci\u00f3n de las clases internas en funci\u00f3n de d\u00f3nde y c\u00f3mo se utilicen:</p> <ul> <li>Clases miembro</li> <li>Clases dentro de un m\u00e9todo.</li> <li>Clases dentro de un bloque.</li> <li>Clases an\u00f3nimas</li> </ul>"},{"location":"bloque_ii/tema_7/page-5/#clases-internas-miembro","title":"Clases internas miembro","text":"<p>Se  utilizan  como  atributos  de  la  clase  contenedora.  Si  se  declaran  como  privadas,  la  clase contenedora es la \u00fanica que conoce su existencia.</p> ContainerMainSalida <pre><code>public class ContainerClass {\n    private int num = 10;\n    private InnerClass inner = new InnerClass();\n\n    private class InnerClass{\n        private int num = 20;\n\n        public void innerMethod(){\n            System.out.printf(\"N\u00famero de la contenedora: %d. N\u00famero de la interna: %d\\n\",\n                    ContainerClass.this.num, num);\n        }\n    }\n\n    public void containerMethod(){\n        inner.innerMethod();\n    }\n}\n</code></pre> <pre><code>public class ShowInnerMemberClass {\n    private void show() {\n        ContainerClass container = new ContainerClass();\n        container.containerMethod();\n    }\n\n    public static void main(String[] args) {\n        new ShowInnerMemberClass().show();\n    }\n}\n</code></pre> <pre><code>N\u00famero de la contenedora: 10. N\u00famero de la interna: 20\n</code></pre> <p>Al usar this dentro de una clase interna, \u00e9ste se refiere al objeto de la clase interna. Para poder referirse al objeto de la clase contenedora, hay que anteponerle al this el nombre de dicha clase, tal y como se puede observar en el ejemplo: <code>ContainerClass.this.num</code>.</p>"},{"location":"bloque_ii/tema_7/page-5/#clases-internas-dentro-de-un-metodo","title":"Clases internas dentro de un m\u00e9todo","text":"<p>Se definen dentro de un m\u00e9todo de la clase contenedora por lo que solamente se pueden utilizar dentro de dicho m\u00e9todo.</p> <p>Se utilizan cuando el m\u00e9todo intenta solucionar un problema y necesita apoyarse en una clase pero no se necesita que esta clase est\u00e9 disponible fuera, por lo tanto, son clases que quedan fuera del dise\u00f1o.</p> <p>La clase interna tiene acceso a los m\u00e9todos y atributos de la clase contenedora y a las variables locales y par\u00e1metros del m\u00e9todo donde se la declara.</p> ContainerMainSalida <pre><code>public class ContainerClass {\n    private int attribute = 10;\n\n    public void containerMethod(int parameter){\n        int localVariable = 20;\n\n        class InnerClass{\n            public void innerMethod(){\n                System.out.printf(\"Clases interna a m\u00e9todo---&gt;\\nAtributo de la clase contenedora: %d\\n\", attribute);\n                System.out.printf(\"Variable local: %d\\n\", localVariable);\n                System.out.printf(\"Par\u00e1metro: %d\\n\", parameter);\n            }\n        }\n    }\n}\n</code></pre> <pre><code>public class ShowInnerMethodClass {\n    private void show() {\n        ContainerClass container = new ContainerClass();\n        container.containerMethod(30);\n    }\n\n    public static void main(String[] args) {\n        new ShowInnerMethodClass().show();\n    }\n}\n</code></pre> <pre><code>Clase interna a m\u00e9todo---&gt;\nAtributo de la contenedora: 10\nVariable local: 20\nPar\u00e1metro: 30\n</code></pre>"},{"location":"bloque_ii/tema_7/page-5/#clases-internas-dentro-de-un-bloque","title":"Clases internas dentro de un bloque","text":"<p>S\u00f3lo son visibles y utilizables dentro del bloque de c\u00f3digo en el que se encuentran definidas.</p> ContainerMainSalida <pre><code>public class ContainerClass {\n    private int attribute = 10;\n\n    public void containerMethod(int parameter){\n        int localVariable = 20;\n\n        if(parameter &gt; localVariable){\n            class InnerClass{\n                public void innerMethod(){\n                    System.out.printf(\"Clase interna a bloque---&gt;\\nAtributo de la contenedora: %d\\n\", attribute);\n                    System.out.printf(\"Variable local: %d\\n\", localVariable);\n                    System.out.printf(\"Par\u00e1metro; %d\\n\", parameter);\n                }\n            }\n            InnerClass inner = new InnerClass();\n            inner.innerMethod();\n        }\n    }\n}\n</code></pre> <pre><code>public class ShowInnerBlockClass {\n    public void show(){\n        ContainerClass container = new ContainerClass();\n        container.containerMethod(30);\n    }\n\n    public static void main(String[] args) {\n        new ShowInnerBlockClass().show();\n    }\n}\n</code></pre> <pre><code>Clase interna a bloque---&gt;\nAtributo de la contenedora: 10\nVariable local: 20\nPar\u00e1metro: 30\n</code></pre> <p>\u00a1Cuidado!</p> <p>Si se intenta utilizar la clase fuera del bloque, da un error de compilaci\u00f3n informando que la clase no puede ser resulta como tipo</p>"},{"location":"bloque_ii/tema_7/page-5/#clases-inline-anonimas","title":"Clases inline an\u00f3nimas","text":"<p>Son clases sin nombre que se definen e instancian en una sola operaci\u00f3n. Este tipo de clases se utiliza cuando se quiere anular el m\u00e9todo de una clase o implementar una interfaz solamente para un momento puntual evitando crear una clase nueva para un solo uso. El t\u00e9rmino inline se debe a que en el cuerpo de un m\u00e9todo se puede escribir una clase ah\u00ed mismo, en la l\u00ednea, es decir, sin necesidad de hacerlo en otro archivo.</p> <p>Por ejemplo, tenemos la siguiente class Class:</p> <pre><code>public class Class{\n    protected String message = \"Clases inline an\u00f3nimas\";\n\n    public void showMessage(){\n        System.out.println(message);\n    }\n}\n</code></pre> <p>Supongamos que queremos anular el m\u00e9todo <code>showMessage()</code> para mostrar el mensaje en rojo en un momento puntual y creamos una subclase o clase hija de Class que sobrescribiera el m\u00e9todo:</p> <pre><code>public class Subclass extends Class{\n\n    @Override\n    public void showMessage(){\n        System.out.println(RED + message + RESET);\n    }\n}\n</code></pre> <p>Entonces estar\u00edamos creando una clase para algo que vamos a hacer solamente una vez. Y si quisi\u00e9ramos en otro momento hacer lo mismo pero en azul, tendr\u00edamos que crear otra subclase para hacerlo. Entonces, la soluci\u00f3n es crear una clase inline an\u00f3nima. Se llama an\u00f3nima porque en ning\u00fan otro momento aparece el nombre <code>Subclass</code>, es decir, estamos haciendo lo mismo que antes pero sin crear la subclase y lo estamos haciendo sobre la marcha:</p> <pre><code>public class AnonymousInlineClass {\n    public void show(){\n        Class anonymousInner = new Class(){\n            public void showMessage(String message){\n                System.out.println(RED + message + RESET);\n            }\n        };\n\n        anonymousInner.showMessage();\n\n        new Class(){ // Lo mismo pero sin utilizar una variable\n            public void showMessage(String message){\n                System.out.println(RED + message + RESET);\n            }\n        }.showMessage();\n    }\n\n    public static void main(String[] args) {\n        new AnonymousInlineClass().show();\n    }\n}\n</code></pre> <p>Veamos un ejemplo con interfaces</p> InterfazMain <pre><code>public interface Message {\n    void showMessage();\n}\n</code></pre> <pre><code>    public class ShowAnonymousInlineClassWithInterface {\n    public void show(){\n        new Message(){\n\n            @Override\n            public void showMessage() {\n                System.out.println(RED + \"Clases inline an\u00f3nimas\" + RESET);\n            }\n        }.showMessage();\n\n        new Message(){\n\n            @Override\n            public void showMessage() {\n                System.out.println(BLUE + \"Clases inline an\u00f3nimas\" + RESET);\n            }\n        }.showMessage();\n    }\n\n    public static void main(String[] args) {\n        new ShowAnonymousInlineClassWithInterface().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-6/","title":"Ejercicios","text":"Ejercicio 1 <p>Queremos hacer una aplicaci\u00f3n para profesores y alumnos. De ambos se quiere conocer el nombre, la edad, el sexo y la nacionalidad. De los profesores se quiere conocer adem\u00e1s el sueldo, y del alumno si es o no repetidor. Realiza los siguientes apartados creando tres paquetes diferentes (uno para apartado). Cada paquete debe contener las clases y la clase con el main.</p> <ol> <li>Realiza en java las clases que consideres oportunas teniendo en cuenta las relaciones de herencia. Realiza un constructor por defecto para todas las clases sin usar super(). Realiza tambi\u00e9n los toString para todas las clases. Haz un programa para probarlo que haga lo siguiente:<ul> <li>Crea un profesor y saca por consola toString.</li> <li>Crea un alumno y saca por consola su toString.</li> <li>Crea una variable del padre y seg\u00fan un valor solicitado por consola, introduce en ella un objeto profesor o alumno. Muestra por consola el toString.</li> </ul> </li> <li>Hacer otra versi\u00f3n sustituyendo el constructor por defecto del padre por otro con par\u00e1metros. Soluciona los errores que surja realizando una llamada expl\u00edcita al constructor de la superclase.</li> <li>Lo mismo que el anterior pero utilizando el this(par\u00e1metros)</li> </ol> Ejercicio 2 <p>Queremos colocar figuras geom\u00e9tricas en un plano bidimensional y adem\u00e1s calcular el \u00e1rea de dichas figuras. Para ello, crear la clase abstracta FiguraGeom\u00e9trica que tendr\u00e1 como m\u00e9todo abstracto calcular_area. Dicha clase iniciar\u00e1 los valores de las coordenadas x e y del plano bidimensional para indicar la posici\u00f3n de la figura en dicho plano. Para el c\u00edrculo ser\u00e1 el centro de la circunferencia y para el resto, el v\u00e9rtice inferior izquierdo. Crea las clases Rect\u00e1ngulo, C\u00edrculo y Tri\u00e1ngulo heredadas de la clase abstracta.</p> Ejercicio 3 <p>Crea una clase empleado y una clase encargado. Los encargados reciben un 10% m\u00e1s de sueldo base que un empleado normal aunque realicen el mismo trabajo. Implementa dichas clases con el m\u00e9todo calcularSueldo() para ambas clases.</p> Ejercicio 4 <p>\u00bfPor qu\u00e9 no compila el siguiente c\u00f3digo?</p> <pre><code>class Prueba{\n    protected String nombre;\n    protected int id;\n\n    public String getIndent() {\n        return nombre;\n    }\n\n    public int getIndent(){\n        return id;\n    }\n}\n</code></pre> Ejercicio 5 <p>Implementa la siguiente estructura de clases:</p> <p>Forma es una superclase que tiene cuatro subclases: c\u00edrculo, cuadrado, tri\u00e1ngulo y rombo. Ni forma ni las subclases contienen atributos. La clase Forma es abstracta y contiene el m\u00e9todo abstracto toString(). Las subclases, al no tener atributos, en el m\u00e9todo toString() informar\u00e1n del tipo de forma que son.</p> <p>La clase forma tendr\u00e1 implementado un m\u00e9todo identidad que devuelva una cadena con la clase a la que pertenece. Realiza el m\u00e9todo identidad de tres maneras:</p> <ol> <li>Con el m\u00e9todo getClass(). Investigar en la API sobre este m\u00e9todo.</li> <li>Con instanceof</li> <li>Sin usar getClass() ni instanceof</li> </ol> <p>Hacer un programa que cree un array con cuatro objetos, uno de cada subclase y ejecutar de todos el m\u00e9todo identidad.</p> Ejercicio 6 <p>Este c\u00f3digo est\u00e1 utilizando la estructura de clases del ejercicio anterior. Modifica la sintaxis de las l\u00edneas que dan problema y elimina aquellas l\u00edneas que aunque sean sint\u00e1cticamente correctas nunca pueden funcionar:</p> <pre><code>public class TestForma{\n    public static void main(String[] args){\n        Forma f = new Circulo();\n        f.identidad();\n        Circulo c = new Circulo();\n        ((Forma) c).identidad();\n        ((Circulo) f).identidad();\n        Forma f2 = new Forma();\n        f2.identidad();\n        (Forma) f.identidad();\n        f = c;\n        c = f;\n    }\n}\n</code></pre> Ejercicio 7 <p>Averigua los errores del siguiente c\u00f3digo:</p> <pre><code>public class Test{\n    public int dato = 0;\n    public static int datoStatic = 0;\n\n    public void metodo(){\n        this.datoStatic++;\n    }\n\n    public static void metodoStatic(){\n        this.datoStatic++;\n        datoStatic++;\n    }\n\n    public static void main(String[] args){\n        dato++;\n        datoStatic++;\n        metodosStatic();\n        metodo();\n    }\n}\n</code></pre> Ejercicio 8 <p>\u00bfQu\u00e9 mostrar\u00e1 el siguiente programa por pantalla?</p> <pre><code>public class Bebe{\n    Bebe(int i ){\n        this(\"Soy un bebe consentido\");\n        System.out.println(\"Hola, tengo \" + i + \" meses\");\n    }\n\n    Bebe(String s){\n        System.out.println(s);\n    }\n\n    void berrea(){\n        System.out.println(\"Buaaaaaaaa\");\n    }\n\n    public static void main(String[] args){\n        new Bebe(8).berrea();\n    }\n}\n</code></pre> Ejercicio 9 <p>Averigua sin ejecutar el c\u00f3digo, que mostrar\u00e1 el siguiente programa por pantalla. Una vez que tengas claro lo que el programa deber\u00eda de mostrar por pantalla ejecuta el c\u00f3digo y verifica que lo que has pensado se cumple.</p> <pre><code>public class Bebe{\n    static void pedir(){\n        System.out.println(str1 + \", \" + str2 + \", \" + str3);\n    }\n\n    static{\n        str2 = \"mama pipi\";\n        str3 = \"mama agua\";\n    }\n\n    Bebe(){\n        System.out.println(\"Nacimiento del bebe\");\n    }\n\n    static String str2, str3, str1 = \"papa tengo caca\";\n\n    public static void main(String[] args){\n        System.out.println(\"El bebe se ha despertado y va a pedir cosas\");\n\n        System.out.println(\"El bebe dice \" + Bebe.str1);\n\n        Bebe.pedir();\n    }\n\n    static Bebe bebe1 = new Bebe();\n    static Bebe bebe2 = new Bebe();\n    static Bebe bebe3 = new Bebe();\n}\n</code></pre> Ejercicio 10 <p>Tenemos la siguiente clase:</p> <pre><code>public abstract class Sorteo{\n    protected int posibilidades;\n    public abstract int lanzar();\n}\n</code></pre> <p>Se pide:</p> <ul> <li>Crear una clase Dado, la cual desciende de la clase Sorteo. La clase Dado, en la llamada al m\u00e9todo lanzar devolver\u00e1 un n\u00famero aleatorio del 1 al 6.</li> <li>Crear la clase Moneda, la cual desciende de la clase Sorteo. Esta clase en la llamada al m\u00e9todo lanzar devolver\u00e1 las palabras cara o cruz</li> </ul> Ejercicio 11 <p>Averigua por qu\u00e9 el compilador da un mensaje de error en el siguiente c\u00f3digo:</p> <pre><code>class TestFinal{\n    public static void main(String[] args){\n        final String s1 = new String(\"Hola\");\n        String s2 = new String(\" Mundo\");\n\n        s1 = s1 + s2;\n    }\n}\n</code></pre> Ejercicio 12 <p>Tenemos la siguiente clase:</p> <pre><code>public abstract class Vehiculo{\n    private int peso;\n    public final void setPeso(int p){\n        peso = p;\n    }\n\n    public abstract int getVelocidadActual();\n}\n</code></pre> <ul> <li>\u00bfpodr\u00e1 tener descendencia esta clase?</li> <li>\u00bfse pueden sobrescribir todos sus m\u00e9todos?</li> </ul> Ejercicio 13 <p>Tenemos una jardiner\u00eda donde se venden plantas de jard\u00edn y productos de alfarer\u00eda. Ambas disponen de atributos precio y descripci\u00f3n pero no tienen relaci\u00f3n de herencia. Adem\u00e1s, las plantas disponen de un atributo para indicar si el producto es fr\u00e1gil. Ambas implementan la interfaz Mercanc\u00eda:</p> <pre><code>interface Mercancia{\n    public double damePrecio();\n    public String dameDescripcion();\n}\n</code></pre> <p>Haz un programa para probarlo que contenga el siguiente m\u00e9todo est\u00e1tico: <code>public static void dameDatos(Mercancia mercancia)</code>. Dicho m\u00e9todo deber\u00e1 mostrar el precio y la descripci\u00f3n del producto.</p> Ejercicio 14 <p>Implementa las siguientes interfaces que  heredan de la interface Mercancia del ejercicio anterior:</p> <pre><code>interface MercanciaViva extends Mercancia{\n    public boolean necesitaComida();\n    public boolean necesitaRiego();\n}\n</code></pre> <pre><code>interface MercanciaFragil extends Mercancia{\n    public String dameEmbalaje();\n    public double damePeso();\n}\n</code></pre> <p>Las plantas implementan la interface MercanciaViva y los productos de alfarer\u00eda implementan MercanciaFr\u00e1gil. Haz un programa para probarlo que contenta el siguiente m\u00e9todo est\u00e1tico: <code>public static void dameDatos(Mercancia producto)</code>. Dicho m\u00e9todo deber\u00e1 utilizar los m\u00e9todos de Mercancia, MercanciaViva y MercanciaFragil.</p> Ejercicio 15 <p>Realiza una clase pez con los atributos nombre, especie y zona donde vive. Realiza una subclase llamada pezAguaDulce con un atributo booleano para saber si es un pez de acuario. Realiza para ambas clases el toString y el equals. Haz un programa para probarlos.</p> Ejercicio 16 <p>Para la clase pez anterior, crea un atributo privado entero numpeces, com\u00fan a todos los objetos pez, el cual cuente el n\u00famero de peces creados. Crea un programa que compruebe que est\u00e1 variable se incrementa cada vez que se crea un objeto pez.</p> Ejercicio 17 <p>Realiza una clase huevo que est\u00e9 compuesta por dos clases internas, una clara y otra yema. Realiza un programa para probarlo.</p> Ejercicio 18 <p>\u00bfQu\u00e9 resultado da el siguiente c\u00f3digo? Analiza qu\u00e9 tipo de clase interna se est\u00e1 utilizando y haz una reflexi\u00f3n del resultado.</p> <p><pre><code>public class VerClaseInterna{\n    public static void main(String[] args){\n        Contenedor c1 = new Contenedor(34);\n        Contenedor.Contenido i1 = c1.new Contenido(23);\n        System.out.println(c1.muestraContenedor(i1));\n        c1.numero = 50;\n        System.out.println(i1.muestraContenido());\n        i1.numero2 = 25;\n        System.out.println(c1.muestraContenedor(i1));\n        i1.numero2 = 65;\n        System.out.println(i1.muestraContenido());\n    }\n}\n</code></pre> <pre><code>public class Contenedor{\n    public int numero = 0;\n    public Contenedor(int numero){\n        this.numero = numero;\n    }\n\n    public String muestraContenedor(Contenido refCont){\n        return \"N. contenedor= \" + numero + \" N. contenido= \" + refCont.numero2;\n    }\n\n    public class Contenido{\n        public int numero2;\n        public Contenido(int numero){\n            numero2 = numero;\n        }\n        public String muestraContenido(){\n            return \"N. contenedor= \"+numero+\" N. contenido = \" + numero2;\n        }\n    }\n}\n</code></pre></p> Ejercicio 19 <p>\u00bfQu\u00e9 resultado da el siguiente c\u00f3digo? Analiza qu\u00e9 tipo de clase interna se est\u00e1 utilizando y haz una reflexi\u00f3n del resultado.</p> <pre><code>public class ClaseLocal{\n    public int numero = 0;\n    public ClaseLocal(int numero){\n        this.numero = numero;\n    }\n\n    public String muestraContenido(){\n        class Mostrador{\n            public String muestraDato(){\n                return \"N\u00famero = \"+numero;\n            }\n        }\n        Mostrador m = new Mostrador();\n        return m.muestraDato();\n    }\n}\n</code></pre> <pre><code>public class VerClaseLocal{\n    public static void main(String[] args){\n        ClaseLocal c1 = new ClaseLocal(346);\n        System.out.println(c1.muestraContenido());\n    }\n}\n</code></pre> Ejercicio 20 <p>\u00bfQu\u00e9 resultado da el siguiente c\u00f3digo? Analiza qu\u00e9 tipo de clase interna se est\u00e1 utilizando y haz una reflexi\u00f3n del resultado.</p> <pre><code>public class VerClaseAnidada{\n    public static void main(String[] args){\n        PrimerContenedor.Contenido i1 = new PrimerContenedor.Contenido(29);\n        i1.numero2 = 25;\n        System.out.println(i1.muestraContenido());\n        PrimerContenedor c1 = new PrimerContenedor(34);\n        System.out.println(c1.muestraContenedor(i1));\n    }\n}\n</code></pre> <pre><code>public class PrimerContenedor{\n    public int numero = 0;\n    static public int numero3 = 13;\n\n    public PrimerContenedor(int numero){\n        this.numero = numero;\n    }\n\n    public String muestraContenedor(Contenido refCont){\n        return \"N\u00ba contenedor=\" +numero+ \"N\u00ba contenido=\" + refCont.numero2;\n    }\n\n    static class Contenido{\n        public int numero2;\n        public Contenido(int numero){\n            numero2 = numero;\n        }\n\n        public String muestraContenido(){\n            return \"N\u00ba contenedor=\" + numero3 + \" N\u00ba contenido= \" + numero2; \n        }\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-7/","title":"Proyecto","text":"<p>En este proyecto se quiere almacenar informaci\u00f3n sobre los profesores y alumnos de un instituto.</p> <p>De ambos se desea almacenar su dni, su nombre y su apellidos. De los profesores adem\u00e1s se quiere almacenar el a\u00f1o en el que empez\u00f3 en el instituto.</p> <p>De los alumnos se desea almacenar:</p> <ul> <li>Curso</li> <li>A\u00f1o de matriculaci\u00f3n</li> <li>Notas de cada asignatura.</li> </ul> <p>Existen dos tipos de profesores: Tutores y no tutores, de los tutores se desea almacenar el curso del cual son tutores y adem\u00e1s pueden realizar las siguientes acciones:</p> <ul> <li>Comunicarse con los padres de alg\u00fan alumno (debe recibir el alumno como par\u00e1metro).</li> <li>Dar boletines de notas de un alumno.</li> <li>Pasar lista.</li> </ul> <p>Adem\u00e1s puede hacer tambi\u00e9n podr\u00e1 poner las notas de un alumno, como cualquier profesor.</p> <p>Tambi\u00e9n se quiere guardar informaci\u00f3n de los directores, que no son considerados profesores ya que no imparten clases, pero pueden hacer cualquier acci\u00f3n realizada por un profesor, ya sea tutor o no.</p> <p>Tambi\u00e9n se almacenar\u00e1 la informaci\u00f3n importante del instituto, dividiendo dicha informaci\u00f3n en: informaci\u00f3n de la direcci\u00f3n, que mostrar\u00e1 los datos de la direcci\u00f3n donde se encuentra el instituto, informaci\u00f3n de los directores y del claustro e informaci\u00f3n con todos los alumnos.</p> <p>Realiza una aplicaci\u00f3n Java con la estructura de clase detallada por lo dicho anteriormente, creando un Diagrama de clases. En el Main, se deber\u00e1 crear varios profesor y alumnos y probar todo los m\u00e9todos que contengan.</p> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>Se deber\u00e1 hacer uso de la herencia, de interfaces y clases internas. Valorando el uso de cada una.</li> <li>Se valorar\u00e1 la complejidad de dicho Main.</li> <li>Se podr\u00e1 usar la librer\u00eda common realiza en proyectos anteriores, haciendo uso de JARs.</li> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante. El repositorio de GitHub tendr\u00e1 el siguiente nombre pr07java-NOMBRE-hig-school siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_ii/tema_8/page-1/","title":"1 Introducci\u00f3n a los tipos enumerados","text":""},{"location":"bloque_ii/tema_8/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Un tipo enumerado (enum type) es un tipo cuyos \u00fanicos valores legales consisten en un conjunto fijo de constantes, como por ejemplo las estaciones del a\u00f1o o los palos en una baraja de cartas.</p> <p>Antes  de  que  los  lenguajes  nos  permitieran  definir  tipos  enumerados,  \u00e9stos  eran  simulados declarando un grupo de constantes enteras, una para cada valor posible del tipo. Por ejemplo, para definir los tipos de manzanas y los tipos de naranjas podr\u00edamos hacer:</p> <pre><code>// APPLE TYPES\npublic static final int APPLE_FUJI = 0;\npublic static final int APPLE_PIPPIN = 1;\npublic static final int APPLE_GRANNY_SMITH = 2;\n\n// ORANGE TYPES\npublic static final int ORANGE_NAVEL = 0;\npublic static final int ORANGE_TEMPLE = 1;\n</code></pre> <p>Esta t\u00e9cnica, conocida como el patr\u00f3n de enumeraci\u00f3n entera, tiene muchos defectos, por lo que no se recomienda su uso.</p> <p>Para  empezar,  al  no  definir  realmente  un  tipo,  el  compilador  no  puede  proporcionarnos seguridad real respecto al tipo. Por ejemplo, podemos pasar un tipo de naranja como argumento de un m\u00e9todo que espera recibir un tipo de manzana, o almacenar un tipo de naranja en una variable que debe tener un tipo de manzana.</p> <pre><code>// Para el compilador esto es correct\nint appleType = ORANGE_TEMPLE;\n</code></pre> <p>No solo eso, podemos comparar err\u00f3neamente tipos de manzanas y tipos de naranjas.</p> <pre><code>int appleType = APPLE_PIPPIN;\nint orangeType = ORANGE_TEMPLE;\n\nif(appleType == orangeType){\n    // ...\n}\n</code></pre> <p>Como Java no proporciona espacios de nombre para grupos de constantes enteras, debemos usar  prefijos  para  evitar  conflictos  con  los  nombres  de  las  constantes  correspondientes  a distintos grupos, como por ejemplo entre <code>ELEMENT_MERCURY</code> y <code>PLANET_MERCURY</code>.</p> <p>Otro problema es que si se cambia el valor asociado a una constante, todas las clases que la usen seguir\u00e1n compilando, pero su comportamiento puede llegar a ser incorrecto.</p> <p>Finalmente, el patr\u00f3n de enumeraci\u00f3n entera tiene el inconveniente de que no hay una forma f\u00e1cil de traducir las constantes enteras a cadenas imprimibles, es decir, la descripci\u00f3n textual del valor que desea representar.</p> <p>En otras ocasiones se usa una variante del patr\u00f3n anterior, pero usando el tipo  String  como tipo para las constantes en lugar de  int. Por ejemplo:</p> <pre><code>// Apple types\npublic static final String APPLE_FUJI = \"FUJI\";\npublic static final String APPLE_PIPPIN = \"PIPPIN\";\npublic static final String APPLE_GRANNY_SMITH = \"SMITH\";\n\n// Orange types\npublic static final String ORANGE_NAVEL = \"NAVEL\";\npublic static final String ORANGE_TEMPLE = \"TEMPLE\";\n</code></pre> <p>Esta  variaci\u00f3n  se  conoce  como  patr\u00f3n  de  enumeraci\u00f3n  con  cadenas,  y  es  a\u00fan  menos deseable  que  la  anterior,  porque  aunque  proporciona  cadenas  imprimibles  para  sus constantes, los desarrolladores pueden tener la tentaci\u00f3n de usar en otras clases los valores de cadena  directamente  en  vez  de  las  constantes,  por  lo  que  un  simple  error  tipogr\u00e1fico  puede conllevar  fallos  en  tiempo  de  ejecuci\u00f3n.  Adem\u00e1s,  la  comparaci\u00f3n  de  cadenas  es  mucho  m\u00e1s costosa que la de enteros.</p> <p>La  alternativa  adecuada  a  los  patrones  de  enumeraci\u00f3n  anteriores  es  que  el  lenguaje  de programaci\u00f3n  nos  permita  definir  tipos  enumerados,  es  decir,  que  nos  permita  definir  un nuevo tipo indicando cu\u00e1les son los valores legales para dicho tipo y con qu\u00e9 nombre queremos referirnos a dichos valores.</p> <p>En algunos lenguajes de programaci\u00f3n, estos tipos enumerados son internamente tipos enteros. Sin  embargo,  en  Java  cuando  definimos  un  tipo  enumerado,  estamos  definiendo  una  clase completa,  lo  que  nos  proporciona  una  mayor  funcionalidad  a  la  de  otros  lenguajes  de programaci\u00f3n.  En  la  versi\u00f3n  5  de  Java,  se  incorporaron  al  lenguaje  los  tipos  de  datos enumerados.</p> <p>As\u00ed, siguiendo el ejemplo anterior, definir\u00edamos las siguientes clases <code>enum</code>:</p> <pre><code>public enum Apple{\n    FUJI, PIPPIN, GRANNY_SMITH\n}\n\npublic enum Orange{\n    NAVEL, TEMPLE\n}\n</code></pre> <p>Los enums presentan numerosas ventajas frente al uso de los patrones de enumeraci\u00f3n entera y de enumeraci\u00f3n con cadenas. La m\u00e1s importante es que la clase enum corresponder\u00e1 a un tipo, por lo que el compilador va a ser capaz de proporcionar comprobaci\u00f3n de tipos en tiempo de compilaci\u00f3n.  Por  ejemplo,  si  se  declara  que  un  par\u00e1metro  es  del  tipo <code>Apple</code>,  el  compilador garantiza que cualquier referencia de objeto no nulo pasada al par\u00e1metro debe ser alguno de las instancias de  Apple  v\u00e1lidas que hemos definido en el enum. En caso contrario, se producir\u00e1 un error  de  compilaci\u00f3n.  Ocurre  exactamente  lo  mismo  al  asignar  una  expresi\u00f3n  de  un  tipo  de enumeraci\u00f3n a una variable de un tipo enum, o al usar el operador <code>==</code> para comparar valores de diferentes tipos enum.</p> <p>Adem\u00e1s,  los  tipos  enum  definen  su  propio  espacio  de  nombres,  por  lo  que  no  hay  ning\u00fan problema en usar constantes con el mismo nombre en distintos enums.</p> <p>Otra ventaja es que si cambiamos el orden de las constantes en el enum, esto no afecta al c\u00f3digo de  los  clientes  del  enum,  dado  que  las  constantes  no  son  compiladas  en  el  c\u00f3digo  cliente,  a diferencia de como ocurr\u00eda en los patrones anteriores.</p>"},{"location":"bloque_ii/tema_8/page-1/#definicion","title":"Definici\u00f3n","text":"<p>Los enumerados se definen con la palabra reservada enum, el nombre del enumerado y luego el conjunto de las constantes, que por las convenciones del lenguaje se escriben en may\u00fascula. Las constantes de la enumeraci\u00f3n son public y static de forma impl\u00edcita.Ejemplo:</p> <pre><code>public enum DayOfWeek{\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n</code></pre> <p>Por otra parte, \u00bfd\u00f3nde debemos definir un enum? Si va a ser usado desde varios lugares, lo l\u00f3gico es definir el enum como una clase en su propio fichero. Si su uso est\u00e1 restringido a una \u00fanica clase cliente, es m\u00e1s razonable definir el enum como una clase interna miembro de dicha clase. Una vez definido el enum, se pueden crear variables de ese tipo:</p> <pre><code>DayOfWeek day; // day es una variable del tipo de enumeraci\u00f3n DayOfWeek\n</code></pre> <p>Como day es de tipo DayOfWeek, los \u00fanicos valores que se le pueden asignar son los definidos por la enumeraci\u00f3n:</p> <pre><code>day = DayOfWeek.MONDAY; // Se asigna a day el valor MONDAY\n</code></pre> <p>El  compilador  nos  da  un  error  si  intentamos  asignar  a  una  variable  enum  un  tipo  que  no  le corresponde:</p> <pre><code>DayOfWeek day = Apple.FUJI; //(1)!\n</code></pre> <ol> <li>ERROR -&gt; falta de correspondencia entre tipos; No se puede convertir de Apple a DayOfWeek</li> </ol>"},{"location":"bloque_ii/tema_8/page-2/","title":"2 Operaciones con tipos enumerados","text":""},{"location":"bloque_ii/tema_8/page-2/#constructores","title":"Constructores","text":"<p>Los  enum  se  implementan  internamente  como  clases.  El  enum DayOfWeek  internamente  se convierte en:</p> <pre><code>class DayOfWeek {\n    public static final DayOfWeek MONDAY = new DayOfWeek();\n    public static final DayOfWeek TUESDAY = new DayOfWeek();\n    public static final DayOfWeek WEDNESDAY = new DayOfWeek();\n    // ...\n}\n</code></pre> <p>Los  enum  de  Java  son  clases  que  exportan  una  instancia  (objeto)  para  cada  constante  de enumeraci\u00f3n  a  trav\u00e9s  de  un  campo  final  est\u00e1tico  p\u00fablico.  Estas  instancias  son  creadas autom\u00e1ticamente  al  hacer  referencia  al  enum  en  nuestro  c\u00f3digo,  es  decir,  el  constructor  se ejecuta para cada constante en el momento de la carga de la clase enum. No podemos crear objetos enum expl\u00edcitamente y, por lo tanto, no podemos invocar al constructor directamente:</p> <pre><code>DayOfWeek day = new DayOfWeek(); // ERROR \n</code></pre> <p>Los \u00fanicos modificadores de acceso permitidos para los constructores de los enum son friendly y private. Los modificadores de acceso protected y public dan un error de compilaci\u00f3n.</p> <p>Como vemos, los  enum  de Java son una generaci\u00f3n del patr\u00f3n de dise\u00f1o singleton permitiendo una  determinada  serie  de  instancias,  cada  una  de  las  cuales  es  accesible  a  trav\u00e9s  de  una constante. Visto de forma inversa, podr\u00edamos decir que un singleton no es m\u00e1s que un enum con una sola instancia.</p>"},{"location":"bloque_ii/tema_8/page-2/#comparaciones","title":"Comparaciones","text":"<p>Los enum se pueden comparar utilizando el operador relacional ==:</p> <pre><code>if(day == DayOfWeek.MONDAY){ \n    // ...\n}\n\nDayOfWeek day = DayOfWeek.MONDAY;\nSystem.out.println(day == DayOfWeek.MONDAY ? \"Es lunes\" : \"No es lunes\")\n</code></pre> <p>El compilador nos da un error si intentamos comparar valores de diferentes tipos enum:</p> <pre><code>DayOfWeek day = DayOfWeek.Monday;\nApple apple = Apple.FUJI;\n\nif(day == apple){ // ERROR\n\n}\n</code></pre>"},{"location":"bloque_ii/tema_8/page-2/#enums-en-switch","title":"Enums en switch","text":"<p>Tambi\u00e9n podemos utilizar switch para comprobar en los case los distintos valores del enum:</p> <pre><code>switch(day){\n    case MONDAY:\n        System.out.println(\"Lunes\");\n        break;\n    case MONDAY:\n        System.out.println(\"Martes\");\n        break;\n    // ...\n}\n</code></pre> <p>\u00a1OJO!</p> <p>No es necesario calificar las constantes en las declaraciones de case con su nombre de tipo enum. De hecho, intentar hacerlo provocar\u00e1 un error de compilaci\u00f3n</p>"},{"location":"bloque_ii/tema_8/page-3/","title":"3 Tipo de enumerados compuestos","text":""},{"location":"bloque_ii/tema_8/page-3/#atributos","title":"Atributos","text":"<p>Los enums no dejan de ser clases, por lo que podemos declararles atributos, que deben ser final, ya que los enums son inmutables por naturaleza. Aunque estos atributos pueden ser public, se recomienda definirlos como private y definir los getters correspondientes si es necesario acceder a los atributos desde fuera del enum.</p> <p>Para  establecer  el  valor  de  estos  atributos,  debemos  definir  en  la  clase  enum  el  constructor adecuado y al establecer las instancias pasaremos como argumento los valores deseados que se pasar\u00e1n al constructor. En el ejemplo, cuando definimos PLUS, le ponemos entre par\u00e9ntesis la cadena  \"+\".  Cuando  se  cree  el  objeto  para PLUS,  se  ejecuta  el  constructor  private <code>Operation(String symbol)</code>  y en symbol se pasa \"+\":</p> EnumMainSalida <pre><code>public enum Operation {\n    PLUS(\"+\"), MINUS(\"-\"), TIMES(\"*\"), DIVIDE(\"/\");\n\n    private final String symbol;\n    Operation(String symbol){\n        this.symbol = symbol;\n    }\n\n    public String getSymbol() {\n        return symbol;\n    }\n}\n</code></pre> <p>Observa</p> <p>Del ejemplo se pueden destacar dos cosas importantes y a tener en cuenta:</p> <ul> <li>El constructor es privado aunque no es necesario indic\u00e1rselo, ya que si se indica un modificar diferente dar\u00eda error de compilaci\u00f3n. Esto ocurre para evitar crear objetos fuera del enum.</li> <li>Cuando se declaran atributos, constructores y/o m\u00e9todos es obligatorio poner <code>;</code> al terminar de declarar los valores del enum.</li> </ul> <pre><code>public class EnumAttributes {\n    public void show(){\n        Operation operation1 = Operation.PLUS;\n        Operation operation2 = Operation.MINUS;\n\n        System.out.printf(\"El atributo de PLUS es una cadena con el valor %s\\n\", operation1.getSymbol());\n        System.out.printf(\"El atributo de MINUS es una cadena con el valor %s\\n\", operation2.getSymbol());\n    }\n\n    public static void main(String[] args) {\n        new EnumAttributes().show();\n    }\n}\n</code></pre> <pre><code>El atributo de PLUS es una cadena con el valor +\nEl atributo de MINUS es una cadena con el valor -\n</code></pre>"},{"location":"bloque_ii/tema_8/page-3/#metodos","title":"M\u00e9todos","text":"<p>Una  enumeraci\u00f3n  no  puede  heredar  de  otra  clase  ni  puede  actuar  como  superclase  de  otra clase, pero por defecto, hereda de la clase <code>java.lang.Enum&lt;E&gt;</code> y por tanto tiene una serie de m\u00e9todos heredados, como por ejemplo los m\u00e9todos <code>toString()</code> y <code>ordinal()</code>.</p> <p>Adem\u00e1s, todas las enumeraciones tienen autom\u00e1ticamente dos m\u00e9todos est\u00e1ticos predefinidos: <code>values()</code> y <code>valueOf(String str)</code>.</p>"},{"location":"bloque_ii/tema_8/page-3/#metodo-tostring","title":"M\u00e9todo toString","text":"<p>Las clases enum proporcionan de serie implementaciones de alta calidad de todos los m\u00e9todos de  la  clase <code>Object</code> (la  clase  <code>Enum</code> hereda de <code>Object</code>), como el m\u00e9todo <code>public  String toString()</code>, que retornar\u00e1 el nombre de la constante asociada a la instancia correspondiente. Por ejemplo <code>Apple.FUJI.toString()</code> retorna la cadena <code>FUJI</code>, aunque si no estamos contentos con  dicha  implementaci\u00f3n,  podemos  sobrescribir  nosotros  dicho  m\u00e9todo.  Adem\u00e1s,  las  clases enum implementan de serie las interfaces  <code>Comparable</code> y <code>Serializable</code> .</p> <pre><code>public class EnumToString {\n\n    private void show() {\n        Operation operation1 = Operation.PLUS;\n        Operation operation2 = Operation.MINUS;\n        String operation1ToString = operation1.toString();\n        String operation2ToString = operation2.toString();\n\n        System.out.println(operation1ToString);\n        System.out.println(operation2ToString);\n        System.out.println(Operation.DIVIDE);\n    }\n\n    public static void main(String[] args) {\n        new EnumToString().show();\n    }\n}\n</code></pre> <p>El m\u00e9todo <code>name()</code> tambi\u00e9n devuelve el nombre del enum.</p>"},{"location":"bloque_ii/tema_8/page-3/#metodo-valueof","title":"M\u00e9todo valueOf","text":"<p><code>public  static  E  valueOf(String  name)</code>   es  un  m\u00e9todo  declarado  impl\u00edcitamente  que devuelve la instancia del enum que posee asociado el nombre de constante recibida.</p> <pre><code>public class EnumValueOf {\n    private void show() {\n        Operation operation = Operation.valueOf(\"PLUS\"); // Se le asigna a operation la instancia correspondiente a PLUS\n\n        System.out.printf(\"La variable operation es de tipo enum %s y su s\u00edmbolo es %s\", operation,\n                operation.getSymbol());\n    }\n\n    public static void main(String[] args) {\n        new EnumValueOf().show();\n    }\n}\n</code></pre> <p>\u00a1CUIDADo!</p> <p>Si el argumento cadena que recibe el m\u00e9todo valueOf no corresponde a ninguna constante de enumeraci\u00f3n, el m\u00e9todo lanza la excepci\u00f3n <code>IllegalArgumentException</code>.</p> <p><pre><code>Operation operation = Operation.valueOf(\"PLUS1\"); //ERROR\n</code></pre> Ten en cuenta que la cadena que corresponda a la enumeraci\u00f3n ha de ser escrita tal y como est\u00e1 escrita en el enum, sino no la reconoce y lanzar\u00e1 la excepci\u00f3n</p> <pre><code>Operation operation = Operation.valueOf(\"plus\"); // ERROR\n</code></pre>"},{"location":"bloque_ii/tema_8/page-3/#metodo-values","title":"M\u00e9todo values","text":"<p><code>public static E[] values()</code> es un m\u00e9todo declarado impl\u00edcitamente que devuelve un array con todas las instancias de la clase enum en el orden en que fueron declarados.</p> <pre><code>public class EnumValues {\n    private void show() {\n        for (Operation operation : Operation.values()) {\n            System.out.println(operation);\n        }\n    }\n\n    public static void main(String[] args) {\n        new EnumValues().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_8/page-3/#metodo-ordinal","title":"M\u00e9todo ordinal","text":"<p>Una  enumeraci\u00f3n  hereda  de  la  clase <code>java.lang.Enum&lt;E&gt;</code> y por  tanto  tiene  una  serie  de m\u00e9todos heredados, como por ejemplo <code>ordinal()</code>.</p> <p><code>public final int ordinal()</code> devuelve un entero que indica la posici\u00f3n de la constante dentro de la enumeraci\u00f3n. La primera constante tiene el valor 0.</p> <pre><code>public class EnumOrdinal {\n    private void show() {\n        for (Operation operation : Operation.values()) {\n            System.out.println(operation.ordinal());\n        }\n    }\n\n    public static void main(String[] args) {\n        new EnumOrdinal().show();\n    }\n}\n</code></pre> <p>El problema de usar el m\u00e9todo <code>ordinal()</code> es que el funcionamiento del c\u00f3digo cliente depende completamente del orden en el que se definen las constantes en el enum, lo que puede resultar problem\u00e1tico  para  el  mantenimiento  del  c\u00f3digo  si  en  un  futuro  se  cambia  dicho  orden.  En realidad,  este  m\u00e9todo  est\u00e1  dise\u00f1ado  para  ser  utilizado  por  estructuras  de  datos  sofisticadas basadas en enumeraciones como <code>EnumSet</code> y <code>EnumMap</code>. (Se explican en el Tema 11. Colecciones).</p> <p>Por  lo  tanto  se  recomienda  no  hacer  uso  del  m\u00e9todo <code>ordinal()</code>, sino  definir  un  atributo  y asignar un valor para dicho atributo en cada instancia:</p> ENUMMain <pre><code>public enum Operation {\n    PLUS(\"+\", 1), MINUS(\"-\", 2), TIMES(\"*\", 3), DIVIDE(\"/\", 4);\n\n    private final String symbol;\n    private final int optionNumber;\n    Operation(String symbol, int optionNumber){\n        this.symbol = symbol;\n        this.optionNumber = optionNumber;\n    }\n\n    public String getSymbol() {\n        return symbol;\n    }\n\n    public int getOptionNumber() {\n        return optionNumber;\n    }\n}\n</code></pre> <pre><code>public class EnumAttributeInsteadOfOrdinal {\n    private void show() {\n        for (Operation operation : Operation.values()) {\n            System.out.println(operation.getOptionNumber());\n        }\n    }\n\n    public static void main(String[] args) {\n        new EnumAttributeInsteadOfOrdinal().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_8/page-3/#metodos-abstractos","title":"M\u00e9todos abstractos","text":"<p>En algunas ocasiones es necesario asociar un comportamiento ligeramente diferente en cada instancia del enum. En estos casos, debemos declarar un m\u00e9todo abstracto en el enum e incluir la implementaci\u00f3n concreta de dicho m\u00e9todo abstracto en la definici\u00f3n de cada instancia. Estas implementaciones reciben el nombre de constant-specific methods. Por ejemplo:</p> EnumMainSalida <pre><code>public enum Operation {\n    PLUS(\"+\"){\n        @Override\n        public double apply(double x, double y) {\n            return x + y;\n        }\n    }, MINUS(\"-\") {\n        @Override\n        public double apply(double x, double y) {\n            return x - y;\n        }\n    }, TIMES(\"*\") {\n        @Override\n        public double apply(double x, double y) {\n            return x * y;\n        }\n    }, DIVIDE(\"/\") {\n        @Override\n        public double apply(double x, double y) {\n            return x / y;\n        }\n    };\n\n    private final String symbol;\n    Operation(String symbol){\n        this.symbol = symbol;\n    }\n\n    public String getSymbol() {\n        return symbol;\n    }\n\n    public abstract double apply(double x, double y);\n}\n</code></pre> <pre><code>public class EnumAbstractMethods {\n    private void show() {\n        for (Operation operation :\n                Operation.values()) {\n            System.out.printf(\"%-8s %.2f %s %.2f = %.2f\\n\", operation + \":\", 5f, operation.getSymbol(), 5f,\n                    operation.apply(5, 3));\n        }\n    }\n\n    public static void main(String[] args) {\n        new EnumAbstractMethods().show();\n    }\n}\n</code></pre> <pre><code>PLUS:     5,00 + 3,00 = 8,00\nMINUS:    5,00 - 3,00 = 2,00\nTIMES:    5,00 * 3,00 = 15,00\nDIVIDE:   5,00 / 3,00 = 1,67\n</code></pre>"},{"location":"bloque_ii/tema_8/page-3/#implementacion-de-interfaces","title":"Implementaci\u00f3n de interfaces","text":"<p>Como  ya  hemos  comentado,  un  enum  no  puede  heredar  de  otro  enum.  Pero  hay  ocasiones donde  tiene  sentido  que  otros  programadores  puedan  \"extender\"  un  enum  que  hayamos proporcionado en nuestra API. Por ejemplo cuando el enum corresponda a c\u00f3digos de operaci\u00f3n sobre una determinada m\u00e1quina, como por ejemplo el enum  Operation , ser\u00eda recomendable que  quien  use  nuestra  API  puede  \"a\u00f1adir\"  nuevas  operaciones.  Para  estos  casos  podemos simular la herencia entre enums definiendo una interfaz con el m\u00e9todo de la operaci\u00f3n y hacer 1ue nuestro enum implemente dicha interfaz. Por ejemplo</p> InterfazBasicOperationExtendOperationMainSalida <pre><code>public interface Operation {\n    double apply(double x, double y);\n    String getSymbol();\n}\n</code></pre> <pre><code>public enum BasicOperation implements Operation {\n    PLUS(\"+\"){\n        @Override\n        public double apply(double x, double y) {\n            return x + y;\n        }\n    }, MINUS(\"-\") {\n        @Override\n        public double apply(double x, double y) {\n            return x - y;\n        }\n    }, TIMES(\"*\") {\n        @Override\n        public double apply(double x, double y) {\n            return x * y;\n        }\n    }, DIVIDE(\"/\") {\n        @Override\n        public double apply(double x, double y) {\n            return x / y;\n        }\n    };\n\n    private final String symbol;\n    BasicOperation(String symbol){\n        this.symbol = symbol;\n    }\n\n    @Override\n    public String getSymbol() {\n        return symbol;\n    }\n}\n</code></pre> <p><pre><code>public enum ExtendedOperation implements Operation{\n    EXP(\"^\"){\n        @Override\n        public double apply(double x, double y) {\n            return Math.pow(x, y);\n        }\n    },\n    REMAINDER(\"%\"){\n        @Override\n        public double apply(double x, double y) {\n            return x % y;\n        }\n    };\n\n    private final String symbol;\n\n    ExtendedOperation(String symbol) {\n        this.symbol = symbol;\n    }\n\n    @Override\n    public String getSymbol() {\n        return symbol;\n    }\n}\n</code></pre> De esta manera, el c\u00f3digo cliente que quiera trabajar con una operaci\u00f3n, tendr\u00e1 que definir la variable correspondiente de tipo interfaz:</p> <p><pre><code>Operation operation = ExtendedOperation.EXT;\n</code></pre> El problema principal de est\u00e1 t\u00e9cnica es que dado de que no se trata de herencia real, no podemos reutilizar c\u00f3digo entre los enums.</p> <pre><code>public class InterfacesImplementation {\n    private void show() {\n        for (Operation operation : BasicOperation.values()) {\n            show(operation);\n        }\n\n        for (Operation operation : ExtendedOperation.values()) {\n            show(operation);\n        }\n    }\n\n    public void show(Operation operation){\n        System.out.printf(\"%-8s %.2f %s %.2f = %.2f\\n\", operation + \":\", 5f, operation.getSymbol(), 5f,\n                operation.apply(5, 3));\n    }\n\n    public static void main(String[] args) {\n        new InterfacesImplementation().show();\n    }\n}\n</code></pre> <pre><code>PLUS:       5,00 + 3,00 = 8,00\nMINUS:      5,00 - 3,00 = 2,00\nTIMES:      5,00 * 3,00 = 15,00\nDIVIDE:     5,00 / 3,00 = 1,67\nEXP:        5,00 ^ 3,00 = 125,00\nREMAINDER:  5,00 % 3,00 = 2,00\n</code></pre>"},{"location":"bloque_ii/tema_8/page-4/","title":"Ejercicios","text":"Ejercicio 1 <p>Crea una aplicaci\u00f3n Java que controle los tipos de manera existentes (Roble, Caoba, Nogal, Cerezo, Boj, Otro). Solic\u00edtale al usuario un tipo de manera existen. La aplicaci\u00f3n finalizar\u00e1 cuando el usuario elija una tipo de madera correcto.</p> Ejercicio 2 <p>Se desea controlar los tipos de lenguaje de programaci\u00f3n que se cursa en el IES BellaVista (Java, C#, Python, Javascript, Typescript, C++). Crea un enum que contenga dichos lenguajes de la forma correcta y crea un main que recorra todos los valores del enum, teniendo en cuenta que a la hora de mostrarlo por pantalla la salida deber\u00e1 ser as\u00ed: <code>Lenguaje de programaci\u00f3n Java</code>.</p> Ejercicio 3 <p>En una empresa existen 3 tipos de empleados: Ingeniero, encargado y vendedor, cuyos salarios bases son 50000, 40000 y 30000, respectivamente. Teniendo en cuenta que se le puede aplicar un aumento de sueldo en base a las prestaciones ofrecidas (como por ejemplo, las horas extras, cantidad de venta realizada, etc.) o incluso un descuento si no cumple ciertas condiciones, crea un enum con los tipos de empleados y un main para probar dichas operaciones.</p> Ejercicio 4 <p>En un bar se vende cerveza en diferentes tipos de vasos, siendo su capacidad, altura y precio diferente:</p> Vaso Capacidad Altura Jarra 500 20,7 Tubo 250 16,7 Tercio 333 12,3 Ca\u00f1a 200 8,5 <p>El precio var\u00eda seg\u00fan el tipo de vaso, teniendo en cuenta que se a\u00f1adir\u00e1 0,10 c\u00e9ntimos por cada 100 ml de capacidad y un 1 euro por cada 10 cm de altura, m\u00e1s una cantidad de impuestos que se deber\u00e1 indicar.</p> <p>Haciendo uso de un m\u00e9todo abstracto crea un enum con los tipos de vasos y luego un main para probarlo.</p> Ejercicio 5 <p>Realiza el mismo ejercicio anterior pero haciendo uso de una interfaz.</p>"},{"location":"bloque_ii/tema_9/page-1/","title":"1 Introducci\u00f3n a las Fechas Java8","text":""},{"location":"bloque_ii/tema_9/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>A partir de Java 8, Java incorpora una nueva API para el manejo de fechas, pero hasta entonces el manejo de fechas era muy diferente.</p> <p>Hoy en d\u00eda la mayor\u00eda de aplicaciones Java usan est\u00e1 nueva API, pero a\u00fan hay aplicaciones que usan las versiones antiguas.</p> <p>Las tres clases principales para el manejo de fechas en Java anterior a la 8 son:</p> <ul> <li><code>Date</code>: Almacena la fecha.</li> <li><code>DateFormat</code> y <code>SimpleDateFormat</code>: Aplica formatos a las fechas.</li> <li><code>Calendar</code>: Realizar c\u00e1lculos sobre fechas.</li> </ul> <p>Una de las desventajas que tiene est\u00e1 API es que no trabaja con la internacionalizaci\u00f3n.</p>"},{"location":"bloque_ii/tema_9/page-1/#la-clase-date","title":"La clase Date","text":"<p>La clase <code>Date</code> representa un tiempo espec\u00edfico con la precisi\u00f3n de los milisegundos.</p> <p>Los constructores de esta clase son:</p> <ul> <li><code>Date()</code>: Crea un objeto Date con la fecha y hora actuales.</li> <li><code>Date(int year, int month, int date)</code>: Crea un objeto Date con los datos del a\u00f1o, del mes (comienza en 0 y acaban en 11) y con el d\u00eda.</li> </ul> <p>Estos m\u00e9todos tambi\u00e9n tienen una versi\u00f3n para recibir la hora y los minutos y la hora, los minutos y los segundos.</p> <p>Otra versi\u00f3n del m\u00e9todo es <code>Date(long date)</code> que crea un objeto de tipo Date a partir de los milisegundos especificados desde el tiempo base est\u00e1ndar conocido como epoch, es decir, desde el 1 de Enero de 1970, OO:OO:OO GTM.</p> <p>\u00a1CUIDADA!</p> <p>Todos estos constructores est\u00e1n deprecated y la mayor\u00eda de m\u00e9todos como por ejemplo <code>getYear()</code>, <code>getMonth()</code>, etc. tambi\u00e9n est\u00e1n deprecated.</p> <p>Algunos m\u00e9todos c\u00f3mo after(Date when) o before(Date when) no est\u00e1n deprecated. Estos m\u00e9todos sirven para comprobar si una fecha sucede despu\u00e9s o antes que otra, respectivamente.</p>"},{"location":"bloque_ii/tema_9/page-1/#dateformat-y-simpledateformat","title":"DateFormat y SimpleDateFormat","text":"<p><code>DateFormat</code> es una clase abstracta hecha para subclases de formateo de fecha/tiempo.</p> <p><code>SimpleDateFormat</code> es una clase concreta para formatear y parsear fechas de manera sensible a la configuraci\u00f3n regional.</p> <p>El formato de fecha y hora se especifican con cadenas de patr\u00f3n de fechas y horas:</p> <p>|Letra    |Componente de fecha u hora|Presentaci\u00f3n    |Ejemplo    | |:-------:|:-----------M-------------:|:-------------:|:---------:| |G        |Designador de era         |Texto           |AD         | |y        |A\u00f1o                       |A\u00f1o             |1996;96    | |M        |Mes del a\u00f1o               |Mes             |July;Jul;07| |d        |D\u00eda del mes               |N\u00famero          |9;09       | |H        |Hora del d\u00eda(0-23)        |N\u00famero          |23         | |m        |Minutos en una hora       |N\u00famero          |10         | |s        |Segundo en un minuto      |N\u00famero          |2;02       |</p> <p>Info</p> <p>Para comprobar el resto de patrones puedes ir a la API y observar la tabla: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/text/SimpleDateFormat.html</p> <p>Con el m\u00e9todo <code>format(Date date)</code>, formateamos la fecha indicada con el patr\u00f3n indicado:</p> <pre><code>Date date = new Date(2022, 10, 10, 7, 2 ,5);\nDateFormat format = new SimpleDateFormat(\"dd/M/yy\");\nSystem.out.println(format.format(date)); // 10/11/22\n</code></pre> <p>Con el m\u00e9todo <code>parse(String str)</code> se parsea una cadena a la clase Date siempre y cuando cumpla el formato, por el contrario, lanzar\u00e1 una excepci\u00f3n <code>ParseException</code>:</p> <pre><code>Date newDate = format.parse(\"12/10/22\");\n</code></pre>"},{"location":"bloque_ii/tema_9/page-1/#calendar","title":"Calendar","text":"<p>Una vez creada una fecha , esta simplemente almacena la informaci\u00f3n . Si queremos realizar operaciones sobre ella lo que tenemos que construir es un <code>Calendar</code>. Una vez construido el calendario le asignamos nuestra fecha con el m\u00e9todo <code>setTime(Date date)</code></p> <p>Calendar es una clase abstracta que permite trabajar con fechas en un tipo de calendario. Existe diferentes tipos de subclases que funcionan como calendarios, como por ejemplo, <code>GregorianCalendar()</code> que permite crear un calendario gregoriano.</p> <pre><code>Calendar calendario = new GregorianCalendar();\ncalendario.setTime(date);\n</code></pre> <p>Para obtener el calendario de la zona actual y de la fecha actual se puede usar el m\u00e9todo est\u00e1tico <code>getInstance()</code>:</p> <pre><code>Calendar calendario = Calendar.getInstance();    \n</code></pre> <p>La clase Calendar tiene varios atributos est\u00e1ticos para indicar meses, <code>Calendar.FEBRUARY</code>, d\u00edas de la semana, <code>Calendar.MONDAY</code>, momentos del a\u00f1o, <code>Calendar.DAY_OF_MONTH</code>, <code>Calendar.HOUR</code>, etc.</p> <p>Una vez establecido el calendario, se puede hacer diferentes operaciones sobre \u00e9l:</p> <ul> <li><code>add(int field, int amount)</code>, siendo el primer par\u00e1metro el atributo est\u00e1tico para indicar que es lo que vamos a\u00f1adir, y el segundo par\u00e1metro la cantidad a a\u00f1adir.</li> <li><code>after(Object object)</code>, comprueba si el calendario representa un momento posterior a la hora indicada en el objeto especificado.</li> <li><code>before(Object objet)</code>, comprueba si el calendario representa un momento anterior a la hora indicada en el objeto especificado.</li> </ul> <pre><code>Date date = new Date(2022, 10, 12); // 12/11/22\nCalendar calendar = Calendar.getInstance(); // Se obtiene el calendario actual\ncalendar.setTime(date); // se le indica la fecha\n\ncalendar.add(Calendar.MONTH, 5); // A\u00f1adimos cinco meses 12/04/23\n</code></pre>"},{"location":"bloque_ii/tema_9/page-1/#nueva-api-de-java","title":"Nueva API de Java","text":"<p>A partir de Java 8, se creo una nueva API en Java para el manejo de fechas, con muchas ventajas sobre la API anterior, siendo una de ellas la internacionalizaci\u00f3n.</p>"},{"location":"bloque_ii/tema_9/page-2/","title":"2 Fechas en Java 8","text":""},{"location":"bloque_ii/tema_9/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Java 8 introduce una nueva API para fechas y horas que es thread-safe, m\u00e1s f\u00e1cil de leer y m\u00e1s amplia que la API anterior.</p> <p>Esta API se introduce para cubrir los siguientes inconvenientes de la vieja API de fecha y hora:</p> <ol> <li><code>java.util.Date</code> no es thread-safe por lo que los desarrolladores tienen que hacer frente a problemas de concurrencia durante el uso de la fecha. La nueva API de fecha y hora es inmutable y no tiene m\u00e9todos setter. Al ser inmutables, no necesitan ser clonadas.</li> <li>Dificultad para manejar zona-horaria.</li> </ol> <p>En java 8 se crea un nuevo paquete para el manejo de fechas, se trata del paquete <code>java.time</code>. Este paquete es una extensi\u00f3n a las clases <code>java.util.Date</code> y <code>java.util.Calendar</code> que vemos un poco limitado para manejo de fechas, horas y localizaci\u00f3n.</p> <p>Las clases definidas en este paquete representan los principales conceptos de fecha - hora, incluyendo instantes, fechas, horas, per\u00edodos, zonas de tiempo, etc. Est\u00e1n basados en el sistema de calendario ISO, el cual es el calendario mundial de-facto que sigue las reglas del calendario Gregoriano.</p>"},{"location":"bloque_ii/tema_9/page-2/#enumerado-de-dia-de-la-semana","title":"Enumerado de d\u00eda de la semana","text":"<p>Existe un enum donde se definen todos los d\u00edas de la semana. Este enum se llama <code>java.time.DayOfWeek</code> y contiene algunos m\u00e9todos interesantes que permiten manipular d\u00edas hacia adelante, <code>plus(int amount)</code> y hacia atr\u00e1s, <code>minus(int amount)</code>:</p> <pre><code>DayOfWeek dia = DayOfWeek.MONDAY;\nSystem.out.printf(\"8 d\u00edas ser\u00e1: %s%n\",dia.plus(8));\nSystem.out.printf(\"2 d\u00edas antes fue: %s%n\",dia.minus(2));\n</code></pre> <p>Adem\u00e1s, con el m\u00e9todo <code>getDisplayName()</code> se puede acceder al texto que corresponde a la fecha. Este m\u00e9todo recibe dos par\u00e1metros:</p> <ul> <li>TextStyle: Es una enum del paquete <code>java.time.format</code> que define diferentes formas de formatear una fecha:<ul> <li><code>TextStyle.FULL</code>, la descripci\u00f3n completa, por ejemplo Monday.</li> <li><code>TextStyle.NARROW</code>, la letra que representa ese d\u00eda, M.</li> <li><code>TextStyle.SHORT</code>, la abreviaci\u00f3n del d\u00eda, Mon.</li> </ul> </li> <li> <p>Locale: Es una clase que trabaja con la localizaci\u00f3n, de est\u00e1 forma ponemos obtener Monday si estamos en UK, o Lunes si estamos en Espa\u00f1a. Para crear una instancia del objeto <code>Locale</code>, se puede hacer de dos formas:</p> <ul> <li>Usando los atributos est\u00e1ticos que representas los m\u00e1s utilizados, por ejemplo: <code>Locale.ENGLISH</code>.</li> <li>Usando el m\u00e9todo est\u00e1tico <code>of()</code>, que recibe el c\u00f3digo de lenguaje, por ejemplo, si es para espa\u00f1ol. Dicho constructor esta sobrecargado para recibir el c\u00f3digo del pa\u00eds, ES para Espa\u00f1a. Tambi\u00e9n tiene una tercera versi\u00f3n que adem\u00e1s de recibir los dos par\u00e1metros indicados antes, recibe el c\u00f3digo de la variante, por ejemplo ca, para el Catal\u00e1n.</li> </ul> <pre><code>Locale locale = Locale.of(\"es\",\"ES\", \"ca\");\n</code></pre> <p>Java 19</p> <p>En versiones anterior a Java 19, el m\u00e9todo est\u00e1tico <code>of()</code>, no exist\u00eda. En su lugar se usan los constructores (que tienen la misma firma que este m\u00e9todo), que est\u00e1n deprecated en esta versi\u00f3n.</p> </li> </ul> <p>Veamos un ejemplo de como mostrar todos los d\u00edas de la semana en espa\u00f1ol:</p> MainSALIDA <pre><code>public class EnumDays {\n    public void show(){\n        Locale locale = Locale.of(\"es\", \"ES\");\n        for (DayOfWeek day : DayOfWeek.values()) {\n            System.out.printf(\"D\u00eda completo: %s\\n\", day.getDisplayName(TextStyle.FULL, locale));\n            System.out.printf(\"Letra del d\u00eda: %s\\n\", day.getDisplayName(TextStyle.NARROW, locale));\n            System.out.printf(\"D\u00eda abreviado: %s\\n\", day.getDisplayName(TextStyle.SHORT, locale));\n        }\n    }\n\n    public static void main(String[] args) {\n        new EnumDays().show();\n    }\n}\n</code></pre> <pre><code>D\u00eda completo: lunes\nLetra del d\u00eda: L\nD\u00eda abreviado: lun\nD\u00eda completo: martes\nLetra del d\u00eda: M\nD\u00eda abreviado: mar\nD\u00eda completo: mi\u00e9rcoles\nLetra del d\u00eda: X\nD\u00eda abreviado: mi\u00e9\nD\u00eda completo: jueves\nLetra del d\u00eda: J\nD\u00eda abreviado: jue\nD\u00eda completo: viernes\nLetra del d\u00eda: V\nD\u00eda abreviado: vie\nD\u00eda completo: s\u00e1bado\nLetra del d\u00eda: S\nD\u00eda abreviado: s\u00e1b\nD\u00eda completo: domingo\nLetra del d\u00eda: D\nD\u00eda abreviado: dom\n</code></pre>"},{"location":"bloque_ii/tema_9/page-2/#enumerado-de-mes-del-ano","title":"Enumerado de mes del a\u00f1o","text":"<p>En est\u00e1 API, tambi\u00e9n se a\u00f1adi\u00f3 el enum <code>java.time.Month</code> que representa los meses del a\u00f1o. Tiene los mismos m\u00e9todos que los d\u00edas de la semana:</p> <pre><code>public class EnumMonths {\n    public void show(){\n        Locale locale = Locale.of(\"es\", \"ES\");\n        for (Month day : Month.values()) {\n            System.out.printf(\"Mes completo: %s\\n\", day.getDisplayName(TextStyle.FULL, locale));\n            System.out.printf(\"Letra del mes: %s\\n\", day.getDisplayName(TextStyle.NARROW, locale));\n            System.out.printf(\"Mes abreviado: %s\\n\", day.getDisplayName(TextStyle.SHORT, locale));\n        }\n    }\n\n    public static void main(String[] args) {\n        new EnumMonths().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-3/","title":"3 Fechas","text":""},{"location":"bloque_ii/tema_9/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Para poder trabajar con fechas, en Java se usa la clase <code>LocalDate</code>, la cu\u00e1l solo maneja la fecha (no la hora), a diferencia de la clase <code>Date</code> del paquete <code>java.util</code>.</p> <p>Para poder crear una instancia de dicha clase, esta API nos proporciona los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>now()</code>: Obtiene la fecha actual.</li> <li><code>of()</code>: Recibe tres par\u00e1metros, el a\u00f1o, el mes (1 al 12) y el d\u00eda, respectivamente de tipo entero. Existe una versi\u00f3n sobrecargada, que en lugar de recibir el mes como un entero lo recibe como tipo enum Month. Si alg\u00fan dato no es correcto, por ejemplo, se espec\u00edfica un mes err\u00f3neo, o un d\u00eda del mes incorrecto, se lanzar\u00e1 la excepci\u00f3n <code>DateTimeException</code>.</li> <li><code>ofEpochDay()</code>: Recibe un par\u00e1metro de tipo long y crea una fecha a partir de milisegundos, partiendo desde el 01 de Enero de 1970.</li> <li><code>ofYearDay()</code>: Recibe dos par\u00e1metros, el a\u00f1o y el d\u00eda del a\u00f1o de tipo entero. Crear\u00e1 la fecha a partir de ambos datos.</li> </ul> <pre><code>LocalDate today = LocalDate.now();\nLocalDate date1 = LocalDate.of(2022, 5, 24); // 24 de Mayo de 2022\nLocalDate date2 = LocalDate.of(2022, Month.MAY; 24);\nLocalDate date3 = LocalDate.of(2022, 2, 30); // DateTimeException\nLocalDate date4 = LocalDate.ofEpochDay(19527); // 2023-06-19\nLocalDate date5 = LocalDate.ofYearDay(2023, 115); // 2023-04-25\n</code></pre> <p>Algunos m\u00e9todos importantes para trabajar con fechas:</p> <ul> <li><code>getDayOfMonth()</code>. Devuelve el d\u00eda del mes de la fecha indicada.</li> <li><code>getDayOfWeek()</code>. Devuelve una instancia del enum <code>DayOfWeek</code> con el d\u00eda de la semana.</li> <li><code>getDayOfYear()</code>. Devuelve el d\u00eda del a\u00f1o.</li> <li><code>getMonth()</code>. Devuelve una instancia del enum <code>Month</code> con el mes al cual pertenece la fecha.</li> <li><code>getMontValue()</code>. Devuelve un n\u00famero entero (1-12) representativo del mes.</li> <li><code>getYear()</code>. Devuelve el a\u00f1o de una fecha.</li> <li><code>isLeapYear()</code>. Comprueba si la instancia fecha es un a\u00f1o bisiesto.</li> <li><code>lengthOfMonth()</code>. Devuelve el n\u00famero de d\u00edas que tiene el mes.</li> <li><code>lengthOfYear()</code>. Devuelve el n\u00famero de d\u00edas que tiene el a\u00f1o.</li> </ul> <p>Adem\u00e1s de estos m\u00e9todos, tambi\u00e9n posee m\u00e9todos para a\u00f1adir d\u00edas (<code>plusDays()</code>), meses (<code>plusMonths()</code>), semanas (<code>plusWeeks()</code>) y a\u00f1os (<code>plusYears()</code>), y los mismos para restar(<code>minusDays()</code>, <code>minusMOnths()</code>, <code>minusWeeks()</code>, <code>minusYears()</code>, <code>minusDays()</code>)</p> <p>Veamos un ejemplo:</p> <pre><code>public class LocalDateExample {\n    public void show(){\n        LocalDate date = LocalDate.now();\n        infoDate(date);\n\n        LocalDate datePlusTenDays = date.plusDays(10);\n        infoDate(datePlusTenDays);\n\n        LocalDate datePlusTwoMonths = date.plusMonths(2);\n        infoDate(datePlusTwoMonths);\n\n        LocalDate dateMinusOneYear = date.minusYears(1);\n        infoDate(dateMinusOneYear);\n    }\n\n    private void infoDate(LocalDate date) {\n        System.out.printf(\"La fecha es: %s\\n- D\u00eda de la semana: %s\\n- Mes: %s\\n- A\u00f1o: %d\\n- \u00bfEs a\u00f1o bisiesto?: %s\\n\",\n                date, date.getDayOfWeek(), date.getMonth(), date.getYear(), date.isLeapYear() ? \"S\u00ed\" : \"No\");\n    }\n\n    public static void main(String[] args) {\n        new LocalDateExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-3/#yearmonth","title":"YearMonth","text":"<p>Es una clase que representa el mes especifico de un a\u00f1o. Se puede instanciar haciendo uso de los m\u00e9todos est\u00e1ticos <code>now()</code> y <code>of(year, month)</code>, siendo month un entero o un tipo enum <code>Month</code>.</p> <p>Con el m\u00e9todo <code>lengthOfMonth()</code> obtenemos el n\u00famero de d\u00edas que tiene ese mes en ese a\u00f1o.</p> <pre><code>YearMonth year = YearMonth.of(2022, 12); \nSystem.out.println(year.lengthOfMonth()); // 31\n</code></pre> <p>Tiene m\u00e9todos parecidos a los vistos en el punto anterior, para a\u00f1adir y restar meses y a\u00f1os y para saber si el a\u00f1o es bisiesto. Adem\u00e1s tiene lo siguientes m\u00e9todos:</p> <ul> <li><code>isAfter(YearMonth other)</code>: Comprueba si la fecha instanciada es posterior a other.</li> <li><code>isBefore(YearMonth other)</code>: Comprueba si la fecha instanciada es anterior a other.</li> <li><code>isValidDay(int day)</code>: Comprueba si el d\u00eda especificado es un d\u00eda v\u00e1lido dentro de ese mes y a\u00f1o. Por ejemplo, el d\u00eda 29 s\u00ed ser\u00eda un d\u00eda v\u00e1lido para el mes Marzo del 2023 pero no ser\u00eda v\u00e1lido para el 29 de Febrero de 2023.</li> <li><code>withMoth()</code>. Devuelve una copia del a\u00f1o y del mes, pero con el mes alterado.</li> <li><code>withYear()</code>. Devuelve una copia del a\u00f1o y del mes, pero con el a\u00f1o alterado.</li> <li><code>atDay(int day)</code>. Devuelve un objeto de tipo <code>LocalDate</code> con el d\u00eda especificado, pudiendo lanzar un <code>DateTimeException</code> si el d\u00eda no es v\u00e1lido para ese mes y ese a\u00f1o.</li> <li><code>atEndOfMonth</code>: Devuelve un objeto de tipo <code>LocalDate</code>con el d\u00eda en el final del mes.</li> </ul> <p>Veamos un ejemplo haciendo uso de estos m\u00e9todos:</p> <pre><code>public class YearMonthExample {\n    public void show(){\n        YearMonth ym1 = YearMonth.now();\n        YearMonth ym2 = YearMonth.of(2023, 5);\n        YearMonth ym3 = ym1.withMonth(10);\n\n        System.out.println(ym1.isAfter(ym2));\n        System.out.println(ym1.isValidDay(31));\n        System.out.println(ym3.atDay(10));\n        System.out.println(ym3.atEndOfMonth());\n    }\n\n    public static void main(String[] args) {\n        new YearMonthExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-3/#monthday","title":"MonthDay","text":"<p>La clase <code>MonthDay</code> representa un d\u00eda de un mes en particular. Para construir una objeto de dicha clase tenemos los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>of(int month, int day)</code>: Recibe el mes y el d\u00eda del mes de los cuales se quiere construir el objeto. Tiene un versi\u00f3n sobrecargada, que en vez de recibir el mes en formato entero lo recibe como un enum Month.</li> <li><code>now()</code>: Crea una instancia de la clase con el mes y el d\u00eda actual.</li> </ul> <p>La mayor\u00eda de m\u00e9todos son parecidos a los vistos anteriormente, pero adem\u00e1s a\u00f1ade:</p> <ul> <li><code>isValidYear()</code>. Comprueba si ese d\u00eda en ese mes concreto es v\u00e1lido para cierto a\u00f1o. Por ejemplo, si pasamos como par\u00e1metro 2023, y validamos si es correcto el 29 de Febrero, retornar\u00eda false, como dicho d\u00eda en dicho mes y en dicho a\u00f1o, el mes de Febrero no tiene 29 d\u00edas.</li> <li><code>atYear()</code>: Crea una instancia de la clase <code>LocalDate</code> con el a\u00f1o indicado. Si la fecha no es v\u00e1lida, lanzar\u00e1 una excepci\u00f3n de tipo <code>DateTimeException</code>.</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>public class MonthDayExample {\n    public void show(){\n        MonthDay md1 = MonthDay.now();\n        MonthDay md2 = md1.withDayOfMonth(20);\n\n        System.out.println(md1.isBefore(md2));\n        System.out.println(MonthDay.of(2, 29).isValidYear(2024));\n        System.out.println(md1.atYear(2020));\n    }\n\n    public static void main(String[] args) {\n        new MonthDayExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-3/#year","title":"Year","text":"<p>La clase <code>Year</code> nos permite obtener informaci\u00f3n de un a\u00f1o especifico sin importar ni el d\u00eda ni el mes. Para construir un objeto de dicha clase se usa los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>now()</code>. Crea una instancia con el a\u00f1o actual.</li> <li><code>of(int year)</code>: Crea una instancia con el a\u00f1o indicado.</li> </ul> <p>Alguno de sus m\u00e9todos son:</p> <ul> <li><code>atDay(int dayOfYear)</code>: Devuelve un <code>LocalDate</code> con el d\u00eda y el mes obtenido del dayOfYear.</li> <li><code>atMonth(int month)</code>: Devuelve un <code>YearMonth</code> con el mes indicado. Tiene una versi\u00f3n sobrecargada que recibe una instancia del enum <code>Month</code>.</li> <li><code>athMonthDay(MonthDay monthDay)</code>: Devuelve un <code>LocalDate</code> con el d\u00eda y el mes indicados.</li> <li><code>getValue()</code>. Retorna el valor entero del a\u00f1o.</li> <li><code>isLeap()</code>. Comprueba si el a\u00f1o es bisiesto. Adem\u00e1s tiene una versi\u00f3n est\u00e1tica <code>isLeap(int year)</code> para comprobar si el a\u00f1o indicado es bisiesto sin necesidad de crear una instancia de la clase <code>Year</code>.</li> <li><code>length()</code>. Devuelve el n\u00famero de d\u00edas que tiene ese a\u00f1o.</li> </ul> <p>Adem\u00e1s tiene m\u00e9todos similares a las clases anteriores. Veamos un ejemplo:</p> <pre><code>public class YearExample {\n    public void show(){\n        Year year1 = Year.now();\n        Year year2 = Year.of(2023);\n\n        System.out.println(year1.isAfter(year2));\n        System.out.println(year1.atDay(123));\n        System.out.println(year1.atMonth(Month.APRIL));\n        System.out.println(\"A\u00f1o en entero: \" + year1.getValue());\n        System.out.println(\"N\u00famero de d\u00edas: \" + year1.length());\n        System.out.println(Year.isLeap(2024));\n    }\n\n    public static void main(String[] args) {\n        new YearExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-4/","title":"Horas","text":""},{"location":"bloque_ii/tema_9/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta API, las horas se pueden manejar de forma independiente a la fecha, con la clase <code>LocalTime</code>. Tiene un funcionamiento bastante similar a la clase <code>LocalDate</code>.</p> <p>Una de las utilidades de esta clase es la capacidad de representar el tiempo de un d\u00eda, como por ejemplo, la hora de inicio de una pel\u00edcula, la hora de apertura de una biblioteca, etc. Hacen referencia a un d\u00eda cualquiera, sin indicar una fecha concreta.</p> <pre><code>public class LocalTimeExample {\n    public void show(){\n        LocalTime time = LocalTime.now();\n        System.out.println(time);\n\n        time = time.plusHours(10);\n        System.out.println(time);\n\n        time = time.minusMinutes(20);\n        System.out.println(time);\n    }\n\n    public static void main(String[] args) {\n        new LocalTimeExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-4/#localdatetime","title":"LocalDateTime","text":"<p>Por el contrario, si se desea manejar el tiempo de una fecha concreta, la API nos proporciona la clase <code>LocalDateTime</code>, que representa la fecha y la hora y es una combinaci\u00f3n de LocalDate y LocalTime.</p> <p>Tiene m\u00e9todos muy parecidos de las dos clases que combina y adem\u00e1s tiene m\u00e9todos est\u00e1ticos para construir una instancia de la clase:</p> <ul> <li><code>of(int year, int month, int day, int hour, int minute, int second)</code>. Crea una instancia de la clase con los datos proporcionados. Adem\u00e1s tiene una sobrecarga donde no recibe los segundos, otra sobrecarga donde tambi\u00e9n recibe los nano segundos, adem\u00e1s de las sobrecargas donde recibe un valor del enum <code>Month</code>.</li> <li><code>of(LocalDate date, LocalTime time)</code>. Crea una instancia de la clase combinando el date y el time indicados.</li> <li><code>now()</code>. Crea una instancia de la clase con la fecha y hora actual.</li> </ul> <p>Veamos un ejemplo con el uso de estos constructores y algunos de sus m\u00e9todos</p> <pre><code>public class LocalDateTimeExample {\n\n    private void show() {\n        LocalDate date = LocalDate.now();\n        LocalTime time = LocalTime.now();\n        LocalDateTime dateTime = LocalDateTime.of(date, time);\n\n        System.out.println(dateTime.plusHours(10));\n        System.out.println(dateTime.minusMonths(12));\n        System.out.println(dateTime.toLocalDate());\n    }\n\n    public static void main(String[] args) {\n        new LocalDateTimeExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-5/","title":"Formateo de fechas","text":""},{"location":"bloque_ii/tema_9/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>La API de Java nos proporciona clase clase para formatear las fechas y las horas, <code>DateTimeFormatter</code>, al igual que su antecesora est\u00e1 compuesta de patrones de cadena que representas diferentes s\u00edmbolos relacionados con las fechas:</p> <ul> <li>y, nos permite acceder al a\u00f1o en formato de cuatro o dos d\u00edgitos (2014 o 14).</li> <li>D, nos permite obtener el n\u00famero de d\u00eda del a\u00f1o (225).</li> <li>d, al contrario del anterior nos devuelve el n\u00famero del d\u00eda del mes en cuesti\u00f3n (27).</li> <li>L, nos ayuda a obtener el mes del a\u00f1o en forma num\u00e9rica, M nos da el mes en texto.</li> <li>H, nos da la hora.</li> <li>s, nos da los segundos.</li> <li>m, nos permite obtener los minutos.</li> <li>a, nos da el am o pm de la hora.</li> <li>z, nos permite acceder al nombre de la zona horaria.</li> </ul> <p>Info</p> <p>Para ver m\u00e1s patrones puede visitar la API: https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/time/format/DateTimeFormatter.html</p> <p>Para construir una instancia de esta clase, existe un m\u00e9todo est\u00e1tico <code>ofPattern(str)</code> que recibe una cadena con los patronos indicados. Existe una versi\u00f3n sobrecargada que adem\u00e1s recibe un <code>Locale</code> para devolver la fecha formateado al idioma deseado.</p> <p>Si el m\u00e9todo recibe un patr\u00f3n err\u00f3neo lanzar\u00e1 la excepci\u00f3n <code>IllegalArgumentException</code></p> <pre><code>DateTimeFormatter format = DateTimeFormatter.ofPattern(\"dd/M/yyyy\", Locale.of(\"es\", \"ES\"));\n</code></pre>"},{"location":"bloque_ii/tema_9/page-5/#parsear-una-fecha-a-cadena","title":"Parsear una fecha a cadena","text":"<p>Las clases LocalDate, LocalTime, LocalDateTime, YearMonth, MonthDay, y el resto de clases referidas a las fechas tienen un m\u00e9todo <code>format()</code> que recibe un objeto de la clase <code>DateTimeFormatter</code> para formatear la fecha con dicho formato. Adem\u00e1s la clase <code>DateTimeFormatter</code> tiene el mismo m\u00e9todo, pero recibe un objeto fecha.</p> <p>Veamos un ejemplo:</p> <pre><code>public class DateToString {\n    public void show(){\n        LocalDateTime date = LocalDateTime.now();\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd/M/yy\");\n\n        System.out.println(date.format(formatter));\n    }\n\n    public static void main(String[] args) {\n        new DateToString().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-5/#parsear-una-cadena-a-una-fecha","title":"Parsear una cadena a una fecha","text":"<p>Las clases de manejo de fecha, tienen un m\u00e9todo est\u00e1tico llamado <code>parse</code>, que recibe la fecha en formato cadena, y un formato (en caso de no recibirlo, tiene una versi\u00f3n sobrecargada donde obtiene el formato est\u00e1ndar) devolviendo as\u00ed un objeto de tipo fecha. En caso de que la cadena no cumpla con el patr\u00f3n se lanzar\u00e1 una excepci\u00f3n <code>DateTimeParseException</code></p> <pre><code>public class StringToDate {\n    public void show(){\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd-LL-yyyy\");\n        System.out.println(LocalDate.parse(\"20-03-2023\", formatter));\n    }\n\n    public static void main(String[] args) {\n        new StringToDate().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-6/","title":"Otras clase de manejo de fechas","text":""},{"location":"bloque_ii/tema_9/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>La API de Java, a parte de todas las clases ya vistas, contiene otras clases para el manejo de fechas y horas:</p> <ul> <li><code>Instant</code>: Esta clase modela un solo punto instant\u00e1neo en la l\u00ednea de tiempo. Esto podr\u00eda usarse para registrar marcas de tiempo de eventos en la aplicaci\u00f3n.</li> <li><code>Period</code>: Una cantidad de tiempo basada en fechas en el sistema de calendario ISO-8601, como '2 a\u00f1os, 3 meses y 4 d\u00edas'. Esta clase modela una cantidad o cantidad de tiempo en t\u00e9rminos de a\u00f1os, meses y d\u00edas.</li> <li><code>ZonedDateTime</code> es una representaci\u00f3n inmutable de una fecha y hora con una zona horaria. Esta clase almacena todos los campos de fecha y hora, con una precisi\u00f3n de nanosegundos, y una zona horaria, con un desplazamiento de zona utilizado para manejar fechas y horas locales ambiguas. Por ejemplo, el valor \"2 de octubre de 2007 a las 13:45.30.123456789 +02:00 en la zona horaria de Europa/Par\u00eds\" se puede almacenar en un archivo ZonedDateTime.</li> </ul>"},{"location":"bloque_ii/tema_9/page-6/#chronounit","title":"ChronoUnit","text":"<p>El enum <code>ChronoUnit</code> contiene unidades para fechas y horas, como por ejemplo, DAYS, MONTHS, WEEKS, YEARS, HOURS, MINUTES, SECONDS, etc. Representa una unidad de tiempo y tiene m\u00e9todo que nos permite manejar fechas como <code>between</code> que te devuelve la distancia entre dos fechas. Veamos un ejemplo:</p> <pre><code>public class ChronosUnitExample {\n\n    private void show() {\n        LocalDateTime today = LocalDateTime.now();\n        LocalDateTime someDay = LocalDateTime.of(2022, 6, 6, 0, 0, 0);\n\n        for (ChronoUnit chronoUnit: ChronoUnit.values()) {\n            System.out.printf(\"La diferencia entre %s y %s en %s: %d\\n\", today, someDay, chronoUnit,\n                    chronoUnit.between(today, someDay));\n        }\n    }\n\n    public static void main(String[] args) {\n        new ChronosUnitExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-7/","title":"Ejercicios","text":"Ejercicio 1 <p>Escribir un m\u00e9todo que reciba una fecha y devuelva el d\u00eda de la semana que corresponde para esta fecha.</p> Ejercicio 2 <p>Realiza un m\u00e9todo que reciba una hora y devuelva los nanosegundos. Comprueba que ta el mismo resultado que el m\u00e9todo toNanoOfDay de la clase LocalTime.</p> Ejercicio 3 <p>Realiza un m\u00e9todo que reciba una fecha de nacimiento de devuelva la edad.</p> Ejercicio 4 <p>Realiza una clase para convertir fechas que tenga los siguientes m\u00e9todos. Haz un programa para probarlo:</p> <ul> <li><code>String europeaToAmerican(String)</code>: este m\u00e9todo convierte una fecha en formato europeo (dia/mes/a\u00f1o) a formato americano (mes/dia/a\u00f1o).</li> <li><code>String americanToEuropea(string)</code>: este m\u00e9todo realiza el paso contrario, convierte fechas de formato americano a formato europeo.</li> </ul> Ejercicio 5 <p>Realiza un programa que muestre la fecha del sistema de la siguiente manera: Hoy es s\u00e1bado 12-marzo-2011 a las 10:22:13</p> Ejercicio 6 <p>Realiza un m\u00e9todo que reciba un mes y un d\u00eda correspondiente a este a\u00f1o y devuelva el n\u00famero de d\u00edas que han pasado desde el 1 de Enero de este a\u00f1o hasta dicho d\u00eda.</p> Ejercicio 7 <p>Realiza un m\u00e9todo de decodifique fechas del siglo XXI. El dato es un entero comprendido entre 10100 y 311299. El resultado es una secuencia de caracteres: n\u00famero del d\u00eda dentro del mes, del mes dentro del a\u00f1o y del a\u00f1o dentro del siglo. Por ejemplo, para el dato 30485, el resultado es el texto 3-4-2085.</p> Ejercicio 8 <p>Realiza un m\u00e9todo que reciba d\u00eda, mes y a\u00f1o y devuelva una cadena con la fecha. Ejemplo:</p> <p>D\u00eda: Jueves Mes: Mayo A\u00f1o: 2012 El m\u00e9todo devolver\u00e1 03/05/2012 ya que coge el primer jueves de mayo.</p> Ejercicio 9 <p>Realiza un m\u00e9todo que reciba una cadena con una fecha y devuelva si dicha fecha es correcta.</p> Ejercicio 10 <p>Realiza un m\u00e9todo que reciba un a\u00f1o y devuelva si es bisiesto o no. No se puede usar el m\u00e9todo isLeap().</p> Ejercicio 11 <p>Realiza un m\u00e9todo que dada dos fechas te devuelva la diferencia de ambas. Utilizar una de las clases indicadas (investigar API).</p> Ejercicio 12 <p>Realiza un m\u00e9todo que reciba un a\u00f1o y un mes y dibuje el calendario de ese mes dentro de ese a\u00f1o con el siguiente formato:</p> <pre><code>      Jun-23\n L  M  X  J  V  S  D\n          1  2  3  4\n 5  6  7  8  9 10 11\n12 13 14 15 16 17 18\n19 20 21 22 23 24 25\n26 27 28 29 30\n</code></pre> <p>Realiza una nueva version donde reciba solamente el a\u00f1o y muestre el calendario de ese a\u00f1o. Por \u00faltimo realiza otra versi\u00f3n, donde no reciba ning\u00fan par\u00e1metro y muestre el calendario del a\u00f1o actual, marcando el d\u00eda actual.</p>"},{"location":"bloque_ii/tema_9/page-8/","title":"Proyecto","text":"<p>En este proyecto se va a realizar cambios en el proyecto conocido como common.</p> <p>Para ello se va a a\u00f1adir los siguientes m\u00e9todos a la clase ConsoleInput:</p> <ul> <li>readDate(): Este m\u00e9todo retornar\u00e1 una fecha v\u00e1lida le\u00edda por teclado con el formato por defecto.</li> <li>readTime(): Este m\u00e9todo retornar\u00e1 una hora v\u00e1lida le\u00edda por teclado con el formato por defecto.</li> <li>readDateTime(): Este m\u00e9todo retornar\u00e1 una fecha y hora v\u00e1lida le\u00edda por teclado con el formato por defecto.</li> </ul> <p>Se sobrescribir\u00e1n los m\u00e9todos anteriores para que adem\u00e1s reciban un par\u00e1metro con el formato con el que se desea leer.</p> <p>Adem\u00e1s, se va a crear la clase Dates en la cu\u00e1l se llevaran a cabo atributos y m\u00e9todos de utilidad (est\u00e1ticos) para trabajar con fechas de la API Java 8.</p> <p>Se crear\u00e1n varios atributos con los patrones de fechas siguientes, (teniendo en cuenta que coger\u00e1 el idioma por defecto del ordenador)</p> <ul> <li>FULL_DATE: Tuesday, 20 June 2023, 12:40:15</li> <li>DATE: Tue, 20 June 2023, 12:40</li> <li>SHORT_DATE: 20 June 2023, 12:40</li> <li>NUMBER_DATE: 20/06/2023, 12:40</li> <li>ONLY_FULL_DATE: Tuesday, 20 June 2023</li> <li>ONLY_DATE: Tue, 20 June 2023</li> <li>ONLY_SHORT_DATE: 20 June 2023</li> <li>ONLY_NUMBER_DATE: 20/06/2023</li> <li>ONLY_TIME: 12:40</li> </ul> <p>Info</p> <p>Puedes a\u00f1adir todos los patrones que consideres oportunos si no est\u00e1n en la lista anterior.</p> <p>Se crear\u00e1n, tambi\u00e9n, los siguientes m\u00e9todos:</p> <ul> <li>betweenDay(date1, date2): Calcula la diferencia en d\u00edas de dos fechas.</li> <li>betweenMonth(date1, date2): Calcula la diferencia en meses de dos fechas.</li> <li>betweenYear(date1, date2): Calcula la diferencia en a\u00f1os de dos fechas.</li> <li>betweenHours(date1, date2): Calcula la diferencia en horas de dos fechas.</li> <li>betweenMinutes(date1, date2): Calcula la diferencia en minutos de dos fechas.</li> <li>betweenSeconds(date1, date2): Calcula la diferencia en segundos de dos fechas.</li> <li>betweenDecades(date1, date2): Calcula la diferencia en d\u00e9cadas de dos fechas.</li> <li>betweenCenturies(date1, date2): Calcula la diferencia en siglos de dos fechas.</li> <li>betweenMillennia(date1, date2): Calcula la diferencia en milenios de dos fechas.</li> <li>between(date1, date2): Calcula el per\u00edodo de tiempo entre dos fechas.</li> <li>format(date): Devuelve una cadena formateada por el formato por defecto.</li> <li>isValidDate(string): Comprueba si la cadena cumple con un formato de fecha.</li> <li>getFirstDate(dayOfWeek, month, year): Devuelve una fecha con el primer un d\u00eda de la semana, mes y a\u00f1o.</li> <li>getLastDate(dayOfWeek, month, year): Devuelve una fecha con el \u00faltimo d\u00eda de la semana, mes y a\u00f1o.</li> <li>calendar(month, year): Muestra un calendario de la mes y a\u00f1o indicado.</li> <li>calendar(month, year, date): Muestra un calendario del mes y del a\u00f1o indicado con la fecha se\u00f1alizada. Si la fecha no coincide con el mes y a\u00f1o indicado, no se se\u00f1alizar\u00e1.</li> <li>calendar(year): Muestra un calendario del a\u00f1o especificado.</li> <li>calendar(year, date): Muestra un calendario del a\u00f1o especificado con la fecha se\u00f1alada. Si la fecha no coincide con el  a\u00f1o indicado, no se se\u00f1alizar\u00e1.</li> <li>calendar(date): Muestra un calendario del a\u00f1o actual con la fecha se\u00f1alada. Si la fecha no coincide con el a\u00f1o actual no se se\u00f1alizar\u00e1.</li> <li>calendar(): Muestra un calendario del a\u00f1o actual con la fecha de hoy se\u00f1alada.</li> </ul> <p>Adem\u00e1s de todos estos m\u00e9todos indicados, se a\u00f1adir\u00e1 un m\u00e9todo a la clase String, toDate(string), que devuelve una fecha dado una cadena.</p> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>NO se realizar\u00e1 una versi\u00f3n sobre el proyecto 6, sino que se realizar\u00e1 un copia de dicho proyecto en esta versi\u00f3n</li> <li>Se mantendr\u00e1 el paquete principal llamado <code>com.NOMBRE.common</code> donde nombre ser\u00e1 el nombre del alumno y common el nombre del proyecto.</li> <li>Se deber\u00e1n sobrescribir los m\u00e9todos necesarios para que reciban los diferentes tipos de fechas que hay.</li> <li>Se crear\u00e1 una clase Main, donde se ponga en pr\u00e1ctica los usos de la librer\u00eda y se valorar\u00e1 la complejidad de dicho Main.</li> <li>Se deber\u00e1n respetar el nombre de las funciones.</li> <li>El nombre del resto de funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre <code>pr09java-NOMBRE-dates</code> siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_iii/tema_11/page-1/","title":"1 Introducci\u00f3n a las colecciones","text":""},{"location":"bloque_iii/tema_11/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Una colecci\u00f3n representa un grupo de objetos. Estos objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almac\u00e9n donde poder guardarlos.</p> <p>Las colecciones son estructuras de datos con la peculiaridad de que son estructuras din\u00e1micas. Eso quiere decir que pueden aumentar o disminuir su tama\u00f1o dependiendo de los elementos que almacenan, lo que suponen una mejora respecto a las estructuras de datos est\u00e1ticas cuyo tama\u00f1o se define en su creaci\u00f3n y no se puede alterar en tiempo de ejecuci\u00f3n, como por ejemplo, los arrays.</p> <p>El API de Java nos proporciona en el paquete <code>java.util</code> el framework de las colecciones, que nos permite utilizar diferentes estructuras de datos para almacenar y recuperar objetos de cualquier clase. Java tiene desde la versi\u00f3n 2 todo un juego de clases e interfaces para guardar colecciones de objetos donde todas las entidades conceptuales est\u00e1n representadas por interfaces y las clases se usan para proveer implementaciones de esas interfaces. Estas clases e interfaces est\u00e1n estructuradas en una jerarqu\u00eda.</p> <p>Pero \u00bfqu\u00e9 podemos almacenar dentro de una colecci\u00f3n? Podemos almacenar cualquier objeto que herede de la clase <code>Object</code>. Pero esto presenta ciertos inconvenientes:</p> <ul> <li>Podr\u00edamos tener una colecci\u00f3n con objetos completamente distintos, lo que puede dar lugar a problemas ya que en todo momento deber\u00edamos saber qu\u00e9 tipo de objeto y qu\u00e9 posici\u00f3n de la colecci\u00f3n se encuentra el elementos con el que queremos trabajar, de otro modo podr\u00edamos tener incongruencias en el c\u00f3digo e incluso hacer saltar una excepci\u00f3n.</li> <li>Otro inconveniente es que tendr\u00edamos que hacer continuos castings para poder trabajar con los elementos de la colecci\u00f3n, lo cual resulta tedioso y poco productivo.</li> </ul> <p>Veamos un ejemplo para obtener la suma de los valores almacenados en una lista:</p> <pre><code>int total = 0;\nArrayList numbers = new ArrayList(); // Creaci\u00f3n de la lista\nnumbers.add(1); // Se a\u00f1ade el elemento 1 a la lista utilizando el m\u00e9todo add\nnumbers.add(2);\nnumbers.add(3);\n\nfor(int i = 0; i &lt; numbers.size(); i++){\n    // No vemos obligados a hacer cast, dado que numbers.get(i) retorna un Object:\n    total += (int) numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>Como vemos en el ejemplo anterior, nos vemos obligados a hacer expl\u00edcitamente un cast cuando obtenemos un elemento de la lista, dado que la lista internamente trabaja con elementos de la clase <code>Object</code>. No hay ning\u00fan contrato que permita a la clase <code>ArrayList</code> saber qu\u00e9 tipo de datos queremos que trabaje.</p> <p>Adem\u00e1s, es posible a\u00f1adir elementos de distinto tipo a la lista, con el agravante de que m\u00e1s adelante cuando se intenta acceder al elemento y se hace cast sobre \u00e9l se producir\u00e1 un error en tiempo de ejecuci\u00f3n. As\u00ed, si modificamos el ejemplo anterior de la siguiente manera:</p> <pre><code>int total = 0;\nArrayList numbers = new ArrayList(); \nnumbers.add(1);\nnumbers.add(2);\nnumbers.add(\"Antonio\");\n\nfor(int i = 0; i &lt; numbers.size(); i++){\n    // Esta l\u00ednea lanza una excepci\u00f3n cuando\n    // se trata de convertir a entero el elemento \"Antonio\",\n    total += (int) numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>As\u00ed pues, para resolver este problema, a partir de la versi\u00f3n 5 de Java empezaron a utilizar los gen\u00e9ricos. Los gen\u00e9ricos nos permiten establecer un tipo con el que vamos a trabajar en esa colecci\u00f3n, de esa manera podemos evitar los problemas mencionados anteriormente.</p> <p>As\u00ed el ejemplo anterior podr\u00edamos modificarlo de la siguiente manera:</p> <pre><code>int total = 0;\nArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); \nnumbers.add(1);\nnumbers.add(2);\n//Esta l\u00ednea da un error de compilaci\u00f3n, dado que el compilador\n// detecta que estamos intentado a\u00f1adir una cadena a la lista de enteros:\nnumbers.add(\"Antonio\");\n\nfor(int i = 0; i &lt; numbers.size(); i++){\n    // Ya no es necesario hacer un cast expl\u00edcito, dado que el compilador\n    // lo har\u00e1 internamente por nosotros, al haberle informado de que quer\u00edamos\n    // trabajar con una lista de enteros\n    total += numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>Como vemos en el ejemplo anterior, gracias a la informaci\u00f3n que le suministramos al compilador sobre el tipo de lista con el que queremos trabajar, en este caso <code>Integer</code>, el compilador es capaz de detectar en tiempo de compilaci\u00f3n que no deber\u00eda ser posible a\u00f1adir una cadena a la lista, y adem\u00e1s nos evita tener que hacer expl\u00edcitamente el cast a entero cuando obtenemos los elementos de la lista, porque ya lo puede hacer \u00e9l internamente por nosotros.</p> <p>Lo que se use en un gen\u00e9rico debe ser un objeto, por lo tanto, los gen\u00e9ricos no funcionan con datos primitivos. Para resolver esta situaci\u00f3n, la API de Java incorpora las clases envoltorio (wrapper class) que no son m\u00e1s que dotar a los datos primitivos con un envoltorio que permita tratarlos como objetos. Las clases envoltorios proporcionan m\u00e9todos de utilidad para la manipulaci\u00f3n de datos primitivos (conversiones de / hacia datos primitivos, conversiones a String, etc).</p>"},{"location":"bloque_iii/tema_11/page-2/","title":"2 ArrayList","text":""},{"location":"bloque_iii/tema_11/page-2/#interfaz-collection","title":"Interfaz Collection","text":"<p>Es la interfaz ra\u00edz de la jerarqu\u00eda de las colecciones. Java no proporciona ninguna implementaci\u00f3n directa de esta interfaz, sino que proporciona implementaciones de sub-interfaces m\u00e1s espec\u00edficas como Set y List. Esta interfaz se utiliza normalmente para pasar colecciones y manipularlas cuando se desea la m\u00e1xima generalidad.</p> <p>Veamos algunos de los m\u00e9todos que podemos observar en la API</p> <ul> <li><code>boolean add(E e)</code>: a\u00f1ade el elemento e a la colecci\u00f3n.</li> <li><code>boolean addAll(Collection &lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de la colecci\u00f3n c.</li> <li><code>void clear()</code>: elimina todos los elementos de la colecci\u00f3n.</li> <li><code>boolean contains(Object o)</code>: comprueba si el elemento o est\u00e1 en la colecci\u00f3n.</li> <li>boolean containsAll(Collection&lt;?&gt; c) : comprueba si todos los elementos de c est\u00e1n en la colecci\u00f3n.</li> <li><code>boolean isEmpty()</code>: comprueba si la colecci\u00f3n est\u00e1 vac\u00eda.</li> <li><code>boolean remove(Object o)</code>: elimina de la colecci\u00f3n el elemento o.</li> <li><code>boolean removeAll(Collection&lt;?&gt; c)</code>: elimina de la colecci\u00f3n todos los elementos de c.</li> <li><code>boolean retainAll(Collection&lt;?&gt; c)</code>: elimina de la colecci\u00f3n todos los elementos exceptos los que est\u00e1n en c, es decir, obtiene la intersecci\u00f3n.</li> <li><code>int size()</code>: devuelve el tama\u00f1o de la colecci\u00f3n.</li> </ul>"},{"location":"bloque_iii/tema_11/page-2/#interfaz-list","title":"Interfaz List","text":"<p>Esta interfaz es una sub-interfaz o interfaz hija de Collection, por lo tanto, tiene todos los m\u00e9todos de Collection y adem\u00e1s a\u00f1ade los suyos propios.</p> <p>Este tipo de colecci\u00f3n se refiere a listas en las que los elementos de la colecci\u00f3n tienen un orden, es decir, existe una secuencia de elementos. Cada elemento tiene un \u00edndice o posici\u00f3n. El primer elemento ocupa la posici\u00f3n 0. La interfaz List s\u00ed admite elementos duplicados.</p> <p>Veamos algunos de los m\u00e9todos que podemos observar en la API:</p> <ul> <li><code>void add(int index, E element)</code>: inserta el elemento E en la posici\u00f3n index.</li> <li><code>boolean add(E e)</code>: a\u00f1ade el elemento e al final de la lista.</li> <li><code>boolean addAll(int index, Collection &lt;? extends E&gt; c)</code>: inserta todos los elementos de c en la posici\u00f3n index.</li> <li><code>boolean addAll(Collection &lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de c al final de la lista.</li> <li><code>E get(int index)</code>: devuelve el elemento de la posici\u00f3n index.</li> <li><code>int indexOf(Object o)</code>: devuelve el \u00edndice de la primera ocurrencia del elemento o en la lista, o -1 si la lista no contiene el elemento.</li> <li><code>int lastIndexOf(Object o)</code>: devuelve el \u00edndice de la \u00faltima ocurrencia del elemento o en la lista, o -1 si la lista no contiene el elemento.</li> <li><code>E remove(int index)</code>: elimina el elemento que se encuentra en la posici\u00f3n index. E set(int index, E element): reemplaza el elemento que se encuentra en index por el elemento element.</li> <li><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code>: devuelve la sub-lista comprendida entre las posiciones fromIndex incluida y toIndex excluida.</li> </ul> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java para la interfaz List, como por ejemplo, ArrayList.</p>"},{"location":"bloque_iii/tema_11/page-2/#la-clase-arraylist","title":"La clase ArrayList","text":"<p>Se basa en un array redimensionable que aumenta su tama\u00f1o seg\u00fan crece la colecci\u00f3n de elementos. Lo bueno es que el tiempo de acceso a un elemento en particular es \u00ednfimo. Lo malo es que si queremos eliminar un elemento del principio o del medio, la clase debe mover todos los que le siguen a la posici\u00f3n anterior, para tapar el agujero que deja el elemento removido. Esto hace que sacar elementos del medio o del principio sea costoso.</p> <p>ArrayList mantiene el orden de inserci\u00f3n, es decir, si recorremos la colecci\u00f3n se nos mostrar\u00e1 en el mismo orden en que insertamos los objetos.</p> <p>Veamos un ejemplo de declaraci\u00f3n e inicializaci\u00f3n:</p> <pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n</code></pre> <p>A partir de java7, no es necesario indicar el gen\u00e9rico en la inicializaci\u00f3n:</p> <pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n</code></pre> <p>Para hacer el c\u00f3digo m\u00e1s gen\u00e9rico, se puede definir la variable de tipo interfaz, ya que dicho c\u00f3digo podr\u00eda funcionar con cualquier clase que implemente la interfaz, simplemente habr\u00eda que cambiar el new:</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n</code></pre> <p>Veamos un ejemplo de ArrayList donde utiliza m\u00e9todos tanto de Collection como de List:</p> C\u00f3digoSalida <pre><code>import java.util.ArrayList;\nimport java.util.List;\n\npublic class ShowArrayList{\n    public void show(){\n\n        List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\n        List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\n        List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();\n\n        list1.add(1);\n        list1.add(2);//Se a\u00f1aden los elementos al final de la lista\n        list1.add(6);\n        list1.add(2, 5);//Se a\u00f1ade el 5 en la posici\u00f3n 2\n\n        for (Integer i : list1) {//Recorremos la lista con un bucle for-each: 1 2 5 6\n            System.out.printf(\" %d \", i);\n        }\n\n        System.out.println();\n\n        list2.add(3);\n        list2.add(4);\n        list1.addAll(2, list2);//Se inserta list2 en la posici\u00f3n 2 de list1\n\n        for (Integer i : list1) {// 1 2 3 4 5 6\n            System.out.printf(\" %d \", i);\n        }\n\n        System.out.println();\n\n        list3.add(7);\n        list3.add(8);\n        list1.addAll(list3);//Se inserta list3 al final de list1\n\n        for (Integer i : list1) {// 1 2 3 4 5 6 7 8\n            System.out.printf(\" %d \", i);\n        }\n\n        System.out.printf(\"\\nEl elemento 3 de list1 es: %d\", list1.get(3));//4\n        System.out.printf(\"\\nLa posici\u00f3n del 4 en list1 es: %d\", list1.indexOf(4));//3\n        list1.add(4);//Se a\u00f1ade un 4 al final de list1\n\n        System.out.printf(\"\\nLa posici\u00f3n del 4 en list1 por el final es: %d\\n\", list1.lastIndexOf(4));//8\n\n        list1.remove(8);//Se elimina el elemento de la posici\u00f3n 8, que es el \u00faltimo 4 insertado\n\n        for (Integer i : list1) {// 1 2 3 4 5 6 7 8\n            System.out.printf(\" %d \", i);\n        }\n\n        list1.set(6, 8);//Se reemplaza el elemento que se encuentra en la posici\u00f3n 6 por un 8\n        System.out.println();\n\n        for (Integer i : list1) {// 1 2 3 4 5 6 8 8\n            System.out.printf(\" %d \", i);\n        }\n\n        System.out.printf(\"\\nLa sub-lista comprendida entre las posiciones 2 y 5 es: \");\n        for (Integer i : list1.subList(2, 6)) {// 3 4 5 6\n            System.out.printf(\" %d \", i);\n        }\n\n        System.out.printf(\"\\nEl 4 %s se encuentra en list1\", list1.contains(4) ? \"s\u00ed\" : \"no\");//s\u00ed\n        System.out.printf(\"\\nEl 9 %s se encuentra en list1\", list1.contains(9) ? \"s\u00ed\" : \"no\");//no\n        //list1: 1 2 3 4 5 6 8 8\n        //list2: 3 4\n        //list3: 7 8\n\n        System.out.printf(\"\\nTodos los elementos de list2 %s se encuentran en list1\", list1.containsAll(list2) ? \"s\u00ed\" : \"no\");//s\u00ed\n\n        System.out.printf(\"\\nTodos los elementos de list3 %s se encuentran en list1\\n\",\n        list1.containsAll(list3) ? \"s\u00ed\" : \"no\");//no\n\n        list1.removeAll(list3);//Se eliminan de list1 todos los elementos de list3, es decir, el 8\n\n        for (Integer i : list1) {// 1 2 3 4 5 6\n            System.out.printf(\" %d \", i);\n        }\n\n        System.out.println();\n        list1.retainAll(list2);//Intersecci\u00f3n entre list1 y list2\n\n        for (Integer i : list1) {// 3 4\n            System.out.printf(\" %d \", i);\n        }\n\n        System.out.printf(\"\\nEl tama\u00f1o de list1 es: %d\", list1.size());//2\n        System.out.printf(\"\\nlist1 %s est\u00e1 vac\u00eda\", list1.isEmpty() ? \"s\u00ed\" : \"no\");//no\n\n        list1.clear();//Elimina todos los elementos de list1\n\n        System.out.printf(\"\\nlist1 %s est\u00e1 vac\u00eda\", list1.isEmpty() ? \"s\u00ed\" : \"no\");//s\u00ed\n    }\n\n    public static void main(String[] args) {\n        new ShowArrayList().show();\n    }\n}\n</code></pre> <pre><code>1 2 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6 7 8\nEl elemento 3 de list1 es: 4\nLa posici\u00f3n del 4 en list1 es: 3\nLa posici\u00f3n del 4 en list1 por el final es: 8\n1 2 3 4 5 6 7 8\n1 2 3 4 5 6 8 8\nLa sub-lista comprendida entre las posiciones 2 y 5 es: 3 4 5 6\nEl 4 s\u00ed se encuentra en list1\nEl 9 no se encuentra en list1\nTodos los elementos de list2 s\u00ed se encuentran en list1\nTodos los elementos de list3 no se encuentran en list1\n1 2 3 4 5 6\n3 4\nEl tama\u00f1o de list1 es: 2\nlist1 no est\u00e1 vac\u00eda\nlist1 s\u00ed est\u00e1 vac\u00eda\n</code></pre>"},{"location":"bloque_iii/tema_11/page-2/#iteradores","title":"Iteradores","text":"<p>En dise\u00f1o de software, el patr\u00f3n de dise\u00f1o Iterador (en ingl\u00e9s, Iterator) define una interfaz que declara los m\u00e9todos necesarios para acceder secuencialmente a un grupo de objetos de una colecci\u00f3n.</p> <p>Este patr\u00f3n debe ser utilizado cuando se requiera una forma est\u00e1ndar de recorrer una colecci\u00f3n, es decir, cuando no sea necesario que un cliente sepa el tipo de colecci\u00f3n que est\u00e1 recorriendo.</p> <p>La interfaz <code>Iterable&lt;T&gt;</code> contiene el m\u00e9todo iterator() que devuelve una instancia de alguno clase que implemente la interfaz <code>Iterator&lt;T&gt;</code>:</p> <ul> <li><code>Iterator&lt;T&gt; iterator()</code>: devuelve un iterador al comienzo de la colecci\u00f3n.</li> </ul> <p>La interfaz <code>Iterator&lt;E&gt;</code> permite el acceso secuencial a los elementos de una colecci\u00f3n y realizar recorridos sobre la colecci\u00f3n. Los m\u00e9todos de <code>Iterator&lt;E&gt;</code> son:</p> <ul> <li><code>boolean hasNext()</code>: comprueba si hay siguiente elemento.</li> <li><code>E next()</code>: devuelve el siguiente elemento y mueve el iterador.</li> <li><code>void remove()</code>: se invoca despu\u00e9s de next() para eliminar el \u00faltimo elemento le\u00eddo.</li> </ul> <p>La interfaz <code>Collection&lt;E&gt;</code> es una sub-interfaz o interfaz hija de <code>Iterable&lt;E&gt;</code>, as\u00ed que dispone del m\u00e9todo <code>iterator()</code>. Veamos un ejemplo de un <code>ArrayList&lt;E&gt;</code>utilizando iteradores:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class ShowIterator{\n    public void show(){\n        Iterator&lt;String&gt; it;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(\"Juan\");\n        list.add(\"Antonio\");\n        list.add(\"Jaime\");\n        list.add(\"Vicente\");\n\n        it = list.iterator();\n\n        while(it.hasNext()){\n            System.out.println(it.next());\n        }\n    }\n\n    public static void main(String[] args){\n        new ShowIterator().show();\n    }\n}\n</code></pre> <pre><code>Juan\nAntonio\nJaime\nVicente\n</code></pre> <p>Si no hay siguiente, <code>next()</code> lanza una excepci\u00f3n <code>NoSuchElementException</code>:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class NextException {\n    public void show() {\n        Iterator&lt;String&gt; it;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(\"Juan\");\n        it = list.iterator();\n        System.out.println(it.next());\n        System.out.println(it.next());//(1)!\n    }\n\n    public static void main(String[] args) {\n        new NextException().show();\n    }\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n una excepci\u00f3n <code>NoSuchElementException</code></li> </ol> <p>Tal y como vemos en el ejemplo anterior, hay que comprobar si hay siguiente con un <code>hashNext()</code> para que el <code>next()</code> no lance la excepci\u00f3n.</p> <p>No se puede modificar la colecci\u00f3n dentro del bucle for-each porque se lanza en ejecuci\u00f3n la excepci\u00f3n <code>ConcurrentModificationException</code>, ya que estamos recorriendo y modificando la lista a la vez:</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\n\npublic class ModifyInsideForEach {\n    public void show() {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(\"Juan\");\n        list.add(\"Antonio\");\n        list.add(\"Jaime\");\n        list.add(\"Vicente\");\n\n        for (String s : list) {//(1)!\n            System.out.printf(\" %s \", s);\n            if (s.equals(\"Antonio\")) {\n                list.remove(\"Antonio\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new ModifyInsideForEach().show();\n    }\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n la excepci\u00f3n <code>ConcurrentModificationException</code></li> </ol> <p>Para solucionarlo, podemos utilizar el m\u00e9todo <code>remove()</code>de <code>Iterator&lt;E&gt;</code>. Si se modifica una colecci\u00f3n mientras se recorre, los iteradores quedan invalidados, a excepci\u00f3n del m\u00e9todo <code>remove()</code> de la interfaz <code>Iterator&lt;E&gt;</code>. El m\u00e9todo <code>remove()</code> permite eliminar elementos de la colecci\u00f3n siendo la \u00fanica forma adecuada para eliminar elementos durante la iteraci\u00f3n:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class RemoveIterator {\n    public void show() {\n        String s;\n        Iterator&lt;String&gt; it;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(\"Juan\");\n        list.add(\"Antonio\");\n        list.add(\"Jaime\");\n        list.add(\"Vicente\");\n        it = list.iterator();\n\n        while (it.hasNext()) {\n            s = it.next();\n            if (s.equals(\"Antonio\")) {\n                it.remove();\n            } else {\n                System.out.println(s);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new RemoveIterator().show();\n    }\n}\n</code></pre> <pre><code>Juan\nJaime\nVicente\n</code></pre> <p>Solo puede haber una invocaci\u00f3n a <code>remove()</code> por cada invocaci\u00f3n <code>next()</code>. Si no cumple, se lanza en ejecuci\u00f3n una excepci\u00f3n <code>IllegalStateException</code>. Por ejemplo, imaginemos que tenemos una lista de personas y queremos eliminar a Antonio y a la persona que venga detr\u00e1s. Si cuando encontramos a Antonio, hacemos dos <code>remove()</code> seguidos, entonces salta la excepci\u00f3n:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class RemoveNext1 {\n    public void show() {\n        String s;\n        Iterator&lt;String&gt; it;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(\"Juan\");\n        list.add(\"Antonio\");\n        list.add(\"Jaime\");\n        list.add(\"Vicente\");\n\n        it = list.iterator();\n\n        while (it.hasNext()) {\n            s = it.next();\n            if (s.equals(\"Antonio\")) {\n            it.remove();\n            it.remove();//(1)!\n            } else {\n                System.out.println(s);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new RemoveNext1().show();\n    }\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n la excepci\u00f3n <code>IllegalStateException</code></li> </ol> <p>Tendr\u00edamos que hacer otro <code>next()</code> para el que venga detr\u00e1s de Antonio:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class RemoveNext2 {\n    public void show() {\n        String s;\n        Iterator&lt;String&gt; it;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(\"Juan\");\n        list.add(\"Antonio\");\n        list.add(\"Jaime\");\n        list.add(\"Vicente\");\n\n        it = list.iterator();\n\n        while (it.hasNext()) {\n            s = it.next();\n            if (s.equals(\"Antonio\")) {\n                it.remove();\n                it.next();\n                it.remove();\n            } else {\n                System.out.println(s);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new RemoveNext2().show();\n    }\n}\n</code></pre> <pre><code>Juan\nVicente\n</code></pre> <p>La interfaz <code>ListIterator&lt;E&gt;</code> es una subinterfaz o interfaz hija de <code>Iterator&lt;E&gt;</code>. Es un iterador para listas que permite al programador recorrer la lista hacia delante y hacia atr\u00e1s, modificar la lista durante la iteraci\u00f3n y obtener la posici\u00f3n actual del iterador en la lista.</p> <p>Hereda los m\u00e9todos de <code>Iterador&lt;E&gt;</code> y adem\u00e1s aporta otros m\u00e9todos nuevos:</p> <ul> <li><code>void add(E e)</code>: inserta el elemento en la lista antes del elemento que ser\u00eda devuelto por next(), si lo hubiera, y despu\u00e9s del elemento que ser\u00eda devuelto por previous(), si lo hubiera. Una llamada posterior a next() no se ver\u00eda afectada y una llamada posterior a previous() devolver\u00eda el nuevo elemento.</li> <li><code>boolean hasPrevious()</code>: comprueba si hay un elemento anterior.</li> <li><code>int nextIndex()</code>: devuelve el \u00edndice del elemento que ser\u00eda devuelto por una llamada a next(). El \u00edndice del primer elemento es 0.</li> <li><code>E previous()</code>: devuelve el elemento anterior de la lista y mueve la posici\u00f3n del cursor hacia atr\u00e1s.</li> <li><code>int previousIndex()</code>: devuelve el \u00edndice del elemento que ser\u00eda devuelto por una llamada a previous().</li> <li><code>void set(E e)</code>: sustituye el \u00faltimo elemento devuelto por next() o previous() por elemento e.</li> </ul> <p>En la interfaz <code>List&lt;E&gt;</code>, hay dos m\u00e9todos para crear este iterador:</p> <ul> <li><code>ListIterator&lt;E&gt; listIterator()</code>: se coloca antes del primer elemento para que al hacer el primer next() se devuelva el primer elemento.</li> <li><code>ListIterator&lt;E&gt; listIterator(int index)</code>: se coloca antes del elemento que se encuentra en la posici\u00f3n index para que al hacer un next() se devuelva dicho elemento. Para recorrer la lista al rev\u00e9s, hay que crearlo con el tama\u00f1o de la lista para que el primer previous() devuelva el \u00faltimo.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\npublic class ShowListIterator {\n    public void show() {\n        ListIterator&lt;Integer&gt; it;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        list.add(1);\n        list.add(2);\n        list.add(4);\n        list.add(6);\n\n        //Recorrido de la lista hacia atr\u00e1s:\n        it = list.listIterator(list.size());\n\n        while (it.hasPrevious()) {\n            System.out.printf(\" %d \", it.previous());// 6 4 2 1\n        }\n\n        it = list.listIterator(1);//Se coloca antes del elemento que se encuentra en la posici\u00f3n 1\n\n        System.out.printf(\"\\n %d \", it.next());//2\n        System.out.printf(\"\\n %d \", it.nextIndex());//2\n        System.out.printf(\"\\n %d \", it.previousIndex());//1\n\n        it.add(3);\n        System.out.printf(\"\\n %d \", it.next());//4 Una llamada posterior a next() no se ve afectada\n\n        it.add(5);\n        System.out.printf(\"\\n %d \", it.previous());//5 Una llamada posterior a previous() devuelve el nuevo elemento\n\n        System.out.printf(\"\\n %d \\n\", it.next());//5\n        it.set(7);//sustituye el \u00faltimo elemento devuelto por next() por 7\n\n        for (Integer i : list) {\n            System.out.printf(\" %d \", i);//1 2 3 4 7 6\n        }\n    }\n\n    public static void main(String[] args) {\n        new ShowListIterator().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/","title":"3 Conjuntos","text":""},{"location":"bloque_iii/tema_11/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Un conjunto es una lista formada por elementos que no se repiten. Para ello, la JVM usar\u00e1 los m\u00e9todos <code>equals</code> y <code>hashCode</code> heredados la clase clase Object para comprobar si dos elementos son iguales.</p> <p>Son m\u00e9todos heredados de la clase <code>Object</code>. Normalmente, hay que sobrescribirlos para adaptarlo de forma adecuada a la clase correspondiente.</p> <p>Sin embargo, debemos tener en cuenta que al sobrescribir todos estos m\u00e9todos debemos seguir cumpliendo con el comportamiento que se espera de ellos, ya que son usados internamente por muchas clases del propio lenguaje. De lo contario, las clases que dependen de ello, como <code>HashMap</code>y <code>HashSet</code> dejar\u00edan de funcionar correctamente.</p> <p>Escribir a mano los m\u00e9todos <code>equals()</code> y <code>hashCode()</code> es bastante tedioso. Para facilitarnos esta tarea tenemos librer\u00edas como la librer\u00eda AutoValue de Google que lo genera autom\u00e1ticamente para nosotros con tan s\u00f3lo usar una determinada anotaci\u00f3n. Otra opci\u00f3n es dejar que el IDE nos genere dichos m\u00e9todos, aunque esto tiene el inconveniente de que no se generan autom\u00e1ticamente de nuevo conforme a\u00f1adimos atributos a nuestro clase, por lo que debemos tener cuidado, algo que s\u00ed hace AutoValue. En todo caso, es mejor usar el IDE que hacerlo nosotros a mano, ya que el humano es m\u00e1s propenso a los errores. En el Eclipse se encuentra en <code>Men\u00fa Source \u2192 Generate hashCode() and equals()</code>.</p>"},{"location":"bloque_iii/tema_11/page-3/#metodo-equals","title":"M\u00e9todo <code>equals</code>","text":"<p>El m\u00e9todo <code>equals()</code> comprueba si dos objetos son iguales.</p> <p>En caso de que no se sobrescriba dicho m\u00e9todo, s\u00f3lo ser\u00e1 igual a s\u00ed misma, es decir, si est\u00e1 situada en la misma posici\u00f3n de memoria.</p> <p>Debemos tener en cuenta que cuando un programador usa el m\u00e9todo <code>equals()</code> sobre un objeto pas\u00e1ndole como argumento otro objeto lo que pretende es descubrir si ambos objetos son equivalentes l\u00f3gicamente(representa el mismo \"valor\"), no si est\u00e1n almacenados en la misma posici\u00f3n de memoria (tienen la misma identidad).</p> <p>No sobrescribir el m\u00e9todo <code>equals()</code> en una determinada clase es la opci\u00f3n recomendada en los siguientes casos:</p> <ul> <li>Cuando cada instancia de la clase es intr\u00ednsecamente \u00fanica, lo cual es cierto para clases como <code>Scanner</code> que representan entidades activas en lugar de valores.</li> <li>Cuando se considera que no hay necesidad de que la clase provea una prueba de equivalencia l\u00f3gica.</li> <li>Cuando una superclase de la clase ya lo ha sobrescrito y el comportamiento de la superclase es apropiado para las subclase.</li> <li>Cuando la clase es privada o friendly, y estamos completamente seguros de que su m\u00e9todo <code>equals()</code> nunca ser\u00e1 invocado, ni expl\u00edcita ni impl\u00edcitamente.</li> </ul> <p>Si nuestra clase no se encuentra en ninguno de los casos anteriores es muy recomendable que sobrescribamos el m\u00e9todo <code>equals()</code>. Un ejemplo muy caracter\u00edstico es cuando la clase corresponda a una entidad que represente un valor.</p> <p>Como hemos comentado, cuando sobrescribamos el m\u00e9todo <code>equals()</code> debemos seguir cumpliendo el comportamiento que el sistema espera de \u00e9l, que incluye las siguientes propiedades:</p> <ul> <li>Reflexiva: Para todo objeto x distinto de null se debe cumplir que <code>x.equals(x)</code> sea true.</li> <li>Sim\u00e9trica: Para todo par de objetos x e y y distintos de null se debe cumplir que <code>x.equals(y)</code> s\u00f3lo debe retornar true si <code>y.equals(x)</code> retorna true.</li> <li>Transitiva: Para todo tr\u00edo de objetos x, y, z distintos de null se debe cumplir que si <code>x.equals(y)</code> retorne true y <code>y.equals(z)</code> retorna true entonces <code>x.equals(z)</code> debe retornar true.</li> <li>Consistente: Para todo par de objetos x e y distintos de null se debe cumplir que <code>x.equals(y)</code>siempre retorne el mismo valor si no hemos cambiado los atributos que se usan para comparar en alguno de los objetos.</li> <li>Para todo objeto x distinto de null se debe cumplir que <code>x.equals(null)</code>debe retornar false.</li> </ul> <p>As\u00ed para sobrescribir el m\u00e9todo <code>equals()</code> cumpliendo con las propiedades anteriores se recomienda seguir los siguientes pasos:</p> <ol> <li>Usar el operador <code>==</code> para comprobar si el argumento corresponde a otra referencia al mismo objeto, en cuyo caso retornar true.</li> <li>Usar el operador <code>instanceof</code> para comprobar si el objeto recibido como argumento no es de la misma clase, en cuyo caso retornar false. Tambi\u00e9n nos sirve para comprobar si dichos argumento es null, ya que en este caso instanceof retornar\u00eda false.</li> <li>Hacer cast del objeto recibido como argumento convirti\u00e9ndolo a la clase correspondiente. Dado que hemos hecho antes instanceof, el cast siempre tendr\u00e1 \u00e9xito.</li> <li>Para cada atributo significativo de la clase, comprobar que dicho atributo en el objeto argumento es equivalente al atributo en el objeto this. Si no tenemos \u00e9xito en alguno de ellos, retornar false. Si todas las comprobaciones se han hecho con \u00e9xito, retornar true. Para realizar las comprobaciones de cada atributo usar:<ul> <li>El operador <code>==</code> para valores primitivos que no sean float ni double.</li> <li>Para los valores float usar <code>Float.compare(value1, value2)</code> y para valores double usar <code>Double.compare(value1, value2)</code>.</li> <li>Para valores correspondientes a objetos llamar a <code>equals()</code> recursivamente. Si es v\u00e1lido que dichos objetos contengan null, entonces debemos usar <code>Objects.equals(object1, object2)</code> para que no se produzca la excepci\u00f3n <code>NullPointerException</code>.</li> <li>Para los valores correspondientes a arrays, compara uno a uno los elementos significativos del array. Si todos los elementos son significativos, usa alguno de las versiones del m\u00e9todo est\u00e1tico <code>Arrays.equals()</code>.</li> </ul> </li> </ol> <p>Veamos un ejemplo:</p> <pre><code>public final class PhoneNumber{\n    private final short areaCode, prefix, lineNum;\n\n    @Override\n    public boolean equals(Object o){\n        if(o == this) return true;\n        if(!(o instanceof PhoneNumber)) return false;\n        PhoneNumber pn = (PhoneNumber) o;\n        return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n    }\n//...\n}\n</code></pre> <p>\u00a1CUIDADO!</p> <p>Un aspecto muy importante es que no debemos cambiar el tipo del objeto recibido como argumento, que siempre debe ser <code>Object</code>, o no estaremos sobrescribiendo el m\u00e9todo <code>equals()</code>, sino sobrecarg\u00e1ndolo, lo que puede producir falsos positivos. El compilador no se quejar\u00e1 si no usamos la anotaci\u00f3n <code>@Override</code> (por eso siempre se recomienda usarla). Por ejemplo, nunca hagas esto:</p> <pre><code>public boolean equals(MyClass o){\n    //...\n}\n</code></pre> <p>Nota</p> <p>Algunas veces, para comparar que una variable de tipo String es equivalente a una determinada constante de cadena se usa la construcci\u00f3n \"Hello\".equals(message) , ya que dicho construcci\u00f3n no puede lanzar NullPointerException si message es null, sino que tan s\u00f3lo retornar\u00e1 false, mientras que message.equals(\"Hello\") lanzar\u00eda NullPointerException en ese caso.</p>"},{"location":"bloque_iii/tema_11/page-3/#metodo-hashcode","title":"M\u00e9todo <code>hashCode</code>","text":"<p>El m\u00e9todo <code>hashCode()</code> devuelve un n\u00famero entero que identifica al objeto cuando se guarda en algunas estructuras de datos.</p> <p>Un detalla muy importante que no debemos olvidar es que **si en una clase sobrescribimos el m\u00e9todo <code>equals()</code> debemos obligatoriamente sobrescribir tambi\u00e9n el m\u00e9todo <code>hashCode()</code> o de lo contrario no se estar\u00e1 cumpliendo con el comportamiento esperado de este \u00faltimo, lo que impedir\u00e1 que los objetos de dichas clase funcionen correctamente en colecciones como <code>HashMap</code> y <code>HashSet</code>.</p> <p>El comportamiento que se espera de <code>hashCode()</code> es el siguiente:</p> <ul> <li>Debe ser consistente, es decir, que repetidas llamadas al m\u00e9todo <code>hashCode()</code> deben retornar el mismo valor, siempre y cuando no se haya modificado ninguno de los atributos usados para las comparaciones.</li> <li>Si dos objetos son equivalentes, es decir, si <code>x.equals(y)</code> retorna true, entonces <code>x.hashCode()</code> e <code>y.hashCode()</code> deben retornar el mismo valor entero. \u00c9ste ees el motivo por el que siempre que sobrescribamos <code>equals()</code> debemos sobrescribir <code>hashCode()</code>, ya que la implementaci\u00f3n por defecto de <code>hashCode()</code> de la clase <code>Object</code> devuelve una representaci\u00f3n num\u00e9rica de la direcci\u00f3n de memoria en la que se encuentra ubicado el objeto.</li> <li>Si dos objetos no son equivalentes, es decir si <code>x.equals(y)</code> retorna false, no es estrictamente necesario, aunque si recomendable, que <code>x.hashCode()</code> e <code>y.hashCode()</code> retornen valores diferentes, de manera que se mejore el rendimiento de las tablas hash. Idealmente el algoritmo de la funci\u00f3n hash debe distribuir una colecci\u00f3n de instancias de un tama\u00f1o considerable de forma uniforme entre todos los valores enteros.</li> </ul> <p>La implementaci\u00f3n caracter\u00edstica al sobrescribir el m\u00e9todo <code>hashCode()</code> en la clase <code>PhoneNumber</code> es la siguiente, usando los atributos areaCode, prefix, lineNum.</p> <pre><code>public final class PhoneNumber{\n    private final short areaCode, prefix, lineNum;\n\n    @Override\n    public boolean equals(Object o){\n        if(o == this) return true;\n        if(!(o instanceof PhoneNumber)) return false;\n        PhoneNumber pn = (PhoneNumber) o;\n        return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n    }\n\n    @Override\n    public int hashCode(){\n        int result = Short.hashCode(areaCode);\n\n        result = 31 * result + Short.hashCode(prefix);\n        result = 31 * result + Short.hashCode(lineNum);\n        return result;\n    }\n//...\n}\n</code></pre> <p>Adem\u00e1s de escribir nosotros a mano el c\u00f3digo del m\u00e9todo <code>hashCode()</code>, podemos usar la implementaci\u00f3n proporcionada por algunas librer\u00edas, como Guava o AutoValue, o usar la implementaci\u00f3n de los IDEs.</p> <p>Por otra parte, podemos usar <code>Objects.hashCode(object...)</code> para sobrescribir el m\u00e9todo con una sola l\u00ednea. Desafortunadamente, este m\u00e9todo es bastante menos eficiente de lo esperado, debido a que recibe un array de atributos y de que realiza boxing y unboxing de los atributos que sean de un tipo primitivo. Por ejemplo:</p> <pre><code>public final class PhoneNumber{\n    private final short areaCode, prefix, lineNum;\n\n    @Override\n    public boolean equals(Object o){\n        if(o == this) return true;\n        if(!(o instanceof PhoneNumber)) return false;\n        PhoneNumber pn = (PhoneNumber) o;\n        return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n    }\n\n    @Override\n    public int hashCode(){\n        return Objects.hash(lineNum, prefix, areaCode);\n    }\n//...\n}\n</code></pre> <p>Si una clase es inmutable y el coste de calcular el valor hash es significativo, podr\u00eda considerar almacenar cacheado el c\u00f3digo hash en el propio objecto, en lugar de recalcularlo cada vez que se solicite. Si cree que la mayor\u00eda de los objetos de esta clase se usar\u00e1n como claves hash, entonces deber\u00eda calcular el c\u00f3digo hash cuando se cree la instancia. De lo contario, podr\u00eda elegir calcular perezosamente el c\u00f3digo hash la primera vez que se invoque el m\u00e9todo <code>hash()</code>.</p> <p>Dos consideraciones finales:en primer lugar no excluya atributos significativos del c\u00e1lculo de valor hash, as\u00ed lograr\u00e1 un mejor rendimiento, al no repetir tanto los valores. En segundo lugar, no proporcione a los clientes de la clase demasiada informaci\u00f3n acerca de c\u00f3mo se calcula el valor hash de esta manera el c\u00f3digo no podr\u00e1 depender de c\u00f3mo se calcula, permiti\u00e9ndonos modificar la implementaci\u00f3n del m\u00e9todo en el futuro sin afectar a los clientes.</p>"},{"location":"bloque_iii/tema_11/page-3/#colecciones-sin-duplicados","title":"Colecciones sin duplicados","text":"<p>La interfaz <code>Set</code>, que hereda de Collection, permite implementar listas de elementos sin duplicados, es decir, modela la abstracci\u00f3n matem\u00e1tica de los conjuntos.</p> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java:</p> <ul> <li>HashSet: esta implementaci\u00f3n almacena los elementos de una tabla hash. Es la implementaci\u00f3n con mejor rendimiento de todas pero no garantiza ning\u00fan orden a la hora de realizar iteraciones.</li> <li>LinkedHashSet: est\u00e1 implementaci\u00f3n almacena los elementos en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que HashSet.</li> <li>TreeSet: est\u00e1 implementaci\u00f3n utiliza una estructura de \u00e1rbol para ordenar los elementos. Es bastante m\u00e1s lenta que HashSet.</li> </ul>"},{"location":"bloque_iii/tema_11/page-3/#clase-hashset","title":"Clase HashSet","text":"<p>Implementa la interfaz <code>Set</code>. Es la clase m\u00e1s utilizada para implementar listas sin duplicados. Esta clase permite el elemento nulo. No garantiza ning\u00fan orden a la hora de realizar iteraciones.</p> <p>Utiliza internamente una tabla de tipos hash:</p> <p> Figura 1 - Hashtable</p> <p>Al querer guardar un objeto en esta estructura, se llama al m\u00e9todo hashCode() el cual devuelve un n\u00famero entero que la estructura usar\u00e1 para decidir en qu\u00e9 caj\u00f3n debe recuperar el objeto. El objetivo de guardar los datos de esta forma y de llamar al m\u00e9todo es lograr almacenar y recuperar la informaci\u00f3n en tiempo constante (lo cual no ocurre siempre, pero se acerca). El que no suceda esto depende, casi siempre, del valor que devuelva el m\u00e9todo <code>hashCode()</code> para cada objeto.</p> <p>Supongamos que guardamos 3 objetos en esta estructura y el m\u00e9todo <code>hashCode()</code> de los 3 devuelve 0, esto quiere decir que los 3 objetos se guardar\u00e1n en el caj\u00f3n 0. Cuando se necesite recuperar un objeto, hay que recorrer los objetos del caj\u00f3n 0 para determinar cu\u00e1l es el que se quiere recuperar. Por lo tanto, este m\u00e9todo <code>hashCode()</code> no es \u00fatil ya que lo que se pretende al guardar los elementos es que \u00e9stos queden dispersos de forma uniforme en toda la estructura quedando la menor cantidad de cajones vac\u00edos y que no haya cajones donde se guarden muchos m\u00e1s elementos que en otros.</p> <p>Si dos objetos tiene el mismo <code>hashCode()</code>, ambos objetos se guardar\u00e1n en el mismo caj\u00f3n. La estructura usa entonces el m\u00e9todo <code>equals()</code> dentro de ese caj\u00f3n para determinar cu\u00e1l corresponde con el solicitado y para eso depende de que el programador haya sobrescrito el m\u00e9todo, de lo contrario no garantiza un resultado correcto.</p> <p> Figura 2 - Hash</p> <p>Los objetos HashSet se construyen con un tama\u00f1o inicial de tabla (el tama\u00f1o del array) y un factor de carga que indica cu\u00e1ndo se debe redimensionar el array. Es decir, si se cre\u00f3 un array de 100 elementos y la carga se estableci\u00f3 al 80%, cuando se hayan rellanado 80 valores, se redimensiona el array. Por defecto, el tama\u00f1o del array se toma con 16 y el factor de carga con 0,75 (75%). No obstante, se puede construir una lista HashSet indicando ambos par\u00e1metros.</p> <p>Esta implementaci\u00f3n proporciona tiempos constantes en las operaciones b\u00e1sicas siempre y cuando la funci\u00f3n hash disperse de forma correcta los elementos dentro de la tabla hash. Es importante definir el tama\u00f1o inicial de la tabla ya que este tama\u00f1o marcar\u00e1 el rendimiento de esta implementaci\u00f3n.</p> <p>Veamos un ejemplo de <code>HashSet</code> con la clase <code>Vehicle</code>. Los atributos significativos a tener en cuenta para el <code>equals()</code> y el <code>hashCode()</code> son wheelCount y colour. La velocidad (speed) no se incluye ya que si comparamos el mismo coche pero con velocidades distintas, en realidad, no deja de ser el mismo coche.</p> VehicleMainConsola <pre><code>public class Vehicle {\n    private int wheelCount;\n    private double speed;\n    private String colour;\n\n    public Vehicle(int wheelCount, String colour) {\n        this.wheelCount = wheelCount;\n        this.colour = colour;\n        speed = 0;\n    }\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public String getColour() {\n        return colour;\n    }\n\n    public void setColour(String colour) {\n        this.colour = colour;\n    }\n\n    public void accelerate(double amount) {\n        speed += amount;\n    }\n\n    public void brake(double amount) {\n        speed -= amount;\n    }\n\n    @Override\n    public String toString() {\n        return \"Vehicle [wheelCount=\" + wheelCount + \", speed=\" + speed + \",colour=\" + colour + \"]\";\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((colour == null) ? 0 : colour.hashCode());\n        result = prime * result + wheelCount;\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (!(obj instanceof Vehicle other))\n            return false;\n\n        if (colour == null) {\n            if (other.colour != null)\n                return false;\n        } else if (!colour.equals(other.colour))\n            return false;\n\n        return wheelCount == other.wheelCount;\n    }\n}\n</code></pre> <pre><code>import java.util.HashSet;\nimport java.util.Set;\npublic class ShowHashSet {\n    public void show() {\n        Set&lt;Vehicle&gt; set = new HashSet&lt;&gt;();\n\n        set.add(new Vehicle(4, \"azul\"));\n        set.add(new Vehicle(2, \"rojo\"));\n        set.add(new Vehicle(4, \"azul\"));\n        set.add(new Vehicle(2, \"rojo\"));\n        set.add(new Vehicle(4, \"verde\"));\n\n        for (Vehicle v : set) {\n            System.out.println(v);//Se llama al toString del objeto\n        }\n    }\n\n    public static void main(String[] args) {\n        new ShowHashSet().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [wheelCount=4, speed=0.0, colour=verde]\nVehicle [wheelCount=4, speed=0.0, colour=azul]\nVehicle [wheelCount=2, speed=0.0, colour=rojo]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/#clase-linkedhashset","title":"Clase LinkedHashSet","text":"<p>Almacena los elementos en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que HashSet.</p> MainConsola <pre><code>import java.util.LinkedHashSet;\nimport java.util.Set;\n\npublic class ShowLinkedHashSet {\n    public void show() {\n        Set&lt;Vehicle&gt; set = new LinkedHashSet&lt;&gt;();\n\n        set.add(new Vehicle(4, \"azul\"));\n        set.add(new Vehicle(2, \"rojo\"));\n        set.add(new Vehicle(4, \"azul\"));\n        set.add(new Vehicle(2, \"rojo\"));\n        set.add(new Vehicle(4, \"verde\"));\n\n        for (Vehicle v : set) {\n            System.out.println(v);//Se llama al toString del objeto\n        }\n    }\n\n    public static void main(String[] args) {\n        new ShowLinkedHashSet().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [wheelCount=4, speed=0.0, colour=azul]\nVehicle [wheelCount=2, speed=0.0, colour=rojo]\nVehicle [wheelCount=4, speed=0.0, colour=verde]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/#clase-enumset","title":"Clase EnumSet","text":"<p>Es una implementaci\u00f3n de conjuntos de alto rendimiento de tipos enumerados. Require que las constantes de enumeraci\u00f3n colocadas en \u00e9l pertenezcan al mismo tipo de enumeraci\u00f3n. Veamos algunos de sus m\u00e9todos:</p> <ul> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; allOf(Class&lt;E&gt; elementType)</code>: crea un conjunto de enumeraciones que contiene todos los valores del tipo de enumeraci\u00f3n especificado.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(EnumSet&lt;E&gt; s)</code>: crea un conjunto de numeraciones con el mismo tipo que el conjunto de enumeraciones especificado, conteniendo inicialmente todos los elementos de este tipo que no est\u00e1n contenidos en el conjunto especificado.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; copyOf(EnumSet&lt;E&gt; s)</code>: crea un conjunto de enumeraciones a partir de otro.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType)</code>: crea un conjunto de enumeraciones vac\u00edo con el tipo de elemento especificado.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E e)</code>: crea un conjunto de enumeraciones que contiene el elemento especificado. Este m\u00e9todo tiene varias sobrecargas para admitir m\u00e1s elementos.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; range(E from, E to)</code>: crea un conjunto de enumeraciones que contiene inicialmente todos los elementos del rango definido por los dos elementos especificados.</li> </ul> ENUMShowEnumSet <pre><code>public enum Operation {\n    PLUS(\"+\"), MINUS(\"-\"), TIMES(\"*\"), DIVIDE(\"/\");\n\n    private final String symbol;\n\n    private Operation(String symbol) {\n        this.symbol = symbol;\n    }\n\n    public String getSymbol() {\n        return symbol;\n    }\n}\n</code></pre> <pre><code>public class ShowEnumSet {\n    public void show() {\n        EnumSet&lt;Operation&gt; allOperations1, allOperations2, operations1, operations2, operations3, operations4;\n\n        allOperations1 = EnumSet.allOf(Operation.class);\n        System.out.printf(\"allOf: %s\", allOperations1);//allOf: [PLUS, MINUS,TIMES, DIVIDE]\n\n        allOperations2 = EnumSet.copyOf(allOperations1);\n        System.out.printf(\"\\ncopyOf: %s\", allOperations2);//copyOf: [PLUS,MINUS, TIMES, DIVIDE]\n\n        operations1 = EnumSet.noneOf(Operation.class);\n        operations1.add(Operation.PLUS);\n        operations1.add(Operation.MINUS);\n        System.out.printf(\"\\nnoneOf y add: %s\", operations1);//noneOf y add: [PLUS, MINUS]\n\n        operations2 = EnumSet.complementOf(operations1);\n        System.out.printf(\"\\ncomplementOf: %s\", operations2);//complementOf:[TIMES, DIVIDE]\n\n        operations3 = EnumSet.of(Operation.DIVIDE, Operation.MINUS);\n        System.out.printf(\"\\nof: %s\", operations3);//of: [MINUS, DIVIDE]\n\n        operations4 = EnumSet.range(Operation.MINUS, Operation.DIVIDE);\n        System.out.printf(\"\\nrange: %s\\n\", operations4);//range: [MINUS,TIMES, DIVIDE]\n\n        System.out.println(operations4.contains(Operation.PLUS));//false\n        System.out.println(operations4.contains(Operation.MINUS));//true\n    }\n\n    public static void main(String[] args) {\n        new ShowEnumSet().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-4/","title":"4 Mapas","text":""},{"location":"bloque_iii/tema_11/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Las colecciones de tipo Set tienen el inconveniente de tener que almacenar una copia exacta del elemento a buscar. Sin embargo, en la pr\u00e1ctica es habitual que haya datos que se consideren clave, es decir, que identifican a cada objeto (el dni de las personas por ejemplo) de tal manera que buscan los datos en base a esa clave y por otro lado se almacenan el resto de los datos. Los mapas permiten definir colecciones de elementos que poseen pares de datos clave-valor. Esto se utiliza para localizar valores en funci\u00f3n de la clave que poseen. Son muy interesantes y r\u00e1pidos. Los mapas tambi\u00e9n son conocidos como diccionarios.</p> <p>La interfaz <code>Map&lt;K,V&gt;</code> es la ra\u00edz de todas las clases que implementan mapas. Hasta la versi\u00f3n 5, los mapas eran colecciones de pares clave-valor donde tanto la clave como el valor eran de tipo Object. Desde la versi\u00f3n versi\u00f3n 5, esta interfaz tiene dos gen\u00e9ricos: <code>K</code> para el tipo de datos de la clave y <code>V</code> para el tipo de los valores. Esta estructura de datos nos permite obtener el objeto <code>V</code> muy r\u00e1pidamente a partir de su clave <code>K</code>.</p> <p>Esta interfaz no hereda de Collection por lo que no tiene los m\u00e9todos vistos anteriormente. La raz\u00f3n es que la obtenci\u00f3n, b\u00fasqueda y borrado de elementos se hace de una manera muy distinta.</p> <p>Las claves no se pueden repetir por lo que se implementan con una tabla hash para que no haya duplicados. Por lo tanto, la clase que se utilice como clave tiene que sobrescribir sus m\u00e9todos <code>equals()</code> y <code>hashCode()</code>.</p> <p>Veamos algunos m\u00e9todos de esta interfaz:</p> <ul> <li><code>boolean containsKey(Object key)</code>: devuelve true si el mapa contiene dicha clave.</li> <li><code>boolean containsValue(Object value)</code>: devuelve true si el mapa contiene dicho valor.</li> <li><code>V get(Object key)</code>: devuelve el valor asociado a la clave o null si no existe esa clave en el mapa.</li> <li><code>V getOrDefault(Object V, defaultValue)</code>: devuelve el valor asociado a la clave o defaultValue si no existe esa clave en el mapa.</li> <li><code>V put(K key, V value)</code>: a\u00f1ade un par clave-valor al mapa. Si ya hab\u00eda un valor para esa clave, se reemplaza. Devuelve el valor que ten\u00eda antes dicha clave o null si la clave no estaba en el mapa.</li> <li><code>V putIfAbsent(K key, V value)</code>: si la clave especificada no est\u00e1 ya asociada a un valor o est\u00e1 asignada a null, se le asocia el valor dado y devuelve null, en caso contrario, devuelve el valor previamente asociado con la clave.</li> <li><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code>: a\u00f1ade los pares claves-valor del mapa m.</li> <li><code>V remove(Object key)</code>: elimina la clave y su valor asociado, el cual se devuelve. Si no existe dicha clave, devuelve null.</li> </ul> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java:</p> <ul> <li><code>HashMap</code>: esta implementaci\u00f3n almacena las claves en una tabla hash. Es la implementaci\u00f3n con mejor rendimiento de todas pero no garantiza ning\u00fan orden a la hora de realizar iteraciones.</li> <li><code>LinkedHashMap</code>: esta implementaci\u00f3n almacena las claves en funci\u00f3n del orden de la inserci\u00f3n. Es un poco m\u00e1s costosa que <code>HashMap</code>.</li> <li><code>TreeMap</code>: esta implementaci\u00f3n utiliza la estructura del \u00e1rbol para ordenar las claves. Es bastante m\u00e1s lenta que <code>HashMap</code>. La veremos m\u00e1s adelante en el apartado de los \u00e1rboles.</li> </ul>"},{"location":"bloque_iii/tema_11/page-4/#clase-hashmap","title":"Clase HashMap","text":"<p>Esta implementaci\u00f3n proporciona tiempos constantes en las operaciones b\u00e1sicas siempre y cuando la funci\u00f3n hash disperse de forma correcta las claves dentro de la tabla hash. Es importante definir el tama\u00f1o inicial de la tabla ya que este tama\u00f1o marcar\u00e1 el rendimiento de esta implementaci\u00f3n. No garantiza ning\u00fan orden a la hora de recorrer el mapa.</p> <p>Veamos un ejemplo de un mapa de veh\u00edculos donde la clave es la matr\u00edcula. A\u00f1adimos la matr\u00edcula como atributo por lo que hay generar de nuevo los m\u00e9todos <code>toString()</code>, <code>hashCode()</code>y <code>equals()</code>:</p> VehicleShowHashMapConsola <pre><code>public class Vehicle{\n    private final String registration; // Atributo para almacenar la matr\u00edcula del coche\n    private final int wheelCount;\n    private double speed;\n    private String colour;\n\n    public Vehicle(String registration, int wheelCount, String colour){\n        this.registration = registration;\n        this.wheelCount = wheelCount;\n        this.colour = colour;\n        speed = 0;\n    }\n\n    public int getWheelCount(){\n        return wheelCount;\n    }\n\n    public double getSpeed(){\n        return speed;\n    }\n\n    public String getColour(){\n        return colour;\n    }\n\n    public void setColour(String colour){\n        this.colour = colour;\n    }\n\n    public String getRegistration(){\n        return registration;\n    }\n\n    public void accelerate(double amount){\n        speed += amount;\n    }\n\n    public void brake(double amount){\n        speed -= amount;\n    }\n\n    @Override\n    public String toString(){\n        return \"Vehicle [registration=\" + registration + \", wheelCount=\" + wheelCount + \", speed=\" + speed + \", colour=\" + colour + \"]\";\n    }\n\n    @Override\n    public int hashCode(){\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((colour == null) ? 0 : colour.hashCode());\n        result = prime * result + ((registration == null) ? 0 : registration.hashCode());\n        result = prime * result + wheelCount;\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj){\n        if(this == obj) return true;\n        if(obj == null) return false;\n\n        if(!(obj instanceof Vehicle other)) return false;\n\n        if(colour == null){\n            if(other.colour != null){\n                return false;\n            }\n        } else if(!colour.equals(other.colour)){\n            return false;\n        }\n\n        if(registration == null){\n            if(other.registration != null){\n                return false;\n            }\n        } else if(!registration.equals(other.registration)){\n            return false;\n        }\n\n        return wheelCount == other.wheelCount;\n    }\n}\n</code></pre> <pre><code>public class ShowHashMap {\n    public void show() {\n        Map&lt;String, Vehicle&gt; map = new HashMap&lt;&gt;();\n        Map&lt;String, Vehicle&gt; map2 = new HashMap&lt;&gt;();\n        Vehicle vehicles[] = new Vehicle[6];\n\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n\n        for (int i = 0; i &lt; vehicles.length; i++) {\n            map.put(vehicles[i].getRegistration(), vehicles[i]);\n        }\n\n        System.out.println(map.containsKey(\"1005SAW\"));//false\n        System.out.println(map.containsKey(\"1705UBG\"));//true\n\n        System.out.println(map.containsValue(new Vehicle(\"5930POI\", 4,\"negro\")));//false\n        System.out.println(map.containsValue(new Vehicle(\"5930POI\", 2,\"negro\")));//true\n\n        System.out.println(map.get(\"4554ASD\"));//null\n        System.out.println(map.get(\"1705UBG\"));//Vehicle[registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\n\n        System.out.println(map.getOrDefault(\"8080SAS\", new Vehicle(\"4554ASD\", 4, \"negro\")));//Vehicle [registration=4554ASD, wheelCount=4, speed=0.0,colour=negro]\n        System.out.println(map.getOrDefault(\"1705UBG\", new Vehicle(\"4554ASD\", 4, \"negro\")));//Vehicle [registration=1705UBG, wheelCount=4, speed=0.0,colour=blanco]\n\n        System.out.println(map.put(\"6320LPL\", new Vehicle(\"6320LPL\", 2,\n        \"verde\")));//null\n        System.out.println(map.put(\"6320LPL\", new Vehicle(\"6320LPL\", 4,\n        \"beis\")));//Vehicle [registration=6320LPL, wheelCount=2, speed=0.0,colour=verde]\n\n        System.out.println(map.putIfAbsent(\"4687RTB\", new Vehicle(\"4687RTB\", 2, \"blanco\")));//null\n        System.out.println(map.putIfAbsent(\"4687RTB\", new Vehicle(\"4687RTB\", 4, \"naranja\")));//Vehicle [registration=4687RTB, wheelCount=2, speed=0.0,colour=blanco]\n\n        System.out.println(map.remove(\"1234ABC\"));//null\n        System.out.println(map.remove(\"4687RTB\"));//Vehicle[registration=4687RTB, wheelCount=2, speed=0.0, colour=blanco]\n\n        System.out.printf(\"El mapa tiene %d veh\u00edculos\", map.size());\n\n        map2.put(\"7410HJH\", new Vehicle(\"7410HJH\", 4, \"rojo\"));\n        map2.put(\"8520FGF\", new Vehicle(\"8520FGF\", 2, \"verde\"));\n        map.putAll(map2);//a\u00f1ade a map los pares clave-valor del mapa map2\n        System.out.printf(\"\\nDespu\u00e9s de a\u00f1adirle map2, el mapa tiene %d veh\u00edculos\", map.size());\n    }\n\n    public static void main(String[] args) {\n        new ShowHashMap().show();\n    }\n}\n</code></pre> <pre><code>false\ntrue\nfalse\ntrue\nnull\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0 colour=blanco]\nVehicle [registration=4554ASD, wheelCount=4, speed=0.0, colour=negro]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nnull\nVehicle [registration=6320LPL, wheelCount=2, speed=0.0, colour=verde]\nnull\nVehicle [registration=4687RTB, wheelCount=2, speed=0.0, colour=blanco]\nnull\nVehicle [registration=4687RTB, wheelCount=2, speed=0.0, colour=blanco]\nEl mapa tiene 7 veh\u00edculos\nDespu\u00e9s de a\u00f1adirle map2, el mapa tiene 9 veh\u00edculos\n</code></pre> <p>Veamos las distintas maneras de recorrer un mapa:</p> <ul> <li><code>Set&lt;K&gt; keySet()</code>: devuelve un conjunto con todas las claves. como entre las claves no puede haber elementos duplicados, las claves forman un conjunto (Set).</li> <li><code>Collection&lt;V&gt; values()</code>: devuelve una colecci\u00f3n con todos los valores. Los valores s\u00ed pueden estar duplicados, por lo tanto, este m\u00e9todo devuelve un Collection.</li> <li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet</code>: devuelve un conjunto de objetos Map.Entry. Los pares de elementos (tambi\u00e9n llamados entradas) de los que est\u00e1 compuesto un Map son de un tipo que viene implementado por la interfaz Map.Entry. La interfaz Map.Entry se define de forma interna a la interfaz Map y representa un objeto de par clave-valor, es decir, mediante esta interfaz podemos trabajar con una entrada del mapa. Veamos algunos m\u00e9todos de la interfaz Map.Entry. <li><code>K getKey()</code>: retorna la clave.</li> <li><code>V getValue()</code>: retorna el valor.</li> <li><code>V setValue(V value)</code>: reemplaza el valor por value y devuelve el valor anterior.</li> TraverseHashMapConsola <pre><code>public class TraverseHashMap {\n    public void show() {\n        Map&lt;String, Vehicle&gt; map = new HashMap&lt;&gt;();\n        Vehicle vehicles[] = new Vehicle[6];\n\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n\n        for (int i = 0; i &lt; vehicles.length; i++) {\n           map.put(vehicles[i].getRegistration(), vehicles[i]);\n        }\n\n        System.out.println(\"Claves del mapa:\\n\");\n        for (String s : map.keySet()) {//keySet() devuelve un conjunto con todas las claves\n            System.out.println(s);\n        }\n\n        System.out.println(\"\\nValores del mapa:\\n\");\n        for (Vehicle v : map.values()) {//values() devuelve una colecci\u00f3n con todos los veh\u00edculos\n            System.out.println(v);\n        }\n\n        System.out.println(\"\\nPares clave-valor del mapa usando un foreach:\\n\");\n        for (Map.Entry&lt;String, Vehicle&gt; entry : map.entrySet()) {\n            System.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\",entry.getKey(), entry.getValue());\n        }\n\n        System.out.println(\"\\nPares clave-valor del mapa usando iteradores:\\n\");\n        Set&lt;Map.Entry&lt;String, Vehicle&gt;&gt; entrySet = map.entrySet();\n        Iterator&lt;Map.Entry&lt;String, Vehicle&gt;&gt; it = entrySet.iterator();\n        Map.Entry&lt;String, Vehicle&gt; entry;\n        while (it.hasNext()) {\n            entry = it.next();\n            System.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\",\n            entry.getKey(), entry.getValue());\n        }\n    }\n\n    public static void main(String[] args) {\n        new TraverseHashMap().show();\n    }\n}\n</code></pre> <pre><code>Claves del mapa:\n\n3495JZA\n1705UBG\n1235GTR\n7314QWE\n9685KMX\n5930POI\n\nValores del mapa:\n\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\n\nPares clave-valor del mapa usando un foreach:\n\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nMatr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\n\nPares clave-valor del mapa usando iteradores:\n\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nMatr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-4/#clase-linkedhashmap","title":"Clase LinkedHashMap","text":"<p>Almacena las claves en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que <code>HashMap</code>.</p> MainConsola <pre><code>public class ShowLinkedHashMap {\n    public void show() {\n        Map&lt;String, Vehicle&gt; map = new LinkedHashMap&lt;&gt;();\n        Vehicle vehicles[] = new Vehicle[6];\n\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n\n        for (int i = 0; i &lt; vehicles.length; i++) {\n            map.put(vehicles[i].getRegistration(), vehicles[i]);\n        }\n\n        for (Map.Entry&lt;String, Vehicle&gt; entry : map.entrySet()) {\n            System.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\",entry.getKey(), entry.getValue());\n        }\n    }\n\n    public static void main(String[] args) {\n        new ShowLinkedHashMap().show();\n    }\n}\n</code></pre> <pre><code>Matr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nMatr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\n</code></pre> <p>Podemos observar que los datos se muestran en el mismo orden en el que se insertaron.</p>"},{"location":"bloque_iii/tema_11/page-4/#ejemplo-de-uso-de-un-mapa-en-un-enum","title":"Ejemplo de uso de un mapa en un enum","text":"<p>Si hemos sobrescrito el m\u00e9todo <code>toString()</code> o las instancias del enum tienen alguna forma adicional de referirnos a ellas, tiene bastante sentido que creemos un m\u00e9todo est\u00e1tico parecido a <code>valueOf()</code>, pero que reciba dicha forma adicional de referirnos a las instancias.</p> EnumMainConsola <pre><code>public enum Operation {\n    PLUS(\"+\") {\n        @Override\n        public double apply(double x, double y) {\n            return x + y;\n        }\n    },\n    MINUS(\"-\") {\n        @Override\n        public double apply(double x, double y) {\n            return x - y;\n        }\n    },\n    TIMES(\"*\") {\n        @Override\n        public double apply(double x, double y) {\n            return x * y;\n        }\n    },\n    DIVIDE(\"/\") {\n        @Override\n        public double apply(double x, double y) {\n            return x / y;\n        }\n    };\n\n    private final String symbol;\n\n    private static final Map&lt;String, Operation&gt; symbolToOperation = Map.of(Operation.PLUS.getSymbol(), Operation.PLUS, Operation.MINUS.getSymbol(), Operation.MINUS, Operation.TIMES.getSymbol(), Operation.TIMES,Operation.DIVIDE.getSymbol(), Operation.DIVIDE);\n\n    private Operation(String symbol) {\n        this.symbol = symbol;\n    }\n\n    public String getSymbol() {\n        return symbol;\n    }\n\n    public abstract double apply(double x, double y);\n\n    public static Operation fromSymbol(String symbol) {\n        return symbolToOperation.get(symbol);\n    }\n}\n</code></pre> <pre><code>public class ExampleUseMapEnum {\n    public void show() {\n        Operation operation;\n        operation = Operation.fromSymbol(\"+\");//operation se asigna con la instancia correspondiente al s\u00edmbolo +\n        System.out.printf(\"La variable operation es de tipo enum %s y su s\u00edmbolo es %s\", operation, operation.getSymbol());\n    }\n\n    public static void main(String[] args) {\n        new ExampleUseMapEnum().show();\n    }\n}\n</code></pre> <pre><code>La variable operation es de tipo enum PLUS y su s\u00edmbolo es +\n</code></pre> <p>Como vemos en el c\u00f3digo anterior, creamos un mapa est\u00e1tico que relaciona cada s\u00edmbolo con cada instancia, de manera que podamos obtener la instancia adecuada a partir del s\u00edmbolo. Debemos tener en cuenta que no est\u00e1 permitido que los constructores de las instancias de un enum accedan a los atributos est\u00e1ticos del enum, con la excepci\u00f3n de las constantes de las instancias, dado que los atributos est\u00e1ticos a\u00fan no han sido inicializados cuando se est\u00e1n ejecutando los constructores de las instancias. Un caso especial de esta restricci\u00f3n es que en los constructores de las instancias tampoco se puede acceder a otras instancias del enum.</p>"},{"location":"bloque_iii/tema_11/page-4/#clases-enummap","title":"Clases EnumMap","text":"<p>Es una implementaci\u00f3n de mapa muy eficiente donde las claves son elementos de una enumeraci\u00f3n:</p> EnumMainConsola <pre><code>public enum Operation {\n    PLUS(\"+\"), MINUS(\"-\"), TIMES(\"*\"), DIVIDE(\"/\");\n\n    private final String symbol;\n\n    private Operation(String symbol) {\n        this.symbol = symbol;\n    }\n\n    public String getSymbol() {\n        return symbol;\n    }\n}\n</code></pre> <pre><code>public class ShowEnumMap {\n    public void show() {\n        EnumMap&lt;Operation, String&gt; operationsMap = new EnumMap&lt;&gt;(Operation.class);\n\n        operationsMap.put(Operation.PLUS, \"Esta operaci\u00f3n se utiliza para sumar\");\n        operationsMap.put(Operation.MINUS, \"Esta operaci\u00f3n se utiliza para restar\");\n        operationsMap.put(Operation.TIMES, \"Esta operaci\u00f3n se utiliza para multiplicar\");\n        operationsMap.put(Operation.DIVIDE, \"Esta operaci\u00f3n se utiliza para dividir\");\n\n        for (Map.Entry&lt;Operation, String&gt; entry : operationsMap.entrySet()) {\n            System.out.printf(\"%-6s: %s\\n\", entry.getKey(), entry.getValue());\n        }\n    }\n\n    public static void main(String[] args) {\n        new ShowEnumMap().show();\n    }\n}\n</code></pre> <pre><code>PLUS : Esta operaci\u00f3n se utiliza para sumar\nMINUS : Esta operaci\u00f3n se utiliza para restar\nTIMES : Esta operaci\u00f3n se utiliza para multiplicar\nDIVIDE: Esta operaci\u00f3n se utiliza para dividir\n</code></pre>"},{"location":"bloque_iii/tema_11/page-5/","title":"5 \u00c1rboles","text":""},{"location":"bloque_iii/tema_11/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Los \u00e1rboles se caracterizan por almacenar sus nodos en forma jer\u00e1rquica y no en forma lineal como las listas</p> <p> Figura 1 - \u00c1rboles</p> <p>Un \u00e1rbol es una estructura en la que los datos se organizan en nodos. Los \u00e1rboles binarios son aquellos en los que un nodo solamente puede tener dos hijos como m\u00e1ximo. Se utilizan para ordenar datos, de tal manera que a la izquierda se colocan los valores menores y a la derecha los valores mayores. Un \u00e1rbol binario se puede recorrer de varias formas, siendo el recorrido inorden el que muestra los datos ordenados: sub\u00e1rbol izquierdo, ra\u00edz, sub\u00e1rbol derecho. Veamos un ejemplo.</p> <p> Figura 2 - Ejemplo \u00e1rbol</p> <p>Nos posicionamos en el 9. Mientras tenga sub\u00e1rbol izquierdo vamos avanzando hasta llegar al 1. Como es una hoja, la mostramos: el 1. Luego mostramos la ra\u00edz: el 3. Despu\u00e9s, continuamos con el sub\u00e1rbol derecho. Nos encontramos con el 6, pero tiene sub\u00e1rbol izquierdo, as\u00ed avanzamos hasta el 4. Como es una hoja, los mostramos: el 4. Luego, continuamos con la ra\u00edz: el 6. Despu\u00e9s, continuamos con el sub\u00e1rbol derecho, avanzando hasta el 7. Como es hoja, lo mostramos: el 7. Ya hemos tratado todo el sub\u00e1rbol izquierdo del 8, que es la ra\u00edz. Ahora mostramos la ra\u00edz: el 8 y a continuaci\u00f3n comenzamos con el sub\u00e1rbol derecho del 8. Y as\u00ed sucesivamente. El resultado final es: 1,3,4,6,7,8,10,13 y 14, es decir, los elementos ordenador de menor a mayor.</p> <p>Si queremos introducir un nuevo nodo en el \u00e1rbol, hay que tener en cuidado de no romper la estructura ni el orden del \u00e1rbol. Hay que tener en cuenta que cada nodo nunca se podr\u00e1 insertar como su hijo. Con esta restricci\u00f3n nos aseguramos de mantener la estructura del \u00e1rbol, pero a\u00fan nos falta mantener el orden. Para localizar el lugar adecuado del \u00e1rbol donde insertar el nuevo nodo se realizan comparaciones entre los nodos del \u00e1rbol y el elemento a insertar. El primer nodo que se compara es el nodo ra\u00edz, si el nuevo nodo es menor que el ra\u00edz, la b\u00fasqueda prosigue por el lado izquierdo de \u00e9ste. Si el nuevo nodo fuese mayor, la b\u00fasqueda seguir\u00eda por el hijo derecho. Y as\u00ed, sucesivamente hasta llegar a un nodo que no tenga hijo en la rama por la que la b\u00fasqueda deber\u00eda seguir. En este caso, el nuevo nodo se inserta en ese hueco, como su nuevo hijo.</p> <p>Por ejemplo, queremos insertar el elemento 9. Lo primero es comparar el nuevo elemento con el nodo ra\u00edz. Como 9 &gt; 8, entonces la b\u00fasqueda prosigue por el lado derecho. Ahora el nuevo nodo se compara con el elemento 10. En este caso 9 &lt; 10, por lo que hay que continuar la b\u00fasqueda por la rama izquierda. Como la rama izquierda de 10 no tiene ning\u00fan nodo, se inserta en ese lugar el nuevo nodo.</p> <p>La interfaz <code>SortedSet&lt;E&gt;</code> es la encargada de definir esta estructura. Esta interfaz es hija de <code>Set&lt;E&gt;</code>, que a su vez es hija de <code>Collection&lt;E&gt;</code>, que a su vez es hija de `Iterable. Por lo tanto, tiene los m\u00e9todos de todas y adem\u00e1s a\u00f1ade sus propios m\u00e9todos. <ul> <li><code>E first()</code>: devuelve el elemento m\u00e1s peque\u00f1o.</li> <li><code>E last()</code>: devuelve el elemento m\u00e1s grande.</li> <li><code>SortedSet&lt;E&gt; headSet(E toElement)</code>: devuelve un SortedSet que contendr\u00e1 todos los elementos menores que toElement.</li> <li><code>SortedSet&lt;E&gt; tailSet(E fromElement)</code>: devuelve un SortedSet que contendr\u00e1 todos los elementos mayores que fromElement.</li> <li><code>SortedSet&lt;E&gt; subSet(E fromElement, E toElement)</code>: devuelve un SortedSet que contendr\u00e1 los elementos que van desde fromElement incluido haste toElement excluido.</li> </ul> <p>Pero, \u00bfc\u00f3mo ordenamos los elementos por ejemplo veh\u00edculos? Para ello, Java nos proporciona dos interfaces: <code>Comparable&lt;T&gt;</code> y <code>Comparator&lt;T&gt;</code>. La diferencia entre ambas es que Comparable se implementa desde la propia clase que se quiere ordenar y Comparator^ no.</p>"},{"location":"bloque_iii/tema_11/page-5/#interfaz-comparable","title":"Interfaz Comparable","text":"<p>La interfaz <code>Comparable</code> contiene un \u00fanico m\u00e9todo, el m\u00e9todo <code>compareTo</code>, que recibe un objeto de la misma clase y que debe realizar una comparaci\u00f3n entre ambos objetos, retornando un valor entero negativo, cero o positivo, dependiendo de si el objeto sobre el que se ejecuta es respectivamente, menor, igual o mayor que el objeto recibido.</p> <p>La definici\u00f3n de la interfaz es la siguiente:</p> <pre><code>public interface Comparable&lt;T&gt;{\n    int compareTo(T o);\n}\n</code></pre> <p>Por ejemplo, si quisi\u00e9ramos crear un \u00e1rbol para ordenar los veh\u00edculos lo primero que tendr\u00edamos que hacer es que la clase Vehicle implemente la interfaz Comparable y que el m\u00e9todo compareTo ordene por el atributo que deseemos. Por ejemplo, vamos a ordenar veh\u00edculos alfab\u00e9ticamente por el color. Como el color es de tipo String, debemos utilizar el compareTo de la clase String:</p> VehicleMain <pre><code>public class Vehicle implements Comparable&lt;Vehicle&gt; {\n    private String registration;\n    private int wheelCount;\n    private double speed;\n    private String colour;\n\n    public Vehicle(String registration, int wheelCount, String colour) {\n        this.registration = registration;\n        this.wheelCount = wheelCount;\n        this.colour = colour;\n        speed = 0;\n    }\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public String getColour() {\n        return colour;\n    }\n\n    public void setColour(String colour) {\n        this.colour = colour;\n    }\n\n    public String getRegistration() {\n        return registration;\n    }\n\n    public void accelerate(double amount) {\n        speed += amount;\n    }\n\n    public void brake(double amount) {\n        speed -= amount;\n    }\n\n    @Override\n    public String toString() {\n        return \"Vehicle [registration=\" + registration + \", wheelCount=\" +  wheelCount + \", speed=\" + speed + \", colour=\"\n                + colour + \"]\";\n    }\n\n    @Override\n    public int compareTo(Vehicle o) {\n        return colour.compareTo(o.colour);\n    }\n}\n</code></pre> <pre><code>public class Compare{\n    public void show(){\n        Vehicle v1 = new Vehicle(\"9685KMX\", 4, \"azul\");\n        Vehicle v2 = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        Vehicle v3 = new Vehicle(\"7314QWE\", 4, \"rojo\");\n\n        System.out.println(v1.compareTo(v2)); // positivo -&gt; v1 &gt; v2\n        System.out.println(v2.compareTo(v1)); // negativo -&gt; v2 &lt; v1\n        System.out.println(v1.compareTo(v3)); // 0 -&gt; v1 == v3\n    }\n\n    public static void main(String[] args){\n        new Compare().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-5/#interfaz-comparator","title":"Interfaz Comparator","text":"<p>La interfaz <code>Comparator&lt;T&gt;</code> es una interfaz que define el m\u00e9todo <code>compare</code>al que se le pasan los dos objetos a comparar y cuyo resultado es como el del compareTo (0 si son iguales, positivo si el primero es mayor y negativo si el segundo es mayor). Para definir un comparador de este forma, hay que crear una clase que implemente esta interfaz y definir el m\u00e9todo compare, despu\u00e9s crear un objeto de ese tipo y usarlo.</p> VehicleComparatorMain <pre><code>public class VehicleComparator implements Comparator&lt;Vehicle&gt;{\n    @Override\n    public int compare(Vehicle o1, Vehicle o2){\n        return o1.getColour().compareTo(o2.getColour());\n    }\n}\n</code></pre> <pre><code>public class Comparator{\n    public void show(){\n        Vehicle v1 = new Vehicle(\"9685KMX\", 4, \"azul\");\n        Vehicle v2 = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        Vehicle v3 = new Vehicle(\"7314QWE\", 4, \"rojo\");\n        VehicleComparator comparator = new VehicleComparator();\n\n        System.out.println(comparator.compare(v1, v2)); // positivo -&gt; v1 &gt; v2\n        System.out.println(comparator.compare(v2, v1)); // negativo -&gt; v2 &lt; v1\n        System.out.println(comparator.compare(v1, v3)); // 0 -&gt; v1 == v3\n    }\n\n    public static void main(String[] args){\n        new Comparator().show();\n    }\n}\n</code></pre> <p>Si dicha clase, solo va a ser utilizada una \u00fanica vez, se recomienda usar una clase an\u00f3nima en l\u00ednea:</p> <pre><code>public class ComparatorAnonymous{\n    public void show(){\n        Vehicle v1 = new Vehicle(\"9685KMX\", 4, \"azul\");\n        Vehicle v2 = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        Vehicle v3 = new Vehicle(\"7314QWE\", 4, \"rojo\");\n        Comparator comparator = new Comparator&lt;Vehicle&gt;(){\n                @Override\n                public int compare(Vehicle o1, Vehicle o2){\n                    return o1.getColour().compareTo(o2.getColour());\n                }\n            };\n\n        System.out.println(comparator.compare(v1, v2)); // positivo -&gt; v1 &gt; v2\n        System.out.println(comparator.compare(v2, v1)); // negativo -&gt; v2 &lt; v1\n        System.out.println(comparator.compare(v1, v3)); // 0 -&gt; v1 == v3\n    }\n\n    public static void main(String[] args){\n        new ComparatorAnonymous().show();\n    }\n}\n</code></pre> <p>Para ordenar descendientemente se cambiar\u00eda el orden de <code>o1</code> por el de <code>o2</code>.</p>"},{"location":"bloque_iii/tema_11/page-5/#usos-de-comparable-y-comparator","title":"Usos de comparable y comparator","text":"<p>Cuando creemos clases que representen valores que posean un determinado orden natural, como por ejemplo un orden alfab\u00e9tico, num\u00e9rico o cronol\u00f3gico, deberemos hacer que dicha clase implemente la interfaz  Comparable, permitiendo as\u00ed que los objetos de dicha clase puedan trabajar con mucho algoritmos gen\u00e9ricos e implementaciones de colecciones que dependen de dicha interfaz.</p> <p>La mayor\u00eda de las clases est\u00e1ndar que representan valores y de las clases enums incorporadas a Java,  implementan  la  interfaz  Comparable,  como  por  ejemplo  la  clase  String.  Las  clases  que definamos nosotros que representen valores tambi\u00e9n deber\u00edan implementarla.</p> <p>A la hora de realizar la implementaci\u00f3n debemos respetar una serie de reglas:</p> <ul> <li><code>x.compareTo(y) == -y.compareTo(x)</code>  para todo valor de  x  e  y .</li> <li>La relaci\u00f3n es transitiva, es decir, que si  <code>(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt;0)</code> entonces  <code>x.compareTo(z) &gt; 0</code>.</li> <li>Si  <code>x.compareTo(y) == 0</code>  entonces  <code>x.compareTo(z) == y.compareTo(z)</code> para cualquier valor de  z.</li> <li>Aunque  no  es  obligatorio  se  recomienda  que  <code>(x.compareTo(y) == 0)</code> == <code>(x.equals(y))</code>.</li> </ul> <p>Si para comparar los objetos debemos comparar un atributo de un tipo primitivo, se recomienda usar los m\u00e9todos est\u00e1ticos de comparaci\u00f3n  compare   de  las  clases  boxed  correspondientes, como <code>Long.compare()</code>,  <code>Float.compare()</code>, etc., disponibles a partir de Java 7, en vez de usar los operadores <code>&lt;</code>  o <code>&gt;</code>, ya que son menos verbosos y propensos al error:</p>"},{"location":"bloque_iii/tema_11/page-5/#clase-treeset","title":"Clase TreeSet","text":"<p>La clase <code>TreeSet&lt;E&gt;</code> es la que se utiliza prioritariamente para trabajar con \u00e1rboles ordenados ya que implementa la interfaz <code>SortedSet&lt;E&gt;</code>.</p> <p>Los objetos a incluir en un TreeSet deben implementar Comparable o bien crear el \u00e1rbol con un constructor que reciba un Comparator</p> <p>Ejemplo:</p> VehicleMainConsola <pre><code>public class Vehicle implements Comparable&lt;Vehicle&gt; {\n    private String registration;\n    private int wheelCount;\n    private double speed;\n    private String colour;\n\n    public Vehicle(String registration, int wheelCount, String colour) {\n        this.registration = registration;\n        this.wheelCount = wheelCount;\n        this.colour = colour;\n        speed = 0;\n    }\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public String getColour() {\n        return colour;\n    }\n\n    public void setColour(String colour) {\n        this.colour = colour;\n    }\n\n    public String getRegistration() {\n        return registration;\n    }\n\n    public void accelerate(double amount) {\n        speed += amount;\n    }\n\n    public void brake(double amount) {\n        speed -= amount;\n    }\n\n    @Override\n    public String toString() {\n        return \"Vehicle [registration=\" + registration + \", wheelCount=\" +  wheelCount + \", speed=\" + speed + \", colour=\"\n                + colour + \"]\";\n    }\n\n    @Override\n    public int compareTo(Vehicle o) {\n        return colour.compareTo(o.colour);\n    }\n}\n</code></pre> <pre><code>public class TreeSet1{\n    public void show(){\n        SortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;();\n        tree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        tree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        tree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        tree.add(new Vehicle(\"5930POI\", 2, \"negro\"));\n        tree.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\n        tree.add(new Vehicle(\"3495JZA\", 2, \"naranja\"));\n\n        for(Vehicle v: tree){\n            System.out.println(v);\n        }\n    }\n\n    public static void main(String[] args){\n        new TreeSet1().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Pero, \u00bfqu\u00e9 ocurrir\u00eda si tuvi\u00e9ramos colores repetidos?:</p> MainConsola <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\n\npublic class TreeSet2 {\n    public void show() {\n        SortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;();\n\n        tree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        tree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        tree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        tree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\n        tree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\n        tree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\n\n        for (Vehicle v : tree) {\n            System.out.println(v);\n        }\n    }\n\n    public static void main(String[] args) {\n        new TreeSet2().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Los tres primero veh\u00edculos se introducen en el \u00e1rbol. Cuando se va a introducir el cuarto que es de color azul, el \u00e1rbol lo va comparando con compareTo con los veh\u00edculos que ya existen el \u00e1rbol para encontrar la posici\u00f3n ordenada donde incluirlo. Pero cuando lo compara con el que es azul, el compareTo, devuelve 0, por lo que el \u00e1rbol interpreta que ese objeto ya existe en el \u00e1rbol, que es igual a otro, por lo tanto no lo incluye en el \u00e1rbol. Lo mismo ocurre con el quinto y el sexto. Por lo tanto, lo que ocurrir\u00eda es que los 3 \u00faltimos no se introducen en el \u00e1rbol porque compareTo devuelve 0 entre veh\u00edculos del mismo color, por lo que el \u00e1rbol considera que son iguales. En estos casos, lo que se hace es que se incluye un segundo criterio de comparaci\u00f3n: vamos a ordenar por el color, y en aquellos casos donde los veh\u00edculos tengan el mismo color entonces vamos a ordenar por matr\u00edcula.</p> VehicleMainConsola <pre><code>public class Vehicle implements Comparable&lt;Vehicle&gt;{\n    //...\n\n    @Override\n    public int compareTo(Vehicle o){\n        int result = colour.compareTo(o.colour);\n\n        if(result == 0){\n            result = registration.compareTo(o,registration);\n        }\n\n        return result;\n    }\n}\n</code></pre> <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\npublic class ShowTreeSet {\n    public void show() {\n        SortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;();\n\n        tree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        tree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        tree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        tree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\n        tree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\n        tree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\n\n        for (Vehicle v : tree) {\n            System.out.println(v);\n        }\n    }\n\n    public static void main(String[] args) {\n        new ShowTreeSet().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Pero, \u00bfqu\u00e9 ocurrir\u00eda si la clase Vehicle no implementase la interfaz Comparable? Pues que no contendr\u00eda el m\u00e9todo compareTo, entonces el \u00e1rbol no tendr\u00eda la informaci\u00f3n de c\u00f3mo ordenar los veh\u00edculos. En este caso, se lanzar\u00eda una excepci\u00f3n <code>ClassCastException</code>.</p> VehicleMainConsola <pre><code>public class Vehicle{\n    //...\n\n    // No contiene el m\u00e9todo compareTo\n}\n</code></pre> <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\n\npublic class ShowException{\n\n    public void show(){\n        SortedSet&lt;Vehicle&gt; = new TreeSet&lt;&gt;();\n        tree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        tree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        tree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        tree.add(new Vehicle(\"5930POI\", 2, \"negro\"));\n        tree.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\n        tree.add(new Vehicle(\"3495JZA\", 2, \"naranja\"));\n\n        for(Vehicle v: tree){\n            System.out.println(v);\n        }\n    }\n\n    public static void main(String[] args){\n        new ShowException().show();\n    }\n}\n</code></pre> <pre><code>Exception in thread \"main\" java.lang.ClassCastException: class \ntema11_Colecciones.arboles3.Vehicle cannot be cast to class\njava.lang.Comparable (tema11_Colecciones.arboles3.Vehicle is in unnamed module\nof loader 'app'; java.lang.Comparable is in module java.base of loader\n'bootstrap')\nat java.base/java.util.TreeMap.compare(TreeMap.java:1291)\nat java.base/java.util.TreeMap.put(TreeMap.java:536)\nat java.base/java.util.TreeSet.add(TreeSet.java:255)\nat tema11_Colecciones.arboles3.ShowException.show(ShowException.java:11)\nat tema11_Colecciones.arboles3.ShowException.main(ShowException.java:25)\n</code></pre> <p>Otra posibilidad es utilizar un objeto <code>Comparator&lt;E&gt;</code>. Para ello, se crea la clase que implementa dicha interfaz y se usar\u00eda en la construcci\u00f3n del \u00e1rbol mediante un constructor que recibe un Comparator: <code>TreeSet(Comparator&lt;? super E&gt; comparator)</code>. En este caso, \u00e9sa ser\u00e1 la forma prioritaria para ordenar la lista, por encima del m\u00e9todo compareTo de la interfaz Comparable. Como ya dijimos anteriormente, la diferencia entre Comparable y Comparator es que Comparable se implementa desde la propia clase que se quiere ordenar y Comparator no, ya que Comparator se implementa desde otra clase distinta a la que se quiere ordenar:</p> VehicleComparatorMainConsola <pre><code>import java.util.comparator;\n\npublic class VehicleComparator implements Comparator&lt;Vehicle&gt;{\n\n    @Override\n    public int compare(Vehicle o1, Vehicle o2){\n        int result = o1.getColour().compareTo(o2.getColour());\n\n        if(result == 0){\n            result = o1.getRegistration().compareTo(o2.getRegistration());\n        }\n\n        return result;\n    }\n}\n</code></pre> <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\n\npublic class ShowComparator {\n    public void show() {\n        SortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new VehicleComparator());\n\n        tree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        tree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        tree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        tree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\n        tree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\n        tree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\n\n        for (Vehicle v : tree) {\n            System.out.println(v);\n        }\n    }\n\n    public static void main(String[] args) {\n        new ShowComparator().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Pero si esta comparaci\u00f3n la vamos a utilizar solamente una vez, tenemos que crear una clase solamente para su uso. Y si necesitamos ordenar los veh\u00edculos de varias maneras, tenemos que tener una clase por cada criterio de ordenaci\u00f3n. En estos casos, podemos utilizar una clase inline an\u00f3nima:</p> MainConsola <pre><code>import java.util.Comparator;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\npublic class AnonymousComparator {\n    public void show() {\n        SortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new Comparator&lt;Vehicle&gt;(){\n            @Override\n            public int compare(Vehicle o1, Vehicle o2){\n                int result = o1.getColour().compareTo(o2.getColour());\n\n                if(result == 0){\n                    result = o1.getRegistration().compareTo(o2.getRegistration());\n                }\n\n                return result;\n            }\n        });\n\n        tree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        tree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        tree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        tree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\n        tree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\n        tree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\n\n        for (Vehicle v : tree) {\n            System.out.println(v);\n        }\n    }\n\n    public static void main(String[] args) {\n        new AnonymousComparator().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Si quisi\u00e9ramos ordenar de manera descendente, cambiamos el orden entre o1 y o2, es decir, hacemos que sea o2 el que ejecute el compareTo</p> MainConsola <pre><code>import java.util.Comparator;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\npublic class DescendingOrder {\n    public void show() {\n        SortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new Comparator&lt;Vehicle&gt;(){\n            /*\n             * Si quisi\u00e9ramos ordenar de manera descendente,\n             * cambiamos el orden entre o1 y o2, es decir,\n             * hacemos que sea o2 el que ejecute el compareTo\n             */\n            @Override\n            public int compare(Vehicle o1, Vehicle o2){\n                int result = o2.getColour().compareTo(o1.getColour());\n\n                if(result == 0){\n                    result = o2.getRegistration().compareTo(o1.getRegistration());\n                }\n\n                return result;\n            }\n        });\n\n        tree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        tree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        tree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        tree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\n        tree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\n        tree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\n\n        for (Vehicle v : tree) {\n            System.out.println(v);\n        }\n    }\n\n    public static void main(String[] args) {\n        new DescendingOrder().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Los comparadores de tipo Comparator permiten ordenar de diferentes formas, por eso en la pr\u00e1ctica se utilizan mucho. Por ejemplo, el m\u00e9todo sort de la clase Arrays tambi\u00e9n admite indicar un comparador para saber de qu\u00e9 forma deseamos ordenar el array.</p> CompareBoxedClassesConsola <pre><code>import java.util.Comparator;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\npublic class CompareBoxedClasses {\n    public void show() {\n        SortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new Comparator&lt;Vehicle&gt;() {\n\n            @Override\n            public int compare(Vehicle o1, Vehicle o2) {\n                int result = Integer.compare(o1.getWheelCount(), o2.getWheelCount());\n                if (result == 0) {\n                    result = Double.compare(o1.getSpeed(), o2.getSpeed());\n                }\n                return result;\n            }\n        });\n\n        Vehicle vehicles[] = new Vehicle[6];\n\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[0].accelerate(100);\n\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[1].accelerate(150);\n\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[2].accelerate(200);\n\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[3].accelerate(80);\n\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[4].accelerate(75);\n\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n        vehicles[5].accelerate(170);\n\n        for (int i = 0; i &lt; vehicles.length; i++) {\n            tree.add(vehicles[i]);\n        }\n\n        for (Vehicle v : tree) {\n            System.out.println(v);\n        }\n    }\n\n    public static void main(String[] args) {\n        new CompareBoxedClasses().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=80.0, colour=negro]\nVehicle [registration=1235GTR, wheelCount=2, speed=150.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=170.0, colour=naranja]\nVehicle [registration=1705UBG, wheelCount=4, speed=75.0, colour=blanco]\nVehicle [registration=9685KMX, wheelCount=4, speed=100.0, colour=azul]\nVehicle [registration=7314QWE, wheelCount=4, speed=200.0, colour=verde]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-5/#clase-treemap","title":"Clase TreeMap","text":"<p>Esta implementaci\u00f3n utiliza una estructura de \u00e1rbol que permite que los elementos del mapa se ordenen en sentido ascendente seg\u00fan la clave, por lo tanto, la clase de las claves tiene que implementar la interfaz Comparable o bien indicar un objeto Comparator durante la creaci\u00f3n del TreeMap.</p> <p>TreeMap implementa la interfaz  <code>SortedMap</code>  que, a su vez, es heredera de  <code>Map</code> , por lo que todo lo dicho sobre los mapas funciona con las colecciones de tipo TreeMap.</p> MainConsola <pre><code>import java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\npublic class ShowTreeMap {\n    public void show() {\n        SortedMap&lt;String, Vehicle&gt; sortedMap = new TreeMap&lt;&gt;();\n\n        Vehicle vehicles[] = new Vehicle[6];\n\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n\n        for (int i = 0; i &lt; vehicles.length; i++) {\n            sortedMap.put(vehicles[i].getRegistration(), vehicles[i]);\n        }\n\n        for (Map.Entry&lt;String, Vehicle&gt; entry : sortedMap.entrySet()) {\n            System.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\", entry.getKey(), entry.getValue());\n        }\n    }\n\n    public static void main(String[] args) {\n        new ShowTreeMap().show();\n    }\n</code></pre> <pre><code>Matr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, \nspeed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4,\nspeed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2,\nspeed=0.0, colour=naranja]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2,\nspeed=0.0, colour=negro]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4,\nspeed=0.0, colour=verde]\nMatr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4,\nspeed=0.0, colour=azul]\n</code></pre> <p>Como podemos observar, est\u00e1 ordenado ascendentemente por la matr\u00edcula ya que la matr\u00edcula es de tipo <code>String</code> que implementa la interfaz  <code>Comparable</code>. Si la clave fuera una clase hecha por nosotros, tendr\u00edamos que hacer que implementara Comparable o bien indicar un Comparator en la creaci\u00f3n del TreeMap.</p>"},{"location":"bloque_iii/tema_11/page-6/","title":"6 Pilas y colas","text":""},{"location":"bloque_iii/tema_11/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Una cola es un tipo de dato que sigue el principio FIFO (first in, first out) que implica que el primer elemento en ser insertado en la cola es tambi\u00e9n el primero en ser eliminado de la misma.</p> <p>En el mundo real podemos encontrar este ejemplo en las colas de un banco, la cadena de impresi\u00f3n de documentos, etc. En el caso de la cola en el banco, la primera persona en llegar es tambi\u00e9n la primera en irse (suponiendo una \u00fanica ventanilla) y en los documentos a imprimir, la impresora imprime seg\u00fan el orden de llegada.</p> <p><code>Queue&lt;E&gt;</code> es una interfaz que hereda de Collection que proporciona operaciones para trabajar con una cola. Veamos alguna de ellas:</p> <ul> <li><code>boolean add(E e)</code>: inserta el elemento al final de la cola.</li> <li><code>E  element()</code>: Devuelve, pero no elimina,  el principio de la cola. Lanza la excepci\u00f3n <code>NoSuchElementException</code> si la cola est\u00e1 vac\u00eda.</li> <li><code>E peek()</code>:Devuelve, pero no elimina, el principio de la cola. Devuelve null si la cola est\u00e1 vac\u00eda.</li> <li><code>E poll()</code>: Devuelve y elimina el principio de la cola. Devuelve null si la cola est\u00e1 vac\u00eda.</li> <li><code>E  remove()</code>: Devuelve y elimina el principio de la cola. Lanza la excepci\u00f3n <code>NoSuchElementException</code> si la cola est\u00e1 vac\u00eda.</li> </ul> <p><code>Deque&lt;E&gt;</code> representa  una  cola  de  doble  extremo,  lo  que  significa  que  se  puede  insertar  y eliminar elementos desde ambos extremos de la cola. El nombre Deque es una abreviatura de Double Ended Queue. Admite,  por  lo  tanto, la  implementaci\u00f3n  de  la  cola  FIFO  como  la implementaci\u00f3n de la pila LIFO, que implica que el \u00faltimo elemento que se ha insertado, es el primero en ser eliminado: LIFO (last in, first out).</p> <p>Deque hereda de Queue, por lo que tiene todos sus m\u00e9todos y adem\u00e1s a\u00f1ade los suyos propios.Veamos algunos de ellos:</p> <ul> <li><code>void addFirst(E e)</code>: inserta el elemento al principio.</li> <li><code>void addLast(E e)</code>: inserta el elemento al final.</li> <li><code>E  getFirst()</code>: Devuelve, pero no  elimina,  el  primer  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code>  si el Deque est\u00e1 vac\u00edo.</li> <li><code>E  getLast()</code>: Devuelve, pero no elimina,  el  \u00faltimo  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code> si el Deque est\u00e1 vac\u00edo.</li> <li><code>E peekFirst()</code>: Devuelve, pero no elimina, el primer elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E peekLast()</code>: Devuelve, pero no elimina, el \u00faltimo elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E pollFirst()</code>: Devuelve y elimina el primer elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E pollLast()</code>: Devuelve y elimina el \u00faltimo elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E  removeFirst()</code>: Devuelve  y  elimina  el  primer  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code> si el Deque est\u00e1 vac\u00edo.</li> <li><code>E  removeLast()</code>: Devuelve y elimina el \u00faltimo  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code> si el Deque est\u00e1 vac\u00edo.</li> </ul>"},{"location":"bloque_iii/tema_11/page-6/#clase-arraydeque","title":"Clase ArrayDeque","text":"<p>La clase <code>ArrayDeque&lt;E&gt;</code> implementa la interfaz Deque y por lo tanto, tambi\u00e9n Queue, ya que Deque hereda de Queue.</p> ColaConsola ColaPilaConsola Pila <p><pre><code>import java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class ShowQueue{\n    public void show(){\n        Queue&lt;Vehicle&gt; queue = new ArrayDeque();\n\n        queue.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        queue.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        queue.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n\n        System.out.println(queue.element()); //(1)!\n        System.out.println(queue.peek());//(2)!\n        System.out.println(queue.poll());//(3)!\n        System.out.println(queue.remove());//(4)!\n        System.out.println(queue.remove());//(5)!\n        System.out.println(queue.peek());//(6)!\n        System.out.println(queue.poll());//(7)!\n        System.out.println(queue.element());//(8)!\n        System.out.println(queue.remove());//(9)!\n    }\n\n    public static void main(String[] args){\n        new ShowQueue().show();\n    }\n}\n</code></pre> 1. Devuelve pero no elimina 9685KMX 1. Devuelve pero no elimina: 9685KMX 1. Devuelve y elimina: 9685KMX 1. Devuelve y elimina: 1235GTR 1. Devuelve y elimina el \u00faltimo, se queda la cola vac\u00eda: 7314QWE 1. Devuelve null 1. Devuelve null 1. Lanza NoSuchElementException porque la cola est\u00e1 vac\u00eda 1. Lanza NoSuchElementException porque la cola est\u00e1 vac\u00eda</p> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nnull\nnull\nException in thread \"main\" java.util.NoSuchElementException\n    at java.base/java.util.ArrayDeque.getFirst(ArrayDeque.java:402)\n    at java.base/java.util.ArrayDeque.element(ArrayDeque.java:551)\n    at tema11_Colecciones.pilasYColas.ShowQueue.show(ShowQueue.java:21)\n    at tema11_Colecciones.pilasYColas.ShowQueue.main(ShowQueue.java:28)\n</code></pre> <pre><code>import java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class ShowDeque{\n    public void show(){\n        Queue&lt;Vehicle&gt; deque = new ArrayDeque();\n\n        deque.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        deque.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        deque.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n\n        System.out.println(deque.element()); //(1)!\n        System.out.println(deque.peek());//(2)!\n        System.out.println(deque.poll());//(3)!\n        System.out.println(deque.remove());//(4)!\n        System.out.println(deque.remove());//(5)!\n        System.out.println(deque.peek());//(6)!\n        System.out.println(deque.poll());//(7)!\n        System.out.println(deque.element());//(8)!\n        System.out.println(deque.remove());//(9)!\n    }\n\n    public static void main(String[] args){\n        new ShowDeque().show();\n    }\n}\n</code></pre> <ol> <li>Devuelve pero no elimina 7314QWE</li> <li>Devuelve pero no elimina: 7314QWE</li> <li>Devuelve y elimina: 7314QWE</li> <li>Devuelve y elimina: 1235GTR</li> <li>Devuelve y elimina el \u00faltimo, se queda la pila vac\u00eda: 9685KMX</li> <li>Devuelve null</li> <li>Devuelve null</li> <li>Lanza NoSuchElementException porque la pila est\u00e1 vac\u00eda</li> <li>Lanza NoSuchElementException porque la pila est\u00e1 vac\u00eda</li> </ol> <pre><code>Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nnull\nnull\nException in thread \"main\" java.util.NoSuchElementException\n    at java.base/java.util.ArrayDeque.getLast(ArrayDeque.java:413)\n    at tema11_Colecciones.pilasYColas.ShowDeque.show(ShowDeque.java:21)\n    at tema11_Colecciones.pilasYColas.ShowDeque.main(ShowDeque.java:28)\n</code></pre>"},{"location":"bloque_iii/tema_11/page-6/#clase-collections","title":"Clase Collections","text":"<p>La clase  Collections  contiene numerosos m\u00e9todos est\u00e1ticos para utilizar con todo tipo de colecciones,  como  por  ejemplo,  para  a\u00f1adir,  buscar,  copiar,  reemplazar,  ordenar,  obtener  el m\u00e1ximo o el m\u00ednimo, etc.</p>"},{"location":"bloque_iii/tema_11/page-7/","title":"Ejercicios","text":"Ejercicio 1 <p>Utilizando la clase gen\u00e9rica caja del bolet\u00edn de gen\u00e9ricos, haz un programa que haga lo siguiente:</p> <ul> <li>Guardar en una lista 5 cajas de cadenas. Recorrer la lista y mostrar por pantalla el contenido de todas las cajas. Mostrar una concatenaci\u00f3n de todas las cadenas.</li> <li>Guardar en otra lista 5 cajas de long. Recorrer la lista y mostrar por pantalla el contenido de las cajas. Mostrar un resultado de sumarlas todas.</li> </ul> Ejercicio 2 <p>Realiza una interfaz gen\u00e9rica que contenga dos m\u00e9todo:     T primerContenido();     T ultimoContenido();</p> <p>Realizar una clase Almacen que contenga una lista de cajas. Dicha clase debe implementar esa interfaz. Los m\u00e9todos devolver\u00e1n el contenido de la primera caja y el contenido de la \u00faltima caja respectivamente.</p> Ejercicio 3 <p>Realiza el siguiente men\u00fa para gestionar una lista simplemente enlazada de cadenas:</p> <ol> <li>Nueva lista</li> <li>N\u00famero de cadenas</li> <li>A\u00f1adir cadena</li> <li>Eliminar cadena</li> <li>Contiene cadena</li> <li>Mostrar lista entera</li> <li>Salir</li> </ol> <p>En la opci\u00f3n 1, se limpiar\u00e1 toda la lista dejando la lista vac\u00eda. En la opci\u00f3n 5, se le pedir\u00e1 una cadena al usuario y se le dir\u00e1 si est\u00e1 o no en la lista.</p> Ejercicio 4 <p>Rellena una lista simplemente enlazada circular de n\u00fameros decimales de tipo float. A continuaci\u00f3n, presentar el siguiente men\u00fa.</p> <ol> <li>Mostrar la lista</li> <li>Mostrar siguiente</li> <li>Eliminar \u00faltimo mostrado</li> <li>Salir</li> </ol> <p>En la opci\u00f3n 2, la primera vez que se ejecute saldr\u00e1 el primero de la lista. La Siguiente vez el segundo, y as\u00ed sucesivamente. Si el \u00faltimo mostrado ha sido el \u00faltimo y se le vuelve a dar esta opci\u00f3n, entonces se mostrar\u00e1 el primero. En la opci\u00f3n 3, se elimina el \u00faltimo mostrado por la opci\u00f3n 2.</p> Ejercicio 5 <p>Realiza el mismo ejercicio anterior pero con una lista doblemente enlazada circular. A\u00f1\u00e1dele una opci\u00f3n nueva al men\u00fa que sea 'Mostrar anterior'.</p> Ejercicio 6 <p>Realiza el siguiente men\u00fa para gestionar una pila de n\u00fameros de tipo byte.</p> <ol> <li>Nueva pila</li> <li>Consultar elemento</li> <li>A\u00f1adir elemento</li> <li>Eliminar elemento</li> <li>Consultar toda la pila</li> <li>Salir</li> </ol> Ejercicio 7 <p>Realiza el ejercicio anterior pero con una cola.</p> Ejercicio 8 <p>Un videoclub quiere que le hagamos una aplicaci\u00f3n para registrar sus pel\u00edculas. Los requisitos que nos exigen son los siguientes:</p> <ul> <li>Enum Genero<ul> <li>3 valores: COMEDIA, FICCION, TERROR<ul> <li>M\u00e9todo getCodigo que devuelva el siguiente car\u00e1cter para cada valor:<ul> <li>COMEDIA: C</li> <li>FICCION: F</li> <li>TERROR: T</li> </ul> </li> </ul> </li> </ul> </li> <li>Clase Clave:<ul> <li>Atributos: enum Genero y un n\u00famero entero</li> <li>Atributos privados y solamente los getters necesarios</li> <li>M\u00e9todo toString: devuelve una cadena concatenando del enum con el n\u00famero entero. Ej: C1, F2, T3</li> <li>M\u00e9todo est\u00e1tico asignarClave: recibe un g\u00e9nero y devuelve un objeto de tipo Clave. El n\u00famero de la clave ser\u00e1 1 para la primera pel\u00edcula de comedia, 1 para la primera pel\u00edcula de terror, ..., 2 para las segundas, etc.</li> </ul> </li> <li>Clase Pel\u00edcula<ul> <li>Atributos:<ul> <li>Clave: objeto de la clase Clave</li> <li>Nombre</li> <li>FechaEstreno. fecha de estreno en Espa\u00f1a</li> <li>FechaDVD: fecha de venta en DVD</li> </ul> </li> <li>Atributos privados y solamente los getters necesarios</li> <li>Constructor: <code>Pelicula(String nombre, Genero genero, LocalDate fechaEstreno, LocalDate fechaDVD)</code></li> <li>Criterio de comparaci\u00f3n de la clase: descendientemente por d\u00edas que ha tardado la pel\u00edcula en salir en DVD desde que se estren\u00f3. Si dos pel\u00edculas tienen el mismo n\u00famero de d\u00edas, ordenarlas ascendentemente por orden alfab\u00e9tico del nombre.</li> </ul> </li> <li> <ul> <li>Se crear\u00e1n pel\u00edculas de la siguiente tabla:</li> </ul> <p>Clase Videoclub: esta clase contendr\u00e1 la l\u00f3gica con varias colecciones para hacer lo siguiente:</p> Orden de la inserci\u00f3n en la colecciones Nombre G\u00e9nero Clave Fecha Estreno Fecha DVD 1 Poltergeist, juegos diab\u00f3licos Terror T1 22/05/2015 22/09/2015 2 La cumbre escarlata Terror T2 09/10/2015 12/02/2016 3 Ocho apellidos catalanes Comedia C1 20/112015 18/03/2016 4 Padres por desigual Comedia C2 01/01/2016 11/05/2016 5 Star Wars: El despertar de la Fuerza Ficci\u00f3n F1 18/12/2015 20/04/2016 6 Mad Max: Furia en la carretera Ficci\u00f3n F2 15/05/2015 01/09/2015 7 Clon de Poltergeist, juegos diab\u00f3licos 8 Clon de Star Wars: El despertar de la fuerza <ul> <li>Utilizar las colecciones oportunas para crear la siguiente salida por consola exactamente igual. Insertar las pel\u00edculas en las colecciones en el orden indicado en la primera columna de la tabla. Tener en cuenta lo siguiente:<ul> <li>En el 3, utiliza un Comparator de manera an\u00f3nima</li> <li>En el 4, el criterio de comparaci\u00f3n de la clave es primera las de ficci\u00f3n, luego las de terror y por \u00faltimo las de comedia. A igualdad de g\u00e9nero, se ordena ascendentemente por el n\u00famero de la clave. Es decir, el orden ser\u00eda: F1, F2, T1, T2, C1, C2.</li> <li>En el 5, utilizar ListIterator.</li> </ul> </li> </ul> </li> </ul> <p>Salidas por consola:  </p> Ejercicio 9 <p>Realiza una aplicaci\u00f3n para gestionar los ex\u00e1menes de junio de 1\u00baCFGS de Aplicaciones Multiplataforma. Se crear\u00e1n los ex\u00e1menes que aparecen en la siguiente tabla y se insertar\u00e1n en todas las colecciones en el orden indicado en la primera columna de la tabla. La clave estar\u00e1 formada por el d\u00eda del examen, un guion y la hora de inicio y ser\u00e1 autogenerada por la clase. La fecha tiene que ser mostrada con el formato d\u00eda/mes/a\u00f1o, tal y como est\u00e1 en la tabla.</p> Orden de inserci\u00f3n en las colecciones Asignatura Descripci\u00f3n Fecha Hora de Inicio Hora de Fin Clave 1 Programaci\u00f3n Herencia y colecciones 16/06/2017 08:15 13:30 16-08:15 2 Base de datos Disparadores y SQL 15/06/2017 11:45 14:30 15-11:45 3 Sistemas Inform\u00e1ticos Sistemas en red 20/06/2017 10:15 11:35 20-10:15 4 Entornos de Desarrollo Diagramas de clases 19/06/2017 09:15 11:15 19-09:15 5 Lenguaje de Marcas Hojas de estilo 14/06/2017 08:15 11:15 13-10:15 6 FOL Derechos del trabajador 13/06/2017 10:15 11:15 13-10:15 7 Base de datos Entidad-Relaci\u00f3n 15/06/2017 08:15 11:30 15-08:15 8 Clon de Programaci\u00f3n 9 Clon de Lenguaje de Marcas <p>Realizar con dichos ex\u00e1menes lo siguiente, teniendo en cuenta que las salidas en consola est\u00e9n bien alineadas y que las horas tienen que salir con dos d\u00edgitos. Ejemplo 08:15</p> <ol> <li>Insertarlos en un ArrayList. Muestra el contenido del ArrayList.</li> <li>Inserta los ex\u00e1menes en una colecci\u00f3n sin duplicados que mantenga el orden de inserci\u00f3n. Muestra la colecci\u00f3n sin duplicados.</li> <li>Muestra el contenido de la colecci\u00f3n sin duplicados del apartado 2 al rev\u00e9s.</li> <li>Utilizando la interfaz List, solic\u00edtale al usuario los valores necesarios para mostrar una sublista de la colecci\u00f3n sin duplicados del apartado 2. Ejemplo: si el usuario introduce 3 y 5, se muestran los ex\u00e1menes de Sistemas Inform\u00e1ticos, Entornos de Desarrollo y Lenguaje de Marcas.</li> <li>Inserta los ex\u00e1menes en un \u00e1rbol. Utilizando la interfaz Comparable, ordena los ex\u00e1menes en el \u00e1rbol ascendente de asignatura, fecha y hora de inicio en este orden. Es decir, si la asignatura es la misma, entonces ordena por fecha, y si la fecha tambi\u00e9n es la misma, entonces ordena por hora. El primer examen ser\u00e1 el de Base de Datos que empieza a las 08:15 y el \u00faltimo ser\u00e1 el de Sistemas Inform\u00e1ticos.</li> <li>Inserta los ex\u00e1menes en otro \u00e1rbol pero esta vez utilizando la interfaz Comparator de manera an\u00f3nima. En dicha \u00e1rbol, el orden ser\u00e1 por orden descendente de fecha y hora de inicio en ese orden. El primer examen ser\u00e1 el de Sistemas Inform\u00e1ticos y el \u00faltimo ser\u00e1 el de FOL.</li> <li>Inserta los ex\u00e1menes en un mapa ordenado utilizando como clave del mapa el campo clave de los ex\u00e1menes. Mostrar el contenido del mapa ordenado.</li> </ol> Ejercicio 10 <p>Una empresa nos ha contratado para hacer una aplicaci\u00f3n en Java para registrar a sus empleados. Pertenecemos a un equipo de trabajo de programadores dirigidos por un analista. El analista quiere que cumplamos una serie de requisitos ya que luego habr\u00e1 que unir todo el c\u00f3digo hecho por los programadores. Los requisitos son los siguientes:</p> <ul> <li>Enum Categoria<ul> <li>3 valores: JEFE, ENCARGADO y EMPLEADO</li> <li>M\u00e9todo getCodigo que devuelva el siguiente car\u00e1cter para cada valor:<ul> <li>JEFE: J</li> <li>ENCARGADO: E</li> <li>EMPLEADO: D</li> </ul> </li> </ul> </li> <li>Clase Clave<ul> <li>Atributos: enum Categoria y un n\u00famero entero.</li> <li>Atributos privados y solamente los getters necesarios.</li> <li>M\u00e9todo toString: devuelve una cadena concatenando el c\u00f3digo del enum con el n\u00famero entero. Ej: J1</li> <li>M\u00e9todo est\u00e1tico asignarClave: recibe una categor\u00eda y devuelve un objeto de tipo Clave. El n\u00famero de la clave ser\u00e1 1 para el primer jefe, primer encargado y primer empleado, 2 para los segundos, etc.</li> </ul> </li> <li>Clase Empleado<ul> <li>Atributos:<ul> <li>Clave: objeto de la clase Clave</li> <li>Nombre</li> <li>FechaAlta: fecha de alta en la empresa</li> <li>FechaBaja: fecha de baja en la empresa. Si contin\u00faan trabajando en la empresa, este atributo se rellena con null  </li> </ul> </li> <li>Atributos privados y solamente los getters necesarios.</li> <li>Constructor: Empleado(String nombre, Categoria categoria, LocalDate fechaAlta, LocalDate fechaBaja)</li> <li>Criterio de comparaci\u00f3n de la clase: descendentemente por d\u00edas trabajados.</li> </ul> </li> <li> <ul> <li> <p>En los 3 \u00e1rboles se a\u00f1adir\u00e1n los siguientes empleados y en este mismo orden:</p> Orden de inserci\u00f3n en los \u00e1rboles Nombre Categor\u00eda Fecha Alta Fecha Baja 1 Pepe Empleado 21/03/2011 22/04/2013 2 Juan Encargado 29/02/2012 No tiene 3 Mar\u00eda Jefe 30/04/2010 No tiene 4 Laura Empleado 30/12/2010 No tiene 5 Esteban Encargado 05/11/2010 11/02/2015 6 Pedro Jefe 16/08/2009 No tiene 7 Yolanda Empleado 27/07/2012 01/10/2013 8 Nuria Jefe 31/08/2009 No tiene 9 Antonio Encargado 28/01/2011 14/05/2014 10 Clone de Pepe 11 Clone de Esteban 12 Clone de Pedro </li> </ul> <p>Clase Arboles: esta clase contendr\u00e1 el main con 3 \u00e1rboles de empleados:</p> <ul> <li>Los tres \u00e1rboles son los siguientes:<ul> <li>\u00c1rbol con los empleados ordenados descendentemente por d\u00edas trabajados.</li> <li>\u00c1rbol con los empleados ordenados ascendentemente por orden alfab\u00e9tico de los nombres de los empleados. Utiliza l interfaz Comparator de manera an\u00f3nima.</li> <li>TreeMap con los empleados ordenador descendentemente por categor\u00eda profesional y a misma categor\u00eda, se ordena ascendentemente por n\u00famero. Utilizar como clave del TreeMap el atributo clave del empleado. </li> </ul> </li> <li>De todos los \u00e1rboles hay que mostrar los datos. La salida por consola debe ser exactamente igual a la siguiente:</li> </ul> <p> </p> </li> </ul>"},{"location":"bloque_iii/tema_11/page-8/","title":"Proyecto","text":"<p>En una empresa quieren guardar informaci\u00f3n sobre los clientes, y de \u00e9stos se desea almacena:</p> <ul> <li>Clave del cliente, que estar\u00e1 formada por las dos primeras letras del nombre del cliente, las tres primeras letras de cada apellido, los tres n\u00fameros de su DNI y su letra. Por ejemplo, si un cliente se llama Rosa Vel\u00e1zquez Mart\u00ednez, con DNI 32050698G, su clave ser\u00eda **rovema698G*.</li> <li>Nombre del cliente</li> <li>Apellidos del cliente</li> <li>DNI</li> <li>Direcci\u00f3n, compuesta por la el tipo de v\u00eda (calle, avenida, pasaje, km, otro), el nombre de la v\u00eda, n\u00famero de la v\u00eda, c\u00f3digo postal, municipio, provincia y otra informaci\u00f3n relevante.</li> <li>Importe total comprado.</li> <li>Lista de fechas de compra.</li> </ul> <p>Crea aun aplicaci\u00f3n Java que le permita al usuario realizar las siguientes operaciones:</p> <ol> <li>A\u00f1adir clientes</li> <li>Consultar clientes por nombre</li> <li>Consultar clientes por DNI</li> <li>Eliminar clientes</li> <li>Mostrar todos los clientes</li> <li>Filtrar por fecha de compra</li> <li>Top 5 de clientes que m\u00e1s dinero han comprado</li> </ol> <p>Realizar la misma aplicaci\u00f3n con diferentes versiones.</p> <ul> <li>La primera versi\u00f3n se har\u00e1 uso de la interfaz List.</li> <li>La segunda versi\u00f3n se har\u00e1 uso de la interfaz Set.</li> <li>La tercera versi\u00f3n se har\u00e1 uso de la interfaz SortedSet.</li> <li>La cuarta versi\u00f3n se har\u00e1 uso de la interfaz Map.</li> <li>La quinta versi\u00f3n se har\u00e1 uso de la interfaz SortedMap.</li> </ul> <p>Ten en cuenta que el orden de natural de los clientes es ordenado primero por su apellido de forma ascendente, en caso de ser repetido, seguir\u00e1 ordenado por nombre de forma ascendente, en caso de que haya dos personas que se llamen igual, se ordenar\u00e1 por las veces que ha realizado un comprar de forma descendente, y por \u00faltimo lugar, el DNI de forma descendiente.</p> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>Se deber\u00e1 entregar un diagrama de clase que represente las relaciones entre las clases y las interfaces.</li> <li>Se valorar\u00e1 la complejidad de un Main que ponga aprueba los m\u00e9todos y clases creadas, as\u00ed como la complejidad de la estructura de la aplicaci\u00f3n.</li> <li>Se podr\u00e1 usar la librer\u00eda common realiza en proyectos anteriores, haciendo uso de JARs.</li> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre <code>pr11java-NOMBRE-collections</code> siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_iii/tema_12/page-1/","title":"1 Interfaces funcionales","text":""},{"location":"bloque_iii/tema_12/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La programaci\u00f3n  imperativa  es  uno  de  los  paradigmas  de  programaci\u00f3n  de computadoras m\u00e1s utilizados. Bajo este paradigma, la programaci\u00f3n se describe en t\u00e9rminos del estado del programa y de sentencias que cambian dicho estado. Java es un lenguaje imperativo, lo que implica que un programa Java est\u00e1 compuesto por una secuencia de instrucciones, que son ejecutadas en el mismo orden en el que se escriben, de manera que al ejecutarla se produce cambios en el estado del programa.</p> <p>Por  su  parte,  la  programaci\u00f3n  funcional  es  un  paradigma  de  programaci\u00f3n alternativo, en el que el resultado de un programa deriva de la aplicaci\u00f3n de distintas funciones a la entrada, sin cambiar el estado interno del programa. En la programaci\u00f3n funcional los bloques principales de construcci\u00f3n de nuestros programas son las funciones y no los objetos.</p> <p>Al aplicar programaci\u00f3n funcional se produce normalmente un c\u00f3digo m\u00e1s corto y m\u00e1s sencillo de entender que aplicando programaci\u00f3n imperativa, ya que es m\u00e1s f\u00e1cil crear abstracciones a trav\u00e9s de funciones que a trav\u00e9s de interfaces.</p> <p>Java siempre fue un lenguaje para programaci\u00f3n imperativa y de hecho las funciones en Java NO son objetos, por lo que una funci\u00f3n no puede pasarse directamente como argumento de otra funci\u00f3n para que se ejecute su c\u00f3digo. Sin embargo, gracias a las interfaces funcionales y a las clases inline an\u00f3nimas pod\u00edamos superar esta limitaci\u00f3n. Pero \u00bfqu\u00e9 es una interfaz funcional?</p>"},{"location":"bloque_iii/tema_12/page-1/#interfaces-funcionales","title":"Interfaces funcionales","text":"<p>Una interfaz funcional es una interfaz que contiene un \u00fanico m\u00e9todo abstracto. Esto no quiere decir que no pueda contener otros m\u00e9todos. De hecho, puede contener:</p> <ul> <li>Otros m\u00e9todos <code>static</code> (Java 8+).</li> <li>Otros m\u00e9todos <code>default</code>  (Java 8+).</li> <li>Otros m\u00e9todos <code>private</code> (Java 9+)</li> <li>M\u00e9todos que sobrescriban m\u00e9todos de la clase <code>Object</code> .</li> </ul> <p>A  la  hora  de  definir  una  interfaz  funcional,  Java  8  proporciona  la  anotaci\u00f3n <code>@FunctionInterface</code>, que informa al compilador de que dicha interfaz es funcional y por tanto tiene un \u00fanico m\u00e9todo abstracto. El objetivo de esta anotaci\u00f3n es que se produzca un error de compilaci\u00f3n si le a\u00f1adimos un segundo m\u00e9todo abstracto a la interfaz. El uso de esta anotaci\u00f3n no se ha establecido como obligatoria para mantener la compatibilidad con el c\u00f3digo ya existente, pero s\u00ed que est\u00e1 recomendada.</p> <p>Una interfaz funcional pura es aquella en la que las clases que la implementan no almacenan ning\u00fan estado, como por ejemplo <code>Comparator</code>. Veamos el m\u00e9todo <code>sort</code> de la interfaz <code>List&lt;E&gt;</code> que recibe un objeto de una clase que implementa la interfaz <code>Comparator</code>: <code>default void sort(Comparator&lt;? super E&gt; c)</code>. El m\u00e9todo utiliza el <code>Comparator</code> para ordenar la lista llamando al m\u00e9todo <code>compare</code> de dicho objeto cada vez que debe comparar dos objetos de la lista. Por lo tanto, debemos crear una clase que implemente <code>Comparator</code> para determinar c\u00f3mo se comparan dos elementos:</p> <pre><code>import java.util.Comparator;\n\npublic class ListOrder implements Comparator&lt;Integer&gt;{\n\n    @Override\n    public int compare(Integer o1, Integer o2){\n        return Integer.compare(o1, o2);\n    }\n}\n</code></pre> <p>As\u00ed, cuando queramos ordenar una lista de enteros har\u00edamos:</p> <pre><code>import java.util.Arrays;\nimport java.util.List;\n\npublic class Main{\n\n    public void show(){\n        List&lt;Integer&gt; list = Arrays.asList(3, 2, 6, 1, 5, 4);\n\n        list.sort(new ListOrder());\n\n        for(Integer i : list){\n            System.out.printf(\" %d \", i);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-1/#implementacion-de-interfaces-funcionales-mediante-clases-inline-anonimas","title":"Implementaci\u00f3n de interfaces funcionales mediante clases inline an\u00f3nimas","text":"<p>El problema del c\u00f3digo anterior es que si esta ordenaci\u00f3n se hace solamente en dicha ocasi\u00f3n, se ha creado la clase <code>ListOrder</code> para un \u00fanico uso. En ese caso, es m\u00e1s conveniente utilizar una clase inline an\u00f3nima:</p> <pre><code>import java.util.Arrays;\nimport java.util.List;\n\npublic class InlineAnonymousClass{\n\n    public void show(){\n        List&lt;Integer&gt; list = Arrays.asList(3, 2, 6, 1, 5, 4);\n\n        list.sort(new Comparator&lt;Integer&gt;(){\n            @Override\n            public int compare(Integer o1, Integer o2){\n                return Integer.compare(o1, o2);\n            }\n        });\n\n        for(Integer i : list){\n            System.out.printf(\" %d \", i);\n        }\n    }\n\n    public static void main(String[] args){\n        new InlineAnonymousClass().show();\n    }\n}\n</code></pre> <p>Lo que estamos haciendo es indicarle al m\u00e9todo <code>sort()</code> el c\u00f3digo que debe ejecutar para comparar dos objetos. Entonces, \u00bfno ser\u00eda m\u00e1s f\u00e1cil que al m\u00e9todo <code>sort()</code> le pudi\u00e9ramos pasar directamente el c\u00f3digo que debe ejecutar? El problema es que en Java las funciones no son objetos, por lo que no pueden ser referenciadas mediante una variable o pasadas directamente como argumento.</p> <p>En realidad, lo que nos interesa es poder establecer tipos funci\u00f3n, es decir, tipos que representen una funci\u00f3n que reciba unos determinados par\u00e1metros de alg\u00fan tipo y que devuelva un valor de retorno de alg\u00fan tipo. Si existieran los tipos funci\u00f3n, podr\u00edamos definir variables o par\u00e1metros de dichos tipos. De hecho hay lenguajes de programaci\u00f3n que tienen tipos funci\u00f3n. En Java, debido a la necesidad de mantener la compatibilidad con versiones anteriores, no existe ninguna sintaxis especial para definir tipos funci\u00f3n sino que se utilizan las interfaces funcionales para representarlos. Dado que una interfaz funcional solo puede tener un \u00fanico m\u00e9todo abstracto, la firma de dicho m\u00e9todo puede ser usado como tipo funci\u00f3n.</p>"},{"location":"bloque_iii/tema_12/page-1/#interfaces-funcionales-puras-predefinidas","title":"Interfaces funcionales puras predefinidas","text":"<p>Java incorpora, a partir de la versi\u00f3n 8, una serie de interfaces funcionales puras predefinidas en el paquete <code>java.util.function</code> para permitir la programaci\u00f3n funcional en Java:</p> <ul> <li><code>Function&lt;T,R&gt;</code>: su m\u00e9todo abstracto es <code>R apply(T t)</code>.</li> <li><code>UnaryOperator&lt;T&gt;</code>: es un caso espec\u00edfico de la interfaz funcional Function, es decir, coinciden el tipo del argumento y el tipo de retorno, por lo que est\u00e1 parametrizada con un \u00fanico tipo. <li><code>BiFunction&lt;T,U,R&gt;</code>: su m\u00e9todo abstracto es <code>R apply(T t,U u)</code>.</li> <li><code>BinaryOperator&lt;T&gt;</code>:es un caso espec\u00edfico  de  la  interfaz  funcional BiFunction en el que coinciden el tipo de los dos argumentos recibidos por el m\u00e9todo apply y el tipo de retorno del mismo. Es por tanto similar a BiFunction. La interfaz funcional  BinaryOperator est\u00e1,  por  tanto, parametrizada con un \u00fanico tipo. <li><code>Predicate&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>boolean test(T t)</code>.</li> <li><code>BiPredicate&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>boolean test(T t,U u)</code>.</li> <li><code>Consumer&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>void accept(T t)</code>.</li> <li><code>BiConsumer&lt;T,U&gt;</code>: su m\u00e9todo abstracto es <code>void accept(T t,U u)</code>.</li> <li><code>Supplier&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>T get()</code>.</li> <p>Veamos un ejemplo utilizando la interfaz funcional <code>BinaryOperator&lt;T&gt;</code></p> ShowBinaryOperatorMainConsola <pre><code>import java.util.function.BinaryOperator;\n\npublic class ShowBinaryOperator{\n\n    public Integer calculate(Integer value1, Integer value2, BinaryOperator&lt;Integer&gt; binaryOperator){\n        return binaryOperation.apply(value1, value2);\n    }\n}\n</code></pre> <pre><code>public class Main2 {\n    public void show(){\n        ShowBinaryOperator binOper = new ShowBinaryOperator();\n\n        System.out.printf(\"12 + 6 = %d\\n\", binOper.calculate(12, 6, new BinaryOperator&lt;Integer&gt;(){\n\n            @Override\n            public Integer apply(Integer t, Integer u){\n                return t + u;\n            }\n        }));\n\n        System.out.printf(\"12 - 6 = %d\\n\", binOper.calculate(12, 6, new BinaryOperator&lt;Integer&gt;(){\n\n            @Override\n            public Integer apply(Integer t, Integer u){\n                return t - u;\n            }\n        }));\n\n        System.out.printf(\"12 / 6 = %d\\n\", binOper.calculate(12, 6, new BinaryOperator&lt;Integer&gt;(){\n\n            @Override\n            public Integer apply(Integer t, Integer u){\n                return t / u;\n            }\n        }));\n\n\n        System.out.printf(\"12 * 6 = %d\\n\", binOper.calculate(12, 6, new BinaryOperator&lt;Integer&gt;(){\n\n            @Override\n            public Integer apply(Integer t, Integer u){\n                return t * u;\n            }\n        }));\n    }\n\n    public static void main(String[] args){\n        new Main2().show();\n    }\n}\n</code></pre> <pre><code>12 + 6 = 18\n12 - 6 = 6\n12 / 6 = 2\n12 * 6 = 72\n</code></pre>"},{"location":"bloque_iii/tema_12/page-1/#interfaces-funcionales-para-tipos-primitivos","title":"Interfaces funcionales para tipos primitivos","text":"<p>Como no podemos usar la parametrizaci\u00f3n de clases e interfaces con los tipos primitivos (limitaci\u00f3n de generics), el paquete <code>java.util.function</code> define tambi\u00e9n una serie de interfaces funcionales similares a las explicadas anteriormente pero espec\u00edficas para los tipos primitivos:</p> <ul> <li>Para el tipo primitivo boolean: <code>BooleanSupplier</code></li> <li>Para  el  tipo  primitivo  double:  <code>DoubleBinaryOperator</code> , <code>DoubleConsumer</code>, <code>DoubleFunction</code>, <code>DoublePredicate</code>, <code>DoubleSupplier</code>, <code>DoubleToIntFunction</code>, <code>DoubleToLongFunction</code>, <code>DoubleUnaryOperator</code>, <code>ToDoubleBiFunction</code>, <code>ToDoubleFunction</code>, <code>ObjDoubleConsumer</code>.</li> <li>Para el tipo primitivo int:  <code>IntBinaryOperator</code>, <code>IntConsumer</code>,  <code>IntFunction</code>, <code>IntPredicate</code>, <code>IntSupplier</code>,  <code>IntToDoubleFunction</code>, <code>IntToLongFunction</code>, <code>IntUnaryOperator</code>, <code>ToIntBiFunction</code>, <code>ToIntFunction</code>, <code>ObjIntConsumer</code>.</li> <li>Para  el  tipo  primitivo  long:  <code>LongBinaryOperator</code> , <code>LongConsumer</code>, <code>LongFunction</code>, <code>LongPredicate</code>,  <code>LongSupplier</code>, <code>LongToDoubleFunction</code>, <code>LongToIntFunction</code>, <code>LongUnaryOperator</code>,  <code>ToLongBiFunction</code>, <code>ToLongFunction</code>, <code>ObjLongConsumer</code>.</li> </ul> <p>Adem\u00e1s, la mayor\u00eda de las interfaces vistas hasta ahora incluyen m\u00e9todos cuyo nombre incluye <code>ToTipo</code> que retornan objetos de interfaces funcionales para tipos primitivos.</p>"},{"location":"bloque_iii/tema_12/page-2/","title":"2 Expresiones lambda","text":""},{"location":"bloque_iii/tema_12/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Con objeto de incorporar a Java funcionalidades propias de la programaci\u00f3n funcional, Java 8 trajo consigo dos nuevas sintaxis para representar interfaces funcionales: expresiones lambda (lambda expressions) y referencias a m\u00e9todo (method references).</p> <p>Una  expresi\u00f3n  lambda  es  una  nueva  sintaxis  con  la  que  representar  la implementaci\u00f3n del m\u00e9todo abstracto de interfaces funcionales indicando adem\u00e1s la lista de par\u00e1metros con sus tipos y el tipo de retorno. De esta manera, podemos escribir el c\u00f3digo de apartados anteriores mediante una expresi\u00f3n lambda, haci\u00e9ndolo mucho m\u00e1s legible.</p> <p>El nuevo operador para las expresiones lambda se denomina operador lambda y tiene la forma de flecha <code>-&gt;</code>. Divide la expresi\u00f3n lambda en dos partes: la parte izquierda especifica los par\u00e1metros necesarios y la parte derecha contiene el cuerpo de la expresi\u00f3n. Este cuerpo puede estar compuesto por una \u00fanica expresi\u00f3n o puede ser un bloque de c\u00f3digo. Cuando es una \u00fanica expresi\u00f3n se denomina lambda de expresi\u00f3n y cuando es un bloque de c\u00f3digo se denomina lambda de bloque.</p> <p>Debemos tener en cuenta que cuando se especifica una expresi\u00f3n lambda, no indicamos  nada  sobre  la  interfaz  funcional  a  la  queremos  aplicarla,  es  decir, dependiendo de donde se est\u00e9 usando la expresi\u00f3n lambda, el compilador deber\u00e1 determinar si la firma de la expresi\u00f3n lambda coincide con la firma del m\u00e9todo abstracto de la correspondiente interfaz funcional. Si la expresi\u00f3n lambda no incluye los tipos de los par\u00e1metros, el compilador tratar\u00e1 de inferirlos a partir de los tipos de los par\u00e1metros del m\u00e9todo abstracto de la interfaz funcional.</p> <p>El ejemplo anterior de la interfaz <code>BinaryOperator&lt;Integer&gt;</code>, si lo realizamos con una expresi\u00f3n lambda, resultar\u00eda de la siguiente manera:</p> <pre><code>public class BinaryOperatorWithLambda{\n    public void show(){\n\n        ShowBinaryOperator binOper = new ShowBinaryOperator();\n\n        System.out.printf(\"12 + 6 = %d\\n\", binOper.calculate(12, 6, (t,u) -&gt; t + u));\n        System.out.printf(\"12 - 6 = %d\\n\", binOper.calculate(12, 6, (t,u) -&gt; t - u));\n        System.out.printf(\"12 / 6 = %d\\n\", binOper.calculate(12, 6, (t,u) -&gt; t / u));\n        System.out.printf(\"12 * 6 = %d\\n\", binOper.calculate(12, 6, (t,u) -&gt; t * u));\n    }\n\n    public static void main(String[] args){\n        new BinaryOperatorWithLambda().show();\n    }\n}\n</code></pre> <p>Veamos el ejemplo de ordenaci\u00f3n de la lista hecho de las dos maneras, con una clase inline an\u00f3nima y con una expresi\u00f3n lambda:</p> <pre><code>import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class LambdaExpression{\n\n    public void show(){\n        List&lt;Integer&gt; list = Arrays.asList(3, 2, 6, 1, 5, 4);\n        list.sort(new Comparator&lt;Integer&gt;(){\n            @Override\n            public int compare(Integer o1, Integer o2){\n                return Integer.compare(o1, o2);\n            }\n        });\n\n        for(Integer i : list){\n            System.out.printf(\" %d \", i);\n        }\n        System.out.println();\n\n        list.sort((o1, o2) -&gt; Integer.compare(o1, o2)); \n\n        for(Integer i : list){\n                System.out.printf(\" %d \", i);\n        }\n    }\n\n    public static void main(String[] args){\n        new LambdaExpression().show();\n    }\n}\n</code></pre> <p>A\u00fan as\u00ed, debemos tener en cuenta que un objeto de una clase inline an\u00f3nima y una expresi\u00f3n lambda no son lo mismo, porque una expresi\u00f3n lambda no crea ninguna clase adicional y adem\u00e1s en una expresi\u00f3n lambda no se puede almacenar ning\u00fan estado, mientras que en una clase an\u00f3nima inline s\u00ed. Un objeto de una clase an\u00f3nima inline genera un archivo de clase independiente durante la compilaci\u00f3n que aumenta el tama\u00f1o del archivo jar. Sin embargo, una expresi\u00f3n lambda se convierte en un simple m\u00e9todo privado. En una lambda, this representa la clase actual desde la que se est\u00e1 usando la lambda. En el caso de una clase an\u00f3nima, this representa ese objeto de la clase an\u00f3nima en particular.</p> <p>Como vemos, las expresiones lambda son muy \u00fatiles para simplificar el c\u00f3digo, pero presentan un problema: para que podamos usar esta nueva sintaxis de expresi\u00f3n lambda es necesario que la interfaz contra la que la usemos sea una interfaz funcional, es decir, que s\u00f3lo contenga un \u00fanico m\u00e9todo abstracto, porque si tuviera por ejemplo dos m\u00e9todos, \u00bfel c\u00f3digo proporcionado mediante la expresi\u00f3n lambda cu\u00e1ndo se deber\u00eda ejecutar, cuando se ejecute uno o cuando se ejecute el otro? Por este motivo las expresiones lambda solo se pueden usar con interfaces funcionales.</p> <p>Se puede almacenar una expresi\u00f3n lambda en una variable cuyo tipo corresponda a una interfaz funcional compatible con dicha lambda, es decir, cuya firma del m\u00e9todo abstracto de la interfaz sea compatible con la expresi\u00f3n lambda. Por ejemplo:</p> <pre><code>Comparator&lt;Integer&gt; comparador = (o1, o2) -&gt; Integer.compare(o1, o2);\nBinaryOperator&lt;Integer&gt; operacionBinaria = (o1, o2) -&gt; o1 + o2;\n</code></pre>"},{"location":"bloque_iii/tema_12/page-2/#sintaxis-de-la-expresion-lambda","title":"Sintaxis de la expresi\u00f3n lambda","text":"<p>Veamos la sintaxis de la expresi\u00f3n lambda:</p> <pre><code>(tipo param1, tipo param2, ...) -&gt; {\n    // instrucciones\n    return valorRetorno;\n}\n</code></pre> <p>Podemos omitir el tipo de dato de cada par\u00e1metro siempre y cuando el compilador pueda inferirlos (deducirlos) a partir del context, es decir, a partir de los tipos de los par\u00e1metros del m\u00e9todo abstracto de la interfaz funcional para la que se est\u00e1 usando.</p> <p>El cuerpo de las expresiones lambda puede contener los mismos tipos de sentencias que cualquier otra funci\u00f3n, como sentencias condicionales, iterativas o <code>try catch</code>.</p> <p>Si se espec\u00edfica un \u00fanico par\u00e1metro y no se espec\u00edfica el tipo de \u00e9ste sino que es inferido, podemos omitir los par\u00e9ntesis. Por ejemplo:</p> <pre><code>x -&gt; x + x;\n</code></pre> <p>Si no se espec\u00edfica ning\u00fan par\u00e1metro, es obligatorio poner los par\u00e9ntesis. Por ejemplo:</p> <pre><code>() -&gt; System.out.println(\"Hola mundo\");\n</code></pre> <p>En el cuerpo podemos omitir las las llaves si \u00e9ste contiene una \u00fanica expresi\u00f3n o una \u00fanica sentencia que no retorna valor. Si el cuerpo contiene una \u00fanica expresi\u00f3n, \u00e9sta ser\u00e1 evaluada y la expresi\u00f3n lambda retornar\u00e1 el valor obtenido.</p> <p>Si el cuerpo contiene m\u00e1s de una sentencia y la expresi\u00f3n lambda debe retornar un valor, entonces debemos usar una sentencia <code>return valor</code>.</p> <p>Si el cuerpo contiene una sentencia <code>return valor</code>, forzosamente debemos poner las llaves, incluso si el cuerpo contiene una \u00fanica sentencia, ya que <code>return</code>no es un expresi\u00f3n.</p> <p>Un expresi\u00f3n lambda se puede usar como argumento de un par\u00e1metro de tipo interfaz funcional y como valor de retorno de una funci\u00f3n cuyo tipo de retorno sea una interfaz funcional. sin embargo habr\u00e1 ocasiones donde debamos realizar un cast expl\u00edcitamente para indicar la interfaz funcional a la que queremos aplicar una determinada expresi\u00f3n lambda.</p>"},{"location":"bloque_iii/tema_12/page-2/#ambito-de-una-expresion-lambda","title":"\u00c1mbito de una expresi\u00f3n lambda","text":"<p>Una expresi\u00f3n lambda puede acceder a las variables <code>static</code> definidas en el \u00e1mbito en el que la expresi\u00f3n lambda es usada. Tambi\u00e9n puede acceder a las variables locales pero que sean eficazmente finales, es decir, variables cuyo valor no cambia una vez asignado. Estas variables no tienen necesariamente que estar definidas como <code>final</code>. Una expresi\u00f3n lambda tambi\u00e9n tiene acceso a <code>this</code>, lo que hace referencia a la instancia de invocaci\u00f3n de la clase contenedora de la expresi\u00f3n lambda.</p> <p>Si en el cuerpo de una expresi\u00f3n lambda con m\u00e1s de una sentencia definimos una variable local, debemos tener en cuenta que dicha variable tendr\u00e1 como \u00e1mbito el correspondiente a donde se ha definido la expresi\u00f3n lambda, ya que la expresi\u00f3n lambda no define su propio \u00e1mbito independiente. Si ya existiera una variable con el mismo nombre en dicho \u00e1mbito se producir\u00eda un error de compilaci\u00f3n. Por ejemplo:</p> <pre><code>int z = 2;\nBinaryOperator&lt;Integer&gt; operacion = (x, y) -&gt; {\n    int z = 4; //(1)!\n    System.out.println(x + z);\n}\n</code></pre> <ol> <li>\u00a1ERROR! z ya est\u00e1 definida en el \u00e1mbito</li> </ol> <p>Una expresi\u00f3n lambda puede generar una excepci\u00f3n. No obstante, si genera una excepci\u00f3n comprobada, esta tendr\u00e1 que ser compatible con la excepci\u00f3n (o excepciones) indicadas en la cl\u00e1usula <code>throws</code> del m\u00e9todo abstracto de la interfaz funcional. Veamos un ejemplo:</p> InterfazMain <pre><code>public interface FunctionalInterface{\n    int ioAction() throws Exception;\n}\n</code></pre> <pre><code>public class LambdaException{\n    public void show(){\n        FunctionalInterface fi = () -&gt; {\n            Scanner keyboard = new Scanner(System.in);\n            int num = keyboard.nextInt();\n            return num;\n        };\n\n\n        try{\n            System.out.printf(\"Introduce un n\u00famero: \");\n            System.out.println(method(fi));\n        } catch (Exception e){\n            System.out.println(\"Error en la lectura\");\n        }\n    }\n\n    public int method(FunctionalInterface fi) throws Exception{\n        return fi.ioAction();\n    }\n\n    public static void main(String[] args){\n        new LambdaException().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-2/#limitaciones-de-las-expresiones-lambda","title":"Limitaciones de las expresiones lambda","text":"<p>El c\u00f3digo de una expresi\u00f3n lambda se convierte en el c\u00f3digo del m\u00e9todo abstracto de la interfaz funcional que implementa. or tanto, las expresiones lambda no sirven para sobrescribir la implementaci\u00f3n por defecto de un m\u00e9todo default de la interfaz, sino que debe tratarse de un m\u00e9todo abstracto. De hecho si la interfaz solo tiene un m\u00e9todo default, no ser\u00e1 considerada una interfaz funcional. Si nos vemos en la obligaci\u00f3n de sobrescribir un m\u00e9todo default de una interfaz, entonces tendremos que usar una clase an\u00f3nima inline.</p> <p>Por otro lado, una expresi\u00f3n j*lambda* no es consciente de qu\u00e9 interfaz funcional concreta est\u00e1 implementando, por lo que no puede llamar a su vez a m\u00e9todos privados ni default de la interfaz.</p> <p>Finalmente, las expresiones lambda no pueden usarse con clases abstractas que tengan un \u00fanico m\u00e9todo abstracto, solo se pueden usar con interfaces funcionales.</p>"},{"location":"bloque_iii/tema_12/page-2/#referencias-a-metodo","title":"Referencias a m\u00e9todo","text":"<p>Una referencia de m\u00e9todo (method reference) es una abreviaci\u00f3n de la lambda y se da siempre y cuando es una expresi\u00f3n de una \u00fanica l\u00ednea y los par\u00e1metros que se le pasa a la lambda son utilizados en la expresi\u00f3n.</p> <p>Una referencia de m\u00e9todo permite hacer referencia a un m\u00e9todo sin ejecutarlo. Al evaluar una referencia de m\u00e9todo, tambi\u00e9n se crea una instancia de una interfaz funcional.</p> <ul> <li>Sintaxis para m\u00e9todos est\u00e1ticos: <code>NombreClase::nombreM\u00e9todo</code><ul> <li><code>v -&gt; Math.sqrt(v)</code> equivaldr\u00eda a <code>Math::sqrt</code></li> <li><code>(o1, o2) -&gt; Integer.compare(o1, o2)</code> equivaldr\u00eda a <code>Integer::compare</code></li> </ul> </li> <li>Sintaxis para m\u00e9todos de instancia: <code>refObj::nombreM\u00e9todo</code><ul> <li><code>persona -&gt; persona.getNombre()</code> equivaldr\u00eda a <code>Persona::getNombre</code></li> <li><code>n -&gt; System.out.println(n)</code> equivaldr\u00eda <code>System.out::println</code></li> <li><code>(cadena1, cadena2) -&gt; cadena1.compareToIgnoreCase(cadena2)</code> equivaldr\u00eda a <code>String::compareToIgnoreCase</code>: en este caso, el primer par\u00e1metro de la expresi\u00f3n lambda es quien ejecuta el m\u00e9todo y el resto de par\u00e1metros se pasan como argumentos en la llamada.</li> <li><code>empleado -&gt; jefe.comparaSalarioCon(empleado)</code> equivaldr\u00eda a <code>jefe::comparaSalarioCon</code>: en este caso, un objeto ajeno a la expresi\u00f3n lambda es quien ejecuta el m\u00e9todo y dicho m\u00e9todo recibe como argumento el (o los) par\u00e1metro(s) de la expresi\u00f3n lambda.</li> <li><code>() -&gt; new TreeMap&lt;&gt;()</code> equivaldr\u00eda a <code>TreeMap::new</code>: este tipo se conoce como referencia a constructor, que emplearemos cuando queramos que se llame al m\u00e9todo constructor de una clase.</li> <li><code>i -&gt; new int[i]</code> equivaldr\u00eda a <code>int[]::new</code>: en este caso, lo que queremos es que se llame al constructor de un array.</li> </ul> </li> <li>Sintaxis para m\u00e9todos gen\u00e9ricos:<ul> <li>Est\u00e1ticos: <code>NombreClase::&lt;T&gt;nombreM\u00e9todo</code></li> <li>M\u00e9todos de instancia: <code>refObj::&lt;T&gt;nombreM\u00e9todo</code></li> </ul> </li> </ul>"},{"location":"bloque_iii/tema_12/page-3/","title":"3 Alguna interfaces funcionales","text":""},{"location":"bloque_iii/tema_12/page-3/#consumer-y-biconsumer","title":"Consumer y BiConsumer","text":"<ul> <li><code>Consumer&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>void accept(T t)</code>.</li> <li><code>BiConsumer&lt;T, U&gt;</code>: su m\u00e9todo abstracto es <code>void accept(T t, U u)</code>.</li> </ul> <p>La interfaz <code>Consumer</code>  es empleada por el m\u00e9todo <code>forEach(Consumer&lt;T&gt; action)</code> de la interfaz <code>Iterable</code>, que ejecuta la acci\u00f3n indicada sobre cada elemento del iterable.</p> <pre><code>import java.util.List; \npublic class InterfaceConsumer {\n    public void show() {\n        List&lt;Integer&gt; list = List.of(3, 2, 6, 1, 5, 4);\n        list.forEach(System.out::println); // num -&gt; System.out.println(num)\n    }     \n\n    public static void main(String[] args) { \n        new InterfaceConsumer().show();     \n    } \n}\n</code></pre> <p>En este ejemplo, se ejecuta la acci\u00f3n de mostrar por consola una l\u00ednea con cada elemento de la lista.</p> <p>La interfaz funcional <code>BiConsumer</code> es similar a <code>Consumer</code> pero su m\u00e9todo recibe dos argumentos, uno de tipo <code>T</code>  y otro de tipo <code>U</code> y no retorna nada: <code>void accept(T t, U u)</code></p> <pre><code>import java.util.HashMap;\nimport java.util.Map; \npublic class InterfaceBiConsumer {     \n    public void show() {         \n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n\n        for (int i = 0; i &lt; 5; i++) {\n            map.put(i, i * i);\n        }\n        map.forEach((k, v) -&gt; System.out.printf(\"Clave:%d Valor:%d\\n\", k, v));\n    }     \n\n    public static void main(String[] args) {         \n        new InterfaceBiConsumer().show();\n    }\n}\n</code></pre> <p>La  interfaz  funcional  <code>Consumer</code>   posee  un  m\u00e9todo  default  llamado <code>andThen(Consumer&lt;T&gt; after)</code> que llama al m\u00e9todo <code>accept</code> del consumidor recibido despu\u00e9s de haber llamado a su propio <code>accept</code>. Gracias a este m\u00e9todo, podemos tener una serie de objetos <code>Consumer</code> predefinidos y encadenarlos de la forma que nos interese.Veamos un ejemplo:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Consumer;\n\npublic class ConsumerAndThen{\n    public void show(){\n        List&lt;Integer&gt; list = List.of(3, 2, 6, 1, 5, 4);\n        List&lt;Integer&gt; listCopy = new ArrayList&lt;&gt;();\n        Consumer&lt;Integer&gt; copy = listCopy::add; // (value) -&gt; listCopy.add(value);\n        Consumer&lt;Integer&gt; show = System.out::println; // (value) -&gt; System.out.println(value);\n\n        list.forEach(copy.andThen(show));\n        listCopy.foreach(show);\n    }\n\n    public static void main(String[] args){\n        new ConsumerAndThen().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-3/#predicate-y-bipredicate","title":"Predicate y BiPredicate","text":"<ul> <li><code>Predicate&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>boolean test(T t)</code>.</li> <li><code>BiPredicate&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>boolean test(T t, U u)</code>.</li> </ul> <p>Las interfaces funcionales  <code>Predicate</code>  y  <code>BiPredicate</code>  poseen m\u00e9todos default que retornan un nuevo objeto que implementa la misma interfaz y que permiten componer predicados  mediante  operaciones  l\u00f3gicas,  como  <code>or(otherPredicate)</code>, <code>and(otherPredicate)</code> o <code>negate(otherPredicate)</code>. El orden en el que se ejecutar\u00e1n ser\u00e1n el orden en el que aparecen en la composici\u00f3n, es decir, no existe una prioridad preestablecida como con los operadores l\u00f3gicos.</p> <p>Veamos un ejemplo utilizando el m\u00e9todo <code>removeIf</code> de la interfaz <code>Collection</code> que recibe un Predicate por par\u00e1metro:  <code>default  boolean  removeIf(Predicate&lt;?  super  E&gt; filter)</code>. Dicho m\u00e9todo elimina de la colecci\u00f3n aquellos elementos que cumplan el Predicate:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class PredicateComposition{\n\n    public void show(){\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(3, 2, 6, 1, 5, 4));\n        Predicate&lt;Integer&gt; esPar = n -&gt; n % 2 == 0;\n        Predicate&lt;Integer&gt; mayorQue3 = n -&gt; n &gt; 3;\n        list.removeIf(esPar.and(mayorQue3));\n        list.forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new PredicateComposition().show();\n    }\n}\n</code></pre> <p>La interfaz <code>Predicate</code> tiene tambi\u00e9n un m\u00e9todo est\u00e1tico factor\u00eda <code>PredicateIsEqual(Object o)</code> que retorna el predicado correspondiente a comprobar si un elemento es igual que otro objeto. Internamente simplemente se llamar\u00e1 al m\u00e9todo <code>equals</code>:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class PredicateIsEqual{\n    public void show(){\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(3, 2, 6, 1, 5, 4));\n        list.removeIf(Predicate.isEqual(5));\n        list.forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new PredicateIsEqual().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-3/#function","title":"Function","text":"<p><code>Function&lt;T,R&gt;</code>: su m\u00e9todo abstracto es <code>R apply(T t)</code>. Veamos un ejemplo de utilizaci\u00f3n en el m\u00e9todo<code>computeIfAbsent</code>de los mapas:</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\npublic class InterfaceFunction{\n    public void show(){\n        Function&lt;Integer, Integer&gt; elevarAlCuadrado = n -&gt; n * n;\n\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n\n        for(int i = 0; i &lt; 10; i++){\n            map.computeIfAbsent(i, elevarAlCuadrado);\n        }\n\n        map.forEach((k,v) -&gt; System.out.printf(\"Clave:%d Valor:%d\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new InterfaceFunction().show();\n    }\n}\n</code></pre> <p>La interfaz funcional <code>Function</code> posee un m\u00e9todo default llamado <code>andThen(afterFunction)</code> que permite que despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo <code>apply</code> de la function original, su resultado se pase como valor de entrada del m\u00e9todo <code>apply</code> del objeto <code>Function</code> pasado como argumento, retornado el objeto <code>Function</code> correspondiente a la cadena de operaciones de transformaci\u00f3n. Veamos un ejemplo:</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\npublic class FunctionAndThen{\n    public void show(){\n        Function&lt;Integer, Integer&gt; elevarAlCuadrado = n -&gt; n * n;\n        Function&lt;Integer, String&gt; aCadena = String::valueOf; // value -&gt; String.valueOf(value)\n        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n\n        for(int i = 0; i &lt; 10; i++){\n            map.computeIfAbsent(i, elevarAlCuadrado.andThen(aCadena));\n        }\n\n         map.forEach((k,v) -&gt; System.out.printf(\"Clave:%d Valor:%d\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new FunctionAndThen().show();\n    }\n}\n</code></pre> <p>Muy parecido al anterior es el m\u00e9todo default <code>compose(beforeFunction)</code> que primero ejecuta el m\u00e9todo <code>apply</code> del objeto <code>Function</code> recibe y despu\u00e9s el m\u00e9todo <code>apply</code> del objeto <code>Function</code> original, es decir, se ejecutan en orden inverso al de <code>andThen</code>. Gracias a estos dos m\u00e9todos, podemos tener una serie de objetos <code>Function</code>predefinidos y encadenarlos de la forma que nos interese.</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\npublic class FunctionCompose{\n    public void show(){\n        Function&lt;Integer, Integer&gt; elevarAlCuadrado = n -&gt; n * n;\n        Function&lt;Integer, String&gt; aCadena = String::valueOf; // value -&gt; String.valueOf(value)\n        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n\n        for(int i = 0; i &lt; 10; i++){\n            map.computeIfAbsent(i, aCadena.compose(elevarAlCuadrado));\n        }\n\n         map.forEach((k,v) -&gt; System.out.printf(\"Clave:%d Valor:%d\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new FunctionCompose().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-3/#comparator","title":"Comparator","text":"<p>La interfaz funcional <code>Comparator</code> (comparador) contiene el m\u00e9todo abstracto <code>int compare(T o1, T o2)</code> que recibe dos valores de tipo <code>T</code> y retorna un entero que vale:</p> <ul> <li>0 si o1 es igual a o2.</li> <li>Menor que 0 si o1 es menor que o2.</li> <li>Mayor que 0 si o1 es mayor que o2.</li> </ul> <p>La interfaz <code>Comparator</code> ya exist\u00eda en Java 7 y de hecho no se encuentra en el paquete <code>java.util.function</code>, sino directamente en <code>java.util</code>. Esta interfaz posee una serie de m\u00e9todos est\u00e1ticos factor\u00eda que retornan objetos <code>Comparator</code> correspondientes a los casos m\u00e1s habituales de comparaci\u00f3n:</p> <ul> <li> <p><code>static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalOrder()</code>: devuelve un objeto <code>Comparator</code> para ordenar por el orden natural. Pero, \u00bfqu\u00e9 considera Java como orden natural? El orden indicado en la implementaci\u00f3n de <code>Comparable</code>.</p> <pre><code>import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class NaturalOrder{\n    public void show(){\n        List&lt;Integer&gt; list = Arrays.asList(3, 2, 6, 1, 5, 4);\n        list.sort(Comparator.naturalOrder());\n        list.forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new NaturalOrder().show();\n    }\n}\n</code></pre> </li> <li> <p><code>static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder()</code>: ordena por el orden natural inverso:</p> <pre><code>import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class ReverseOrder{\n    public void show(){\n        List&lt;Integer&gt; list = Arrays.asList(3, 2, 6, 1, 5, 4);\n        list.sort(Comparator.reverseOrder());\n        list.forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new ReverseOrder().show();\n    }\n}\n</code></pre> </li> <li> <p><code>static &lt;T&gt; Comparator&lt;T&gt; nullsFirst(Comparator&lt;? super T&gt; comparator)</code>: recibe un comparador y retorna un nuevo comparador seg\u00fan el cual los elementos <code>null</code> preceder\u00e1n a los que no lo sean, que ser\u00e1n ordenados atendiendo al comparador recibido. Tambi\u00e9n tenemos <code>nullsLast</code>, similar al anterior pero los elementos que sean <code>null</code>se sit\u00faan al final.</p> <pre><code>import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class NullsFirst{\n    public void show(){\n        List&lt;Integer&gt; list = Arrays.asList(3, 2, null, 6, 1, 5, 4, null);\n\n        list.sort(Comparator.nullsFirst(Comparator.naturalOrder()));\n        System.out.println(\"nullsFirst: \");\n        list.forEach(System.out::println);\n\n        list.sort(Comparator.nullsLast(Comparator.naturalOrder()));\n        System.out.println(\"nullsLast: \");\n        list.forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new ReverseOrder().show();\n    }\n}\n</code></pre> </li> <li> <p><code>static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T, ? extends U&gt; keyExtractor)</code>: recibe una funci\u00f3n que debe retornar el valor por el que debe comparar el comparador retornado. Este m\u00e9todo es muy \u00fatil si queremos ordenar una lista de objetos por un determinado campo.</p> VehicleMainConsola <pre><code>public class Vehicle {     \n    private String registration;\n    private int wheelCount;\n    private double speed;\n    private String colour;\n\n    public Vehicle(String registration, int wheelCount, String colour) {\n            this.registration = registration;\n            this.wheelCount = wheelCount;\n            this.colour = colour;\n            speed = 0;\n    }\n\n    public int getWheelCount() {\n        return wheelCount;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }     \n\n    public String getColour() {\n        return colour;\n    }     \n\n    public void setColour(String colour) {\n        this.colour = colour;\n    }     \n\n    public String getRegistration() {\n        return registration;\n    }     \n\n    public void accelerate(double amount) {\n        speed += amount;\n    }     \n\n    public void brake(double amount) {\n        speed -= amount;\n    }     \n\n    @Override\n    public String toString() {\n        return \"Vehicle [registration=\" + registration + \", wheelCount=\" + wheelCount + \", speed=\" + speed + \", colour=\" + colour + \"]\";\n    } \n}\n</code></pre> <pre><code>public class Comparing{\n    public void show(){\n        List&lt;Vehicle&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\n        list.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        list.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        list.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        list.add(new Vehicle(\"3495JZA\", 2, \"blanco\"));\n        list.add(new Vehicle(\"5930POI\", 2, \"negro\"));\n\n        list.sort(Comparator.comparing(Vehicle::getColour));\n        list.forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new Comparing().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=blanco]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Hay versiones de este m\u00e9todo est\u00e1tico factor\u00eda para cuando el valor por que se debe ordenar es de un tipo primitivo, como <code>comparingInt</code>, <code>comparingLong</code> o <code>comparingDouble</code></p> </li> </ul> <p>La interfaz funcional <code>Comparator</code> tambi\u00e9n incorpora una serie de m\u00e9todos default que nos permiten encadenar comparadores:</p> <ul> <li> <p><code>default Comparator&lt;T&gt; reversed()</code>: sirve para obtener el orden inverso al del comparador original.</p> MainConsola <pre><code>public class Reversed{\n    public void show(){\n        List&lt;Vehicle&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\n        list.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        list.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        list.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        list.add(new Vehicle(\"3495JZA\", 2, \"blanco\"));\n        list.add(new Vehicle(\"5930POI\", 2, \"negro\"));\n\n        list.sort(Comparator.comparing(Vehicle::getColour).reversed());\n        list.forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new Reversed().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=blanco]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\n</code></pre> <ul> <li><code>default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing(Function&lt;? super T, ? extends U&gt; keyExtractor)</code>: recibe una funci\u00f3n con la que indica el valor por el que comparar si con el comparador original los elementos son iguales:</li> </ul> MainConsola <pre><code>public class ThenComparingFunction{\n    public void show(){\n        List&lt;Vehicle&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\n        list.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        list.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        list.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        list.add(new Vehicle(\"3495JZA\", 2, \"blanco\"));\n        list.add(new Vehicle(\"5930POI\", 2, \"negro\"));\n\n        list.sort(Comparator.comparing(Vehicle::getColour).thenComparing(Vehicle::getWheelCount));\n        list.forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new Reversed().show();\n    }\n}\n</code></pre> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=blanco]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> </li> </ul> <p>Existen versiones espec\u00edficas de este m\u00e9todo para cunado la funci\u00f3n retorna un tipo primitivo, como <code>thenComparingInt</code>, <code>thenComparingLong</code> y <code>thenComparingDouble</code>.</p>"},{"location":"bloque_iii/tema_12/page-4/","title":"4 Optional","text":""},{"location":"bloque_iii/tema_12/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>La clase <code>Optional&lt;T&gt;</code> es un wrapper alrededor de un valor que puede estar presente o no. El objetivo de esta clase es servir b\u00e1sicamente como tipo de retorno de aquellos m\u00e9todos que pueden retornar una valor o no.</p> <p>Por ejemplo, supongamos que queremos realizar un m\u00e9todo que retorne la posici\u00f3n en la que se encuentra un determinado elemento de una lista de enteros. La pregunta que inmediatamente nos har\u00edamos como desarrolladores ser\u00eda, \u00bfqu\u00e9 debo hacer si el elemento a buscar, que ha sido pasado como argumento del m\u00e9todo, no se encuentra en la lista? Debo lanzar una excepci\u00f3n? No puedo retornar <code>false</code> porque el m\u00e9todo retorna un entero. \u00bfDebo retornar un valor especial como por ejemplo <code>-1</code>?\u00bfRetorno como valor especial del valor <code>null</code>?</p> <p>Tradicionalmente los desarrolladores han resulto esta situaci\u00f3n de distintas maneras y todas tienen sus inconvenientes. Por un lado, lanzar una excepci\u00f3n parece excesivo porque no es un error del programa y al cliente del m\u00e9todo simplemente hay que informarle de alguna manera de que no se ha encontrado el elemento.</p> <p>Por otra parte, retornar un valor especial tiene el inconveniente que de que obliga a que el cliente conozca dicho valor especial y adem\u00e1s debe acordarse de comprobar que el valor retornada no es el valor especial si quiere usarlo. En cierta manera estamos d\u00e1ndolo al cliente la responsabilidad de la comprobaci\u00f3n pero no estamos oblig\u00e1ndola a ello. La consecuencia es que si el desarrollador del c\u00f3digo cliente olvida realizar la comprobaci\u00f3n, estar\u00e1 usando un valor no v\u00e1lido. Este hecho se convierte en m\u00e1s peligroso a\u00fan si el valor retornado es <code>null</code>, porque si olvida realizar la comprobaci\u00f3n y m\u00e1s adelante en el c\u00f3digo se trata de acceder a una propiedad del objeto retornado por el m\u00e9todo, se producir\u00eda una excepci\u00f3n <code>NullPointerException</code>.</p> <p>Entonces, \u00bfcu\u00e1l es la soluci\u00f3n? La soluci\u00f3n propuesta por Java 8 es que el m\u00e9todo no retorne directamente un objeto de clase <code>T</code>, sino un <code>Optional&lt;T&gt;</code>. La ventaja de esta soluci\u00f3n es que si el c\u00f3digo cliente quiere acceder al objeto real debe forzosamente comprobar si el Optional tiene un valor presente o no, de manera que pueda extraerse.</p> <p>Es muy importante resaltar que no es posible tener un Optional cuyo valor contenido sea null.</p>"},{"location":"bloque_iii/tema_12/page-4/#construccion","title":"Construcci\u00f3n","text":"<p>La clase <code>Optional&lt;T&gt;</code> es una clase inmutable, por lo que no proporciona m\u00e9todos setter que permitan cambiar el valor que contiene. Adem\u00e1s el proceso de construcci\u00f3n de un Optional no se realizar a trav\u00e9s de un constructor, sino usando alguno de los m\u00e9todos est\u00e1ticos factor\u00eda que se indican a continuaci\u00f3n.</p> <ul> <li><code>static &lt;T&gt; Optional&lt;T&gt; empty()</code>: retorna un Optional que no contiene valor.</li> <li><code>static &lt;T&gt; Optional&lt;T&gt; of(T value)</code>: retorna un Optional que contiene un valor pasado como argumento. Si tratamos de pasar el valor <code>null</code> a dicho m\u00e9todo se producir\u00e1 una excepci\u00f3n.</li> <li><code>static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code>: retorna un Optional que contiene el valor pasado como argumento. A diferencia del m\u00e9todo anterior, si tratamos de pasar el valor <code>null</code>, el m\u00e9todo retorna un Optional vac\u00edo.</li> </ul> <pre><code>import java.util.Optional;\n\npublic class Construction{\n    public void show(){\n        Optional&lt;Integer&gt; optional1 = Optional.empty(); //(1)!\n        System.out.println(optional1);\n\n        Optional&lt;Integer&gt; optional2 = Optional.of(1000); //(2)!\n        System.out.println(optional2);\n\n        Optional&lt;Integer&gt; optional3 = Optional.ofNullable(methodWhichCanReturnNull(5)); //(3)!\n        System.out.println(optional3);\n\n        Optional&lt;Integer&gt; optional4 = Optional.ofNullable(methodWhichCanReturnNull(2));\n        System.out.println(optional4); \n\n        Optional&lt;Integer&gt; optional5;\n        try {\n            optional5 = Optional.of(null);\n            System.out.println(optional5);\n        } catch (NullPointerException e) {\n            System.out.println(\"Se ha lanzado la excepci\u00f3n NullPointerException\");\n        }       \n    }\n\n    public static Integer methodWhichCanReturnNull(int num){        \n        if (num &gt;= 5) {\n            return num;\n        } else {\n            return null;\n        }     \n    }\n\n    public static void main(String[] args) {\n        new Construction().show();     \n    }\n}\n</code></pre> <ol> <li>Crea un optional sin valor.</li> <li>Crea un optional con valor 1000</li> <li>Retorna un Optional vac\u00edo si el valor pasado como argumento es null:</li> </ol>"},{"location":"bloque_iii/tema_12/page-4/#igualdad","title":"Igualdad","text":"<p>Podemos comparar los valores de dos Optional con el m\u00e9todo <code>boolean equals(Object obj)</code>: compara los valores de los dos Optional. Dos Optional vac\u00edos de distinto tipo son considerados iguales:</p> <pre><code>import java.util.Optional; \n\npublic class Equality {     \n    public void show() {         \n        Optional&lt;Integer&gt; optional1 = Optional.of(1000); //Crea un optional con valor 1000\n        Optional&lt;Integer&gt; optional2 = Optional.of(1000);\n        Optional&lt;Integer&gt; optional3 = Optional.empty();\n        Optional&lt;String&gt; optional4 = Optional.empty();         \n\n        System.out.println(optional1.equals(optional2)); //Comprueba  si tienen el mismo valor: true\n\n        System.out.println(optional1 == optional2); //Comprueba si son  el mismo objeto: false\n\n        System.out.println(optional3.equals(optional4));//Dos Optional  vac\u00edos de distinto tipo son considerados iguales: true\n\n        System.out.println(optional3.equals(null));//False     \n    }     \n\n    public static void main(String[] args) { \n        new Equality().show();     \n    } \n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-4/#procesamiento","title":"Procesamiento","text":"<p>Supongamos que queremos usar el m\u00e9todo est\u00e1tico <code>Collections.max(collection)</code> que retorna el valor m\u00e1ximo contenido en una colecci\u00f3n:</p> <pre><code>// Suponiendo que list es una colecci\u00f3n de enteros\nInteger max = Collections.max(list);\n</code></pre> <p>Pero \u00bfqu\u00e9 ocurre si la colecci\u00f3n est\u00e1 vac\u00eda? En este caso el m\u00e9todo <code>max()</code> lanzar\u00e1 la excepci\u00f3n <code>NoSuchElementException</code>. \u00bfCu\u00e1l es el problema? Que el cliente debe mirar la documentaci\u00f3n para enterarse de ello y capturar la excepci\u00f3n o de lo contrario producir\u00e1 un error en tiempo de ejecuci\u00f3n. Est\u00e1 obligando a darse cuenta de que debe hacer:</p> <pre><code>try{\n    Integer max = Collections.max(list);\n} catch(NoSuchElementException e){\n    // ...\n}\n</code></pre> <p>\u00bfY si existiera una forma de indicar que el valor de retorno de una funci\u00f3n es opcional? Pues bien, Java 8 introdujo para este problema la clase <code>Optional&lt;T&gt;</code>.</p> <p>La clase <code>Optional&lt;T&gt;</code> es una clase parametrizada que representa la abstracci\u00f3n de un valor de retorno opcional. As\u00ed, podr\u00edamos codificar nuestro m\u00e9todo anterior haciendo que retorno un <code>Optional&lt;T&gt;</code> en vez de lanzar una excepci\u00f3n en el caso de que la colecci\u00f3n est\u00e9 vac\u00eda:</p> <pre><code>public static &lt;T extends Comparable&lt;T&gt;&gt; Optional&lt;T&gt; max(Collection &lt;? extends T&gt; coll){\n    try{\n        return Optional.of(Collections.max(coll));\n    } catch(NoSuchElementException){\n        return Optional.empty();\n    }\n}\n</code></pre> <p>En ese caso, cuando el cliente llame a este m\u00e9todo estar\u00e1 obligado a tratar el hecho de que puede que no se retorne un valor. No tiene que mirar la documentaci\u00f3n ni recordar hacer ning\u00fan tipo de comprobaci\u00f3n porque el tipo de terno es <code>Optional&lt;T&gt;</code>, de manera que si de verdad quiere obtener el valor, va a tener que comprobar si el Optional tiene o no valor.</p> <pre><code>Optional&lt;Integer&gt; maxOpt = max(list);\n</code></pre> <p>Veamos m\u00e1s m\u00e9todos de Optional:</p> <ul> <li><code>T get()</code>: si un valor est\u00e1 presente, devuelve el valor, de lo contrario lanza la excepci\u00f3n NoSuchElementException.</li> <li> <p><code>boolean isPresent()</code>: si un valor est\u00e1 presente, devuelve true, en caso contrario false.</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Optional; \n\npublic class GetAndIsPresent {     \n\n    public void show() {         \n        List&lt;Integer&gt; list1 = List.of(3, 2, 6, 1, 5, 4);\n        List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\n\n        Optional&lt;Integer&gt; maximumOptional1 = max(list1);\n        Optional&lt;Integer&gt; maximumOptional2 = max(list2);\n        Integer maximum1 = 0, maximum2;    \n\n        if (maximumOptional1.isPresent()) {\n            maximum1 = maximumOptional1.get();\n        }\n\n        System.out.println(maximumOptional1);//Optional[6]\n\n        System.out.println(maximum1);//6         \n\n        maximum2 = maximumOptional2.isPresent() ? maximumOptional2.get() : 0;\n\n        System.out.println(maximumOptional2);//Optional.empty\n\n        System.out.println(maximum2);//0     \n\n    }     \n\n    public static &lt;T extends Comparable&lt;T&gt;&gt; Optional&lt;T&gt; max(Collection&lt;? extends T&gt; coll) {\n        try {\n            return Optional.of(Collections.max(coll));\n        } catch (NoSuchElementException e) {\n            return Optional.empty();\n        }\n    } \n\n    public static void main(String[] args) {         \n        new GetAndIsPresent().show();     \n    } \n}\n</code></pre> </li> <li> <p><code>T orElse(T other)</code>: si un valor est\u00e1 presente, devuelve el valor, de lo contrario devuelve el valor suministrado como argumento</p> </li> <li><code>T orElseGet(Supplier&lt;? extends T&gt; supplier)</code>: si hay un valor, devuelve el valor,  en  caso  contrario  devuelve  el  resultado  producido  por  la  funci\u00f3n suministradora.</li> <li><code>T orElseThrow()</code>: si un valor est\u00e1 presente, devuelve el valor, de lo contrario lanza la excepci\u00f3n NoSuchElementException.</li> <li> <p><code>&lt;X extends Throwable&gt; T orElseThrow(Suppler&lt;? extends X&gt; exceptionSupplier) throws x</code>: si hay un valor, devuelve el valor, en caso contrario, lanza una excepci\u00f3n producida por la funci\u00f3n suministradora.</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.Random;\n\npublic class OrElse {     \n\n    public void show() {         \n        List&lt;Integer&gt; list1 = List.of(3, 2, 6, 1, 5, 4);\n        List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\n        Optional&lt;Integer&gt; maximumOptional1 = max(list1);\n        Optional&lt;Integer&gt; maximumOptional2 = max(list2);\n        Integer maximum1, maximum2; \n\n        maximum1 = maximumOptional1.orElse(0);\n        maximum2 = maximumOptional2.orElse(0);\n\n        System.out.println(maximum1);//6\n        System.out.println(maximum2);//0         \n\n        maximum1 = maximumOptional1.orElseGet(() -&gt; obtainRandomNumber());\n        maximum2 = maximumOptional2.orElseGet(() -&gt; obtainRandomNumber());\n\n        System.out.println(maximum1);//6\n        System.out.println(maximum2);//N\u00famero aleatorio entre 1 y  10\n\n        maximum1 = maximumOptional1.orElseThrow();\n        System.out.println(maximum1);//6\n        try {\n            maximum2 = maximumOptional2.orElseThrow();\n        } catch (NoSuchElementException e) {\n            System.out.println(\"Valor no presente\");\n        }\n\n        maximum1 = maximumOptional1.orElseThrow(IllegalStateException::new);\n\n        System.out.println(maximum1);//6\n\n        try {\n            maximum2 = maximumOptional2.orElseThrow(IllegalStateException::new);\n        } catch (IllegalStateException e) {\n            System.out.println(\"Valor no presente\");\n        }     \n    }     \n\n    public Integer obtainRandomNumber() {\n            return new Random().nextInt(10) + 1;//Devuelve un n\u00famero aleatorio entre 1 y 10\n    }     \n\n    public static &lt;T extends Comparable&lt;T&gt;&gt; Optional&lt;T&gt; max(Collection&lt;? extends T&gt; coll){\n        try {\n            return Optional.of(Collections.max(coll));\n        } catch (NoSuchElementException e) {\n            return Optional.empty();\n        }\n    }     \n\n    public static void main(String[] args) {\n        new OrElse().show();     \n    } \n</code></pre> </li> <li> <p><code>Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</code>: se introdujo en Java 9 para encadenar Optionals. Si el Optional original contiene un valor, el m\u00e9todo retorna un nuevo Optional con dicho valor. Si el Optional original no contiene el valor, el m\u00e9todo retornar\u00e1 el Optional producido por la funci\u00f3n suministradora.</p> </li> <li><code>&lt;U&gt; Optional&lt;U&gt; map(Function &lt;? super T, ? extends U&gt; mapper)</code>: sirve para transformar el valor contenido en un Optional. Si el Optional original est\u00e1 vac\u00edo, devuelve un nuevo Optional vac\u00edo y si tiene valor, devolver\u00e1 el Optional que contendr\u00e1 como valor el resultado de aplicar la funci\u00f3n de transformaci\u00f3n al valor contenido en el Optional original. Si dicha funci\u00f3n devuelve un resultado nulo, entonces se devuelve un Optional vac\u00edo.</li> <li> <p><code>Optional&lt;T&gt; filter(Predicate &lt;? super T&gt; predicate)</code>: retorna un nuevo Optional que estar\u00e1 vac\u00edo si el Optional original estaba vac\u00edo o si no se cumple el predicado recibido como argumento (su m\u00e9todo <code>test()</code> retorna <code>false</code>). Si el Optional original conten\u00eda un valor y dicho valor cumple con el predicado, el nuevo Optional retornado contendr\u00e1 el valor del Optional original.</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.Random;\n\npublic class OrMapFilter {     \n\n    public void show() {         \n        List&lt;Integer&gt; list1 = List.of(3, 2, 6, 1, 5, 4);\n        List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\n        Optional&lt;Integer&gt; maximumOptional1 = max(list1);\n        Optional&lt;Integer&gt; maximumOptional2 = max(list2);\n        Optional&lt;Integer&gt; maximumOptional3, maximumOptional4, maximumOptional5;         \n\n        maximumOptional3 = maximumOptional1.or(() -&gt; Optional.of(obtainRandomNumber()));\n        maximumOptional4 = maximumOptional2.or(() -&gt; Optional.of(obtainRandomNumber()));\n\n        System.out.println(maximumOptional3);//Optional[6]\n        System.out.println(maximumOptional4);//Optional de un n\u00famero aleatorio\n\n        maximumOptional3 = maximumOptional1.map(n -&gt; n * 2);\n        maximumOptional4 = maximumOptional2.map(n -&gt; n * 2);\n\n        System.out.println(maximumOptional3);//Optional[12]\n        System.out.println(maximumOptional4);//Optional.empty  \n\n        maximumOptional3 = maximumOptional1.filter(n -&gt; n % 2 == 0);\n        maximumOptional4 = maximumOptional1.filter(n -&gt; n % 2 != 0);\n        maximumOptional5 = maximumOptional2.filter(n -&gt; n % 2 == 0);\n\n        System.out.println(maximumOptional3);//Optional[6]\n        System.out.println(maximumOptional4);//Optional.empty\n        System.out.println(maximumOptional5);//Optional.empty\n    }     \n\n    public Integer obtainRandomNumber() {\n        return new Random().nextInt(10) + 1;//Devuelve un n\u00famero aleatorio entre 1 y 10\n    }     \n\n    public static &lt;T extends Comparable&lt;T&gt;&gt; Optional&lt;T&gt; max(Collection&lt;? extends T&gt; coll)     {\n        try {\n            return Optional.of(Collections.max(coll));\n        } catch (NoSuchElementException e) {\n            return Optional.empty();\n        }\n    }     \n\n    public static void main(String[] args) {         \n        new OrMapFilter().show();     \n    } \n}\n</code></pre> </li> <li> <p><code>void ifPresent(Consumer &lt;? super T&gt; action)</code>: permite consumir (usar) directamente el valor contenido en Optional si es que \u00e9ste contiene un valor. Si el Optional est\u00e1 vac\u00edo, no hace nada.</p> </li> <li><code>void ifPresentOrElse(Consumer &lt;? super T&gt; action, Runnable emptyAction)</code>: se incorpor\u00f3 este m\u00e9todo en Java 9. Ejecuta el consumidor pasado como argumento si el Optional posee un valor o ejecuta el Runnable pasado como argumento si el Optional no contiene ning\u00fan valor.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\n\npublic class IfPresent {     \n\n    public void show() {         \n        List&lt;Integer&gt; list1 = List.of(3, 2, 6, 1, 5, 4);\n        List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\n        Optional&lt;Integer&gt; maximumOptional1 = max(list1);\n        Optional&lt;Integer&gt; maximumOptional2 = max(list2);\n\n        maximumOptional1.ifPresent(System.out::println);//6\n        maximumOptional2.ifPresent(System.out::println);//No hace nada         \n        maximumOptional1.ifPresentOrElse(System.out::println,() -&gt; System.out.println(\"No hay m\u00e1ximo porque la lista est\u00e1 vac\u00eda\"));//6\n        maximumOptional2.ifPresentOrElse(System.out::println,() -&gt; System.out.println(\"No hay m\u00e1ximo porque la  lista est\u00e1 vac\u00eda\"));//No hay m\u00e1ximo porque la lista est\u00e1 vac\u00eda     \n    }     \n\n    public static &lt;T extends Comparable&lt;T&gt;&gt; Optional&lt;T&gt; max(Collection&lt;? extends T&gt; coll){\n        try {\n            return Optional.of(Collections.max(coll));\n        } catch (NoSuchElementException e) {\n            return Optional.empty();\n        }\n    }     \n\n    public static void main(String[] args) {         \n        new IfPresent().show();     \n    } \n}\n</code></pre> <p>Desafortunadamente, no podemos garantizar que la referencia al objeto Optional en s\u00ed no sea <code>null</code>. De hecho, en todos los ejemplos anteriores estamos confiando en que el m\u00e9todo <code>max()</code> nunca va a retornar un <code>null</code>. Otros lenguajes de programaci\u00f3n m\u00e1s modernos, como Kotlin o Swift, incorporan el concepto de Optional al sistema de tipos, de manera que existir\u00e1n dos tipos distintos, uno que incorpora la posibilidad de tener el valor <code>null</code> y otro tipo que no lo permite. Por ejemplo, en Kotlin existe el tipo <code>String</code>, que no puede contener el valor <code>null</code> y el tipo <code>String?</code>, que s\u00ed puede contenerlo. Al establecer el tipo de retorno de una funci\u00f3n tendremos que decidir si el tipo de retorno del m\u00e9todo es <code>String?</code>, el cliente deber\u00e1 comprobar si realmente se ha retornado un valor o no, pero siempre podr\u00e1 realizar la comprobaci\u00f3n. El problema de Java es que al encapsular un valor en un objeto Optional, el propio objeto Optional podr\u00eda ser <code>null</code> y deber\u00edamos fiarnos de que eso nunca puede suceder o realizar la comprobaci\u00f3n cada vez. Evidentemente, cualquier desarrollador que realiza un m\u00e9todo que retorna un Optional deber\u00eda asegurarse y documentar que dicho m\u00e9todo nunca retornar\u00e1 <code>null</code>, sino siempre un Optional.</p>"},{"location":"bloque_iii/tema_12/page-4/#donde-no-usar-optional","title":"D\u00f3nde no usar Optional","text":"<p>Debemos tener en cuenta que la clase <code>Optional&lt;T&gt;</code> ha sido dise\u00f1ada espec\u00edficamente para ser usada como tipo de retorno de los m\u00e9todos. No se recomienda su uso en los siguientes casos:</p> <ul> <li>No se recomienda usar Optional como tipo de los atributos de una clase.</li> <li>No se recomienda usar Optional como tipo de los par\u00e1metros de un m\u00e9todo porque ensucian mucho el c\u00f3digo y realmente no hacen que el par\u00e1metro sea opcional.</li> <li>No se recomienda usar Optional como tipo de una colecci\u00f3n, como por ejemplo en una lista.</li> </ul>"},{"location":"bloque_iii/tema_12/page-5/","title":"Proyecto y ejercicios","text":"<p>En este proyecto se llevar\u00e1 acabo una serie de ejercicios sobre la programaci\u00f3n funcional.</p> <p>IMPORTANTE</p> <p>S\u00f3lo se crear\u00e1 un \u00fanico proyecto, para cada ejercicio se deber\u00e1 crear una nueva versi\u00f3n del mismo a trav\u00e9s de GitHub, teniendo que usar tags para cada versi\u00f3n cuyo nombre sea vX.0 d\u00f3nde X es el n\u00famero de ejercicio</p> Ejercicio 1 <p>Crear una interfaz <code>Predicate</code>, que tenga un \u00fanico m\u00e9todo llamado <code>test(entero)</code> que reciba un entero y retorne un booleano.</p> <p>Crea una clase llamada <code>IsPrime</code> que implemente la interfaz <code>Predicate</code> y cuyo m\u00e9todo <code>test(entero)</code> retorne true si el entero recibido es un n\u00famero primo.</p> <p>Crea una clase <code>SuperFunctions</code>, que posea los siguientes m\u00e9todos est\u00e1ticos:</p> <ol> <li><code>count(list, predicate)</code>: Retorna el n\u00famero de elementos de la lista que cumplen con el predicado recibido. En el <code>main</code> llama a dicho m\u00e9todo est\u00e1tico para obtener cu\u00e1ntos n\u00fameros hay que sean primos en una lista pasada como argumento. As\u00ed, si la lista es <code>[5, 7, 2, 4, 9, 5, 15, 3]</code>, el m\u00e9todo est\u00e1tico debe retornar <code>5</code>, ya que contiene los siguientes n\u00fameros primos <code>5, 7, 2, 5, 3</code>.</li> <li><code>allMatch(list, predicate)</code>: Retorna true si todos los elementos de la lista cumplen con el predicado recibido. En el <code>main</code> llama a dicho m\u00e9todo est\u00e1tico para obtener si todos los n\u00fameros de la lista son primos.</li> <li><code>noneMatch(list, predicate)</code>: Retorna true si ning\u00fan elemento de la lista cumple con el predicado  recibido.  En  el main   llama  a  dicho  m\u00e9todo  est\u00e1tico  para  obtener  si  ninguno  de  los n\u00fameros de la lista es primo.</li> <li><code>anyMatch(list,  predicate)</code>:  Retorna true si  alg\u00fan  elemento  de  la  lista  cumple  con  el predicado recibido. En el <code>main</code>  llama a dicho m\u00e9todo est\u00e1tico para obtener si alguno de los n\u00fameros de la lista es primo.</li> <li><code>takeWhile(list, predicate)</code>: Retorna una nueva lista creada a partir de los elementos de la lista recibida como argumento, de manera que va tomando valores de la lista original mientras \u00e9stos cumplan con el predicado recibido. En cuanto un elemento no cumple el predicado se dejan de incluir elementos en la lista resultante. Por ejemplo, si le pasamos la lista <code>[5, 7, 2, 4, 9, 5, 15, 3]</code> y el predicado de que el n\u00famero sea primo, la funci\u00f3n deber\u00e1 retornar la lista <code>[5, 7, 2]</code>, ya que el <code>4</code> ya no es primo. Prueba el ejemplo anterior desde el <code>main</code>.</li> <li><code>dropWhile(list, predicate)</code>: Retorna una nueva lista creada a partir de los elementos de la lista recibida como argumento, de manera que el primer elemento que es incluido en la lista resultante es  aquel  que  no  cumple  con  el  predicado  recibido  como  argumento,  y  a  partir  de  dicho  elemento  el resto de elementos de la lista original son incluidos sin realizar ninguna comprobaci\u00f3n. Por ejemplo, si le pasamos la lista <code>[5, 7, 2, 4, 9, 5, 15, 3]</code> y el predicado de que el n\u00famero sea primo, la funci\u00f3n  deber\u00e1  retornar  la  lista <code>[4, 9, 5, 15, 3]</code>, porque  el  primer  n\u00famero  no  primo  de  la  lista original es <code>4</code>. Prueba el ejemplo anterior desde el  main .</li> </ol> Ejercicio 2 <p>Crea una interfaz <code>Function</code>, que tenga un \u00fanico m\u00e9todo llamado <code>apply(entero)</code>que reciba un entero y retorne un entero.</p> <p>Crea una clase llamada <code>Triple</code> que implemente la interfaz <code>Function</code> y cuyo m\u00e9todo <code>apply(entero)</code>retorne el triple del entero recibido.</p> <p>Crea  una  clase  llamada <code>LessThan100</code>   que  implemente  la  interfaz <code>Predicate</code>  y cuyo m\u00e9todo <code>test(entero)</code> retorne  true si el entero recibido es &gt;= 0 y menor que 100.</p> <p>En la clase  SuperFunctions  agrega los siguientes m\u00e9todos est\u00e1ticos:</p> <ol> <li><code>iterate(integerSeed,  count,  function)</code>: Retorna  una  lista  con <code>count</code>  elementos  (se debe lanzar una excepci\u00f3n si <code>count  &lt;=  0</code>), donde el primer elemento corresponde a <code>integerSeed</code> y  el  resto  de  elementos  se  calcula  aplicando  la  funci\u00f3n  recibida  al  elemento anterior.  Por  ejemplo,  si <code>integerSeed</code> es 1, <code>count</code> es 4 y la funci\u00f3n es calcular el triple,  el m\u00e9todo debe retornar la lista  <code>[1, 3, 9, 27]</code></li> <li><code>iterate(integerSeed, max, predicate,  function)</code>:  Retorna  una  lista  donde  el  primer elemento  corresponde  a <code>integerSeed</code> y  el  resto  de  elementos  se  calcula  aplicando  la  funci\u00f3n recibida  al  elemento  anterior.  En  cuanto  un  elemento  generado  no  cumple  con  el  predicado  dicho elemento no es incluido en la lista resultante y \u00e9sta se da por concluida. Si la lista resultante alcanza el n\u00famero m\u00e1ximo de elementos <code>max</code> la lista se da por concluida. Por ejemplo, si <code>integerSeed</code> es 1, <code>max</code> es 10, el predicado es que el n\u00famero sea menor que 100 y la funci\u00f3n es calcular  el triple, el m\u00e9todo debe retornar la lista <code>[1, 3, 9, 27, 81]</code>, ya que  243 (81 * 3)  ya no es menor que 100. Si el predicado se cumple siempre, como por ejemplo si en el caso anterior <code>integerSeed</code> es 0 , se retornar\u00e1 una lista cuyo tama\u00f1o corresponder\u00e1 a <code>max</code>, en nuestro caso <code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</code>.</li> </ol> Ejercicio 3 <p>Crea una interfaz <code>ConsumerBinary</code>, que tenga un \u00fanico m\u00e9todo <code>accept(entero1,entero2)</code>  que reciba dos enteros y no retorne nada.</p> <p>Crea  una  clase <code>PrinterWithIndex</code> que  implemente  la  interfaz <code>ConsumerBinary</code> y cuyo m\u00e9todo <code>accept(entero1, entero2)</code> muestre por consola el mensaje \"El valor {entero2} tiene el \u00edndice {entero1}\"  sustituyendo <code>{entero2}</code> por  el  valor  de entero2 y {entero1}   por  el  valor  de{entero1} </p> <p>Crear una interfaz <code>FunctionBinary</code>, que tenga un \u00fanico m\u00e9todo <code>apply(entero1, entero2)</code> que reciba dos enteros y retorne un entero.</p> <p>Crea una clase <code>Subtractor</code> que implemente dicha interfaz y cuyo m\u00e9todo <code>apply()</code> retorne el resultado de restarle entero1 a entero2.</p> <p>En la clase <code>SuperFunctions</code> agrega los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>actWithIndex(list, consumerBinary)</code>: Para cada elemento de la lista llama al m\u00e9todo <code>accept</code> del consumidor binario pas\u00e1ndole como primer argumento el \u00edndice del elemento y como segundo argumento el elemento en s\u00ed. La funci\u00f3n debe retornar una nueva lista con los elementos de la lista original. Por ejemplo, si la lista es <code>[10, 20, 30]</code> y el <code>consumerBinary</code> es un objeto de la clase <code>PrinterWithIndex</code>, se debe mostrar por consola:</li> </ul> <p><pre><code>El valor 10 tiene el \u00edndice 0\nEl valor 20 tiene el \u00edndice 1\nEl valor 30 tiene el \u00edndice 2\n</code></pre> La funci\u00f3n debe retornar <code>[10, 20, 30]</code>.</p> <ul> <li><code>consumeWithIndex(list, consumerBinary)</code>: Para cada elemento de la lista llama al m\u00e9todo <code>accept</code> del consumidor binario pas\u00e1ndole como primer argumento el \u00edndice del elemento y como segundo argumento el m\u00e9todo en s\u00ed. La funci\u00f3n no debe retornar nada.</li> <li><code>reduceFromEnd(list, functionBinary)</code>: Retorna un valor entero con el resultado de aplicar la operaci\u00f3n de reducci\u00f3n indicada por la <code>functionBinary</code> pero tomando como primer elemento el \u00faltimo de la lista original. Si la lista original estuviera vac\u00eda retornar\u00e1 <code>null</code>. Por ejemplo, si la lista es <code>[1, 3, 9, 27]</code> y la funci\u00f3n binaria corresponde a un objeto de la clase <code>Subtractor</code>, la funci\u00f3n debe retornar 14, que corresponde a la operaci\u00f3n 27 - 9 - 3 - 1.</li> <li><code>reduceFromEnd(list, identity, functionBinary)</code>: Retorna un valor entero con el resultado de aplicar la operaci\u00f3n de reducci\u00f3n indicada por la <code>functionBinary</code> pero tomado como primer elemento el \u00faltimo de la lista original. El valor inicial de acumulador corresponder\u00e1 a <code>identity</code>. Por ejemplo, si la lista es <code>[1, 3, 9, 27]</code>, identidad corresponde <code>0</code> y la funci\u00f3n binaria corresponde a un objeto de la clase <code>Subtractor</code>, la funci\u00f3n debe retornar -40, que corresponde a la operaci\u00f3n 0 - 27 - 9 - 3 - 1.</li> </ul> Ejercicio 4 <p>Realiza las siguientes modificaciones:</p> <ul> <li>En el main(), realiza las llamadas anteriores a las funciones haciendo uso de las clases an\u00f3nimas inline, en vez de usar las clases <code>IsPrime</code>, <code>Triple</code>, <code>NaturalLessThan100</code>, <code>PrinterWithIndex</code> o <code>Subtractor</code>, que puedes eliminar tranquilamente.</li> <li>Modifica las interfaces para que en vez de trabajar con enteros, sean interfaces gen\u00e9ricas parametrizadas que funcionen con tipos gen\u00e9ricos.</li> <li>Modifica los m\u00e9todos de la clase <code>SuperFunction</code> para que se adapten a los cambios descritos anteriormente.</li> <li>Vuelve a cambiar en el main(), las llamadas a las funciones, haciendo uso de las clases an\u00f3nimas inline, pero en esta ocasi\u00f3n haciendo uso de los parametrizadas con el tipo adecuado.</li> </ul> Ejercicio 5 <p>Crea la clase <code>Stream&lt;T&gt;</code>, que representa un flujo, y a\u00f1\u00e1dele los m\u00e9todos de la clase <code>SuperFunctions</code>, sin que sean est\u00e1ticos (excepto el m\u00e9todo <code>iterate</code>). (La clase <code>SuperFunctions</code> podr\u00e1 ser eliminada).</p> <p>Haz que los m\u00e9todos de la clase retornen un nuevo flujo en vez de una lista.</p> <p>Agrega a la clase <code>Stream&lt;T&gt;</code> los m\u00e9todos:</p> <ul> <li><code>filter(predicate)</code>: retorna un nuevo flujo con los elementos de la lista original que cumplan el predicado.</li> <li><code>map(function)</code>: retorna un nuevo flujo con los elementos \"transformados\" del flujo original. Por ejemplo, si la flujo inicial est\u00e1 formado por los n\u00fameros del 1 al 10 y se quiere transformar al cuadrado de dichos n\u00fameros (el valor de <code>function</code> ser\u00eda una clase an\u00f3nima inline, que la implementaci\u00f3n de su m\u00e9todo <code>apply</code>retorne el cuadrado de un n\u00famero).</li> <li><code>of(vararg)</code>: m\u00e9todo est\u00e1tico que recibe un vararg de elementos, que retornar\u00e1 un flujo con los elementos recibidos.</li> <li><code>from(collection)</code>: m\u00e9todo est\u00e1tico que recibe una colecci\u00f3n de elementos y retornar\u00e1 un nuevo flujo con los elementos recibidos.</li> <li><code>recolectar()</code>: retorna una lista con los elementos gestionados por el flujo.</li> </ul> <p>Realiza un main que cree un flujo usando el m\u00e9todo est\u00e1tico <code>iterate(integerSeed, count, function)</code>, donde <code>integerSeed</code>, sea 1, <code>count</code>sea 5 y <code>function</code> sea una <code>Function&lt;Integer&gt;</code> cuyo m\u00e9todo <code>apply()</code> retorna el valor recibido multiplicado por 5 y se le sume 1. Despu\u00e9s el flujo generado ser\u00e1 filtrado de manera que se obtenga un nuevo flujo con s\u00f3lo los valores del anterior que sean pares. Despu\u00e9s se deber\u00e1 obtener un nuevo flujo con los valores del anterior convertidos a cadena con el formato <code>-valor-</code> y finalmente dicho flujo se reduzca haciendo uso del m\u00e9todo <code>reduceFromEnd()</code>, de manera que se obtenga una \u00fanica cadena de caracteres. Por ejemplo <code>-156--6-</code>.</p> Ejercicio 6 <p>Realiza la versi\u00f3n anterior modificando lo siguiente:</p> <ul> <li>A\u00f1ade la anotaci\u00f3n <code>@FunctionalInterface</code> a todas las interfaces definidas.</li> <li>Reemplaza las clases an\u00f3nimas con expresiones lambdas.</li> </ul> Ejercicio 7 <p>En esta versi\u00f3n elimina las interfaces funcionales y reempl\u00e1zalas en la clase <code>Stream&lt;T&gt;</code>  por las interfaces funcionales predefinidas en Java 8.</p> Ejercicio 8 <p>Crea una clase <code>MyAppUtils</code> con los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>quintupleMoreOne(value)</code>: recibe un entero y retorna dicho valor multiplicado por 5 y despu\u00e9s sum\u00e1ndole 1.</li> <li><code>isEven(value)</code>: recibe un entero y retorna true si el n\u00famero es par.</li> <li><code>withDashes(value)</code>: recibe un entero y retorna la cadena <code>-value-</code>.</li> <li><code>concat(str1, str2)</code>: retorna la concatenaci\u00f3n de ambas cadenas recibidas.</li> </ul> <p>Haciendo uso de la referencias a m\u00e9todos, sustituye las expresiones lambda por la llamada a estos m\u00e9todos.</p> Ejercicio 9 <p>Realiza los m\u00e9todos anteriores dentro de la misma clase Main sin definirlos de forma est\u00e1tica y eliminado la clase <code>MyAppUtils</code>. Adem\u00e1s en vez de usar el m\u00e9todo <code>concat</code> (que puede ser eliminado) se usar\u00e1 el m\u00e9todo <code>concat</code> de la clase <code>String</code>.</p> Ejercicio 10 <p>Agrega a la clase <code>Stream&lt;T&gt;</code> un m\u00e9todo <code>find(predicate)</code> que encuentre el primer elemento que cumple con el predicado y lo retorne en un <code>Optional&lt;T&gt;</code>.</p> <p>Agrega tambi\u00e9n, un m\u00e9todo llamada <code>findLast(predicate)</code> que encuentre el \u00faltimo elemento que cumple con el predicado y lo retorne en un <code>Optional&lt;T&gt;</code>.</p>"},{"location":"bloque_iii/tema_13/page-1/","title":"1 Introducci\u00f3n a los Streams","text":""},{"location":"bloque_iii/tema_13/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Un stream (flujo) en Java es una secuencia de elementos que se pueden procesar (mapear, filtrar, transformar, reducir y recolectar), de forma secuencial o paralela, mediante una cadena de operaciones especificadas a trav\u00e9s de expresiones lambda. Introducidos en Java 8, los streams permiten optimizar la forma de procesar grandes colecciones de datos.</p> <p>La interfaz <code>Stream&lt;T&gt;</code> representa un flujo de elementos de tipo <code>T</code> aunque tambi\u00e9n se definen interfaces concretas para los tipos primitivos, como <code>IntStream</code>, <code>LongStream</code>, etc.</p> <p>Un stream es una abstracci\u00f3n que representa un flujo de datos pero no una estructura de datos, ya que los elementos no son almacenados en el stream, sino tan solo procesador por \u00e9l. De hecho, no se puede acceder individualmente a un determinado elemento del stream, sino que se define la fuente de datos origen del stream y la secuencia de operaciones que se deben aplicar sobre sus elementos, especificadas de forma funcional mediante expresiones lambda.</p> <p>M\u00e1s a\u00fan, la fuente de datos de origen del stream no se ve afectada por las operaciones realizadas dentro del stream. Por ejemplo, si se filtran algunos elementos de datos del stream, no se eliminan realmente de la fuente de datos origen, simplemente se omiten en el stream a partir de ese momento y ya no se tienen en cuenta la siguiente operaci\u00f3n incluida en la secuencia de operaciones del stream. Por tanto, los datos con los que trabajamos no se ven afectados por el stream.</p> <p>Los streams solo gestionan datos transitorios en memoria, lo que implica que si la aplicaci\u00f3n falla dichos datos se perder\u00e1n.</p> <p>Un stream puede ser finito, es decir, tener un n\u00famero finito de elementos, o infinito, si genera un n\u00famero infinito de elementos. Algunas operaciones permiten restringir el n\u00famero de elementos procesados, como <code>limit()</code> o <code>findFirst()</code>.</p>"},{"location":"bloque_iii/tema_13/page-1/#pipeline","title":"Pipeline","text":"<p>Una vez hayamos creado un stream a partir de una fuentes de datos, podemos ejecutar sobre \u00e9l cero o m\u00e1s operaciones intermedias, y forzosamente, una operaci\u00f3n final. A esta cadena de operaciones se le conoce como pipeline. Un pipeline tiene los siguientes elementos en el siguiente orden:</p> <ol> <li>Una funci\u00f3n generadora del stream.</li> <li>Cero o m\u00e1s operaciones intermedias.</li> <li>Un operaci\u00f3n terminal.</li> </ol> <p>Debemos tener en cuenta que cada operaci\u00f3n intermedia del pipeline genera un nuevo stream resultante de aplicar la operaci\u00f3n indicada al stream anterior de la cadena.</p> <ul> <li>Operaciones intermedias (aggregate operations): producen como resultado un nuevo stream. Se usan para transformar, filtrar y clasificar los elementos del stream. Puede ser:<ul> <li>Operaciones sin estado: al aplicarlas, el procesamiento de un elemento del stream es independiente de cualquier otro elemento del mismo. Por ejemplo, la operaci\u00f3n de filtrado es sin estado, ya que el filtro de cada elemento s\u00f3lo depende de una condici\u00f3n, no de ning\u00fan otro elemento del stream.</li> <li>Operaciones con estado: al aplicarlas, el procesamiento de un elemento del stream depende de alg\u00fan otro elemento del mismo. Por ejemplo, la operaci\u00f3n de ordenaci\u00f3n es con estado, ya que para posicionar un elemento es necesario compararlo con el resto.</li> </ul> </li> <li>Operaciones terminales (terminal operations): procesan todos los elementos del stream para generar un resultado o un efecto secundario. De hecho, no retornan un stream. Despu\u00e9s de su ejecuci\u00f3n, el stream original no puede ser usado de nuevo, produciendo una excepci\u00f3n si se intenta. De ah\u00ed que se denominen operaciones terminales. Por tanto, un determinado stream puede ser usado una sola vez; si necesitamos procesar la misma fuente de datos, deberemos crear un nuevo stream con ella como origen.</li> </ul> <p>Otra caracter\u00edstica important\u00edsima del pipeline es que es perezoso (lazy), lo que quiere decir que las operaciones intermedias s\u00f3lo son ejecutadas cuando las requiere la operaci\u00f3n terminal que se est\u00e9 ejecutando.</p> <p>Por defecto, los elementos de un stream son procesados secuencialmente de uno en uno en el mismo hilo de ejecuci\u00f3n. Es lo que se conoce como stream secuencial. Sin embargo, podemos convertir un stream secuencial en un stream paralelo con tan s\u00f3lo llamar a su m\u00e9todo <code>parallel()</code>. Los elementos de los streams paralelos son agrupados en conjuntos y se usa un grupo de hilos en ejecuci\u00f3n, denominados common fork-join pool, para procesar estos conjuntos de elementos en hilos de ejecuci\u00f3n independientes.</p> <p>Debemos tener en cuenta que al llamar al m\u00e9todo <code>parallel()</code> se convierte el stream completo en paralelo, no solo desde el punto en el que se llama al m\u00e9todo.</p> <p>Debemos tener en cuenta que las operaciones intermedias con estado no utilizar\u00e1n todas las posibilidades de paralelismo existentes, dada su naturaleza en lo relativo a lo dependencia entre elementos.</p>"},{"location":"bloque_iii/tema_13/page-1/#modelo-mapreduce","title":"Modelo MapReduce","text":"<p>En Java, los streams utilizan el modelo MapReduce, que es un modelo de programaci\u00f3n utilizado para procesar conjuntos de datos muy grandes y que ha sido adoptado por la programaci\u00f3n funcional. Este modelo se basa en los siguientes tipos de operaciones:</p> <ul> <li>Transformaci\u00f3n (map): filtra o crea copias modificadas de los elementos originales. Todas las operaciones intermedias de los streams corresponden a operaciones de transformaci\u00f3n.</li> <li> <p>Reducci\u00f3n (reduce): genera un resultado resumen de todos los elementos, por ejemplo, la suma o la media aritm\u00e9tica. Las operaciones terminales de la clase <code>Stream</code> corresponde a operaciones de reducci\u00f3n. De hecho, la clase <code>Stream</code> implementa dos operaciones de reducci\u00f3n diferentes:</p> <ul> <li>De reducci\u00f3n pura: implementada en las diferentes versiones del m\u00e9todo <code>reduce</code>, que procesa un flujo de elementos para obtener un \u00fanico valor.</li> <li>De reducci\u00f3n mutable: implementada en las diferentes versiones del m\u00e9todo <code>collect</code>, que procesa un flujo de elementos para generar una estructura de datos mutable, como por ejemplo, una colecci\u00f3n.</li> </ul> </li> </ul>"},{"location":"bloque_iii/tema_13/page-1/#creacion-de-un-stream-a-partir-de-una-fuente-de-datos","title":"Creaci\u00f3n de un stream a partir de una fuente de datos","text":"<p>Java permite muchas maneras de crear un stream, dependiendo de la fuente de datos origen deseada. Veamos algunas de estas fuentes:</p> <ul> <li> <p>Colecci\u00f3n: se ejecuta el m\u00e9todo <code>stream()</code> sobre una colecci\u00f3n para crear un stream que tenga como fuente de datos de origen dicha colecci\u00f3n. Tambi\u00e9n tenemos disponible el m\u00e9todo <code>parallelStream()</code> para que los elementos sean procesados en modo paralelo.</p> <p>Podemos crear un stream a partir del cualquier interfaz que extienda de <code>Collection</code>, como <code>List</code>, <code>Set</code> o <code>Queue</code> y cualquiera de las clases que implementen dichas interfaces. Por ejemplo, desde una lista:</p> <pre><code>List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4);\nStream&lt;Integer&gt; stream = list.stream();\n</code></pre> <p>o desde el <code>Set</code> correspondiente a las entradas de un <code>Map</code>:</p> <pre><code>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\nStream&lt;Map.Entry&lt;Integer, String&gt;&gt; stream = map.entrySet().stream();\n</code></pre> </li> <li> <p>Array: el m\u00e9todo est\u00e1tico <code>Arrays.stream(array)</code> recibe un array, que actuar\u00e1 como fuente de datos origen del stream. Ejemplo:</p> <pre><code>Integer array[] = {1, 2, 3, 4};\nStream&lt;Integer&gt; stream = Arrays.stream(array);\n</code></pre> </li> <li> <p>Conjunto predeterminado de elementos: el m\u00e9todo est\u00e1tico <code>Stream.of()</code> recibe un n\u00famero variable de elementos que actuar\u00e1n como fuente de datos origen del stream. Ejemplo</p> <pre><code>Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4);\n</code></pre> </li> <li> <p>Funci\u00f3n suministradora de objetos (interfaz funcional <code>Supplier</code>): el m\u00e9todo est\u00e1tico <code>Stream.generate()</code> recibe un <code>Supplier</code>, es decir, una funci\u00f3n suministradora de elementos, que actuar\u00e1 como fuente de datos origen infinita para el stream. Ejemplo:</p> <pre><code>Stream&lt;Integer&gt; stream = Stream.generate(new Random()::nextInt);\n</code></pre> </li> <li> <p>Un valor inicial y una funci\u00f3n que obtiene el siguiente elemento a partir del anterior: el m\u00e9todo est\u00e1tico <code>Stream.iterate(seed, unaryOperator)</code> recibe un valor inicial y una funci\u00f3n que recibe el elemento anterior y retorna el valor del nuevo elemento, que debe ser del mismo tipo. Se tratar\u00e1 de un stream infinito.</p> <p>Ejemplo:</p> <pre><code>Stream&lt;Integer&gt; stream = Stream.iterate(0, x -&gt; x + 5);\n</code></pre> <p>Java 9 introdujo una nueva versi\u00f3n de este m\u00e9todo <code>Stream.iterate(seed, predicate, unaryOperator)</code> que recibe un par\u00e1metro intermedia adicional correspondiente a un predicate que al dejar de cumplir hace que el stream no emita m\u00e1s valores, convirti\u00e9ndose en un stream finito. Ejemplo:</p> <pre><code>Stream&lt;Integer&gt; stream = Stream.iterate(0, x -&gt; x &lt; 100, x -&gt; x + 5);\n</code></pre> </li> <li> <p>Detectando patrones en una cadena: el m\u00e9todo <code>splitAsStream(cadena)</code> de la clase <code>Pattern</code> permite dividir una cadena en base a un patr\u00f3n y retornar un stream de subcadenas. Por ejemplo:</p> <pre><code>Stream&lt;String&gt; stream = Pattern.compile(\",\".splitAsStream(\"Luis,Paco,Ricardo\"));\n</code></pre> <p>retorna un stream cuyos elementos ser\u00e1n Luis, Paco y Ricardo.</p> </li> <li> <p>Generador de n\u00fameros aleatorios: el m\u00e9todo <code>ints(limiteInf, limiteSup)</code> de la clase <code>Random</code> retorna un stream (un <code>IntStream</code>) cuya fuente de datos origen es el generador de n\u00fameros aleatorios contenidos entre <code>limiteInf</code> y <code>limiteSup</code>. Es especialmente \u00fatil para hacer pruebas. Ejemple:</p> <pre><code>IntStream stream = new Random().ints(1, 100);\n</code></pre> </li> <li> <p>M\u00e9todos est\u00e1ticos de la clase IntStream:</p> <ul> <li> <p><code>IntStream.range(start, end)</code>: retorna un <code>IntStream</code> ordenado cuyos elementos corresponden a los enteros que van desde <code>start</code> hasta <code>end - 1</code>, es decir, <code>end</code> est\u00e1 excluido. Ejemplo:</p> <pre><code>IntStream stream = IntStream.range(1,8);\n</code></pre> </li> <li> <p><code>IntStream.rangeClosed(start, end)</code>: retorna un <code>IntStream</code> ordenado cuyos elementos corresponden a los enteros que van desde <code>start</code> hasta <code>end</code> incluido. Ejemplo:</p> <pre><code>IntStream stream = IntStream.rangeClosed(1, 8);\n</code></pre> </li> </ul> </li> <li> <p>M\u00e9todo chars() de String: retorna un <code>IntStream</code> cuyos elementos corresponden a los caracteres de la cadena. Ejemplo:</p> <pre><code>IntStream stream = \"Programaci\u00f3n\".chars();\n</code></pre> </li> <li> <p>Un valor inicial: Java 9 incorpora el m\u00e9todo est\u00e1tico <code>Stream.ofNullable(T value)</code> que retorna un <code>Stream&lt;T&gt;</code> con el valor indicado o vac\u00edo si el valor proporcionado es <code>null</code>.</p> </li> <li>Un Optional: Java 9 incorpora el m\u00e9todo <code>stream()</code> que retorna un <code>Stream&lt;T&gt;</code> con un \u00fanico valor correspondiente al valor contenido en el optional o un stream vac\u00edo si el optional no tiene valor presente.</li> <li>Un stream vac\u00edo: podemos crear un stream vac\u00edo mediante el m\u00e9todo est\u00e1tico <code>empty()</code> de la interfaz <code>Stream&lt;T&gt;</code>.</li> <li>Un stream builder: podemos crear un stream a partir de un objeto <code>Stream.Builder&lt;T&gt;</code> al que podamos agregar elementos mediante el m\u00e9todo <code>add(item)</code> y posteriormente usar el m\u00e9todo <code>build()</code> del mismo para obtener el objeto <code>Stream&lt;T&gt;</code>.</li> <li> <p>La concatenaci\u00f3n de dos streams: El m\u00e9todo est\u00e1tico <code>Stream.concat(stream1, stream2)</code> retorna un stream resultante de la concatenaci\u00f3n de los dos streams recibidos. Ejemplo:</p> <pre><code>Stream&lt;String&gt; stream1 = Stream.of(\"Luis\", \"Paco\", \"Ricardo\");\nStream&lt;String&gt; stream2 = Stream.of(\"Ana\", \"Lidia\", \"Esther\");\nStream&lt;String&gt; stream = Stream.concat(stream1, stream2);\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-1/#tratamiento-individual-de-los-elementos","title":"Tratamiento individual de los elementos","text":"<p>En algunas ocasiones necesitamos realizar alg\u00fan tratamiento sobre cada uno de los elementos del stream. En dicho caso debemos diferenciar entre operaciones terminales y no terminales. Las operaciones terminales no producir\u00e1n un nuevo stream mientras que las operaciones intermedias s\u00ed que lo producir\u00e1n.</p> <ul> <li><code>void forEach(Consumer&lt;? super T&gt; action)</code>: operaci\u00f3n terminal para tratar cada uno de los elementos del stream. Aplica la acci\u00f3n recibida en forma de Consumer a cada uno de los elementos del stream.</li> <li><code>Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)</code>: tambi\u00e9n se aplica la acci\u00f3n recibida en forma de Consumer a cada uno de los elementos del stream pero retorna un nuevo stream con los mismos elementos que el original, por lo que se trata de una operaci\u00f3n intermedia. Este m\u00e9todo se utiliza para tratar individualmente cada uno de los elementos del stream sin tener por ello que terminar la cadena de operaciones.</li> </ul>"},{"location":"bloque_iii/tema_13/page-2/","title":"2 Operaciones intermedias","text":""},{"location":"bloque_iii/tema_13/page-2/#filtrado","title":"Filtrado","text":"<p>Otra de las operaciones intermedias que se pueden realizar sobre un stream es el filtrado de sus elementos, es decir, la generaci\u00f3n de un nuevo stream que s\u00f3lo contenga algunos de los elementos del stream original. Java nos proporciona distintos m\u00e9todos:</p> <ul> <li> <p><code>Stream&lt;T&gt; distinct()</code>: retorna un nuevo stream con los elementos del stream original, excepto aquellos que estuvieran repetidos. Para determinar que dos elementos son iguales se usar\u00e1 al m\u00e9todo <code>equals()</code> del elemento. Ejemplo:</p> MainSalida <pre><code>import java.util.stream.Stream;\n\npublic class Distinct{\n\n    public void show(){\n        Stream.of(1, 3, 2, 3, 1)\n            .distinct()\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new Distinct().show();\n    }\n}\n</code></pre> <pre><code>1\n3\n2\n</code></pre> <ul> <li><code>Stream&lt;T&gt; limit(long maxSize)</code>: retorna un nuevo stream con tan s\u00f3lo maxSize elementos del stream original, atendiendo al orden intr\u00ednseco del mismo. Tiene un mal rendimiento en streams paralelos ordenados. Ejemplo:</li> </ul> MainSalida <pre><code>public class Limit{\n\n    public void show(){\n        Stream.of(\"Ricardo\", \"Luis\", \"Paco\")\n            .limit(2)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new Limit().show();\n    }\n}\n</code></pre> <pre><code>Ricardo\nLuis\n</code></pre> <ul> <li><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>: retorna un nuevo stream que s\u00f3lo incorpora los elementos del stream original que cumplan el predicado recibido. Ejemplo:</li> </ul> MainSalidas <pre><code>public class Filter{\n\n    public void show(){\n        Stream.of(9, 12, 15, 24, 37, 6)\n            .filter(n -&gt; n % 2 == 0)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new Filter().show();\n    }\n}\n</code></pre> <pre><code>12\n24\n6\n</code></pre> <ul> <li><code>Stream&lt;T&gt; skip(long n)</code>: retorna un nuevo stream en el que no se incluyen los primeros n elementos del stream original pero s\u00ed se incluye el resto. No proporciona un buen rendimiento en streams paralelos ordenados. Ejemplo:</li> </ul> MainSalida <pre><code>public class Skip{\n\n    public void show(){\n        Stream.of(9, 12, 15, 24, 27, 6)\n            .skip(3)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new Skip().show();\n    }\n}\n</code></pre> <pre><code>24\n37\n6\n</code></pre> <ul> <li><code>default Stream&lt;T&gt; dropWhile(Predicate &lt;? super T&gt; predicate)</code>: retorna un nuevo stream con el primer elemento que no cumpla el predicado y el resto de elementos, independientemente de si cumplen el predicado o no. Proporciona un mal rendimiento con streams paralelos ordenados:</li> </ul> MainSalida <pre><code>public class DropWhile{\n\n    public void show(){\n        Stream.of(9, 13, 15, 24, 37, 6)\n            .dropWhile(n -&gt; n % 2 != 0)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new DropWhile().show();\n    }\n}\n</code></pre> <pre><code>24\n37\n6\n</code></pre> <ul> <li><code>default Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</code>: mientras los elementos cumplan el predicado se van incluyendo en el stream, pero en cuanto se encuentra un elemento que no cumple el predicado se deja de incluir el resto de elementos, incluso aunque cumplan el predicado. Ejemplo:</li> </ul> MainSalida <pre><code>public class TakeWhile{\n\n    public void show(){\n        Stream.of(9, 13, 15, 24, 37, 6)\n            .takeWhile(n -&gt; n % 2 != 0)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new TakeWhile().show();\n    }\n}\n</code></pre> <pre><code>9\n13\n15\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-2/#ordenacion","title":"Ordenaci\u00f3n","text":"<p>Algunos streams son ordenados, es decir, que sus elementos poseen un determinado orden intr\u00ednseco significativo, conocido como encounter order. Por ejemplo, un stream cuya fuente de datos corresponda a una lista crear\u00e1 un stream ordenado, cuyo encounter order ser\u00e1 el orden en el que los elementos est\u00e1n situados en la lista. Sin embargo, otros streams no son ordenados, en el sentido de que sus elementos no tienen un orden intr\u00ednseco significativo. Por ejemplo, un stream cuya fuente de datos sea un conjunto (Set) ser\u00e1 un stream sin encounter order, ya que un conjunto los elementos no tienen un orden preestablecido.</p> <p>El hecho de que un stream sea ordenado o no depender\u00e1 del tipo de fuente de datos asociada y de las operaciones intermedias anteriores que hayamos realizado mediante las que se ha obtenido el stream.</p> <p>Algunas operaciones trabajan por defecto en base a este encounter order, imponiendo una restricci\u00f3n acerca del orden en el que los elementos deben ser procesados, como por ejemplo las operaciones intermedias limit o skip.</p> <p>Sin embargo, existen otras operaciones que no tienen en cuenta el encounter order, como por ejemplo forEach. Si se ejecuta sobre un stream paralelo, no hay ninguna garant\u00eda sobre en que orden se aplica la acci\u00f3n a los elementos. Si queremos que s\u00ed se tenga en cuenta el orden, entonces tendr\u00edamos que usar el m\u00e9todo <code>void forEachOrdered(Consumer&lt;? super T&gt; action)</code>. Normalmente se usa encadenado despu\u00e9s de llamar a un m\u00e9todo de ordenaci\u00f3n que habr\u00e1 ordenado el stream. La ventaja de este m\u00e9todo es que se garantiza que la acci\u00f3n se aplica a los elementos en el orden intr\u00ednseco del stream, incluso aunque \u00e9ste se trate de un stream paralelo, aunque conlleve un peor rendimiento.</p> <p>Al trabajar con streams secuenciales, el encounter order no afecta al rendimiento de la aplicaci\u00f3n, pero si trabajamos con streams paralelos, el empleo del encounter order por parte de algunos operadores pueden afectar en gran medida al rendimiento general de la aplicaci\u00f3n. Dependiendo de la operaci\u00f3n de la que se trate, ser\u00e1 necesario procesar a la vez m\u00e1s de un elemento del stream a partir del anterior, en el que no se tenga en cuenta el encounter order. Al ejecutar el m\u00e9todo <code>unordered()</code>, tan solo se est\u00e1 creando un nuevo stream en el que se ha borrado el indicador de que el encounter order debe tenerse en cuenta. Normalmente, esta operaci\u00f3n de desactivaci\u00f3n del encounter order se realiza con el objetivo de mejorar el rendimiento en streams paralelos.</p> <p>Por otra parte, si queremos obtener un stream ordenado a partir de otro desordenado o a partir de otro stream ordenado pero por un orden distinto, podemos usar el m\u00e9todo <code>sorted()</code>, en cuyo caso los elementos del stream deben implementar la interfaz <code>Comparable</code> para determinar el orden en el que deben ser ordenados. Otra posibilidad es usar una versi\u00f3n sobrecargada de dicho m\u00e9todo que recibe un objeto <code>Comparator</code> como argumento. Ejemplo:</p> MainSalida <pre><code>public class Sorted{\n\n    public void show(){\n        Stream.of(\"Ricardo\", \"Luis\", \"Paco\")\n            .sorted()\n            .limit(2)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new Sorted().show();\n    }\n}\n</code></pre> <pre><code>Luis\nPaco\n</code></pre> <p>Ejemplo utilizando <code>Comparator</code>:</p> MainSalida <pre><code>public class SortedReverseOrder{\n\n    public void show(){\n        Stream.of(\"Ricardo\", \"Luis\", \"Paco\")\n            .sorted(Comparator.reverseOrder())\n            .limit(2)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new SortedReverseOrder().show();\n    }\n}\n</code></pre> <pre><code>Ricardo\nPaco\n</code></pre>"},{"location":"bloque_iii/tema_13/page-2/#transformacion","title":"Transformaci\u00f3n","text":"<p>Java nos proporciona distintos m\u00e9todos:</p> <ul> <li> <p><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code>: retorna un nuevo stream obtenido a partir de aplicar la funci\u00f3n de transformaci\u00f3n indicada a cada uno de los elementos del stream original. El tipo del stream resultante corresponder\u00e1 al tipo de retorno de la funci\u00f3n de transformaci\u00f3n, que puede ser distinto al tipo del stream original, pero contendr\u00e1 tantos elementos como \u00e9ste.</p> MainSalida <pre><code>public class Map{\n\n    public void show(){\n        Stream.of(20, 27, 31)\n            .map(n -&gt; \"N\u00famero \" + n)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new Map().show();\n    }\n}\n</code></pre> <pre><code>N\u00famero 20\nN\u00famero 27\nN\u00famero 31\n</code></pre> </li> <li> <p>M\u00e9todos que permiten obtener un stream de un tipo primitivo a partir de uno que no lo sea:</p> <ul> <li> <p><code>DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code>: retorna un <code>DoubleStream</code> correspondiente de aplicar a cada elemento del stream original la funci\u00f3n a double recibida:</p> MainSalida <pre><code>public class MapToDouble{\n\n    public void show(){\n        Stream.of(20, 27, 31)\n            .mapToDouble(n -&gt; n * 0.5)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new MapToDouble().show();\n    }\n}\n</code></pre> <pre><code>10.0\n13.5\n15.5\n</code></pre> </li> <li> <p><code>IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper)</code>: retorna un <code>IntStream</code> correspondiente de aplicar a cada elemento del stream original la funci\u00f3n de conversi\u00f3n a int recibida. Ejemplo:</p> MainSalida <pre><code>public class MapToInt{\n\n    public void show(){\n        Stream.of(\"Ricardo\", \"Luis Miguel\", \"Paco\")\n            .mapToInt(n -&gt; n.length)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new MapToInt().show();\n    }\n}\n</code></pre> <pre><code>7\n11\n4\n</code></pre> </li> <li> <p><code>LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper)</code>: retorna un <code>LongStream</code> correspondiente de aplicar a cada elemento del stream original la funci\u00f3n de conversi\u00f3n a long recibida.</p> MainSalida <pre><code>public class MapToLong{\n\n    public void show(){\n        Stream.of(55000, 60000, 72500)\n            .mapToLong(n -&gt; (long)n * n)\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new MapToLong().show();\n    }\n}\n</code></pre> <pre><code>3025000000\n3600000000\n5256250000\n</code></pre> </li> </ul> </li> <li> <p><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code>: cuando una funci\u00f3n de transformaci\u00f3n retorna un stream y se aplica esta funci\u00f3n con el m\u00e9todo map, el stream resultante es un <code>Stream&lt;Stream&lt;Tipo&gt;&gt;</code>. En estos casos, es m\u00e1s \u00f3ptimo obtener un \u00fanico <code>Stream&lt;Tipo&gt;</code> que contuviera concatenados todos los elementos de todos los substreams. A este proceso se le conoce como aplanado (flat) de substreams.</p> MainSalida <pre><code>public class FlatMap{\n\n    public void show(){\n        Stream.of(1, 2, 3)\n            .flatMap(n -&gt; IntStream.rangeClosed(1, n).boxed())\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new FlatMap().show();\n    }\n}\n</code></pre> <pre><code>1\n1\n2\n1\n2\n3\n</code></pre> <p>En el ejemplo, muestra los valores <code>1</code> (proveniente del primer substream), <code>1</code>, <code>2</code> (provenientes del segundo substream) y <code>1</code>, <code>2</code> y <code>3</code>, provenientes del tercer substream, en este orden.</p> <p>Si nos interesa que el tipo del stream resultante fuera primitivo, podemos usar los m\u00e9todos <code>flatMapToDouble</code>, <code>flatMapToInt</code> o <code>flatMapToLong</code>.</p> MainSalida <pre><code>public class FlatMapToInt{\n\n    public void show(){\n        Stream.of(1, 2, 3)\n            .flatMapToInt(n -&gt; IntStream.rangeClosed(1, n))\n            .forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new FlatMapToInt().show();\n    }\n}\n</code></pre> <pre><code>1\n1\n2\n1\n2\n3\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-3/","title":"3 Operaciones terminales","text":""},{"location":"bloque_iii/tema_13/page-3/#reduccion-pura","title":"Reducci\u00f3n pura","text":""},{"location":"bloque_iii/tema_13/page-3/#metodos-estandar-de-reduccion","title":"M\u00e9todos est\u00e1ndar de reducci\u00f3n","text":"<ul> <li> <p><code>long count()</code>: retorna el n\u00famero de elementos de un stream. Ejemplo:</p> <pre><code>public class Count{\n\n    public void show(){\n        long howManyAreEven;\n\n        howManyAreEven = Stream.of(30, 23, 24, 57, 8, 15)\n                                .filter(n -&gt; n % 2 == 0)\n                                .count();\n\n        System.out.println(howManyAreEven); // 3\n    }\n\n    public static void main(String[] args){\n        new Count().show();\n    }\n}\n</code></pre> </li> <li> <p>Las clases <code>IntStream</code>, <code>LongStream</code> y <code>DoubleStream</code>, correspondientes a streams de elementos de tipos primitivos num\u00e9ricos, disponen del m\u00e9todo <code>sum()</code> para calcular la suma de los elementos del stream:</p> <pre><code>public class Sum{\n    public void show(){\n        int sumEvenNumbers;\n        sumEvenNumbers = IntStream.of(30, 23, 24, 57, 8, 15)\n                                .filter(n -&gt; n % 2 == 0)\n                                .sum();\n\n        System.out.println(sumEvenNumbers); // 62\n    }\n\n    public static void main(String[] args){\n        new Sum().show();\n    }\n}\n</code></pre> <p>Si disponemos de un stream gen\u00e9rico de elementos y no de un stream y no de un stream de alguna de las clases mencionadas anteriormente, podemos usar alguno de los m\u00e9todos <code>mapToInt()</code>, <code>mapToLong()</code>, <code>mapToDouble()</code>, <code>flatMapToInt()</code>, etc., para obtener un stream de un tipo espec\u00edfico. Ejemplo:</p> <pre><code>public class SumMapToInt{\n\n    public void show(){\n        int sumEvenNumbers = Stream.of(30, 23, 24, 47, 8, 15)\n                                   .filter(n -&gt; n % 2 == 0)\n                                   .mapToInt(n -&gt; n)\n                                   .sum();\n        System.out.println(sumEvenNumbers); // 62\n    }\n\n    public static void main(String[] args){\n        new SumMapToInt().show();\n    }\n}\n</code></pre> </li> <li> <p>Estas clases de streams de elementos de tipo primitivo num\u00e9rico tambi\u00e9n disponen de m\u00e9todos para obtener el valor m\u00e1xima, <code>max()</code>, el valor m\u00ednimo, <code>min()</code> y la media aritm\u00e9tica, <code>average()</code>, de los elementos num\u00e9ricos del stream. Dado que el stream sobre el que se apliquen puede estar vac\u00edo, estos m\u00e9todos retornan un Optional.</p> <pre><code>public class MaxMinAverage{\n    public void show(){\n        OptionalInt minEvenNumbers, maxEvenNumbers;\n        OptionalDouble averageEvenNumbers;\n\n        minEvenNumbers = IntStream.of(30, 23, 24, 57, 8, 15)\n                                  .filter(n -&gt; n % 2 == 0)\n                                  .min();\n\n        minEvenNumbers.ifPresent(System.out::println); // 8\n\n        maxEvenNumbers = IntStream.of(30, 23, 24, 57, 8, 15)\n                                  .filter(n -&gt; n % 2 == 0)\n                                  .max();\n\n        maxEvenNumbers.ifPresent(System.out::println); // 30\n\n        averageEvenNumbers = IntStream.of(30, 23, 24, 57, 8, 15)\n                                     .filter(n -&gt; n % 2 == 0)\n                                     .average();\n\n        averageEvenNumbers.ifPresent(n -&gt; System.out.printf(\"%.2f\", n)); //20,67\n    }\n\n    public static void main(String[] args){\n        new MaxMinAverage().show();\n    }\n}\n</code></pre> <p>Si se trata de un stream gen\u00e9rico, tenemos disponibles m\u00e9todos para calcular el m\u00e1ximo y el m\u00ednimo que reciben un Comparator para comparar los elementos del stream y as\u00ed obtener en cada caso el valor m\u00ednimo o el m\u00e1ximo:</p> <ul> <li><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></li> <li><code>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)</code></li> </ul> <pre><code>public class MaxMinComparator{\n\n    public void show(){\n        Optional&lt;Vehicle&gt; minVehicle;\n        Optional&lt;Vehicle&gt; maxVehicle;\n\n        List&lt;Vehicle&gt; list = new ArrayList&lt;&gt;();\n        list.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\n        list.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n\n        System.out.println(\"Veh\u00edculo con menor n\u00famero de ruedas: \");\n        minVehicle = list.stream()\n                         .min(Comparator.comparingInt(Vehicle::getWheelCount));\n\n        minVehicle.ifPresent(System.out::println);\n\n        System.out.println(\"Veh\u00edculo con mayor matr\u00edcula alfab\u00e9ticamente\");\n\n        maxVehicle = list.stream()\n                         .max(Comparator.comparing(Vehicle::getRegistration));\n\n        maxVehicle.ifPresent(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new MaxMinComparator().show();\n    }\n}\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-3/#metodos-reduce","title":"M\u00e9todos reduce","text":"<p>\u00bfY si queremos realizar una operaci\u00f3n de reducci\u00f3n distinta a las anteriores? Para casos m\u00e1s gen\u00e9ricos usaremos el m\u00e9todo <code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code> que recibe una funci\u00f3n acumuladora. La funci\u00f3n acumuladora debe ser una funci\u00f3n asociativa, es decir, da igual en qu\u00e9 orden se opere con los elementos porque siempre se va a obtener el mismo resultado. Se trata de una regla que se cumple en la suma y en la multiplicaci\u00f3n. Por ejemplo, <code>1+2+3</code> da el mismo resultado que <code>2+3+1</code>.</p> <p>En este caso, el proceso de reducci\u00f3n comienza cuando se obtiene el segundo elemento, ya que necesitamos al menos dos elementos para hacer la primera reducci\u00f3n. Por este motivo, el m\u00e9todo retorna un <code>Optional</code>, dado que si el stream no tiene elementos suficientes no se puede realizar la reducci\u00f3n ni producir ning\u00fan valor.</p> <pre><code>public class Reduce{\n\n    public void show(){\n        OptionalInt integerSum = IntStream.of(30, 23, 24, 57, 8, 15)\n                                          .reduce((subtotal, element) -&gt; subtotal + element);\n\n        integerSum.ifPresent(System.out::println); // 157\n\n        integerSum = IntStream.of(30, 23, 24, 57, 8, 15)\n                              .reduce(Integer::sum);\n\n        integerSum.ifPresent(System.out::println); // 157\n\n        integerSum = IntStream.empty()\n                              .reduce(Integer::sum);\n\n        System.out.println(integerSum); // OptionalInt.empty\n        integerSum.ifPresent(System.out::println); // No hace nada\n    }\n\n    public static void main(String[] args){\n        new Reduce().show();\n    }\n}\n</code></pre> <p>Este m\u00e9todo est\u00e1 sobrecargado para pasarle como primer par\u00e1metro un valor conocido como identidad (identity), que es usado como valor inicial de la operaci\u00f3n de reducci\u00f3n y el resultado por defecto si el stream est\u00e1 vac\u00edo: <code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code>.</p> <p>Debemos elegir cuidadosamente el valor de identity atendiendo a la operaci\u00f3n que se lleve a cada en la funci\u00f3n binaryOperator. El valor de identity debe ser una identidad para la funci\u00f3n acumuladora, es decir, si se aplica la funci\u00f3n acumuladora a cualquier elemento con la identidad, debe devolver el mismo elemento. Por ejemplo, si utilizamos como operaci\u00f3n una suma, la identidad debe ser 0 ya que cualquier n\u00famero al que le sumemos 0, nos devuelve el mismo n\u00famero. Por el mismo razonamiento, si la operaci\u00f3n es una multiplicaci\u00f3n, la identidad sobre ser 1.</p> <pre><code>public class ReduceIdentity{\n\n    public void show(){\n        Integer sum, mult;\n\n        sum = IntStream.of(30, 23, 24, 57, 8, 15)\n                       .reduce(0, Integer::sum);\n\n        System.out.println(sum); // 157\n\n        sum = IntStream.empty()\n                       .reduce(0, Integer::sum);\n\n        System.out.println(sum); // 0\n\n        mult = IntStream.of(2, 3, 4)\n                        .reduce(1, (subtotal, element) -&gt; subtotal * element);\n\n        System.out.println(mult); // 24\n\n        mult = IntStream.of(2, 3, 4)\n                        .reduce(1, Math::multiplyExact);\n\n        System.out.println(mult); // 24\n\n        mult = IntStream.empty()\n                        .reduce(1, Math::multiplyExact);\n\n        System.out.println(mult); // 1\n    }\n\n    public static void main(String[] args){\n        new ReduceIdentity().show();\n    }\n}\n</code></pre> <p>Tenemos disponible una tercera versi\u00f3n del m\u00e9todo, <code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, u&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code>, especialmente \u00fatil para streams paralelos, que se usa cuando queremos que el m\u00e9todo retorne un valor de tipo diferente al del stream original. La funci\u00f3n combiner es necesaria para indicar c\u00f3mo se deben combinar acumuladores parciales realizadas en distintos hilos en streams paralelos.</p> <pre><code>public class ReduceCombiner{\n\n    public void show(){\n        int count = Stream.of(\"Juan\", \"Pepe\", \"Luis\", \"Ricardo\", \"Laura\")\n                          .reduce(0, (subtotal, element) -&gt; {\n                                if(element.length() % 2 == 0){\n                                    return subtotal + 1;\n                                } else {\n                                    return subtotal;\n                                }\n                            }, Integer::sum);\n\n        System.out.printf(\"Cu\u00e1ntos nombres con n\u00famero de caracteres pares: %d\", count); // 3\n    }\n\n    public static void main(String[] args){\n        new ReduceCombiner().show();\n    }\n}\n</code></pre> <p>Debemos tener encuentra que la funci\u00f3n <code>reduce()</code> en cualquiera de sus versiones respeta el orden del stream a la hora de combinar los c\u00e1lculos intermedios.</p>"},{"location":"bloque_iii/tema_13/page-3/#operaciones-terminales-de-consulta","title":"Operaciones terminales de consulta","text":"<p>La clase <code>Stream</code> tambi\u00e9n proporciona una serie de m\u00e9todos de consulta sobre los elementos de un stream, denominadas operaciones de cortocircuito (short-circuit terminal operators). Se llaman as\u00ed porque se deja de procesar el resto de elementos si con los elementos que ya han sido procesados se es capaz de determinar el resultado.</p> <p>Tenemos un conjunto de m\u00e9todos que permiten consultar, respectivamente, si todos, ninguno o algunos de los elementos del stream cumplen con un determinado predicado, retornado un valor booleano:</p> <ul> <li><code>boolean allMatch(Predicate&lt;? super T&gt; predicate)</code></li> <li><code>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</code></li> <li><code>boolean anyMatch(Predicate&lt;? super T&gt; predicate)</code></li> </ul> <pre><code>public class Match{\n\n    public void show(){\n        boolean match;\n\n        match = IntStream.of(1, 2, 4).allMatch(n -&gt; n % 2 == 0);\n\n        System.out.println(match); // false\n\n        match = IntStream.of(2, 4, 6).allMatch(n -&gt; n % 2 == 0);\n\n        System.out.println(match); // true\n\n        match = IntStream.of(1, 2, 4).noneMatch(n -&gt; n % 2 == 0);\n\n        System.out.println(match); // false\n\n        match = IntStream.of(1, 3, 5).noneMatch(n -&gt; n % 2 == 0);\n\n        System.out.println(match); // true\n\n        match = IntStream.of(1, 3, 5).anyMatch(n -&gt; n % 2 == 0);\n\n        System.out.println(match); // false\n\n        match = IntStream.of(2, 3, 5).anyMatch(n -&gt; n % 2 == 0);\n\n        System.out.println(match); // true\n    }\n\n    public static void main(String[] args){\n        new Match().show();\n    }\n}\n</code></pre> <p>Por otro lado tenemos los m\u00e9todos <code>findFirst()</code> y <code>findAny()</code>, que retornan un <code>Optional&lt;T&gt;</code> con, respectivamente, el primer elemento del stream, o alg\u00fan elemento del stream (no est\u00e1 indicado cu\u00e1l), si es que existe. Un aspecto curioso es que estos m\u00e9todos no reciben ning\u00fan predicado con el que indicar la condici\u00f3n de b\u00fasqueda por lo que normalmente se usan despu\u00e9s de haber ejecutarlo el m\u00e9todo <code>filter</code> sobre el stream.</p> <pre><code>public class Find{\n    public void show(){\n        Optional&lt;Integer&gt; find;\n\n        find = Stream.of(1, 2, 4)\n                     .filter(n -&gt; n % 2 == 0)\n                     .findFirst();\n        find.ifPresent(System.out::println); // 2\n\n        find = Stream.of(6, 2, 4)\n                     .filter(n -&gt; n % 2 == 0)\n                     .findAny();\n        find.ifPresent(System.out::println); // 6\n    }\n\n    public static void main(String[] args){\n        new Find().show();\n    }\n}\n</code></pre> <p>Un aspecto curioso es que no se proporciona ning\u00fan m\u00e9todo para obtener el \u00faltimo elemento de un stream. sin embargo, podemos obtenerlo usando el m\u00e9todo <code>skip</code> (siempre y cuando se trate de un stream finito):</p> <pre><code>public class LastElement{\n\n    public void show(){\n        List&lt;Integer&gt; list = List.of(30, 23, 24, 57, 8, 15);\n        long count = list.stream().count();\n\n        Optional&lt;Integer&gt; last = list.stream()\n                                     .skip(count - 1)\n                                     .findFirst();\n\n        last.ifPresent(System.out::println); // 15\n    }\n\n    public static void main(String[] args){\n        new LastElement().show();\n    }\n}\n</code></pre> <p>Otra manera de hacerlo es mediante la reducci\u00f3n en la que siempre nos quedemos con el segundo elemento:</p> <pre><code>public class LastReduce{\n\n    public void show(){\n        OptionalInt last;\n\n        last = IntStream.of(30, 23, 24, 57, 8, 15)\n                        .reduce((first, second) -&gt; second);\n\n        last.ifPresent(System.out::println); // 15\n    }\n\n    public static void main(String[] args){\n        new LastElement().show();\n    }\n}\n</code></pre> <p>Debemos tener en cuenta que si ejecutamos estos m\u00e9todos sobre streams paralelos el resultado puede ser distinto entre distintas llamadas.</p>"},{"location":"bloque_iii/tema_13/page-4/","title":"4 Reducci\u00f3n mutable","text":""},{"location":"bloque_iii/tema_13/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>La operaci\u00f3n de recolecci\u00f3n es una operaci\u00f3n terminal que permite crear una estructura de datos con los resultados del procesamiento de datos asociado a un stream. La operaci\u00f3n de recolecci\u00f3n tambi\u00e9n recibe el nombre de operaci\u00f3n de reducci\u00f3n mutable. Para llevarla a cabo usaremos el m\u00e9todo <code>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</code></p> <p>El m\u00e9todo recibe un objeto de una clase que implemente la interfaz <code>Collector</code>. Aunque podemos crear nuestras propias clases que implementen dicha interfaz, en la mayor\u00eda de las ocasiones podremos utilizar alguno de los recolectores est\u00e1ndar proporcionados por Java a trav\u00e9s de la clase auxiliar <code>Collectors</code>, que contiene m\u00e9todos est\u00e1ticos que retornan objetos <code>Collector</code> correspondientes a los recolectores m\u00e1s habituales. Todos estos m\u00e9todos est\u00e1n dise\u00f1ados para funcionar de manera \u00f3ptima incluso con streams paralelos.</p>"},{"location":"bloque_iii/tema_13/page-4/#recolectores-a-estructuras-de-datos-clasicas","title":"Recolectores a estructuras de datos cl\u00e1sicas","text":"<p>La clase <code>Collectors</code> tiene un conjunto de m\u00e9todos est\u00e1ticos que nos permiten recolectar los elementos de un stream y almacenarlos en una estructura de datos:</p> <ul> <li><code>public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</code>: retorna una lista con los elementos del stream. En Java 16, se ha incorporada tambi\u00e9n un m\u00e9todo <code>toList()</code> a la interfaz <code>Stream&lt;T&gt;</code>.</li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toUnmodifiableList()</code>: retorna una lista inmutable de los elementos del stream en el orden en que son producidos (encounter order).</li> <li> <p><code>public static &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</code>: el problema de <code>toList()</code> y <code>toSet()</code> es que no podemos especificar la implementaci\u00f3n concreta que queremos que se use. Por ejemplo, no podemos indicar que se use un <code>LinkedList</code>, en el caso de <code>toList()</code>, o un <code>TreeSet</code>, en el caso de <code>toSet()</code>.</p> <p>Para solucionar este problema, el m\u00e9todo recibe un supplier que retorna la estructura de datos concreta en la que queremos que se recolecte el stream.</p> <pre><code>public class CollectorsClassicDataStructures{\n\n    public void show(){\n        List&lt;Integer&gt; list = List.of(3, 6, 1, 2, 4, 5);\n        List&lt;Integer&gt; listEvenNumbers = list.stream()\n                                            .filter(n -&gt; n % 2 == 0)\n                                            .collect(Collectors.toList());\n\n        listEvenNumbers.forEach(System.out::println);\n\n        SortedSet&lt;Integer&gt; tree = list.stream()\n                                      .filter(n -&gt; n % 2 == 0)\n                                      .collect(Collectors.toCollection(TreeSet::new));\n        tree.forEach(System.out::println);\n    }\n\n    public static void main(String[] args){\n        new CollectorsClassicDataStructures().show();\n    }\n}\n</code></pre> </li> <li> <p><code>public static &lt;T, K, V&gt; Collector&lt;T, ?, Map&lt;K, U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper)</code>: retorna un mapa obtenido de la siguiente manera:</p> <ul> <li>Con el <code>Function</code> keyMapper obtiene la clave, de manera que su valor de retorno ser\u00e1 usado como clave del elemento en el mapa resultante. Como el mapa resultante no puede tener claves repetidas, si retoma el mismo valor para dos elementos distintos del stream, se lanzar\u00e1 la excepci\u00f3n <code>IllegalStateException</code></li> <li>Con el <code>Function</code> valueMapper se obtiene el valor del elemento en el mapa resultante.</li> </ul> <pre><code>public class CollectorsToMap{\n\n    public void show(){\n        Map&lt;String, Vehicle&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[6];\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n\n        map = Arrays.stream(vehicles)\n                .collect(Collectors.toMap(Vehicle::getRegistration, vehicle-&gt; vehicle));\n\n        map.forEach((k, v) -&gt; System.out.printf(\"Clave:%s Valor:%s\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new CollectorsToMap().show();\n    }\n}\n</code></pre> <p>Si nos fijamos en el <code>Function</code> valueMapper (vehicle -&gt; vehicle), tambi\u00e9n podemos usar el m\u00e9todo est\u00e1tico <code>static &lt;T&gt; Function&lt;T,T&gt; identity()</code>, que es una funci\u00f3n que siempre devuelve su argumento de entrada:</p> <pre><code>public class FunctionIdentity{\n\n    public void show(){\n        Map&lt;String, Vehicle&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[6];\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n\n        map = Arrays.stream(vehicles)\n                    .collect(Collectors.toMap(Vehicle::getRegistration, Function.identity()));\n\n        map.forEach((k, v) -&gt; System.out.printf(\"Clave:%s Valor:%s\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new FunctionIdentity().show();\n    }\n}\n</code></pre> <p>Tenemos disponible una segunda versi\u00f3n del m\u00e9todo para que en lugar de lanzar una excepci\u00f3n, proporcionemos una funci\u00f3n de combinaci\u00f3n de elementos con la misma clave:</p> </li> <li> <p><code>public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K, U&gt;&gt; yoMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)</code>: el tercer par\u00e1metro indica c\u00f3mo de deben combinar dos elementos con la misma clave.</p> MainSALIDA <pre><code>public class CombinationRepeatedKeys{\n    public void show(){\n        Map&lt;String, String&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[6];\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"rojo\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"azul\");\n\n        map = Arrays.stream(vehicles)\n                .collect(Collectors.toMap(\n                        Vehicle::getColour, \n                        Vehicle::getRegistration,\n                        (r1, r2) -&gt; String.format(\"Clave:%-7s Valor: %s\\n\", r1, r2)\n                    )\n                );\n\n        map.forEach((k, v) -&gt; System.out.printf(\"Clave:%-7s Valor:%s\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new CombinationRepeatedKeys().show();\n    }\n}\n</code></pre> <pre><code>Clave:rojo Valor:1235GTR-5930POI\nClave:blanco Valor:1705UBG\nClave:verde Valor:7314QWE\nClave:azul Valor:9685KMX-3495JZA\n</code></pre> <p>Estas dos versiones del m\u00e9todo <code>toMap</code> retornan por defecto un <code>HashMap</code>, por lo que existe una tercera versi\u00f3n para obtener una implementaci\u00f3n distinta de la interfaz <code>Map</code>, como por ejemplo <code>LinkedHashMap</code> o <code>TreeMap</code>:</p> </li> <li> <p><code>public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt; Collector &lt;T, ?, M&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapFactory)</code>: recibe un <code>Supplier</code> como cuarto par\u00e1metro para indicar el tipo de mapa que se quiere obtener:</p> <pre><code>public class CombinationRepeatedKeysSupplier{\n    public void show(){\n        Map&lt;String, Vehicle&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[6];\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"rojo\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"azul\");\n\n\n        map = Arrays.stream(vehicles)\n                    .collect(Collectors.toMap(Vehicle::getColour, Vehicle::getRegistration,\n                        (r1, r2) -&gt; String.format(\"%s-%s\", r1, r2), TreeMap::new));\n\n        map.forEach((k, v) -&gt; System.out.printf(\"Clave:%-7s Valor:%s\\n\", k,v));\n    }\n\n    public static void main(String[] args){\n        new CombinationRepeatedKeys().show();\n    }\n}\n</code></pre> </li> <li> <p>Recolecci\u00f3n de un stream hacia un array: no se realizar\u00e1 a trav\u00e9s de ning\u00fan recolector, ni del m\u00e9todo <code>collect</code>, sino directamente a trav\u00e9s del m\u00e9todo <code>toArray()</code>de la clase <code>Stream</code>, que retorna un <code>Object[]</code>, es decir un array de elementos de la clase <code>Objecto</code>, debido a que los arrays no usan gen\u00e9ricos.</p> <pre><code>public class ToArray{\n\n    public void show(){\n\n        List&lt;Vehicle&gt; list = new ArrayList&lt;&gt;();\n        list.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        list.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        list.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        list.add(new Vehicle(\"5930POI\", 2, \"negro\"));\n        list.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\n        list.add(new Vehicle(\"3495JZA\", 2, \"naranja\"));\n\n        Object vehiclesArray[] = list.stream().toArray();\n\n        for(Object v: vehiclesArray){\n            System.out.println(v);\n        }\n    }\n\n    public static void main(String[] args){\n        new ToArray().show();\n    }\n}\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-4/#recolectores-de-operaciones-de-reduccion-basicas","title":"Recolectores de operaciones de reducci\u00f3n b\u00e1sicas","text":"<p>La clase <code>Collectors</code> dispone adem\u00e1s de una serie de m\u00e9todos est\u00e1ticos que retornan recolectores parecidos a las operaciones de reducci\u00f3n:</p> <ul> <li> <p><code>counting()</code>: Para obtener el n\u00fameros de elementos.</p> <pre><code>public class CollectorsCounting{\n\n    public void show(){\n        long howManyAreEven = Stream.of(30, 23, 24, 57, 8, 15)\n                                    .filter(n -&gt; n % 2 == 0)\n                                    .collect(Collectors.counting());\n    }\n\n    public static void main(String[] args){\n        new CollectorsCounting().show();\n    }\n}\n</code></pre> </li> <li> <p>Para obtener la sumar de los elementos que son convertidos al tipo indicado mediante la funci\u00f3n suministrada:</p> <ul> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code></li> </ul> <pre><code>public class CollectorsSumming{\n\n    public void show(){\n        List&lt;Vehicles&gt; list = new ArrayList&lt;&gt;();\n        list.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\n        list.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\n        list.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\n        list.add(new Vehicle(\"5930POI\", 2, \"negro\"));\n        list.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\n        list.add(new Vehicle(\"3495JZA\", 2, \"naranja\"));\n\n        int sumWheels = list.stream()\n                            .collect(Collectors.summingInt(Vehicle::getWheelCount));\n\n        System.out.println(sumWheels); // 18\n    }\n\n    public static void main(String[] args){\n        new CollectorsSumming().show();\n    }\n}\n</code></pre> </li> <li> <p>Para obtener el valor m\u00ednimo y el m\u00e1ximo atendiendo a un comparador pasado como argumento.</p> <ul> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator)</code></li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator)</code></li> </ul> <pre><code>public class CollectorsMinMax{\n\n    public void show(){\n        Optional&lt;Integer&gt; min, max;\n\n        List&lt;Integer&gt; list = List.of(30, 23, 24, 57, 8, 15);\n\n        min = list.stream()\n                  .collect(Collectors.minBy(Comparator.naturalOrder()));\n\n        min.ifPresent(System.out::println); // 8\n\n        max = list.stream()\n                  .collect(Collectors.maxBy(Comparator.naturalOrder()));\n\n        max.ifPresent(System.out::println); // 57\n    }\n\n    public static void main(String[] args){\n        new CollectorsMinMax().show();\n    }\n}\n</code></pre> </li> <li> <p>Para obtener la media aritm\u00e9tica de los valores (que son convertidos al tipo indicado mediante la funci\u00f3n suministrada). Si el stream no tiene elementos retorna cero:</p> <ul> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code></li> </ul> <pre><code>public class CollectorsAveraging{\n\n    public void show(){\n        double average;\n        List&lt;Integer&gt; list = List.of(30, 23, 24, 57, 8, 15);\n        average = list.stream()\n                      .collect(Collectors.averagingInt(Integer::intValue));\n        System.out.printf(\"%.2f\", average); //26,17\n    }\n\n    public static void main(String[] args){\n        new CollectorsAveraging().show();\n    }\n}\n</code></pre> </li> <li> <p>Para obtener todo lo anterior (n\u00famero de elementos, suma, m\u00ednimo, m\u00e1ximo y la media) de una sola vez:</p> <ul> <li><code>public static&lt;T&gt; Collector(T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static&lt;T&gt; Collector(T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static&lt;T&gt; Collector(T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code></li> </ul> MainSALIDA <pre><code>    public class Summarizing{\n\n    public void show(){\n        IntSummaryStatistics oddStatistics = Stream.of(30, 23, 24, 57, 8, 15)\n                                                   .filter(n -&gt; n % 2 != 0)\n                                                   .collect(Collectors.summarizingInt(Integer::intValue));\n        System.out.println(oddStatistics);\n    }\n\n    public static void main(String[] args){\n        new Summarizing().show();\n    }\n}\n</code></pre> <pre><code>IntSummaryStatistics{count=3, sum=95, min=15, average=31,666667,max=57}\n</code></pre> </li> <li> <p>Para recolectar con una operaci\u00f3n de reducci\u00f3n distinta de las anteriores: <code>public static &lt;T&gt; Collector&lt;T,?,Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)</code></p> <pre><code>public class CollectorsReducing {\n\n    public void show() {\n\n        Optional&lt;Integer&gt; integerSum = Stream.of(30, 23, 24, 57, 8, 15)\n                                             .collect(Collectors.reducing((subtotal,element) -&gt; subtotal + element));//Con lambda\n\n        integerSum.ifPresent(System.out::println);//157\n\n        integerSum = Stream.of(30, 23, 24, 57, 8, 15)\n                            .collect(Collectors.reducing(Integer::sum));//Con referencia a m\u00e9todo\n        integerSum = Stream.&lt;Integer&gt;empty().collect(Collectors.reducing(Integer::sum));//Optional.empty\n        integerSum.ifPresent(System.out::println);//No hace nada\n    }\n\n    public static void main(String[] args) {\n        new CollectorsReducing().show();\n    }\n}\n</code></pre> </li> </ul> <p>Tambi\u00e9n tenemos otra versi\u00f3n del m\u00e9todo que recibe como primer par\u00e1metro el valor correspondiente a la identidad: <code>public static &lt;T&gt; Collector&lt;T,?,T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)</code></p> <pre><code>public class CollectorsReducingIdentity {\n    public void show() {\n        Integer sum,mult;\n\n        sum = Stream.of(30, 23, 24, 57, 8, 15).collect(Collectors.reducing(0, Integer::sum));\n        System.out.println(sum);//157\n\n        sum = Stream.&lt;Integer&gt;empty().collect(Collectors.reducing(0, Integer::sum));\n        System.out.println(sum);//0\n\n        mult = Stream.of(2,3,4).collect(Collectors.reducing(1, Math::multiplyExact));\n        System.out.println(mult);//24\n\n        mult = Stream.&lt;Integer&gt;empty().collect(Collectors.reducing(1,Math::multiplyExact));\n        System.out.println(mult);//1\n    }\n\n    public static void main(String[] args) {\n        new CollectorsReducingIdentity().show();\n    }\n}\n</code></pre> <p>Existe adem\u00e1s una tercera versi\u00f3n del m\u00e9todo que recibe como segundo par\u00e1metro una funci\u00f3n de transformaci\u00f3n que ser\u00e1 ejecutada sobre cada elemento antes de realizar la recolecci\u00f3n: <code>public static &lt;T, U&gt; Collector&lt;T,?,U&gt; reducing(U identity, Function&lt;? super T,? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</code>:</p> <pre><code>public class CollectorsReducingCombiner {\n    public void show() {\n        int count = Stream.of(\"Juan\", \"Pepe\", \"Luis\", \"Ricardo\", \"Laura\").collect(Collectors.reducing(0, element -&gt; {\n                                                                            if(element.length() % 2 == 0) {\n                                                                            return 1;\n                                                                            }\n                                                                            else {\n                                                                            return 0;\n                                                                            }\n                                                                        }, Integer::sum));\n        System.out.printf(\"Cu\u00e1ntos nombres con n\u00famero de caracteres pares: %d\", count);//3\n    }\n\n    public static void main(String[] args) {\n        new CollectorsReducingCombiner().show();\n    }\n}\n</code></pre> <p>Como podemos apreciar, todos los recolectores vistos en este apartado son muy similares (casi iguales) a los m\u00e9todos est\u00e1ndar de reducci\u00f3n que vimos en un apartado anterior. Entonces, \u00bfpor qu\u00e9 existen estos recolectores? El motivo es que, como veremos m\u00e1s adelante, Java nos va a ofrecer la oportunidad de encadenar varios recolectores, de manera que usaremos los recolectores vistos en este apartado normalmente como acompa\u00f1ante de alg\u00fan otro recolector. De hecho, no se recomienda usar estos recolectores si no es en conjunci\u00f3n con otro recolector. Si se va a emplear de forma aislada, es m\u00e1s \u00f3ptimo emplear los m\u00e9todos est\u00e1ndar de recolecci\u00f3n que vimos en un apartado anterior.</p>"},{"location":"bloque_iii/tema_13/page-4/#recolectores-de-transformacion","title":"Recolectores de transformaci\u00f3n","text":"<ul> <li> <p><code>public  static  Collector&lt;CharSequence,?,String&gt;  joining()</code>:  permite obtener un  <code>String</code>  correspondiente a la concatenaci\u00f3n de los elementos del stream. Solo podremos usar este recolector sobre un stream de elementos de tipo <code>CharSequence</code> , por lo que es posible que antes hayamos tenido que aplicar una operaci\u00f3n de transformaci\u00f3n mediante el m\u00e9todo map  para obtener un stream adecuado.  <code>CharSequence</code>  es una interfaz que representa una secuencia de caracteres. Esta interfaz no impone la mutabilidad, por lo tanto, nos podemos encontrar con clases inmutables y mutables que implementen esta interfaz. Por ejemplo, <code>String</code>  es inmutable y <code>StringBuilder</code>  y <code>StringBuffer</code>  son mutables</p> <pre><code>public class CollectorsJoining {          \n    public void show() {\n        String result = Stream.of(\"Juan\", \"Pepe\", \"Luis\",\"Ricardo\", \"Laura\")\n                        .collect(Collectors.joining());\n\n        System.out.println(result);     \n    }\n\n    public static void main(String[] args) {         \n        new CollectorsJoining().show();     \n    } \n}\n</code></pre> <p>Existe una segunda versi\u00f3n para concatenar los elementos de entrada separados por  un  delimitador  que  se  pasa  por  par\u00e1metro: <code>public  static Collector&lt;CharSequence,?,String&gt; joining(CharSequence delimiter)</code></p> <pre><code>public class CollectorsJoiningDelimiter {     \n    public void show() {\n\n        String result = Stream.of(\"Juan\", \"Pepe\", \"Luis\",\"Ricardo\", \"Laura\")\n                    .collect(Collectors.joining(\" - \"));\n        System.out.println(result);\n    }\n\n    public static void main(String[] args) {         \n        new CollectorsJoiningDelimiter().show();     \n    } \n}\n</code></pre> <p>Existe una tercera versi\u00f3n del m\u00e9todo que permite indicar el prefijo y el sufijo que queremos poner a la cadena resultante de la concatenaci\u00f3n: <code>public  static Collector&lt;CharSequence,?,String&gt; joining(CharSequence  delimiter, CharSequence prefix,  CharSequence suffix)</code></p> <pre><code>public class CollectorsJoiningPrefixSuffix{\n    public void show(){\n        String result = Stream.of(\"Juan\", \"Pepe\", \"Luis\", \"Ricardo\", \"Laura\")\n                            .collect(Collectors.joining(\" - \", \"Lista de nombres: \", \".\"));\n\n        System.out.println(result);\n    }\n\n    public static void main(String[] args){\n        new CollectorsJoiningPrefixSuffix().show();\n    }\n}\n</code></pre> </li> <li> <p><code>public static &lt;T, U, A, R&gt; Collector&lt;T,?,R&gt; mapping(Function&lt;? super T,?  extends  U&gt;  mapper,    Collector&lt;?  super  U,A,R&gt;  downstream)</code>: realiza alguna operaci\u00f3n de transformaci\u00f3n sobre los elementos justo antes de aplicarles un recolector que se pasa por par\u00e1metro.</p> <pre><code>public class CollectorsMapping{\n\n    public void show(){\n        Vehicle vehicles[] = new Vehicle[6];\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n        String result = Arrays.stream(vehicles)\n        .collect(Collectors.mapping(Vehicle::getRegistration, Collectors.joining(\", \")));\n\n        System.out.println(result);\n    }\n\n    public static void main(String[] args){\n        new CollectorsMapping().show();\n    }\n}\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-4/#recolectores-de-agrupacion","title":"Recolectores de agrupaci\u00f3n","text":"<p><code>public  static  &lt;T,  K&gt;  Collector&lt;T,?,Map&lt;K,List&lt;T&gt;&gt;&gt;  groupingBy(Function&lt;? super T,? extends K&gt; classifier)</code>: permite obtener un mapa  <code>Map&lt;K, List&lt;T&gt;&gt;</code> donde las claves son los valores resultantes de aplicar la funci\u00f3n de clasificaci\u00f3n a los elementos de entrada y los valores son listas que contienen los elementos de entrada que al aplicarles la funci\u00f3n de clasificaci\u00f3n se obtiene la clave correspondiente, es decir, todos aquellos elementos del stream original que al aplicarles la funci\u00f3n clasificadora retornen el mismo valor, dicho valor ser\u00e1 la clave y los elementos ser\u00e1n agrupados en la misma lista con dicha clave. Veamos un ejemplo: vamos a crear un mapa donde la clave ser\u00e1 el n\u00famero de ruedas del veh\u00edculo. El mapa tendr\u00e1 dos entradas, una para los veh\u00edculos de 2 ruedas y otra para los veh\u00edculos de 4 ruedas. Cada clave tendr\u00e1 una lista con los veh\u00edculos que correspondan con dicho n\u00famero de ruedas:</p> <pre><code>public class CollectorsGroupingBy{\n    public void show(){\n        Map&lt;Integer, List&lt;Vehicle&gt;&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[6];\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n\n        map = Arrays.stream(vehicles)\n                    .collect(Collectors.groupingBy(Vehicle::getWheelCount));\n\n        map.forEach((k, v) -&gt; {\n            System.out.printf(\"Veh\u00edculos con %d ruedas: \\n\", k);\n\n            v.forEach(vehicle -&gt; System.out.printf(\"%s\\n\", vehicle));\n        })\n    }\n\n    public static void main(String[] args){\n        new CollectorsGroupingBy().show();\n    }\n}\n</code></pre> <p>Sin embargo, ser\u00e1 muy habitual que queramos realizar alg\u00fan c\u00e1lculo sobre la lista de elementos de cada grupo. Para hacernos m\u00e1s sencilla dicha tarea, tenemos disponible otra versi\u00f3n del m\u00e9todo: <code>public  static  &lt;T, K,  A,  D&gt;  Collector&lt;T,?,Map&lt;K,D&gt;&gt; groupingBy(Function&lt;?  super  T,?  extends  K&gt;  classifier,  Collector&lt;?  super T,A,D&gt; downstream)</code>, que recibe un recolector que queremos que se le aplique a la lista de elementos de cada grupo. Para este cometido, podemos usar los recolectores de operaciones de reducci\u00f3n b\u00e1sicas que vimos en el apartado anterior. Si lo aplicamos al ejemplo anterior, podemos obtener cu\u00e1ntos veh\u00edculos hay con 2 ruedas y cu\u00e1ntos hay con 4 ruedas:</p> <pre><code>public class CollectorsGroupingByDownstream{\n\n    public void show(){\n        Map&lt;Integer, Long&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[6];\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n\n        map = Arrays.stream(vehicles)\n                    .collect(Collectors.groupingBy(Vehicle::getWheelCount, Collectors.counting()));\n\n        map.forEach((k, v) -&gt; System.out.printf(\"N\u00famero de veh\u00edculos con %d ruedas: %d\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new CollectorsGroupingByDownstream().show();\n    }\n}\n</code></pre> <p>Estas dos versiones del m\u00e9todo <code>groupingBy</code>  retornan por defecto un <code>HashMap</code>, por lo que existe una tercera versi\u00f3n para obtener una implementaci\u00f3n distinta de la interfaz <code>Map</code>, como por ejemplo <code>LinkedHashMap</code> o <code>TreeMap</code> : <code>public static &lt;T, K, D, A, M  extends  Map&lt;K,  D&gt;&gt;  Collector&lt;T,?,M&gt;  groupingBy(Function&lt;?  super  T,? extends K&gt; classifier,  Supplier&lt;M&gt; mapFactory,  Collector&lt;? super T,A,D&gt; downstream)</code>:</p> <pre><code>public class CollectorsGroupingBySupplier{\n\n    public void show(){\n        Map&lt;Integer, Long&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[6];\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n\n        map = Arrays.stream(vehicles)\n                    .collect(Collectors.groupingBy(Vehicle::getWheelCount, LinkedHashMap::new,\n                    Collectors.counting()));\n\n        map.forEach((k, v) -&gt; System.out.printf(\"N\u00famero de veh\u00edculos con %d ruedas: %d\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new CollectorsGroupingBySupplier().show();\n    }\n}\n</code></pre> <p>\u00bfY si queremos realizar alguna operaci\u00f3n de conversi\u00f3n sobre los elementos de la lista de cada grupo antes de aplicarle el recolector downstream? Podemos usar el m\u00e9todo <code>Collectors.mapping</code> que ya conocemos:</p> <pre><code>public class CollectorsGroupingByMapping{\n\n    public void show(){\n        Map&lt;Integer, String&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[6];\n        vehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\n        vehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\n        vehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\n        vehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\n        vehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\n        vehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\n\n        map = Arrays.stream(vehicles)\n                    .collect(Collectors.groupingBy(Vehicle::getWheelCount, TreeMap::new,\n                    Collectors.mapping(Vehicle::getRegistration, \n                    Collectors.joining(\" - \"))));\n\n        map.forEach((k, v) -&gt; System.out.printf(\"Matr\u00edculas con %d ruedas: %s\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new CollectorsGroupingByMapping().show();\n    }\n}\n</code></pre> <p>Si la funci\u00f3n de transformaci\u00f3n retorna un stream, podemos usar <code>public static &lt;T, U, A, R&gt; Collector&lt;T,?,R&gt; flatMapping(Function&lt;? super T,? extends Stream&lt;? extends U&gt;&gt; mapper,  Collector&lt;? super U,A,R&gt; downstream)</code> disponible a partir de Java 9.</p> <p>Por ejemplo, vamos a cambiar la clase Vehicle para registrar modelos de coches con un determinado n\u00famero de ruedas y una lista de todos los colores en los que est\u00e1 disponible dicho modelo, y si quisi\u00e9ramos obtener de cada n\u00famero de ruedas cu\u00e1ntos colores hay disponible podr\u00edamos hacer lo siguiente:</p> VehicleMainSalida <pre><code>public class Vehicle{\n    private String model;\n    private int wheelCount;\n    private List&lt;String&gt; colors;\n\n    public Vehicle(String model, int wheelCount, List&lt;String&gt; colors){\n        this.model = model;\n        this.wheelCount = wheelCount;\n        this.colors = colors;\n    }\n\n    public String getModel(){\n        return model;\n    }\n\n    public int getWheelCount(){\n        return wheelCount;\n    }\n\n    public List&lt;String&gt; getColors(){\n        return colors;\n    }\n}\n</code></pre> <pre><code>public class CollectorsGroupingByMapping{\n    public void show(){\n        Map&lt;Integer, List&lt;Object&gt;&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[4];\n\n        vehicles[0] = new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\", \"blanco\"));\n        vehicles[1] = new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\"));\n        vehicles[2] = new Vehicle(\"Audi\", 2, List.of(\"negro\", \"verde\"));\n        vehicles[3] = new Vehicle(\"Ford\", 2, List.of(\"negro\", \"blanco\"));\n\n        map = Arrays.stream(vehicles)\n                    .collect(Collectors.groupingBy(Vehicle::getWheelCount, TreeMap::new,\n                    Collectors.mapping(v -&gt; v.getColors(), Collectors.toList())));\n\n        map.forEach((k,v) -&gt; System.out.printf(\"N\u00famero de ruedas: %d Colores: %s\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new CollectorsGroupingByMapping().show();\n    }\n}\n</code></pre> <pre><code>N\u00famero de ruedas: 2 Colores: [[negro, verde], [negro, blanco]]\nN\u00famero de ruedas: 4 Colores: [[azul, rojo, blanco], [naranja, blanco]]\n</code></pre> <p>Si nos fijamos en la salida de consola, salen las sublistas. Para quitarlas, podemos pasar estas listas a streams y luego utilizar el m\u00e9todo flatMapping  para aplanarlas:</p> MainSalida <pre><code>public class CollectorsGroupingByFlatMapping{\n    public void show(){\n        Map&lt;Integer, String&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[4];\n\n        vehicles[0] = new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\", \"blanco\"));\n        vehicles[1] = new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\"));\n        vehicles[2] = new Vehicle(\"Audi\", 2, List.of(\"negro\", \"verde\"));\n        vehicles[3] = new Vehicle(\"Ford\", 2, List.of(\"negro\", \"blanco\"));\n\n        map = Arrays.stream(vehicles)\n                .collect(Collectors.groupingBy(Vehicle::getWheelCount, TreeMap::new,\n                        Collectors.flatMapping(v -&gt; v.getColors().stream(), Collectors.joining(\"-\"))));\n\n        map.forEach((k,v) -&gt; System.out.printf(\"N\u00famero de ruedas: %d Colores: %s\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new CollectorsGroupingByFlatMapping().show();\n    }\n}\n</code></pre> <pre><code>N\u00famero de ruedas: 2 Colores: negro-verde-negro-blanco\nN\u00famero de ruedas: 4 Colores: azul-rojo-blanco-naranja-blanco\n</code></pre> <p>Ahora nos encontramos con colores repetidos. Para quitarlos, podemos hacer uso del m\u00e9todo  <code>public  static  &lt;T,  A,  R,  RR&gt;  Collector&lt;T,A,RR&gt; collectingAndThen(Collector&lt;T,A,R&gt;  downstream,  Function&lt;R,RR&gt;  finisher)</code>.Este  m\u00e9todo recolecta y despu\u00e9s se puede realizar un Function sobre el resultado de la recolecci\u00f3n.</p> MainSalida <pre><code>public class CollectorsGroupingByCollectingAndThen{\n    public void show(){\n        Map&lt;Integer, String&gt; map;\n\n        Vehicle[] vehicles = new Vehicle[4];\n\n        vehicles[0] = new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\", \"blanco\"));\n        vehicles[1] = new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\"));\n        vehicles[2] = new Vehicle(\"Audi\", 2, List.of(\"negro\", \"verde\"));\n        vehicles[3] = new Vehicle(\"Ford\", 2, List.of(\"negro\", \"blanco\"));\n\n        map = Arrays.stream(vehicles)\n                .collect(Collectors.groupingBy(Vehicle::getWheelCount, TreeMap::new,\n                        Collectors.collectingAndThen(Collectors.flatMapping(v -&gt;\n                                        v.getColors().stream(), Collectors.toList()),\n                                list -&gt; list.stream().distinct().collect(Collectors.joining(\"-\")))));\n\n        map.forEach((k,v) -&gt; System.out.printf(\"N\u00famero de ruedas: %d Colores: %s\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new CollectorsGroupingByCollectingAndThen().show();\n    }\n}\n</code></pre> <pre><code>N\u00famero de ruedas: 2 Colores: negro-verde-blanco\nN\u00famero de ruedas: 4 Colores: azul-rojo-blanco-naranja\n</code></pre> <p>En otras ocasiones, lo que queremos es filtrar los elementos de cada lista en base a alg\u00fan criterio, antes de aplicarle el recolector downstream. Para ello, Java 9 incorpor\u00f3 el m\u00e9todo <code>public  static  &lt;T,  A,  R&gt;  Collector&lt;T,?,R&gt;  filtering(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T,A,R&gt; downstream)</code>:</p> MainSalida <pre><code>public class CollectorsGroupingByFiltering{\n    public void show(){\n        Map&lt;String, List&lt;Vehicle&gt;&gt; map;\n\n\n        List&lt;Vehicle&gt; vehicles = new ArrayList&lt;&gt;();\n\n        vehicles.add(new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\")));\n        vehicles.add(new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\")));\n        vehicles.add(new Vehicle(\"Audi\", 2, List.of(\"negro\", \"verde\")));\n        vehicles.add(new Vehicle(\"Ford\", 2, List.of(\"amarillo\", \"blanco\")));\n\n        map = vehicles.stream()\n                    .collect(Collectors.groupingBy(Vehicle::getModel,\n                    Collectors.filtering(v -&gt; v.getWheelCount() == 4, Collectors.toList())));\n\n        map.forEach((k,v) -&gt; System.out.printf(\"Modelo: %s Veh\u00edculos de 4 ruedas: %s\\n\", k, v));\n    }\n\n    public static void main(String[] args){\n        new CollectorsGroupingByFiltering().show();\n    }\n}\n</code></pre> <pre><code>Modelo:Audi Veh\u00edculos de 4 ruedas: [Vehicle [model=Audi, wheelCount=4,\nspeed=0.0, colors=[azul, rojo]]]\nModelo:Ford Veh\u00edculos de 4 ruedas: [Vehicle [model=Ford, wheelCount=4,\nspeed=0.0, colors=[naranja, blanco]]]\n</code></pre> <p>Se pueden crear varios niveles de agrupamiento, aplicando  groupingBy  como recolector downstream de los elementos de cada grupo:</p> MainSalida <pre><code>public class CollectorsVariousLevelsOfGroupingBy{\n\n    public void show(){\n        Map&lt;String, Map&lt;Integer, Long&gt;&gt; map;\n\n        List&lt;Vehicle&gt; vehicles = new ArrayList();\n\n        vehicles.add(new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\")));\n        vehicles.add(new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\", \"verde\")));\n        vehicles.add(new Vehicle(\"Seat\", 4, List.of(\"amarillo\", \"verde\")));\n        vehicles.add(new Vehicle(\"Audi\", 2, List.of(\"negro\")));\n        vehicles.add(new Vehicle(\"Ford\", 2, List.of(\"rojo\", \"blanco\")));\n        vehicles.add(new Vehicle(\"Seat\", 2, List.of(\"amarillo\", \"morado\")));\n\n        map = vehicles.stream()\n                .collect(Collectors.groupingBy(Vehicle::getModel,\n                        Collectors.groupingBy(Vehicle::getWheelCount,\n                                Collectors.flatMapping(v -&gt; v.getColors().stream(),\n                                        Collectors.counting()))));\n        map.forEach((k,v) -&gt; {\n            v.forEach((k2, v2) -&gt; {\n                System.out.printf(\"Modelo %s con %d ruedas est\u00e1 disponible en %d %s\\n\", k, k2, v2,\n                        v2 == 1 ? \"color\" : \"colores\");\n            });\n        });\n    }\n\n    public static void main(String[] args){\n        new CollectorsVariousLevelsOfGroupingBy().show();\n    }\n}\n</code></pre> <pre><code>Modelo Seat con 2 ruedas est\u00e1 disponible en 2 colores\nModelo Seat con 4 ruedas est\u00e1 disponible en 2 colores\nModelo Audi con 2 ruedas est\u00e1 disponible en 1 color\nModelo Audi con 4 ruedas est\u00e1 disponible en 2 colores\nModelo Ford con 2 ruedas est\u00e1 disponible en 2 colores\nModelo Ford con 4 ruedas est\u00e1 disponible en 3 colore\n</code></pre>"},{"location":"bloque_iii/tema_13/page-4/#recolectores-de-particionado","title":"Recolectores de particionado","text":"<p><code>public  static  &lt;T&gt;  Collector&lt;T,?,Map&lt;Boolean,List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;?  super  T&gt;  predicate)</code>: aplica  el  predicado proporcionado a cada uno de los elementos del stream y crea dos grupos, uno con los que cumplen el predicado y otro con los que no lo cumplen:</p> MainSALIDA <pre><code>public class CollectorsPartitionBy{\n    public void show(){\n\n        Map&lt;Boolean, Long&gt; map;\n\n        List&lt;Vehicle&gt; vehicles = new ArrayList&lt;&gt;();\n\n        vehicles.add(new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\")));\n        vehicles.add(new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\", \"verde\")));\n        vehicles.add(new Vehicle(\"Seat\", 4, List.of(\"amarillo\", \"verde\")));\n        vehicles.add(new Vehicle(\"Audi\", 2, List.of(\"negro\")));\n        vehicles.add(new Vehicle(\"Ford\", 2, List.of(\"rojo\", \"blanco\")));\n\n\n        map = vehicles.stream()\n                .collect(Collectors.partitioningBy(vehicle -&gt; vehicle.getWheelCount() == 4, \n                        Collectors.counting()));\n\n        map.forEach((k, v) -&gt; {\n            System.out.printf(\"%s hay en %d modelos\\n\", k ? \"Veh\u00edculos de 4 ruedas\" : \"Veh\u00edculos que no son de 4 ruedas: \", v);\n        });\n    }\n\n    public static void main(String[] args){\n        new CollectorsPartitionBy().show();\n    }\n}\n</code></pre> <pre><code>Veh\u00edculos que no son de 4 ruedas:\nVehicle [model=Audi, wheelCount=2, colours=[negro, verde]]\nVehicle [model=Ford, wheelCount=2, colours=[amarillo, blanco]]\nVeh\u00edculos de 4 ruedas:\nVehicle [model=Audi, wheelCount=4, colours=[azul, rojo]]\nVehicle [model=Ford, wheelCount=4, colours=[naranja, blanco]\n</code></pre> <p>Existe otra versi\u00f3n del m\u00e9todo que recibe como segundo argumento un recolector para que sea ejecutado sobre la lista de cada grupo:</p> MainSALIDA <pre><code>public class CollectorsPartitioningByDownstream{\n    public void show(){\n\n        Map&lt;Boolean, List&lt;Vehicle&gt;&gt; map;\n\n        List&lt;Vehicle&gt; vehicles = new ArrayList&lt;&gt;();\n\n        vehicles.add(new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\")));\n        vehicles.add(new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\")));\n        vehicles.add(new Vehicle(\"Audi\", 2, List.of(\"negro\", \"verde\")));\n        vehicles.add(new Vehicle(\"Ford\", 2, List.of(\"amarillo\", \"blanco\")));\n\n        map = vehicles.stream()\n                      .collect(Collectors.partitioningBy(v -&gt; v.getWheelCount() == 4));\n\n        map.forEach((k, v) -&gt; {\n            System.out.printf(\"%s\\n\", k ? \"Veh\u00edculos de 4 ruedas\" : \"Veh\u00edculos que no son de 4 ruedas: \");\n            v.forEach(System.out::println);\n        });\n    }\n\n    public static void main(String[] args){\n        new CollectorsPartitioningByDownstream().show();\n    }\n}\n</code></pre> <pre><code>Veh\u00edculos que no son de 4 ruedas:\nVehicle [model=Audi, wheelCount=2, colours=[negro, verde]]\nVehicle [model=Ford, wheelCount=2, colours=[amarillo, blanco]]\nVeh\u00edculos de 4 ruedas:\nVehicle [model=Audi, wheelCount=4, colours=[azul, rojo]]\nVehicle [model=Ford, wheelCount=4, colours=[naranja, blanco]\n</code></pre>"},{"location":"bloque_iii/tema_13/page-4/#combinacion-de-dos-recolectores","title":"Combinaci\u00f3n de dos recolectores","text":"<p><code>public  static  &lt;T,  R1,  R2,  R&gt;  Collector&lt;T,?,R&gt;  teeing(Collector&lt;?  super T,?,R1&gt; downstream1,  Collector&lt;? super T,?,R2&gt; downstream2,  BiFunction&lt;? super R1,? super R2,R&gt; merger)</code>: ejecuta ambos recolectores sobre los elementos y despu\u00e9s ejecuta sobre los resultados la <code>BiFunction</code> proporcionada, que combinar\u00e1 ambos resultados, de manera que la combinaci\u00f3n ser\u00e1 el producto final de la recolecci\u00f3n</p> ResultMainSALIDA <pre><code>public class Result{\n    private Optional&lt;Vehicle&gt; min;\n    private Optional&lt;Vehicle&gt; max;\n\n    public Result(Optional&lt;Vehicle&gt; min, Optional&lt;Vehicle&gt; max){\n        this.min = min;\n        this.max = max;\n    }\n\n    public Optional&lt;Vehicle&gt; getMin(){\n        return min;\n    }\n\n    public Optional&lt;Vehicle&gt; getMax(){\n        return max;\n    }\n\n    @Override\n    public String toString(){\n        return String.format(\"El veh\u00edculo que tiene el m\u00ednimo n\u00famero de colores es %s\\nEl veh\u00edculo que tiene el m\u00e1ximo n\u00famero de colores es %s\\n\", min, max);\n    }\n}\n</code></pre> <pre><code>public class CollectorsTeeing{\n\n    public void show(){\n        Result result;\n\n        List&lt;Vehicle&gt; vehicles = new ArrayList&lt;&gt;();\n\n        vehicles.add(new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\")));\n        vehicles.add(new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\", \"verde\")));\n        vehicles.add(new Vehicle(\"Seat\", 4, List.of(\"amarillo\", \"verde\")));\n        vehicles.add(new Vehicle(\"Audi\", 2, List.of(\"negro\")));\n        vehicles.add(new Vehicle(\"Ford\", 2, List.of(\"rojo\", \"blanco\")));\n        vehicles.add(new Vehicle(\"Seat\", 2, List.of(\"amarillo\", \"morado\")));\n\n        result = vehicles.stream()\n                .collect(Collectors.teeing(Collectors.minBy(Comparator.comparing(v -&gt; v.getColors().size())),\n                        Collectors.maxBy(Comparator.comparing(v -&gt; v.getColors().size())),\n                        Result::new));\n        System.out.println(result);\n    }\n\n    public static void main(String[] args){\n        new CollectorsTeeing().show();\n    }\n}\n</code></pre> <pre><code>El veh\u00edculo que tiene el m\u00ednimo n\u00famero de colores es Vehicle [model=Audi, wheelCount=2, colours=[negro]]\nEl veh\u00edculo que tiene el m\u00e1ximo n\u00famero de colores es Vehicle [model=Ford, wheelCount=4, colours=[naranja, blanco, verde]]\n</code></pre> <p>Este m\u00e9todo es de la versi\u00f3n 12 de Java. En versiones anteriores, ser\u00eda necesario operar dos  veces  sobre  el  stream,  almacenar  los  resultados  intermedios  en  variables temporales y despu\u00e9s combinar las variables temporales.</p>"},{"location":"bloque_iii/tema_13/page-4/#streams-y-checked-exceptions","title":"Streams y checked exceptions","text":"<p>Las checked exceptions de Java no congenian demasiado bien con la programaci\u00f3n funcional y los stream. En el siguiente  ejemplo  vemos  como  nuestro  c\u00f3digo  queda  m\u00e1s  ofuscado  debido  a  que  estamos  obligados  a capturar la checked exception generada por el constructor de la clase <code>URL</code>:</p> <pre><code>List&lt;URL&gt; urls = Stream.of(\"www.iessaladillo.com/api\", \"www.iessaladillo.com/css\")\n                       .map(s -&gt; s.replace(\"iessaladillo.com\", \"iessaladillo.es\"))\n                       .map(url -&gt; {\n                            try{\n                              return new URL(url);\n                            } catch(Exception e){\n                              // ...\n                            }\n                        }).collect(toList());\n</code></pre> <p>Con el objeto de mejorar la claridad de nuestro c\u00f3digo, podemos crear m\u00e9todos que capturen la checked exception y la relancen como una runtime exception, tal y como hace la siguiente librer\u00eda https://gist.github.com/jomoespe/ea5c21722b693c09c38bf6286226cd92</p> <pre><code>List&lt;URL&gt; urls = Stream.of(\"www.iessaladillo.com/api\", \"www.iessaladillo.com/css\")\n                       .map(s -&gt; s.replace(\"iessaladillo.com\", \"iessaladillo.es\"))\n                       .map(rethrowFunction(URL::new))\n                       .collect(toList());\n</code></pre>"},{"location":"bloque_iii/tema_13/page-5/","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza una nueva versi\u00f3n del proyecto del tema anterior eliminando la clase <code>Stream&lt;T&gt;</code> y haciendo uso de los streams</p> Ejercicio 2 <p>En un Udemy se desea guardar informaci\u00f3n referente a los cursos que se tienen almacenado:</p> <ul> <li>El t\u00edtulo del curso</li> <li>La duraci\u00f3n expresada en horas. Si un curso dura una hora y 15 minutos se representar\u00e1 como 1,25.</li> <li>Cantidad de videos que contiene el curso</li> <li>Cantidad de alumnos subscritos al curso</li> </ul> <p>Teniendo en cuenta la siguiente informaci\u00f3n de los cursos:</p> T\u00edtulo Duraci\u00f3n Vides Alumnos Curso profesional de Java 6,5 50 200 Curso profesional de Python 8,5 60 800 Curso profesional de DB 4,5 700 700 Curso profesional de Android 7,5 10 400 Curso profesional de Escritura 1,5 10 300 <ul> <li>Obtener la cantidad de cursos con una duraci\u00f3n mayor a 5 horas.</li> <li>Obtener la cantidad de cursos con una duraci\u00f3n menor a 2 horas.</li> <li>Listar t\u00edtulo de todos aquellos cursos con una cantidad de v\u00eddeos mayor a 50.</li> <li>Mostrar en consola el t\u00edtulo de los 3 primeros cursos con mayor duraci\u00f3n.</li> <li>Mostrar en consola la duraci\u00f3n total de todos los cursos.</li> <li>Mostrar en consola todos aquellos libros que superen el promedio en cuanto a duraci\u00f3n se refiere.</li> <li>Mostrar en consola la duraci\u00f3n de todos aquellos cursos que tengan una cantidad de alumnos inscritos menor a 500.</li> <li>Obtener el curso con mayor duraci\u00f3n.</li> <li>Crear una lista con todos los t\u00edtulos de los cursos.</li> </ul> Ejercicio 3 <p>Crea una aplicaci\u00f3n Java que defina las siguientes clases:</p> <ul> <li>Student: Representa a un alumno. Dispone de los campos:<ul> <li>id: identificador de tipo long</li> <li>name: nombre del alumno de tipo String</li> <li>age: edad del alumno de tipo int</li> <li>group: grupo del alumno de tipo String</li> <li>grant: cantidad de la beca concedida de tipo Integer</li> <li>grades: notas del alumno de tipo List <li>Grade: Representa una nota. Dispone de los campos:<ul> <li>subject: nombre de la asignatura de tipo String</li> <li>mark: nota de dicha asignatura de tipo float</li> </ul> </li> <li>Database: Representa la base de datos con la que trabajaremos. Dispondr\u00e1 de un campo privado correspondiente a la lista de estudiantes. Adem\u00e1s tendr\u00e1 un m\u00e9todo p\u00fablico denominado queryAllStudents() que retornar\u00e1 la lista de alumnos.</li> <p>Inicializa la base de datos con los siguientes datos de los alumnos (en este orden):</p> ID Name Age Group Grant Grades 1 Germ\u00e1n Gin\u00e9s 23 1\u00ba CFGS DAM 2000 [PROGR, 8], [LM, 3] 2 Baldomero 21 1\u00ba CFGS DAM 0 [PROGR, 5], [LM, 4] 3 Ana Guerra 17 1\u00ba CFGS SMR 4000 [PROGR, 8] <p>Realiza en Java los m\u00e9todos necesarios para mostrar por pantalla el resto de las siguientes consultas, usando streams (y optionals cuando sea necesario).</p> <ul> <li> <p>showLegalAgeStudentCount(): Debe mostrar los alumnos que sean mayores de edad. La salida ser\u00eda:</p> <pre><code>N\u00famero de alumnos mayores de edad: 2\n</code></pre> </li> <li> <p>showStudentNamesOrderAlphabetically(): Debe mostrar los nombre de los alumnos ordenados alfab\u00e9ticamente. La salida ser\u00eda:</p> <pre><code>Nombre los alumnos (orden alfab\u00e9tico):\nAna Guerra\nBaldomero\nGerm\u00e1n Gin\u00e9s\n</code></pre> </li> <li> <p>showFirstTwoStudentsNames(): Debe mostrar los nombres de los dos primeros alumnos. La salida ser\u00eda:</p> <pre><code>Nombre de los dos primeros alumnos:\nGerm\u00e1n Gin\u00e9s\nBaldomero\n</code></pre> </li> <li> <p>showStudentsNamesExceptTheFirstOne(): Debe mostrar los nombres de todos los alumnos menos del primero, La salida ser\u00eda:</p> <pre><code>Nombres de alumnos (excepto el primero):\nBaldomero\nAna Guerra\n</code></pre> </li> <li> <p>showStudentsNamesUntilFirstNotLegalAgeOne(): Debe mostrar los nombres de todos los alumnos hasta que encuentre uno menor de edad. \u00c9ste ya no lo mostrar\u00e1. La salida ser\u00eda:</p> <pre><code>Nombres de alumnos (hasta que encontramos uno menor de edad):\nGerm\u00e1n Gin\u00e9s\nBaldomero\n</code></pre> </li> <li> <p>showStudentsSinceFirstNotLegalAgeOne(): Debe mostrar los nombres de todos los alumnos desde que encontremos uno menor de edad. \u00c9ste si lo mostrar\u00e1. La salida ser\u00eda:</p> <pre><code>Nombres de alumnos (desde que encontramos uno menor de edad):\nAna Guerra\n</code></pre> </li> <li> <p>showDifferentSubjectsOrderedAlphabetically(): Debe mostrar las asignaturas de las que hay alg\u00fan alumno matriculado, ordenadas alfab\u00e9ticamente. La salida ser\u00eda:</p> <pre><code>Asignaturas:\nLM\nPROGR\n</code></pre> </li> <li> <p>showStudentsGrantsAndSum(): Debe mostrar la beca de cada alumno y adem\u00e1s la suma de todas las becas. La salida ser\u00eda:</p> <pre><code>Becas:\nGerm\u00e1n Gin\u00e9s: 2000\nBaldomero: 0\nAna Guerra: 4000\nSuma de becas: 6000\n</code></pre> </li> <li> <p>getStudentsOlderThan20(): Debe retornar una lista con los nombres de los alumnos mayores de 20 a\u00f1os. El retorno deber\u00eda la lista:</p> <pre><code>[Germ\u00e1n Gin\u00e9s, Baldomero]\n</code></pre> </li> <li> <p>showYoungestStudentName(): Debe mostrar el nombre de alumna m\u00e1s joven. La salida ser\u00eda:</p> <pre><code>Alumno m\u00e1s joven: Ana Guerra\n</code></pre> </li> <li> <p>showOldestStudentOlderThan23(): Debe mostrar el nombre del alumnos m\u00e1s veterano de entre los que tengan m\u00e1s de 23 a\u00f1os. La salida ser\u00eda:</p> <pre><code>Alumno m\u00e1s veterano mayor de 23: No encontrado\n</code></pre> </li> <li> <p>showStudentNamesWithCommasOrderedByAge(): Debe mostrar una cadena con los nombres de los alumnos separados por coma, ordenados por su edad. La salida ser\u00eda:</p> <pre><code>Alumnos: Ana Guerra, Baldomero, Germ\u00e1n Gin\u00e9s\n</code></pre> </li> <li> <p>showStudentCountInEachGroup(): Debe mostrar el n\u00famero de alumnos de cada grupo-clase, ordenados por nombre del grupo. La salida ser\u00eda:</p> <pre><code>N\u00famero de alumnos en cada grupo:\n1\u00ba CFGS DAM: 2 alumnos\n1\u00ba CFGM SMR: 1 alumno\n</code></pre> <p>Intenta hacer que el listado salga ordenado por el nombre del grupo-clase, a ver si lo consigues.</p> </li> <li> <p>showGrantSummary(): Debe mostrar la estad\u00edstica de becas de los alumnos, es decir, la beca m\u00e1xima, la m\u00ednima y la media (haciendo todos los c\u00e1lculos de una sola vez). La salida ser\u00eda:</p> <pre><code>Estad\u00edstica de becas:\nM\u00e1xima: 4000, M\u00ednima: 0, Media: 2000,00\n</code></pre> </li> <li> <p>showAreAnyStudentUnderLegalAge(): Debe mostrar si hay alg\u00fan alumno menor de edad. La salida ser\u00eda:</p> <pre><code>\u00bfAlg\u00fan alumno menor de edad? S\u00ed\n</code></pre> </li> <li> <p>showAllStudentHaveGrant(): Debe mostrar si todos los alumnos tienen beca. La salida ser\u00eda:</p> <pre><code>\u00bfTodos los alumnos tienen beca?: No\n</code></pre> </li> <li> <p>showFirstStudentWithoutGrant(): Debe mostrar el nombre del primer alumno que no tenga beca. La salida ser\u00eda:</p> <pre><code>Nombre del primer alumno sin beca: Baldomero\n</code></pre> </li> <li> <p>showHowManyStudentWithOrWithoutGrant(): Debe mostrar cu\u00e1ntos alumnos hay con beca y cu\u00e1ntos sin beca. La salida ser\u00eda:</p> <pre><code>Alumnos con o sin beca\nSin beca: 1\nCon beca: 2\n</code></pre> </li> <li> <p>showNumberOfSubjectsOfEachStudent(): Debe mostrar el n\u00famero de asignaturas de las que est\u00e1 matriculado cada alumnos. La salida ser\u00eda:</p> <pre><code>N\u00famero de asignaturas de cada alumno:\nBaldomero: 2\nAna Guerra: 1\nGerm\u00e1n Gin\u00e9s: 2\n</code></pre> </li> <li> <p>showNumberOfPassersStudentsOfEachSubject() (NIVEL PRO): Debe mostrar el n\u00famero de alumnos aprobados en cada asignatura (mark &gt;= 5). La salida ser\u00eda:</p> <pre><code>N\u00famero de aprobados por asignatura:\nPROGR - 3 aprobados\nLM - 0 aprobados\n</code></pre> <p>Intenta hacer que el listado salga ordenado por nombre de la asignatura.</p> </li> </ul>"},{"location":"bloque_iii/tema_13/page-6/","title":"Proyecto","text":"<p>En una tienda se desea almacenar la siguiente informaci\u00f3n sobre los productos:</p> <ul> <li>Un identificador</li> <li>El nombre del producto</li> <li>La marca del producto</li> <li>El modelo del producto, si \u00e9ste tuviese</li> <li>Precio individual del producto</li> <li>Cantidad de stock</li> <li>Fecha de caducidad, si el producto lo require</li> <li>Peso del producto en gramos</li> </ul> <p>El identificador se forma con las dos primeras letras del nombre del producto, seguido de las 3 siguientes de la marca, seguido del hashCode de ambas.</p> <p>La cesta de la compra estar\u00e1 formada por una colecci\u00f3n de productos y la cantidad de \u00e9stos que contiene. Cada vez que se a\u00f1ade un producto, se deber\u00e1 comprobar si \u00e9ste ya existe en la cesta. Si es as\u00ed, aumentar\u00e1 la cantidad de producto que hay en la cesta, por el contrario a\u00f1adir\u00e1 el producto a la cesta con la cantidad de 1.</p> <p>Una vez que se realice la compra se guardar\u00e1 la informaci\u00f3n en las Facturas, de cada factura se desea conocer:</p> <ul> <li>El identificador de la factura (ser\u00e1 una hash de la fecha de la factura)</li> <li>Fecha de la factura</li> <li>Detalle de la factura (compuesta por el producto, cantidad y precio)</li> <li>Descuentos</li> <li>Precio total</li> </ul> <p>Realiza una aplicaci\u00f3n Java teniendo en cuenta lo siguiente:</p> <ul> <li>Cuando un usuario va a comprar el contenido de la cesta, \u00e9sta se quedar\u00e1 vac\u00eda, adem\u00e1s se deber\u00e1 decrementar la cantidad de stock del producto comprado.</li> <li>Se realizar\u00e1 un descuento del 5% si supera un precio total de 100\u20ac en la factura o si tiene m\u00e1s de 10 productos diferentes</li> </ul> <p>La aplicaci\u00f3n tendr\u00e1 las siguientes opciones:</p> <ul> <li>Mostrar lista de productos</li> <li>Localizar producto por marca, nombre o identificador.</li> <li>A\u00f1adir producto a la cesta (solo haciendo uso del identificador, en caso de que no encuentre dicho producto mostrar\u00e1 un mensaje de error)</li> <li>Mostrar la cesta</li> <li>Eliminar producto de la cesta</li> <li>Realizar compra (si la cesta est\u00e1 vac\u00eda mostrar\u00e1 un mensaje de error)</li> <li>Mostrar facturas</li> <li>Filtrar factura por fechas (mes, a\u00f1o y d\u00eda) o por nombre.</li> </ul> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>Se deber\u00e1 entregar un diagrama de clase que represente las relaciones entre las clases y las interfaces.</li> <li>Todo las operaciones posibles se har\u00e1 haciendo uso de streams</li> <li>Se podr\u00e1 usar la librer\u00eda common realiza en proyectos anteriores, haciendo uso de JARs.</li> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre pr13java-NOMBRE-streams siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_iv/tema_14/page-1/","title":"1 Introducci\u00f3n al Manejo de Ficheros","text":""},{"location":"bloque_iv/tema_14/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Un fichero o archivo es un conjunto de bits almacenados en un dispositivo. Los ficheros son no vol\u00e1tiles, es decir, que los datos que almacenados permanecen en el dispositivo incluso cuando se apaga el ordenador.</p> <p>Los ficheros tienen un nombre y se ubican en directorios o carpetas, Dicho nombre ha de ser \u00fanico y no se debe repetir en el mismo directorio.</p> <p>Por lo general, los ficheros cuenta con diferentes extensiones, que por lo general suele ser 3 letras y nos permiten saber el tipo de fichero.</p> <p>Un fichero est\u00e1 formado por un conjunto de registros o l\u00edneas y cada registro por un conjunto de campos relacionados, por ejemplo, un fichero de empleados puede contener datos de los empleados de una empresa, un fichero de texto puede contener l\u00edneas de texto correspondientes a l\u00edneas impresas en una hoja de papel.</p>"},{"location":"bloque_iv/tema_14/page-1/#clases-asociadas-a-las-operaciones-de-gestion-de-ficheros","title":"Clases asociadas a las operaciones de Gesti\u00f3n de Ficheros","text":"<p>El paquete java.io contiene las clases para manejar la entrada/salida en Java, por tanto, necesitaremos importar dicho paquete cuando trabajemos con ficheros.</p> <p>La clase File proporciona un conjunto de utilidades relacionadas con los ficheros que nos van a proporcionar informaci\u00f3n acerca de los mimos (su nombre, atributos, directorios, etc)</p> <p>Para crear un objeto de tipo File se puede usar cualquiera de estos tres constructores.</p> <ul> <li>File(String directoryFile). Usa como argumento el directorio del fichero en forma de cadena.</li> <li>File(String directorio, String nombreFichero). Usa como argumento el directorio padre (directorio que contiene el fichero) del fichero y su nombre, ambas en forma de cadena.</li> <li>File(File directorio, String fichero). Usa como argumento el directorio padre en forma de tipo File y el nombre del fichero en cadena.</li> </ul> <p>En Linux se utiliza como prefijo de una ruta absoluta \"/\", En Microsoft Windows, el prefijo de un nombre de ruta consiste en la letra de la unidad seguida de \":\" y seguida por \"\\\\\" si la ruta es absoluta</p> <pre><code>//Windows\nFile ficherol = new File(\"C:\\\\EJERCICIOS\\\\UNil\\\\ejemplol.txt\");\n//Linux\nFile ficherol = new File(\"/home/ejercicios/unil/ejemplol.txt\");\nString directorio= \"C:/EJERCICIOS/UNil\";\nFile fichero2 = new File(directorio, \"emplo2.txt\");\nFile direc = new File(directorio);\nFile fichero3 = new File(directorio);\n</code></pre> <p>Algunos de los m\u00e9todos m\u00e1s importantes de la clase File son los siguientes:</p> M\u00e9todo Funci\u00f3n String[] list() Devuelve un array de String con los nombre de los ficheros y directorios asociados al objeto File. File[] listFiles() Devuelve un array de objetos File conteniendo de los ficheros que est\u00e9n dentro del directorio representado por el objeto File. String getName() Devuelve el nombre del fichero o directorio. String getPath() Devuelve la ruta relativa String getAbsolutePath() Devuelve la ruta absoluta boolean exists() Devuelve true si el fichero o directorio existe. boolean canWrite() Devuelve true si el fichero se puede escribir. boolean canRead() Devuelve true si el fichero se puede leer. boolean isFile() Devuelve true si el objeto File corresponde a un fichero normal. boolean isDirectory() Devuelve true si el objeto File corresponde a un directorio. long legth() Devuelve el tama\u00f1o del fichero en bytes. boolean mkdir() Crea un directorio con el nombre indicado en la creaci\u00f3n del objeto File. Solo se crear\u00e1 si no existe. boolean renameTo(File nuevoNombre) Renombra el fichero representando por el objeto File asign\u00e1ndole nuevo nombre. boolean delete() Borra el fichero o directorio asociado al objeto File. boolean createNewFile() Crea un nuevo fichero, vac\u00edo, asociado File si y solo si no existe un fichero con ese nombre String getParent() Devuelve el nombre del directorio padre, o null  si no existe. <pre><code>public class ListDir {\n    public void show() {\n        String dir = \".\"; // directorio actual\n        File f = new File(dir);\n        String[] files = f.list();\n        System.out.printf(\"Ficheros en el directorio actual: %d \\n\",\n                files != null ? files.length : 0);\n\n        for (String archivo : files) {\n            File f2 = new File(f, archivo);\n            System.out.printf(\"Nombre: %s, es fichero?: %b, es directorio?: %b \\n\",\n                    archivo, f2.isFile(), f2.isDirectory());\n        }\n    }\n\n    public static void main(String[] args) {\n        new ListDir().show();\n    }\n}\n</code></pre> <p>En el siguiente ejemplo mostramos informaci\u00f3n referente a un fichero:</p> <pre><code>public class FileInfo {\n    public void show() {\n        System.out.println(\"INFORMACI\u00d3N SOBRE EL FICHERO\");\n        File f = new   File(\"src/exercises/bloque_iv/tema_14/FileInfo.java\");\n        if(f.exists()){\n            System.out.println(\"Nombre del fichero          : \" + f.getName());\n            System.out.println(\"Ruta            : \" + f.getPath());\n            System.out.println(\"Ruta Absoluta             : \" + f.getAbsolutePath());\n            System.out.println(\"Se puede leer             : \" + f.canRead());\n            System.out.println(\"Se puede escribir           : \" + f.canWrite());\n            System.out.println(\"Tama\u00f1o               : \" + f.length());\n            System.out.println(\"Es un directorio         : \" + f.isDirectory());\n            System.out.println(\"Es un fichero             : \" + f.isFile());\n            System.out.println(\"Nombre del directorio padre :\" + f.getParent());\n        }\n    }\n\n    public static void main(String[] args) {\n        new FileInfo().show();\n    }\n}\n</code></pre> <p>Por \u00faltimo, vemos un ejemplo para crear directorios  y ficheros y renombrarlos:</p> <pre><code>public class RenameFile {\n    public void show() {\n        File d = new File(\"DIR\");\n        File f1 = new File(d,\"file1.txt\");\n        File f2 = new File(d,\"file2.txt\");\n        File f3 = new File(\"DIR/file3.txt\");\n        File renameFile = new File(d, \"file1_change.txt\");\n        boolean success;\n\n        success = d.mkdir();\n\n        System.out.printf(\"La carpeta %s%s ha sido creada con \u00e9xito\\n\", d.getName(), success ? \"\" : \"no\");\n\n        try{\n            success = f1.createNewFile();\n            System.out.printf(\"Fichero %s%s ha sido creado con \u00e9xito\\n\", f1.getName(), success ? \"\" : \"no\");\n\n            success = f2.createNewFile();\n            System.out.printf(\"Fichero %s%s ha sido creado con \u00e9xito\\n\", f2.getName(), success ? \"\" : \"no\");\n        } catch (IOException e) {\n            System.err.println(\"Error de entrada y salida\");\n        }\n\n        success = f1.renameTo(renameFile);\n        System.out.printf(\"%s ha cambiado el fichero %s a %s\\n\", success ? \"Se\" : \"No se\", \n                f1.getName(), f3.getName());\n\n        try {\n            success = f3.createNewFile() ;\n            System.out.printf(\"Fichero %s%s ha sido creado con \u00e9xito\\n\", f3.getName(), success ? \"\" : \"no\");\n        } catch (IOException ioe) {\n            System.err.println(\"Error de entrada y salida\");\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new RenameFile().show();\n    }\n}\n</code></pre> <p>El m\u00e9todo createNewFile() puede lanzar la excepci\u00f3n IOException, por ello se introduce en un bloque try-catch.</p> <p>Por \u00faltimo, vamos a ver un ejemplo de como eliminar un fichero:</p> <pre><code>public class DeleteFile {\n    public void show() {\n        File f = new File(\"DIR/file3.txt\");\n        boolean success = f.delete();\n\n        System.out.printf(\"%s ha eliminado correctamente el fichero %s\\n\", success ? \"Se\" : \"No\",\n                f.getName());\n    }\n\n    public static void main(String[] args) {\n        new DeleteFile().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-1/#flujos-o-streams-tipos","title":"Flujos o Streams: Tipos","text":"<p>El sistema de entrada/salida en Java presenta una gran cantidad de clases que se implementan el paquete java.io. Usa la abstracci\u00f3n del flujo (stream) para tratar la comunicaci\u00f3n de informaci\u00f3n entre una fuente y un destino.</p> <p>Cualquier programa que tenga que obtener informaci\u00f3n de cualquier fuente necesita abrir in stream, si necesita evitar informaci\u00f3n abrir\u00e1 un stream y se escribir\u00e1 la informaci\u00f3n en serie. Se define dos tipos de flujos:</p> <ul> <li>Flujos de bytes (8 bits): Realizan operaciones de entradas y salidas de bytes y su uso est\u00e1 orientado a la lectura/escritura de datos binarios. Todas las clases de flujos de bytes descienden de las clases InputStream y OutputStream, cada vez una de estas clases tienen varias subclases que controlan las diferencias entre los distintos dispositivos de entrada/salida que se pueden utilizar.</li> <li>Flujos de caracteres (16 bits): Realizan operaciones de entradas y salidas de caracteres. El flujo de caracteres viene gobernado por las clases Reader y Writer.</li> </ul>"},{"location":"bloque_iv/tema_14/page-1/#flujos-de-bytes","title":"Flujos de Bytes","text":"<p>La clase InputStream representa las clases que producen entradas de distintas fuentes, estas fuentes pueden ser: un array de bytes, un objeto de String, un fichero, una \"tuber\u00eda\", una secuencia de otros flujos, otras fuentes.</p> <p>La clase InputFileStream  es el flujo de entrada hacia un fichero, y se usa para leer la informaci\u00f3n de un fichero.</p> <p>Los tipos de OutputStream incluyen clases que deciden d\u00f3nde ir\u00e1 la salida: a un array de bytes. un fichero o una tuber\u00eda.</p> <p>La clase OutputFileStream es el flujo de salida hacia un fichero, y se usa para enviar informaci\u00f3n a un fichero.</p> <p>FileInputStream y FileOutputStream manipulan los flujos de bytes provenientes o dirigidos en disco.</p>"},{"location":"bloque_iv/tema_14/page-1/#flujo-de-caracteres","title":"Flujo de Caracteres","text":"<p>Las clases Reader y Writer manejan flujos de caracteres Unicode. Hay ocasiones en las que hay que usar las clases que manejan bytes en combinaci\u00f3n con las clases que manejas caracteres. Para lograr esto hay clases puentes: InputStreamReader que convierte un InputStream en un Reader y OutputStreamWriter que convierte un OutputStream en un Writer.</p> <p>Las clases de flujos de caracteres m\u00e1s importantes son:</p> <ul> <li>Para acceso a ficheros, lectura y escritura de caracteres en ficheros: FileReader y FileWriter.</li> <li>Para acceso a caracteres, leen y escribe un flujo de caracteres en un array de caracteres: CharArrayReader y CharArrayWriter.</li> <li>Para bufferizaci\u00f3n de datos: BufferedReader y BufferedWriter, se utilizan para evitar que cada lectura o escritura acceda directamente al fichero, ya que utilizan un buffer intermedio entre la memoria y el stream.</li> </ul>"},{"location":"bloque_iv/tema_14/page-1/#formas-de-acceso-a-un-fichero","title":"Formas de Acceso a un fichero","text":"<p>Hay dos formas de acceso a la informaci\u00f3n almacenada en un fichero: acceso secuencial y acceso directo o aleatorio:</p> <ul> <li>Acceso secuencial: los datos o registros se leen y se escriben en orden, del mismo modo que se hace en una antigua cinta de audio (cassette). Si se quiere acceder a un dato o un registro que est\u00e1 hacia la mitad del fichero es necesario leer antes todos los anteriores. La escritura de datos se har\u00e1 a partir del \u00faltimo dato escrito, no es posible hacer inserciones entre los datos que ya hay escritos.</li> <li>Acceso directo o aleatorio: permite acceder directamente a un dato o registro sin necesidad de leer los anteriores y se puede acceder a la informaci\u00f3n en cualquier orden. Los datos est\u00e1n almacenados en registros de tama\u00f1o conocido, nos podemos mover de un registro a otro de forma aleatoria para leerlos o modificarlos, como uno de los CDs actuales.</li> </ul> <p>En Java el acceso secuencial m\u00e1s com\u00fan en ficheros puede ser binario o a caracteres. Para el acceso binario: se usan las clases FileInputStream y FileOutputStream; para el acceso a caracteres (texto) se usan las clases FileReader y FileWriter. En el acceso aleatorio se utiliza la clase RandomAccessFile.</p>"},{"location":"bloque_iv/tema_14/page-10/","title":"10 Ficheros JSON","text":""},{"location":"bloque_iv/tema_14/page-10/#introduccion","title":"Introducci\u00f3n","text":"<p>JSON (JavaScript Object Notation - Notaci\u00f3n de Objetos de JavaScript) es un formato ligero de intercambio de datos. Leerlo y escribirlo es simple para humanos, mientras que para las m\u00e1quinas es simple interpretarlo y generarlo. Est\u00e1 basado en un subconjunto del Lenguaje de Programaci\u00f3n JavaScript.</p> <p>JSON es un formato de texto que es completamente independiente del lenguaje pero utiliza convenciones que son ampliamente conocidos por los programadores de la familia de lenguajes C, incluyendo C, C++, C#, Java, JavaScript, Perl, Python, y muchos otros. Estas propiedades hacen que JSON sea un lenguaje ideal para el intercambio de datos.</p> <p>JSON est\u00e1 constituido por dos estructuras:</p> <ul> <li>Una colecci\u00f3n de pares de nombre/valor. En varios lenguajes esto es conocido como un objeto, registro, estructura, diccionario, tabla hash, lista de claves o un arreglo asociativo.</li> <li>Una lista ordenada de valores. En la mayor\u00eda de los lenguajes, esto se implementa como arreglos, vectores, listas o secuencias.</li> </ul> <p>Estas son estructuras universales; virtualmente todos los lenguajes de programaci\u00f3n las soportan de una forma u otra. Es razonable que un formato de intercambio de datos que es independiente del lenguaje de programaci\u00f3n se base en estas estructuras.</p>"},{"location":"bloque_iv/tema_14/page-10/#objetos-json","title":"Objetos JSON","text":"<p>Un objeto es un conjunto desordenado de pares nombre/valor. Un objeto comienza con <code>{</code>, llave de apertura y termine con <code>}</code>, llave de cierre. Cada nombre es seguido por <code>:</code>, dos puntos y los pares nombre/valor est\u00e1n separados por <code>,</code>, coma.</p>"},{"location":"bloque_iv/tema_14/page-10/#arreglo-json","title":"Arreglo JSON","text":"<p>Un arreglo es una colecci\u00f3n de valores. Un arreglo comienza con <code>[</code>corchete izquierdo y termina con <code>]</code>corchete derecho. Los valores se separan por <code>,</code>coma.</p> <p> Figura 2 - Array JSON</p>"},{"location":"bloque_iv/tema_14/page-10/#valor","title":"Valor","text":"<p>Un valor puede ser una cadena de caracteres con comillas dobles, o un n\u00famero, o <code>true</code> o <code>false</code> o <code>null</code>, o un objeto o un arreglo. Estas estructuras pueden anidarse.</p> <p> Figura 3 - Value JSON</p>"},{"location":"bloque_iv/tema_14/page-10/#cadena-de-caracteres","title":"Cadena de Caracteres","text":"<p>Una cadena de caracteres es una colecci\u00f3n de cero o m\u00e1s caracteres Unicode, encerrados entre comillas dobles, usando barras divisorias invertidas como escape. Un car\u00e1cter est\u00e1 representado por una cadena de caracteres de un \u00fanico car\u00e1cter. Una cadena de caracteres es parecida a una cadena de caracteres C o Java.</p> <p> Figura 3 - String JSON</p>"},{"location":"bloque_iv/tema_14/page-10/#numero","title":"N\u00famero","text":"<p>Un n\u00famero es similar a un n\u00famero C o Java, excepto que no se usan los formatos octales y hexadecimales.</p> <p> Figura 4 - Number JSON</p>"},{"location":"bloque_iv/tema_14/page-10/#espacios-en-blancos","title":"Espacios en blancos","text":"<p>Los espacios en blanco pueden insertarse entre cualquier par de s\u00edmbolos. Exceptuando peque\u00f1os detalles de encoding, esto describe completamente el lenguaje.</p> <p> Figura 5 - Whitespace JSON</p>"},{"location":"bloque_iv/tema_14/page-10/#ejemplos-json","title":"Ejemplos JSON","text":"OBJETOArrays <pre><code>{\n  \"squadName\": \"Super hero squad\",\n  \"homeTown\": \"Metro City\",\n  \"formed\": 2016,\n  \"secretBase\": \"Super tower\",\n  \"active\": true,\n  \"members\": [\n    {\n      \"name\": \"Molecule Man\",\n      \"age\": 29,\n      \"secretIdentity\": \"Dan Jukes\",\n      \"powers\": [\n        \"Radiation resistance\",\n        \"Turning tiny\",\n        \"Radiation blast\"\n      ]\n    },\n    {\n      \"name\": \"Madame Uppercut\",\n      \"age\": 39,\n      \"secretIdentity\": \"Jane Wilson\",\n      \"powers\": [\n        \"Million tonne punch\",\n        \"Damage resistance\",\n        \"Superhuman reflexes\"\n      ]\n    },\n    {\n      \"name\": \"Eternal Flame\",\n      \"age\": 1000000,\n      \"secretIdentity\": \"Unknown\",\n      \"powers\": [\n        \"Immortality\",\n        \"Heat Immunity\",\n        \"Inferno\",\n        \"Teleportation\",\n        \"Inter dimensional travel\"\n      ]\n    }\n  ]\n}\n</code></pre> <pre><code>[\n  {\n    \"name\": \"Molecule Man\",\n    \"age\": 29,\n    \"secretIdentity\": \"Dan Jukes\",\n    \"powers\": [\n      \"Radiation resistance\",\n      \"Turning tiny\",\n      \"Radiation blast\"\n    ]\n  },\n  {\n    \"name\": \"Madame Uppercut\",\n    \"age\": 39,\n    \"secretIdentity\": \"Jane Wilson\",\n    \"powers\": [\n      \"Million tonne punch\",\n      \"Damage resistance\",\n      \"Superhuman reflexes\"\n    ]\n  }\n]\n</code></pre> <p>Info</p> <p>Al final de esta p\u00e1gina, https://www.json.org/json-es.html se puede ver las grandes cantidades de librer\u00edas para poder trabajar con JSON.</p> <p>Gson es una de ellas y esta desarrollada por Google.</p>"},{"location":"bloque_iv/tema_14/page-11/","title":"11 Gson","text":""},{"location":"bloque_iv/tema_14/page-11/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Puede darse la situaci\u00f3n de que en nuestra aplicaci\u00f3n Java, necesitemos atender peticiones representadas en JSON, transformarlas a Java, tratar los datos y devolver una respuesta en JSON. Los servicios REST o los Websockets son un buen ejemplo de esto.</p> <p>Para resolver este problema podemos implementar \u00aba mano\u00bb la l\u00f3gica de negocio para serializar y deserializar nuestro JSON, lo que supondr\u00e1 un esfuerzo considerable. O podr\u00edamos hacer uso de alguna librer\u00eda dise\u00f1ada para este prop\u00f3sito como puede ser Gson.</p>"},{"location":"bloque_iv/tema_14/page-11/#gson","title":"Gson","text":"<p>Antes de nada necesitaremos a\u00f1adir la siguiente dependencia a nuestra aplicaci\u00f3n:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupid&gt;com.google.code.gson&lt;/groupid&gt;\n    &lt;artifactid&gt;gson&lt;/artifactid&gt;\n    &lt;version&gt;2.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Tambi\u00e9n se puede descargar desde aqu\u00ed</p> <p>El uso de esta librer\u00eda se basa en el uso de una instancia de la clase Gson. Dicha instancia se puede crear de manera directa (<code>new Gson()</code>) para transformaciones sencillas o de forma m\u00e1s compleja con <code>GsonBuilder</code> para a\u00f1adir distintos comportamientos. Lo veremos en los ejemplos.</p> <p>Una instancia de la clase Gson no mantiene ning\u00fan tipo de estado, por lo que el mismo objeto puede reutilizarse para m\u00faltiples serializaciones/deserializaciones.</p>"},{"location":"bloque_iv/tema_14/page-11/#serializando-objetos","title":"Serializando objetos","text":"<p>En este ejemplo, tenemos una clase Empleado que queremos convertir en un JSON.</p> EmployeeMainSalida <pre><code>public class Employee {\n    private final int id;\n    private final String name;\n    private final String business;\n\n    public Employee(int id, String name, String business) {\n        this.id = id;\n        this.name = name;\n        this.business = business;\n    }\n}\n</code></pre> <pre><code>public class ToJson {\n    public void show() {\n        final Employee employee = new Employee(32, \"Marta\", \"Avon\");\n        final Gson gson = new Gson();\n        final String json = gson.toJson(employee);\n\n        System.out.println(json);\n    }\n\n    public static void main(String[] args) {\n        new ToJson().show();\n    }\n}\n</code></pre> <pre><code>{\"id\":32,\"name\":\"Marta\",\"business\":\"Avaon\"}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-11/#deserializando-objetos","title":"Deserializando objetos","text":"<p>Con el m\u00e9todo fromJson podemos pasar una cadena JSON a un objeto de una clase espec\u00edfica.</p> <pre><code>public class FromJson {\n    public void show() {\n        final String json = \"{\\\"id\\\":32,\\\"name\\\":\\\"Marta\\\",\\\"business\\\":\\\"Avon\\\"}\\n\";\n        final Gson gson = new Gson();\n        final Employee employee = gson.fromJson(json, Employee.class);\n\n        System.out.println(employee);\n    }\n\n    public static void main(String[] args) {\n        new FromJson().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-11/#5-gsonbuilder","title":"5. GsonBuilder","text":"<p>A veces, usando el constructor de la clase Gson no podemos tener configuraciones especificas. La librer\u00eda Gson tiene una clase que sigue el patr\u00f3n de dise\u00f1o builder. A un objeto de esta clase, puede llamar a m\u00e9todos para configurar la clase Gson y finalmente al m\u00e9todo create() que es la que creara el objeto Gson con las configuraciones realizadas.</p> <p>Por ejemplo, si tuvi\u00e9semos que almacenar, varios datos, la cadena de salida predeterminada por el objeto, no es visualmente la m\u00e1s conveniente, por ello la clase GsonBuilder, tiene un m\u00e9todo setPrettyPrinting() que sirve para que la cadena de salida, salga formateada.</p> MainSalida <pre><code>public class PrettyPrinting {\n    public void show() {\n        final Employee employee = new Employee( 32, \"Marta\", \"Avon\");\n        final Gson gson = new GsonBuilder().setPrettyPrinting().create();\n        final String prettyJson = gson.toJson(employee);\n        System.out.println(prettyJson);\n    }\n\n    public static void main(String[] args) {\n        new PrettyPrinting().show();\n    }\n}\n</code></pre> <pre><code>{\n  \"id\": 32,\n  \"name\": \"Marta\",\n  \"business\": \"Avon\"\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-11/#array-de-objetos","title":"Array de Objetos","text":"<p>Tenemos una lista de empleados y queremos serializarla en una cadena JSON, en ese caso, la configuraci\u00f3n sigue la misma que todo lo visto anteriormente.</p> Main <pre><code>List&lt;Employee&gt; employeeList = List.of(\npublic class ArrayJSON {\n    public void show() {\n        List&lt;Employee&gt; employeeList = List.of(\n                new Employee( 32, \"Marta\", \"Avon\"),\n                new Employee(25, \"Mar\u00eda\", \"Fresh\"),\n                new Employee(38, \"Juan\", \"Pop\")\n        );\n\n        final Gson gson = new GsonBuilder().setPrettyPrinting().create();\n        final String json = gson.toJson(employeeList);\n        System.out.println(json);\n    }\n\n    public static void main(String[] args) {\n        new ArrayJSON().show();\n    }\n}\n</code></pre> Salida <pre><code>[\n  {\n    \"id\": 32,\n    \"name\": \"Marta\",\n    \"business\": \"Avaon\"\n  },\n  {\n    \"id\": 25,\n    \"name\": \"Mar\u00eda\",\n    \"business\": \"Fresh\"\n  },\n  {\n    \"id\": 38,\n    \"name\": \"Juan\",\n    \"business\": \"Pop\"\n  }\n]\n</code></pre> <p>Para deserializarlo, ser\u00e1 necesario decirle al Gson el tipo de lista que se va a deserializar, por eso al m\u00e9todo fromGson(), en vez de pasarle la clase, se le pasar\u00e1 un objeto de clase Type.</p> <p>La librer\u00eda Gson contiene la clase TypeToke con la cu\u00e1l podemos indicar el tipo de lista con el que se va a trabajar. <pre><code>public class FromArrayJson {\n    public void show() {\n        final String json = \"\"\"\n    [\n    {\n        \"id\": 32,\n        \"name\": \"Marta\",\n        \"business\": \"Avon\"\n    },\n    {\n        \"id\": 25,\n        \"name\": \"Mar\u00eda\",\n        \"business\": \"Fresh\"\n    },\n    {\n        \"id\": 38,\n        \"name\": \"Juan\",\n        \"business\": \"Pop\"\n    }\n]\"\"\";\n\n        final Gson gson = new Gson();\n        final Type typeOfEmployeeList = new TypeToken&lt;List&lt;Employee&gt;&gt;(){}.getType();\n        final List&lt;Employee&gt; employeeList = gson.fromJson(json, typeOfEmployeeList);\n        System.out.println(employeeList);\n    }\n\n    public static void main(String[] args) {\n        new FromArrayJson().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-11/#genericos","title":"Gen\u00e9ricos","text":"<p>Al igual que las listas, si queremos pasar extraer de JSON una clase gen\u00e9rica, debemos usar la clase TypeToken</p> <pre><code>public class Generics {\n    public void show() {\n        final String json = \"{\\\"object\\\":{\\\"id\\\":46,\\\"name\\\":\\\"Miguel\\\",\" +\n                \"\\\"business\\\":\\\"Autentia\\\"}}\";\n        final Type typeWrapper = new TypeToken&lt;Wrapper&lt;Employee&gt;&gt;(){}.getType();\n        final Gson gson = new Gson();\n        final Wrapper&lt;Employee&gt; wrapperEmployee = gson.fromJson(json, typeWrapper);\n\n        System.out.println(wrapperEmployee);\n    }\n\n    public static void main(String[] args) {\n        new Generics().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-11/#fechas","title":"Fechas","text":"<p>Para tratar con fechas ser\u00e1 necesario usar el m\u00e9todo de configuraci\u00f3n setDateFormat().</p> ClaseMain <pre><code>public class VacationRequest {\n    private final Date init;\n    private final Date end;\n    private final int totalDays;\n\n    public VacationRequest(Date init, Date end, int totalDays) {\n        this.init = init;\n        this.end = end;\n        this.totalDays = totalDays;\n    }\n}\n</code></pre> <pre><code>public class VacationRequest {\n    public void show() {\n        final String STRING_FORMATTER = \"dd/MM/yyyy\";\n        final String json = \"{\\\"init\\\":\\\"06/08/2012\\\",\\\"end\\\":\\\"10/08/2012\\\",\\\"totalDays\\\":\\\"4\\\"}\";\n        final Gson gson = new GsonBuilder().setDateFormat(STRING_FORMATTER).create();\n        final VacationRequest vacationRequest = gson.fromJson(json, VacationRequest.class);\n        System.out.println(vacationRequest);\n    }\n\n    public static void main(String[] args) {\n        new VacationRequest().show();\n    }\n}\n</code></pre> <p>El problema de este m\u00e9todo ocurre en las versiones recientes de Java, no es posible usando este m\u00e9todo en las fechas de Java 8, por lo que ser\u00e1 necesario parsearlo.</p>"},{"location":"bloque_iv/tema_14/page-11/#mapeando-propiedades","title":"Mapeando propiedades","text":"<p>Realizamos la deserializaci\u00f3n del objeto JSON al objeto Java directamente con fromJson, \u00e9sta se realizar\u00e1 propiedad a propiedad entre el objeto JSON y el Java de manera autom\u00e1tica si las propiedades y atributos tienen el mismo nombre. Sin embargo, podemos hacer que esto no sea as\u00ed.</p> <p>Para poder mapear dichas propiedades podemos usar en la clase la anotaci\u00f3n SerializedName.</p> <pre><code>@SerializedName(\"d\")\nprivate final int totalDias;\n</code></pre>"},{"location":"bloque_iv/tema_14/page-11/#objeto-java-con-una-lista","title":"Objeto Java con una lista","text":"<p>Este parece un caso especial, y que habr\u00eda que indicar el tipo de la lista, pero en este caso, no es necesario realizar esto, se har\u00eda exactamente igual:</p> EmployeeVacationsMain <pre><code>public class EmployeeVacations {\n    private final int id;\n    private final String name;\n    private final String business;\n    private final List&lt;VacationRequest&gt; vacation;\n\n    public EmployeeVacations(int id, String name, String business, List&lt;VacationRequest&gt; vacation) {\n        this.id = id;\n        this.name = name;\n        this.business = business;\n        this.vacation = vacation;\n    }\n\n    @Override\n    public String toString() {\n        return \"EmployeeVacations{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", business='\" + business + '\\'' +\n                \", vacation=\" + vacation +\n                '}';\n    }\n}\n</code></pre> <pre><code>public class ObjectWithList {\n    public void show() {\n        final String json = \"\"\"\n{\n    \"id\" : 46,\n    \"name\" : \"Miguel\",\n    \"business\" : \"Autentia\",\n    \"vacation\":[\n        {\n            \"init\" : \"06/08/2012\",\n            \"end\" : \"10/08/2012\",\n            \"d\" : 5\n        },\n        {\n            \"init\" : \"23/08/2012\",\n            \"end\" : \"29/08/2012\",\n            \"d\" : 7\n        }\n    ]\n}\"\"\";\n        final Gson gson = new GsonBuilder().setDateFormat(\"dd/MM/yyyy\").create();\n        final EmployeeVacations employee = gson.fromJson(json, EmployeeVacations.class);\n\n        System.out.println(employee);\n    }\n\n    public static void main(String[] args) {\n        new ObjectWithList().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-11/#obtener-json-de-un-fichero","title":"Obtener JSON de un fichero","text":"<p>Nuestro objeto Gson no solo acepta un String como representaci\u00f3n JSON del objeto a deserializar. Tambi\u00e9n puede leerlo desde un fichero y realizar la mista tarea. Imaginemos que tenemos un fichero employee.json con el objeto JSON del ejemplo anterior. Lo \u00fanico que tenemos que hacer es pasar a nuestro objeto Gson un Reader (java.io.Reader) con la informaci\u00f3n de ese fichero y Gson har\u00e1 el resto.</p>"},{"location":"bloque_iv/tema_14/page-12/","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza un programa que dado un fichero que se le solicite al usuario, muestre su nombre, si es un ejecutable, si est\u00e1 oculto, la ruta relativa, la ruta absoluta y el tama\u00f1o.</p> Ejercicio 2 <p>Realiza un programa que cree un directorio en el directorio actual, luego cree tres ficheros en dicho directorio donde uno se borre y otro se renombre. Crearle tambi\u00e9n un subdirectorio con un fichero dentro. Despu\u00e9s mostrar la ruta absoluta de ambos directorios y sus contenidos.</p> Ejercicio 3 <p>Realiza un programa que muestre el nombre y tipo (fichero o directorio) de los ficheros y subdirectorios contenidos en un directorio solicitado al usuario. Mostrar tambi\u00e9n el contenido de todos los subdirectorios y si \u00e9stos contienen subdirectorios tambi\u00e9n...y as\u00ed sucesivamente hasta mostrar todo el contenido de dicho directorio.</p> Ejercicio 4 <p>Un filtro sirve para que el m\u00e9todo list devuelva solo aquellos archivos o carpetas que  cumplan una condici\u00f3n (que tengan una extensi\u00f3n determinada, contengan en su nombre una cadena concreta, empiecen por un car\u00e1cter, etc). Un filtro es un objeto de una clase que implementa el interface FilenameFilter. Realiza un programa que muestre los archivos de un directorio que posean una extensi\u00f3n concreta. Tanto la extensi\u00f3n como el directorio se solicita al usuario.</p> Ejercicio 5 <p>Realiza un programa que dadas dos rutas, origen y destino, copie el archivo origen(fichero de texto) en el destino de la siguiente manera:</p> <ul> <li>Si el destino es un directorio, se crear\u00e1 un archivo con el mismo nombre donde se copiar\u00e1 el archivo origen l\u00ednea a l\u00ednea(una l\u00ednea se considera hasta que se encuentre un salto de l\u00ednea). Utilizar Stream de la clase BufferedReader.</li> <li>Si el destino es un archivo, habr\u00e1 varias opciones seg\u00fan un booleano:  <ul> <li>Si el booleano es verdadero y el destino es un archivo existente, se reemplazar\u00e1 su contenido por el del archivo origen copiando car\u00e1cter a car\u00e1cter.</li> <li>Si el booleano es verdadero y el destino es un archivo inexistente, se lanzar\u00e1 una excepci\u00f3n.</li> <li>Si el booleano es falso y el destino es un archivo existente, se reemplazar\u00e1 su contenido por el del archivo origen copiandolo usando un buffer(array) sin desplazamiento de 20 caracteres. En el caso de la \u00faltima escritura, si no se llena el buffer, utilizar el desplazamiento para no dejar basura.</li> <li>Si el booleano es falso y el destino es un archivo inexistente, no se har\u00e1 nada con el archivo y se le dar\u00e1 un mensaje al usuario de que la copia no se puede realizar.</li> </ul> </li> </ul> Ejercicio 6 <p>Realiza un programa que dado un fichero de texto, se copie en tres ficheros diferentes de tal  manera que copie en el primer fichero los primeros 5 caracteres, en el segundo, los 5 siguientes y en el tercero los 5 siguientes, y as\u00ed sucesivamente hasta copiar todo el fichero. Utilizar lectura sin desplazamiento y escrituras con desplazamiento de un buffer de 15 caracteres. Despu\u00e9s, hacer justamente lo contrario. Dados los 3 ficheros, construir uno como el fichero original. Utilizar ahora lecturas con desplazamiento y escritura sin desplazamiento de un buffer de 15 caracteres. Comprobar por c\u00f3digo que ambos son iguales. En el caso de la \u00faltima lectura/escritura, si no se llena el buffer, utilizar el desplazamiento para no dejar basura.</p> Ejercicio 7 <p>Dise\u00f1ar un programa para encriptar y desencriptar los datos de un fichero de texto. Se introduce una cadena por teclado que ser\u00e1 la clave a aplicar para la encriptaci\u00f3n y desencriptaci\u00f3n. A cada car\u00e1cter del fichero de texto original se le sumar\u00e1 una letra de la clave (el c\u00f3digo Unicode), cuando se hayan acabado las letras de la palabra clave y a\u00fan no se hayan acabado los caracteres del fichero, se volver\u00e1 al principio de la cadena para seguir aplicando la encriptaci\u00f3n. Los datos encriptados se escribir\u00e1n en un fichero destino, que ser\u00e1 usado como origen para desencriptar. Para desencriptar se aplicar\u00e1 la f\u00f3rmula a la inversa. Por ejemplo, si el fichero origen contiene \u201cabcdef\u201d y la palabra clave es \u201crosa\u201d, en el fichero destino se escribir\u00e1n los siguientes caracteres: \u201d\u00d3\u00d1\u00d6\u00c5\u00d7\u00d5\u201d.  Es decir, \u00d3 es el resultado de sumar a y r, \u00d1 es el resultado de sumar b y o, y as\u00ed sucesivamente.</p> Ejercicio 8 <p>Queremos hacer una agenda telef\u00f3nica con los siguientes datos:</p> <ul> <li>Nombre de contacto</li> <li>Tel\u00e9fono</li> <li>Direcci\u00f3n</li> <li>C\u00f3digo postal</li> <li>Fecha de Nacimiento</li> <li>Si le debo dinero o no</li> <li>Cantidad de dinero que le debo</li> </ul> <p>Realiza un programa que almacene los datos en un fichero binario. A continuaci\u00f3n, lee el fichero y muestra el contenido contenido por consola. Haz dos versiones, una sin serializaci\u00f3n de objetos y otras con serializaci\u00f3n.</p> <p>Almacena unos cuantos contactos, luego cierra el programa y vuelve a ejecutarlo a\u00f1adiendo unos cuantos contactos m\u00e1s.</p> Ejercicio 9 <p>Haz un programa que lea los contactos del fichero del ejercicio 8 (la versi\u00f3n con serializaci\u00f3n de objetos) y los guarde en un fichero aleatorio. En el fichero aleatorio tienes que a\u00f1adir un identificador a cada contacto antes de los datos. El identificador empieza en 1. A\u00f1\u00e1dele tambi\u00e9n en el fichero a cada contacto un indicador para comprobar si el usuario ha sido eliminado. A continuaci\u00f3n, hazle el siguiente men\u00fa al fichero aleatorio:</p> <ul> <li>Consultar todos los contactos.</li> <li>Consultar un contacto (pedirle al usuario el identificador)</li> <li>A\u00f1adir un contacto<ul> <li>Por el final</li> <li>En la primera posici\u00f3n libre</li> </ul> </li> <li>Eliminar un contacto de forma de forma l\u00f3gica o suave.</li> <li>Modificar si le debo dinero y la cantidad (pedirle al usuario el identificador)</li> <li>Compactaci\u00f3n del fichero</li> </ul> <p>Realiza dos versiones del ejercicio, usando <code>writeChars</code> y otra usando <code>writeUTF</code>.</p> Ejercicio 10 <p>Haz un programa que lea los contactos del fichero binario de la agenda telef\u00f3nica con serializaci\u00f3n de objetos del ejercicio 8 y los escriba en un fichero XML usando la librer\u00eda XStream.</p> Ejercicio 11 <p>Dado el XML del ejercicio anterior, utilizando XStream, p\u00e1salo a un fichero binario sin serializaci\u00f3n de objetos. Compara que sea igual al fichero binario sin serializaci\u00f3n de objetos obtenido en el ejercicio 8. Haz la comparaci\u00f3n en binario.</p> Ejercicio 12 <p>Dado el fichero XML, a\u00f1\u00e1dele los siguientes atributos utilizando un editor de textos:</p> <ul> <li>Prefijo del pa\u00eds en el tel\u00e9fono.</li> <li>Localidad en la direcci\u00f3n</li> <li>Tipo de moneda en el dinero</li> </ul> <p>Proc\u00e9salo con SAX y guarda los datos en un fichero de texto. Guarda cada contacto en una l\u00ednea. Los datos deben estar alineados por columnas.</p> Ejercicio 13 <p>Crea una plantilla XSL para dar una presentaci\u00f3n al fichero XML de la agenda telef\u00f3nica. Realiza un programa para transformarlo en HTML.</p> Ejercicio 14 <p>A partir del fichero XML de la agenda telef\u00f3nica, obtener un fichero JSON utilizando la librer\u00eda GSON.</p> Ejercicio 15 <p>Dado el fichero JSON del ejercicio anterior, obtener un fichero de texto con el siguiente formato:</p> <p> Resultado del ejercicio 15 </p> Ejercicio 16 <p>Dado el fichero JSON anterior, mostrar todos los datos de los contactos cuyo nombre nos indique el usuario. La b\u00fasqueda se har\u00e1 directamente en el fichero JSON. NO utilizar GSON</p> Ejercicio 17 <p>Realiza una funci\u00f3n que te permita buscar en un JSON por un n\u00famero indeterminado de campos.</p>"},{"location":"bloque_iv/tema_14/page-2/","title":"2 Operaciones sobre ficheros","text":""},{"location":"bloque_iv/tema_14/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Las operaciones b\u00e1sicas que se realizan sobre cualquier fichero independientemente de la forma de acceso al mismo son las siguientes:</p> <ul> <li>Creaci\u00f3n del fichero. El fichero se crea en el disco con un nombre que despu\u00e9s se debe utilizar para acceder a \u00e9l. La creaci\u00f3n es un proceso que se realiza una vez.</li> <li>Apertura del fichero. Para que un programa pueda operar con un fichero, la primera operaci\u00f3n que tiene que realizar es la apertura del mismo. El programa utilizar\u00e1 alg\u00fan m\u00e9todo para identificar el fichero con el que quiere trabajar, por ejemplo, asignar a una variable el descriptor del fichero.</li> <li>Cierre del fichero. El fichero se debe cerrar cuando el programa no lo vaya a utilizar. Normalmente suele ser la \u00faltima instrucci\u00f3n del programa.</li> <li>Lectura de los datos del fichero. Este proceso consiste en transferir informaci\u00f3n del fichero a la memoria principal, normalmente a trav\u00e9s de alguna variable o variables de nuestro programa en las que se depositar\u00e1n los datos extra\u00eddos del fichero.</li> <li>Escritura de datos en el fichero. En este caso el proceso consiste en transferir informaci\u00f3n de la memoria (por medio de las variables del programa) al fichero.</li> </ul> <p>Normalmente las operaciones t\u00edpicas que se realizan sobre un fichero una vez abierto son las siguientes:</p> <ul> <li>Altas: Consiste en a\u00f1adir un nuevo registro al fichero.</li> <li>Bajas: Consiste en eliminar del fichero un registro ya existente. La eliminaci\u00f3n puede ser l\u00f3gica, cambiando el valor de alg\u00fan campo del registro que usemos para controlar dicha situaci\u00f3n; o f\u00edsica, eliminando f\u00edsicamente el registro del fichero. El borrado f\u00edsico consiste muchas veces en reescribir de nuevo el fichero en otro fichero sin los datos que se desean eliminar y luego renombrarlo al fichero original.</li> <li>Modificaciones: Consiste en cambiar parte del contenido de un registro. Antes de realizar la modificaci\u00f3n ser\u00e1 necesario localizar el registro a modificar dentro del fichero; y una vez localizarlo se realizan los cambios y se reescribe el registro.</li> <li>Consultas: Consiste en buscar en el fichero un registro determinado.</li> </ul>"},{"location":"bloque_iv/tema_14/page-2/#operaciones-sobre-ficheros-secuenciales","title":"Operaciones sobre ficheros secuenciales","text":"<p>En los ficheros secuenciales los registros se insertan en orden cronol\u00f3gico, es decir, un registro se inserta a continuaci\u00f3n del \u00faltimo insertado. Si hay que a\u00f1adir nuevos registros estos se a\u00f1aden a partir del final del fichero.</p> <p>Veamos c\u00f3mo se realizan las operaciones t\u00edpicas:</p> <ul> <li>Consultas: Para consultar un determinado registro es necesario empezar la lectura desde el primer registro, y continuar leyendo secuencialmente hasta localizar el registro buscado. Por ejemplo, si el registro a buscar es el 90 dentro del fichero, ser\u00e1 necesario leer secuencialmente los 89 que le preceden.</li> <li>Altas: En un fichero secuencial las altas se realizan al final del \u00faltimo registro insertado, es decir, solo se permite a\u00f1adir datos al final del fichero.</li> <li>Bajas: Para dar de baja un registro de un fichero es necesario leer todos los registros uno a uno y escribirlos en un fichero auxiliar, salvo el que deseamos dar de baja. Una vez reescritos hemos de borrar el fichero inicial y renombrar el fichero auxiliar d\u00e1ndole el nombre del fichero original.</li> <li>Modificaciones: Consiste en localizar el registro a modificar, efectuar la modificaci\u00f3n y reescribir el fichero inicial en otro fichero auxiliar que incluya el registro modificado. El proceso es similar a las bajas.</li> </ul> <p>Los ficheros secuenciales se usan t\u00edpicamente en aplicaciones de proceso por lotes como, por ejemplo, en el respaldo de los datos o back-up, y son \u00f3ptimos en dichas aplicaciones si se procesan todos los registros. La ventaja de estos ficheros es la r\u00e1pida capacidad de acceso al siguiente registro (son r\u00e1pidos cuando se accede a los registros de forma secuencial) y que aprovechan mejor la utilizaci\u00f3n del espacio. Tambi\u00e9n son sencillos de usar y aplicar.</p> <p>La desventaja es que no se puede acceder directamente a un registro determinado, hay que leer antes todos los anteriores; es decir, no soporta acceso aleatorio. Otra desventaja es el proceso de actualizaci\u00f3n, la mayor\u00eda de los ficheros secuenciales no pueden ser actualizados, habr\u00e1 que reescribirlos totalmente. Para las aplicaciones interactivas que incluyen peticiones o actualizaciones de registros individuales, los ficheros secuenciales ofrecen un rendimiento pobre.</p>"},{"location":"bloque_iv/tema_14/page-2/#operaciones-sobre-los-ficheros-aleatorios","title":"Operaciones sobre los ficheros aleatorios","text":"<p>Las operaciones en ficheros aleatorios son las vistas anteriormente, pero teniendo en cuenta que para acceder a un registro hay que localizar la posici\u00f3n o direcci\u00f3n donde se encuentra. Los ficheros de acceso aleatorio en disco manipulan direcciones relativas en lugar de direcciones absolutas (n\u00famero de pista y n\u00famero de sector en el disco), lo que hace al programa independiente de la direcci\u00f3n absoluta del fichero en el disco.</p> <p>Normalmente para posicionamos en un registro es necesario aplicar una funci\u00f3n de conversi\u00f3n, que usualmente tiene que ver con el tama\u00f1o del registro y con la clave del mismo (la clave es el campo o campos que identifica de forma un\u00edvoca a un registro). Por ejemplo, disponemos de un fichero de empleados con tres campos: identificador, apellido y salario. Usamos el identificador como campo clave del mismo, y le damos el valor 1 para el primer empleado, 2 para el segundo empleado y as\u00ed sucesivamente; entonces, para localizar al empleado con identificador X necesitamos acceder a la posici\u00f3n tama\u00f1o*(X-1) para acceder a los datos de dicho empleado.</p> <p>Puede ocurrir que al aplicar la funci\u00f3n al campo clave nos devuelva una posici\u00f3n ocupada por otro registro, en ese caso, habr\u00eda que buscar una nueva posici\u00f3n libre en el fichero para ubicar dicho registro o utilizar una zona de excedentes dentro del mismo para ir ubicando estos registros.</p> <p>Veamos c\u00f3mo se realizan las operaciones t\u00edpicas:</p> <ul> <li>Consultas: para consultar un determinado registro necesitamos saber su clave, aplicar la funci\u00f3n de conversi\u00f3n a la clave para obtener la direcci\u00f3n y leer el registro ubicado en esa posici\u00f3n. Habr\u00eda que comprobar si el registro buscado est\u00e1 en esta posici\u00f3n si no est\u00e1, se buscar\u00eda en la zona de excedentes.</li> <li>Altas: para insertar un registro necesitamos saber su clave, aplicar la funci\u00f3n de conversi\u00f3n a la clave para obtener la direcci\u00f3n y escribir el registro en la posici\u00f3n devuelta. Si la posici\u00f3n est\u00e1 ocupada por otro registro, en ese caso el registro se insertar\u00eda en la zona de excedentes.</li> <li>Bajas: !as bajas suelen realizarse de forma l\u00f3gica, es decir, se suele utilizar un campo del registro a modo de switch que tenga el valor 1 cuando el registro exista y le damos el valor O para darle de baja, f\u00edsicamente el registro no desaparece del disco. Habr\u00eda que localizar el registro a dar de baja a partir de su campo clave y reescribir en este campo el valor O.</li> <li>Modificaciones: para modificar un registro hay que localizarlo, necesitamos saber su clave para aplicar la funci\u00f3n de conversi\u00f3n y as\u00ed obtener la direcci\u00f3n, modificar los datos que nos interesen y reescribir el registro en esa posici\u00f3n.</li> </ul> <p>Una de las principales ventajas de los ficheros aleatorios es el r\u00e1pido acceso a una posici\u00f3n determinada para leer o escribir un registro. El gran inconveniente es establecer la relaci\u00f3n entre la posici\u00f3n que ocupa el registro y su contenido; ya que a veces al aplicar la funci\u00f3n de conversi\u00f3n para obtener la posici\u00f3n se obtienen posiciones ocupadas y hay que recurrir a la zona de excedentes. Otro inconveniente es que se puede desaprovechar parte del espacio destinado al fichero, ya que se pueden producir huecos (posiciones no ocupadas) entre un registro y otro.</p>"},{"location":"bloque_iv/tema_14/page-3/","title":"3 Ficheros de Textos","text":""},{"location":"bloque_iv/tema_14/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>En Java podemos utilizar dos tipos de ficheros: de texto o binarios; y el acceso a los mismos se puede realizar de forma secuencial o aleatoria. Los ficheros de texto est\u00e1n compuestos de caracteres legibles, mientras que los binarios pueden almacenar cualquier tipo de dato (int, float, boolean, etc.)</p>"},{"location":"bloque_iv/tema_14/page-3/#ficheros-de-texto","title":"Ficheros de texto","text":"<p>Los ficheros de texto, los que normalmente se generan con un editor, almacenan caracteres alfanum\u00e9ricos en un formato est\u00e1ndar (ASCII, UNICODE, UTF8, etc.) Para trabajar con ellos usaremos las clases <code>FileReader</code> para leer caracteres y <code>FileWriter</code> para escribir los caracteres en el fichero. Cuando trabajamos con ficheros, cada vez que leemos o escribimos en uno debemos hacerlo dentro de un manejador de excepciones try-catch. Al usar la clase FileReader se puede generar la excepci\u00f3n <code>FileNotFoundException</code>, ya que el nombre del fichero no exista o no sea v\u00e1lida, y al usar la clase FileWriter la excepci\u00f3n IOException, ya que el disco est\u00e9 lleno o protegido contra escritura.</p>"},{"location":"bloque_iv/tema_14/page-3/#lectura-de-ficheros-de-texto","title":"Lectura de ficheros de texto","text":"<p>Los m\u00e9todos que proporciona la clase FileReader para la lectura son los siguientes:.</p> M\u00e9todo Funci\u00f3n int read() Lee un car\u00e1cter y lo devuelve int read(char[] buf) Lee hasta buf.length caracteres de datos de una matriz de caracteres (buf). Los caracteres le\u00eddos del fichero se van almacenando en buf. int read(char[] buf, int desplazamiento, int n) Lee hasta n caracteres de datos de la matriz buf comenzando por buf[desplazamiento] y devuelve el n\u00famero le\u00eddo de caracteres. <p>En un programa Java para crear o abrir un fichero se invoca a la clase File y a continuaci\u00f3n se crea el flujo de entrada hacia el fichero con la clase FileReader. Despu\u00e9s se realizan las operaciones de lectura o escritura y cuando terminemos de usarlo lo cerraremos mediante el m\u00e9todo close().</p> <pre><code>public class ReadFile {\n    public void show() throws IOException {\n        File file = new File(\"src/exercises/bloque_iv/tema_14/text_files/ReadFile.java\");\n        FileReader reader = new FileReader(file);\n\n        int i;\n        while ((i = reader.read()) != -1) { //se va leyendo un car\u00e1cter\n            System.out.println((char) i);\n            reader.close();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        new ReadFile().show();\n    }\n}\n</code></pre> <p>En el ejemplo, la expresi\u00f3n (char) i convierte el valor entero recuperado por el m\u00e9todo read() a car\u00e1cter, es decir, hacemos un cast a char. Se llega al final del fichero cuando el m\u00e9todo read() devuelve -1. Tambi\u00e9n se puede declarar el fichero de la siguiente manera:</p> <pre><code>FileReader reader = new FileReader(\"src/exercises/bloque_iv/tema_14/text_files/ReadFile.java\");\n</code></pre> <p>Si en vez de leer de car\u00e1cter a car\u00e1cter queremos ir leyendo en mayores cantidades, ser\u00e1 necesario crearse un buffer con la cantidad a leer:</p> <pre><code>char b[]= new char[20];\nwhile ((i = fic.read(b)) != -1) System.out.println(b);\n</code></pre>"},{"location":"bloque_iv/tema_14/page-3/#bufferedreader","title":"BufferedReader","text":"<p>FileReader no contiene m\u00e9todos que nos permita leer l\u00edneas completas, pero <code>BufferedReader</code> s\u00ed; dispone del m\u00e9todo <code>readLine()</code> que lee una l\u00ednea del fichero y la devuelve, o devuelve null si no hay nada que leer o se llega al final del fichero.</p> <p>Tambi\u00e9n dispone del m\u00e9todo <code>read()</code> para leer un car\u00e1cter. Para construir un BufferedReader es necesario un FileReader.</p> <pre><code>public class BufferRead {\n    public void show() {\n        try{\n            BufferedReader buffer = new BufferedReader(new FileReader(\n                    \"src/exercises/bloque_iv/tema_14/text_files/ReadFile.java\"));\n            String linea;\n            while((linea = buffer.readLine()) != null){\n                System.out.println(linea);\n            }\n            buffer.close();\n        } catch(FileNotFoundException fn){\n            System.out.println(\"No se encuentra el fichero\");\n        } catch(IOException e){\n            System.out.println(\"Error de E/S\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new BufferRead().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-3/#escritura-de-ficheros-de-textos","title":"Escritura de Ficheros de Textos","text":"<p>La clase FileWriter es la que se usa para poder escribir en ficheros de textos. Los m\u00e9todos que proporciona son:</p> M\u00e9todo Funci\u00f3n void write(int c) Escribe un car\u00e1cter. void write(char[] buf) Escribe un array de car\u00e1cteres. void write(char[] buf, int desplazamiento, int n) Escribe n caracteres de datos en la matriz buf comenzando por buf[desplazamiento] void write(String str) Escribe una cadena de caracteres void append(char c) A\u00f1ade un car\u00e1cter a un fichero. <p>Estos m\u00e9todos tambi\u00e9n pueden lanzar la excepci\u00f3n IOException. Igual que antes declaramos el fichero mediante la clase File y a continuaci\u00f3n se crea el flujo de salida hacia el fichero con la clase FileWriter.</p> <pre><code>public class Write {\n    public void show() throws IOException {\n        File fichero = new File(\"file.txt\"); //declarar fichero\n        FileWriter fic = new FileWriter(fichero);\n\n        String cadena = \"Esto es una prueba con FileWriter\";\n\n        char[] cad  = cadena.toCharArray();\n        for (char c : cad) {\n            fic.write(c); // se va escribiendo un car\u00e1cter\n        }\n\n        fic.append('*'); //se a\u00f1ade al final un *\n        fic.close(); //cerrar fichero\n    }\n\n    public static void main(String[] args) {\n        new Write().show();\n    }\n}\n</code></pre> <p>Warning</p> <p>Si el fichero a escribir no existe, se crear\u00e1 de forma autom\u00e1tica. Adem\u00e1s, hay que tener en cuenta que si el fichero existe cuando vayamos a escribir caracteres sobre \u00e9l, todo lo que ten\u00eda almacenado anteriormente se borrar\u00e1. Si queremos a\u00f1adir caracteres al final, usaremos la clase FileWriter a\u00f1adiendo un valor booleano, de tal forma que si es true, a\u00f1adir\u00e1 caracteres al final, si es false, lo sobrescribir\u00e1, de la misma forma como si no ponemos dicho valor.</p> <pre><code>FileWrite fic = new FileWriter(fichero, true);\n</code></pre>"},{"location":"bloque_iv/tema_14/page-3/#bufferedwriter","title":"BufferedWriter","text":"<p>La clase <code>BufferedWriter</code> tambi\u00e9n deriva de la clase Writer. Esta clase a\u00f1ade un buffer para realizar una escritura eficiente de caracteres. Para construir un BufferedWriter necesitamos la clase FileWriter. El m\u00e9todo <code>newLine()</code> sirve para escribir un salto de l\u00ednea.</p> <pre><code>public class BufferWrite {\n    public void show() {\n        try{\n            BufferedWriter fichero = new BufferedWriter(\n                    new FileWriter(\"file.txt\"));\n\n            for(int i = 1; i &lt; 11; i++){\n                fichero.write(\"Fila numero: \" + i); //escribe una l\u00ednea\n                fichero.newLine(); // escribe un salto de l\u00ednea\n            }\n\n            fichero.close();\n        } catch (FileNotFoundException fn){\n            System.out.println(\"No se encuentra el fichero\");\n        } catch (IOException io){\n            System.out.println(\"Error de E/S\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new BufferWrite().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-3/#printwriter","title":"PrintWriter","text":"<p>La clase PrintWriter, que tambi\u00e9n deriva de Writer, posee los m\u00e9todos print(String), println(String), printf(String, Object) para escribir en un fichero.</p> <p>Los tres m\u00e9todos reciben una String y lo escriben en un fichero, pero el segundo m\u00e9todo a\u00f1ade un salto de l\u00ednea y el tercero la cadena formateada.</p> <pre><code>public class PrintWrite {\n    public void show() throws IOException {\n        PrintWriter fichero = new PrintWriter(new FileWriter(\"file.txt\"));\n\n        for(int i = 1; i &lt; 11; i++){\n            fichero.println(\"Fila numero: \" + i);\n        }\n\n        fichero.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new PrintWrite().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-4/","title":"4 Ficheros Binarios","text":""},{"location":"bloque_iv/tema_14/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Los ficheros binarios almacenan secuencias de d\u00edgitos binarios que no son legibles directamente por el usuario. Tienen la ventaja de que ocupan menos espacio en disco.</p> <p>En Java, las dos clases que que nos permiten trabajar con ficheros son <code>FileInputStream</code>, para entrada de datos, y <code>FileOutputStream</code>, para salida. Estas dos clases trabajan con flujos de bytes y crean un enlace entre el flujo de bytes y el fichero.</p>"},{"location":"bloque_iv/tema_14/page-4/#fileinputstream","title":"FileInputStream","text":"<p>Los m\u00e9todos que proporciona la clase <code>FileInputStream</code> para lectura son similares a los vistos para la clase FileReader, estos m\u00e9todos devuelven el n\u00famero de bytes le\u00eddos o -1 si se ha llegado al final.</p> M\u00e9todo Funci\u00f3n int read() Lee un byte y lo devuelve int read(byte[] b) Lee hasta b.length bytes de datos de una matriz de bytes int read(byte[] b, int desplazamiento, int n) Lee hasta n bytes de la matriz b comenzando por b[desplazamiento] y devuelve el n\u00famero le\u00eddo de bytes. <pre><code>public class ReadFile {\n    public void show() throws IOException {\n        File file = new File(\"src/exercises/bloque_iv/tema_14/binary_files/ReadFile.java\");\n        FileInputStream reader = new FileInputStream(file);\n\n        int i;\n        while ((i = reader.read()) != -1) { \n            System.out.println((char) i);\n            reader.close();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        new ReadFile().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-4/#fileoutputstream","title":"FileOutputStream","text":"<p>Los m\u00e9todos que proporciona la clase <code>FileOutputStream</code> para escritura son:</p> M\u00e9todo Funci\u00f3n void write() Escribe un byte void write(byte[] b) Escribe b.length bytes void write(byte[] b, int desplazamiento, int n) Escribe n bytes de la matriz b comenzando por b[desplazamiento]. <p>Para a\u00f1adir bytes al final del fichero usaremos FileOutputStream colocando en el segundo par\u00e1metro del constructor el valor true.</p> <pre><code>public class WriteFile {\n    public void show() throws IOException {\n        File fichero = new File(\"file.txt\"); //declarar fichero\n        FileOutputStream fic = new FileOutputStream(fichero);\n\n        String cadena = \"Esto es una prueba con FileWriter\";\n\n        char[] cad  = cadena.toCharArray();\n        for (char c : cad) {\n            fic.write(c); // se va escribiendo un car\u00e1cter\n        }\n\n        fic.close(); //cerrar fichero\n    }\n\n    public static void main(String[] args) {\n        new WriteFile().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-4/#lectura-y-escritura-de-datos-primitivos","title":"Lectura y escritura de datos primitivos","text":"<p>Para leer y escribir datos de tipos primitivos: int, float, long, etc usaremos las clases <code>DataInputStream</code> y <code>DataOutputStream</code>. Estas clases definen diversos m\u00e9todos <code>readXXX</code> y <code>writeXXX</code> que son variaciones de los m\u00e9todos read() y write() de la clase base para leer y escribir datos de tipo primitivo. Algunos de los m\u00e9todos se muestran en la siguiente tabla:</p> M\u00c9TODOS PARA LECTURA M\u00c9TODOS PARA ESCRITURA boolean readBoolean(); void writeBoolean(boolean v); byte readByte(); void writeByte(int v); int readUnsignedByte(); void writeBytes(String s); int readUnsignedShort(); void writeShort(int v); short readShort(); void writeChars(String s); char readChar(); void writeChar(int v); int readInt(); void writeInt(int v); long readLong(); void writeLong(long v); float readFloat(); void writeFloat(float v); double readDouble(); void writeDouble(double v); String readUTF(); void writeUTF(String str); <p>Para crear un objeto det tipo DataInputStream o DataOutputStream es necesario pasarle como argumento en el constructor un FileInputStream y un FileOutputStream, respectivamente.</p> <p>El siguiente ejemplo inserta datos en el fichero data_file.dat, los datos los toma de dos arrays, uno contiene los nombres de una serie de personas y el otro sus edades, recorremos los arrays y vamos escribiendo en el fichero el nombre y la edad.</p> <pre><code>public class DataWrite {\n    public void show() throws IOException {\n        File f = new File(\"FilesData.dat\");\n        FileOutputStream file = new FileOutputStream(f);\n        DataOutputStream writer = new DataOutputStream(file);\n        String[] nombres = {\"Ana\", \"Luis Miguel\", \"Alicia\", \"Pedro\", \n                \"Manuel\", \"Andr\u00e9s\", \"Julio\", \"Antonio\", \"Mar\u00eda Jes\u00fas\"};\n        int[] edades = {14, 15, 13, 15, 16, 12, 16, 14, 13};\n\n        for (int i = 0; i &lt; edades.length; i++) {\n            writer.writeUTF(nombres[i]); // escribe nombre\n            writer.writeInt(edades[i]); // escribe edad\n        }\n\n        writer.close(); // cierre\n    }\n\n    public static void main(String[] args) throws IOException {\n        new DataWrite().show();\n    }\n}\n</code></pre> <p>En el siguiente ejemplo visualiza los datos grabados anteriormente en el fichero, se deben recuperar en el mismo orden en el que se escribieron, es decir, primero obtenemos el nombre y luego la edad.</p> <pre><code>public class DataRead {\n    public void show() throws IOException {\n        File f = new File(\"FilesData.dat\");\n        FileInputStream file = new FileInputStream(f);\n        DataInputStream reader = new DataInputStream(file);\n        String n;\n        int e;\n\n        try{\n            while(true){\n                n = reader.readUTF(); // recupera el nombre\n                e = reader.readInt(); // recupera la edad\n                System.out.println(\"Nombre: \" + n + \", edad: \" + e );\n            }\n        } catch(EOFException ignored){}\n\n        reader.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new DataRead().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-5/","title":"5 Escritura y Lectura de Objeto","text":""},{"location":"bloque_iv/tema_14/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Si se quiere guardar en archivo un objeto con varios atributos, se podr\u00eda guardar en un fichero, guardando cada atributo por separado como un dato primitivo. Pero esto se puede volver engorroso si hay una gran cantidad de objetos.</p> <p>Para ello, Java permite guardar objetos en ficheros binarios, por lo que la clase tiene que implementar la interfaz <code>Serializable</code>.</p>"},{"location":"bloque_iv/tema_14/page-5/#interfaz-serializable","title":"Interfaz Serializable","text":"<p>La interfaz serializable es un interfaz que permite guardar objetos en fichero binarios. Para que un objeto pueda ser escrito en un fichero binario, la clase de dicho objeto debe implementar dicha interfaz.</p> <p>La interfaz dispone de una serie de m\u00e9todos con los que podremos guardar y leer objetos en ficheros binarios. Lo m\u00e1s importantes son:</p> <ul> <li><code>Object readObject()</code>: Se utiliza para leer un objeto del ObjectInputStream. Puede lanzar las excepciones IOException y ClassNotFoundException.</li> <li><code>void writeObject(Object obj)</code>: Se utiliza para escribir el objeto especificado en el objeto ObjectOutputStream. Puede lanzar la excepci\u00f3n IOException.</li> </ul> <p>La serializaci\u00f3n de objetos de Java permite tomar cualquier objeto que implemente la interfaz Serializable y convertido en una secuencia de bits que puede ser posteriormente restaurada para regenerar el objeto original.</p> <p>Para leer y escribir objetos serializables a un stream se utilizan las clases de Java ObjectInputStream y ObjectOutputStream respectivamente.</p> <pre><code>import java.io.Serializable;\npublic class Person implements Serializable{\n    private String name;\n    private int age;\n\n    public Person(String name, int age){\n        this.name = name;\n        this.age = age;\n    }\n    public Person(){\n        this.name = null;\n    }\n    public void setName(String name){this.name = name;}\n    public void setAge(int age){this.age = age;}\n\n    public String getName(){return this.name;}\n    public int getAge(){return this.age;}\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-5/#escritura-con-objetos","title":"Escritura con objetos","text":"<p>Para escribir un objeto en un fichero, ser\u00e1 necesario crear un flujo de salida a disco con FileOutputStream y crear el flujo de salida ObjectOutputStream que es el que procesa los datos y se ha de vincular al fichero de FileOutputStream</p> <p>El m\u00e9todo writeObject() escribe los objetos al flujo de salida y los guarda en el fichero en disco.</p> <pre><code>public class WriteObjects {\n    public void show() throws IOException {\n        Person p; // Define la variable persona\n        File f = new File(\"person.dat\"); // Declara el fichero\n        FileOutputStream file = new FileOutputStream(f); // Crea el flujo de salida\n        ObjectOutputStream writer = new ObjectOutputStream(file);\n        String[] names = {\"Ana\", \"Luis Miguel\", \"Alicia\", \"Pedro\", \"Manuel\", \"Andr\u00e9s\", \n                \"Julio\", \"Antonio\", \"Mar\u00eda Jes\u00fas\"};\n        int[] ages = {14,15,13,15,16,12,16,14,13};\n\n        for(int i = 0; i &lt; ages.length; i++){\n            p = new Person(names[i], ages[i]);\n            writer.writeObject(p); // Escribe la persona en el fichero\n        }\n\n        writer.close(); // Cierra el stream de salida\n    }\n\n    public static void main(String[] args) throws IOException {\n        new WriteObjects().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-5/#lectura-con-objetos","title":"Lectura con objetos","text":"<p>Para leer los objetos de un fichero se necesita el flujo de entrada a disco FileInputStream y a continuaci\u00f3n crear el flujo de entrada ObjectInputStream que es el que procesa los datos y se ha de vincular al fichero de FileInputStream</p> <p>El m\u00e9todo readObject() lee los objetos del flujo de entrada, puede lanzar la excepci\u00f3n ClassNotFoundException e IOException, por lo que habr\u00e1 que controlarlas. El proceso de lectura se hace en un bucle while(true), este se encierra en un bloque try-catch ya que la lectura finalizar\u00e1 cuando llegue al final del fichero, por lo que lanzar\u00e1 la excepci\u00f3n EOFException.</p> <pre><code>public class ReadObjects {\n    public void show() throws IOException, ClassNotFoundException {\n        Person p; // Define la variable persona\n        File f = new File(\"files/PersonFile.dat\");\n        FileInputStream file = new FileInputStream(f); // Crea el flujo de entrada\n        ObjectInputStream object = new ObjectInputStream(file); // Conecta el flujo de bytes al flujo de datos\n\n        try{\n            while(true){\n                p = (Person) object.readObject();\n                System.out.printf(\"Nombre: %s, edad: %d \\n\", p.getName(), p.getAge());\n            }\n        } catch (EOFException eo){\n            System.out.println(\"Fin de Lectura\");\n        }\n\n        object.close(); // Cerrar stream de entrada\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        new ReadObjects().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-5/#problema-con-los-ficheros-de-objetos","title":"Problema con los ficheros de objetos","text":"<p>Existe un problema con los ficheros de objetos. Al crear un fichero de objetos se crea una cabecera inicial con informaci\u00f3n y a continuaci\u00f3n se a\u00f1aden los objetos. Si el fichero se utiliza de nuevo para a\u00f1adir m\u00e1s registros, se crea una nueva cabecera y se a\u00f1aden los objetos a partir de esa cabecera. El problema surge al leer el fichero cuando en la lectura se encuentra con la segunda cabecera, y aparece la excepci\u00f3n StreamCorruptedException y no se puede leer m\u00e1s objetos.</p> <p>La cabecera se crea cada vez que se pone crea un objeto de la clase ObjectOutputStream(f).</p> <p>Para que no se a\u00f1adan dichas cabeceras se suele redefinir la clase ObjectOutputStream creando una nueva clase que la herede, y dentro de dicha clase se redefine el m\u00e9todo writeStreamHeader(), que se encarga de escribir las cabeceras.</p> <p>De esta forma, si el fichero ya se ha creado se llamar\u00e1 a ese m\u00e9todo de la clase redefinida.</p> <pre><code>public class MyObjectOutputStream extends ObjectOutputStream{\n    public MyObjectOutputStream(OutputStream out) throws IOException{\n        super(out);\n    }\n\n    protected MyObjectOutputStream() throws IOException, SecurityException{\n        super();\n    }\n\n    @Override\n    protected void writeStreamHeader(){}\n}\n</code></pre> <p>A la hora de usarlo dentro de nuestro programa, a la hora de abrir el fichero para a\u00f1adir nuevos objetos se pregunta si ya existe, en caso afirmativo crea el objeto, y si no existe se crea con la clase ObjectOutputStream</p> <pre><code>File f = new File(\"files/PersonFile.dat\");\npublic class WriteObject {\n    public void show() throws IOException {\n        File f = new File(\"files/PersonFile.dat\");\n        ObjectOutputStream writer;\n        Person p;\n        if(!f.exists()){\n            FileOutputStream file = new FileOutputStream(f);\n            writer = new ObjectOutputStream(file);\n        } else {\n            writer = new MyObjectOutputStream(new FileOutputStream(f, true));\n        }\n\n        String[] names = {\"Ana\", \"Luis Miguel\", \"Alicia\", \"Pedro\", \"Manuel\", \"Andr\u00e9s\",\n                \"Julio\", \"Antonio\", \"Mar\u00eda Jes\u00fas\"};\n        int[] ages = {14,15,13,15,16,12,16,14,13};\n\n        for(int i = 0; i &lt; ages.length; i++){\n            p = new Person(names[i], ages[i]);\n            writer.writeObject(p); // Escribe la persona en el fichero\n        }\n\n        writer.close(); // Cierra el stream de salida\n    }\n\n    public static void main(String[] args) {\n        new WriteObject().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-6/","title":"6 Fichero de Acceso Aleatorio","text":""},{"location":"bloque_iv/tema_14/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Hasta ahora, todas las operaciones que se han realizado sobre los ficheros se realizaban de forma secuencial, es decir, se empezaba la lectura en el primer dato (byte, car\u00e1cter u objeto), y seguidamente se le\u00edan los siguientes uno a continuaci\u00f3n del otro hasta terminar el fichero. De la misma forma se hac\u00eda la escritura.</p> <p>Una de las desventajas que supone esto es que si se desea acceder a uno los elementos intermedios o se quiere insertar un elemento en medio del fichero, habr\u00eda que leer o escribir de forma secuencial el fichero hasta la posici\u00f3n de inserci\u00f3n o lectura, y luego realizar la operaci\u00f3n, lo que lo hace bastante trabajoso.</p> <p>Java dispone de la clase <code>RandomAccessFile</code> que dispone de m\u00e9todos para acceder al contenido de un fichero binario de forma aleatoria, es decir, no secuencial; para posicionarnos en una posici\u00f3n concreta del mismo. Esta clase no hereda de InputStream/OutputStream, ya que su comportamiento es totalmente distinto puesto que se puede avanzar y retroceder dentro de un fichero.</p>"},{"location":"bloque_iv/tema_14/page-6/#clase-randomaccessfile","title":"Clase RandomAccessFile","text":"<p>La clase RandomAccessFile es una clase de Java que permite acceder al contenido de un fichero posicion\u00e1ndose en una posici\u00f3n concreta del mismo. Se dice que se accede de forma aleatoria y no secuencial.</p> <p>La clase dispone de dos constructores para crear el fichero de acceso aleatorio (puede lanzar la excepci\u00f3n FileNotFoundException):</p> <ul> <li><code>RandomAccessFile(String nombreFichero, String modoAcceso)</code>: Contiene la cadena del nombre del fichero incluido en el path.</li> <li><code>RandomAccessFile(File file, String modoAcceso)</code>: Contiene el objeto File asociado a un fichero.</li> </ul> <p>El argumento modoAcceso puede tener dos valores:</p> <ul> <li>r \u2192 Abre el fichero en modo de solo lectura, por lo que debe existir. Una operaci\u00f3n de escritura en este fichero lanzar\u00e1 la excepci\u00f3n IOException.</li> <li>rw \u2192 Abre el fichero en modo lectura y escritura. En caso de que no exista dicho fichero, se crea.</li> </ul> <p>Una vez abierto el fichero pueden usarse los m\u00e9todos <code>readXXX</code> y <code>writeXXX</code> de las clases DataInputStream y DataOutputStream.</p> <p>La clase RandomAccessFile maneja un puntero que indica la posici\u00f3n actual en el fichero. Cuando el fichero se crea el puntero al fichero se coloca en 0, apuntando al principio del mismo. Las sucesivas llamadas a los m\u00e9todos read() y write() ajustan el puntero seg\u00fan la cantidad de bytes le\u00eddos o escritos.</p> <p>Los m\u00e9todos m\u00e1s importantes son:</p> M\u00e9todo Funci\u00f3n long getFilePointer() Devuelve la posici\u00f3n actual del puntero del fichero. void seek(long posici\u00f3n) Coloca el puntero del fichero en una posici\u00f3n determinada desde el comienzo del mismo. long length() Devuelve el tama\u00f1o del fichero en bytes. La posici\u00f3n length() marca el final del fichero. int skipBytes(int desplazamiento) Desplaza el puntero desde la posici\u00f3n actual el n\u00famero de bytes indicados en desplazamientos."},{"location":"bloque_iv/tema_14/page-6/#escritura-de-archivos-de-acceso-aleatorio","title":"Escritura de archivos de acceso aleatorio","text":"<p>Este ejemplo inserta datos de empleados en un fichero aleatorio. Los datos a insertar son: apellido, departamento y salario, que se obtienen de arrays que se llenan en el programa, los datos se van introduciendo de forma secuencial por lo que no va a ser necesario usar m\u00e9todo seek(). Por cada empleado tambi\u00e9n se insertar\u00e1 un identificador (mayor que 0) que coincidir\u00e1 con el \u00edndice +1 con el que se recorren los arrays. La longitud del registro de cada empleado es la misma (36 bytes) y los tipos se insertan y su tama\u00f1o en bytes es el siguiente:</p> <ul> <li>Se inserta en primer lugar un entero, que es el identificador, ocupa 4 bytes.</li> <li>A continuaci\u00f3n una cadena de 10 caracteres, es el apellido. Como Java utiliza caracteres UNICODE, cada car\u00e1cter de una cadena de caracteres ocupa 16 bits (2 bytes), por lo tanto, el apellido ocupa 20 bytes.</li> <li>Un tipo entero que es el departamento, ocupa 4 bytes.</li> <li>Un tipo double que es el salario, ocupa 8 bytes.</li> </ul> <p>Tama\u00f1os de otros tipos: short (2 bytes), byte (1 byte), long (8 bytes), boolean (1 byte), float (4 bytes), etc.</p> <p>El fichero se abre en modo \"rw\" para lectura y escritura.</p> <pre><code>public class Write {\n    public void show() throws IOException {\n        File f = new File(\"employee.dat\");\n        RandomAccessFile randomFile = new RandomAccessFile(f, \"rw\");\n\n        String[] apellido = { \"FERNANDEZ\", \"GIL\", \"LOPEZ\", \"RAMOS\", \"SEVILLA\", \"CASILLA\", \"REY\"};\n        int[] dep = {10,20,10,10,30,30,20};\n        double[] salario = {1000.45, 2400.60, 3000.0, 1500.56, 2200.0, 1435.87, 2000.0};\n\n        StringBuilder buffer = null;\n        int n = apellido.length;\n\n        for(int i = 0; i &lt; n; i++){ // Se recorre los arrays\n            randomFile.writeInt(i+1); // Uso i+1 para identificar al empleado\n\n            buffer = new StringBuilder(apellido[i]);\n            buffer.setLength(10); // 10 caracteres para el apellido\n            randomFile.writeChars(buffer.toString()); // Insertar apellido\n\n            randomFile.writeInt(dep[i]); // Insertar departamento\n            randomFile.writeDouble(salario[i]); // Insertar salario\n        }\n        randomFile.close(); // Cierre de fichero\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Write().show();\n    }\n}\n</code></pre> <p>Para acceder a un registro espec\u00edfico, podemos usar la siguiente formula siendo n el n\u00famero de registro que quiero acceder.</p> <p>F\u00f3rmula de acceso $$ (n-1)*36 $$</p>"},{"location":"bloque_iv/tema_14/page-6/#lectura-de-ficheros-de-acceso-aleatorio","title":"Lectura de ficheros de acceso aleatorio","text":"<p>Ahora se visualiza todos los registros. El posicionamiento para empezar a recorrer los registros empieza en 0, para recuperar los siguientes registros hay que sumar 36 (tama\u00f1o del registro) a la variable utilizada para el posicionamiento.</p> <pre><code>public class Read {\n    public void show() throws IOException {\n        File f = new File(\"files/EmployerRandom.dat\");\n        RandomAccessFile randomFile = new RandomAccessFile(f, \"r\"); // Solo lectura\n\n        int id, dep, posicion;\n        double salario;\n        char[] apellido = new char[10];\n        String apellidos;\n        char aux;\n\n        posicion = 0; //  se sit\u00faa al principio\n        do {\n            randomFile.seek(posicion); // se posiciona en posici\u00f3n\n            id = randomFile.readInt(); // se obtiene id del empleado\n\n            // se recorre uno a uno los caracteres del apellido\n            for (int i = 0; i &lt; apellido.length; i++) {\n                aux = randomFile.readChar();\n                apellido[i] = aux;\n            }\n\n            // convierte a String el array\n            apellidos = new String(apellido);\n            dep = randomFile.readInt(); // obtiene el departamento\n            salario = randomFile.readDouble(); // obtiene el salario\n\n            if (id &gt; 0) {\n                System.out.printf(\"ID: %s, Apellido: %s, Departamento: %d, Salario: %.2f \\n\",\n                        id, apellidos.trim(), dep, salario);\n            }\n\n            // se posiciona para el siguiente empleado\n            posicion = posicion + 36;\n\n            // si se ha recorrido TO DO los bytes se sale del bucle\n        } while (randomFile.getFilePointer() != randomFile.length());\n        randomFile.close();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-6/#consultar-datos","title":"Consultar datos","text":"<p>Para consultar datos determinados de un fichero no es necesario recorrer todos los registros del fichero, conociendo su identificador se puede acceder a la posici\u00f3n que ocupa dentro del mismo y as\u00ed obtener sus datos.</p> <p>OJO</p> <p>Es recomendable que si se va a leer/escribir de forma secuencial NO se maneje el puntero</p> <p>Por ejemplo, se supone que se desean obtener los datos del empleado con identificador 5, para calcular la posici\u00f3n se ha de tener en cuenta los bytes que ocupa cada registro, en este caso 36:</p> <pre><code>public class Select {\n    public void show() throws IOException {\n        File f = new File(\"files/EmployerRandom.dat\");\n        RandomAccessFile file = new RandomAccessFile(f, \"r\"); // Solo lectura\n\n        int id, dep;\n        double salario;\n        char[] apellido = new char[10];\n        String apellidos;\n        char aux;\n        int identificador = 5;\n        int position = (identificador - 1) * 36;\n\n        if (position &gt;= file.length()) {\n            System.out.printf(\"ID: %d, NO EXISTE EMPLEADO...\\n\", identificador);\n        } else {\n            file.seek(position); // se posiciona\n            id = file.readInt(); // obtengo el id del empleado\n            // se recorre uno a uno los caracteres del apellido\n            for (int i = 0; i &lt; apellido.length; i++) {\n                aux = file.readChar();\n                apellido[i] = aux;\n            }\n\n            // convierto a String el array\n            apellidos = new String(apellido);\n            dep = file.readInt(); // obtiene el departamento\n            salario = file.readDouble(); // obtiene el salario\n\n            if (id &gt; 0) {\n                System.out.printf(\"ID: %s, Apellido: %s, Departamento: %d, Salario: %.2f \\n\",\n                        id, apellidos.trim(), dep, salario);\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Select().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-6/#insertar-datos","title":"Insertar datos","text":"<p>Para a\u00f1adir un registro a partir del \u00faltimo insertado, hay que posicionarse al final del fichero.</p> <pre><code>long posicion = file.length();\nfile.seek(posicion);\n</code></pre> <p>Para insertar un nuevo registro se aplica la funci\u00f3n al identificador para calcular la posici\u00f3n.</p> <pre><code>StringBuffer buffer = null; // buffer para almacenar el apellido\nString apellido = \"GONZALEZ\"; // apellido a insertar\ndouble salario = 1230.97; // salario\nint id = 20; // id del empleado\nint dep = 10; // departamento del empleado\n\nlong posicion = (id -1)*36; // se calcula la posici\u00f3n\n\nfile.seek(posicion); // se posiciona\nfile.writeInt(id); // escribe la id\nbuffer = new StringBuffer(apellido);\nbuffer.setLength(10); // 10 caracteres para el apellido\nfile.writeChars(buffer.toString()); // inserta el apellido\nfile.writeInt(dep); // inserta el departamento\nfile.writeDouble(salario); //inserta salario\nfile.close(); // cierra el fichero\n</code></pre>"},{"location":"bloque_iv/tema_14/page-6/#modificar-un-registro","title":"Modificar un registro","text":"<p>Para modificar un registro, se accede a la posici\u00f3n y se efect\u00faa las modificaciones. Es necesario que el fichero se abra en modo rw.</p> <pre><code>int registro = 4; // id a modificar\nlong posicion = (registro - 1) * 36; // calculo la posicion\nposicion = posicion + 4 + 20;// sumo el tama\u00f1o de ID + apellido\nfile.seek(posicion); // se posiciona\nfile.writeInt(40); // modifico el departamento\nfile.writeDouble(4000.87); // modifico el salario\n</code></pre>"},{"location":"bloque_iv/tema_14/page-6/#writeutf","title":"writeUTF","text":"<p>El m\u00e9todo <code>writeUTF()</code> me permite escribir una cadena completa en un fichero aleatorio. Tenemos que tener en cuenta que para cadena ocupar\u00e1 siempre 2 bytes de m\u00e1s, ya que tambi\u00e9n almacenada el tama\u00f1o de la cadena.</p> <pre><code>int stringSize = 10;\nint intSize = 2;\nint totalSize = stringSize+intSize+2;\n\nrandomAccess.writeUTF(String.format(\"%-\"+stringSize\"s\", \"Holaa\"));\n</code></pre> <p>\u00a1Importante!</p> <p>Cuando el tama\u00f1o m\u00e1ximo a escribir, es mayor que el tama\u00f1o real de la cadena, se escribir\u00e1n null. En el ejemplo anterior el tama\u00f1o m\u00e1ximo de cadena es de 10, mientras que la cadena \"Holaa\", es de tama\u00f1o 5, por lo que se escribir\u00eda \"HolaaNULLNULLNULLNULLNULL\", 5 null para poder llegar al m\u00e1ximo, aunque esto puede ser un problema.</p> <p>Si queremos escribir una cadena con writeUTF tendremos que formatear la cadena de tal forma que me escriba espacios en blanco en vez de null, para ello ser\u00eda \u00fatil usar String.format(), con el tama\u00f1o de la cadena, en negativo, para que ponga los espacios a la derecha de la cadena.</p>"},{"location":"bloque_iv/tema_14/page-7/","title":"7 Introducci\u00f3n a los ficheros XML","text":""},{"location":"bloque_iv/tema_14/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>XML (eXtensible Markup Language) es un metalenguaje, es decir, un lenguaje para la definici\u00f3n de lenguajes de marcado. Este tipo de fichero permite jerarquizar y estructurar la informaci\u00f3n y describir los contenidos dentro del propio documento.</p> <p>Los ficheros XML son ficheros de texto escritos en este lenguaje, donde la informaci\u00f3n est\u00e1 organizada de forma secuencial y en orden jer\u00e1rquico.</p> <p>Existen unas marcas especiales que sirven para delimitar las marcas que dan estructuran al documento (&lt; y &gt;). Cada marca tiene un nombre y puede contener varios atributos.</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;Empleados&gt;\n &lt;empleado&gt;\n     &lt;iD&gt;1&lt;/iD&gt;\n        &lt;apellido&gt;FERNANDEZ&lt;/apellido&gt;\n        &lt;departamento&gt;10&lt;/departamento&gt;\n        &lt;salario&gt;1000.45&lt;/salario&gt;\n    &lt;/empleado&gt;\n    &lt;empleado&gt;\n     &lt;iD&gt;2&lt;/iD&gt;\n        &lt;apellido&gt;GIL&lt;/apellido&gt;\n        &lt;departamento&gt;20&lt;/departamento&gt;\n        &lt;salario&gt;2400.6&lt;/salario&gt;\n    &lt;/empleado&gt;\n    &lt;empleado&gt;\n     &lt;iD&gt;3&lt;/iD&gt;\n        &lt;apellido&gt;LOPEZ&lt;/apellido&gt;\n        &lt;departamento&gt;10&lt;/departamento&gt;\n        &lt;salario&gt;3000.0&lt;/salario&gt;\n    &lt;/empleado&gt;\n&lt;/Empleados&gt;\n</code></pre>"},{"location":"bloque_iv/tema_14/page-7/#acceso-a-ficheros-xml","title":"Acceso a ficheros XML","text":"<p>Los ficheros XML se pueden utilizar para proporcionar datos a una base de datos o para almacenar copias de partes del contenido de una base de datos. Tambi\u00e9n se utilizan para escribir ficheros de configuraci\u00f3n de programas o en el protocolo SOAP (Simple Object Access Protocol) para ejecutar comandos en servidores remotos.</p> <p>Para leer los ficheros XML y acceder a su contenido y estructura se utiliza un procesador de XML o parse. El procesador lee los documentos y proporciona un acceso a su contenido y estructura. Alguno de los procesadores m\u00e1s usados son:</p> <ul> <li>DOM (Modelo de Objetos de Documento). Almacena toda la estructura del documento en memoria en forma del \u00e1rbol con nodos padre, nodos hijos y nodos finales (no tienen descendientes). Este tipo de procesamiento necesita m\u00e1s recursos de memoria y tiempo sobre todo si los ficheros XML a procesar son bastante grandes y complejos.</li> <li>SAX (API Simple para XML). Lee un fichero en forma secuencial y produce una secuencia de eventos (comienzo/fin del documento, de la etiqueta, etc) en funci\u00f3n de los resultados de la lectura. Este tipo de procesamiento pr\u00e1cticamente no consume memoria, pero por otra parte, impide tener una visi\u00f3n global del documento por el que navegar.</li> </ul>"},{"location":"bloque_iv/tema_14/page-8/","title":"8 Serializaci\u00f3n de Objetos a XML","text":""},{"location":"bloque_iv/tema_14/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Para serializar de forma sencilla objetos Java a XML y viceversa, se suele usar la librer\u00eda XStream.</p> <p>Para usarla hay que descargarse los JAR desde el sitio web https://x-stream.github.io/</p> <p>Se descomprime y se inserta al proyecto los JAR xstream-X.X.X.jar ubicada dentro de la carpeta lib. Tambi\u00e9n ser\u00e1 necesario el fichero kxml-X.X.X.jar que se localiza en la carpeta lib/xstream.</p> <p>Otra manera de poder usar es a trav\u00e9s de los gestores de paquetes Maven o Gradle, entre otros.</p>"},{"location":"bloque_iv/tema_14/page-8/#escritura-de-ficheros-xml","title":"Escritura de ficheros XML","text":"<p>Para escribir un fichero XML usando la librer\u00eda XStream, deberemos crear una clase que contenga una lista de los datos que queremos insertar, y despu\u00e9s deberemos insertamos dicha lista en un XML usando la funci\u00f3n toXML() que me permitir\u00e1 parsear la lista a XML.</p> <p>En est\u00e1 librer\u00eda encontramos los siguientes m\u00e9todos \u00fatiles:</p> <ul> <li>alias(): Este m\u00e9todo sirve para cambiar el nombre de la etiqueta de la clase en XML. Por ejemplo, si tenemos una clase ListProduct, la etiqueta XML por defecto ser\u00e1 <code>&lt;ListProduct&gt;&lt;/ListProduct&gt;</code>, si queremos cambiar dicha etiqueta usaremos dicho m\u00e9todo con el nombre de la etiqueta y la clase necesaria.</li> <li>aliasField(): Es igual que el m\u00e9todo anterior pero para los atributos de la clase.</li> <li>addImplicitCollection(). Este m\u00e9todo no a\u00f1ade la etiqueta del atributo de la lista que contiene la lista de objetos que queremos parsear.</li> </ul> ListaContactosMain <pre><code>public class ListaContactos {\n    private final List&lt;Person&gt; list = new ArrayList&lt;&gt;();\n\n    public ListaContactos() {}\n\n    public List&lt;Person&gt; getList() {\n        return list;\n    }\n\n    public void add(Person person){\n        list.add(person);\n    }\n}\n</code></pre> <pre><code>public class WriteXML {\n    public void show() {\n        XStream xStream = new XStream();\n        ListaContactos listaContactos = new ListaContactos();\n        File destino = new File(\"person.xml\");\n\n        listaContactos.add(new Person(\"Mar\u00eda\", 25));\n        listaContactos.add(new Person(\"Juli\u00e1n\", 33));\n\n        try{\n            xStream.alias(\"ListaPersonas\", ListaContactos.class);\n            xStream.alias(\"Contactos\", Person.class);\n            xStream.addImplicitCollection(ListaContactos.class, \"list\");\n            xStream.aliasField(\"NombreContacto\", Person.class, \"name\");\n            xStream.aliasField(\"Tel\u00e9fonoContacto\", Person.class, \"age\");\n            xStream.toXML(listaContactos, new FileOutputStream(destino));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new WriteXML().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-8/#lectura-de-ficheros-xml","title":"Lectura de ficheros XML","text":"<p>Para leer un fichero serializado XML con XStream ser\u00e1 necesario volver a indicarle las al\u00edas, en caso de haberlo hecho.</p> <p>\u00a1Importante!</p> <p>En algunas ocasiones para leer un fichero, ser\u00e1 necesario darle permiso, por lo que usaremos la funci\u00f3n <code>addPermission()</code></p> <pre><code>public class ReadXML {\n    public void show() {\n        XStream xStream = new XStream();\n        ListaContactos listaContactos;\n        File file = new File(\"person.xml\");\n\n        try {\n            xStream.addPermission(AnyTypePermission.ANY);\n            xStream.alias(\"ListaPersonas\", ListaContactos.class);\n            xStream.alias(\"Contactos\", Person.class);\n            xStream.addImplicitCollection(ListaContactos.class, \"list\");\n            xStream.aliasField(\"NombreContacto\", Person.class, \"name\");\n            xStream.aliasField(\"Tel\u00e9fonoContacto\", Person.class, \"age\");\n            listaContactos = (ListaContactos) xStream.fromXML(new FileInputStream(file));\n            for (Person person : listaContactos.getList()) {\n                System.out.println(person);\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new ReadXML().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-9/","title":"9 Acceso a ficheros XML con SAX","text":""},{"location":"bloque_iv/tema_14/page-9/#introduccion","title":"Introducci\u00f3n","text":"<p>SAX (API Simple para XML) es un conjunto de clases e interfaces que ofrecen una herramienta muy \u00fatil para el procesamiento de documentos XML. Permite analizar los documentos de forma secuencial, lo que implica poco consumo de memoria aunque los documentos sean de gran tama\u00f1o. Pero por lo contrario, impide tener una visi\u00f3n global del documento que se va a analizar.</p> <p>SAX es m\u00e1s complejo de programar que DOM, ya que es una API totalmente escrita en Java e incluida dentro del JRE que nos permite crear nuestro propio parser de XML.</p>"},{"location":"bloque_iv/tema_14/page-9/#lectura-de-un-documento-xml","title":"Lectura de un documento XML","text":"<p>La lectura de un documento XML produce eventos que ocasiona la llamada a m\u00e9todos, los eventos son encontrar la etiqueta de inicio y fin del documento (startDocument() y endDocument()), la etiqueta de inicio y fin de un elemento (startElement() y endElement()), los caracteres entre etiquetas (characters()), etc.</p> Documentos XML M\u00e9todos asociados a eventos del documento &lt;?xml version=\"1.o\"?&gt;<code>&lt;listadealumnos&gt;</code> <code>&lt;alumno&gt;</code> <code>&lt;nombre&gt;</code>   Juan <code>&lt;/nombre&gt;</code> <code>&lt;edad&gt;</code>   19 <code>&lt;/edad&gt;</code> <code>&lt;/alumno&gt;</code> <code>&lt;alumno&gt;&lt;br/&gt;</code> <code>&lt;nombre&gt;</code>   Mar\u00eda <code>&lt;/nombre&gt;</code> <code>&lt;edad&gt;</code>   20 <code>&lt;/edad&gt;</code> <code>&lt;/alumno&gt;</code><code>&lt;/listadealumnos&gt;</code> starDocument()starElement() startElement()  startElement()   characters()  endElement()  startElement()   characters()  endElement() endElement()starElement() startElement()  startElement()   characters()  endElement()  startElement()   characters()  endElement() endElement()endDocument() <p>Para leer un documento se crea un objeto procesador de XML, un XMLReader, que puede producir un excepci\u00f3n SAXException que es necesario capturar.</p> <p>A continuaci\u00f3n hay que indicar al XMLReader que objetos poseen los m\u00e9todos que tratar\u00e1n los eventos. Estos objetos ser\u00e1n normalmente implementaciones de las siguientes interfaces:</p> <ul> <li>ContentHandler: Recibe las notificaciones de los eventos que ocurren en el documento.</li> <li>DTDHandler: Recoge eventos relacionados con la DTD.</li> <li>ErrorHandle: Define los m\u00e9todos de tratamientos de errores.</li> <li>EntityResolver: Sus m\u00e9todos se llaman cada vez que se encuentra una referencia a una entidad.</li> <li>DefaultHandler: Clase que provee una implementaci\u00f3n por defecto para todos sus m\u00e9todos, el programador definir\u00e1 los m\u00e9todos que sean utilizados por el programa. Esta clase es de la que se extender\u00e1 para poder crear una clase parser de XML:</li> <li>startDocument(): se produce al comenzar el procesado del documento XML.</li> <li>endDocument(): se produce al finalizar el procesado del documento XML.</li> <li>startElement(): se produce al finalizar el procesado del documento XML.</li> <li>endElement(): se produce al finalizar el procesado de una etiqueta XML.</li> <li>characters(): se produce al encontrar una cadena de texto.</li> </ul> <p>Para indicar al procesador XML los objetos que realizar\u00e1n el tratamiento se utilizan alguno de los siguientes m\u00e9todos incluidos dentro de los objetos XMLReader: setContentHandler(), setDTDHandler(), setEntityResolver() y setErrorHandler(); cada uno trata un tipo de evento asociado a una interfaz determinada. Despu\u00e9s se lee mediante el objeto InputSource.</p> Gestor de ContenidoMain <pre><code>public class GestorDeContenidos extends DefaultHandler {\n    public GestorDeContenidos() { super(); }\n\n    @Override\n    public void startDocument() throws SAXException {\n        System.out.println(\"Comienzo del Documento XML\");\n    }\n\n    @Override\n    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n        System.out.printf(\"\\tPrincipio Elemento: %s\\n\", localName);\n    }\n\n    @Override\n    public void characters(char[] ch, int start, int length) throws SAXException {\n        String car = new String(ch, start, length);\n        car = car.replaceAll(\"[\\t\\n]\", \"\");\n        System.out.printf(\"\\tCaracteres: %s\\n\", car);\n    }\n\n    @Override\n    public void endElement(String uri, String localName, String qName) throws SAXException {\n        System.out.printf(\"\\tFin Elemento: %s\\n\", localName);\n    }\n\n    @Override\n    public void endDocument() throws SAXException {\n        System.out.println(\"Final del Documento\");\n    }\n}\n</code></pre> <pre><code>public class ReadSax {\n    public void show() throws SAXException, IOException, ParserConfigurationException {\n        XMLReader procesadorXML = SAXParserFactory.newInstance().newSAXParser().getXMLReader(); //XMLReaderFactory.createXMLReader();\n        HandlerContent handler = new HandlerContent();\n        procesadorXML.setContentHandler(handler);\n        InputSource fileXML = new InputSource(\"file.xml\");\n        procesadorXML.parse(fileXML);\n    }\n\n    public static void main(String[] args) throws IOException, SAXException, ParserConfigurationException {\n        new ReadSax().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-9/#atributos-xml","title":"Atributos XML","text":"<p>Un fichero XML puede contener atributos, por lo que podemos recorrerlos al recorrer el elemento:</p> <pre><code>public void startElement(String uri, String localName, String name,\n    Attributes attributes) throws SAXException {\n    int i;\n    System.out.println(\"\\nProcesando etiqueta...\");\n    System.out.println(\"\\tNamespace uri: \"+uri);\n    System.out.println(\"\\tNombre: \"+localName);\n    System.out.println(\"\\tNombre con prefijo: \"+name);\n    //Recorremos los atributos\n    System.out.println(\"\\tProcesando \"+attributes.getLength()+\" atributos...\");\n    for(i=0;i&lt;attributes.getLength();i++){\n    System.out.println(\"\\t\\tNombre: \"+attributes.getQName(i));\n    System.out.println(\"\\t\\tValor: \"+attributes.getValue(i));\n    }\n    // Tambi\u00e9n podemos obtener los atributos por nombre\n    String valorId = attributes.getValue(\"id\");\n    if(valorId!=null){\n    System.out.println(\"\\tId: \"+valorId);\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_14/page-9/#estilos-con-xsl","title":"Estilos con XSL","text":"<p>XSL (Extensible Stylesheet Language) es una recomendaci\u00f3n para expresar hojas de estilo en lenguaje XML. Una hoja de estilo XSL describe el proceso de presentaci\u00f3n a trav\u00e9s de un peque\u00f1o conjunto de elementos XML.</p> <p>Una hoja de estilo XSL describe el proceso de presentaci\u00f3n a trav\u00e9s de un peque\u00f1o conjunto de elementos XML. Esta hoja, puede contener elementos de reglas que representan a las reglas de construcci\u00f3n y elementos de reglas de estilo que representan a las reglas de mezcla de estilos.</p> <pre><code>&lt;?xml version=\"1.0\" encoding='ISO-8859-1'?&gt;\n&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;\n &lt;xsl:template match='/'&gt;\n   &lt;html&gt;&lt;xsl:apply-templates /&gt;&lt;/html&gt;\n &lt;/xsl:template&gt;\n &lt;xsl:template match='listadealumnos'&gt;\n    &lt;head&gt;&lt;title&gt;LISTADO DE ALUMNOS&lt;/title&gt;&lt;/head&gt;\n    &lt;body&gt; \n    &lt;h1&gt;LISTA DE ALUMNOS&lt;/h1&gt;\n    &lt;table border='1'&gt;\n    &lt;tr&gt;&lt;th&gt;Nombre&lt;/th&gt;&lt;th&gt;Edad&lt;/th&gt;&lt;/tr&gt;\n      &lt;xsl:apply-templates select='alumno' /&gt;\n    &lt;/table&gt;\n    &lt;/body&gt;\n &lt;/xsl:template&gt;\n &lt;xsl:template match='alumno'&gt;\n   &lt;tr&gt;&lt;xsl:apply-templates /&gt;&lt;/tr&gt;\n &lt;/xsl:template&gt;\n &lt;xsl:template match='nombre|edad'&gt;\n   &lt;td&gt;&lt;xsl:apply-templates /&gt;&lt;/td&gt;\n &lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</code></pre> <p>Para realizar la transformaci\u00f3n se necesita obtener un objeto Transformer que se obtiene creando una instancia de TransformerFactory y aplicando el m\u00e9todo newTransformer(Source source) a la fuente XSL que se va a utilizar para aplicar la transformaci\u00f3n, o lo que es lo mismo, para aplicar la hoja de estilos XSL al fichero XML.</p> <pre><code>public class XLS {\n    public void show() throws IOException {\n        String hojaEstilo = \"alum_template.xsl\";\n        String datosAlumnos = \"alum.xml\";\n        File pagHTML = new File(\"page.html\");\n\n        FileOutputStream os = new FileOutputStream(pagHTML);\n        Source estilos = new StreamSource(hojaEstilo); // fuenteXSL\n        Source datos = new StreamSource(datosAlumnos); // fuenteXML\n\n        Result result = new StreamResult(os);\n\n        try{\n            Transformer transformer = TransformerFactory.newInstance().newTransformer(estilos);\n            transformer.transform(datos, result);\n        } catch (Exception e){\n            System.err.println(\"Error: \"+ e);\n        }\n        os.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new XLS().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_15/page-1/","title":"1 Introducci\u00f3n a las bases de datos","text":""},{"location":"bloque_iv/tema_15/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Una base de datos es una recopilaci\u00f3n organizada de informaci\u00f3n o datos estructurados que normalmente se almacenan de forma electr\u00f3nica en un sistema inform\u00e1tico.</p> <p>Acceso a datos es el proceso de recuperaci\u00f3n o manipulaci\u00f3n de datos extra\u00eddos de un origen de datos local o remoto. Alguno de los or\u00edgenes de datos con los que podemos encontrarnos son: base de datos relacional remota a un servidor o local, una hoja de c\u00e1lculo, un fichero de texto en nuestro ordenador, un servicio de informaci\u00f3n online, etc.</p> <p>Un conector es un software que se encargar\u00e1 de las conexiones desde el programa Java con una base de datos relacional.</p> <p>Existen diferentes tipos de bases de datos:</p> <ul> <li>Relacionales o SQL. Son las m\u00e1s usadas como tecnolog\u00eda de las industrias. Est\u00e1n dise\u00f1adas para almacenar datos estructurados en tablas relacionadas entre s\u00ed. Las tablas est\u00e1n organizadas en filas y columnas y utilizan claves para relacionar los datos entre ellas. Las bases de datos relacionales son muy escalables y ofrecen una gran flexibilidad en cuanto a la forma en que se pueden consultar los datos. Son ideales para aplicaciones que requieren transacciones en tiempo real, como sistemas de gesti\u00f3n de inventario, ventas o finanzas.      Figura 1 - Gestores de Bases de Datos SQL </li> <li>No Relacionales o no SQL. Son una alternativa a las bases de datos relacionales. No utilizan tablas y claves como las bases de datos relacionales, sino que utilizan una variedad de estructuras de datos, como documentos, gr\u00e1ficos y pares clave-valor. Las bases de datos NoSQL son muy escalables y ofrecen un rendimiento excelente para grandes conjuntos de datos no estructurados, como datos de redes sociales o de Internet de las cosas (IoT).      Figura 2 - Gestores de Bases de Datos NpSQL </li> <li>Bases de datos de Objetos. Las bases de datos de objetos son un tipo de base de datos NoSQL que almacenan datos como objetos. Est\u00e1n dise\u00f1adas para trabajar con lenguajes de programaci\u00f3n orientados a objetos, como Java o Python. Las bases de datos de objetos son ideales para aplicaciones que necesitan almacenar y manipular objetos complejos y jer\u00e1rquicos, como aplicaciones de modelado 3D o simulaci\u00f3n de f\u00edsica.</li> <li>Bases de datos de grafos. Las bases de datos de grafos est\u00e1n dise\u00f1adas para trabajar con datos relacionales complejos, como las relaciones sociales o las redes de transporte. Utilizan un modelo de datos basado en nodos y relaciones, lo que les permite almacenar y acceder a datos relacionales complejos con facilidad. Las bases de datos de grafos son ideales para aplicaciones que necesitan an\u00e1lisis complejos y b\u00fasqueda de patrones en grandes conjuntos de datos relacionales.</li> <li>Bases de datos en memoria. Las bases de datos en memoria son una forma de base de datos que almacena datos directamente en la memoria de la computadora, en lugar de en el disco duro. Esto les permite ofrecer un rendimiento excepcionalmente r\u00e1pido para aplicaciones que requieren acceso instant\u00e1neo a los datos, como juegos en l\u00ednea o aplicaciones de trading de alta frecuencia.</li> </ul> <p>Elegir el tipo de base de datos adecuado es una parte importante del proceso de dise\u00f1o de cualquier sistema de informaci\u00f3n. Cada tipo de base de datos tiene sus propias fortalezas y debilidades, y elegir el tipo adecuado para la tarea en cuesti\u00f3n puede marcar una gran diferencia en la eficiencia y eficacia del sistema. Al elegir la base de datos adecuada, es importante tener en cuenta los requisitos del sistema en cuanto al rendimiento, escalabilidad, estructura de datos y seguridad, as\u00ed como la experiencia del usuario.</p>"},{"location":"bloque_iv/tema_15/page-1/#2-el-desfase-objecto-relacional","title":"2. El desfase Objecto-Relacional","text":"<p>Actualmente las bases de datos orientadas a objetos est\u00e1n ganando cada vez  m\u00e1s aceptaci\u00f3n frente a las bases de datos relacionales, ya que solucionan las necesidades de aplicaciones m\u00e1s sofisticadas para dise\u00f1o y fabricaci\u00f3n.</p> <p>Las bases de datos relacionales no est\u00e1n dise\u00f1adas para almacenar objetos, ya que existe un desfase entre las construcciones t\u00edpicas que proporciona el modelo de datos relacional y las proporcionadas por los ambientes de programaci\u00f3n basados en objetos, es decir, al guardar los datos de un programa bajo el enfoque orientado a objetos se incrementa la complejidad del programa, dando lugar a m\u00e1s c\u00f3digo y m\u00e1s esfuerzo de programaci\u00f3n debido a la diferencia de esquemas entre los elementos a almacenar (objetos) y las caracter\u00edsticas del repositorio de la base de datos (Tablas)</p> <p>Info</p> <p>Para saber m\u00e1s sobre las bases de datos relacionales visite la siguiente p\u00e1gina:"},{"location":"bloque_iv/tema_15/page-2/","title":"2 Bases de datos embebidas","text":""},{"location":"bloque_iv/tema_15/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Las bases de datos como Oracle o MySQL sirven para almacenar grandes cantidades de informaci\u00f3n. Si por el contrario, no es necesario almacenar tanta informaci\u00f3n se puede utilizar una base de datos embebida donde el motor est\u00e9 incrustado a la aplicaci\u00f3n, y termina cuando se cierra la aplicaci\u00f3n.</p> <p>Estas bases de datos son dependientes de su aplicaci\u00f3n y que no pueden iniciar un servicio independiente de esta en la maquina. Estos gestores de bases de datos, suplen las necesidades que los grandes no pueden cumplir, como la portabilidad, rapidez, rendimiento, integridad referencial, la concurrencia, escasa memoria, entre otras</p>"},{"location":"bloque_iv/tema_15/page-2/#2-sqlite","title":"2 SQLite","text":"<p>SQLite es un sistema gestor de base de datos multiplataforma escrito en C que proporciona un motor muy ligero. Las bases de datos se guardan en forma de ficheros por lo que es f\u00e1cil trasladar la base de datos con la aplicaci\u00f3n que la usa. Cuanta con una utilidad que nos permitir\u00e1 ejecutar comandos SQL en modo consola. Es un proyecto de dominio p\u00fablico.</p> <p>La biblioteca implementa la mayor parte del est\u00e1ndar SQL-92 incluyendo transacciones de base de datos at\u00f3micas, consistencias de base de datos, aislamiento y durabilidad, triggers (o disipadores) y la mayor parte de la consultas complejas.</p> <p>SQLite se puede utilizar desde programas en C/C++, PHP, Visual Basic, Perl, Delphi, Java, etc. Para poder instalarlo accedemos a su p\u00e1gina http://sqlite.org/download.html</p> <p>Alguno de los comandos de consola interesantes de SQLite son:</p> <ul> <li>.help para ayudas.</li> <li>.tables para mostrar las tablas creadas.</li> <li>.quit para salir de la terminal de sql.</li> </ul>"},{"location":"bloque_iv/tema_15/page-3/","title":"3 Protocolos de Acceso a Bases de Datos","text":""},{"location":"bloque_iv/tema_15/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>En tecnolog\u00edas de base de datos podemos encontrarnos con dos normas de conexi\u00f3n a una base de datos SQL:</p> <ul> <li>ODBC (Open Database Connectivity) define una API (Application Program Interface) que pueden usar las aplicaciones para abrir una conexi\u00f3n con una base de datos, enviar consultas, actualizaciones y obtener los resultados. Las aplicaciones pueden usar esta API para conectarse a cualquier servidor de base de datos compatible con ODBC. Est\u00e1 escrito en C.</li> <li>JDBC (Java Database Connectivity) define una API que pueden usar los programas Java para conectarse a los servidores de bases de datos relacionales.</li> </ul>"},{"location":"bloque_iv/tema_15/page-3/#acceso-a-datos-mediante-jdbc","title":"Acceso a Datos mediante JDBC","text":"<p>JDBC proporciona una librer\u00eda est\u00e1ndar para acceder a fuentes de datos principalmente orientados a bases de datos relacionales que usan SQL. No solo provee una interfaz sino que tambi\u00e9n define una arquitectura est\u00e1ndar, para que los fabricantes puedan crear los drivers que permitan a los aplicaciones Java el acceso a los datos. JDBC dispone de una interfaz distinta para cada base de datos, es lo que llamamos driver (controlador o conector). Esto permite que las llamadas a los m\u00e9todos Java de las clases JDBC se correspondan con el API de la base de datos.</p> <p>JDBC consta de un conjunto de clases e interfaces que nos permite escribir aplicaciones Java para gestionar las siguientes tareas con una base de datos relacional:</p> <ul> <li>Conectarse a la base de datos</li> <li>Enviar consultas e instrucciones de actualizaci\u00f3n a la base de datos</li> <li>Recuperar y procesar los resultados recibidos de la base de datos en respuesta a las consultas</li> </ul>"},{"location":"bloque_iv/tema_15/page-3/#dos-modelos-de-acceso-a-bases-de-datos","title":"Dos modelos de acceso a bases de datos","text":"<p>La API JDBC es compatible con los modelos tanto de dos como de tres capas para el acceso a la base de datos.</p> <p>En el modelo de dos capas, un applet o aplicaci\u00f3n Java hablan directamente con la base de datos, esto requiere un driver JDBC residiendo en el mismo lugar que la aplicaci\u00f3n. Desde el programa Java se env\u00edan las sentencias SQL al sistema gestor de Base de datos  para que las procese y los resultados se env\u00edan de vuelta al programa. La base de datos puede encontrarse en otra m\u00e1quina diferente a la de la aplicaci\u00f3n y las solicitudes se hacen a trav\u00e9s de la red. El driver ser\u00e1 encargado de manejar la comunicaci\u00f3n a trav\u00e9s de la red de forma transparente al programa.</p> <p> Figura 3 - Modelo de dos capas</p> <p>En el modelo de tres capas, los comandos se env\u00edan a una capa intermedia que se encargar\u00e1 de enviar los comandos SQL a la base de datos y de recoger los resultados de la ejecuci\u00f3n de las sentencias. En este caso los drivers no tienen que residir en la m\u00e1quina cliente.</p> <p> Figura 4 - Modelo de tres capas</p> <p>Un servidor de aplicaciones es una implementaci\u00f3n de la especificaci\u00f3n J2EE (Java 2 Platform Enterprise Edition). J2EE es un entorno centrado en Java para desarrollar, construir y desplegar aplicaciones empresariales multicapa basadas en la Web. Existen diversas implementaciones, cada una con sus propias caracter\u00edsticas. Algunas de ellas son las siguientes: BEA WebLogic, IBM WebSphere, Oracle IAS, Borland AppServer, etc</p>"},{"location":"bloque_iv/tema_15/page-3/#tipos-de-drivers","title":"Tipos de drivers","text":"<p>Existen 4 tipos de drivers JDBC:</p> <ul> <li>Tipo 1. JDBC-ODBC Bridge Permite el acceso a bases de datos JDBC mediante un driver ODBC. Convierte las llamadas al API de JDBC en llamadas ODBC. Exige la instalaci\u00f3n y configuraci\u00f3n de ODBC en la m\u00e1quina cliente.</li> <li>Tipo 2. Native Controlador escrito parcialmente en Java y en c\u00f3digo nativo de la base de datos. Traduce las llamadas al API de JDBC Java en llamadas propias del motor de base de datos. Exige instalar en la m\u00e1quina cliente c\u00f3digo binario propio del cliente de base de datos y del sistema operativo.</li> <li>Tipo 3. Network Controlador de Java puro que utiliza un protocolo de red (HTTP) para comunicarse con el servidor de base de datos. Traduce las llamadas al API de JDBC Java en llamadas propias del protocolo de red independiente de la base de datos y a continuaci\u00f3n son traducidas por un software intermedio (Middleware) al protocolo usado por el motor de base de datos. El driver JDBC no comunica directamente con la base de datos, comunica con el software intermedio, que a su vez comunica con la base de datos. Son \u00fatiles para aplicaciones que necesitan interactuar con diferentes formatos de bases de datos, ya que usan el mismo driver JDBC sin importar la base de datos espec\u00edfica. No exige la instalaci\u00f3n en cliente.</li> <li>Tipo 4. Thin Controlador de Java puro con protocolo nativa. Traduce las llamadas al API de JDBC Java en llamadas propias del protocolo de red usado por el motor de base de datos. No exige instalaci\u00f3n en el cliente</li> </ul> <p>Warning</p> <p>Los tipos 3 y 4 son la mejor forma para acceder a bases de datos JDBC. Los tipos 1 y 2 se usan normalmente cuando no queda otro remedio, porque el \u00fanico sistema de acceso final al gestor de bases de datos es ODBC. En la mayor\u00eda de los casos la opci\u00f3n m\u00e1s adecuada ser\u00e1 el tipo 4.</p>"},{"location":"bloque_iv/tema_15/page-4/","title":"4 Funcionamiento del JDBC","text":""},{"location":"bloque_iv/tema_15/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>JDBC define carias interfaces que permite realizar operaciones con base de datos. Est\u00e1n definidas en el paquete java.sql.</p> Clase e Interfaz Descripci\u00f3n Driver Permite conectarse a una base de datos: cada gestor de base de datos requiere un driver distinto. DriverManager Permite gestionar todos los drivers instalados en el sistema. DriverPropertyInfo Proporciona diversa informaci\u00f3n acerca de un driver Connection Representa una conexi\u00f3n con una base de datos, Una aplicaci\u00f3n puede tener m\u00e1s de una conexi\u00f3n. DatabaseMetadata Proporciona informaci\u00f3n acerca de una base de datos, como las tablas que contiene... Statement Permite ejecutar sentencias SQL sin par\u00e1metros PreparedStatement Permite ejecutar sentencias SQL con par\u00e1metros de entrada CallableStatement Permite ejecutar sentencias SQL con par\u00e1metros de entrada y salida, como llamadas a procedimientos almacenados. ResultSet Contiene las filas resultantes de ejecutar una orden SELECT. ResultSetMetadata Permite obtener informaci\u00f3n sobre un ResultSet, como el n\u00famero de columnas, su nombres, etc <p>El trabajo con JDBC comienza con la clase DriverManager que es la encargada de establecer las conexiones con los or\u00edgenes de datos a trav\u00e9s de los drivers JDBC. El funcionamiento es el siguiente:</p> <ol> <li>Importar las clases necesarias</li> <li>Cargar el drivers JDBC</li> <li>Identificar el origen de datos</li> <li>Crear un objeto Connection</li> <li>Crear un objeto Statement</li> <li>Ejecutar una consulta con el objeto Statement</li> <li>Recuperar los datos del objeto ResultSet</li> <li>Liberar el objeto ResultSet</li> <li>Liberar el objeto Statement</li> <li>Liberar el objeto Connection</li> </ol> <p> Figura 4 - Funcionamiento de JDBC</p>"},{"location":"bloque_iv/tema_15/page-4/#conexion-a-una-bd","title":"Conexi\u00f3n a una BD","text":"<p>En una base de datos MySQL tenemos una base de datos llamada empresa y un usuario llamado usuario con la misma contrase\u00f1a. El usuario tendr\u00e1 todos los privilegios sobre esta base de datos.</p> <pre><code>create database empleados;\n\nCREATE USER 'usuario'@'localhost' identified by 'usuario';\n\nGRANT ALL PRIVILEGES ON empleados.* TO 'usuario'@localhost;\n\nFLUSH PRIVILEGES;\n</code></pre> <p>Tenemos las siguientes tablas: empleados y departamentos con los siguientes datos:</p> <pre><code>CREATE TABLE departamentos(\n dept_no TINYINT(2) NOT NULL PRIMARY KEY,\n    dnombre VARCHAR(15),\n    loc VARCHAR(15)\n) ENGINE=InnoDB;\n\nCREATE TABLE empleados(\n emp_no SMALLINT(4) NOT NULL PRIMARY KEY,\n    apellido VARCHAR(10),\n    oficio VARCHAR(10),\n    dir SMALLINT,\n    fecha_alt DATE,\n    salario FLOAT(6,2),\n    comision FLOAT(6,2),\n    dept_no TINYINT(2) NOT NULL,\n    CONSTRAINT FK_DEP FOREIGN KEY (dept_no) REFERENCES departamentos(dept_no)\n) ENGINE=InnoDB;\n\n\nINSERT INTO departamentos VALUES \n(10, 'CONTABILIDAD', 'SEVILLA'),\n(20, 'INVESTIGACI\u00d3N', 'BARCELONA'),\n(30, 'VENTAS', 'BARCELONA'),\n(40, 'PRODUCCI\u00d3N', 'BILBAO');\n\nINSERT INTO empleados VALUES\n(1, 'GARC\u00cdA', 'ANALISTA', 2, '2018-06-06', 2500, 1500, 10),\n(2, 'MORENO', 'CONTABLE', 2, '2019-12-12', 1500, 100, 10),\n(3, 'GOMEZ', 'DEPENDIENTE', 2, '2010-01-12', 1500, 500, 30)\n</code></pre> <p>En el siguiente programa mostramos el contenido de la tabla departamentos:</p> <pre><code> package com.irudev.examples.bloque_iv.tema_15;\n\nimport java.sql.*;\n\npublic class ShowDepartamentos {\n    public void show() {\n        try{\n            // Carga el driver\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n\n            // Establece conexi\u00f3n con la BD\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/empleados\", \"acdat\", \"acdat\");\n\n            // Se prepara la consulta\n            Statement sentence = connection.createStatement();\n            String sql = \"SELECT * FROM departamentos\";\n            ResultSet result = sentence.executeQuery(sql);\n\n            // Recorremos el resultado para visualizar cada filza\n            // Se hace un bucle mientras haya registros y se van mostrando\n            while(result.next()){\n                System.out.printf(\"%d, %s, %s\\n\", result.getInt(1), result.getString(2), result.getString(3));\n            }\n\n            result.close(); // Cerrar ResultSet\n            sentence.close(); // Cerrar Statement\n            connection.close(); // Cerrar conexi\u00f3n\n        } catch (ClassNotFoundException | SQLException e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new ShowDepartamentos().show();\n    }\n}\n</code></pre> <p>En el m\u00e9todo getConnection() de la clase DriverManager le pasamos como argumentos la URL de conexi\u00f3n a base de datos. Siendo en general: <code>jdbc:mysql://&lt;host&gt;:&lt;puerto&gt;/&lt;bd&gt;</code></p> <p>Donde:</p> <ul> <li>jdbc:mysql indica el driver JDBC para MySQL</li> <li>host indica el nombre del servidor d\u00f3nde se encuentra la base de datos. Se puede poner una IP el nombre de la m\u00e1quina en la que est\u00e1 la red. Si indicamos localhost indicamos que el servidor se encuentra en la misma m\u00e1quina d\u00f3nde se ejecuta el programa Java.</li> <li>puerto es el puerto predeterminado para las bases de datos MySQL, por defecto es 3306</li> <li>bd nombre de la base de datos a la que nos vamos a conectar y que debe existir en MySQL.</li> </ul> <p>Se indica el nombre de usuario y la contrase\u00f1a, como segundo y tercer par\u00e1metro respectivamente.</p>"},{"location":"bloque_iv/tema_15/page-4/#obtener-resultados-de-una-consulta","title":"Obtener resultados de una consulta","text":"<p>Para obtener resultados de una consulta ser\u00e1 necesario llamar al m\u00e9todo <code>executeQuery()</code> de la clase <code>Statement</code>. Este m\u00e9todo retornar\u00e1 un <code>ResultSet</code> que contiene internamente un puntero que apunta al primer registro de la lista.</p> <p>ResultSet dispone varios m\u00e9todos para mover dicho puntero:</p> M\u00e9todo Definici\u00f3n boolean next() Mueve el puntero del objeto ResultSet una fila hacia adelante a partir de la posici\u00f3n actual. Devuelve true si el puntero se posiciona correctamente y false si no hay registros en el ResultSet boolean first() Mueve el puntero al primer registro de la lista. Devuelve true si se posiciona correctamente y false si no hay registros. boolean last() Mueve el puntero al \u00faltimo registro anterior de la lista. Devuelve true si se posiciona correctamente y false si no hay registros. boolean previous() Mueve el puntero al registro anterior de la lista. Devuelve true si el puntero se posiciona correctamente y false si se coloca antes del primer registro. void beforeFirst() Mueve el puntero del objeto justo antes del primer registro int getRow() Devuelve el n\u00famero de registro actual."},{"location":"bloque_iv/tema_15/page-5/","title":"5 Ejecuci\u00f3n de sentencias de descripci\u00f3n de datos","text":""},{"location":"bloque_iv/tema_15/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Normalmente cuando desarrollamos una aplicaci\u00f3n JDBC conocemos la estructura de las tablas y datos que estamos manejando, es decir, conocemos, las columnas que tienen y c\u00f3mo est\u00e1n relacionadas entre s\u00ed. Es posible que no conozcamos la estructura de las tablas de una base de datos, en este caso la informaci\u00f3n de la base de datos se puede obtener a trav\u00e9s de los meta objetos, que no son m\u00e1s que objetos que proporcionan informaci\u00f3n sobre las bases de datos.</p> <p>La interfaz <code>DatabaseMetaData</code> proporciona informaci\u00f3n sobre la base de datos a trav\u00e9s de m\u00faltiples m\u00e9todos de los cu\u00e1les es posible obtener gran cantidad de informaci\u00f3n. Muchos de estos m\u00e9todos devuelven un <code>ResultSet</code>, algunos son:</p> M\u00e9todo Descripci\u00f3n getTables() Proporciona informaci\u00f3n sobre las tablas y vistas de la base de datos getColumns() Devuelve informaci\u00f3n sobre las columnas de una tabla getPrimaryKeys() Proporciona informaci\u00f3n sobre las columnas que forman la clave primaria de una tabla getExportedKeys() Devuelve informaci\u00f3n sobre las claves ajenas que utilizan la clave primaria de una tabla getImportedKeys() Devuelve informaci\u00f3n sobre las claves ajenas existentes en una tabla getProcedures() Devuelve informaci\u00f3n sobre los procedimientos almacenados <p>El siguiente ejemplo conecta con la base de datos MySQL de nombre empleados y muestra informaci\u00f3n sobre el producto de base de datos, el driver, la URL para acceder a la base de datos, el nombre de usuario y las tablas y vistas del esquema actual. Un esquema se corresponde generalmente con un usuario de la base de datos. El M\u00e9todo <code>getMetaData()</code> de la interfaz <code>Connection</code> devuelve un objeto <code>DataBaseMetaData</code> que contiene informaci\u00f3n sobre la base de datos representada por el objeto <code>Connection</code>:</p> <pre><code>public class MetaData {\n    public void show() {\n        try{\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            // Se establece conexi\u00f3n con la bases de datos\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/empleados\",\n                    \"acdat\", \"acdat\");\n            DatabaseMetaData dbmd = connection.getMetaData();\n            ResultSet result = null;\n\n            String name   = dbmd.getDatabaseProductName();\n            String driver = dbmd.getDriverName();\n            String url    = dbmd.getURL();\n            String user   = dbmd.getUserName();\n\n            System.out.println(\"INFORMACI\u00d3N SOBRE LA BASE DE DATOS\");\n            System.out.println(\"==================================\");\n            System.out.printf(\"Nombre : %s\\n\", name);\n            System.out.printf(\"Driver : %s\\n\", driver);\n            System.out.printf(\"URL    : %s\\n\", url);\n            System.out.printf(\"User   : %s\\n\", user);\n\n            // Obtener informaci\u00f3n de las tablas y vistas que hay\n            result = dbmd.getTables(null, \"empleados\", null,\n                    null);\n\n            while(result.next()){\n                String catalogue = result.getString(1);\n                String schema = result.getString(2);\n                String table = result.getString(3);\n                String type = result.getString(4);\n                System.out.printf(\"%s - Catalogo: %s, Esquema: %s, Nombre: %s\\n\",\n                        type, catalogue, schema, table);\n            }\n\n            connection.close();\n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new MetaData().show();\n    }\n}\n</code></pre> <p>Los m\u00e9todos usados son los siguientes:</p> M\u00e9todo Descripci\u00f3n int getColumnCount() Devuelve el n\u00famero de columnas devueltas por la consulta String getColumnName(int indice) Devuelve el nombre de la columna cuya posici\u00f3n se indica en indice String getColumnTypeName(int indice) Devuelve el nombre del tipo de dato especifico del sistema de bases de datos que contiene la columna indicada en indice int isNullable(int indice) Devuelve 0 si la columna no puede contener valores nulos. int getColumnDisplaySize(int indice) Devuelve el m\u00e1ximo ancho de caracteres de la columna indicada en indice"},{"location":"bloque_iv/tema_15/page-5/#ejecucion-de-sentencias-de-manipulacion-de-datos","title":"Ejecuci\u00f3n de sentencias de manipulaci\u00f3n de datos","text":"<p>En ejemplos anteriores vimos como se pod\u00edan ejecutar sentencias SQL mediante la interfaz  <code>Statement</code> (sentencia), esta proporciona m\u00e9todos para ejecutar sentencias SQL y obtener los  resultados. Como <code>Statement</code> es una interfaz no se pueden crear objetos directamente, en su lugar  los objetos se obtienen con una llamada al m\u00e9todo <code>createStatement()</code> de un objeto <code>Connection</code>  v\u00e1lido: <code>Statement sentencia = connection.createStatement();</code></p> <p>Al crearse un objeto <code>Statement</code> se crea un espacio de trabajo para crear consultas SQL,  ejecutarlas y para recibir los resultados de las consultas. Una vez creado el objeto se pueden usar  los siguientes m\u00e9todos:  </p> <ul> <li><code>ResultSet executeQuery(String)</code>: se utiliza para sentencias SQL que recuperan datos  de un \u00fanico objeto <code>ResultSet</code>, se utiliza para las sentencias SELECT.  </li> <li><code>int executeUpdate(String)</code>: se utiliza para sentencias que no devuelven un <code>ResultSet</code> como son las sentencias de manipulaci\u00f3n de datos (DML): INSERT, UPDATE y  DELETE; y las sentencias de definici\u00f3n de datos (DDL): CREATE, DROP y ALTER.  El m\u00e9todo devuelve un entero indicando el n\u00famero de filas que se vieron afectadas y  en el caso de las sentencias DDL devuelve el valor 0.</li> <li><code>boolean execute(String)</code>: se puede utilizar para ejecutar cualquier sentencia SQL. Tanto para las que devuelven un <code>ResultSet</code> (por ejemplo, SELECT), como para las  que devuelven el n\u00famero de filas afectadas (por ejemplo, INSERT, UPDATE,  DELETE) y para las de definici\u00f3n de datos como por ejemplo, CREATE. El m\u00e9todo  devuelve true si devuelve un <code>ResultSet</code> (para recuperar las filas ser\u00e1 necesario llamar  al m\u00e9todo <code>getResultSet()</code>) y false si se trata de un recuento de actualizaciones o no  hay resultados; en este caso se usar\u00e1 el m\u00e9todo <code>getUpdateCount()</code> para recuperar el  valor devuelto.</li> </ul> <p>En este ejemplo <code>execute()</code> ejecuta una sentencia SELECT, devuelve true; por tanto, es necesario recuperar las filas devueltas usando el m\u00e9todo  <code>getResultSet()</code></p> <pre><code>public class Execute {\n    public void show() {\n        try{\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/empleados\",\n                    \"acdat\", \"acdat\");\n            String sql = \"SELECT * FROM departamentos\";\n            Statement sentence = connection.createStatement();\n            boolean valor = sentence.execute(sql);\n\n            if(valor){\n                ResultSet result = sentence.getResultSet();\n                while(result.next()){\n                    System.out.printf(\"%d, %s, %s\\n\",\n                            result.getInt(1),\n                            result.getString(2),\n                            result.getString(3));\n                }\n                result.close();\n            } else {\n                int f = sentence.getUpdateCount();\n                System.out.printf(\"Filas afectadas: %d\\n\", f);\n            }\n        } catch (ClassNotFoundException | SQLException e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Execute().show();\n    }\n}\n</code></pre> <p>A trav\u00e9s de un objeto <code>ResultSet</code> se puede acceder al valor de cualquier columna de la fila actual por nombre o por posici\u00f3n, tambi\u00e9n se puede obtener informaci\u00f3n sobre las columnas como el n\u00famero de columnas o su tipo. Algunos son:</p> M\u00e9todo Tipo de Java devuelto getString(int index)getString(String nombre) String getBoolean(int index)getBoolean(String nombre) boolean getByte(int index)getByte(String nombre) byte getShort(int index)getShort(String nombre) short getInt(int index)getInt(String nombre) int getLong(int index)getLong(String nombre) long getFloat(int index)getFloat(String nombre) float getDouble(int index)getDouble(String nombre) double getBytes(int index)getBytes(String nombre) byte[] getDate(int index)getDate(String nombre) Date getTime(int index)getTime(String nombre) Time getTimestamp(int index)getTimestamp(String nombre) Timestamp <p>Ahora, en los siguientes ejemplo, mostraremos una sentencia de inserci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n.</p> INSERTUPDATEDELETE <pre><code>public class Insert {\n    public void show() {\n        try {\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/empleados\",\n                    \"acdat\", \"acdat\");\n\n            int dep = 50;\n            String dName = \"RRHH\";\n            String loc = \"BILBAO\";\n\n            String sql = String.format(\"INSERT INTO departamentos VALUES (%d, '%s', '%s')\",\n                    dep, dName, loc);\n            System.out.println(sql);\n\n            Statement sentence = connection.createStatement();\n            int rows = sentence.executeUpdate(sql);\n            System.out.printf(\"Filas afectadas: %d\\n\", rows);\n\n            sentence.close();\n            connection.close();\n        } catch (ClassNotFoundException | SQLException e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Insert().show();\n    }\n}\n</code></pre> <pre><code>public class Update {\n    public void show() {\n        try {\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/empleados\",\n                    \"acdat\", \"acdat\");\n\n            int dep = 50;\n            double update = 10;\n\n            String sql = String.format(\"UPDATE empleados SET salario = salario + %.0f WHERE dept_no = %d\", update, dep);\n            System.out.println(sql);\n\n            Statement sentence = connection.createStatement();\n            int rows = sentence.executeUpdate(sql);\n            System.out.printf(\"Filas afectadas: %d\\n\", rows);\n\n            sentence.close();\n            connection.close();\n        } catch (ClassNotFoundException | SQLException e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Update().show();\n    }\n}\n</code></pre> <pre><code>public class Delete {\n    public void show() {\n        try {\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/empleados\",\n                    \"acdat\", \"acdat\");\n\n            int dep = 50;\n\n            String sql = String.format(\"DELETE FROM departamentos WHERE dept_no = %d\", dep);\n            System.out.println(sql);\n\n            Statement sentence = connection.createStatement();\n            int rows = sentence.executeUpdate(sql);\n            System.out.printf(\"Filas afectadas: %d\\n\", rows);\n\n            sentence.close();\n            connection.close();\n        } catch (ClassNotFoundException | SQLException e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new Delete().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_15/page-5/#ejecucion-de-scripts","title":"Ejecuci\u00f3n de Scripts","text":"<p>Algunas bases de datos admiten la ejecuci\u00f3n de varias sentencias DDL y/o DML en una misa cadena. Por ejemplo, m\u00faltiples insert. Para ello es necesario indicarlo en la conexi\u00f3n a\u00f1adiendo la propiedad allowMultiQueries=true, tal que as\u00ed:</p> <pre><code>Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/empleados?allowMultiQueries=true\", \"usuario\", \"usuario\");\n</code></pre> <p>A continuaci\u00f3n, vamos a insertar el siguiente script a la base de datos a trav\u00e9s de un programa java:</p> SQLJava <pre><code>SET FOREIGN_KEY_CHECKS = 0;\ndrop table if EXISTS notas;\ndrop table if EXISTS alumnos;\ndrop table if EXISTS asignaturas;\nCREATE TABLE IF NOT EXISTS ALUMNOS(\nDNI VARCHAR(10) NOT NULL primary key,\nAPENOM VARCHAR(30),\nDIREC VARCHAR(15),\nPOBLA VARCHAR(15),\nTELEF VARCHAR(10)\n);\n\nCREATE TABLE IF NOT EXISTS ASIGNATURAS(\nCOD int NOT NULL primary key,\nNOMBRE VARCHAR(25)\n);\n\nCREATE TABLE IF NOT EXISTS NOTAS(\nDNI VARCHAR(10) NOT NULL,\nCOD int NOT NULL,\nNOTA int,\nprimary key(DNI, COD)\n);\n\n/*Create Foreign Keys*/\nALTER TABLE NOTAS\n ADD CONSTRAINT FKNOTASALUM FOREIGN KEY (DNI)\n REFERENCES ALUMNOS (DNI) ON UPDATE CASCADE ON DELETE RESTRICT;\n\nALTER TABLE NOTAS\n ADD CONSTRAINT FKNOTASASIG FOREIGN KEY (COD)\n REFERENCES ASIGNATURAS (COD) ON UPDATE CASCADE ON DELETE RESTRICT;\n\n/*Rellenar Datos*/\nINSERT IGNORE INTO ASIGNATURAS VALUES (1, 'Prog. Leng. Estr.');\nINSERT IGNORE INTO ASIGNATURAS VALUES (2, 'Sist. Inform\u00e1ticos');\nINSERT IGNORE INTO ASIGNATURAS VALUES (3, 'An\u00e1lisis');\nINSERT IGNORE INTO ASIGNATURAS VALUES (4, 'FOL');\nINSERT IGNORE INTO ASIGNATURAS VALUES (5, 'RET');\n\nINSERT IGNORE INTO ALUMNOS VALUES('12344345', 'Alcalde Garc\u00eda, Elena', 'C/Las Matas, 24', 'Madrid', '917766545');\n\nINSERT IGNORE INTO ALUMNOS VALUES('4448242', 'Cerrato Vela, Luis', 'C/Minas 28 - 3A', 'Madrid', '916566545');\n\nINSERT IGNORE INTO ALUMNOS VALUES('56882942', 'D\u00edaz Fern\u00e1ndez, Mar\u00eda', 'C/Luis Vives 25', 'M\u00f3stoles', '915577545');\n\nINSERT IGNORE INTO NOTAS VALUES('12344345', 1, 6);\nINSERT IGNORE INTO NOTAS VALUES('12344345', 2, 5);\n\nINSERT IGNORE INTO NOTAS VALUES('4448242', 4, 6);\nINSERT IGNORE INTO NOTAS VALUES('4448242', 5, 8);\n\nINSERT IGNORE INTO NOTAS VALUES('56882945', 1, 8);\nINSERT IGNORE INTO NOTAS VALUES('56882942', 3, 7);\n\nCOMMIT;\n</code></pre> <pre><code>public class ImportScript {\n    public void show() {\n        File scriptFile = new File(\"src/main/resources/sql.sql\");\n        System.out.println(\"\\n\\nFichero de consulta: \" + scriptFile.getName());\n        System.out.println(\"Convirtiendo el fichero a cadena...\");\n\n        try (BufferedReader entrada = new BufferedReader(new FileReader(scriptFile));\n             Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/empleados?allowMultiQueries=true\",\n                     \"acdat\", \"acdat\");\n             Statement sentence = connection.createStatement()\n        ){\n            StringBuilder stringBuilder;\n            String line;\n            stringBuilder = new StringBuilder();\n            String jump = System.getProperty(\"line.separator\");\n\n            while ((line = entrada.readLine()) != null) {\n                stringBuilder.append(line);\n                stringBuilder.append(jump);\n            }\n\n            String consulta = stringBuilder.toString();\n            System.out.println(consulta);\n\n            int res = sentence.executeUpdate(consulta);\n            System.out.println(\"Script creado con \u00e9xito, res = \" + res);\n\n        } catch (FileNotFoundException e) {\n            System.err.println(\"ERROR NO HAY FILE: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"I/O Error\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new ImportScript().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_15/page-5/#sentencias-preparadas","title":"Sentencias preparadas","text":"<p>La interfaz <code>PreparedStatement</code> nos va a permitir construir una cadena de caracteres SQL con placeholder o marcadores de posici\u00f3n, que representar\u00e1n los datos que ser\u00e1n asignados m\u00e1s tarde, el placeholder se representa mediante el s\u00edmbolo interrogaci\u00f3n (<code>?</code>)</p> <p>Cada placeholder tiene un \u00edndice, el 1 corresponder\u00eda al primero que se encuentre en la cadena,el 2 al segundo y as\u00ed sucesivamente. Solo se pueden utilizar para ocupar el sitio de los datos en la cadena SQL, no se pueden usar para representar una columna o un nombre de una tabla, por ejemplo <code>select * from ?</code> ser\u00eda incorrecto.</p> <p>Antes de ejecutar un <code>PreparedStatement</code> es necesario asignar los datos para que cuando se ejecute la base de datos asigne variables de uni\u00f3n con estos datos y ejecute la orden SQL. Los objetos <code>PreparedStatement</code> se pueden preparar o pre-compilar una sola vez y ejecutar las veces que queramos asignado diferentes valores a los marcadores de posici\u00f3n, en cambio en los objetos Statement, la sentencia SQL se suministra en el momento de ejecutar.</p> <p>Los m\u00e9todos de <code>PreparedStatement</code> tienen los mismos nombres que en <code>Statement</code>: <code>executeQuery()</code>, <code>executeUpdate()</code>, <code>execute()</code> pero no necesita enviar la cadena de caracteres con la orden SQL en la llamada ya que lo hace el m\u00e9todo <code>prepareStatement(String)</code>.</p> <p>Para asignar valor a cada uno de los marcadores de posici\u00f3n se utilizan los m\u00e9todos <code>setXXX(int index, Tipo valor)</code>.</p> M\u00e9todo Tipo SQL void setString(int index, String valor) VARCHAR void setBoolean(int index, boolean valor) BIT void setByte(int index, byte valor) TINYINT void setShort(int index, short valor) SMALLINT void setInt(int index, int valor) INTEGER void setLong(int index, long valor) BIGINT void setFloat(int index, float valor) FLOAT void setDouble(int index, double valor) DOUBLE void setBytes(int index, byte[] valor) VARBINARY void setDate(int index, Date valor) DATE void setTime(int index, Time valor) TIME <p>Para asignar valores NULL a un par\u00e1metro se usa el m\u00e9todo <code>setNull()</code> el formato es: <code>void setNull(int index, int tipoSQL)</code>, siento <code>tipoSQL</code> una constante definida en la librer\u00eda <code>java.sql.Types</code>, que son: ARRAY, BIGINT, BIT, BLOB, BOOLEAN, CHAR, CLOB, DATALINK, DATE, DECIMAL, DISTINCT, DOUBLE, FLOAT, INTEGER, JAVA_OBJECT, LONGVARCHAR, LONGVARBINARY, LONGVARCHAR, NCHAR, NCLOB, NULL, NUMERIC, NVARCHAR, OTHER, REAL, REF, REF_CURSOR, ROWID, SMALLINT, SQLXML, STRUCT, TIME, TIME_WITH_TIMEZONE, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, TINYINT, VARBINARY, VARCHAR</p> <pre><code>public class PlaceholderQueries {\n    public void show() throws ClassNotFoundException {\n        Class.forName(\"com.mysql.cj.jdbc.Driver\");\n        String sql = \"INSERT INTO departamentos VALUES (?,?,?)\";\n        try (\n                Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/empleados\",\n                        \"acdat\", \"acdat\");\n                PreparedStatement sentence = connection.prepareStatement(sql);\n            ) {\n\n            sentence.setInt(1, 60);\n            sentence.setString(2, \"DERECHO\");\n            sentence.setString(3, \"C/ Bilbao\");\n\n            int rows = sentence.executeUpdate();\n\n            System.out.println(\"Filas: \" + rows);\n\n        } catch (SQLException ex) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException {\n        new PlaceholderQueries().show();\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_15/page-5/#ejecucion-de-procedimientos","title":"Ejecuci\u00f3n de Procedimientos","text":"<p>Los procedimientos almacenados en la base de datos consisten en un conjunto de sentencias SQL y del lenguaje procedural utilizado por el sistema gestor de base de datos que se pueden llamar por su nombre para llevar a cabo alguna tarea en la base de datos. Pueden definirse con par\u00e1metros de entrada (IN), de salida (OUT), de entrada/salida (INOUT) o sin ning\u00fan par\u00e1metro. Tambi\u00e9n pueden devolver un valor, en este caso se tratar\u00eda de una funci\u00f3n.</p> <pre><code>delimiter //\nCREATE PROCEDURE subida_sal(d INT, subida INT)\nBEGIN\n UPDATE empleados SET salario = salario + subida WHERE dept_no = d;\n COMMIT;\nEND;\n//\n\ndelimiter //\nCREATE FUNCTION nombre_dep(d int) RETURNS VARCHAR(15)\nBEGIN\n DECLARE nom VARCHAR(15);\n SET nom = 'INEXISTENTE';\n SELECT dnombre INTO nom FROM departamentos\n WHERE dept_no=d;\n\n RETURN nom;\nEND;\n//\n\nDELIMITER //\nCREATE PROCEDURE datos_dep(d int, OUT nom VARCHAR(15), OUT locali VARCHAR(15))\nBEGIN\n SET locali = 'INEXISTENTE';\n SET nom = 'INEXISTENTE';\n SELECT nombre, loc INTO nom, locali FROM departamentos\n WHERE dept_no=d;\nEND;\n//\n</code></pre> <p>La interfaz <code>CallableStatement</code> permite que se pueda llamar desde Java a los procedimientos almacenados. Para crear un objeto se llama al m\u00e9todo <code>prepareCall(String)</code> del objeto <code>Connection</code>. En el String se declara la llamada al procedimiento o funci\u00f3n, tiene dos formatos, uno incluye el par\u00e1metro de resultado (usado para las funciones) y el otro no: <code>{? = call &lt;nombre_procedure&gt;[(&lt;arg1\\&gt;, &lt;arg2\\&gt;, ...)]}</code> o <code>{call &lt;nombre_procedure&gt;[(&lt;arg1\\&gt;, &lt;arg2\\&gt;, ...)]}</code></p> <p>Si los procedimientos y funciones incluyen par\u00e1metros de entrada y salida es necesario indicarlos en forma de marcadores de posici\u00f3n. El par\u00e1metro de resultado y los par\u00e1metros de salida deben ser registrados antes de realizar la llamada.</p> <pre><code>String sql = \"{call subida_sal (?, ?)}\";\nCallableStatement llamada = connection.prepareCall(sql);\n</code></pre> <p>Hay 4 formas de declarar las llamadas a los procedimientos y funciones que dependen del uso u omisi\u00f3n de par\u00e1metros, y de la devoluci\u00f3n de valores. Son las siguientes:</p> <ul> <li>{call procedimiento}: para un procedimiento almacenado sin par\u00e1metros.</li> <li>{ ? = call funci\u00f3n}: para una funci\u00f3n almacenada que devuelve un valor no recibe par\u00e1metros, el valor se recibe a la izquierda del igual y es el primer par\u00e1metro de resultado.</li> <li>{ call procedimientos(?, ?,...)}: para un procedimiento almacenado que recibe par\u00e1metros</li> <li>{? = call funci\u00f3n (?,?,...)}: para una funci\u00f3n almacenada que devuelve un valor (primer par\u00e1metro) y recibe varios par\u00e1metros.</li> </ul> <pre><code>public class ProcedureCall {\n    public void show() {\n        try{\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/empleados\",\n                    \"root\", \"\");\n\n            int dep = 10;\n            float subida = 100;\n\n            //construir orden de llamada\n            String sql = \"{call subida_sal(?,?)}\";\n\n            // Preparar la llamada\n            CallableStatement call = connection.prepareCall(sql);\n\n            // Dar valor a los argumentos\n            call.setInt(1, dep);\n            call.setFloat(2, subida);\n\n            // Ejecutar procedimiento\n            call.executeUpdate();\n            System.out.println(\"Subida realizada...\");\n\n            call.close();\n            connection.close();\n        } catch (ClassNotFoundException | SQLException cn){\n            System.out.println(\"Something went wrong\");\n            cn.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new ProcedureCall().show();\n    }\n}\n</code></pre> <p>En MySQL al ejecutarlo puede que se muestre el siguiente error: <code>java.sql.SQLException: User does not have access to metadata required to determinate stored procedure parameter types...</code>, si el usuario no tiene permisos para ejecutar procedimientos. En este caso debemos darle privilegio SELECT sobre la tabla de sistema mysql.proc que contiene la informaci\u00f3n sobre todos los procedimientos: <code>GRANT SELECT ON mysql.proc TO 'usuario'@'localhost'</code></p> <p>Cuando un procedimiento o funci\u00f3n tiene par\u00e1metros de salida (OUT) deben ser registrados antes de que la llamada tenga lugar, si no se registra se producir\u00e1 un error. El m\u00e9todo que se utilizar\u00e1 es registerOutParameter(int index, int tipoSQL), siendo el primer par\u00e1metro es la posici\u00f3n y el siguiente es una constante definida en la clase java.sql.Types.</p> <p>Una vez ejecutada la llamada al procedimiento, los valores de los par\u00e1metros OUT e INOUT se obtienen con los m\u00e9todos getXXX() similares a los utilizados para obtener los valores de las columnas en un ResultSet.</p> <pre><code>try{\n    Class.forName(driver);\n    Connection connection = DriverManager.getConnection(url);\n\n    int dep = 10;\n\n    String sql = \"{? = call nombre_dep (?, ?)}\";\n\n    CallableStatement call = connection.prepareCall(sql);\n\n    call.registerOutParameter(1, Types.VARCHAR); // registro de parametro OUT\n    call.setInt(2, dep);\n    call.registerOutParameter(3, Types.VARCHAR);\n\n    call.executeUpdate();\n    System.out.printf(\"Nombre Dep: %s, Localidad: %s\\n\", call.getString(1), call.getString(3));\n\n    call.close();\n    connection.close();\n} catch (ClassNotFoundException cn){\n    cn.printStackTrece();\n} catch (SQLException e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"bloque_iv/tema_15/page-6/","title":"Ejercicios","text":"<p>Queremos hacer una aplicaci\u00f3n para organizar los horarios de los ciclos formativos del IES Saladillo. En dicho instituto, la oferta educativa es la siguiente:</p> <ol> <li>Ciclo formativo de grado medio: Sistemas microinform\u00e1ticos y redes.</li> <li>Ciclo formativo de grado superior: Desarrollo de aplicaciones multiplataforma.</li> </ol> Grado medioGrado superior <p>En el ciclo de grado medio, las asignaturas est\u00e1n organizadas en dos cursos con la siguiente distribuci\u00f3n horaria semanal:</p> Asignaturas 1\u00ba Curso Horas Totales Horas semanales Montaje y mantenimiento de equipos 224 7 y 3 de desdoble Sistemas operativos monopuesto 160 5 Aplicaciones ofim\u00e1ticas 256 8 y 4 de desdoble Redes locales 224 7 y 3 de desdoble Formaci\u00f3n y orientaci\u00f3n laboral 96 3 TOTALES 960 30 Asignaturas 2\u00ba Curso Horas Totales Horas semanales Sistemas operativos en red 147 7 Seguridad inform\u00e1tica 105 5 Servicios en red 147 7 Aplicaciones web 84 4 Empresa e iniciativa emprendedora 84 4 Horas de libre configuraci\u00f3n 63 3 TOTALES 630 30 <p>En el ciclo de grado superior, las asignaturas est\u00e1n organizadas en dos cursos con la siguiente distribuci\u00f3n horario semanal:</p> Asignaturas 1\u00ba Curso Horas Totales Horas semanales Sistemas inform\u00e1ticos 192 6 y 3 de desdoble Bases de datos 192 6 y 3 de desdoble Programaci\u00f3n 256 8 y 6 de desdoble Entorno de desarrollo 96 3 Lenguaje de marcas y sistemas de gesti\u00f3n de informaci\u00f3n 96 3 Formaci\u00f3n y orientaci\u00f3n laboral 96 3 TOTALES 960 30 Asignaturas 2\u00ba Curso Horas Totales Horas semanales Acceso a datos 105 5 Desarrollo de interfaces 147 7 Programaci\u00f3n de servicios y procesos 63 3 Programaci\u00f3n multimedia y dispositivos m\u00f3viles 84 4 Empresa e iniciativa emprendedora 84 4 Horas de libre configuraci\u00f3n 63 3 TOTALES 630 30 <p>Los tramos horarios son de lunes a viernes los siguientes: 8:15-9:15, 9:15-10:15, 10:15-11:15, 11:45-12:45, 12:45-13:45 y 13:45-14:45. En cada tramo horario, una asignatura es impartida en un curso por un profesor o ambos en el caso de los desdobles.</p> <p>Existen asignaturas que se imparten en cursos diferentes, como por ejemplo, Horas de libre configuraci\u00f3n y Formaci\u00f3n y orientaci\u00f3n laboral. Dichas asignaturas se deben considerar la misma asignatura pero que se imparte en m\u00e1s de un curso.</p> <p>El curso se identificar\u00e1 con la oferta educativa. Adem\u00e1s, tiene asociado un profesor que es el tutor de dicho curso.</p> <p>De la oferta educativa, se necesita conocer una descripci\u00f3n de la misma y la fecha en que la ley correspondiente entr\u00f3 en vigor.</p> <p>De los profesores, interesa conocer su nombre y apellidos y la fecha de alta en el instituto.</p> <p>Para dicha aplicaci\u00f3n, necesitamos que la base de datos almacene los horarios de todos los cursos junto con los profesores que imparten cada asignatura en cada tramo horario.</p> Ejercicio 1 <p>Dado la informaci\u00f3n anterior:</p> <ol> <li>Realiza el esquema entidad/relaci\u00f3n.</li> <li>Realiza el paso a tablas seg\u00fan el modelo relacional.</li> <li>Comprobar que est\u00e1 normalizado hasta terce forma norma (3FN) utilizando las dependencias funcionales.</li> <li>Crear la base de datos en un gestor de base de datos. Para ello, dise\u00f1ar un script con:<ul> <li>Creaci\u00f3n de las tablas con las claves primarias y ajenas. En el caso de las claves ajenas, controlar el caso de actualizaci\u00f3n o borrado de la clave a la que hacen referencia.</li> <li>Introducci\u00f3n de datos reales con el horario de este curso.</li> </ul> </li> </ol> Ejercicio 2 <p>Realiza un programa que ejecute el script de la BD Horario, creada en el ejercicio anterior.</p> Ejercicio 3 <p>Mostrar informaci\u00f3n sobre las columnas de una tabla, sus claves primarias, las claves ajenas existentes en la tabla y las claves ajenas que utilizan la clave primaria de esta tabla.</p> Ejercicio 4 <p>Insertar la siguiente oferta educativa</p> <p>cod_OE: FPB nombre: FP b\u00e1sica inform\u00e1tica y comunicaciones descripci\u00f3n: La formaci\u00f3n profesional b\u00e1sica de inform\u00e1tica y comunicaciones tiene una duraci\u00f3n de 2000 horas repartidas entre dos cursos acad\u00e9micos incluyendo 240 horas de Formaci\u00f3n en centros de trabajo (FCT) en empresas del Sector</p> Ejercicio 5 <p>A\u00f1ade el primer curso de la FP B\u00e1sica con la tutora Lola Enr\u00edquez Lara y las siguientes asignaturas. Utiliza sentencias preparadas.</p> Asignaturas 1\u00ba Curso Horas semanales Horas Totales Profesor Operaciones auxiliares para la configuraci\u00f3n y la explotaci\u00f3n 7 245 Antonio D\u00edaz Sanamar\u00eda Montaje y mantenimiento de sistemas y componentes inform\u00e1ticos 9 315 Lola Enr\u00edquez Lara Ejercicio 6 <p>Aumenta las horas semanales y las horas totales en un 10% de aquellas asignaturas de la FP B\u00e1sica que empiecen por M.</p> Ejercicio 7 <p>La FP B\u00e1sica desaparece del IES Saladillo. Borra de la base de datos todo lo que sea de dicha oferta educativa.</p> Ejercicio 8 <p>Mostrar todos los datos de los profesores ordenados por:</p> <ul> <li>Apellidos en orden ascendente</li> <li>Fecha de alta en el instituto en orden descendente</li> </ul> Ejercicio 9 <p>Mostrar todos los datos de los profesores y de los cursos en los que son tutores. Si no son tutores, que aparezca \"Este profesor no es tutor\" en lugar de los datos del curso.</p> Ejercicio 10 <p>Del resultado de la consulta del ejercicio anterior, muestra el nombre de la columna, el tipo de dato de dicha columna, si puede contener valores nulos y el m\u00e1ximo de caracteres de la columna.</p> Ejercicio 11 <p>Mostrar de todos los cursos el nombre de la oferta educativa, la clave primaria del curso y el nombre del tutor.</p> Ejercicio 12 <p>Mostrar cu\u00e1ndo se imparte una asignatura en un curso concreto.</p> Ejercicio 13 <p>Mostrar qu\u00e9 asignaturas imparte un profesor.</p> Ejercicio 14 <p>Mostrar el horario de un curso en modo tabla. A\u00f1adir un asterisco en aquellos tramos horarios donde haya un desdoble.</p> Ejercicio 15 <p>Mostrar d\u00f3nde se encuentra un profesor en un tramo horario concreto.</p> Ejercicio 16 <p>Mostrar d\u00f3nde se encuentra un profesor ahora, es decir, en el momento actual.</p> Ejercicio 17 <p>Mostrar de cada asignatura el nombre, el n\u00famero de horas a la semana, el n\u00famero de cursos distintos donde se imparte, el n\u00famero de ofertas educativas distintas donde se imparte, de aquellas asignaturas que tengan 3 o m\u00e1s horas a la semana.</p> Ejercicio 18 <p>Realiza un funci\u00f3n en MySQL que dado un curso, devuelva el nombre del tutor. Haz un programa en Java que llame a dicha funci\u00f3n y muestre por consola el resultado.</p> Ejercicio 19 <p>Realiza un procedimiento en MySQL que dado un curso y una asignatura, devuelva el n\u00famero de horas semanales que tiene la asignatura y el nombre del profesor que la imparte. Haz un programa en Java que llame al procedimiento y muestre por consola los resultados.</p>"},{"location":"bloque_iv/tema_16/page-1/","title":"1 Introducci\u00f3n a las ORM","text":""},{"location":"bloque_iv/tema_16/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>En la mayor\u00eda de las aplicaciones actuales se requiere acceso al menos a una fuente de datos. Dichas fuentes son, por lo general, base de datos relacionales. En principio, esto no debe suponer ning\u00fan problema y podremos realizar operaciones y consultas sobre la base de datos SQL, pero en ciertas ocasiones podemos tener m\u00e1s de un fuente de datos a la vez o la fuente que tenemos pude sufrir ciertos cambios. Todo esto puede dar lugar a una refactorizaci\u00f3n de gran parte del c\u00f3digo.</p> <p>Supongamos que tenemos una fuente de datos que corresponde a una base de datos MySQL llamada students. La base de datos tiene la siguiente estructura:</p> <pre><code>+-------------+       +--------------+       +--------+\n| Estudiante  |-------| Inscripci\u00f3n  |-------| Curso  |\n+-------------+       +--------------+       +--------+\n| id          |       | id           |       | id     |\n| nombre      |       | idEstudiante |       | nombre |\n| edad        |       | idCurso      |       | cr\u00e9ditos|\n+-------------+       +--------------+       +--------+\n</code></pre> <p>De todo ello, obtenemos el siguiente script:</p> <pre><code>CREATE DATABASE IF NOT EXISTS `students` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\nUSE `students`;\n\nCREATE TABLE `course` (\n  `id` int(11) NOT NULL,\n  `name` varchar(30) NOT NULL,\n  `credits` int(11) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;\n\nINSERT INTO `course` (`id`, `name`, `credits`) VALUES\n(1, 'Matem\u00e1ticas', 3),\n(2, 'Historia', 4),\n(3, 'Programaci\u00f3n', 5),\n(4, 'Literatura', 3),\n(5, 'Qu\u00edmica', 4),\n(6, 'F\u00edsica', 5),\n(7, 'Ingl\u00e9s', 3),\n(8, 'Econom\u00eda', 4),\n(9, 'Biolog\u00eda', 5),\n(10, 'Arte', 3);\n\n\nCREATE TABLE `inscription` (\n  `id` int(11) NOT NULL,\n  `idStudent` int(11) NOT NULL,\n  `idCourse` int(11) NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;\n\nINSERT INTO `inscription` (`id`, `idStudent`, `idCourse`) VALUES\n(1, 1, 1),\n(2, 2, 3),\n(3, 3, 2),\n(4, 4, 4),\n(5, 5, 5),\n(6, 6, 6),\n(7, 7, 8),\n(8, 8, 7),\n(9, 9, 9),\n(10, 10, 10);\n\n\nCREATE TABLE `student` (\n  `id` int(11) NOT NULL,\n  `name` varchar(30) NOT NULL,\n  `age` int(11) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;\n\n\nINSERT INTO `student` (`id`, `name`, `age`) VALUES\n(1, 'Juan P\u00e9rez', 20),\n(2, 'Mar\u00eda L\u00f3pez', 22),\n(3, 'Carlos Rodr\u00edguez', 21),\n(4, 'Laura Garc\u00eda', 23),\n(5, 'Pedro S\u00e1nchez', 22),\n(6, 'Ana Mart\u00ednez', 24),\n(7, 'Miguel Gonz\u00e1lez', 20),\n(8, 'Elena Ram\u00edrez', 21),\n(9, 'Javier Fern\u00e1ndez', 23),\n(10, 'Sof\u00eda D\u00edaz', 22);\n\nALTER TABLE `course`\n  ADD PRIMARY KEY (`id`);\n\nALTER TABLE `inscription`\n  ADD PRIMARY KEY (`id`),\n  ADD KEY `fk_insc_stu` (`idStudent`),\n  ADD KEY `fk_insc_cour` (`idCourse`);\n\nALTER TABLE `student`\n  ADD PRIMARY KEY (`id`);\n\nALTER TABLE `course`\n  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=11;\n\nALTER TABLE `inscription`\n  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=11;\n\nALTER TABLE `student`\n  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=11;\n\nALTER TABLE `inscription`\n  ADD CONSTRAINT `fk_insc_cour` FOREIGN KEY (`idCourse`) REFERENCES `course` (`id`),\n  ADD CONSTRAINT `fk_insc_stu` FOREIGN KEY (`idStudent`) REFERENCES `student` (`id`);\nCOMMIT;\n</code></pre>"},{"location":"bloque_iv/tema_16/page-1/#proyecto-jpaexample","title":"Proyecto JPAExample","text":"<p>Supongamos que vamos a crear una aplicaci\u00f3n para poder registrar las compras que se hacen en una librer\u00eda. Teniendo en cuenta las siguientes clases POJOs:</p> DiagramaStudentCourseInscription <pre><code>classDiagram\n    class Student{\n        -Integer id\n        -String name\n        -int age\n        +Student copy(String name)\n    }\n    class Course{\n        -Integer id\n        -String name\n        -int credits\n        +Course copy(String name)\n    }\n    class Inscription{\n        -Integer id\n        -Student student\n        -Course course\n    }\n\n    Inscription \"1..\" *-- \"1\" Student\n    Inscription \"1\" *-- \"1\" Course</code></pre> <pre><code>public class Student implements Comparable&lt;Student&gt;{\n\n    private Integer id;\n    private String name;\n    private int age;\n\n    public Student(Integer id, String name, int age){\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public Student(String name, int age){\n        this(null, name, age);\n    }\n\n    public static Student of(ResultSet result) throws SQLException {\n        return new Student(result.getInt(\"id\"), result.getString(\"name\"), result.getInt(\"age\"));\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Student student = (Student) o;\n        return age == student.age &amp;&amp; student.id.equals(id) &amp;&amp; name.equalsIgnoreCase(student.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode() + name.hashCode() + Integer.hashCode(age);\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n\n    @Override\n    public int compareTo(Student o) {\n        return id.compareTo(o.id);\n    }\n\n    public Student copy(String newName) {\n        return new Student(id, newName, age);\n    }\n}   \n</code></pre> <pre><code>public class Course implements Comparable&lt;Course&gt;{\n    private Integer id;\n    private String name;\n    private int credits;\n\n    public Course(Integer id, String name, int credits) {\n        this.id = id;\n        this.name = name;\n        this.credits = credits;\n    }\n\n    public Course(String name, int credits) {\n        this(null, name, credits);\n    }\n\n    public static Course of(ResultSet result) throws SQLException {\n        return new Course(result.getInt(\"id\"), result.getString(\"name\"), result.getInt(\"credits\"));\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getCredits() {\n        return credits;\n    }\n\n    public void setCredits(int credits) {\n        this.credits = credits;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Course course = (Course) o;\n        return credits == course.credits &amp;&amp; id.equals(course.id) &amp;&amp; name.equalsIgnoreCase(course.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode() + name.hashCode() + Integer.hashCode(credits);\n    }\n\n    @Override\n    public String toString() {\n        return \"Course{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", credits=\" + credits +\n                '}';\n    }\n\n    @Override\n    public int compareTo(Course o) {\n        return id.compareTo(o.id);\n    }\n\n    public Course copy(String newName) {\n        return new Course(id, newName, credits);\n    }\n}\n</code></pre> <pre><code>public class Inscription implements Comparable&lt;Inscription&gt;{\n    private Integer id;\n    private Student student;\n    private Course course;\n\n    public Inscription(Integer id, Student student, Course course) {\n        this.id = id;\n        this.student = student;\n        this.course = course;\n    }\n\n    public Inscription(Student student, Course course) {\n        this(null, student, course);\n    }\n\n    public static Inscription of(ResultSet result) throws SQLException {\n        return new Inscription(result.getInt(\"id\"), Student.of(result), Course.of(result));\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public Student getStudent() {\n        return student;\n    }\n\n    public void setStudent(Student student) {\n        this.student = student;\n    }\n\n    public Course getCourse() {\n        return course;\n    }\n\n    public void setCourse(Course course) {\n        this.course = course;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Inscription that = (Inscription) o;\n        return id.equals(that.id) &amp;&amp; student.equals(that.student) &amp;&amp; course.equals(that.course);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode() + student.hashCode() + course.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return \"Inscription{\" +\n                \"id=\" + id +\n                \", student=\" + student +\n                \", course=\" + course +\n                '}';\n    }\n\n    @Override\n    public int compareTo(Inscription o) {\n        return 0;\n    }\n}\n</code></pre> <p>Adem\u00e1s el proyecto contiene un interfaz que servir\u00e1 para cada uno de los modelos de nuestras clases POJOs, en la cual se encuentras los m\u00e9todos necesarios para trabajar con las consultas comunes de cada una de nuestras clases:</p> <pre><code>public interface Source&lt;T&gt; {\n    T getById(Integer id);\n    List&lt;T&gt; getAll();\n    boolean save(T t);\n    boolean update(T t);\n    boolean delete(T t);\n}\n</code></pre> <p>Es una interfaz gen\u00e9rica, donde T es el tipo de clase POJO con la que estamos trabajando.</p> <p>Haciendo uso del patr\u00f3n de dise\u00f1o Singleton, crearemos una clase que trabaje con la conexi\u00f3n a nuestra base de datos:</p> <pre><code>public class Database {\n    private static Database database;\n\n    private Connection connection;\n\n    private Database(){\n        try{\n            Class.forName(DRIVER);\n            connection = DriverManager.getConnection(URL, USER, PASSWORD);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        } catch (SQLException e) {\n            System.out.println(RED + \"Connection to MySQL DB failed: \" + e.getMessage() + RESET);\n        }\n    }\n\n    public PreparedStatement query(String sql) throws SQLException {\n        return connection.prepareStatement(sql);\n    }\n\n    public Statement query() throws SQLException {\n        return connection.createStatement();\n    }\n\n    public static Database instance(){\n        if(database == null){\n            database = new Database();\n        }\n\n        return database;\n    }\n}\n</code></pre> <p>Una vez creada la clase para trabajar con la conexi\u00f3n creamos los modelos que implementen la interfaz que hemos creado anteriormente:</p> StudentModelCourseModelInscriptionModel <pre><code>public class StudentModel implements Source&lt;Student&gt; {\n\n    private final Database db;\n\n    public StudentModel(Database db) {\n        this.db = db;\n    }\n\n    @Override\n    public Student getById(Integer id) {\n        try(PreparedStatement statement = db.query(\"select * from student where id = ?\")) {\n            statement.setInt(1, id);\n            ResultSet result = statement.executeQuery();\n\n            if(!result.next())  return null;\n\n            return Student.of(result);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return null;\n        }\n    }\n\n    @Override\n    public List&lt;Student&gt; getAll() {\n        final List&lt;Student&gt; students = new ArrayList&lt;&gt;();\n\n        try(Statement statement = db.query()) {\n            ResultSet result = statement.executeQuery(\"select * from student\");\n\n            while (result.next()){\n                students.add(Student.of(result));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n\n        return students;\n    }\n\n    @Override\n    public boolean save(Student student) {\n        try(PreparedStatement statement = db.query(\"insert into student (name, age) values (?, ?)\")) {\n            statement.setString(1, student.getName());\n            statement.setInt(2, student.getAge());\n\n            return statement.executeUpdate() &gt; 0;\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n    }\n\n    @Override\n    public boolean update(Student student) {\n        try(PreparedStatement statement = db.query(\"update student set name = ?, age = ? where id = ?\")) {\n            statement.setString(1, student.getName());\n            statement.setInt(2, student.getAge());\n            statement.setInt(3, student.getId());\n\n            return statement.executeUpdate() &gt; 0;\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n    }\n\n    @Override\n    public boolean delete(Student student) {\n        try(PreparedStatement statement = db.query(\"delete from student where id = ?\")) {\n            statement.setInt(1, student.getId());\n\n            return statement.executeUpdate() &gt; 0;\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n    }\n}\n</code></pre> <pre><code>public class CourseModel implements Source&lt;Course&gt; {\n    private final Database db;\n\n    public CourseModel(Database db) {\n        this.db = db;\n    }\n\n    @Override\n    public Course getById(Integer id) {\n        try(PreparedStatement statement = db.query(\"select * from course where id = ?\")) {\n            statement.setInt(1, id);\n            ResultSet result = statement.executeQuery();\n\n            if(!result.next())  return null;\n\n            return Course.of(result);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return null;\n        }\n    }\n\n    @Override\n    public List&lt;Course&gt; getAll() {\n        final List&lt;Course&gt; courses = new ArrayList&lt;&gt;();\n\n        try(Statement statement = db.query()) {\n            ResultSet result = statement.executeQuery(\"select * from course\");\n\n            while (result.next()){\n                courses.add(Course.of(result));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n\n        return courses;\n    }\n\n    @Override\n    public boolean save(Course course) {\n        try(PreparedStatement statement = db.query(\"insert into course (name, credits) values (?, ?)\")) {\n            statement.setString(1, course.getName());\n            statement.setInt(2, course.getCredits());\n\n            return statement.executeUpdate() &gt; 0;\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n    }\n\n    @Override\n    public boolean update(Course course) {\n        try(PreparedStatement statement = db.query(\"update course set name = ?, age = ? where id = ?\")) {\n            statement.setString(1, course.getName());\n            statement.setInt(2, course.getCredits());\n            statement.setInt(3, course.getId());\n\n            return statement.executeUpdate() &gt; 0;\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n    }\n\n    @Override\n    public boolean delete(Course course) {\n        try(PreparedStatement statement = db.query(\"delete from course where id = ?\")) {\n            statement.setInt(1, course.getId());\n\n            return statement.executeUpdate() &gt; 0;\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n    }\n}\n</code></pre> <pre><code>public class InscriptionModel implements Source&lt;Inscription&gt; {\n    private final Database db;\n\n    public InscriptionModel(Database db) {\n        this.db = db;\n    }\n\n    @Override\n    public Inscription getById(Integer id) {\n        try(PreparedStatement statement = db.query(\"select i.id, s.*, c.* from inscription i JOIN student s on i.idStudent = s.id join course c on i.idCourse = c.id where i.id = ?\")) {\n            statement.setInt(1, id);\n            ResultSet result = statement.executeQuery();\n\n            if(!result.next())  return null;\n\n            return Inscription.of(result);\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return null;\n        }\n    }\n\n    @Override\n    public List&lt;Inscription&gt; getAll() {\n        final List&lt;Inscription&gt; inscriptions = new ArrayList&lt;&gt;();\n\n        try(Statement statement = db.query()) {\n            ResultSet result = statement.executeQuery(\"select i.id, s.*, c.* from inscription i JOIN student s on i.idStudent = s.id join course c on i.idCourse = c.id\");\n\n            while (result.next()){\n                inscriptions.add(Inscription.of(result));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n        }\n\n        return inscriptions;\n    }\n\n    @Override\n    public boolean save(Inscription inscription) {\n        try(PreparedStatement statement = db.query(\"insert into inscription (idStudent, idCourse) values (?, ?)\")) {\n            statement.setInt(1, inscription.getStudent().getId());\n            statement.setInt(2, inscription.getCourse().getId());\n\n            return statement.executeUpdate() &gt; 0;\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n    }\n\n    @Override\n    public boolean update(Inscription inscription) {\n        return false;\n    }\n\n    @Override\n    public boolean delete(Inscription inscription) {\n        try(PreparedStatement statement = db.query(\"delete from inscription where id = ?\")) {\n            statement.setInt(1, inscription.getId());\n\n            return statement.executeUpdate() &gt; 0;\n        } catch (SQLException e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n    }\n}\n</code></pre> <p>Info</p> <p>Puedes encontrar este proyecto en: https://github.com/irubenboy/jpaexample</p>"},{"location":"bloque_iv/tema_16/page-1/#problemas-de-carencia-de-orm","title":"Problemas de carencia de ORM","text":"<p>Al usar esta estructura de proyecto, podemos evitar el error de cambio de fuente de forma sencilla, pero a\u00fan as\u00ed tenemos muchos otros problemas, como por ejemplo, si queremos a\u00f1adir m\u00e1s queries, o si quisi\u00e9ramos cambiar la estructura de una clase POJO habr\u00eda que cambiar tambi\u00e9n su modelo.</p>"},{"location":"bloque_iv/tema_16/page-2/","title":"2 Persistencia","text":""},{"location":"bloque_iv/tema_16/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>La persistencia se refiere a la capacidad de almacenar y recuperar datos de forma duradera a trav\u00e9s de diversas fuentes, como bases de datos, archivos, o incluso memoria, es decir, se trata de mantener la informaci\u00f3n m\u00e1s all\u00e1 de la ejecuci\u00f3n del programa para que pueda ser utilizada en sesiones posteriores o compartida entre diferentes aplicaciones.</p> <p>La persistencia es una de las soluciones posibles al problema planteado en el proyecto anterior.</p>"},{"location":"bloque_iv/tema_16/page-2/#patron-de-diseno-dao","title":"Patr\u00f3n de dise\u00f1o DAO","text":"<p>El patr\u00f3n de dise\u00f1o DAO (Data Access Object) es un patr\u00f3n de dise\u00f1o que se utiliza en programaci\u00f3n para separar la l\u00f3gica de acceso a datos de la l\u00f3gica de negocio. Su objetivo principal es proporcionar una capa de abstracci\u00f3n entre la aplicaci\u00f3n y la fuente de datos, lo que facilita la gesti\u00f3n de la base de datos y permite cambios en la base de datos sin afectar la l\u00f3gica de la aplicaci\u00f3n.</p> <p>Este patr\u00f3n tiene los siguientes componentes:</p> <ul> <li> <p>Interfaz DAO: Define los m\u00e9todos que representan operaciones de acceso a datos, como insertar, actualizar, eliminar y recuperar datos. Esta interfaz sirve como contrato para las clases concretas que implementar\u00e1n la l\u00f3gica de acceso a datos.</p> <pre><code>public interface StudentDAO {\n    Student getById(int id);\n    List&lt;Student&gt; getAll();\n    void insert(Student student);\n    void update(Student student);\n    void delete(int id);\n}\n</code></pre> </li> <li> <p>Clase DAO: Implementa la interfaz DAO y proporciona la l\u00f3gica real para interactuar con la fuente de datos, como una base de datos. Esta clase realiza operaciones de lectura y escritura en la fuente de datos, como consultas SQL en una base de datos relacional.</p> <pre><code>public class StudentDAOImpl implements StudentDAO {\n// Implementaci\u00f3n de los m\u00e9todos definidos en la interfaz\n// Aqu\u00ed se realizar\u00edan las operaciones de acceso a la base de datos.\n}\n</code></pre> </li> <li> <p>Modelo de datos (POJO): Representa los objetos de datos que se almacenan o recuperan de la fuente de datos. Los objetos de este tipo son simples y contienen propiedades que mapean a las columnas de la base de datos.</p> <pre><code>public class Student {\n    private int id;\n    private String name;\n    private int age;\n    // Getters y setters\n}\n</code></pre> </li> </ul> <p>De esta forma podemos realizar las operaciones de una base de datos de forma m\u00e1s sencilla:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Crear una instancia del DAO\n        StudentDAO studentDAO = new StudentDAOImpl();\n\n        // Insertar un estudiante en la base de datos\n        Student student = new Student();\n        student.setName(\"John Doe\");\n        student.setAge(20);\n        studentDAO.insert(student);\n\n        // Recuperar un estudiante por ID\n        Student retrievedStudent = studentDAO.getById(1);\n        System.out.println(\"Nombre del estudiante: \" + retrievedStudent.getName());\n\n        // Actualizar un estudiante\n        retrievedStudent.setName(\"Jane Smith\");\n        studentDAO.update(retrievedStudent);\n\n        // Eliminar un estudiante\n        studentDAO.delete(1);\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_16/page-2/#implementacion-del-patron-de-diseno-dao-al-proyecto-students","title":"Implementaci\u00f3n del patr\u00f3n de dise\u00f1o DAO al proyecto students","text":"<p>El primer cambio que sufre nuestro proyecto es la eliminaci\u00f3n de la interfaz <code>Source&lt;T&gt;</code> por un interfaz especifica para cada tipo de dato:</p> StudentDAOCourseDAOInscriptionDAO <pre><code>public interface StudentDAO {\n    Student getById(Integer id);\n    List&lt;Student&gt; getAll();\n    boolean save(Student student);\n    boolean update(Student student);\n    boolean delete(Student student);\n}\n</code></pre> <pre><code>public interface CourseDAO {\n    Course getById(Integer id);\n    List&lt;Course&gt; getAll();\n    boolean save(Course course);\n    boolean update(Course course);\n    boolean delete(Course course);\n}\n</code></pre> <pre><code>public interface InscriptionDAO {\n    Inscription getById(Integer id);\n    List&lt;Inscription&gt; getAll();\n    boolean save(Inscription inscription);\n    boolean delete(Inscription inscription);\n}\n</code></pre> <p>De esta forma tendremos una interfaz para cada modelo de datos, y as\u00ed cada implementaci\u00f3n realizar\u00e1 la misma operaciones, sin importar el tipo de fuente de datos que usemos.</p> <p>Otro de los cambios a seguir, l\u00f3gicamente, son nuestras clases l\u00f3gicas, anteriormente llamadas Model, las cuales implementaban la interfaz <code>Source</code> y ahora implementar\u00e1n las interfaces DAO que tenemos:</p> StudentDAOImplCourseDAOImplOderDAOImpl <pre><code>public class StudentDAOImpl implements StudentDAO {\n\n    //...\n\n    @Override\n    public Student getById(Integer id) {\n        // ...\n    }\n\n    @Override\n    public List&lt;Student&gt; getAll() {\n        // ...\n    }\n\n    @Override\n    public boolean save(Student student) {\n        //...\n    }\n\n    @Override\n    public boolean update(Student student) {\n       // ...\n    }\n\n    @Override\n    public boolean delete(Student student) {\n        //...\n    }\n}\n</code></pre> <pre><code>public class CourseDAOImpl implements CourseDAO {\n    //...\n\n    @Override\n    public Course getById(Integer id) {\n       // ...\n    }\n\n    @Override\n    public List&lt;Course&gt; getAll() {\n        // ...\n    }\n\n    @Override\n    public boolean save(Course Course) {\n        // ...\n    }\n\n    @Override\n    public boolean update(Course Course) {\n        // ...\n    }\n\n    @Override\n    public boolean delete(Course Course) {\n        // ...\n    }\n}\n</code></pre> <pre><code>public class InscriptionDAOImpl implements InscriptionDAO {\n    //...\n    @Override\n    public Inscription getById(Integer id) {\n        // ...\n    }\n\n    @Override\n    public List&lt;Inscription&gt; getAll() {\n        // ...\n    }\n\n    @Override\n    public boolean save(Inscription inscription) {\n        // ...\n    }\n\n\n    @Override\n    public boolean delete(Inscription inscription) {\n        // ...\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_16/page-2/#patron-de-diseno-repository","title":"Patr\u00f3n de dise\u00f1o repository","text":"<p>El patr\u00f3n de dise\u00f1o Repository es un patr\u00f3n de dise\u00f1o de software que se utiliza para abstraer y centralizar la l\u00f3gica de acceso a datos en una aplicaci\u00f3n. Proporciona una interfaz com\u00fan para acceder a datos, independientemente de la fuente de datos subyacente, como una base de datos, un servicio web o incluso una memoria cach\u00e9. El patr\u00f3n Repository tambi\u00e9n se utiliza para separar la l\u00f3gica de acceso a datos de la l\u00f3gica de negocio de una aplicaci\u00f3n.</p> <p>Los componentes de este patr\u00f3n son:</p> <ul> <li> <p>Interfaz Repository: Define m\u00e9todos para acceder a los datos, como guardar, recuperar, actualizar y eliminar objetos. Esta interfaz act\u00faa como un contrato que las clases concretas deben implementar.</p> <pre><code>public interface BookRepository {\n    Book getById(int id);\n    List&lt;Book&gt; getAll();\n    void save(Book book);\n    void update(Book book);\n    void delete(int id);\n}\n</code></pre> </li> <li> <p>Clase Repository concreta: Implementa la interfaz Repository y proporciona la l\u00f3gica de acceso a datos real. Puede interactuar con una base de datos, un servicio web, un sistema de archivos u otra fuente de datos.</p> <pre><code>public class JdbcBookRepository implements BookRepository {\n// Implementaci\u00f3n de los m\u00e9todos definidos en la interfaz\n// Aqu\u00ed se realizar\u00edan las operaciones de acceso a la base de datos.    \n}\n</code></pre> </li> <li> <p>Modelo de datos (POJO): Representa los objetos de datos que se almacenan o recuperan. Los objetos de este tipo son simples y contienen propiedades que mapean a los datos almacenados.</p> <pre><code>public class Book {\n    private int id;\n    private String title;\n    private String author;\n\n    // Getters y setters\n}\n</code></pre> </li> </ul>"},{"location":"bloque_iv/tema_16/page-2/#dao-vs-repository","title":"DAO vs Repository","text":"<p>Aparentemente ambos patrones de dise\u00f1o son bastantes parecido, pero a\u00fan as\u00ed hay algunas diferencias entre ellos:</p> <ol> <li> <p>Abstracci\u00f3n de la fuente de datos: En el patr\u00f3n Repository, se busca proporcionar una capa de abstracci\u00f3n que abarque m\u00faltiples fuentes de datos, como bases de datos, servicios web, sistemas de archivos, etc. El patr\u00f3n DAO generalmente se asocia m\u00e1s estrechamente con la interacci\u00f3n con bases de datos, aunque tambi\u00e9n puede utilizarse para otros tipos de fuentes de datos.</p> </li> <li> <p>Mapeo objeto-relacional: El patr\u00f3n Repository a menudo incluye un mapeo objeto-relacional (ORM) para facilitar la conversi\u00f3n entre los objetos de la aplicaci\u00f3n y los datos almacenados. En contraste, el patr\u00f3n DAO tiende a tener una relaci\u00f3n m\u00e1s directa con las consultas SQL o la interacci\u00f3n con la base de datos.</p> </li> <li> <p>Centralizaci\u00f3n de la l\u00f3gica de acceso a datos: El patr\u00f3n Repository se centra en centralizar la l\u00f3gica de acceso a datos, mientras que el patr\u00f3n DAO puede ser m\u00e1s flexible en t\u00e9rminos de c\u00f3mo se organiza la l\u00f3gica de acceso a datos.</p> </li> </ol> <p>En resumen, el patr\u00f3n Repository se centra en proporcionar una capa de abstracci\u00f3n m\u00e1s amplia para acceder a datos desde diversas fuentes, mientras que el patr\u00f3n DAO se enfoca m\u00e1s espec\u00edficamente en la l\u00f3gica de acceso a datos en el contexto de una base de datos. La elecci\u00f3n entre estos patrones depender\u00e1 de las necesidades y la arquitectura de tu aplicaci\u00f3n.</p>"},{"location":"bloque_iv/tema_16/page-3/","title":"3 Java Persistence API (JPA)","text":""},{"location":"bloque_iv/tema_16/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>En nuestro entorno existen muchas aplicaciones que realizan operaciones con la base de almacenar y recuperar grandes cantidades de datos.</p> <p>Tal y como hemos visto hasta ahora para poder realizar dichas operaciones hemos tenido que utilizar una gran cantidad de c\u00f3digo, a pesar de haber mejorado la t\u00e9cnica haciendo uso de patrones.</p> <p>Java Persistence API es un conjunto de clases y m\u00e9todos que persistentemente almacena una gran cantidad de datos a una base de datos proporcionada.</p> <p>Para poder reducir la carga en la gesti\u00f3n de los objetos en los modelos relaciones, se sigue el marco Proveedor JPA que nos permite de forma f\u00e1cil una interacci\u00f3n con la instancia de la base de datos.</p> <p> Figura 2 - JPA Provider</p>"},{"location":"bloque_iv/tema_16/page-3/#arquitectura","title":"Arquitectura","text":"<p>JPA es una fuente para almacenar entidades relaciones y muestra c\u00f3mo definir una clase POJO como una entidad y la forma de gestionar las relaciones con las entidades.</p> <p> Figura 3 - Arquitectura JPA</p> Unidad Descripci\u00f3n EntityManagerFactory Esta es una clase de f\u00e1brica de EntityManager. Crea y gestiona m\u00faltiples instancias EntityManager. EntityManager Es una interfaz, que gestiona la persistencia de objetos. Funciona como instancia de consulta. Entidad Las entidades son los objetos de persistencia, tiendas como registros en la base de datos. EntityTransaction Tiene una relaci\u00f3n de uno a uno con EntityManager. Para cada m\u00e9todo EntityManager, se mantienen las operaciones de la clase EntityTransaction. Persistence Esta clase contiene m\u00e9todos est\u00e1ticos para obtener EntityManagerFactory. Query Esta interfaz es implementada por cada proveedor JPA relacional para obtener objetos que cumplan los criterios. <p>En la arquitectura, las relaciones entre las clases e interfaces pertenecen a la clase <code>javax.persistence</code> paquete. El siguiente diagrama muestra la relaci\u00f3n entre ellos.</p> <p>JPA package</p> <p>https://mvnrepository.com/artifact/javax.persistence/javax.persistence-api</p> <p> Figura 4 - JPA Relaci\u00f3n de clases</p> <ul> <li>La relaci\u00f3n entre EntityManagerFactory y EntityManager es de uno a varios. Se trata de una clase de f\u00e1brica a instancias EntityManager.</li> <li>La relaci\u00f3n entre EntityManager y EntityTransaction es uno a uno. EntityManager para cada operaci\u00f3n, hay un EntityTransaction.</li> <li>La relaci\u00f3n entre EntityManager y Query es de uno a varios. Un n\u00famero de consultas puede ser ejecutado mediante una instancia EntityManager.</li> <li>La relaci\u00f3n entre Entidad y EntityManager es uno de muchos. Un EntityManager puede administrar varias entidades.</li> </ul>"},{"location":"bloque_iv/tema_16/page-3/#object-relational-mapping-orm","title":"Object Relational Mapping (ORM)","text":"<p>Object Relational Mapping es una capacidad de programaci\u00f3n para convertir un objeto relacional devuelto de una consulta a un objeto entidad. Su principal caracter\u00edstica es enlazar un objeto a sus respectivos similares en la base de datos, as\u00ed como sus relaciones con las entidades en cualquier otra tabla.</p> <p>El uso de ORM tiene una serie de ventajas:</p> <ul> <li>Persistencias idiom\u00e1ticas: le permite escribir persistencia utilizando las clases orientadas a objetos.</li> <li>Alto rendimiento: tiene un alto rendimiento a la ahora de realizar t\u00e9cnicas de bloqueo.</li> <li>Fiable: es muy estable y usado.</li> </ul> <p>La arquitectura ORM es similar a la siguiente</p> <p> Figura 5 - Arquitectura ORM</p>"},{"location":"bloque_iv/tema_16/page-3/#fase-1","title":"Fase 1","text":"<p>La primera fase, denominada fases de datos del objeto, contiene las clases POJO, interfaces y el resto de clases. Es el principal componente de la capa empresarial que contiene operaciones y atributos de l\u00f3gica de negocios. Por ejemplo, podemos tener la clase POJO, Employee con la informaci\u00f3n referente a almacenar de los empleados, as\u00ed como su interfaz DAO que contendr\u00e1 los m\u00e9todos necesarios para trabajar con la base de datos.</p> <p>Es importante que las clases POJOs sigan el principio Bean para poder trabajar con ellas a trav\u00e9s del proveedor.</p> EmployeeEmployeeDAO <pre><code>public class Employee{\n    private int id;\n    private String name;\n    private double salary;\n    private String deg;\n\n    public Employee(int id, String name, double salary, String deg){\n        this.id = id;\n        this.name = name;\n        this.salary = salary;\n        this.deg = deg;\n    }\n\n    // Getters and setters\n}\n</code></pre> <pre><code>public interface EmployeeDAO{\n    Employee get(int id);\n    List&lt;Employee&gt; getAll();\n    boolean insert(Employee employee);\n    boolean update(int id, Employee employee);\n    boolean delete(int id);\n}\n</code></pre>"},{"location":"bloque_iv/tema_16/page-3/#fase-2","title":"Fase 2","text":"<p>La fase 2, o fase de mapeo o persistencia, contiene el proveedor JPA, as\u00ed como el archivo de configuraci\u00f3n, el JPA loader, y el object Grid.</p> <ul> <li>JPA Provider: es el proveedor que contiene el JPA.</li> <li>Archivo de asignaci\u00f3n: es el archivo que contiene la configuraci\u00f3n de la asignaci\u00f3n entre los datos de la clase POJO y los datos de una base de datos relacional.</li> <li>JPA Loader: Carga los datos de la base de datos en una especie de memoria cach\u00e9, para as\u00ed interactuar con las clases servicios de datos.</li> <li>Object Grid: es una ubicaci\u00f3n temporal que puede almacenar una copia de los datos relacionales, como una memoria cach\u00e9. Todas las consultas en la base de datos se efectuar\u00e1n, primero en los datos del objeto grid. S\u00f3lo despu\u00e9s de que se ha comprometido, afectar\u00e1 a la base de datos principal.</li> </ul>"},{"location":"bloque_iv/tema_16/page-3/#fase-3","title":"Fase 3","text":"<p>La tercera fase es la fase de datos relacionales, que contiene los datos relacionales que est\u00e1n conectados al componente empresarial. Como se ha indicado anteriormente, s\u00f3lo cuando el componente empresarial se compromete con los datos, que se almacenan en la base de datos b\u00e1sicamente. Hasta entonces, los datos modificados se almacenan en una memoria cach\u00e9 como un formato de cuadr\u00edcula. El proceso de obtenci\u00f3n de los datos es id\u00e9ntico a la de almacenar los datos.</p> <p>El mecanismo de la interacci\u00f3n mediante programaci\u00f3n por encima de tres fases se denomina asignaci\u00f3n objeto-relacional .</p>"},{"location":"bloque_iv/tema_16/page-3/#mapeoxml","title":"Mapeo.xml","text":"<p>La asignaci\u00f3n del archivo.xml consiste en indicar al JPA Provider la relaci\u00f3n entre las clases de entidad con las tablas de la base de datos relacional.</p> <p>Para la clase Employee y la tabla empleado tenemos la siguiente asignaci\u00f3n:</p> <pre><code>&lt;? xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n\n&lt;entity-mappings xmlns=\"http://java.sun.com/xml/ns/persistence/orm\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence/orm    \n   http://java.sun.com/xml/ns/persistence/orm_1_0.xsd\"\n   version=\"1.0\"&gt;\n\n   &lt;description&gt; XML Mapping file&lt;/description&gt;\n\n   &lt;entity class=\"Employee\"&gt;        \n      &lt;table name=\"empleado\"/&gt;\n\n      &lt;attributes&gt;\n         &lt;id name=\"id\"&gt;\n            &lt;generated-value strategy=\"TABLE\"/&gt;\n         &lt;/id&gt;\n\n         &lt;basic name=\"name\"&gt;\n            &lt;column name=\"nombre\" length=\"100\"/&gt;\n         &lt;/basic&gt;\n\n         &lt;basic name=\"salary\"&gt;\n         &lt;/basic&gt;\n\n         &lt;basic name=\"deg\"&gt;\n         &lt;/basic&gt;\n      &lt;/attributes&gt;\n\n   &lt;/entity&gt;\n&lt;/entity-mappings&gt;\n</code></pre> <p>Del archivo anterior podemos destacar:</p> <ul> <li><code>&lt;entity-mappings&gt;</code>: esta etiqueta define el esquema ORM que permitir\u00e1 reconocer a las etiquetas siguientes.</li> <li><code>&lt;description&gt;</code>: ofrece una descripci\u00f3n acerca de la aplicaci\u00f3n.</li> <li><code>&lt;entity&gt;</code>: define la clase entidad que se desea relacionar con la tabla de la base de datos. El atributo <code>class</code> define el nombre del la clase POJO. Tambi\u00e9n se puede definir el atributo <code>access</code> que indica el modo de acceso. El valor <code>FIELD</code> accede directamente a la propiedad mientras que el valor <code>PROPERTY</code> hace uso de los m\u00e9todos getters and setters.</li> <li><code>&lt;table&gt;</code>: define el nombre de la tabla indic\u00e1ndola con el atributo <code>name</code>. En caso de que el nombre de la clase POJO y el nombre de la tabla sean el mismo, no ser\u00eda necesario indicar esta etiqueta.</li> <li><code>&lt;attributes&gt;</code>: define los atributos/campos de una clase/tabla.</li> <li><code>&lt;id&gt;</code>: define la clave principal de la tabla. Con el atributo <code>name</code> se indica el nombre del atributo de la clase con la que se relaciona.</li> <li> <p><code>&lt;generated-value&gt;</code>: define c\u00f3mo se le asignar\u00e1 el valor a la clave principal. Siempre va en el interior de la etiqueta <code>id</code>. Sus posibles valores son</p> <ul> <li>IDENTITY: El valor se genera autom\u00e1ticamente por la base de datos. Este estrategia se usa para bases de datos que permitan la autoincrementaci\u00f3n como MySQL.</li> <li>SEQUENCE: El valor se genera secuencialmente.Esta estrategia se usa en base de datos donde permita la asignaci\u00f3n de valores secuenciales como en Oracle.</li> <li>TABLE: JPA crea una tabla adicional en la base de datos para generar valores de clave primaria. Es menos eficiente que IDENTITY o SEQUENCE.</li> <li>AUTO: Permite que el proveedor de persistencia elija la forma m\u00e1s adecuada seg\u00fan la base de datos. En la mayor\u00eda de los casos, esto se traducir\u00e1 en IDENTITY o SEQUENCE, si son compatibles.</li> <li>NONE: Esta opci\u00f3n significa que no se generar\u00e1 ning\u00fan valor autom\u00e1ticamente para la clave primaria. Debes proporcionar el valor de la clave primaria manualmente en tu c\u00f3digo.</li> </ul> <p>Cada estrategia tiene sus propias ventajas y limitaciones, y la elecci\u00f3n de la estrategia adecuada depende de la base de datos subyacente y los requisitos espec\u00edficos de tu aplicaci\u00f3n. Por ejemplo, si trabajas con una base de datos que admite autoincremento, IDENTITY es una elecci\u00f3n com\u00fan. Si est\u00e1s en una base de datos que utiliza secuencias, entonces SEQUENCE es apropiado. La estrategia AUTO es una opci\u00f3n conveniente si deseas que el proveedor de JPA elija la estrategia m\u00e1s adecuada en funci\u00f3n de la base de datos subyacente. Por otro lado, TABLE puede ser \u00fatil en situaciones donde ninguna de las otras estrategias es aplicable. La estrategia NONE se utiliza cuando deseas controlar completamente la generaci\u00f3n de valores por ti mismo. - <code>&lt;basic&gt;</code>: se utiliza para indicar los atributos de la clase. - <code>&lt;column-name&gt;</code>: se utiliza para indicar a que columna de la tabla hace referencia el atributo de la clase. Siempre van dentro de la etiqueta <code>basic</code>. En caso de que el atributo de la clase y el campo de la tabla sea el mismo, no es necesario indicarlo. - <code>&lt;many-to-many&gt;</code>: se utiliza para indicar un atributo for\u00e1neo que tiene relaci\u00f3n con otra tabla. - <code>&lt;join-table&gt;</code>: se utiliza para indicar con que tabla esta relacionada. - <code>&lt;join-column&gt;</code>: se utiliza para indicar el nombre de la columna a la que se una.</p> </li> </ul>"},{"location":"bloque_iv/tema_16/page-3/#anotaciones","title":"Anotaciones","text":"<p>Por lo general, se utilizan los archivos XML para configurar los componentes espec\u00edficos. Esto a veces supone un poco trillado, porque debemos conocer los atributos de la clase con los de la base de datos. Gracias a las anotaciones, podemos indicar dicha configuraci\u00f3n en las clases y atributos en Java. Todas las anotaciones est\u00e1n en el paquete <code>javax.persistence</code>.</p> <ul> <li><code>@Entity</code>: Esta anotaci\u00f3n se utiliza para marcar una clase como una entidad que se puede mapear a una tabla en la base de datos. Las instancias de esta clase se pueden administrar mediante JPA.</li> <li><code>@Table</code>: Se usa para especificar detalles espec\u00edficos de la tabla de la base de datos que corresponde a una entidad. Puedes definir el nombre de la tabla, el esquema y otras propiedades relacionadas con la tabla.</li> <li><code>@Id</code>: Indica que un atributo es la clave primaria de la entidad. Este atributo se asocia con la columna de clave primaria en la tabla de la base de datos.</li> <li><code>@GeneratedValue</code>: Se utiliza junto con @Id para especificar la estrategia de generaci\u00f3n de valores para la clave primaria. Puedes utilizar valores como IDENTITY, SEQUENCE, TABLE, AUTO, etc.</li> <li><code>@Column</code>: Se usa para personalizar la asignaci\u00f3n de atributos de entidad a columnas de la tabla de la base de datos. Puedes especificar el nombre de la columna, su tipo de datos, su longitud, y m\u00e1s.</li> <li><code>@ManyToOne</code> y <code>@OneToMany</code>: Estas anotaciones se utilizan para mapear relaciones entre entidades en una asociaci\u00f3n muchos a uno o uno a muchos. Por ejemplo, si tienes una entidad Author y una entidad Book, puedes utilizar estas anotaciones para definir la relaci\u00f3n entre autores y libros.</li> <li><code>@JoinColumn</code>: Esta anotaci\u00f3n se utiliza junto con @ManyToOne y @OneToMany para personalizar la columna que se utiliza para realizar la asociaci\u00f3n entre entidades.</li> <li><code>@OneToOne</code> y <code>@ManyToMany</code>: Estas anotaciones se utilizan para definir relaciones de uno a uno y muchos a muchos entre entidades.</li> <li><code>@NamedQuery</code> y <code>@NamedQueries</code>: Estas anotaciones se utilizan para definir consultas JPQL que se pueden reutilizar en varias partes de la aplicaci\u00f3n.</li> <li><code>@NamedNativeQuery</code> y <code>@NamedNativeQueries</code>: Similar a las anotaciones @NamedQuery, pero se utilizan para definir consultas SQL nativas en lugar de consultas JPQL.</li> <li><code>@Version</code>: Se usa para marcar un atributo que se utiliza para el control de versiones de una entidad. Ayuda a evitar problemas de concurrencia al realizar actualizaciones en registros.</li> <li><code>@Temporal</code>: Se utiliza para especificar el tipo de fecha y hora que se almacena en una columna, como DATE, TIME, o TIMESTAMP.</li> <li><code>@Lob</code>: Esta anotaci\u00f3n se usa para marcar un atributo que almacena datos grandes (como objetos binarios largos, como im\u00e1genes o documentos) en la base de datos.</li> <li><code>@PrePersist</code> y <code>@PreUpdate</code>: Estas anotaciones se utilizan para marcar m\u00e9todos que se ejecutar\u00e1n antes de la persistencia y antes de una actualizaci\u00f3n de una entidad, respectivamente.</li> <li><code>@PostLoad</code>, <code>@PostPersist</code>, <code>@PostUpdate</code>, y <code>@PostRemove</code>: Estas anotaciones se utilizan para marcar m\u00e9todos que se ejecutar\u00e1n despu\u00e9s de cargar una entidad, despu\u00e9s de la persistencia, despu\u00e9s de una actualizaci\u00f3n y despu\u00e9s de eliminar una entidad, respectivamente.</li> </ul> <pre><code>@Entity\n@Table(name = \"empleados\")\npublic class Employee{\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name=\"nombre\")\n    private String name;\n\n    @ManyToOne\n    @JoinColumn(name=\"department_id\")\n    private Department department;\n}\n\n@Entity\npublic Department{\n    @OneToMany(mappedBy = \"department\")\n    private List&lt;Employee&gt; employee;\n    //...\n}\n</code></pre>"},{"location":"bloque_iv/tema_16/page-3/#persistencexml","title":"Persistence.xml","text":"<p>El archivo <code>persistence.xml</code> es un archivo de configuraci\u00f3n esencial en el contexto de JPA. Se utiliza para definir la configuraci\u00f3n de la unidad de persistencia de una aplicaci\u00f3n Java que emplea JPA. Este archivo cumple varias funciones clave:</p> <ul> <li>Definici\u00f3n de la Unidad de Persistencia: El archivo persistence.xml define una o varias unidades de persistencia que representan las conexiones a bases de datos y las configuraciones de mapeo objeto-relacional (ORM) en la aplicaci\u00f3n. Cada unidad de persistencia se identifica por un nombre \u00fanico y agrupa configuraciones relacionadas.</li> <li>**Configuraci\u00f3n del Proveedor de JP**A: En el archivo persistence.xml, puedes especificar el proveedor de JPA que deseas utilizar en tu aplicaci\u00f3n. Los proveedores comunes incluyen Hibernate, EclipseLink y otros. La elecci\u00f3n del proveedor depende de tus necesidades y preferencias.</li> <li>Configuraci\u00f3n de la Fuente de Datos: Puedes definir la fuente de datos (generalmente una conexi\u00f3n a la base de datos) que la unidad de persistencia utilizar\u00e1 para interactuar con la base de datos. Esto incluye informaci\u00f3n como la URL de conexi\u00f3n, el nombre de usuario y la contrase\u00f1a.</li> <li>Definici\u00f3n de Clases de Entidad: El archivo persistence.xml enumera todas las clases de entidad que se administrar\u00e1n en la unidad de persistencia. Las clases de entidad son objetos Java que se mapean a tablas de bases de datos y se utilizan para realizar operaciones de persistencia.</li> <li>Configuraci\u00f3n Adicional: Puedes proporcionar propiedades de configuraci\u00f3n adicionales, como dialectos de SQL, estrategias de creaci\u00f3n de tablas, configuraci\u00f3n de cach\u00e9, y m\u00e1s, seg\u00fan las necesidades de tu aplicaci\u00f3n.</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;persistence xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\"\n    version=\"2.2\"&gt;\n    &lt;persistence-unit name=\"MyPersistenceUnit\"&gt;\n        &lt;!-- Configuraci\u00f3n del proveedor de JPA --&gt;\n        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;\n\n        &lt;!-- Configuraci\u00f3n de la fuente de datos --&gt;\n        &lt;jta-data-source&gt;java:jboss/datasources/MyDataSource&lt;/jta-data-source&gt;\n\n        &lt;!-- Lista de clases de entidad que se gestionar\u00e1n --&gt;\n        &lt;class&gt;com.example.Product&lt;/class&gt;\n        &lt;class&gt;com.example.Customer&lt;/class&gt;\n\n        &lt;!-- Configuraci\u00f3n adicional de JPA --&gt;\n        &lt;properties&gt;\n            &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.MySQLDialect\" /&gt;\n            &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"update\" /&gt;\n        &lt;/properties&gt;\n\n        &lt;mapping-file&gt;path/to/orm.xml&lt;/mapping-file&gt;\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre> <p>Destacamos las siguientes etiquetas:</p> <ul> <li><code>&lt;persistence-unit&gt;</code>: define la unidad de persistencia, indicando su nombre con el atributo name.</li> <li><code>&lt;class&gt;</code>: define la clase de entidad con nombre del paquete. Puede haber tantas como clases vamos a trabajar.</li> <li><code>&lt;provider&gt;</code>: Proveedor de persistencia.</li> <li><code>&lt;properties&gt;</code>: define las propiedades del provider y cada propiedad dentro de la etiqueta <code>&lt;property&gt;</code>.</li> <li><code>&lt;mapping-file&gt;</code>: define la ruta donde se encuentra el fichero de mapeo, en caso de que se tenga alguno.</li> </ul> <p>Este fichero se debe almacenar en el directorio <code>META_INF</code> localizado en el directorio principal del proyecto.</p>"},{"location":"bloque_iv/tema_16/page-3/#operaciones-de-persistencia","title":"Operaciones de persistencia","text":"<p>Para realizar operaciones de persistencia ser\u00e1 necesario crear un <code>EntityManager</code> (para ello ser\u00e1 necesario tener un <code>EntityManagerFactory</code>). El m\u00e9todo <code>Persistence.createEntityManagerFactory(\"MyPersistence\")</code> creamos un objeto <code>EntityManagerFactory</code> e invocamos el m\u00e9todo <code>createEntityManager</code> para crear un <code>EntityManager</code>.</p> <pre><code>EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"MyPersistenceUnit\");\nEntityManager em = emf.createEntityManager();\n</code></pre> <p>Para realizar cada tipo de operaci\u00f3n ser\u00e1 necesario obtener la transacci\u00f3n, comenzar y ejecutarla a trav\u00e9s de los siguientes m\u00e9todos:</p> <ul> <li><code>Transaction getTransaction()</code>: obtiene el objeto transacci\u00f3n de la <code>EntityManager</code>.</li> <li><code>begin()</code>: inicia la transacci\u00f3n.</li> <li><code>persist()</code>: crea un objeto en la persistencia.</li> <li><code>commit()</code>: actualiza los datos en la base de datos original.</li> <li><code>rollback()</code>: deshace la transacci\u00f3n en caso de error.</li> <li><code>find()</code>: busca un elemento de la Entidad dado un id.</li> <li><code>remove()</code>: elimina un elemento.</li> </ul> <p>Una vez realiza las operaciones es necesario cerrar la <code>EntityManagerFactory</code>y la <code>EntityManager</code>.</p> <pre><code>// Crear una EntityManagerFactory basada en persistence.xml\nEntityManagerFactory emf = Persistence.createEntityManagerFactory(\"MyPersistenceUnit\");\n\n// Crear un EntityManager a partir de EntityManagerFactory\nEntityManager em = emf.createEntityManager();\n\n// Operaci\u00f3n de creaci\u00f3n (Persistencia)\nEmployee employee = new Employee(123, \"John Doe\", 50000, \"Developer\");\nem.getTransaction().begin();\nem.persist(employee);\nem.getTransaction().commit();\n\n// Operaci\u00f3n de lectura (B\u00fasqueda)\nem.getTransaction().begin();\nEmployee retrievedEmployee = em.find(Employee.class, 123);\nem.getTransaction().commit();\n\nSystem.out.println(\"Empleado recuperado: \" + retrievedEmployee);\n\n// Operaci\u00f3n de actualizaci\u00f3n\nem.getTransaction().begin();\nretrievedEmployee.setSalary(55000);\nem.getTransaction().commit();\n\n// Operaci\u00f3n de eliminaci\u00f3n\nem.getTransaction().begin();\nem.remove(retrievedEmployee);\nem.getTransaction().commit();\n\n// Cerrar EntityManager y EntityManagerFactory\nem.close();\nemf.close();\n</code></pre>"},{"location":"bloque_iv/tema_16/page-4/","title":"4 Java Persistence Query Language (JPQL)","text":""},{"location":"bloque_iv/tema_16/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Java Persistence Query Language (JPQL) es un lenguaje de consulta que se utiliza en el contexto de Java Persistence API (JPA) para realizar consultas en bases de datos relacionales de una manera orientada a objetos. JPQL se basa en conceptos de programaci\u00f3n orientada a objetos y abstrae las diferencias entre los diversos sistemas de bases de datos, permitiendo a los desarrolladores realizar consultas de manera independiente del sistema de gesti\u00f3n de bases de datos subyacente. A continuaci\u00f3n, se detallan los aspectos m\u00e1s importantes de JPQL:</p> <ul> <li>Sintaxis Similar a SQL: JPQL tiene una sintaxis similar a SQL, lo que facilita la transici\u00f3n para aquellos familiarizados con SQL. Sin embargo, en lugar de referirse a tablas y columnas, se hace referencia a clases y atributos de entidades.</li> <li>Consulta de Entidades: JPQL permite realizar consultas en las entidades de tu aplicaci\u00f3n en lugar de tablas de la base de datos. Las entidades se mapean a tablas en la base de datos, y JPQL ofrece una abstracci\u00f3n para interactuar con estas entidades.</li> </ul>"},{"location":"bloque_iv/tema_16/page-4/#consultas-jpql","title":"Consultas JPQL","text":"<p>En JPQL encontramos los tipos de consultas similares a SQL:</p> <ul> <li>SELECT: Se utiliza para recuperar datos de la base de datos en forma de objetos de entidad.</li> <li>UPDATE: Permite realizar actualizaciones en los registros de la base de datos.</li> <li>DELETE: Permite eliminar registros de la base de datos.</li> <li>INSERT (rara vez utilizado en JPQL): Se usa para insertar nuevos registros.</li> </ul> <p>Al hacer un <code>SELECT</code> tenemos que tener en cuenta las siguientes cl\u00e1usulas</p> <ul> <li>SELECT: Indica qu\u00e9 atributos o entidades se deben recuperar.</li> <li>FROM: Especifica la entidad (o alias) desde la que se realizar\u00e1 la consulta.</li> <li>WHERE: Define condiciones para filtrar los resultados.</li> <li>ORDER BY: Ordena los resultados de la consulta.</li> <li>GROUP BY y HAVING: Utilizados para agrupar y filtrar resultados, respectivamente.</li> </ul> <pre><code>SELECT p FROM Product p\n</code></pre> <p>En el ejemplo anterior obtenemos todos los registros de la entidad Producto, siendo P un alias para indicar todos los atributos de la entidad producto</p> <p>En JPQL, podemos hacer uso de los par\u00e1metros de tal forma que facilita la creaci\u00f3n de consultas din\u00e1micas. Un par\u00e1metro va precedidos por dos puntos <code>:</code> y el nombre del par\u00e1metro (<code>:par\u00e1metro</code>). Hay que indicarle el valor del par\u00e1metro antes de ejecutar la consulta.</p> <pre><code>SELECT p FROM Product p WHERE p.name = :productName\n</code></pre> <p>JPQL tambi\u00e9n admite funciones de agregaci\u00f3n comunes como, <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MIN</code> y <code>MAX</code>, as\u00ed como las palabras claves para las asociaciones: <code>join</code>, <code>inner join</code>, etc.</p> <pre><code>SELECT p, c FROM Product p JOIN p.category c\n</code></pre> <p>A trav\u00e9s de JPQL puedes realizar subconsultas al igual que en SQL:</p> <pre><code>SELECT COUNT(p) FROM Product p WHERE p.category.name = 'Electr\u00f3nicos'\n</code></pre>"},{"location":"bloque_iv/tema_16/page-4/#interfaz-query-y-typequery","title":"Interfaz Query y TypeQuery <p>En Java Persistence API (JPA), TypedQuery y Query son dos interfaces relacionadas que se utilizan para ejecutar consultas, pero tienen diferencias clave en t\u00e9rminos de seguridad de tipos y conveniencia.</p> <ol> <li><code>TypeQuery&lt;T&gt;</code>:<ul> <li>Es una interfaz gen\u00e9rica que se utiliza para consultas JPQL que deben devolver resultados tipados</li> <li>Proporciona seguridad de tipos, lo que significa que el tipo de resultado se conoce en tiempo de compilaci\u00f3n y se garantiza que coincida con el tipo especificado en la consulta</li> <li>Mejora la legibilidad y el mantenimiento del c\u00f3digo al permitir el uso de resultados tipados en lugar de objetos gen\u00e9ricos.</li> <li>Es preferible cuando se espera un tipo de resultado espec\u00edfico y se desea evitar conversiones manuales.</li> </ul> </li> <li><code>Query</code>:<ul> <li>Es una interfaz no gen\u00e9rica que se utiliza para consultas JPQL que pueden devolver resultados no tipados o cuando el tipo de resultado no se conoce de antemano.</li> <li>No proporciona seguridad de tipos en tiempo de compilaci\u00f3n, lo que significa que los resultados se devuelven como objetos gen\u00e9ricos (Object).</li> <li>Es menos seguro en t\u00e9rminos de tipos y puede requerir conversiones manuales para trabajar con los resultados.</li> <li>Es \u00fatil en casos donde la estructura de los resultados es desconocida o cuando se desea una mayor flexibilidad.</li> </ul> </li> </ol> <p>En resumen, la principal diferencia entre TypedQuery y Query radica en la seguridad de tipos. TypedQuery se utiliza cuando se espera un tipo de resultado espec\u00edfico y se desea seguridad de tipos, mientras que Query se utiliza cuando la estructura de los resultados es menos predecible o no se necesita seguridad de tipos. La elecci\u00f3n entre ambas depende de los requisitos de tu consulta y de cu\u00e1nto control deseas tener sobre los tipos de resultados.</p> <p>Es importante resaltar que <code>TypeQuery</code>es hijo directo de <code>Query</code>.</p>","text":""},{"location":"bloque_iv/tema_16/page-4/#ejecucion-de-consultas","title":"Ejecuci\u00f3n de consultas <p>Para poder ejecutar las consultas en Java, se podr\u00e1 usar el m\u00e9todo <code>createQuery(query)</code> que recibe la query como par\u00e1metro. Algunos de sus m\u00e9todos importantes son:</p> <ul> <li><code>Query getResultList()</code>: Ejecuta la consulta y devuelve una lista con los registros resultados.</li> <li><code>Query getSingleResult()</code>: Ejecuta la consulta y devuelve un \u00fanico resultado. Lanza la excepci\u00f3n <code>NoResultException</code> si la consulta no devuelve ning\u00fan resultado y la excepci\u00f3n <code>NonUniqueResultException</code> si la consulta devuelve m\u00e1s de un resultado.</li> <li><code>Query setParameter(String name, Object value)</code>: establece los valores de los par\u00e1metros creados en la consulta. Si hemos creado un par\u00e1metro en la consulta <code>:name</code> en el par\u00e1metro del m\u00e9todo se indica unicamente el nombre y no los dos puntos. Existe un versi\u00f3n sobrecargada que en vez de recibir el nombre del par\u00e1metro recibe la posici\u00f3n del mismo.</li> <li><code>Query setFirstResult(int startPosition)</code>: se utiliza para establecer el primer resultado que se debe recuperar. Es \u00fatil para la paginaci\u00f3n de resultados.</li> <li><code>Query setMaxResults(int maxResult)</code>: Este m\u00e9todo se utiliza para limitar el n\u00famero de resultados recuperados. Tambi\u00e9n es \u00fatil para paginaci\u00f3n.</li> <li><code>int executeUpdate()</code>: Este m\u00e9todo se utiliza para ejecutar una consulta de modificaci\u00f3n (por ejemplo, UPDATE o DELETE). Devuelve el n\u00famero de registros afectados por la consulta.</li> </ul> <p>En JPQL podemos ejecutar consultas nombradas. Una consulta nombradas es un consulta ya creada e identificada con un nombre, por lo que primero debe estar definida en el archivo de mapeo, o por el contrario a trav\u00e9s de las anotaciones:</p> XMLAnotaciones   <pre><code>&lt;named-query name=\"Product.findByName\"&gt;\n    &lt;query&gt;\n        SELECT p FROM Product p WHERE p.name = :productName\n    &lt;/query&gt;\n&lt;/named-query&gt;\n</code></pre>   <pre><code>@Entity\n@NamedQuery(\n    name = \"Product.findByName\",\n    query = \"SELECT p FROM Product p WHERE p.name = :productName\"\n)\npublic class Product {\n    // Atributos, constructores y m\u00e9todos de la entidad\n}\n</code></pre>    <p>Para usarlo en java hacemos uso del m\u00e9todo <code>createNamedQuery('name')</code>, siendo name el nombre de la consultada creada:</p> <pre><code>TypedQuery&lt;Product&gt; query = entityManager.createNamedQuery(\"Product.findByName\", Product.class);\nquery.setParameter(\"productName\", \"Laptop\");\nList&lt;Product&gt; products = query.getResultList();\n</code></pre>","text":""},{"location":"bloque_iv/tema_16/page-4/#consultas-nativas","title":"Consultas nativas <p>Las consultas nativas en JPA permiten ejecutar consultas SQL directamente en la base de datos utilizando SQL nativo en lugar de JPQL. Las consultas nativas son \u00fatiles cuando necesitas ejecutar consultas SQL espec\u00edficas de tu base de datos o realizar operaciones que no se pueden expresar f\u00e1cilmente en JPQL.</p> <p>Para ejecutar una consulta nativa en JPA, puedes usar el m\u00e9todo <code>createNativeQuery()</code> proporcionado por la interfaz <code>EntityManager</code>. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo ejecutar una consulta SQL nativa en JPA:</p> <pre><code>EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"MyPersistenceUnit\");\nEntityManager em = emf.createEntityManager();\n\n// Ejecutar una consulta SQL nativa para seleccionar todos los productos con un precio mayor a 50\nString sql = \"SELECT * FROM Product WHERE price &gt; 50\";\nList&lt;Object[]&gt; results = em.createNativeQuery(sql).getResultList();\n\nfor (Object[] row : results) {\n    Long id = (Long) row[0];\n    String name = (String) row[1];\n    double price = (Double) row[2];\n    System.out.println(\"Product ID: \" + id + \", Name: \" + name + \", Price: \" + price);\n}\n\nem.close();\nemf.close();\n</code></pre>","text":""},{"location":"bloque_iv/tema_16/page-5/","title":"5 Estrategias de herencia","text":""},{"location":"bloque_iv/tema_16/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Java Persistence API (JPA) proporciona varias estrategias para mapear la herencia en un modelo de objetos a una estructura de base de datos relacional. Estas estrategias permiten definir c\u00f3mo se representan las jerarqu\u00edas de clases en la base de datos. A continuaci\u00f3n, se describen las estrategias de herencia comunes en JPA con ejemplos y esquemas:</p> <p>Supongamos que tenemos una jerarqu\u00eda de clases de productos con una clase base <code>Product</code> y dos subclases <code>Book</code> y <code>Electronics</code>. Cada una de las estrategias a continuaci\u00f3n se ilustrar\u00e1 utilizando esta jerarqu\u00eda.</p>"},{"location":"bloque_iv/tema_16/page-5/#herencia-de-tabla-unica-single-table-inheritance","title":"Herencia de tabla \u00fanica (Single Table Inheritance)","text":"<p>En esta estrategia, se utiliza una sola tabla para almacenar todas las entidades de la jerarqu\u00eda. Se agrega una columna discriminadora (generalmente una columna de tipo) para indicar la clase concreta de cada fila.</p> <p>Una columna discriminadora es una columna en una tabla de base de datos que se utilizar para identificar la clase concreta de una entidad en una jerarqu\u00eda de herencia. Por ejemplo, en una tabla producto, en la columna product_type se indica el tipo de producto que es, y ese tipo est\u00e1 relacionado con una subclase de la clase Product.</p> <p>Un valor discriminado es el valor que se le dar\u00e1 en esa columna discriminadora en caso de ser del tipo espec\u00edfico.</p> XMLAnotacionesEsquema <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity-mappings xmlns=\"http://xmlns.jcp.org/xml/ns/persistence/orm\"\n                 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                 xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence/orm http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd\"\n                 version=\"2.2\"&gt;\n    &lt;entity class=\"com.example.model.Product\"&gt;\n        &lt;table name=\"Product\"/&gt;\n        &lt;inheritance strategy=\"SINGLE_TABLE\"/&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"name\"/&gt;\n            &lt;!-- Otros campos y mapeos espec\u00edficos de Product --&gt;\n        &lt;/attributes&gt;\n        &lt;discriminator-column name=\"product_type\" length=\"1\"/&gt;\n    &lt;/entity&gt;\n\n    &lt;entity class=\"com.example.model.Book\"&gt;\n        &lt;table name=\"Product\"/&gt;\n        &lt;attributes&gt;\n            &lt;discriminator-value&gt;B&lt;/discriminator-value&gt;\n            &lt;basic name=\"author\"/&gt;\n            &lt;!-- Otros campos y mapeos espec\u00edficos de Book --&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n\n    &lt;entity class=\"com.example.model.Electronics\"&gt;\n        &lt;table name=\"Product\"/&gt;\n        &lt;attributes&gt;\n            &lt;discriminator-value&gt;E&lt;/discriminator-value&gt;\n            &lt;basic name=\"manufacturer\"/&gt;\n            &lt;!-- Otros campos y mapeos espec\u00edficos de Electronics --&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n&lt;/entity-mappings&gt;\n</code></pre> <pre><code>@Entity\n@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n@DiscriminatorColumn(name = \"product_type\")\npublic class Product {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n    // Otros campos y m\u00e9todos\n}\n\n@Entity\n@DiscriminatorValue(\"B\")\npublic class Book extends Product {\n    private String author;\n    // Otros campos y m\u00e9todos espec\u00edficos de Book\n}\n\n@Entity\n@DiscriminatorValue(\"E\")\npublic class Electronics extends Product {\n    private String manufacturer;\n    // Otros campos y m\u00e9todos espec\u00edficos de Electronics\n}\n</code></pre> <pre><code>| ID | NAME    | PRODUCT_TYPE | AUTHOR         | MANUFACTURER   |\n|----|---------|--------------|----------------|----------------|\n| 1  | BookA   | B            | John Doe       |                |\n| 2  | Laptop  | E            |                | Lenovo         |\n</code></pre>"},{"location":"bloque_iv/tema_16/page-5/#herencia-de-tabla-por-clase-table-per-class-inheritance","title":"Herencia de tabla por clase (Table per Class Inheritance)","text":"<p>En esta estrategia, cada clase concreta en la jerarqu\u00eda de herencia tiene su propia tabla en la base de datos. Se crea una tabla separada para cada clase, y todas las tablas comparten una clave principal.</p> XMLAnotacionesEsquema <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity-mappings xmlns=\"http://xmlns.jcp.org/xml/ns/persistence/orm\"\n                    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence/orm http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd\"\n                    version=\"2.2\"&gt;\n    &lt;entity class=\"com.example.model.Product\"&gt;\n        &lt;table name=\"Product\"/&gt;\n        &lt;inheritance strategy=\"TABLE_PER_CLASS\"/&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"name\"/&gt;\n            &lt;!-- Otros campos y mapeos espec\u00edficos de Product --&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n\n    &lt;entity class=\"com.example.model.Book\"&gt;\n        &lt;attributes&gt;\n            &lt;basic name=\"author\"/&gt;\n            &lt;!-- Otros campos y mapeos espec\u00edficos de Book --&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n\n    &lt;entity class=\"com.example.model.Electronics\"&gt;\n        &lt;attributes&gt;\n            &lt;basic name=\"manufacturer\"/&gt;\n            &lt;!-- Otros campos y mapeos espec\u00edficos de Electronics --&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n&lt;/entity-mappings&gt;\n</code></pre> <pre><code>@Entity\n@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\npublic class Product {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n    // Otros campos y m\u00e9todos\n}\n\n@Entity\npublic class Book extends Product {\n    private String author;\n    // Otros campos y m\u00e9todos espec\u00edficos de Book\n}\n\n@Entity\npublic class Electronics extends Product {\n    private String manufacturer;\n    // Otros campos y m\u00e9todos espec\u00edficos de Electronics\n}\n</code></pre> <pre><code>Product Table:\n| ID | NAME    |\n|----|---------|\n| 1  | BookA   |\n| 2  | Laptop  |\n\nBook Table:\n| ID | AUTHOR         |\n|----|----------------|\n| 1  | John Doe       |\n\nElectronics Table:\n| ID | MANUFACTURER   |\n|----|----------------|\n| 2  | Lenovo         |\n</code></pre>"},{"location":"bloque_iv/tema_16/page-5/#herencia-de-tabla-por-subclase-table-per-subclass-inheritance","title":"Herencia de tabla por subclase (Table per Subclass Inheritance)","text":"<p>En esta estrategia, se crea una tabla para la clase base y una tabla separada para cada subclase. Las tablas de las subclases tienen una relaci\u00f3n uno a uno con la tabla de la clase base utilizando una clave for\u00e1nea.</p> XMLAnotacionesEsquema <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity-mappings xmlns=\"http://xmlns.jcp.org/xml/ns/persistence/orm\"\n                    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence/orm http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd\"\n                    version=\"2.2\"&gt;\n    &lt;entity class=\"com.example.model.Product\"&gt;\n        &lt;table name=\"Product\"/&gt;\n        &lt;inheritance strategy=\"JOINED\"/&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"name\"/&gt;\n            &lt;!-- Otros campos y mapeos espec\u00edficos de Product --&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n\n    &lt;entity class=\"com.example.model.Book\"&gt;\n        &lt;attributes&gt;\n            &lt;basic name=\"author\"/&gt;\n            &lt;!-- Otros campos y mapeos espec\u00edficos de Book --&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n\n    &lt;entity class=\"com.example.model.Electronics\"&gt;\n        &lt;attributes&gt;\n            &lt;basic name=\"manufacturer\"/&gt;\n            &lt;!-- Otros campos y mapeos espec\u00edficos de Electronics --&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n&lt;/entity-mappings&gt;\n</code></pre> <pre><code>@Entity\n@Inheritance(strategy = InheritanceType.JOINED)\npublic class Product {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n    // Otros campos y m\u00e9todos\n}\n\n@Entity\npublic class Book extends Product {\n    private String author;\n    // Otros campos y m\u00e9todos espec\u00edficos de Book\n}\n\n@Entity\npublic class Electronics extends Product {\n    private String manufacturer;\n    // Otros campos y m\u00e9todos espec\u00edficos de Electronics\n}\n</code></pre> <pre><code>Product Table:\n| ID | NAME    |\n|----|---------|\n| 1  | BookA   |\n| 2  | Laptop  |\n\nBook Table:\n| ID | AUTHOR         |\n|----|----------------|\n| 1  | John Doe       |\n\nElectronics Table:\n| ID | MANUFACTURER   |\n|----|----------------|\n| 2  | Lenovo         |\n</code></pre> <p>Estas son tres de las estrategias de herencia m\u00e1s comunes en JPA. La elecci\u00f3n de la estrategia de herencia depende de tus necesidades espec\u00edficas y del dise\u00f1o de tu base de datos. Cada estrategia tiene sus ventajas y desventajas, por lo que debes seleccionar la que mejor se adapte a tu aplicaci\u00f3n y modelo de datos.</p>"},{"location":"bloque_iv/tema_16/page-6/","title":"6 Relaciones de Entidades","text":"<p>En Java Persistence API (JPA), las relaciones de entidad son una parte fundamental para modelar las relaciones entre las clases de entidad en tu aplicaci\u00f3n y, en \u00faltima instancia, mapearlas a la base de datos. Las relaciones de entidad permiten definir c\u00f3mo las entidades se relacionan entre s\u00ed y c\u00f3mo se almacenan y recuperan en la base de datos.</p> <p>Los tipos de relaciones entre entidades son similares a las relaciones que existen entre entidades en las bases de datos, tenemos relaci\u00f3n de uno a uno, relaci\u00f3n de uno a muchos, relaci\u00f3n de muchos a uno y relaci\u00f3n de muchos a muchos.</p> <p>Cuando se trabaja con relaciones en JPA, una de las entidades involucradas se considera la entidad propietaria de la relaci\u00f3n, mientras que la otra se considera la entidad inversa o no propietaria. La entidad propietaria es la que controla c\u00f3mo se mapea la relaci\u00f3n en la base de datos y, por lo general, es la que contiene la clave for\u00e1nea que establece la relaci\u00f3n.</p>"},{"location":"bloque_iv/tema_16/page-6/#one-to-one","title":"One to one","text":"<p>Es una relaci\u00f3n uno a uno, es decir una entidad se relaciona con exactamente una entidad en el otro lado de la relaci\u00f3n.</p> <p>Con la anotaci\u00f3n <code>@OneToOne</code> (o su etiqueta equivalente <code>&lt;one-to-one&gt;</code>) indicamos el atributo de la clase que tiene relaci\u00f3n.</p> <p>El atributo <code>mappedBy</code> se utiliza en una relaci\u00f3n bidireccional entre entidades en JPA para indicar cu\u00e1l es el campo en la entidad inversa que mapea la relaci\u00f3n. Cuando se establece mappedBy, se est\u00e1 definiendo que la entidad actual no es la propietaria de la relaci\u00f3n y que la propiedad de la relaci\u00f3n se encuentra en la entidad que se especifica en mappedBy.</p> <p>En el ejemplo, tenemos una relaci\u00f3n One-to-One entre las entidades Student y Address. La entidad Student contiene una referencia a la entidad Address, y viceversa, para representar una relaci\u00f3n de estudiante a direcci\u00f3n. Aqu\u00ed, <code>mappedBy</code> no se utiliza en la entidad Student, lo que indica que Student es el propietario de la relaci\u00f3n y es responsable de la clave for\u00e1nea en la tabla de la base de datos.</p> <p>En el caso de la entidad Address, <code>mappedBy = \"address\"</code> indica que la entidad Address no es la propietaria de la relaci\u00f3n. En cambio, la relaci\u00f3n se mapea a trav\u00e9s del campo address en la entidad Student. Esto significa que la entidad Student es la propietaria de la relaci\u00f3n y contiene la clave for\u00e1nea en la tabla de la base de datos que se utiliza para relacionar un estudiante con una direcci\u00f3n.</p> <p>La etiqueta <code>&lt;join-column&gt;</code> se utiliza para personalizar la configuraci\u00f3n de la columna de clave for\u00e1nea en una relaci\u00f3n, pero no es necesaria si deseas utilizar la configuraci\u00f3n predeterminada.</p> AnotacionesXML <pre><code>@Entity\npublic class Student {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n\n    @OneToOne\n    @JoinColumn(name = \"address_id\")\n    private Address address;\n\n    // Getters y setters\n}\n\n@Entity\npublic class Address {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String street;\n    private String city;\n\n    @OneToOne(mappedBy = \"address\")\n    private Student student;\n\n    // Getters y setters\n}\n</code></pre> <pre><code>&lt;entity-mappings xmlns=\"http://xmlns.jcp.org/xml/ns/persistence/orm\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence/orm http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd\"\n             version=\"2.2\"&gt;\n    &lt;entity class=\"com.example.model.Student\"&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"name\"/&gt;\n            &lt;one-to-one name=\"address\"&gt;\n                &lt;join-column name=\"address_id\"/&gt; \n            &lt;/one-to-one&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n\n    &lt;entity class=\"com.example.model.Address\"&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"street\"/&gt;\n            &lt;basic name=\"city\"/&gt;\n            &lt;one-to-one name=\"student\" mapped-by=\"address\"/&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n&lt;/entity-mappings&gt;\n</code></pre>"},{"location":"bloque_iv/tema_16/page-6/#one-to-many","title":"One to many","text":"<p>En la relaci\u00f3n uno a muchos, un registro de una entidad se relaciona con varios registros de otra entidad.</p> <p>Con la anotaci\u00f3n <code>@OneToMany</code> (o su etiqueta equivalente <code>&lt;one-to-many&gt;</code>) indicamos el atributo de la clase que tiene relaci\u00f3n de uno a muchos. En la otra entidad (la no propietaria), indicamos la anotaci\u00f3n contraria <code>@ManyToOne</code> (o su equivalente <code>&lt;many-to-one&gt;</code>)</p> AnotacionesXML <pre><code>@Entity\npublic class Department {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n\n    @OneToMany(mappedBy = \"department\")\n    private List&lt;Employee&gt; employees;\n\n    // Getters y setters\n}\n\n@Entity\npublic class Employee {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n\n    @ManyToOne\n    @JoinColumn(name = \"department_id\") // Nombre de la columna de clave for\u00e1nea\n    private Department department;\n\n    // Getters y setters\n}\n</code></pre> <pre><code>&lt;entity-mappings xmlns=\"http://xmlns.jcp.org/xml/ns/persistence/orm\"\n                 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                 xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence/orm http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd\"\n                 version=\"2.2\"&gt;\n    &lt;entity class=\"com.example.model.Department\"&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"name\"/&gt;\n            &lt;one-to-many name=\"employees\"&gt;\n                &lt;map-key-column name=\"department_id\"/&gt; &lt;!-- Nombre de la columna de clave for\u00e1nea --&gt;\n            &lt;/one-to-many&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n\n    &lt;entity class=\"com.example.model.Employee\"&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"name\"/&gt;\n            &lt;many-to-one name=\"department\"&gt;\n                &lt;join-column name=\"department_id\"/&gt; &lt;!-- Nombre de la columna de clave for\u00e1nea --&gt;\n            &lt;/many-to-one&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n&lt;/entity-mappings&gt;\n</code></pre> <p>En el ejemplo anterior, Employee es la entidad propietaria de la relaci\u00f3n One-to-Many y la entidad Department usa la anotaci\u00f3n con el <code>mappedBy</code>. La entidad Employee contiene una clave for\u00e1nea llamada department_id que referencia al departamento al que pertenece.</p>"},{"location":"bloque_iv/tema_16/page-6/#many-to-many","title":"Many to many","text":"<p>En la relaci\u00f3n muchos a muchos, varios registros de una entidad se relacionan con varios registros de otra entidad.</p> <p>Con la anotaci\u00f3n <code>@ManyToMany</code> (o su etiqueta equivalente <code>&lt;many-to-many&gt;</code>) indicamos el atributo de la clase que tiene relaci\u00f3n de muchos a muchos.</p> AnotacionesXML <pre><code>@Entity\npublic class Student {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n\n    @ManyToMany\n    @JoinTable(name = \"student_course\",\n        joinColumns = @JoinColumn(name = \"student_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"course_id\"))\n    private List&lt;Course&gt; courses;\n\n    // Getters y setters\n}\n\n@Entity\npublic class Course {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n\n    @ManyToMany(mappedBy = \"courses\")\n    private List&lt;Student&gt; students;\n\n    // Getters y setters\n}\n</code></pre> <pre><code>&lt;entity-mappings xmlns=\"http://xmlns.jcp.org/xml/ns/persistence/orm\"\n                 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                 xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence/orm http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd\"\n                 version=\"2.2\"&gt;\n    &lt;entity class=\"com.example.model.Student\"&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"name\"/&gt;\n            &lt;many-to-many name=\"courses\"&gt;\n                &lt;join-table name=\"student_course\"&gt;\n                    &lt;join-column name=\"student_id\"/&gt;\n                    &lt;inverse-join-column name=\"course_id\"/&gt;\n                &lt;/join-table&gt;\n            &lt;/many-to-many&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n\n    &lt;entity class=\"com.example.model.Course\"&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"name\"/&gt;\n            &lt;many-to-many name=\"students\" mapped-by=\"courses\"/&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n&lt;/entity-mappings&gt;\n</code></pre> <p>En este ejemplo, tanto Student como Course son propietarios de la relaci\u00f3n Many-to-Many. La anotaci\u00f3n <code>@ManyToMany</code> se utiliza en ambas entidades para establecer la relaci\u00f3n, y se utiliza <code>@JoinTable</code> para especificar la tabla de uni\u00f3n (student_course) que asocia las dos entidades. Esta anotaci\u00f3n permite especificar el nombre de la tabla intermedia, as\u00ed como las columnas de clave for\u00e1nea (join columns) que conectan las tablas de las entidades relacionadas.</p> <p>Explicaci\u00f3n de los atributos de <code>@JoinTable</code>:</p> <ul> <li><code>name</code>: Especifica el nombre de la tabla intermedia que se crea para la relaci\u00f3n Many-to-Many. En este caso, la tabla intermedia se llama \"student_course\".</li> <li><code>joinColumns</code>: Especifica las columnas de clave for\u00e1nea en la tabla intermedia que hacen referencia a la entidad actual (Student). En este caso, la columna de clave for\u00e1nea en la tabla intermedia \"student_course\" que se relaciona con la entidad Student se llama \"student_id\".</li> <li><code>inverseJoinColumns</code>: Especifica las columnas de clave for\u00e1nea en la tabla intermedia que hacen referencia a la entidad relacionada (Course). En este caso, la columna de clave for\u00e1nea en la tabla intermedia \"student_course\" que se relaciona con la entidad Course se llama \"course_id\".</li> </ul> <p>La anotaci\u00f3n @JoinTable se utiliza en una de las dos entidades que participan en una relaci\u00f3n Many-to-Many para configurar la tabla de uni\u00f3n (tabla intermedia) que conecta las dos entidades. Generalmente, se coloca en la entidad propietaria de la relaci\u00f3n o en la entidad que tiene m\u00e1s control sobre la configuraci\u00f3n de la tabla de uni\u00f3n.</p> <p>La otra entidad, aunque a\u00fan se considera propietaria de la relaci\u00f3n, no necesariamente contendr\u00e1 <code>@JoinTable</code>, ya que asumir\u00e1 la configuraci\u00f3n definida en la entidad principal propietaria. En su lugar, la otra entidad puede utilizar <code>mapped-by</code> para establecer la relaci\u00f3n inversa y, por lo tanto, no necesita especificar nuevamente los detalles de la tabla de uni\u00f3n.</p>"},{"location":"bloque_iv/tema_16/page-7/","title":"7 Proyecto Students con JPA","text":""},{"location":"bloque_iv/tema_16/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>Una vez conocido todos los conceptos y relaciones pertinentes, es momento de aplicar dichos conocimientos a nuestro proyecto Bookstore, que en la \u00faltima versi\u00f3n hab\u00eda sido a\u00f1adida el patr\u00f3n de dise\u00f1o Repository. En esta versi\u00f3n, es indiferente el tipo de patr\u00f3n de dise\u00f1o a usar, ya que para lo que nos compete el funcionamiento es bastante similar.</p>"},{"location":"bloque_iv/tema_16/page-7/#configuracion-de-dependencias","title":"Configuraci\u00f3n de dependencias","text":"<p>Si usamos un gestor de dependencias como Maven o Gradle, es necesario importar los artifacts, tanto de Hibernate como de JPA, as\u00ed como el conector de la base de datos:</p> MavenGradle <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;version&gt;8.0.33&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;javax.persistence&lt;/groupId&gt;\n        &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt;\n        &lt;version&gt;2.2&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n        &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;\n        &lt;version&gt;6.2.7.Final&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>dependencies {\n    implementation 'javax.persistence:javax.persistence-api:2.2'\n    implementation 'org.hibernate:hibernate-core:5.5.6.Final'\n}\n</code></pre>"},{"location":"bloque_iv/tema_16/page-7/#configuracion-de-las-orm","title":"Configuraci\u00f3n de las ORM","text":"<p>Podemos usar nuestras clases POJOs con anotaciones o haciendo uso del XML:</p> StudentCourseInscription ORMAnnotation <pre><code>&lt;entity-mappings xmlns=\"https://jakarta.ee/xml/ns/persistence/orm\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"https://jakarta.ee/xml/ns/persistence/orm https://jakarta.ee/xml/ns/persistence/orm/orm_3_0.xsd\"\n             version=\"3.0\"&gt;\n    &lt;entity class=\"com.irudev.data.entity.Student\" &gt;\n        &lt;table name=\"student\"/&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;column name=\"id\"/&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"name\"&gt;\n                &lt;column name=\"name\"/&gt;\n            &lt;/basic&gt;\n            &lt;basic name=\"age\"&gt;\n                &lt;column name=\"age\"/&gt;\n            &lt;/basic&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n&lt;/entity-mappings&gt;\n</code></pre> <pre><code>@Entity\npublic class Student implements Comparable&lt;Student&gt;{\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Integer id;\n    private String name;\n    private int age;\n\n    public Student(){}\n    public Student(Integer id, String name, int age){\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    // ...\n}\n</code></pre> ORMAnnotation <pre><code>&lt;entity-mappings xmlns=\"http://xmlns.jcp.org/xml/ns/persistence/orm\"\n                 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                 xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence/orm\n                                     http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd\"\n                 version=\"2.2\"&gt;\n    &lt;entity class=\"com.irudev.data.entity.Course\"&gt;\n        &lt;table name=\"course\"/&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;column name=\"id\"/&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;basic name=\"name\"&gt;\n                &lt;column name=\"name\"/&gt;\n            &lt;/basic&gt;\n            &lt;basic name=\"credits\"&gt;\n                &lt;column name=\"credits\"/&gt;\n            &lt;/basic&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n&lt;/entity-mappings&gt;\n</code></pre> <pre><code>@Entity\npublic class Course implements Comparable&lt;Course&gt;{\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Integer id;\n    private String name;\n    private int credits;\n\n    public Course(){}\n    // ...\n}\n</code></pre> ORMAnnotation <pre><code>&lt;entity-mappings xmlns=\"http://xmlns.jcp.org/xml/ns/persistence/orm\"\n                 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                 xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence/orm\n                                     http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd\"\n                 version=\"2.2\"&gt;\n    &lt;entity class=\"com.irudev.data.entity.Inscription\"&gt;\n        &lt;table name=\"inscription\"/&gt;\n        &lt;attributes&gt;\n            &lt;id name=\"id\"&gt;\n                &lt;column name=\"id\"/&gt;\n                &lt;generated-value strategy=\"IDENTITY\"/&gt;\n            &lt;/id&gt;\n            &lt;many-to-one name=\"student\" fetch=\"EAGER\"&gt;\n                &lt;join-column name=\"idStudent\"/&gt;\n            &lt;/many-to-one&gt;\n            &lt;many-to-one name=\"course\" fetch=\"EAGER\"&gt;\n                &lt;join-column name=\"idCourse\"/&gt;\n            &lt;/many-to-one&gt;\n        &lt;/attributes&gt;\n    &lt;/entity&gt;\n&lt;/entity-mappings&gt;\n</code></pre> <pre><code>@Entity\npublic class Inscription implements Comparable&lt;Inscription&gt;{\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Integer id;\n\n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"idStudent\")\n    private Student student;\n\n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"idCourse\")\n    private Course course;\n\n    public Inscription(){}\n    // ...\n}\n</code></pre>"},{"location":"bloque_iv/tema_16/page-7/#archivo-de-configuracion","title":"Archivo de configuraci\u00f3n","text":"<p>Debemos de crear el archivo de configuraci\u00f3n persistence xml</p> <pre><code>&lt;!-- persistence.xml --&gt;\n&lt;persistence version=\"3.0\" xmlns=\"https://jakarta.ee/xml/ns/persistence\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd\"&gt;\n\n    &lt;persistence-unit name=\"myPersistenceUnit\"&gt;\n        &lt;!-- Asignaci\u00f3n de Hibernate como JPA Provider --&gt;\n        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;\n\n        &lt;!-- Mapeo ORM --&gt;\n        &lt;mapping-file&gt;META-INF/orm/Student.xml&lt;/mapping-file&gt;\n        &lt;mapping-file&gt;META-INF/orm/Course.xml&lt;/mapping-file&gt;\n        &lt;mapping-file&gt;META-INF/orm/Inscription.xml&lt;/mapping-file&gt;\n\n\n        &lt;!-- Configuraci\u00f3n de las propiedades --&gt;\n        &lt;properties&gt;\n            &lt;!-- Configuraci\u00f3n de la fuente de datos para MySQL --&gt;\n            &lt;property name=\"javax.persistence.jdbc.driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;\n            &lt;property name=\"javax.persistence.jdbc.url\" value=\"jdbc:mysql://localhost:3306/students?useSSL=false&amp;amp;serverTimezone=UTC\"/&gt;\n            &lt;property name=\"javax.persistence.jdbc.user\" value=\"root\"/&gt;\n            &lt;property name=\"javax.persistence.jdbc.password\" value=\"\"/&gt;\n\n            &lt;!-- Configuraci\u00f3n de Hibernate --&gt;\n            &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.MySQLDialect\"/&gt;\n            &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt;\n            &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"update\"/&gt;\n        &lt;/properties&gt;\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre> <p>Importante</p> <p>En el fichero persistence.xml ser\u00e1 obligatorio indicar el <code>mapping-file</code> si se usa archivos xml para la ORM en lugar de anotaciones</p>"},{"location":"bloque_iv/tema_16/page-7/#modelos","title":"Modelos","text":"<p>Al no utilizar los m\u00e9todos ni crear las conexiones, los modelos deben cambiar:</p> StudentCourseInscription <pre><code>public class JDBCStudentRepository implements StudentRepository {\n\n    private final EntityManager manager;\n\n    public JDBCStudentRepository(EntityManager manager){\n        this.manager = manager;\n    }\n\n    @Override\n    public Student getById(Integer id) {\n        return manager.find(Student.class, id);\n    }\n\n    @Override\n    public List&lt;Student&gt; getAll() {\n        return manager.createQuery(\"select s from Student s\", Student.class).getResultList();\n    }\n\n    @Override\n    public boolean save(Student student) {\n        try{\n            manager.getTransaction().begin();\n            manager.persist(student);\n            manager.getTransaction().commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n\n    @Override\n    public boolean update(Student student) {\n        try{\n            manager.getTransaction().begin();\n            manager.merge(student);\n            manager.getTransaction().commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n\n    @Override\n    public boolean delete(Student student) {\n        try{\n            manager.getTransaction().begin();\n            manager.remove(student);\n            manager.getTransaction().commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n}\n</code></pre> <pre><code>public class JDBCCourseRepository implements CourseRepository {\n    private final EntityManager manager;\n\n    public JDBCCourseRepository(EntityManager manager) {\n        this.manager = manager;\n    }\n\n    @Override\n    public Course getById(Integer id) {\n        return manager.find(Course.class, id);\n    }\n\n    @Override\n    public List&lt;Course&gt; getAll() {\n        return manager.createQuery(\"select c from Course c\", Course.class).getResultList();\n    }\n\n\n    @Override\n    public boolean save(Course course) {\n        try{\n            manager.getTransaction().begin();\n            manager.persist(course);\n            manager.getTransaction().commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n\n    @Override\n    public boolean update(Course course) {\n        try{\n            manager.getTransaction().begin();\n            manager.merge(course);\n            manager.getTransaction().commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n\n    @Override\n    public boolean delete(Course course) {\n        try{\n            manager.getTransaction().begin();\n            manager.remove(course);\n            manager.getTransaction().commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n}\n</code></pre> <pre><code>public class JDBCInscriptionRepository implements InscriptionRepository {\n    private final EntityManager manager;\n\n    public JDBCInscriptionRepository(EntityManager manager) {\n        this.manager = manager;\n    }\n\n    @Override\n    public Inscription getById(Integer id) {\n        return manager.find(Inscription.class, id);\n    }\n\n    @Override\n    public List&lt;Inscription&gt; getAll() {\n        return manager.createQuery(\"select i from Inscription i\", Inscription.class).getResultList();\n\n    }\n\n    @Override\n    public boolean save(Inscription inscription) {\n        try{\n            manager.getTransaction().begin();\n            manager.persist(inscription);\n            manager.getTransaction().commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n\n\n    @Override\n    public boolean delete(Inscription inscription) {\n        try{\n            manager.getTransaction().begin();\n            manager.remove(inscription);\n            manager.getTransaction().commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_16/page-8/","title":"8 Hibernate","text":""},{"location":"bloque_iv/tema_16/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Hibernate es un proveedor de JPA, uno de los m\u00e1s populares y ampliamente utilizados en la comunidad de desarrollo de Java. Act\u00faa como una implementaci\u00f3n de la especificaci\u00f3n JPA, permitiendo a los desarrolladores interactuar con bases de datos relacionales utilizando entidades mapeadas en objetos Java.</p> <p>Hibernate ofrece una serie de caracter\u00edsticas poderosas para el mapeo objeto-relacional, incluyendo:</p> <ol> <li>Mapeo de entidades: Hibernate permite mapear clases Java a tablas en la base de datos y atributos de clase a columnas en esas tablas.</li> <li>Consultas JPQL: Proporciona un lenguaje de consulta llamado JPQL (Java Persistence Query Language) que permite realizar consultas orientadas a objetos en lugar de escribir SQL directamente.</li> <li>Gesti\u00f3n de transacciones: Hibernate facilita la gesti\u00f3n de transacciones en aplicaciones JPA, lo que garantiza la consistencia y la integridad de los datos.</li> <li>Cach\u00e9 de primer y segundo nivel: Ofrece mecanismos de cach\u00e9 que pueden mejorar el rendimiento de las consultas y reducir la carga en la base de datos.</li> <li>Relaciones: Hibernate admite una variedad de tipos de relaciones, incluyendo relaciones uno a uno, uno a muchos y muchos a muchos, lo que facilita el modelado de datos complejos.</li> <li>Herencia: Permite mapear jerarqu\u00edas de clases y herencia de manera eficiente.</li> <li>Integraci\u00f3n con Java EE y Spring: Hibernate se puede integrar con entornos de desarrollo empresarial como Java EE y marcos de desarrollo como Spring.</li> </ol> <p>Es importante destacar que Hibernate no es el \u00fanico proveedor de JPA disponible. Otros proveedores, como EclipseLink y Apache OpenJPA, tambi\u00e9n implementan la especificaci\u00f3n JPA y proporcionan funcionalidades similares. La elecci\u00f3n de un proveedor espec\u00edfico depende de los requisitos del proyecto y las preferencias del desarrollador. Hibernate es popular debido a su amplia comunidad de usuarios, su amplia adopci\u00f3n y su rico conjunto de caracter\u00edsticas.</p>"},{"location":"bloque_iv/tema_16/page-8/#arquitectura-hibernate","title":"Arquitectura Hibernate","text":"<p>Hibernate parte de la filosof\u00eda de mapear objetos Java (POJO). Para almacenar y recuperar estos objetos de la base de datos, el desarrollador debe mantener una conversaci\u00f3n con el motor de Hibernate mediante un objeto especial que es la sesi\u00f3n (equiparable al concepto de conexi\u00f3n de JDBC). Igual que con las conexiones JDBC, las sesiones se deben crear y cerrar.</p> <p> Figura 6 - Arquitectura hibernate</p> <p>La clase <code>Session</code> pertenece al paquete <code>org.hibernate.Session</code> y ofrece m\u00e9todos como <code>save(Object object)</code>, <code>createQuery(String sql)</code>, <code>beginTransaction()</code>, <code>close()</code>, etc, para interactuar con la base de datos.</p> <p>Por ejemplo, podemos insertar un objeto con <code>save(Object o)</code> sin necesidad de especificar una sentencia SQL. Una instancia de <code>Session</code> no consume mucha memoria y su creaci\u00f3n y destrucci\u00f3n es muy eficiente, lo que es muy importante ya que podemos crear y destruir sesiones todo el tiempo, quiz\u00e1s en cada petici\u00f3n.</p> <p>Las interfaces de hibernate son las siguientes:</p> <ul> <li>La interfaz <code>SessionFactory</code> permite obtener instancias <code>Session</code>. Esta interfaz debe compartirse entre muchos hilos de ejecuci\u00f3n. Por regla general hay una \u00fanica <code>SessionFactory</code> para toda la aplicaci\u00f3n, creada durante la inicializaci\u00f3n de la misma, y se utilizar para crear todas las sesiones relacionadas con un contexto dado. Si la aplicaci\u00f3n accede a varias bases de datos se necesitar\u00e1 una <code>SessionFactory</code> por cada base de datos.</li> <li>La interfaz <code>Configuration</code> se utiliza para configurar Hibernate. La aplicaci\u00f3n la utiliza para especificar la ubicaci\u00f3n de los documentos que indican el mapeado de los objetos y propiedades especificas de Hibernate, y a continuaci\u00f3n crea la <code>SessionFactory</code>.</li> <li>La interfaz <code>Query</code> permite realizar consultar a la base de datos y controla c\u00f3mo se ejecutan dichas consultas. Las consultas se escriben en HQL o en el dialecto SQL nativo de la base de datos que estemos utilizando. Una instancia de esta interfaz se utiliza para enlazar los par\u00e1metros de la consulta, limitar el n\u00famero de resultados devueltos y para ejecutar dicha consulta.</li> <li> <p>La interfaz <code>Transaction</code> nos permite asegurar que cualquier error que ocurra entre el inicio y el final de la transacci\u00f3n produzca el fallo de la misma.</p> <p> <pre><code>flowchart\n    cfg[\"Configuration\n    Configuration cfg = new Configuration().configure();\"]\n    factory[\"SessionFactory\n    SessionFactory sessionFactory = cfg.buildSessionFactory();\"]\n    db[(Database)]\n    session1[\"Session\n    Session session = sessionFactory.openSession();\"]\n    session2[\"Session\n    Session session = sessionFactory.openSession();\"]\n\n    subgraph one\n    trans1[\"Transaction\n    Transaction tx = session.beginTransaction\"]\n    subgraph two LR\n    save1[\"save\"]\n    load1[\"load\"]\n    delete1[\"delete\"]\n    get1[\"get\"]\n    update1[\"update\"]\n    end\n    subgraph three LR \n    commit1[\"tx.commit();\"]\n    rollback1[\"tx.rollback();\"]\n    end\n    close1[\"session.close();\"]\n    end\n\n    subgraph four\n    trans1[\"**Transaction**\n    Transaction tx = session.beginTransaction\"]\n    subgraph five LR\n    save2[\"save\"]\n    load2[\"load\"]\n    delete2[\"delete\"]\n    get2[\"get\"]\n    update2[\"update\"]\n    end\n    subgraph six LR \n    commit2[\"tx.commit();\"]\n    rollback2[\"tx.rollback();\"]\n    end\n    close2[\"session.close();\"]\n    end\n\n    cfg --&gt; factory\n    factory --&gt; session1\n    factory --&gt; session2\n    factory --&gt; db\n    session1 --&gt; one\n    session2 --&gt; four</code></pre> Figura 7 - Aplicaci\u00f3n con Hibernate </p> </li> </ul>"},{"location":"bloque_iv/tema_16/page-8/#configuracion","title":"Configuraci\u00f3n","text":"<p>El fichero de configuraci\u00f3n de Hibernate es un archivo XML que contiene una serie de elemento que indican sus propiedad, como el protocolo a seguir, y los datos de conexi\u00f3n.</p> <p>El fichero de configuraci\u00f3n debe ir en la ra\u00edz del proyecto o en la carpeta resources si se usa un gestor de proyectos. El nombre del fichero debe ser hibernate.cfg.xml</p> <pre><code>&lt;hibernate-configuration&gt;\n    &lt;session-factory name=\"MyConnection\"&gt;\n        &lt;property name=\"hibernate.connection.drive_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.password\"&gt;&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost/horario&lt;/property&gt;\n        &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;\n    &lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;\n</code></pre> <p>En el ejemplo anterior vemos como tenemos una factor\u00eda de sesi\u00f3n llama MyConnection con las propiedades pertinentes para una conexi\u00f3n a la base de datos horario.</p> <p>Este archivo de configuraci\u00f3n servir\u00e1 como sustituto del archivo de configuraci\u00f3n de la JPA est\u00e1ndar (persistence.xml).</p> <p>Para poder indicar el mapeo de una entidad, se usar\u00e1 la etiqueta <code>&lt;mapping&gt;</code>. Se utilizar\u00e1 junto el atributo <code>class</code> cuando el mapeo de una entidad viene determinado por una clase, mientras que con el atributo <code>resource</code> se indicar\u00e1 el archivo ORM que define el mapeo.</p> <pre><code>&lt;mapping class=\"com.package.CLASS\"/&gt;\n\n&lt;mapping resource=\"url/to/ORM.xml\"/&gt;\n</code></pre> <p>Importante</p> <p>Las clases que funcione como entidades deben implementar la interfaz <code>Serializable</code>. Adem\u00e1s se recomiendan los est\u00e1ndares de renombrado de JavaBean.</p>"},{"location":"bloque_iv/tema_16/page-8/#archivos-de-mapeo","title":"Archivos de mapeo","text":"<p>A la hora de realizar el mapeo de una entidad a trav\u00e9s de anotaciones, no es necesario realizar ning\u00fan cambio, ya que Hibernate usa las anotaciones del paquete de JPA. Mientras que si queremos mapear una entidad a trav\u00e9s un archivo XML, podemos usar la nomenclatura est\u00e1ndar ed la JPA o una espec\u00edfica para Hibernate (recomendado).</p> <p>Un ejemplo de una configuraci\u00f3n espec\u00edfica es:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n&lt;hibernate-mapping&gt;\n  &lt;class name=\"ejemplo01.Profesor\" table=\"Profesor\" &gt;\n    &lt;id column=\"Id\" name=\"id\" type=\"integer\"&gt;\n        &lt;generator class=\"identity\"/&gt;\n    &lt;/id&gt;\n    &lt;property name=\"nombre\" /&gt;\n    &lt;property name=\"ape1\" /&gt;\n    &lt;property name=\"ape2\" /&gt;\n  &lt;/class&gt;\n&lt;/hibernate-mapping&gt;\n</code></pre> <p>De este ejemplo podemos destacar las siguientes etiqueta:</p> <ul> <li><code>class</code>: indica la clase que hace de entidad. Con el atributo <code>name</code> indicamos la ruta de paquetes del fichero Java y con el atributo <code>table</code> indica el nombre de la tabla de la base de datos con la que est\u00e1 relacionada.</li> <li><code>id</code>: indica el atributo de la clase que act\u00faa como primary key. Con el atributo <code>column</code> indicamos el nombre de la columna de la base de datos a la que hace referencia, y con el atributo <code>name</code> el nombre del atributo de la clase. Adem\u00e1s con <code>type</code> podemos indicar el tipo de dato.</li> <li><code>property</code>: indica los atributos de las clases. Tambi\u00e9n tiene el atributo <code>access</code> al igual que en los archivos ORM est\u00e1ndar pero en esta ocasi\u00f3n se usa por defecto el valor property</li> <li><code>generator</code>: indica la forma en la que se va a generar la clave primaria. Los valores posibles son:<ul> <li>increment: genera identificadores.</li> <li>identity: admite columnas de identidad de DB2, MySQL, MS SQL Server, Sybase y HypersonicSQL.</li> <li>sequence: usa una secuencia en DB2, PostgreSQL, Oracle, SAP DB, McKoi o un generador en Interbase.</li> </ul> </li> </ul> <p>Info</p> <p>Para m\u00e1s informaci\u00f3n de las etiquetas y de los atributos visite: http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd</p> <p>Para las relaciones tenemos las siguientes etiquetas:</p> <ul> <li><code>many-to-one</code>: indica una relaci\u00f3n de muchos a uno. Algunos de sus atributos m\u00e1s comunes son: <code>name</code>, <code>column</code>, <code>class</code>.</li> <li><code>one-to-one</code>: indica una relaci\u00f3n de uno a uno.</li> <li><code>join</code>: mapea las propiedades de una clase a varias tablas que tengan relaci\u00f3n uno-a-uno.</li> </ul> <p>Para poder indicar una relaci\u00f3n <code>many-to-many</code> hacemos uso de las etiquetas <code>set</code>, <code>list</code> o <code>map</code>. Los atributos m\u00e1s comunes son:</p> <ul> <li><code>name</code>: indica el nombre del atributo de la clase que representa la lista.</li> <li><code>table</code>: indica el nombre de la tabla que representa la relaci\u00f3n. Por ejemplo, si tenemos una tabla product y otra customer, la tabla que representa la relaci\u00f3n puede ser cart.</li> </ul> <p>Dentro de estas etiquetas podemos encontrar otras como:</p> <ul> <li><code>key</code>: indica la clave de la relaci\u00f3n, normalmente representa a la clave primaria de la entidad. En su interior se debe usar la etiqueta <code>column</code> para indicar a que columna hace referencia.</li> <li><code>many-to-many</code>: indica la otra clase identidad que debe mapear, si la relaci\u00f3n es many to many.</li> <li><code>one-to-many</code>: indica la clase a la que hace referencia, pero en esta ocasi\u00f3n la relaci\u00f3n es one to many.</li> </ul> <p>Este ejemplo trata dos entidad, Stock y StockDailyRecord, cuya relaci\u00f3n es de uno a muchos. La clase Stock representa el stock de un producto, mientras que StockDailyRecord representa los cambios de stock diarios:</p> StockStockDailyRecord <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;\n&lt;hibernate-mapping&gt;\n    &lt;class name=\"com.example.stock.Stock\" table=\"stock\" catalog=\"example_db\"&gt;\n        &lt;id name=\"stockId\" type=\"java.lang.Integer\"&gt;\n            &lt;column name=\"STOCK_ID\" /&gt;\n            &lt;generator class=\"identity\" /&gt;\n        &lt;/id&gt;\n        &lt;property name=\"stockCode\" type=\"string\"&gt;\n            &lt;column name=\"STOCK_CODE\" length=\"10\" not-null=\"true\" unique=\"true\" /&gt;\n        &lt;/property&gt;\n        &lt;property name=\"stockName\" type=\"string\"&gt;\n            &lt;column name=\"STOCK_NAME\" length=\"20\" not-null=\"true\" unique=\"true\" /&gt;\n        &lt;/property&gt;\n        &lt;set name=\"stockDailyRecords\" table=\"stock_daily_record\"\n    inverse=\"true\" lazy=\"true\" fetch=\"select\"&gt;\n            &lt;key&gt;\n                &lt;column name=\"STOCK_ID\" not-null=\"true\" /&gt;\n            &lt;/key&gt;\n            &lt;one-to-many class=\"com.example.stock.StockDailyRecord\" /&gt;\n        &lt;/set&gt;\n    &lt;/class&gt;\n&lt;/hibernate-mapping&gt;\n</code></pre> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;\n&lt;hibernate-mapping&gt;\n    &lt;class name=\"com.example.stock.StockDailyRecord\" table=\"stock_daily_record\" \n  catalog=\"example_db\"&gt;\n        &lt;id name=\"recordId\" type=\"java.lang.Integer\"&gt;\n            &lt;column name=\"RECORD_ID\" /&gt;\n            &lt;generator class=\"identity\" /&gt;\n        &lt;/id&gt;\n        &lt;many-to-one name=\"stock\" class=\"com.example.stock.Stock\" fetch=\"select\"&gt;\n            &lt;column name=\"STOCK_ID\" not-null=\"true\" /&gt;\n        &lt;/many-to-one&gt;\n        &lt;property name=\"priceOpen\" type=\"java.lang.Float\"&gt;\n            &lt;column name=\"PRICE_OPEN\" precision=\"6\" /&gt;\n        &lt;/property&gt;\n        &lt;property name=\"priceClose\" type=\"java.lang.Float\"&gt;\n            &lt;column name=\"PRICE_CLOSE\" precision=\"6\" /&gt;\n        &lt;/property&gt;\n        &lt;property name=\"priceChange\" type=\"java.lang.Float\"&gt;\n            &lt;column name=\"PRICE_CHANGE\" precision=\"6\" /&gt;\n        &lt;/property&gt;\n        &lt;property name=\"volume\" type=\"java.lang.Long\"&gt;\n            &lt;column name=\"VOLUME\" /&gt;\n        &lt;/property&gt;\n        &lt;property name=\"date\" type=\"date\"&gt;\n            &lt;column name=\"DATE\" length=\"10\" not-null=\"true\" unique=\"true\" /&gt;\n        &lt;/property&gt;\n    &lt;/class&gt;\n&lt;/hibernate-mapping&gt;\n</code></pre>"},{"location":"bloque_iv/tema_16/page-8/#sessions-y-objetos-hibernate","title":"Sessions y objetos hibernate","text":"<p>Para trabajar con hibernate se recomienda tener una clase que se encargue de crear una <code>SessionFactory</code>, se recomienda hacerlo con un patr\u00f3n Singleton:</p> <pre><code>public class HibernateUtil{\n    private static final SessionFactory sessionFactory = buildSessionFactory();\n\n    private static SessionFactory buildSessionFactory(){\n        try{\n            Configuration configuration = new Configuration().configure()\n            return configuration.buildSessionFactory(new StandardServiceRegistryBuilder().configure().build());\n        } catch (Throwable ex){\n            System.err.println(\"Initial SessionFactory creation failed.\" + ex);\n            throw new ExceptionInInitializerError(ex);\n        }\n    }\n\n    public static SessionFactory getSessionFactory(){\n        return sessionFactory;\n    }\n}\n</code></pre> <p>Para poder obtener la sesi\u00f3n actual, ser\u00e1 necesario cargar el fichero de configuraci\u00f3n hibernate.cfg.xml. Para ello se llama a <code>new Configuration().configure()</code>, y de esta forma se inicializa el entorno de Hibernate. Se necesita crear un objeto <code>StandardServiceRegistry</code>que contiene una lista de servicios que utiliza Hibernate para crear el <code>SessionFactory</code>.</p>"},{"location":"bloque_iv/tema_16/page-8/#transacciones","title":"Transacciones","text":"<p>Un objeto <code>Session</code> de Hibernate representa una \u00fanica unidad de trabajo para un almac\u00e9n de datos dado y lo abre un ejemplar de <code>SessionFactory</code> (<code>openSession()</code>). Al crear la sesi\u00f3n se crea la transacci\u00f3n para dicha sesi\u00f3n (<code>close()</code>). Se deben cerrar las sesiones cuando se haya completado todo el trabajo de una transacci\u00f3n:</p> <pre><code>// Obtener la sesi\u00f3n\nSessionFactory factory = HibernateUtil.getSessionFactory();\n// Crear la sesi\u00f3n\nSession session = factory.openSession();\n// Crear transacci\u00f3n\nTransaction tx = session.beginTransaction();\n\n// Operaciones\n\ntx.commit();\nsession.close(); // Se cierra la sesi\u00f3n\n</code></pre> <p>El m\u00e9todo <code>beginTransaction()</code> marca el comienzo de una transacci\u00f3n y el m\u00e9todo <code>commit</code>valida una transacci\u00f3n. Mientras que el m\u00e9todo, <code>rollback()</code> deshace la transacci\u00f3n.</p>"},{"location":"bloque_iv/tema_16/page-8/#estados-de-un-objeto-hibernate","title":"Estados de un objeto Hibernate","text":"<p>Hibernate define y soporta los siguientes estados de objeto:</p> <ul> <li> <p>Transitorio (Transient): Un objeto es transitorio si ha sido reci\u00e9n instanciando utilizando el operador new, y no est\u00e1 asociado a una sesi\u00f3n de Hibernate- No tiene una representaci\u00f3n persistente en la base de datos y no se le ha asignado un valor identificador. Las instancias transitorias ser\u00e1n destruidas por el recolector de basura si la aplicaci\u00f3n no mantiene m\u00e1s de una referencia. Utiliza la sesi\u00f3n de Hibernate para hacer un objeto persistente y deja que Hibernate se ocupe de las declaraciones SQL que necesitan ejecutarse para esta transici\u00f3n. Las instancias reci\u00e9n instanciadas de una clase persistente, Hibernate las considera como transitorias. Podemos hacer una instancia transitoria persistente asoci\u00e1ndola con una sesi\u00f3n.</p> <pre><code>Department dep = new Department();\ndep.setDeptNo((byte) 60);\ndep.setDName(\"MARKETING\");\ndep.setLoc(\"GUADALAJARA\");\nsession.save(dep); // (1)!\n</code></pre> <ol> <li><code>save()</code> hace que la instancia sea persistente</li> </ol> </li> <li> <p>Persistente (Persistent). Un objeto estar\u00e1 en este estado cuando ya est\u00e1 almacenado en la base de datos. Puede haber sido guardado o cargado, sin embargo, por definici\u00f3n, se encuentra en el \u00e1mbito de una sesi\u00f3n. Hibernate detectar\u00e1 cualquier cambio realizado a un objeto en estado persistente y sincronizar\u00e1 el estado con la base de datos cuando se complete la unidad de trabajo. En definitiva, los objetos transitorios solo existen en memoria y no en un almac\u00e9n de datos, han ido instanciados por el desarrollador sin haberlos almacenado mediante una sesi\u00f3n. Los persistentes se caracterizan por haber sido ya creados y almacenados en una sesi\u00f3n o bien devueltos en una consulta realizada con la sesi\u00f3n.</p> </li> <li>Separado (Detached). Un objeto est\u00e1 en este estado cuando cerramos la sesi\u00f3n mediante el m\u00e9todo <code>close()</code>. Una instancia separada es un objeto que se ha hecho persistente, pero su sesi\u00f3n ha sido cerrada. La referencia al objeto todav\u00eda es v\u00e1lida, por supuesto, y la instancia separada podr\u00eda incluso ser modificada en este estado. Una instancia separada puede ser asociada a una nueva sesi\u00f3n m\u00e1s tarde, haci\u00e9ndola persistente de nuevo (con todas las modificaciones).</li> </ul>"},{"location":"bloque_iv/tema_16/page-8/#carga-de-objetos","title":"Carga de objetos","text":"<p>Para cargar objetos usaremos lo siguientes m\u00e9todos de la clase <code>Session</code>:</p> M\u00e9todo Descripci\u00f3n <code>&lt;T&gt; T load(Class&lt;T&gt; clase, Serializable id)</code> Devuelve la instancia persistente de la clase indicada con el identificador dado. La instancia tiene que existir, si no existe el m\u00e9todo lanza una excepci\u00f3n <code>ObjectNotFound</code>. <code>Object load(String className, Serializable id)</code> Similar al m\u00e9todo anterior, pero en este caso indicamos en el primer par\u00e1metro el nombre de la case en formato <code>String</code>. <code>&lt;T&gt; T get(Class&lt;T&gt; class, Serializable id)</code> Devuelve la instancia persistente de la clase indicada con el identificador dado. Si la instancia no existe, devuelve null. <code>Object get(String className, Serializable id)</code> Similar al m\u00e9todo anterior, pero en este caso indicamos en el primer par\u00e1metro el nombre de la clase <p>Si queremos obtener un objeto y que se lance una clase en caso de que no exista, se usar\u00eda el m\u00e9todo <code>load()</code>:</p> <pre><code>try{\n    Department dep = (Department) session.load(Department.class, (byte) 20);\n    // ...\n} class (ObjectNotFoundException o){\n    // ...\n}\n</code></pre> <p>Por el contrario, si no queremos que lance una excepci\u00f3n usaremos el m\u00e9todo <code>get()</code>:</p> <pre><code>Department dep = (Department) session.get(Department.class, (byte) 11);\n\nif(dep == null){\n    System.out.println(\"No existe el departamento con id \" + 11);\n} else {\n    //...\n}\n</code></pre>"},{"location":"bloque_iv/tema_16/page-8/#operaciones-basicas-de-objetos","title":"Operaciones b\u00e1sicas de objetos","text":"<p>Para almacenamiento, modificaci\u00f3n y borrado de objetos usamos los siguiente m\u00e9todos:</p> M\u00e9todos Descripci\u00f3n <code>Serializable persist(Object o)</code> Guarda el objeto que se pasa como argumento en la base de datos. Hace que la instancia transitoria del objeto sea persistente. <code>void merge(Object o)</code> Actualiza en la base de datos el objeto que se pasa como argumento. El objeto a modificar debe ser cargado con el m\u00e9todo <code>load()</code> o <code>get()</code>. <code>void remove(Object o)</code> Elimina de la base de datos el objeto que se pasa como argumento. El Objeto a eliminar debe ser cargado con el m\u00e9todo <code>load()</code> o <code>get()</code>. <p>Al insertar un objeto puede producirse una excepci\u00f3n en caso de que se cree un objeto que necesite de otro, como Inscription necesita un estudiante y un curso (<code>TransientPropertyValueException</code>, al hacer el m\u00e9todo <code>persist()</code>)</p> <p>Adem\u00e1s dichas operaciones puede dar una excepci\u00f3n en caso de que se intente actualizar o eliminar un objeto que no exista en la base de datos, o se intente almacenar un objeto ya existente (<code>ConstraintViolationException</code>). Esta excepci\u00f3n se lanza en el m\u00e9todo <code>commit()</code>.</p> SaveUpdateDelete <pre><code>SessionFactory factory = HibernateUtil.getSessionFactory();\nSession session = factory.openSession();\nTransaction tx = session.beginTransaction();\n\ntry{\n    Department dep = new Department();\n\n    dep.setDeptNo((byte) 70);\n    dep.setDName(\"INFORM\u00c1TICA\");\n    dep.setLoc(\"TOLEDO\");\n\n    session.save(dep);\n    tx.commit();\n} catch(ConstraintViolationException e){\n    //...\n}\nsession.close();\n</code></pre> <pre><code>SessionFactory factory = HibernateUtil.getSessionFactory();\nSession session = factory.openSession();\nTransaction tx = session.beginTransaction();\n\ntry{\n    Employee em = (Employee) session.load(Employee.class, (short) 7369);\n\n    em.setSalary(em.getSalary() + 1000);\n\n    session.update(em);\n    tx.commit();\n} catch(ObjectNotFoundException o){\n    // ...\n} catch(ConstraintViolationException c){\n    // ...\n}\nsession.close();\n</code></pre> <pre><code>SessionFactory factory = HibernateUtil.getSessionFactory();\nSession session = factory.openSession();\nTransaction tx = session.beginTransaction();\n\ntry{\n    Employee em = (Employee) session.load(Employee.class, (short) 7369);\n\n    session.delete(em);\n    tx.commit();\n} catch(ObjectNotFoundException o){\n    // ...\n} catch(ConstraintViolationException c){\n    // ...\n}\n\nsession.close();\n</code></pre>"},{"location":"bloque_iv/tema_16/page-8/#consultas","title":"Consultas","text":"<p>Hibernate soporta un lenguaje de consulta orientado a objetos denominado HQL (Hibernate Query Language) f\u00e1cil de usar pero potente a la vez. Este lenguaje es una extensi\u00f3n orientada a objetos de SQL. Las consultas HQL y SQL nativas son representadas con una instancia de la interfaz <code>Query</code> (del paquete <code>org.hibernate</code>). Esta interfaz ofrece m\u00e9todos para ligar par\u00e1metros, manejo del conjunto resultado, y para la ejecuci\u00f3n de la consulta real. Siempre obtiene una <code>Query</code> utilizando el objeto <code>Session</code> actual.</p> <p>Para crear una query se utilizar\u00eda el m\u00e9todo <code>createQuery(String sql)</code> de la interfaz <code>SharedSessionContract</code> que implementa la <code>Session</code>:</p> <pre><code>Query q = session.createQuery(\"from Department\");\n</code></pre> <p>Algunos m\u00e9todos importantes de esta interfaz son:</p> M\u00e9todo Descripci\u00f3n <code>Iterator iterate()</code> Devuelve en un objeto <code>Iterator</code> el resultado de la consulta. <code>List list()</code> Devuelve el resultado de la consulta en un <code>List</code> <code>Query setFetchSize(int size)</code> Fija el n\u00famero de resultados a recuperar en cada acceso a la base de datos al valor indicado en size. <code>int executeUpdate()</code> Ejecuta la sentencia de modificaci\u00f3n o borrado. Devuelve el n\u00famero de entidades afectadas <code>String getQueryString()</code> Devuelva la consulta en un String <code>Object uniqueResult()</code> Devuelve un objeto (cuando sabemos que la consulta devuelve un objeto) o nulo si la consulta no devuelve resultados <code>Query setCharacter(int position, char value)</code><code>Query setCharacter(String name, char value)</code> Asigna el value indicado en el m\u00e9todo a un par\u00e1metro de tipo char.position indica la posici\u00f3n del par\u00e1metro dentro de la consulta, empieza en 0.name es el nombre (se indica <code>:name</code>) del par\u00e1metro dentro de la consulta <code>Query setDate(int position, Date value)</code><code>Query setDate(String name, Date value)</code> Asigna un value a un par\u00e1metro de tipo <code>Date</code>. <code>Query setDouble(int position, double value)</code><code>Query setDouble(String name, double value)</code> Asigna value a un par\u00e1metro de tipo decimal. <code>Query setInteger(int position, int value)</code><code>Query setInteger(String name, int value)</code> Asigna value a uin par\u00e1metro de tipo entero <code>Query setString(int position, String value)</code><code>Query setString(String name, String value)</code> Asigna un value a un par\u00e1metro de tipo <code>VARCHAR</code> <code>Query setParameterList(String name, Collection values)</code> Asigna una colecci\u00f3n de valores al par\u00e1metro cuyo nombre se indica en name <code>Query setParameter(String name, Object value)</code> Asigna un valor al par\u00e1metro indicado en name <p>Consulta la API de Hibernate</p> <p>https://docs.jboss.org/hibernate/orm/current/javadocs/</p>"},{"location":"bloque_iv/tema_16/page-8/#hql","title":"HQL","text":"<p>Hibernate Query Language (HQL) es un lenguaje bastante similar a SQL, pero en lugar de tablas se trata de clases y en lugar de columnas se trata de propiedades o atributos de una clase.</p> <p>Las consultas HQL son consultas independientes de la base de datos porque las consultas HQL se convierten internamente en consultas SQL espec\u00edficas de la base de datos utilizando la clase <code>Dialect</code> mencionada en el archivo hibernate-cfg.xml.</p> <p>Usar este lenguaje puede tener las siguientes ventajas:</p> <ol> <li>Independiente de la base de datos</li> <li>F\u00e1cil de aprender para el programador Java</li> <li>HQL soporta totalmente las consultas polim\u00f3rficas. Es decir, junto con el objeto que se devuelve como resultado de una consulta, se devolver\u00e1n todos los objetos secundarios (objetos de subclases) del objeto dado. Se tiene todo el modelo.</li> </ol> <p>Las siguientes clausulas a usar en HQL son:</p> Clausula Ejemplo Descripci\u00f3n FROM <code>FROM Employee</code> Devuelve el objeto completo que representa la clase AS <code>FROM Employee AS E</code> Indica un alias para acceder de forma sencilla a las propiedades de la clase (se puede omitir e indicar directamente el alias) SELECT <code>SELECT e.firstName FROM Employee as e</code> Devuelve las propiedades de la clase espec\u00edficas del objeto WHERE <code>FROM Employee AS E WHERE E.firstName like 'A%'</code> Indica una condici\u00f3n para filtrar el conjunto de objetos. ORDER BY <code>FROM Person P WHERE P.id &gt; 10 ORDER  BY P.salary DESC</code> Se indica para ordenar la consulta. Puede ir seguido de <code>ASC</code> si se desea un orden ascendente (se puede omitir ya que es el valor por defecto) o <code>DESC</code> si, por el contrario, se quiere un orden descendente GROUP BY <code>SELECT SUM(P.salary), P.firstName FROM Person P GROUP BY P.firstName</code> Se usa para agrupar los datos de una consulta. Normalmente se usa para a\u00f1adir un valor agregado. INSERT <code>INSERT INTO Employee (Salary, Loc) VALUES (1000, 'C\u00e1diz')</code> Crea objetos de una entidad UPDATE <code>UPDATE Employee E SET E.salary = E.salary * 1000 WHERE E.ID = 10</code> Actualiza los objetos DELETE <code>DELETE Employee E WHERE E.ID = 10</code> Elimina objetos <p>Se puede utilizar diferentes entidades separadas por coma <code>,</code> lo que producir\u00e1 un cross join: <code>from Department d, Employee e</code>.</p> <p>Las funciones de agregaci\u00f3n, que normalmente van con la clausula <code>GROUP BY</code>, son:</p> <ul> <li>COUNT: Se utiliza para contar el n\u00famero de objetos resultantes: <code>SELECT COUNT(*) FROM Employee E GROUP BY E.Loc</code>.</li> <li>SUM: Suma los valores de una propiedad espec\u00edfica: <code>SELECT SUM(E.salary) FROM Employee E GROUP BY E.Loc</code>.</li> <li>AVG: Calcula el valor promedio de una columna espec\u00edfica: <code>SELECT AVG(E.salary) FROM Employee E GROUP BY E.Loc</code>.</li> <li>MIN/MAX: Encuentra el valor m\u00ednimo/m\u00e1ximo: <code>SELECT MIN(E.salary) FROM Employee E</code>.</li> <li>COALESCE: Comprueba si el primer valor indicado es null, en caso de serlo, comprueba el segundo valor, y s\u00ed este lo es, devuelve el siguiente, as\u00ed sucesivamente. Por ejemplo, en la expresi\u00f3n <code>coalesce(e.salary, null, 0)</code>, comprueba si salary es null, si no lo es devuelve su valor, y en caso de serlo comprueba el siguiente valor, que si es null, comprueba el siguiente valor, hasta encontrar uno de no es null, como en este caso, que si salary es null, devolver\u00e1 0, ya que el segundo argumento es null.</li> </ul> <p>HQL tambi\u00e9n admite las consultas <code>JOIN</code> con las clausulas <code>INNER JOIN</code>, <code>LEFT JOIN</code>, <code>RIGHT JOIN</code>, <code>FETCH JOIN</code>, etc.</p> <p>En el siguiente ejemplo se va a recorrer a todos los empleados que tengan un salario mayor al indicado como par\u00e1metro:</p> <pre><code>String hql = \"FROM Employee e where e.salary &gt; :salary\";\nQuery&lt;Employee&gt; = session.createQuery(hql, Employee.class);\nquery.setInteger(\"salary\", 1000);\nList&lt;Employee&gt; = query.list();\n</code></pre>"},{"location":"bloque_iv/tema_16/page-8/#consultas-con-parametros","title":"Consultas con par\u00e1metros","text":"<p>Hibernate soporta par\u00e1metros con nombres y par\u00e1metros de estilo JDBC (<code>?</code>) en las consultas HQL. Los par\u00e1metros son enumerados desde 0, es decir, el primer par\u00e1metro que aparece estar\u00e1 en la posici\u00f3n 0, el siguiente en el 1, as\u00ed sucesivamente. El uso de par\u00e1metros nombrados tiene una serie de ventajas:</p> <ul> <li>son insensibles al orden en que aparecen en la cadena de consulta.</li> <li>pueden aparecer m\u00faltiples veces en la misma petici\u00f3n.</li> <li>son autodocumentados.</li> </ul> <p>Para asignar valores a los par\u00e1metros se utilizan los m\u00e9todos <code>setXXX</code>, vistos en la anterior tabla., siendo <code>setParameter()</code> la sintaxis simple.</p> <pre><code>String hql = \"from Employees emp where emp.department.deptNo = ? and emp.oficio = ?\";\n\nQuery q = session.createQuery(hql);\nq.setParameter(0, (byte) 10);\nq.setParameter(1, \"Director\");\n</code></pre> <p>El ejemplo anterior se puede hacer con par\u00e1metros nombrados y con sus m\u00e9todos espec\u00edficos para cada dato:</p> <pre><code>String hql = \"from Employees emp where emp.department.deptNo = :ndep and emp.oficio = :ofi\";\n\nQuery q = session.createQuery(hql);\nq.setInteger('ndep', (byte) 10);\nq.setString('ofi', \"Director\");\n</code></pre> <p>Incluso podemos pasarle una lista de par\u00e1metros:</p> <pre><code>List&lt;Byte&gt; numbers = new ArrayList&lt;&gt;();\nnumbers.add((byte) 20);\nnumbers.add((byte) 20);\n\nString hql = \"from Employees emp where emp.department.deptNo in (:listaDep) order by emp.department.deptNo\";\n\nQuery q = session.createQuery(hql);\nq.setParameterList(\"listDep\", numbers);\n</code></pre>"},{"location":"bloque_iv/tema_16/page-8/#consultas-sobre-clases-no-asociadas","title":"Consultas sobre clases no asociadas","text":"<p>Si queremos recuperar los datos de una consulta en la que intervienen varias tablas y los atributos no est\u00e1n asociados a ninguna clase podemos utilizar la clase object. Los resultados se reciben en un array de objetos, donde el primer elemento del array se corresponde con la primera clase que ponemos a la derecha de FROM, el siguiente elemento con la siguiente clase, y as\u00ed sucesivamente.</p> <pre><code>String hql = \"from Employee e, Department d where e.department.deptNo = d.deptNo order by apellido\"\n\nQuery q = session.createQuery(sql);\nIterator iterate = q.iterate();\nObject[] par;\nEmployee employee;\nDepartment department;\n\nwhile(q.hasNext()){\n    par = (Object[]) iterate.next();\n    employee = (Employee) par[0];\n    department = (Department) par[1];\n    // ...\n}\n</code></pre> <p>Supongamos, ahora, que se desea obtener el nombre de departamento, su n\u00famero de empleados y el salario medio. Como los datos de esta consulta no est\u00e1n asociados a ninguna clase, se puede crear una y utilizarla sin la necesidad de mapearla.</p> TOTALESMain <pre><code>public class Totales{\n    private Long nEmployees;\n    private Byte nDepartment;\n    private Double avgSalary;\n    private String departmentName;\n\n    // Constructores y getter y setters\n}\n</code></pre> <pre><code>String hql = \"select new package.Totales(\" \n+ \" d.deptNo, count(e.empNo), coalasce(ave(e.salario), 0)), d.nombre) \"\n+ \" from Employees as e right join e.departments as d \"\n+ \" group by d.deptNo, d.nombre\";\n\nQuery q = session.createQuery(hql);\nIterator i = q.iterate();\nTotales t;\n\nwhile(t.hasNext()){\n    t = (Totales) q.next();\n    System.out.println(t);\n}\n</code></pre>"},{"location":"bloque_iv/tema_16/page-8/#records","title":"Records","text":"<p>En Hibernate, no es posible utilizar records como clases de identidad, ya que es necesario tener los m\u00e9todos setters para la modificaci\u00f3n de la informaci\u00f3n que obtenemos de la base de datos. Sin embargo, a trav\u00e9s del lenguaje JPQL o HPL, podemos obtener una consulta y envolverla en una clase record.</p> <pre><code>TypedQuery&lt;BookWithAuthorNamesRecord&gt; q = \n        em.createQuery(\n                \"SELECT new org.thoughts.on.java.model.BookWithAuthorNamesRecord(\"\n                        + \"b.id, b.title, b.price, concat(a.firstName, ' ', a.lastName)) \"\n                + \" FROM Book b JOIN b.author a \"\n                + \" WHERE b.title LIKE :title\",\n                BookWithAuthorNamesRecord.class);\nq.setParameter(\"title\", \"%Hibernate Tips%\");\nList&lt;BookWithAuthorNamesRecord&gt; books = q.getResultList();\n</code></pre> <p>Otra soluci\u00f3n es en la clase de entidad, indicarle que al realizar la consulta, mapee el resultado a la clase record deseada:</p> <pre><code>@SqlResultSetMapping(\n        name = \"BookWithAuthorNamesRecordMapping\",\n        classes = @ConstructorResult(\n                targetClass = BookWithAuthorNamesRecord.class,\n                columns = { @ColumnResult(name = \"id\", type = Long.class), \n                            @ColumnResult(name = \"title\"), \n                            @ColumnResult(name = \"price\"), \n                            @ColumnResult(name = \"authorName\")}))\n</code></pre>"},{"location":"bloque_iv/tema_16/page-8/#proyecto-students-con-hibernate","title":"Proyecto Students con Hibernate","text":"<p>Vamos ahora a modificar nuestro proyecto Students para a\u00f1adirle todo lo aprendido. En primer lugar, eliminamos el persistence.xml y a\u00f1adimos un fichero hibernate.cfg.xml:</p> <pre><code>&lt;!DOCTYPE hibernate-configuration PUBLIC\n        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n        \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;\n&lt;hibernate-configuration&gt;\n    &lt;session-factory name=\"\"&gt;\n        &lt;property name=\"hibernate.connection.drive_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.password\"&gt;&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost/students&lt;/property&gt;\n        &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;\n\n        &lt;mapping resource=\"orm/Course.xml\"/&gt;\n        &lt;mapping resource=\"orm/Inscription.xml\"/&gt;\n        &lt;mapping resource=\"orm/Student.xml\"/&gt;\n    &lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;\n</code></pre> <p>Luego creamos los ficheros xml de mapeo (en caso de usar anotaciones, no se deben modificar):</p> COURSESTUDENTINSCRIPTION <pre><code>&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;\n&lt;hibernate-mapping&gt;\n    &lt;class name=\"com.irudev.data.entity.Course\" table=\"course\"&gt;\n        &lt;id name=\"id\" type=\"java.lang.Integer\"&gt;\n            &lt;column name=\"id\"/&gt;\n            &lt;generator class=\"identity\"/&gt;\n        &lt;/id&gt;\n        &lt;property name=\"name\" type=\"string\"&gt;\n            &lt;column name=\"name\"/&gt;\n        &lt;/property&gt;\n        &lt;property name=\"credits\" type=\"int\"&gt;\n            &lt;column name=\"credits\"/&gt;\n        &lt;/property&gt;\n    &lt;/class&gt;\n&lt;/hibernate-mapping&gt;\n</code></pre> <pre><code>&lt;!-- estudiante.orm.xml --&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;\n&lt;hibernate-mapping&gt;\n    &lt;class name=\"com.irudev.data.entity.Student\" table=\"student\"&gt;\n        &lt;id name=\"id\" type=\"java.lang.Integer\"&gt;\n            &lt;column name=\"id\"/&gt;\n            &lt;generator class=\"identity\"/&gt;\n        &lt;/id&gt;\n        &lt;property name=\"name\" type=\"string\"&gt;\n            &lt;column name=\"name\" /&gt;\n        &lt;/property&gt;\n        &lt;property name=\"age\" type=\"int\"&gt;\n            &lt;column name=\"age\"/&gt;\n        &lt;/property&gt;\n    &lt;/class&gt;\n&lt;/hibernate-mapping&gt;\n</code></pre> <pre><code>&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;\n&lt;hibernate-mapping&gt;\n    &lt;class name=\"com.irudev.data.entity.Inscription\" table=\"inscription\"&gt;\n        &lt;id name=\"id\" type=\"java.lang.Long\"&gt;\n            &lt;column name=\"id\"/&gt;\n            &lt;generator class=\"identity\"/&gt;\n        &lt;/id&gt;\n        &lt;many-to-one name=\"student\" class=\"com.irudev.data.entity.Student\"&gt;\n            &lt;column name=\"idStudent\"/&gt;\n        &lt;/many-to-one&gt;\n        &lt;many-to-one name=\"course\" class=\"com.irudev.data.entity.Course\"&gt;\n            &lt;column name=\"idCourse\"/&gt;\n        &lt;/many-to-one&gt;\n    &lt;/class&gt;\n&lt;/hibernate-mapping&gt;\n</code></pre> <p>A\u00f1adimos nuestro Singleton que controle nuestro acceso a las sesiones de Hibernate:</p> <pre><code>public class HibernateUtil {\n    private static HibernateUtil instance;\n    private SessionFactory factory;\n    private Session session;\n\n    private HibernateUtil(){}\n\n    private void buildSessionFactory(){\n        Configuration configuration = new Configuration().configure();\n        StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure().build();\n        factory = configuration.buildSessionFactory(registry);\n    }\n\n    private void openSession(){\n        if(factory == null){\n            buildSessionFactory();\n        }\n\n        if(session == null || !session.isOpen()){\n            session = factory.openSession();\n        }\n    }\n\n    public void closeSession(){\n        if(session != null){\n            session.close();\n        }\n\n        if(factory != null){\n            factory.close();\n        }\n    }\n\n    public Session getCurrentSession(){\n        if(session == null){\n            openSession();\n        }\n\n        return session;\n    }\n\n    public static HibernateUtil getInstance(){\n        if(instance == null){\n            instance = new HibernateUtil();\n        }\n\n        return instance;\n    }\n}\n</code></pre> <p>Por \u00faltimo, modificamos nuestros modelos:</p> COURSESTUDENTINSCRIPTION <pre><code>public class JDBCCourseRepository implements CourseRepository {\n    private final HibernateUtil manager;\n\n    public JDBCCourseRepository(HibernateUtil manager) {\n        this.manager = manager;\n    }\n\n    @Override\n    public Course getById(Integer id) {\n        return manager.getCurrentSession().get(Course.class, id);\n    }\n\n    @Override\n    public List&lt;Course&gt; getAll() {\n        return manager.getCurrentSession().createQuery(\"from Course c\", Course.class).list();\n    }\n\n\n    @Override\n    public boolean save(Course course) {\n        try{\n            Transaction tx = manager.getCurrentSession().beginTransaction();\n            manager.getCurrentSession().persist(course);\n            tx.commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n\n    @Override\n    public boolean update(Course course) {\n        try{\n            Transaction tx = manager.getCurrentSession().beginTransaction();\n            manager.getCurrentSession().merge(course);\n            tx.commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n\n    @Override\n    public boolean delete(Course course) {\n        try{\n            Transaction tx = manager.getCurrentSession().beginTransaction();\n            manager.getCurrentSession().remove(course);\n            tx.commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n}\n</code></pre> <pre><code>public class JDBCStudentRepository implements StudentRepository {\n\n    private final HibernateUtil manager;\n\n    public JDBCStudentRepository(HibernateUtil manager){\n        this.manager = manager;\n    }\n\n    @Override\n    public Student getById(Integer id) {\n        return manager.getCurrentSession().get(Student.class, id);\n    }\n\n    @Override\n    public List&lt;Student&gt; getAll() {\n        return manager.getCurrentSession().createQuery(\"from Student s\", Student.class).list();\n    }\n\n    @Override\n    public boolean save(Student student) {\n        try{\n            Transaction tx = manager.getCurrentSession().beginTransaction();\n            manager.getCurrentSession().persist(student);\n            tx.commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n\n    @Override\n    public boolean update(Student student) {\n        try{\n            Transaction tx = manager.getCurrentSession().beginTransaction();\n            manager.getCurrentSession().merge(student);\n            tx.commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n\n    @Override\n    public boolean delete(Student student) {\n        try{\n            Transaction tx = manager.getCurrentSession().beginTransaction();\n            manager.getCurrentSession().remove(student);\n            tx.commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n}\n</code></pre> <pre><code>public class JDBCInscriptionRepository implements InscriptionRepository {\n    private final HibernateUtil manager;\n\n    public JDBCInscriptionRepository(HibernateUtil manager) {\n        this.manager = manager;\n    }\n\n    @Override\n    public Inscription getById(Integer id) {\n        return manager.getCurrentSession().get(Inscription.class, id);\n    }\n\n    @Override\n    public List&lt;Inscription&gt; getAll() {\n        return manager.getCurrentSession().createQuery(\"from Inscription i\", Inscription.class).list();\n\n    }\n\n    @Override\n    public boolean save(Inscription inscription) {\n        try{\n            Transaction tx = manager.getCurrentSession().beginTransaction();\n            manager.getCurrentSession().persist(inscription);\n            tx.commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n\n\n    @Override\n    public boolean delete(Inscription inscription) {\n        try{\n            Transaction tx = manager.getCurrentSession().beginTransaction();\n            manager.getCurrentSession().remove(inscription);\n            tx.commit();\n            return true;\n        }catch (Exception e){\n            return false;\n        }\n    }\n}\n</code></pre>"},{"location":"bloque_iv/tema_16/page-9/","title":"Ejercicios","text":"<p>Dado el siguiente diagrama relacional de la base de datos, realiza los siguientes ejercicios:</p> <p> Figura 7 - Modelo Relacional</p> Ejercicio 1 <p>Crea el diagrama UML, y las clases en Java que representas las entidades anteriores, teniendo que el identificador de cada clase ser\u00e1 generado por UUID.</p> <p>Esta ser\u00e1 la versi\u00f3n inicial del proyecto.</p> Ejercicio 2 <p>Haciendo uso del patr\u00f3n Repository y JDBC donde le permita al usuario realizar un CRUD de cada una de las entidades realizadas anteriormente. Esta ser\u00e1 la primera versi\u00f3n del proyecto. </p> <p>A\u00f1ade los m\u00e9todos necesarios para trabajar con cada uno de las entidades para poder realizar las siguientes operaciones:</p> <ul> <li>Se puede insertar actores, g\u00e9neros y pel\u00edculas.</li> <li>Se puede eliminar pel\u00edculas y g\u00e9neros.</li> <li>Se puede localizar actores, g\u00e9neros y pel\u00edculas dado su id.</li> <li>Se puede obtener todos los registros de cada una de las entidades.</li> <li>Se puede obtener una lista de g\u00e9neros dado su nombre.</li> <li>Se puede obtener una lista de actores que hayan nacido despu\u00e9s     de una cierta fecha.</li> <li>Se puede obtener una lista de actores cuyo apellido termina con un valor espec\u00edfico.</li> <li>Se puede obtener una lista de pel\u00edculas por su nombre.</li> <li></li> </ul> Ejercicio 3 <p>En la segunda versi\u00f3n del proyecto, modifica lo necesario para usar JPA con archivos de mapeo.</p> <p>En esta versi\u00f3n del proyecto, y en las posteriores, el proveedor de JPA debe encargarse de la creaci\u00f3n de la base de datos.</p> Ejercicio 4 <p>En la tercera versi\u00f3n del proyecto, modifica lo necesario para hacer uso del framework hibernate, manteniendo los archivos de mapeo.</p> Ejercicio 5 <p>En la cuarta versi\u00f3n del proyecto, modifica lo necesario para usar anotaciones en lugar de un fichero de mapeo.</p>"},{"location":"bloque_iv/tema_17/page-1/","title":"1 Base de datos objeto relacional","text":""},{"location":"bloque_iv/tema_17/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La base de datos objeto-relacional es una extensi\u00f3n de la base de datos relacional tradicional, a la cual se le proporcionan caracter\u00edsticas de la programaci\u00f3n orientada a objetos (POO).</p> <p>La principal caracter\u00edstica de estas bases de datos es que el usuario puede crear sus propios tipos de datos y los m\u00e9todos necesarios para trabajar con dichos tipos de datos.  Son bases de datos que han evolucionado desde el modelo relacional incorporando conceptos del paradigma orientado a objetos.</p>"},{"location":"bloque_iv/tema_17/page-1/#tipos-de-objetos","title":"Tipos de objetos","text":"<p>En las bases de datos orientadas a objetos podemos encontrar los siguientes tipos at\u00f3micos:</p> <ul> <li>Boolean: un valor booleano es aquel que puede tomar uno de los siguientes valores: verdadero o falso.</li> <li>Short: entero con signo, normalmente de 8 o 16 bits.</li> <li>Long: entero con signo, normalmente de 32 o 64 bits.</li> <li>Unsigned short: entero sin signo, normalmente de 8 o 16 bits.</li> <li>Unsigned long: entero sin signo, normalmente de 32 o 64 bits.</li> <li>Float: valor real en coma flotante de simple precisi\u00f3n.</li> <li>Double: valor real en coma flotante de doble precisi\u00f3n.</li> <li>Octet: almac\u00e9n de 8 bits.</li> <li>Char: car\u00e1cter ASCII o UNICODE.</li> <li>String: cadena de caracteres.</li> <li>Enum: tipo enumerado donde los valores se especifican expl\u00edcitamente cuando se declara el tipo.</li> </ul> <p>Tambi\u00e9n podemos encontrar colecciones, como las siguientes:</p> <ul> <li>Set y bag: grupo desordenado de objetos del mismo tipo. La diferencia est\u00e1 en que set no permite duplicados y bag s\u00ed.</li> <li>List: grupo ordenado de objetos del mismo tipo.</li> <li>Array: grupo ordenado de objetos del mismo tipo. Se puede acceder a ellos mediante su posici\u00f3n.</li> </ul> <p>Adem\u00e1s, tenemos tipos de datos que siguen un estructura:</p> <ul> <li>Date: para las fechas.</li> <li>Time: para las horas.</li> <li>Timestamp: hora de una fecha.</li> <li>Interval: periodos de tiempo.</li> </ul>"},{"location":"bloque_iv/tema_17/page-1/#postgresql","title":"PostgreSQL","text":"<p>PostgreSQL es un sistema de gesti\u00f3n de bases de datos relacional libre que destaca por agilizar la interacci\u00f3n de cliente, servidor y base de datos, ya que realiza la mayor\u00eda del trabajo referente a bases de datos cuando se hacen las peticiones.</p> <p>Una de las caracter\u00edsticas que tiene este gestor de bases de datos es SGBDOR (Sistema de Gesti\u00f3n de Base de Datos Orientado a Objetos), por lo que incluye los mecanismos de una base de datos orientada a objetos.</p> <p>Info</p> <p>Para saber m\u00e1s sobre PostgreSQL orientado a objetos, visita la gu\u00eda: INSERT_LINK</p>"},{"location":"bloque_iv/tema_17/page-2/","title":"2 Base de datos orientadas a objetos","text":""},{"location":"bloque_iv/tema_17/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Una base de datos orientada a objetos es un sistema de gesti\u00f3n de base de datos mediante el cual representamos la informaci\u00f3n en forma de objetos que son utilizados en programaci\u00f3n orientada a objetos.</p> <p>La investigaci\u00f3n y el desarrollo de la base de datos orientada a objetos fue impulsada en gran medida por su alto rendimiento en almacenamiento de datos y los requerimientos de acceso que ten\u00edan entornos de soporte de dise\u00f1o tales como el CAD (Computer Aided Design) y el CASE (Computer Aided Software Engineering).</p> <p>A medida que ha ido aumentando el uso de la tecnolog\u00eda web, muchas organizaciones se muestran m\u00e1s interesadas en el concepto de base de datos orientada a objetos, dado que es \u00fatil para mostrar los datos complejos de estas tecnolog\u00edas.</p> <p>Algunas bases de datos orientadas a objetos han sido dise\u00f1adas para trabajar bien con lenguajes de programaci\u00f3n orientados a objetos tales como Delphi, Ruby, Python, Perl, Java, Visual Basic.NET, etc.</p> <p>A partir de 2004, la base de datos orientada a objetos ha vuelto a experimentar un crecimiento debido al surgimiento de bases de datos orientadas a objetos de c\u00f3digo abierto. Son f\u00e1ciles de usar y asequibles. Est\u00e1n totalmente escritas en lenguaje de programaci\u00f3n orientado a objetos, como Smalltalk, Java o C.  </p>"},{"location":"bloque_iv/tema_17/page-2/#caracteristicas","title":"Caracter\u00edsticas","text":"<p>La base de datos orientada a objetos ha encontrado su nicho de aplicaci\u00f3n en \u00e1reas tales como la ingenier\u00eda, las bases de datos espaciales, las telecomunicaciones y en \u00e1reas cient\u00edficas como la f\u00edsica de alta energ\u00eda y la biolog\u00eda molecular.</p> <p>Otro conjunto de bases de datos orientadas a objetos se centra en el uso integrado en dispositivos, paquetes de software y sistemas en tiempo real.</p> <p>Podemos encontrar las siguientes caracter\u00edsticas:</p> <ul> <li>La mayor\u00eda de bases de datos orientadas a objetos incluyen alg\u00fan tipo de lenguaje para realizar consultas, lo cual permite que los objetos sean encontrados utilizando un enfoque de programaci\u00f3n declarativa.</li> <li>En una base de datos orientada a objetos, el acceso a los datos es m\u00e1s r\u00e1pido debido a que los Joins casi nunca son necesarios, a diferencia de lo que ocurre con las bases de datos relacionales. Esto es as\u00ed porque un objeto puede ser recuperado directamente sin una b\u00fasqueda, simplemente siguiendo los punteros.</li> <li>Un \u00e1rea en la que los diferentes productos pueden variar es la forma en la que el esquema de la base de datos es definido. Sin embargo, una caracter\u00edstica general es que el lenguaje de programaci\u00f3n y el esquema de la base de datos utilizan la misma definici\u00f3n de tipos.</li> <li>Las aplicaciones multimedia se agilizan debido a que los m\u00e9todos de clase asociados con los datos son responsables de una correcta interpretaci\u00f3n.</li> <li>Muchas bases de datos orientadas a objetos ofrecen soporte para control de versiones. Un objeto puede ser visto como un conjunto de todas sus versiones. Tambi\u00e9n las versiones de objetos pueden ser tratadas como objetos por derecho propio. Algunas bases de datos orientadas a objetos tambi\u00e9n proporcionan soporte sistem\u00e1tico para triggers y restricciones.</li> <li>La eficiencia de una base de datos orientada a objetos tambi\u00e9n ha mejorado considerablemente en \u00e1reas en las cuales se requieren cantidades masivas de datos sobre un elemento. Por ejemplo, una entidad bancaria podr\u00eda obtener la informaci\u00f3n de la cuenta de un usuario y proporcionarle eficientemente informaci\u00f3n muy extensa conteniendo todas las transacciones, todas las entradas con informaci\u00f3n de la cuenta, etc.</li> </ul> <p>Una base de datos orientada a objetos almacena datos complejos y relaciones entre datos directamente, sin asignar filas y columnas, y esto hace que sean m\u00e1s adecuadas para aplicaciones que tratan con datos muy complejos. Los objetos tienen relaciones \u201cmuchos a muchos\u201d y son accesibles mediante el uso de punteros. Estos punteros se vinculan a los objetos para establecer relaciones. Otro beneficio adicional de una base de datos orientada a objetos es que puede ser programada con peque\u00f1as diferencias de procedimientos sin afectar a todo el sistema.</p>"},{"location":"bloque_iv/tema_17/page-2/#sql-orientado-a-objetos","title":"SQL orientado a objetos","text":"<p>En 1999 fue desarrollado el lenguaje SQL 3, que ven\u00eda a mejorar las anteriores versiones e incorporar la orientaci\u00f3n a objetos. Por tanto, este lenguaje es considerado como la base de la mayor\u00eda de los SGBD. Como principal caracter\u00edstica se puede destacar la posibilidad de definir tipos de datos:</p> <ul> <li>Grandes Objetos.SQL99 define dos tipos de objetos grandes, el llamado BLOB (Binary Large Object), adecuado para almacenar datos binarios como por ejemplo im\u00e1genes, videos,... y CLOB (Character Large Object), ideal para datos extensivos de tipos texto como por ejemplo informes, p\u00e1ginas web...</li> <li>Colecciones: Permite almacenar de forma directa colecciones enteras de datos tanto de tipo b\u00e1sico como de tipo estructurado.</li> <li>Tipos compuestos o estructurados: Gracias a la incorporaci\u00f3n de estos tipos de datos es posible crear tipo de datos definidos por el usuario.</li> <li>Referencia a tipos estructurados: Se trata de un tipo especial que act\u00faa como apuntador de tipos compuestos.</li> </ul> <p>La manipulaci\u00f3n de estos tipos de datos no se realiza volc\u00e1ndolas a tipos de datos est\u00e1ndares, sino que se utilizan unas clases especiales (<code>java.sql.Blob</code>, <code>java.sql.Clob</code> o j<code>ava.sql.Array</code>) que act\u00faan como punteros l\u00f3gicos a la informaci\u00f3n deseada a la base de datos.</p>"},{"location":"bloque_iv/tema_17/page-2/#caracteristica-de-base-de-datos-orientada-a-objeto","title":"Caracter\u00edstica de base de datos orientada a objeto","text":"<p>En una base de datos orientada a objetos, la informaci\u00f3n se representa mediante objetos como los presentes en la programaci\u00f3n orientada a objetos. Un ODBMS hace que los objetos de la base de datos aparezcan como objetos de un lenguaje de programaci\u00f3n en uno o m\u00e1s lenguajes de programaci\u00f3n a los que d\u00e9 soporte.</p> <p>La iniciativa ODMG (Object Database Management Group) proporciona est\u00e1ndares sobre base de datos orientada a objetos, y define:</p> <ul> <li>Un modelo de objetos est\u00e1ndar para el dise\u00f1o de estas BBDD.</li> <li>El lenguaje de definici\u00f3n de objetos u ODL (Object Definition Language).</li> <li>Lenguaje de consultas denominado OQL.</li> </ul>"},{"location":"bloque_iv/tema_17/page-2/#sgbdoo","title":"SGBDOO","text":"<p>Un sistema de gesti\u00f3n de base de datos orientado a objeto es un software que se utiliza para poder trabajar con bases de datos orientadas a objetos. Entre las m\u00e1s destacadas tenemos:</p> <ul> <li>ObjectStore: es una soluci\u00f3n para C++ y Java</li> <li>wakanda y ObjectDB: soluci\u00f3n para Javascript.</li> <li>ObjectDB: soluci\u00f3n para Java.</li> </ul>"},{"location":"bloque_iv/tema_17/page-3/","title":"3 ObjectDB","text":""},{"location":"bloque_iv/tema_17/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>ObjectDB es un administrador de sistemas de base de datos orientada a objetos (ODBMS), de software propietario, pero que ofrece una versi\u00f3n gratuita limitada para su estudio.</p> <p>Una de las ventajas de este sistema es que ofrece JPA como interfaz para el programador y dispone de un entorno gr\u00e1fico para consultar y actualizar los datos. Este entorno gr\u00e1fico, admite la realizaci\u00f3n de consultas con JPQL.</p>"},{"location":"bloque_iv/tema_17/page-3/#proyecto-objectdb","title":"Proyecto ObjectDB","text":"<p>Para comenzar, configuramos el <code>pom.xml</code> de la siguiente manera:</p> <pre><code>&lt;!-- ... --&gt;\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;objectdb&lt;/id&gt;\n            &lt;name&gt;ObjectDB Repository&lt;/name&gt;\n            &lt;url&gt;https://m2.objectdb.com&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.objectdb&lt;/groupId&gt;\n            &lt;artifactId&gt;objectdb&lt;/artifactId&gt;\n            &lt;version&gt;2.8.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.persistence&lt;/artifactId&gt;\n            &lt;version&gt;2.1.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.transaction&lt;/groupId&gt;\n            &lt;artifactId&gt;jta&lt;/artifactId&gt;\n            &lt;version&gt;1.1&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;!-- ... --&gt;\n</code></pre> <p>Creamos nuestra clase POJO:</p> <pre><code>@Entity\npublic class Point implements Serializable {\n    @Id @GeneratedValue\n    private long id;\n\n    private int x;\n    private int y;\n\n    public Point(){}\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    @Override\n    public String toString() {\n        return \"Point{\" +\n                \"id=\" + id +\n                \", x=\" + x +\n                \", y=\" + y +\n                '}';\n    }\n}\n</code></pre> <p>Y nuestro <code>main</code>:</p> <pre><code>public class Main {\n    public void show() {\n        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"p2.odb\");\n        EntityManager em = emf.createEntityManager();\n\n        // Guardar punto\n        em.getTransaction().begin();\n        em.persist(new Point(10, 10));\n        em.getTransaction().commit();\n\n        // Query\n        Query q = em.createQuery(\"SELECT p FROM Point p\", Point.class);\n        System.out.println(q.getResultList());\n    }\n\n    public static void main(String[] args) {\n        new Main().show();\n    }\n}\n</code></pre> <p>Como se puede observar no ha sido necesario crear un archivo de configuraci\u00f3n persistence.xml, ya que no necesito decirle al proveedor la relaci\u00f3n de clases. \u00danicamente indico el fichero <code>odb</code> donde se almacenar\u00e1 los datos.</p>"},{"location":"bloque_iv/tema_18/page-1/","title":"1 Introducci\u00f3n a las bases de datos NoSQL","text":""},{"location":"bloque_iv/tema_18/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Las bases de datos NoSQL son aquellas que no siguen el modelo cl\u00e1sico del sistema de gesti\u00f3n de bases de datos relacionales. Su principal caracter\u00edsticas es que no usan SQL como lenguaje principal de consultas, y adem\u00e1s, en el almacenamiento de los datos no se utilizan estructuras fijas de almacenamiento.</p> <p>El t\u00e9rmino NoSQL surge con la llegada de la web 2.0, ya que hasta ese momento solo sub\u00edan contenidos a la red aquellas empresas que ten\u00edan un portal, pero con la llegada de las diferentes RRSS (Facebook, Twitter, Youtube, etc), en las que el usuario pod\u00eda subir su propio contenido, se produjo as\u00ed un crecimiento exponencial de los datos.</p>"},{"location":"bloque_iv/tema_18/page-1/#soluciones-propuestas","title":"Soluciones propuestas","text":"<p>Esto provocaba problemas para gestionar y acceder a toda esa informaci\u00f3n que se encuentra almacenada en bases de datos relacionales. Las empresas propusieron solucionar dichos problemas con el incremento de m\u00e1quinas, sin embargo, era una soluci\u00f3n cara y no terminaba con el problema.</p> <p>Otra soluci\u00f3n propuesta fue la de crear nuevos sistemas gestores de datos pensados para un uso espec\u00edfico, que con el paso del tiempo han dado lugar a soluciones robustas, apareciendo as\u00ed el movimiento NoSQL.</p> <p>As\u00ed pues, hablar de NoSQL es hablar de estructuras que nos permiten almacenar informaci\u00f3n en aquellas situaciones en las que las bases de datos relacionales generan ciertos problemas.</p>"},{"location":"bloque_iv/tema_18/page-1/#sql-vs-nosql","title":"SQL vs NoSQL","text":"<p>Las bases de datos relacionales focalizan su inter\u00e9s en la fiabilidad de las transacciones bajo el conocido principio ACID (Atomicity, Consistency, Isolation and Durability, Atomicidad, Consistencia, Aislamiento y Durabilidad en espa\u00f1ol).</p> PRINCIPIO ACID - Bases de datos relacionales Atomicity Asegurar de que la transacci\u00f3n se complete o no, sin quedarse a medias ante fallos. Consistency Asegurar el estado de validez de los datos en todo momento. Isolation Asegurar independencia entre transacciones Durability Asegurar la persistencia de la transacci\u00f3n ante cualquier fallo <p>Este principio aporta una robustez y colisiona el rendimiento con la operatividad a medida que los vol\u00famenes de datos crecen.</p> <p>Cuando la magnitud y el dinamismo de los datos cobran importancia, el principio ACID de los modelos relacionales quedan en segundo plano frente al rendimiento, disponibilidad y escalabilidad, las caracter\u00edsticas m\u00e1s propias de las bases de datos NoSQL. Hoy en d\u00eda, los modernos sistemas de datos en internet se ajustan m\u00e1s al tambi\u00e9n conocido principio BASE (Basic Availability, Soft State, Eventually consistency, Disponibilidad como prioridad, la consistencia de datos se delega a gesti\u00f3n externa al motor de la base de datos, intentar lograr la convergencia hacia un estado consistente).</p> PRINCIPIO BASE - Bases de datos NoSQL Basic Availability Prioridad de la disponibilidad de los datos Soft state Se prioriza la propagaci\u00f3n de datos, delegando el control de inconsistencias a elementos externos Eventually consistency Se asume que inconsistencias temporales progresen a un estado final estable"},{"location":"bloque_iv/tema_18/page-1/#ventajas-de-los-sistemas-nosql","title":"Ventajas de los sistemas NoSQL","text":"<p>La gran diferencia de estas bases de datos es c\u00f3mo almacenan los datos. Por ejemplo, en una base del modelo relacional para almacenar una factura, se utilizar\u00edan 4 tablas, cada una con 3 o 4 ajenas, mientras que en NoSQL solo se guarda la factura, por ejemplo, con una clave y el objeto factura.</p> <p>La forma de almacenamiento de informaci\u00f3n en este tipo de bases de datos ofrece ciertas ventajas sobre los modelos relacionales:</p> <ul> <li>Se ejecutan en m\u00e1quinas con pocos recursos: estos sistemas no requieren mucha programaci\u00f3n, por lo que se pueden instalar en m\u00e1quinas de un coste m\u00e1s reducido.</li> <li>Escalabilidad horizontal: para mejorar el rendimiento de estos sistemas simplemente se consigue a\u00f1adiendo m\u00e1s nodos, con la \u00fanica operaci\u00f3n de indicar al sistema cu\u00e1les son los nodos que est\u00e1n disponibles.</li> <li>Pueden manejar gran cantidad de datos: esto es debido a que utiliza una estructura distribuida, en muchos casos mediante tablas Hash.</li> <li>No genera cuellos de botella: el principal problema de los sistemas SQL es que necesitan transcribir cada sentencia para poder ser ejecutada, y cada sentencia compleja requiere, adem\u00e1s, de un nivel de ejecuci\u00f3n a\u00fan m\u00e1s complejos, lo que constituye un punto de entrada en com\u00fan, que ante muchas peticiones puede ralentizar el sistema.</li> </ul>"},{"location":"bloque_iv/tema_18/page-1/#diferencias-con-las-bases-de-datos-sql","title":"Diferencias con las bases de datos SQL","text":"<p>Las diferencias m\u00e1s importantes entre los sistemas NoSQL y los sistemas SQL son:</p> <ul> <li>No utilizan SQL como lenguaje de consultas</li> <li>No utilizan las estructuras filas como tablas para el almacenamiento de los datos. Permiten hacer uso de otros tipos de modelos de almacenamiento de informaci\u00f3n como sistemas clave-valor, objetos o grafos.</li> <li>No suelen permitir operaciones JOIN. Al disponer un volumen de datos tan extremadamente grande suele resultar deseable evitar los JOIN. Esto se debe a que , cuando la operaci\u00f3n no es la b\u00fasqueda de una clave, la sobrecarga puede ser costosa. Las soluciones m\u00e1s directas consisten en desnormalizar los datos, o bien, realizar el JOIN mediante software en la capa de aplicaci\u00f3n.</li> <li>Arquitectura distribuida. Las bases de datos relacionales suelen estar centralizadas en una \u00fanica m\u00e1quina o bien en una estructura m\u00e1ster-esclavo, sin embargo en los casos NoSQL la informaci\u00f3n puede estar compartida en varias m\u00e1quinas mediante mecanismos de tablas Hash distribuidas.</li> </ul>"},{"location":"bloque_iv/tema_18/page-1/#tipos-de-bases-de-datos-nosql","title":"Tipos de bases de datos NoSQL","text":"<p>Seg\u00fan el tipo o modelo escogido para almacenar los datos, las bases de datos NoSQL se agrupan en cuatro categor\u00edas principales:</p> <ul> <li>Clave/Valor. Los datos son almacenados y se localizan e identifican usando una clave \u00fanica y un valor.</li> <li>Columnas. Parecido al modelo clave/valor, pero la clave se basa en una combinaci\u00f3n de columna, fila y marca de tiempo que se utiliza para referenciar conjuntos de columnas. Es una implementaci\u00f3n bastante similar al modelo relacional.</li> <li>Documentos. Los datos se almacenan en documentos que encapsulan la informaci\u00f3n en formato XML, YAML o JSON. Los documentos tienen nombres de campos auto contenidos en el propio documento. La informaci\u00f3n se indexa utilizando esos nombres de campos. Este tipo de implementaci\u00f3n permite, adem\u00e1s de realizar b\u00fasquedas por clave-valor, realizar consultas m\u00e1s avanzadas sobre el contenido del documento.</li> <li>Grafos. Se sigue un modelo de grafos que se extiende entre m\u00faltiples m\u00e1quinas. En este tipo de bases de datos, la informaci\u00f3n se representa como nodos de un grafo y sus relaciones con las artistas del mismo, de manera que se puede hacer uso de la teor\u00eda de los grafos para recorrerla. Es un modelo apropiado para datos cuyas relaciones se ajustan a este modelo, como, por ejemplo, redes de transporte, mapas, etc.</li> </ul>"},{"location":"bloque_iv/tema_18/page-2/","title":"2 Introducci\u00f3n a MongoDB","text":""},{"location":"bloque_iv/tema_18/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>MongoDB es un sistema de base de datos multiplataforma orientado a documentos, se podr\u00e1 almacenar cualquier tipo de contenido sin obedecer a un modelo o esquema. Est\u00e1 escrito en C++, por lo que es bastante r\u00e1pido. Es un software de licencia libre que funciona en sistemas operativos como Windows, Linux, OS X y Solaris.</p> <p>Una de las caracter\u00edsticas principales es la velocidad y la sencilla forma que tiene para hacer consultas a los contenidos. MongoDB se utiliza para cualquier aplicaci\u00f3n que necesite almacenar datos semi-estructurados, caso de aplicaciones CMS, aplicaciones m\u00f3viles, de juegos, o plataformas e-commerce.</p> <p>MongoDB no soporta JOINS ni transacciones, aunque posee \u00edndices secundarios, un propio lenguaje de consulta muy expresivo, operaciones at\u00f3micas en un solo documento, y lecturas consistentes.</p>"},{"location":"bloque_iv/tema_18/page-2/#diferencia-con-el-modelo-relacional","title":"Diferencia con el modelo relacional","text":"<p>La mayor diferencia entre las bases de datos relacionales y MongoDB es la forma en que se crea el modelo de datos, el modelo relacional es un modelo r\u00edgido y estructurado mientras que el modelo MongoDB es un modelo din\u00e1mico.</p> Modelo Relacional MongoDB Base da datos Base de datos Tabla Colecci\u00f3n Fila Documento Columna Campo \u00cdndice \u00cdndice Join Documento embebido o referencia <p>Con el modelo MongoDB se pasa de un modelo de datos r\u00edgido basado en estructuras bidimensionales, formado por tablas, filas y columnas a un modelo de datos de documentos rico y din\u00e1mico con sub-documentos y matrices embebidas. En MongoDB se pueden crear colecciones sin definir su estructura, tambi\u00e9n se puede alterar la estructura de los documentos simplemente a\u00f1adiendo nuevos campos o borrando los ya existentes. Esta caracter\u00edsticas convierte a Mongo en una BD muy flexible con respecto a las alternativas relacionales.</p> <p>MongoDB almacena documentos JSON en una representaci\u00f3n binaria llamada BSON. BSON es una serializaci\u00f3n codificada en binario de documentos JSON, soporta todas las caracter\u00edsticas JSON e incluye los tipos de datos int, long, float o arrays. El documento representa la unidad b\u00e1sica de datos en MongoDB.</p>"},{"location":"bloque_iv/tema_18/page-2/#instalacion","title":"Instalaci\u00f3n","text":"<p>Para la instalaci\u00f3n de MongDB sigue las instrucciones de esta p\u00e1gina https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/</p> <p>O si lo prefieres, puedes usar la versi\u00f3n en la nube MongoDB Atlas</p>"},{"location":"bloque_iv/tema_18/page-3/","title":"3 Operaciones B\u00e1sicas en MongoDB","text":""},{"location":"bloque_iv/tema_18/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Todos los comandos para operar con esta base de datos se escriben en min\u00fasculas, lo m\u00e1s comunes son:</p> <ul> <li>show databases. Listar base de datos.</li> <li>db. Mostrar la base de datos actual.</li> <li>show collections. Mostrar las colecciones de la base de datos actual.</li> <li>use [data name]. Usa una base de datos. Si no existe no importa, porque se crear\u00e1 en el momento que se a\u00f1ada un objeto JSON. use my_data_base</li> <li>count, size, length. Devuelve el n\u00ba de documentos de loas colecciones. db.my_coleccion.count()</li> </ul> <p>\u00a1Cuidado!</p> <p>El m\u00e9todo count est\u00e1 actualmente deprecated, sus alternativas son:</p> <ul> <li><code>db.collection.countDocuments()</code></li> <li><code>db.collection.estimatedDocumentCount()</code></li> </ul> <ul> <li>Para a\u00f1adir comentarios utilizamos los caracteres // de comentario de Java.</li> </ul> <p>Veamos un ejemplo, creamos una base de datos llamada my_first_database</p> <pre><code>use my_first_database\n</code></pre> <p>Listamos las bases de datos para comprar que se ha creado:</p> <pre><code>show databases\n</code></pre> <p>Como puedes comprobar a\u00fan no aparece en la lista, esto se debe porque hasta que no tengamos unos datos no se crea de forma oficial.</p> <p>A continuaci\u00f3n, comprobamos el nombre de la base de datos actual.</p> <pre><code>db\n</code></pre>"},{"location":"bloque_iv/tema_18/page-3/#crear-registros","title":"Crear Registros","text":"<p>M\u00e9todos deprecated</p> <p>En versiones anteriores de MongoDB se usaban los m\u00e9todos save() e insert() para crear registros, actualmente dichos m\u00e9todos est\u00e1n deprecated.</p> <p>Los m\u00e9todos para insertar registros son:</p> <ul> <li><code>db.collection.insertOne()</code>. Para insertar un valor</li> <li><code>db.collection.insertMany()</code>. Para insertar varios valores</li> <li><code>db.collection.bulkWrite()</code>. Toma un array y lo inserta.</li> <li><code>db.collection.updateOne()</code>. Actualiza un \u00fanico elemento.</li> <li><code>db.collection.updateMany().</code> Actualiza varios elementos.</li> <li><code>db.collection.findOneAndUpdate()</code>. Localiza un elemento y luego lo actualiza.</li> </ul>"},{"location":"bloque_iv/tema_18/page-3/#identificador-de-objetos","title":"Identificador de Objetos","text":"<p>Los identificadores de cada registro son \u00fanicos. Se asignan autom\u00e1ticamente al crear el documento, se generan de forma r\u00e1pida y ordenada. Tambi\u00e9n se pueden crear de forma manual. Es un n\u00famero hexadecimal que consta de 12 bytes, los 4 primeros son una marca de tiempo, los 3 siguientes la identificaci\u00f3n de la m\u00e1quina, 2 bytes de identificador de proceso y un contador de 3 bytes empezando en un n\u00famero aleatorio. El ObjectId o _id, es como si fuese la clave del documento, no se repetir\u00e1 en una colecci\u00f3n. Si un documento no tiene _id MongoDB se lo asignar\u00e1 autom\u00e1ticamente, es lo que ocurre cuando insertamos y no indicamos el identificador.</p> <p> Figura 1 - ObjectId</p> <p>Que el ObjectId est\u00e9 compuesto de esa manera, nos da algunas funcionalidades muy \u00fatiles. La primera es que nos puede dar una indicaci\u00f3n de el orden de creaci\u00f3n de los documentos. No es algo del todo fiable si estamos tratando con documentos creados en el mismo margen de tiempo, pero s\u00ed en tramos de tiempo m\u00e1s largos.</p> <p>Tambi\u00e9n nos sirve para obtener la fecha de creaci\u00f3n del documento.</p> <p>Vamos a crear un amigo:</p> <pre><code>friend1 = {name: 'Ana', phone: 658963145, curso: '2DAM', nota: 7.5}\n</code></pre> <p>Insertamos a dicho amigo:</p> <pre><code>db.friends.insertOne(friend1);\n</code></pre> <p>Importante</p> <p>No hemos creado la colecci\u00f3n friends pero al usar uno de los m\u00e9todos de creaci\u00f3n se crea en caso de que no exista.</p> <p>Ahora, volvemos a listar las bases de datos:</p> <pre><code>show databases\n</code></pre> <p>Ahora, en la lista, si aparece la base de datos que hemos creado al principio.</p> <p>Ahora, insertamos usuarios con insertMany:</p> <pre><code>db.friends.insertMany([\n    {name: 'Lucas', phone: 722589636, curso: '1DAM', nota: 6.9},\n    {name: 'Luc\u00eda', phone: 733256985, curso: '2DAM', nota: 7.0}\n]);\n</code></pre>"},{"location":"bloque_iv/tema_18/page-3/#consultar-registros","title":"Consultar registros","text":"<p>Para consultar todos los elementos de una colecci\u00f3n utilizaremos la orden find(). De esta forma se mostrar\u00e1n los identificativos (_id) de cada objeto JSON, \u00fanicos de cada colecci\u00f3n, y el resto de campos.</p> <p>Si queremos mostrar la salida ordenada por alg\u00fan campo, se usa junto con find() el m\u00e9todo sort({campo: X}), siendo campo el nombre del campo por el que quieres ordenar y X siendo 1, si quieres que se de forma ascendente, o -1, descendente.</p> <p>Si se desean hacer b\u00fasquedas de documentos que cumplan una o varias condiciones, utilizamos el siguiente formato: <code>db.collection.find(filtro, campo)</code></p> <ul> <li>En filtro indicamos la condici\u00f3n de b\u00fasqueda, podemos a\u00f1adir los pares nombre:valor a buscar. Si omitimos este, o pasa un documento vac\u00edo (<code>{}</code>) par\u00e1metro devuelve todos los documentos.</li> <li>En campos se especifican los campos a devolver de los documentos que coinciden con el filtro de la consulta. Para mostrar todos los campos omitimos este par\u00e1metros. Si se desean devolver uno o m\u00e1s campos escribiremos {campo: 1} o {campo: true}, y si no queremos usamos {campo: 0} o {campo: false}.</li> </ul> <p>Se pueden hacer consultas m\u00e1s complejas a\u00f1adiendo selectores de b\u00fasqueda:</p> <ul> <li>$eq, igual a un valor.</li> <li>\\(gt***, mayor que y ***\\)gte mayor o igual que.</li> <li>$lt, menor que, y lte, menor o igual que.</li> <li>$ne, distinto a un valor.</li> <li>\\(in***, entre una lista de valores y ***\\)nin, no est\u00e1 entre la lista de valores.</li> </ul> <p>Tambi\u00e9n podemos realizar b\u00fasquedas con selectores de b\u00fasquedas l\u00f3gicos:</p> <ul> <li>$or. condici\u00f3n1 O condici\u00f3n2. Devuelve todos los documentos que cumplen una de las dos condiciones.</li> <li>$and. condici\u00f3n1 Y condici\u00f3n2. Devuelve todos los registros que cumplen ambas condiciones. Este operador se maneja de forma impl\u00edcita y no es necesario especificarlo.</li> <li>$not. Representa la negaci\u00f3n.</li> <li>$exists. Permite filtrar la b\u00fasqueda tomando en cuenta la existencia de la expresi\u00f3n.</li> </ul> <p>A continuaci\u00f3n, vamos a listar todos los registros de la colecci\u00f3n:</p> <pre><code>db.friends.find();\n</code></pre> <p>Vamos a mostrar la misma salida anterior, pero ordenada por notas, primero de forma ascendente:</p> <pre><code>db.friends.find().sort({nota: 1});\n</code></pre> <p>Luego, descendente:</p> <pre><code>db.friends.find().sort({nota: -1});\n</code></pre> <p>Ahora, vamos a consultar todos los amigos cuyo curso sea \"2DAM\":</p> <pre><code>db.friends.find({curso: \"2DAM\"});\n</code></pre> <p>Bien, ahora vamos a buscar a los amigos, cuyo curso sea \"2DAM\" y su nombre \"Ana\":</p> <pre><code>db.friends.find({curso: \"2DAM\", name: \"Ana\"});\n</code></pre> <p>Vamos a probar la misma b\u00fasqueda anterior pero solo quiero mostrar la nota:</p> <pre><code>db.friends.find({curso: \"2DAM\", name: \"Ana\"}, {nota: true});\n</code></pre> <p>Ahora vamos a mostrar cu\u00e1ntos amigos pertenecen a \"2DAM\":</p> <pre><code>db.friends.find({curso: \"2DAM\"}).size();\n</code></pre> <p>Vamos a mostrar todos los amigos cuyas notas sean igual a 7:</p> <pre><code>db.friends.find({nota: {$eq: 7}});\n</code></pre> <p>Ahora las que sea de mayor o igual que 7:</p> <pre><code>db.friends.find({nota: {$gte: 7}});\n</code></pre> <p>Ahora todos los amigos que no est\u00e9n en segundos:</p> <pre><code>db.friends.find({curso: {$ne: \"2DAM\"}});\n</code></pre> <p>Mostramos todos los amigos cuyas notas sean 6, 7 u 8. Mostramos solo el nombre:</p> <pre><code>db.friends.find({nota: {$in: {6, 7, 8}}}, {name: true})\n</code></pre> <p>Buscamos todos los amigos que sean de 2DAM o se llamen Lucas:</p> <pre><code>db.friends.find({$or: [ {curso: \"2DAM\"}, {name: \"Lucas\"}]});\n</code></pre> <p>Ahora mostramos todos los amigos que sean de 2DAM y se llamen Ana;</p> <pre><code>db.friends.find({$and: [ {name: \"Ana\"}, {curso: \"2DAM\"}]});\n</code></pre> <p>Esta sentencia tambi\u00e9n se puede escribir as\u00ed:</p> <pre><code>db.friends.find({name: \"Ana\", curso: \"2DAM\"});\n</code></pre> <p>Vamos a insertar un amigo con nota null:</p> <pre><code>db.friends.insertOne({name: \"Rub\u00e9n\", phone: 695362523, curso: \"1DAM\", nota: null});\n</code></pre> <p>Ahora otro, sin nota directamente:</p> <pre><code>db.friends.insertOne({name: \"Selena\", phone: 123456789, curso: \"2DAM\"})\n</code></pre> <p>Mostramos los amigos que tienen nota:</p> <pre><code>db.friends.find({nota: {$exists:true}})\n</code></pre> <p>Ahora, aquellos que no tienen, se pueden hacer de dos formas, con <code>$not</code> o con <code>$exists: false</code></p> <pre><code>db.friends.find({nota: {$exists:false}})\n</code></pre> <pre><code>db.friends.find({nota: {$not: {$exists:true}}});\n</code></pre> <p>Podemos entender que un amigo no tiene nota, cuando est\u00e1 no exista o cuando sea null, entonces vamos a mostrar todos los amigos que realmente tengan nota:</p> <pre><code>db.friends.find( {nota: {$exists:true}, nota: {$ne: null}  } )\n</code></pre>"},{"location":"bloque_iv/tema_18/page-3/#actualizar-registros","title":"Actualizar registros","text":"<p>Para actualizar datos utilizaremos el comando .update, con este formato:</p> <pre><code>db.collection.update(\n filter,\n    changes,\n    {\n     upsert: boolean,\n     multi: boolean\n    }\n)\n</code></pre> <p>En filter, se indica la condici\u00f3n para localizar los registros o documentos a modificar.</p> <p>En changes, se especifican los cambios que se desean hacer. Hay que tener cuidado al utilizar esta orden, ya que cambiar\u00e1 el contenido del documento.</p> <p>\u00a1CUIDADO!</p> <p>Si indicamos solo un campo a modificar y no el resto de campos, el campo indicado se modificar\u00e1 pero los dem\u00e1s SER\u00c1N ELIMINADOS AUTOM\u00c1TICAMENTE.</p> <p>Por ende, nos encontramos con dos tipos de cambios: cambiar el documento completo o modificando solo los campos especificados, para ello utilizamos los par\u00e1metros upsert y multi, ambos son opcionales y su valor por defecto es false.</p> <ul> <li>upsert. Si asignamos true a este par\u00e1metro, se indica que si el filtro de b\u00fasqueda no encuentra ning\u00fan resultado, entonces, el cambio debe ser insertado como un nuevo registro.</li> <li>multi. En caso de que el filtro de b\u00fasqueda devuelva m\u00e1s de un resultado, si lo ponemos a true, el cambio se realizar\u00e1 a todos los resultados, de lo contrario solo se cambiar\u00e1 al primero que encuentre, es decir, al que tenga menor identificativo de objeto, _id.</li> </ul> <p>El comando update cuenta con una serie de operadores para realizar actualizadores m\u00e1s complejas. Algunos de estos operadores son los siguientes:</p> <ul> <li>$set. Permite actualizar con nuevas propiedades a un documento, o conjunto. Si el documento ya tiene ese campo, no lo a\u00f1ade, si no que lo cambia en caso de que sea distinto.</li> <li>$unset. Permite eliminar propiedad de un documento.</li> <li>$inc. Incrementa en una cantidad num\u00e9rica especificada en el valor del campo incrementar</li> <li>$rename. Renombra campos del documento.</li> </ul> <p>Vamos a actualizar los datos de Lucas:</p> <pre><code>db.friends.update({name: \"Lucas\"}, {name: \"Lucas\", phone: 685967412, curso: \"2DAM\"})\n</code></pre> <p>F\u00edjate que el campo de nota de Lucas ha desaparecido.</p> <p>Vamos a actualizar a Sonia cambi\u00e1ndole el tel\u00e9fono a 689234567, como no existe lo crear\u00e1.</p> <pre><code>db.friends.update({name: \"Sonia\"}, {name: \"Sonia\", phone: \"689234567\"}, {upsert: true})\n</code></pre> <p>Vamos a actualizar la edad de Sonia, teniendo en cuenta que es un campo que no existe se debe usar con $set:</p> <pre><code>db.friends.update({name:\"Sonia\"}, { $set: {edad: 24}})\n</code></pre> <p>Vamos a cambiar el curso a Ana y Luc\u00eda, como es una propiedad que ya existe, y es el \u00faltimo campo que se desea cambiar, tambi\u00e9n usaremos $set:</p> <pre><code>db.friends.update({name: \"Ana\"}, { $set: {curso: \"1DAM\"}})\ndb.friends.update({name: \"Luc\u00eda\"}, { $set: {curso: \"1DAM\"}})\n</code></pre> <p>Como podemos observar solo ha cambiado el campo \"curso\" y no el resto de ellos.</p> <p>Ahora, vamos a actualizar al amigo Rub\u00e9n, elimin\u00e1ndole la nota:</p> <pre><code>db.friends.update({name: \"Rub\u00e9n\"}, {$unset: {nota: 7}})\n</code></pre> <p>F\u00edjate, que hemos indicado nota 7, y a pesar que dicho amigo no tiene nota 7 si no null, tambi\u00e9n ser\u00e1 eliminada.</p> <p>Vamos a sumarle uno a la edad de Sonia</p> <pre><code>db.friends.update({name: \"Sonia\"}, {$inc: {edad: 1}})\n</code></pre> <p>Ahora vamos a cambiar el nombre del campo edad de Sonia, y lo ponemos en ingl\u00e9s:</p> <pre><code>db.friends.update({name: \"Sonia\"}, {$rename: {edad: 'age'}})\n</code></pre> <p>Vamos a incrementarle un 1 a todos aquellos amigos que est\u00e9n en el curso 1DAM:</p> <pre><code>db.friends.update({curso: \"1DAM\"}, { $inc: {nota:1}})\n</code></pre> <p>Como podemos observar, solo cambia el primer amigo que encuentra con esa condici\u00f3n, para ello es importante, usar la propiedad multi a true:</p> <pre><code>db.friends.update({curso: \"1DAM\"}, {$inc: {nota: 1}}, {multi: true})\n</code></pre> <p>Ahora si se le ha cambiado a todos, incluso a aquellos amigos que no ten\u00eda el campo nota.</p> <p>Ahora vamos a a\u00f1adirle la poblaci\u00f3n a aquellos alumnos que sean de 2DAM.</p> <pre><code>db.friends.update({curso: \"2DAM\"}, { $set: {poblacion: \"Talavera\"}}, {multi:true})\n</code></pre>"},{"location":"bloque_iv/tema_18/page-3/#operaciones-con-arrays","title":"Operaciones con Arrays","text":"<p>Para consultar un elemento de un campo de tipo array, solo ser\u00e1 necesario escribir el nombre del campo-array y el valor que se desea buscar.</p> <p>Existen tambi\u00e9n operadores de modificaci\u00f3n para los campos que sean arrays:</p> <ul> <li>$push. A\u00f1ade un elemento a un array.</li> <li>$addToSet. Agrega elementos a un array solo s\u00ed estos no existen.</li> <li>***\\(each.*** Se usa en conjunto con *\\)addToSet* o $push para indicar que se a\u00f1aden varios elementos al array.</li> <li>$pop. Elimina el primer o \u00faltimo valor del array. Con valor -1 borra el primero, con otro valor el \u00faltimo.</li> <li>$pull. Elimina los valores de un array que cumplan con el filtro indicado.</li> </ul> <p>Creamos la colecci\u00f3n libro e insertamos tres libros, cada uno de ellos con un campo de tipo array que almacenar\u00e1 los temas del libro:</p> <pre><code>db.books.insertMany(\n    [\n        {code: 1, name: \"Acceso a Datos\", pvp: 35, editorial: \"Garceta\", temas: [\"Base de datos\", \"Hibernate\", \"Neodatis\"]},\n        {code: 2, name: \"Entornos de desarrollo\", pvp: 27, editorial: \"Garceta\", temas: [\"UML\", \"Subversi\u00f3n\", \"ERMaster\"]},\n        {code: 3, name: \"Programaci\u00f3n de Servicios\", pvp: 25, editorial: \"Garceta\", temas: [\"SOCKET\", \"Multihilo\"]}\n   ]\n);\n</code></pre> <p>Consultamos:</p> <ul> <li> <p>Libros que tengan el tema UML:</p> <pre><code>db.books.find({temas: \"UML\"})\n</code></pre> </li> <li> <p>Libros que tengan el tema UML o Neodatis:</p> <pre><code>db.books.find({ $or: [{temas: \"UML\"}, {temas: \"Neodatis\"}]})\n</code></pre> </li> <li> <p>Libros de la editorial Garceta, con pvp mayor que 25 y que tengan el tema UML o Neodatis:</p> <pre><code>db.books.find({ editorial: \"Garceta\", pvp: {$gt: 25}, $or: [{temas: \"UML\"}, {temas: \"Neodatis\"}]})\n</code></pre> </li> </ul> <p>Ahora, vamos a actualizar:</p> <ul> <li> <p>A\u00f1adimos el tema MongoDB al libro que tenga c\u00f3digo 1.</p> <pre><code>db.books.update({codigo: 1}, {$push: {temas: \"MongoDB\"}})\n</code></pre> </li> <li> <p>Vamos a agregar el tema \"Bases de Datos\" a todos los libros que tengan el campo \"temas\":</p> <pre><code>db.books.update({temas: {$exists:true}}, {$addToSet: {temas: \"Bases de Datos\"}}, {multi: true})\n</code></pre> </li> <li> <p>A continuaci\u00f3n a\u00f1adimos al libro de c\u00f3digo 1 los temas \"JSON\" y \"XML\"</p> <pre><code>db.books.update({code:1}, {$push: {temas: {$each: [\"JSON\", \"XML\"]}}})\n</code></pre> </li> <li> <p>Ahora, a\u00f1adimos los temas \"Eclipse\" y \"Developper\" a los libros de c\u00f3digo 2 (usamos $addToSet):</p> <pre><code>db.books.update({code: 2}, {$addToSet: {temas: {$each: [\"Eclipse\", \"Developper\"]}}})\n</code></pre> </li> <li> <p>Ahora eliminamos el primer tema del libro con c\u00f3digo 3:</p> <pre><code>db.books.update({code: 3}, {$pop: {temas: -1}})\n</code></pre> </li> <li> <p>Borramos de todos los libros, los elementos \"Base de Datos y JSON\"</p> <pre><code>db.books.update({}, {$pull: {temas: { $in: [\"Base de datos\", \"JSON\"]}}}, {multi: true})\n</code></pre> </li> </ul>"},{"location":"bloque_iv/tema_18/page-3/#borrar-registros","title":"Borrar registros","text":"<p>Para borrar registros podemos usar las \u00f3rdenes remove o drop. Se puede eliminar documentos que cumplan una condici\u00f3n, o todos los documentos de la colecci\u00f3n o la colecci\u00f3n completa.</p> <ul> <li>Para borrar un documentos o registro que cumpla una condici\u00f3n utilizaremos la orden remove({valor})</li> <li>Para eliminar todos los elementos de la colecci\u00f3n escribimos remove({})</li> <li>Para eliminar una colecci\u00f3n se usa drop()</li> </ul> <p>Eliminamos a Ana:</p> <pre><code>db.friends.remove({name: \"Ana\"})\n</code></pre>"},{"location":"bloque_iv/tema_18/page-4/","title":"4 Agregaci\u00f3n Pipeline","text":""},{"location":"bloque_iv/tema_18/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>La agregaci\u00f3n pipeline o tuber\u00edas de agregaci\u00f3n se basa en someter una colecci\u00f3n a un conjunto de operaciones o etapas, estas etapas ir\u00e1n convirtiendo y transformando el conjunto de documentos pertenecientes a la colecci\u00f3n, hasta obtener un conjunto de documentos con el resultado deseado.</p> <p>Se le llama tuber\u00eda ya que cada etapa ir\u00e1 modificando, moldeando y calculando la estructura de los documentos para pasarlos a la etapa que le sigue.</p>"},{"location":"bloque_iv/tema_18/page-4/#funciones-de-agregado","title":"Funciones de agregado","text":"<p>Al igual que en otra base de datos, MongoDB dispone de funciones matem\u00e1ticas y de cadenas para utilizaras en las consultas.</p>"},{"location":"bloque_iv/tema_18/page-4/#funciones-aritmeticas","title":"Funciones Aritm\u00e9ticas","text":"Funci\u00f3n Descripci\u00f3n $abs Valor absoluto de un n\u00famero $add A\u00f1ade n\u00fameros a una cantidad o a una fecha, en este caso suma milisegundos. $ceil Devuelve el entero menor, mayor o igual que el n\u00famero especificado. $divide Devuelve el resultado de dividir el primer n\u00famero por el segundo floor Devuelve el entero mayor, menor o igual que el n\u00famero especificado. $mod Devuelve el resto de dividir el primero n\u00famero por el segundo $multiply Multiplica varios n\u00fameros, acepta varios argumentos. $pow Eleva un n\u00famero a la potencia especificada $sqrt Calcula la ra\u00edz cuadrada $subtract Devuelve el resultado de restar el primer n\u00famero menos el segundo. Si los dos valores son fechas devuelve la diferencia en milisegundos. $trunc Trunca un n\u00famero"},{"location":"bloque_iv/tema_18/page-4/#funciones-de-cadenas","title":"Funciones de Cadenas","text":"Funci\u00f3n Descripci\u00f3n $concat Concatena varias cadenas $substr Devuelve una subcadena, a partir de una posici\u00f3n indicada hasta una longitud especificada. $toLower Convierte una cadena a min\u00fasculas $toUpper Convierte una cadena may\u00fasculas $strcasecmp Compara cadenas y devuelve 0 si ambos son iguales, 1 si la primera es mayor que la segunda, o -1 si la primera es menor que la segunda"},{"location":"bloque_iv/tema_18/page-4/#funciones-de-grupo","title":"Funciones de Grupo","text":"Funci\u00f3n Descripci\u00f3n sum Devuelve la sma de los valores num\u00e9ricos, ignorando los no num\u00e9ricos. $avg Devuelve la media de los valores num\u00e9ricos e ignora los no num\u00e9ricos $first Devuelve el primer valor del grupo $last Devuelve el \u00faltimo valor $max Devuelve el valor m\u00e1ximo $min Devuelve el valor m\u00ednimo"},{"location":"bloque_iv/tema_18/page-4/#funciones-de-fecha","title":"Funciones de Fecha","text":"Funci\u00f3n Descripci\u00f3n $dayOfYear Devuelve el d\u00eda del a\u00f1o $dayOfMonth Devuelve el d\u00eda del mes. $dayOfWeek Devuelve el d\u00eda de la semana $year Devuelve el a\u00f1o $month Devuelve el n\u00famero del mes $hour Devuelve la hora $minute Devuelve los minutos $second Devuelve los segundos $dateToString Devuelve la fecha en String"},{"location":"bloque_iv/tema_18/page-4/#uso-de-estas-funciones","title":"Uso de estas funciones","text":"<p>Estas funciones se utilizan en las operaciones de agregaci\u00f3n, o consultas de agregaci\u00f3n, que lo que hacen es procesar los registros y obtener nuevos resultados, calculados o transformados.</p> <p>La agregaci\u00f3n opera con grupos de valores de m\u00faltiples documentos y se puede realizar una variedad de operaciones sobre los datos agrupados para devolver un solo resultado. El objetivo es presentar datos calculados, formateados y/o filtrados de manera diferente a como se encuentra en los documentos.</p> <p>MongoDB ofrece tres formas de realizar la agregaci\u00f3n:  la agregaci\u00f3n pipeline, la funci\u00f3n de map-reduce y la agregaci\u00f3n de prop\u00f3sito \u00fanico.</p>"},{"location":"bloque_iv/tema_18/page-4/#etapas-pipeline","title":"Etapas Pipeline","text":"<p>Las etapas son las siguientes:</p> Etapa Descripci\u00f3n Multiplicidad $match Filtra los resultado. Permite filtrar los resultados de los documentos que cumplen cierto criterios. Se puede filtrar antes o despu\u00e9s de agregar resultados. n:1 $group Agrupaci\u00f3n. Permite agrupar distintos documentos seg\u00fan compartan el valor de uno o varios de sus atributos, y realizar operaciones sobre los elementos de cada uno de los grupos. Se utilizan las funciones de grupo n:1 $sort Ordenaci\u00f3n de los documentos 1:1 $skip Salta N documentos n:1 $limit Elige N elementos para el resultado n:1 $unwind Normaliza arrays 1:n $out Env\u00eda el resultado a una salida, se almacena en la BD como una nueva colecci\u00f3n 1:1 <p>La multiplicidad se refiere a cu\u00e1ntos documentos obtenemos como resultado despu\u00e9s de aplicar la etapa. De esta forma 1:1 se aplica a un documento y se obtiene otro, n:1 se aplica a n documentos y se obtiene 1, y 1:n se aplica a un documentos y se obtienen n.</p>"},{"location":"bloque_iv/tema_18/page-4/#formato-pipeline","title":"Formato pipeline","text":"<p>El formato de pipe line es la siguiente:</p> <pre><code>db.collection.aggregate([\n    {\n     $etapa1: {\n      //...\n     }\n    }, {\n     $etapa2: {\n      //...\n     }\n    },\n])\n</code></pre> <p>Por ejemplo:</p> <p>Tenemos la colecci\u00f3n articulos, cada registro est\u00e1 formado por los campos: c\u00f3digo, denominaci\u00f3n, pvp, categor\u00eda, uv, y stock.</p> <p>Vamos a obtener los articulos de los art\u00edculos y la categor\u00eda convertida a may\u00fasculas. Se utiliza la etapa $project pues cambiamos el aspecto del documento.</p> <p>\u00a1Importante!</p> <p>Para referirnos a los campos del documento los ponemos entre comillas y con el prefijo $.</p> <pre><code>db.articulos.aggregate([\n    {\n     $project:\n     {\n      denominacion: {$toUpper: \"$denominacion\"}\n      cetegoria: {$toUpper: \"$categoria\"}\n     }\n    }\n])\n</code></pre> <p>Si dicha salida se desea a\u00f1adir a la base de datos, se le a\u00f1ade la etapa out:</p> <pre><code>db.articulos.aggregate([\n    {\n     $project:\n     {\n      denominacion: {$toUpper: \"$denominacion\"}\n      cetegoria: {$toUpper: \"$categoria\"}\n     }\n    },\n    { $out: \"salidanueva\"}\n])\n</code></pre> <p>Vamos a obtener la denominaci\u00f3n en may\u00fasculas, el importe de las ventas que ser\u00e1n las uv * pvp, y el stock actual que ser\u00e1 stock - uv.</p> <p>Las etapas a usar en este caso son: project, multiply, substract.</p> <pre><code>db.articulos.aggregate([\n    {\n    $project: {\n     articulo: {$toUpper: \"$denominacion\"},\n     importe: { $multiply: [\"$pvp\", \"$uv\"]},\n     stockactual: {$subtract: [\"$stock\", \"$uv\"]}\n    }\n    }\n])\n</code></pre>"},{"location":"bloque_iv/tema_18/page-4/#condiciones-de-agregacion","title":"Condiciones de agregaci\u00f3n","text":"<p>Podemos a\u00f1adir las siguientes condiciones a las consultas de agregaci\u00f3n</p> Name Descripci\u00f3n $cond Este operador eval\u00faa una expresi\u00f3n y dependiendo del resultado, devuelve el valor de una de las otras dos expresiones. Recibe tres expresiones en una lista ordenada: {$cond: [ \\, \\, \\]} $ifNull Devuelve o bien el resultado no nulo de la primera expresi\u00f3n o el resultado de la segunda expresi\u00f3n si la primera expresi\u00f3n da como resultado un resultado nulo. El resultado de la segunda expresi\u00f3n puede ser nulo. { $ifNull: [ \\, &lt;expresionsiesnull&gt;]} <p>Ejemplo: A la consulta anterior, vamos a preguntar si el stock actual es negativo, asignaremos a un campo nuevo llamado reponer true si es menor que 0 y false si no lo es:</p> <pre><code>db.articulos.aggregate([\n    {\n    $project: {\n     articulo: {$toUpper: \"$denominacion\"},\n     importe: { $multiply: [\"$pvp\", \"$uv\"]},\n     stockactual: {$subtract: [\"$stock\", \"$uv\"]},\n     reponer: {\n      $cond: [\n             {$lte: [{$substract: [\"stock\", \"uv\"]}, 0]}, true, false\n         ] \n     }\n    }}\n])\n</code></pre> <p>En la siguiente consulta, obtenemos por cada categor\u00eda el n\u00famero de art\u00edculos, el total unidades vendidas de art\u00edculos, y el total importe, la suma de los pvp*unidades. Se utiliza la etapa <code>$group</code>, cuando se usa esta etapa se debe a\u00f1adir el identificador de objeto _id, en este caso como agrupamos por categor\u00eda lo indicamos en el _id. Para contar art\u00edculos se utiliza la funci\u00f3n   <code>$sum</code></p> <pre><code>db.articulos.aggregate([\n    {\n    $group:{\n     _id: \"$categoria\",\n     contador: {$sum: 1},\n     sumaunidades: {$sum: \"$uv\"},\n     totalimporte: {$sum: {$multiply: [\"$pvp\", \"$uv\"]}}\n    }\n    }\n])\n</code></pre> <p>En la siguiente consulta obtenemos el n\u00famero de documentos de la categor\u00eda Deportes, el total de unidades vendidas de sus art\u00edculos, el total del importe y la media de unidades vendidas. Se utilizan las etapas <code>$match</code> para seleccionar la categor\u00eda, y luego <code>$group</code> para obtener resultados agrupados</p> <pre><code>db.articulos.aggregate([\n    {$match: {categoria: \"Deportes\"}},\n    {$group: {\n     _id: \"Deportes\",\n     contador: {$sum: 1},\n     sumaunidades: { $sum: \"$uv\"},\n     media: { $avg: \"$uv\"},\n     totalimporte: { $sum: { $multiply: [\"$pvp\", \"$uv\"]}}\n    }}\n])\n</code></pre> <p>Obtenemos, ahora el precio m\u00e1s caro:</p> <pre><code>db.articulos.aggreate([\n    {$group: {\n     _id: null,\n     maximo: { $max: \"$pvp\"}\n    }}\n])\n</code></pre> <p>\u00bfY s\u00ed, queremos obtener el art\u00edculo con el precio m\u00e1s caro?</p> <p>En primer lugar, debemos obtener los datos pvp y denominaci\u00f3n, de todos los articulos ordedanos descendentemente por el precio y denominaci\u00f3n. ($sort)</p> <p>Despu\u00e9s, el resultado obtenido se agrupa para luego coger el primero con la funci\u00f3n $first</p> <pre><code>db.articulos.aggregate([\n    { $sort: { pvp: -1, denominacion: -1}}\n    {\n     $group:{\n      _id:null,\n      mascaro: {$first: \"$denominacion\"}\n      precio: {$first: \"$pvp\"}\n     }\n    }\n])\n</code></pre> <p>Ahora, queremos obtener la suma del importe de los art\u00edculos cuya denominaci\u00f3n empieza por M o P.</p> <p>Primero, debemos obtener el primer car\u00e1cter de todos los art\u00edculos utilizando la funci\u00f3n $substr:</p> <pre><code>{\n $project: {\n  primercarac: { $substr: [\"$denominacion\", 0, 1]},\n  impor: { $multiply: [\"$pvp\", \"$uv\"]}\n }\n}\n</code></pre> <p>Despu\u00e9s seleccionamos, de los datos obtenidos, lo que tienen en primercarac P o M:</p> <pre><code>{$match: {\"primercarac\": {$in: [\"M\", \"P\"]}}}\n</code></pre> <p>Finalmente, se agrupa el resultado y se suma los importes:</p> <pre><code>{\n $group:{\n  _id: 1,\n  totalimporte: { $sum: \"$impor\"}\n }\n}\n</code></pre> <p>La consulta completa ser\u00eda:</p> <pre><code>db.articulos.aggregate([\n    {\n  $project: {\n   primercarac: { $substr: [\"$denominacion\", 0, 1]},\n   impor: { $multiply: [\"$pvp\", \"$uv\"]}\n  }\n },\n    {$match: {\"primercarac\": {$in: [\"M\", \"P\"]}}},\n    {\n        $group:{\n            _id: 1,\n   totalimporte: { $sum: \"$impor\"}\n  }\n }\n])\n</code></pre> <p>En la siguiente consulta, obtenemos por cada categor\u00eda el art\u00edculo con el precio m\u00e1s caro. Para ello primero ordenamos descendentemente por pcategor\u00eda, pvp y denominaci\u00f3n, utilizando la etapa <code>$sort</code>. Y el resultado obtenido se agrupa con <code>$group</code> para luego obtener el primero de cada categor\u00eda con la funci\u00f3n <code>$first</code></p> <pre><code>db.articulos.aggregate([\n    {$sort: {categoria: -1, pvp: -1, denominacion: -1}},\n    {\n     $group:{\n      _id: \"$categoria\",\n      mascaro: { $first: \"$denominacion\"},\n      precio: {$first: \"$pvp\"}\n     }\n    }\n])\n</code></pre>"},{"location":"bloque_iv/tema_18/page-4/#utilizacion-de-arrays-campos-compuestos-y-agregados","title":"Utilizaci\u00f3n de Arrays, Campos compuestos y agregados","text":"<p>Las siguientes funciones sirve trabajar con arrays:</p> Nombre Descripci\u00f3n $arrayElemAt Devuelve el elemento especificado en el \u00edndice $concatArrays Devuelve un array concatenado en una cadena $filter Selecciona elementos de un array y devuelve otro array con esos elementos. $isArray Determina si el operando es un array o no. Devuelve true o false $size Devuelve el n\u00famero de elementos del array $slice Devuelve un sub-set de elementos del array, especificando el n\u00famero <p>Vamos a usar ahora la colecci\u00f3n Trabajadores.  Vamos a insertar un nuevo trabajador</p> <pre><code>db.trabajadores.insert(\n    {\n  nombre: {nom: \"Alicia\", ape1: \"Ramos\", ape2: \"Mart\u00edn\"},\n     direccion: {poblacion: \"Madrid\", calle: {\"Avda Toledo 10\", }},\n     salario: 1200,\n     oficios: [\"Profesora\", \"Analista\"],\n     primas: [20,30,40],\n     edad: 50\n    }\n)\n</code></pre> <p>Como podemos observar un empleado, tiene dos campos compuestos, nombre y direcci\u00f3n, y adem\u00e1s dos listas: oficios  y primas.</p> <p>Vamos a consultar la poblaci\u00f3n, el nombre descompuesto en nombre, ape1 y ape2, el primer oficio, el segundo y el \u00faltimo. En caso de no tenerlas no devuelve nada. Adem\u00e1s lo vamos a ordenar de forma ascendente</p> <p>Importante</p> <p>Para acceder a los campos compuestos navegamos como si fuese un objeto. Por ejemplo, si quiero acceder al campo nom del nombre o al campo poblacion de la direcci\u00f3n, ser\u00eda: nombre.nom o direccion.poblacion</p> <pre><code>db.trabajadores.find({direccion.poblacion: \"Toledo\"})\n</code></pre> <pre><code>db.trabajadores.aggregate([\n    {$sort: {direccion.poblacion: 1}},\n    {$project: \n     {\n      poblacion: \"$direccion.poblacion\",\n      nombre: \"$nombre.nom\",\n      ape1: \"$nombre.ape1\",\n      ape2: \"$nombre.ape2\",\n      oficio1: {$arrayElementAt: [\"$oficios\", 0]},\n      oficio2: {$arrayElementAt: [\"$oficios\", 1]},\n      oficio3: {$arrayElementAt: [\"$oficios\", -1]}\n     }\n    }\n])\n</code></pre> <p>Ahora, obtenemos los elementos que tienen los arrays de los trabajadores, y los arrays concatenados. Se utiliza la funci\u00f3n $ifNull para comprobar que los arrays existan en los trabajadores, y evitar errores de salida. Se pregunta si es null, si lo es devuelve el array vacio.</p> <pre><code>db.trabajadores.aggregate([\n    {\n    $project:\n     {\n      nombre: \"$nombre.nom\",\n      numerooficios: {$size: {\"$ifNull\": [\"$oficios\", []]}},\n      numeroprimas: { $size: { \"$ifNull\": [\"$primas\", []]}},\n      oficiosconcatenados: {$concatArrays: [\"$oficios\", \"$primas\"]}\n     }\n    }\n])\n</code></pre> <p>Por \u00faltimo, devolvemos el n\u00famero de trabajadores y la media de edad de los trabajadores que han tenido el oficio de Analista</p> <pre><code>db.trabajadores.aggregate([\n    {$match: {oficios: \"Analista\"}},\n    {$group: {\n     _id: \"analista\",\n     contador: { $sum:1 },\n     media: {$avg: \"$edad\"}\n    }}\n])\n</code></pre> Ejercicio <p>Utilizando la colecci\u00f3n trabajadores realiza las siguientes consultas:</p> <ul> <li>Visualiza la edad media, la media del salario y el n\u00famero de trabajadores que hayan tenido una prima de 30 o de 80.</li> <li>Visualiza por poblaci\u00f3n el n\u00famero de trabajadores, el salario medio y el m\u00e1ximo salario.</li> <li>Visualiza el nombre, ape1, ape2, del empleado que tiene m\u00e1ximo salario</li> <li>A partir de la consulta anterior, obt\u00e9n ahora el nombre, ape1, ape2 y salario del empleado que tiene m\u00e1ximo salario por cada poblaci\u00f3n.</li> </ul>"},{"location":"bloque_iv/tema_18/page-5/","title":"5 Relaciones entre documentos","text":""},{"location":"bloque_iv/tema_18/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>MongoDB utiliza 2 m\u00e9todos o patrones que nos van a permitir establecer la estructura de los documentos y sus relaciones. Vamos a ver c\u00f3mo como son las relaciones entre documentos compar\u00e1ndolas con el modelo relacional.</p>"},{"location":"bloque_iv/tema_18/page-5/#referencias-manuales","title":"Referencias Manuales","text":"<p>Este m\u00e9todo consiste en almacenar el campo _id de un documento como referencia de un documento. Este m\u00e9todo es similar al concepto de clave ajena del modelo relacional.</p> <p>En el modelo relacional se debe realizar una segunda consulta para devolver los datos relaciones. Este es el m\u00e9todo m\u00e1s utilizado.</p> <p>Por ejemplo, creamos la colecciones emple y depart, cada elemento con su _id credo manualmente. Tenemos en cuenta que es como si fuese una relaci\u00f3n 1:N, es decir, un departamento puede tener varios empleados.</p> <pre><code>db.emple.insertMany([\n    {_id: \"emp1\", nombre: \"Juan\", salario: 1000, fechaalta: \"10/10/199\"},\n    {_id: \"emp2\", nombre: \"Alicia\", salario: 1400, fechaalta: \"07/08/2000\", oficio: \"Profesora\"},\n    {_id: \"emp3\", nombre: \"Mar\u00eda Jes\u00fas\", salario: 1500, fechaalta: \"05/01/2005\", oficio: \"Analista\", comision: 100},\n    {_id: \"emp4\", nombre: \"Alberto\", salario: 1100, fechaalta: \"15/11/2001\"}\n])\n</code></pre> <p>En la colecci\u00f3n depart, con dos departamentos, asignamos los dos primeros empleados al primer departamento, y los dos siguientes al segundo. Para asignar los empleados ponemos el nombre de la colecci\u00f3n y entre corchetes dentro de un array de referencias los _id de los empleados a incluir, por ejemplo emple:['emp1', 'emp2']</p> <pre><code>db.depart.insertMany([\n    {_id:'dep1', nombre: 'Inform\u00e1tica', loc: 'Madrid', emple:['emp1', 'emp2']},\n    {_id: 'dep2', nombre: \"Gesti\u00f3n\", loc: \"Talavera\", emple: ['emp3', 'emp4']}\n])\n</code></pre> <p>Para visualizar los datos de la combinaci\u00f3n de las colecciones necesitaremos hacer dos consultas, una para obtener el departamento a consultar, y la otra para obtener los empleados de ese departamento, que est\u00e1n dentro del array del departamento. Por ejemplo, se desea visualizar los empleados del departamento con identificativo _id igual a dep1</p> <p>Para ello primero cargamos el departamento con _id:dep1 en una variable, utilizamos el m\u00e9todo findOne. Dicho m\u00e9todo siempre incluye  el campo __id incluso si el campo no se especifica expl\u00edcitamente en el par\u00e1metro de consulta:</p> <pre><code>departrabajo = db.depart.findOne({_id: 'dep1'})\n</code></pre> <p>Despu\u00e9s recuperamos los empleados cuyo _id se encuentre enlazado a este departamento</p> <pre><code>emplesdep = db.emple.find({_id: {$in: departrabajo.emple}})\n</code></pre> <p>Podemos a\u00f1adir el m\u00e9todo toArray() los datos se devuelven en una matriz que contiene todos los documentos de la consulta, es decir, devuelve un array de documentos:</p> <pre><code>emplesdep = db.emple.find({_id: {$in: departrabajo.emple}}).toArray()\n</code></pre> <p>Ahora vamos a obtener los empleados del departamento 2 cuyo salario sea mayor de 1400</p> <pre><code>departrabajo = db.depart.findOne({_id: 'dep2'})\n</code></pre> <pre><code>emplesdep = db.emple.find({_id: { $in: departrabajo.emple}, salario: {$gt: 1400}}).toArray()\n</code></pre>"},{"location":"bloque_iv/tema_18/page-5/#dbrefs","title":"DBRefs","text":"<p>Son referencias de un documento a otro utilizando el valor del campo _id del primer documento, el nombre de la colecci\u00f3n y, opcionalmente, el nombre de la base de datos. Con la inclusi\u00f3n de estos nombres, los DBRefs permiten que documentos que se encuentran en varias colecciones sean vinculados para ser documentos de una sola colecci\u00f3n.</p> <p>Los DBRefs proporcionan en esencia una sem\u00e1ntica com\u00fan para la representaci\u00f3n de los v\u00ednculos entre documentos. Los DBRefs tambi\u00e9n requieren consultas adicionales para devolver los documentos de referencia.</p> Ejercicio <p>Crea la colecci\u00f3n sucursales y cuentas y realiza las siguientes consultas:</p> <ul> <li>Visualiza las cuentas de las sucursales de Madrid.</li> <li>Visualiza las cuentas son saldohaber &gt; 10000 cuyo director sea Fernando Rato.</li> <li>Sube 300 el saldohaber de las cuentas de la sucursal con c\u00f3digo SUCI</li> </ul>"},{"location":"bloque_iv/tema_18/page-6/","title":"6 MongoDB en Java","text":""},{"location":"bloque_iv/tema_18/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Para trabajar en Java con MongoDB necesitamos descargar el driver desde la URL de MongoDB https://mongodb.github.io/mongo-java-driver</p>"},{"location":"bloque_iv/tema_18/page-6/#bson","title":"BSON","text":"<p>BSON es un formato de serializaci\u00f3n binaria, se utiliza para almacenar documentos y hacer llamadas a procedimientos en MongoDB. La especificaci\u00f3n BSON se encuentra en <code>bsonspec.org</code>. BSON soporta los siguientes tipos de datos como valores en los documentos, cada tipo de dato tiene un n\u00famero y un alias que se pueden utilizar con el operador <code>$type</code> para consultar los documentos por tipo BSON. Algunos de los tipos BSON son los siguientes:</p> Tipo N\u00famero Al\u00edas Double 1 \"double\" String 2 \"string\" Object 3 \"object\" Array 4 \"array\" Binary data 5 \"binData\" ObjectId 7 \"objectId\" Boolean 8 \"bool\" Date 9 \"date\" Null 10 \"null\" Symbol 14 \"symbol\" Timestamp 17 \"timestamp\" <p>Al comparar los valores de los diferentes tipos BSON, MongoDB utiliza el siguiente orden de comparaci\u00f3n, de menor a mayor: <code>Null</code>, <code>Numbers(int, long, double)</code>, <code>Symbol</code>, <code>String</code>, <code>Object</code>, <code>Array</code>, <code>BinData</code>, <code>ObjectId</code>, <code>Boolean</code>, <code>Date</code>, <code>Timestamp</code></p>"},{"location":"bloque_iv/tema_18/page-6/#conexion-a-la-bd","title":"Conexi\u00f3n a la BD","text":"<p>Para conectarnos a la base de datos creamos una instancia de <code>MongoClient</code>, por defecto crea una conexi\u00f3n con la base de datos local, y escucha por el puerto 27017. Todos los m\u00e9todos relacionados con operaciones CRUD (C*reate, R*ead, U*pdate and *D*elete) en Java se accede a trav\u00e9s de la interfaz ***MongoCollection. Las instancias de MongoCollection se pueden obtener a partir de la interfaz MongoClient por medio de una MongoDatabase</p> <pre><code>MongoClient client = MongoClients.create(URI);\nMongoDatabase db = client.getDatabase(DB);\nMongoCollection&lt;Document&gt; collection = db.getCollection(COLLECTION);\nclient.close(); // Close connection\n</code></pre> <p><code>MongoCollection</code> es una interfaz gen\u00e9rica: el par\u00e1metro de tipo TDocument es la clase que los clientes utilizan para insertar o modificar los documentos de una colecci\u00f3n, y es el tipo predeterminado para devolver b\u00fasqueda y agregados. El m\u00e9todo de un solo argumento <code>getCollection</code> devuelve una instancia de <code>MongoCollection&lt;Document&gt;</code>, y as\u00ed podemos trabajar con instancias de la clase de documento.</p>"},{"location":"bloque_iv/tema_18/page-6/#visualizar-los-datos-de-una-coleccion","title":"Visualizar los datos de una colecci\u00f3n","text":"<p>Los datos de una colecci\u00f3n se pueden cargar en una lista utilizando el m\u00e9todo <code>find().into()</code> de la siguiente manera:</p> <pre><code>List&lt;Document&gt; query = collection.find().into(new ArrayList&lt;&gt;());\n\nfor (Document document : query) {\n    System.out.println(document);\n}\n</code></pre> <p>Con el m\u00e9todo <code>find()</code> se realiza la consulta, mientras que con el m\u00e9todo <code>into</code> pasamos dicha consulta a la colecci\u00f3n de datos que deseemos.</p> <p>Tambi\u00e9n podemos recuperar los valor de los campos del documento, utilizando los m\u00e9todos <code>get</code> del objeto Document, que recibe como par\u00e1metro el nombre de la clave. Si se sabe el tipo de dato de la clave elegiremos el m\u00e9todo correspondiente, y si no utilizamos <code>get()</code> que devuelve un objeto. Primero cargamos el elemento de la lista en un Document. Si la clave no existe en el documento visualizar\u00e1 null</p> <pre><code> for (Document document : query) {\n    System.out.printf(\"Nombre: %s \", document.getString(\"nombre\"));\n    System.out.printf(\"Edad: %d \", document.getInteger(\"edad\", 0));\n    System.out.printf(\"On: %b\\n\", document.getBoolean(\"on\", false));\n}\n</code></pre>"},{"location":"bloque_iv/tema_18/page-6/#insertar-documentos","title":"Insertar documentos","text":"<p>Para insertar documentos, creamos un objeto Document, con el m\u00e9todo <code>put</code> asignamos los pares clave-valor, donde el primer par\u00e1metro es el nombre del campo o la clave, y el segundo el valor. Y con el m\u00e9todo <code>insertOne</code> se inserta en la colecci\u00f3n.</p> <pre><code>Document doc = new Document();\ndoc.put(\"nombre\", \"Mar\u00eda\");\ndoc.put(\"edad\", 18);\ncollection.insertOne(doc);\n</code></pre> <p>Tambi\u00e9n se puede insertar documentos utilizando el m\u00e9todo append de Document. Por ejemplo, se va a insertar el siguiente documento, se crea en curso un nuevo documento con dos pares clave-valor:</p> <pre><code>Document doc = new Document(\"nombre\", \"Marcos\")\n        .append(\"edad\", 18)\n        .append(\"cursos\", new Document()\n                .append(\"curso1\", \"1DAM\")\n                .append(\"curso2\", \"2DAM\")\n        );\n\ncollection.insertOne(doc);\n</code></pre> <p>Dicho documento se visualizar\u00eda de la siguiente forma:</p> <pre><code>{\n    \"Nombre\": \"Pedro\",\n    \"tel\u00e9fono\": 12345,\n    \"curso\": {\n        \"curso1\": \"1DAM\",\n        \"curso2\": \"2DAM\",\n    }\n}\n</code></pre> <p>A la hora de visualizar el curso utilizaremos el m\u00e9todo <code>get()</code> en lugar de <code>getString()</code>.</p> <p>Se puede insertar en la base de datos una lista de documentos en una colecci\u00f3n utilizando el m\u00e9todo <code>insertMany</code></p> <p>Si se desea saber los documentos de una colecci\u00f3n se puede utilizar el m\u00e9todo <code>countDocuments</code>:</p> <pre><code>System.out.println(\"N\u00ba documentos: \" + collection.countDocuments());\n</code></pre>"},{"location":"bloque_iv/tema_18/page-6/#iterable","title":"Iterable","text":"<p>El m\u00e9todo <code>find()</code> devuelve un cursor de una instancia <code>FindIterable</code>. Podemos utilizar el m\u00e9todo <code>iterator()</code> para recorrer el cursor.</p> <pre><code>MongoCursor&lt;Document&gt; cursor = collection.find().iterator();\nDocument document;\n\nwhile(cursor.hasNext()){\n    document = cursor.next();\n    System.out.println(document.toJson());\n}\ncursor.close();\n</code></pre> <p>Si solo se desea obtener el primer documento utilizamos el m\u00e9todo <code>first()</code>:</p> <pre><code>Document first = collection.find().first();\nSystem.out.println(first.toJson());\n</code></pre>"},{"location":"bloque_iv/tema_18/page-6/#utilizar-filtros","title":"Utilizar filtros","text":"<p>El m\u00e9todo <code>find()</code> admite la utilizaci\u00f3n de filtros. Para utilizar los m\u00e9todos de la clase <code>Filters</code> hacemos un <code>import static</code> de la clase <code>Filters</code> de la siguiente manera:</p> <pre><code>import static com.mongodb.client.model.Filters.*;\n</code></pre> <p>Podemos usar sus diferentes m\u00e9todos como, <code>eq</code> para poder localizar los documentos cuyo elementos sean igual a lo indicado</p> <pre><code>Document document1 = collection.find(eq(\"nombre\", \"prueba\")).first();\n\nif(document1 == null) {\n    System.out.println(\"Documento con nombre 'prueba' no encontrado\");\n} else {\n    System.out.println(document1);\n}\n</code></pre> <p>Si el filtro devuelve varios documentos los recuperamos con un cursor, o bien con una lista.</p> <p>Si se desea extraer los objetos BSON de un documento, utilizaremos los filtros:</p> <pre><code>System.out.println(\"-------------------------OBJETOS BSON---------------------------\");\nMongoCursor&lt;Document&gt; cursor2 = collection.find().iterator();\nDocument document2;\n\nwhile(cursor2.hasNext()){\n    document2 = cursor2.next();\n    Bson id = eq(\"_id\", document2.get(\"_id\"));\n    Bson nombre = eq(\"nombre\", document2.get(\"nombre\"));\n    Bson curso = eq(\"curso\", document2.get(\"curso\"));\n    System.out.println(\"Id: \" + id + \". Nombre: \" + nombre + \". Curso: \" + curso);\n}\n\ncursor2.close();\n</code></pre>"},{"location":"bloque_iv/tema_18/page-6/#ordenar-resultados","title":"Ordenar resultados","text":"<p>Para ordenar el resultado de una consulta importamos los m\u00e9todos de la clase Sorts:</p> <pre><code>import static com.mongodb.client.model.Sorts.*;\n</code></pre> <p>De esta forma podemos obtener todos los documentos que tenga 2\u00baDAM, ordenados de forma descendiente por el nombre:</p> <pre><code>collection.find(eq(\"curso\", \"2DAM\")).sort(descending(\"nombre\"));\n</code></pre>"},{"location":"bloque_iv/tema_18/page-6/#utilizar-proyecciones","title":"Utilizar proyecciones","text":"<p>A veces no se necesitan todos los datos contenidos en un documento, se pueden utilizar proyecciones para cambiar las salidas. Se necesitan importar los m\u00e9todos de la clase <code>Projection</code>, estos m\u00e9todos devuelven un tipo BSON, que podr\u00e1 ser utilizado en otro m\u00e9todo. El import debe ser el siguiente:</p> <pre><code>import static com.mongodb.client.model.Projections.*;\n</code></pre> <p>De esta manera, solo vamos a obtener el nombre y la edad de cada persona:</p> <pre><code>MongoCursor&lt;Document&gt; cursor3 = collection.find()\n        .sort(ascending(\"nombre\"))\n        .projection(Projections.include(\"nombre\", \"edad\"))\n        .iterator();\n\nwhile (cursor3.hasNext()){\n    System.out.println(cursor3.next().toJson());\n}\n\ncursor3.close();\n</code></pre> <p>El m\u00e9todo <code>include</code> se utiliza para indicar los elementos que se desea visualizar, con el m\u00e9todo <code>exclude</code>, se indica los elementos que no se desea visualizar.</p>"},{"location":"bloque_iv/tema_18/page-6/#utilizar-agregaciones","title":"Utilizar agregaciones","text":"<p>Para utilizar los agregados se necesitan importar los m\u00e9todos de la clase <code>Aggregates</code>. Cada m\u00e9todo devuelve una instancia del tipo BSON, que a su vez se puede pasar al m\u00e9todo de agregado de MongoCollection. El import debe ser:</p> <pre><code>import static com.mongodb.client.model.Aggregates.*;\n</code></pre> <p>De esta manera:</p> <pre><code>MongoCursor&lt;Document&gt; cursor4 = collection.aggregate(\n        List.of(match(eq(\"curso\", \"1DAM\")))\n).iterator();\n\nwhile (cursor4.hasNext()){\n    System.out.println(cursor4.next().toJson());\n}\n\ncursor4.close();\n</code></pre>"},{"location":"bloque_iv/tema_18/page-6/#actualizar-documentos","title":"Actualizar documentos","text":"<p>Para actualizar las propiedad de un documento, podemos usar los m\u00e9todo <code>updateOne</code> y <code>updateMany</code>, para actualizar uno o varios documentos. Para poder actualizar un documento ser\u00e1 necesario:</p> <ul> <li>el filtro de consulta para localizar el/los elementos a actualizar, que puede ser un objeto Bson de la clase <code>Filters</code> o puede ser un nuevo Documento.</li> <li>la actualizaci\u00f3n de las propiedades con los m\u00e9todos de la clase de utilidad <code>Updates</code>, por ejemplo, el m\u00e9todo <code>set(prop, value)</code> indica un nuevo valor para dicha propiedad (o a\u00f1ade la propiedad si no existe), <code>inc(prop, value)</code> incrementa el valor  en la propiedad indicada, o <code>unset(prop)</code>, elimina la propiedad del documento. Se puede combinar varias actualizaciones haciendo uso del m\u00e9todo <code>combine</code>.</li> <li>opciones de actualizaci\u00f3n, como por ejemplo indicar que se inserte el documento en caso de que no exista, con el m\u00e9todo <code>upsert(true)</code> de la clase <code>UpdateOptions</code>.</li> </ul> <p>La actualizaci\u00f3n devuelve un objeto de tipo <code>UpdateResult</code> en el que podemos comprobar cuando documentos han sido modificados (<code>getModifiedCount()</code>) y cuantos elementos han sido seleccionados (<code>getMatchedCount()</code>).</p> <pre><code>collection.updateOne(eq(\"nombre\", \"Ana\"), set(\"nota\", 5));\n\nUpdateResult updateResult = collection.updateMany(eq(\"curso\", \"1DAM\"), inc(\"nota\", 1));\n\nSystem.out.println(\"Se han modificado: \" + updateResult.getModifiedCount());\nSystem.out.println(\"Se han seleccionado: \" + updateResult.getMatchedCount());\n</code></pre> <p>Tambi\u00e9n existe el m\u00e9todo <code>findOneAndUpdate()</code>, que localiza el documento a actualizar y lo actualiza y en lugar de devolverle un <code>UpdateResult</code> devuelve el documento de la forma indicada en las opciones de actualizaci\u00f3n (de la clase <code>FindOneAnUpdateOptions</code>). Con el m\u00e9todo <code>returnDocument(value)</code> podemos indicar que retorne el documento antes de actualizar (<code>ReturnDocument.BEFORE</code>) o despu\u00e9s de actualizar (<code>ReturnDocument.AFTER</code>)</p>"},{"location":"bloque_iv/tema_18/page-6/#reemplazar-documentos","title":"Reemplazar documentos","text":"<p>Con <code>replaceOne</code> se puede reemplazar un documento, indic\u00e1ndole la consulta de filtrado, el nuevo documento a reemplazar y las opciones de reemplazado (como por ejemplo <code>upsert</code> de la clase <code>ReplaceOptions</code>).</p> <pre><code>Bson query = eq(\"title\", \"Music of the Heart\");\nDocument replaceDocument = new Document().\n        append(\"title\", \"50 Violins\").\n        append(\"fullplot\", \" A dramatization of the true story of Roberta Guaspari who co-founded the Opus 118 Harlem School of Music\");\nReplaceOptions opts = new ReplaceOptions().upsert(true);\nUpdateResult result = collection.replaceOne(query, replaceDocument, opts);\n</code></pre> <p>La diferencia entre reemplazar y actualizar, es que actualizar me permite realizar actualizaciones de propiedades espec\u00edficas, mientras que reemplazar, reemplaza (o actualiza) el documento completo.</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>findOneAndReplace()</code>, que localiza el documento a reemplazar y lo reemplaza y en lugar de devolverle un <code>UpdateResult</code> devuelve el documento de la forma indicada en las opciones de reemplazo (de la clase <code>FindOneAndReplaceOptions</code>). Con el m\u00e9todo <code>returnDocument(value)</code> podemos indicar que retorne el documento antes de reemplazar (<code>ReturnDocument.BEFORE</code>) o despu\u00e9s de reemplazar (<code>ReturnDocument.AFTER</code>)</p>"},{"location":"bloque_iv/tema_18/page-6/#borrar-un-documento-de-la-coleccion","title":"Borrar un documento de la colecci\u00f3n","text":"<p>Para eliminar un documento se usar\u00e1 <code>deleteOne</code> y para borrar varios <code>deleteMany</code>. Ambos devuelve un <code>DeleteResult</code></p> <pre><code>DeleteResult result1 = collection.deleteMany(eq(\"nombre\", \"Mar\u00eda\"));\nSystem.out.println(\"Se han eliminado: \" + result1.getDeletedCount());\n</code></pre>"},{"location":"bloque_iv/tema_18/page-6/#crear-y-borrar-una-coleccion","title":"Crear y borrar una colecci\u00f3n","text":"<p>Para crear una colecci\u00f3n utilizamos el m\u00e9todo <code>createCollection</code>, asociado a la base de datos y para eliminarla, usamos el m\u00e9todo <code>drop</code> asociado a la colecci\u00f3n:</p> <pre><code>MongoClient client = MongoClients.create(URI);\nMongoDatabase db = client.getDatabase(DB);\ndb.createCollection(\"new_collection\");\n\nMongoCollection&lt;Document&gt; collection = db.getCollection(\"new_collection\");\ncollection.drop();\n</code></pre>"},{"location":"bloque_iv/tema_18/page-6/#listar-colecciones-de-la-base-de-datos","title":"Listar colecciones de la base de datos","text":"<p>El m\u00e9todo listCollectionNames devuelve las colecciones de la base de datos en un MongoIterable:</p> <pre><code>db.listCollectionNames()\n    .forEach(System.out::println);\n</code></pre>"},{"location":"bloque_iv/tema_18/page-6/#crear-listar-y-borrar-bases-de-datos","title":"Crear, listar y borrar bases de datos","text":"<p>Para crear una base de datos se llama al m\u00e9todo <code>getDatabase()</code> desde el objeto <code>MongoClient</code>, sin embargo, la base de datos no se crear\u00e1 hasta que no se inserte un documento.</p> <p>Con el m\u00e9todo <code>listDatabaseNames()</code> sirve para listar las bases de datos, y con el m\u00e9todo <code>drop</code> se elimina</p>"},{"location":"bloque_iv/tema_18/page-6/#pasar-de-mongodb-a-fichero","title":"Pasar de MongoDB a Fichero","text":"<p>Podemos crear un fichero JSON consultando todos los documentos y a\u00f1adi\u00e9ndolos a un fichero con la clase <code>BufferedWriter</code></p> <pre><code>MongoClient client = MongoClients.create(URI);\nMongoDatabase db = client.getDatabase(DB);\nMongoCollection&lt;Document&gt; collection = db.getCollection(COLLECTION);\n\ntry(BufferedWriter writer = new BufferedWriter(\n        new FileWriter(\"src/main/resources/doc.json\"))){\n    List&lt;Document&gt; query = collection.find().into(new ArrayList&lt;&gt;());\n\n    for (Document document :\n            query) {\n        writer.write(document.toJson());\n        writer.newLine();\n    }\n} catch (IOException e) {\n    System.out.println(\"Error\");\n}\n\nclient.close();\n</code></pre> <p>Por el contrario, si tengo un fichero JSON y quiero almacenarlo, deber\u00eda leer dicho fichero con BufferedReader y insertar cada documento. Para pasar de una cadena en formato JSON a un documento, podemos usar el m\u00e9todo est\u00e1tico <code>parse</code> de la clase <code>Document</code>:</p> <pre><code>MongoClient client = MongoClients.create(URI);\nMongoDatabase db = client.getDatabase(DB);\nMongoCollection&lt;Document&gt; collection = db.getCollection(COLLECTION);\n\ntry(BufferedReader reader = new BufferedReader(\n        new FileReader(\"src/main/resources/doc.json\"))){\n    String str;\n    Document doc;\n    List&lt;Document&gt;  documents = new ArrayList&lt;&gt;();\n    while((str = reader.readLine()) != null){\n        doc = Document.parse(str);\n        documents.add(doc);\n    }\n\n    collection.insertMany(documents);\n} catch (IOException e) {\n    System.out.println(\"Error\");\n}\n\nclient.close();\n</code></pre>"},{"location":"bloque_iv/tema_18/page-6/#clases-pojos","title":"Clases POJOs","text":"<p>A veces, lo interesante de utilizar una base de datos es poder realizar conversiones con clases POJOs de un lenguaje de programaci\u00f3n. Para ello, se debe crear la clase POJO que representar\u00eda un documento de la base de datos. Teniendo el siguiente esquema de documentos, puede ser representada por la siguiente clase POJO:</p> DocumentClass GradeClass Score <pre><code>{\n    \"_id\": \"ObjectId\",\n    \"student_id\": \"number\",\n    \"scores\": [\n        {\n            \"type\": \"string\",\n            \"score\": \"double\"\n        }\n    ],\n    \"class_id\": \"number\"\n}\n</code></pre> <pre><code>public class Grade {\n    private ObjectId id;\n    @BsonProperty(\"student_id\")\n    private Double studentId;\n    @BsonProperty(\"class_id\")\n    private Integer classId;\n    private List&lt;Score&gt; scores;\n\n    public ObjectId getId() {\n        return id;\n    }\n\n    public void setId(ObjectId id) {\n        this.id = id;\n    }\n\n    public Double getStudentId() {\n        return studentId;\n    }\n\n    public void setStudentId(Double studentId) {\n        this.studentId = studentId;\n    }\n\n    public Integer getClassId() {\n        return classId;\n    }\n\n    public void setClassId(Integer classId) {\n        this.classId = classId;\n    }\n\n    public List&lt;Score&gt; getScores() {\n        return scores;\n    }\n\n    public void setScores(List&lt;Score&gt; scores) {\n        this.scores = scores;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Grade grade = (Grade) o;\n        return id.equals(grade.id) &amp;&amp; studentId.equals(grade.studentId)\n                &amp;&amp; classId.equals(grade.classId) &amp;&amp; scores.equals(grade.scores);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode() + studentId.hashCode() + classId.hashCode() + scores.hashCode();\n    }\n}\n</code></pre> <pre><code>public class Score {\n    private String type;\n    private Double score;\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public Double getScore() {\n        return score;\n    }\n\n    public void setScore(Double score) {\n        this.score = score;\n    }\n\n    @Override\n    public String toString() {\n        return \"Score{\" +\n                \"type='\" + type + '\\'' +\n                \", score=\" + score +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Score score1 = (Score) o;\n        return score1.type.equals(type) &amp;&amp; score1.score.equals(score);\n    }\n\n    @Override\n    public int hashCode() {\n        return type.hashCode() + score.hashCode();\n    }\n}\n</code></pre> <p>Utilizamos la anotaci\u00f3n <code>BsonProperty(name)</code> para hacer coincidir un atributo de la clase con una propiedad del documento, que tienen nombres diferentes.</p> <p>Una vez definida la clase POJO, podemos empezar a realizar conexiones. En primer lugar, crearemos la conexi\u00f3n, pero en este caso en lugar de usar la ruta por defecto (tal y como hemos hecho hasta hora), necesitaremos especificarle una configuraci\u00f3n POJO, es decir, debemos incluirle una configuraci\u00f3n de codificaci\u00f3n de los POJO, adem\u00e1s de una codificaci\u00f3n para los tipos de Java:</p> <pre><code>ConnectionString string = new ConnectionString(URI);\nCodecRegistry pojoCodeRegistry = CodecRegistries.fromProviders(PojoCodecProvider.builder().automatic(true).build());\nCodecRegistry codecRegistry = CodecRegistries.fromRegistries(MongoClientSettings.getDefaultCodecRegistry(), pojoCodeRegistry);\nMongoClientSettings settings = MongoClientSettings.builder()\n        .applyConnectionString(string)\n        .codecRegistry(codecRegistry)\n        .build();\n\nMongoClient client = MongoClients.create(settings);\n</code></pre> <p>Analicemos cada una de las l\u00edneas del ejemplo anterior:</p> <ul> <li>La primera l\u00ednea crea una cadena de conexi\u00f3n, que ser\u00e1 necesaria para crear los settings del cliente de MongoDB.</li> <li>La segunda l\u00ednea configura un registro de codificaci\u00f3n para las clases POJOs de forma autom\u00e1tica. De esta forma, se puede aceptar cualquier clase POJO.</li> <li>La tercera l\u00ednea a\u00f1ade a la configuraci\u00f3n de codificaci\u00f3n los registros de codificaci\u00f3n por defecto para los tipos de Java, adem\u00e1s para las clases POJOs.</li> <li>En la cuarta l\u00ednea creamos la configuraci\u00f3n para el cliente de MongoDB, el cual le aplicamos la cadena de conexi\u00f3n (debe de ser de tipo <code>ConnectionString</code>, de ah\u00ed, que en la primera l\u00ednea se cree la cadena con dicha clase), e indic\u00e1ndole los registro de codificaci\u00f3n.</li> <li>Por \u00faltimo, creamos el cliente MongoDB con toda la configuraci\u00f3n realizada.</li> </ul> <p>Una vez creado nuestro cliente, podemos acceder a la base de datos y a nuestra colecci\u00f3n, tal y como hemos hecho hasta hora. Sin embargo, en lugar de utilizar el tipo gen\u00e9rico <code>Document</code> para la clase <code>MongoCollection</code>, se usar\u00eda como tipo gen\u00e9rico el tipo de la clase creada, adem\u00e1s que al m\u00e9todo <code>getCollection</code> se le indica tambi\u00e9n la clase a la que debe parsear:</p> <pre><code>MongoDatabase db = client.getDatabase(DB);\nMongoCollection&lt;Grade&gt; collection = db.getCollection(COLLECTION, Grade.class);\n</code></pre> <p>Para poder insertar un nuevo objeto, se crea el objeto de dicha clase y se inserta haciendo uso del m\u00e9todo <code>insertOne</code>. Si por el contrario, se quiere insertar varios elementos de dicha clase, se crea una lista de con los objetos de la clase y se inserta con el el m\u00e9todo <code>insertMany</code>. El resto de operaciones, funcionar\u00eda exactamente igual, pero en lugar de usar objetos de clase <code>Document</code>, se usar\u00eda objetos de la clase <code>Grade</code>. Ejemplo completo:</p> <pre><code>ConnectionString string = new ConnectionString(URI);\nCodecRegistry pojoCodeRegistry = fromProviders(PojoCodecProvider.builder().automatic(true).build());\nCodecRegistry codecRegistry = fromRegistries(MongoClientSettings.getDefaultCodecRegistry(), pojoCodeRegistry);\nMongoClientSettings settings = MongoClientSettings.builder()\n        .applyConnectionString(string)\n        .codecRegistry(codecRegistry)\n        .build();\n\nMongoClient client = MongoClients.create(settings);\n\nMongoDatabase db = client.getDatabase(DB);\nMongoCollection&lt;Grade&gt; collection = db.getCollection(COLLECTION, Grade.class);\n\nScore score = new Score(\"exam\", 7.5);\n\nGrade grade = new Grade(10003.0, 10, List.of(score));\n\n\ncollection.insertOne(grade);\n\nGrade findGrade = collection.find(eq(\"student_id\", 10003d)).first();\nSystem.out.println(\"Grade found:\\t\" + grade);\n\nif(findGrade == null){\n    System.out.println(\"No se encuentra\");\n    return;\n}\n\nList&lt;Score&gt; newScores = new ArrayList&lt;&gt;(findGrade.getScores());\nScore newScore = new Score(\"exam\", 42d);\nnewScores.add(newScore);\ngrade.setScores(newScores);\nDocument filterByGradeId = new Document(\"_id\", grade.getId());\nFindOneAndReplaceOptions returnDocAfterReplace = new FindOneAndReplaceOptions()\n        .returnDocument(ReturnDocument.AFTER);\nGrade updatedGrade = collection.findOneAndReplace(filterByGradeId, grade, returnDocAfterReplace);\nSystem.out.println(\"Grade replaced:\\t\" + updatedGrade);\n\nSystem.out.println(collection.deleteOne(filterByGradeId));\n\nclient.close();\n</code></pre>"},{"location":"bloque_iv/tema_18/page-7/","title":"Proyecto","text":"<p>Se quiere crear una base de datos y un sistema gestor de la misma para trabajar con los ex\u00e1menes tipo test de una universidad de prestigio. Para ello, se quiere almacenar informaci\u00f3n de los siguientes datos:</p> Ex\u00e1menesPreguntasRespuestas <p>Se desea almacenar informaci\u00f3n de los ex\u00e1menes que se van a realizar, almacenando los siguientes datos:</p> <ul> <li>T\u00edtulo del examen (por ejemplo, \"Examen parcial del patr\u00f3n MVC\").</li> <li>Materia a la que va dirigida el examen.</li> <li>Profesor/a titular del examen.</li> <li>Tiempo del examen (la ley obliga que un examen no pueda ser superior a 2 horas y media).</li> <li>Puntuaci\u00f3n m\u00e1xima a obtener.</li> </ul> <p>De las preguntas solo se desea guardar su t\u00edtulo y su puntuaci\u00f3n. Has de tener en cuenta que una pregunta solo puede pertenecer a un examen. Dentro de un mismo examen. Tambi\u00e9n se desea saber si la pregunta es de m\u00faltiple opci\u00f3n o no.</p> <p>De las respuestas se desea conocer, el valor de la respuesta como un indicador de s\u00ed la respuesta es correcta o no.</p> Ejercicio 1 <p>Una vez definida la estructura de los datos, realiza el modelo entidad relaci\u00f3n y el modelo de datos. Adem\u00e1s crea las clases POJOs necesarias haciendo uso del diagrama de clases.</p> Ejercicio 2 <p>Crea la estructura de datos nuestra aplicaci\u00f3n haciendo uso del patr\u00f3n Repository.</p> Ejercicio 3 <p>Crea un men\u00fa que tenga las siguientes opciones:</p> <ol> <li>Crear un examen. Debe solicitar los datos necesarios del examen al usuario, crear e insertarlo en la base de datos.</li> <li>A\u00f1adir preguntas a un examen. El usuario deber\u00e1 insertar todas las preguntas que sean necesarias hasta que indique como t\u00edtulo de la pregunta que ya no desea insertar ninguna pregunta m\u00e1s (haciendo uso de la palabra exit). Para insertar una pregunta se le solicitar\u00e1 al usuario:<ul> <li>La informaci\u00f3n relevante para la pregunta. Debes tener en cuenta la puntuaci\u00f3n del examen, en caso de que la nota supere el m\u00e1ximo esperado, dejando como nota la cantidad necesaria hasta llegar al m\u00e1ximo sin importar lo indicado por el usuario, es decir, si el examen tiene una puntuaci\u00f3n m\u00e1xima de 10 y tiene 3 preguntas con 3 puntos cada una, la pregunta a insertar no puede superar el 1, en caso de hacerlo, har\u00e1 caso omiso, y escribir\u00e1 1.</li> <li>El n\u00famero de respuestas a introducir y el valor de la respuesta, teniendo en cuenta que si la pregunta es de una sola respuesta correcta y se inserta m\u00e1s respuestas correctas, solo tomar\u00e1 como correcta, la primera de ellas.</li> <li>El examen a insertar.</li> </ul> </li> <li>Consultar examen. Podr\u00e1 ver las pregunta (sin respuestas) del examen solicitado por el usuario.</li> <li>Actualizar pregunta. Podr\u00e1 modificar preguntas del examen solicitado. Solo puede modificar el t\u00edtulo y la puntuaci\u00f3n.</li> <li>Eliminar pregunta. Eliminar\u00e1 la pregunta indicada.</li> <li>Consultar pregunta. Mostrar\u00e1 las respuestas del examen solicitado.</li> <li>Actualizar respuesta. Podr\u00e1 actualizar una respuesta de la pregunta solicitada, pudiendo modificar tanto el valor de la respuesta como si es correcta o no.</li> <li>A\u00f1adir respuesta. Solicitar\u00e1 informaci\u00f3n de una respuesta y la introducir\u00e1 en la pregunta.</li> <li>Eliminar respuesta. Eliminar\u00e1 la respuesta de la pregunta eliminada.</li> <li>Ver examen completo. Se le solicitar\u00e1 el usuario el examen a ver y el modo de verlo, alumno o profesor. Si elige la opci\u00f3n modo alumno, mostrar\u00e1 el examen imprimido con el formato (indicado despu\u00e9s), mientras que si el usuario elige el modo profesor, mostrar\u00e1 el examen con las respuestas correctas indicadas en verdes.</li> <li>Realizar back up. Se almacenar\u00e1 en un fichero JSON, una copia de seguridad de la base de datos. </li> <li>Imprimir examen. Imprimir\u00e1 el examen en su formato en un fichero de texto. Ten en cuenta, que el examen no ser\u00e1 imprimido si le faltan preguntas o si una pregunta no tiene respuestas. </li> </ol>"},{"location":"bloque_v/tema_19/page-1/","title":"1 Programa vs Proceso","text":""},{"location":"bloque_v/tema_19/page-1/#aplicacion","title":"Aplicaci\u00f3n","text":"<p>A simple vista, parece que con los t\u00e9rminos aplicaci\u00f3n, ejecutable y proceso, hacen referencia al mismo concepto, pero en realidad no es as\u00ed.</p> <p>En general, conocemos como software el conjunto de programas inform\u00e1ticos que se ejecutan sobre el hardware del equipo.</p> <p>Programa</p> <p>Un programa es el conjunto de instrucciones que ejecutadas en un ordenador realizar\u00e1n una tarea o ayudar\u00e1n al usuario a realizarla.</p> <p>Este conjunto de programas se puede subdividir en dos grandes grupos:</p> <ul> <li>Los programas para la gesti\u00f3n del hardware: sistema operativo, controladores de dispositivos, etc.</li> <li>Las aplicaciones de usuario, que son los que resuelven problemas espec\u00edficos del usuario, como por ejemplo editar una imagen, enviar un e-mail, etc.</li> </ul> <p>Aplicaci\u00f3n</p> <p>Una aplicaci\u00f3n es un tipo de programa inform\u00e1tico, dise\u00f1ado como herramienta para resolver de manera autom\u00e1tica un problema espec\u00edfico del usuario.</p> <p>Desde el punto de vista de los sistemas operativos, llamamos programa a la representaci\u00f3n en disco de una aplicaci\u00f3n, que contiene tanto el c\u00f3digo como los datos que maneja.</p> <p>Una aplicaci\u00f3n es un tipo de programa inform\u00e1tico, dise\u00f1ado como herramienta para resolver de manera autom\u00e1tica un problema espec\u00edfico del usuario.</p>"},{"location":"bloque_v/tema_19/page-1/#ejecutable","title":"Ejecutable","text":"<p>Nosotros, como programadores y programadoras, creamos un programa, escribiendo su c\u00f3digo fuente. Con ayuda de un compilador, obtenemos su c\u00f3digo binario o interpretado. Este c\u00f3digo binario o interpretado, lo guardamos en un fichero. Este fichero, es un fichero ejecutable.</p> <p>Ejecutable</p> <p>Un ejecutable es un fichero que contiene el c\u00f3digo binario o interpretado que puede ser ejecutado en un ordenador.</p> <p>En sistemas operativos Windows, podemos reconocer un fichero ejecutable porque su extensi\u00f3n suele ser <code>.exe</code>. En otros sistemas operativos, como los basados en GNU/Linux, los ficheros ejecutables se identifican como ficheros que tienen activado su permiso de ejecuci\u00f3n y no tienen que tener una extensi\u00f3n determinada.</p> <p>Seg\u00fan el tipo de c\u00f3digo que contenga, podemos clasificar ejecutables en:</p> <ul> <li>Binarios: Formados por un conjunto de instrucciones que directamente son ejecutadas por el procesador del ordenador. Este c\u00f3digo se obtiene al compilar el c\u00f3digo fuente de un programa y se guarda en un fichero ejecutable. Este c\u00f3digo s\u00f3lo se ejecutar\u00e1 correctamente en equipos cuya plataforma sea compatible con aquella para la que ha sido compilado (no es multiplataforma).</li> <li>Interpretados. C\u00f3digo que suele tratarse como un ejecutable, pero no es c\u00f3digo binario (m\u00e1quina), sino otro tipo de c\u00f3digo, como por ejemplo el bytecode de Java. Est\u00e1 formado por c\u00f3digos de operaci\u00f3n que tomar\u00e1 el int\u00e9rprete, en el caso de Java la m\u00e1quina virtual Java o JRE. Ese int\u00e9rprete ser\u00e1 el encargado de traducirlos al lenguaje m\u00e1quina que ejecutar\u00e1 el procesador. El c\u00f3digo interpretado es m\u00e1s susceptible de ser multiplataforma o independiente de la m\u00e1quina f\u00edsica en la que se haya compilado.</li> </ul> <p>Un tipo especial de ejecutables interpretados, son los llamados scripts. Estos ficheros, contienen las instrucciones que ser\u00e1n ejecutadas una detr\u00e1s de otra por el int\u00e9rprete. Se diferencian de otros lenguajes interpretados porque no son compilados. Por lo que los podremos abrir y ver el c\u00f3digo que contienen con un editor de texto plano (cosa que no pasa con los binarios e interpretados compilados). Los int\u00e9rpretes de este tipo de lenguajes se suelen llamar motores. Ejemplos de lenguajes de script son JavaScript, PHP, Python, ficheros .BAT en MS-DOS, Powershell en Windows, bash scripts en GNU/Linux, etc.</p> <p>Las librer\u00edas, por su parte, contienen c\u00f3digo ejecutable que es de utilidad para varios programas, que pueden invocar las funciones que contienen. El conjunto de funciones que incorpora una librer\u00eda suele ser altamente reutilizable y \u00fatil para los programadores, evitando que tengan que reescribir una y otra vez el c\u00f3digo que realiza la misma tarea.</p>"},{"location":"bloque_v/tema_19/page-1/#proceso","title":"Proceso","text":"<p>Desde el punto de vista del sistema operativo, un programa no deja de ser un conjunto de ficheros almacenados en un disco. Entre dichos archivos, al menos uno de ellos ser\u00e1 un archivo ejecutable, pero no deja de ser un archivo en disco.</p> <p>Sin embargo, cuando ejecutamos el fichero ejecutable de un programa aparece un nuevo concepto, el de proceso.</p> <p>Proceso</p> <p>Podr\u00edamos definir proceso como la representaci\u00f3n en el sistema operativo de un programa en ejecuci\u00f3n.</p> <p>Un proceso no se refiere \u00fanicamente al c\u00f3digo y a los datos gestionados por el programa correspondiente, sino tambi\u00e9n toda la informaci\u00f3n necesaria para que el sistema operativo pueda ejecutar el programa.</p> <p>Siempre que lancemos la ejecuci\u00f3n de un programa, se crear\u00e1, al menos, un proceso nuevo en nuestro sistema.</p> <p>Debemos tener en cuenta que podemos tener dos procesos distintos que provengan del mismo programa. Por ejemplo, si ejecutamos el mismo programa dos veces, a trav\u00e9s de su fichero ejecutable, tendremos dos procesos distintos, con un contador, imagen de memoria y estado del procesador diferentes, aunque ambos procesos est\u00e9n basados en el mismo programa.</p> <p>Otra posibilidad es que un programa, al ponerse en ejecuci\u00f3n, de lugar a m\u00e1s de un proceso, cada uno de ellos ejecutando una parte del programa. Por ejemplo, al ejecutar el navegador puede dar lugar a m\u00e1s de un proceso: uno que controla la interacci\u00f3n del usuario con la interfaz, otro que lleva a cabo las peticiones web solicitadas por el usuario, etc.</p>"},{"location":"bloque_v/tema_19/page-1/#demonios-y-servicios","title":"Demonios y servicios","text":"<p>Demonio</p> <p>Llamamos demonio a un proceso que est\u00e1 ejecut\u00e1ndose continuamente en segundo plano, sin interactuar con el usuario. Se dedican normalmente a ofrecer un servicio b\u00e1sico al sistema. De hecho, en algunos sistemas operativos, como Windows, a los demonios se les denomina servicios.</p> <p>Un servicio es un proceso que, normalmente, es cargado durante el arranque del sistema operativo. Recibe el nombre de servicio, ya que es un proceso que queda a la espera de que otro le pida que realice una tarea. Por ejemplo, tenemos el servicio de impresi\u00f3n con su t\u00edpica cola de trabajos a imprimir. Nuestra impresora imprime todo lo que recibe del sistema. El servicio de impresi\u00f3n, es el encargado de ir enviando los datos de forma correcta a la impresora para que el resultado sea el esperado. Adem\u00e1s, las impresoras, no siempre tienen suficiente memoria para guardar todos los datos de impresi\u00f3n de un trabajo completo, por lo que el servicio de impresi\u00f3n se los dar\u00e1 conforme vaya necesit\u00e1ndolos. Cuando finalice cada trabajo, puede notific\u00e1rselo al usuario. Si en la cola de impresi\u00f3n, no hay trabajos pendientes, el servicio de impresi\u00f3n quedar\u00e1 a la espera y podr\u00e1 avisar a la impresora para que quede en standby.</p> <p>Normalmente hay muchos servicios activos o en ejecuci\u00f3n en el sistema, y no todos son servicios del sistema operativo, tambi\u00e9n hay servicios de aplicaci\u00f3n, instalados por el usuario y que pueden lanzarse al arrancar el sistema operativo o no, dependiendo de su configuraci\u00f3n.</p>"},{"location":"bloque_v/tema_19/page-2/","title":"2 Computaci\u00f3n Concurrente","text":""},{"location":"bloque_v/tema_19/page-2/#computacion-concurrente-y-multitarea","title":"Computaci\u00f3n concurrente y multitarea","text":"<p>Como sabemos, en nuestro sistema operativo, se est\u00e1n ejecutando al mismo tiempo muchos procesos. Por ejemplo, podemos estar escuchando m\u00fasica con nuestro reproductor multimedia favorito, y al mismo tiempo tener abierto el navegador web, o cualquier otra aplicaci\u00f3n. De igual manera, se estar\u00e1n ejecutando tambi\u00e9n procesos del propio sistema operativo.</p> <p>Computaci\u00f3n concurrente</p> <p>Llamamos computaci\u00f3n concurrente al hecho de que varios procesos se est\u00e9n ejecutando concurrentemente en el sistema operativo.</p> <p>Se dice que dos procesos son concurrentes cuando la primera instrucci\u00f3n de uno de ellos se ejecuta despu\u00e9s de la primera instrucci\u00f3n del otro y antes de la \u00faltima. Es decir, cuando existe un solapamiento en la ejecuci\u00f3n de sus instrucciones, no siendo estrictamente necesario que se est\u00e9n ejecutando a la vez en un instante dado.</p> <p>Multitarea</p> <p>Desde el punto de vista del usuario, la computaci\u00f3n concurrente es conocida como multitarea, ya que permite al usuario estar realizando varias tareas de manera concurrente.</p> <p>Todos los sistema operativos actuales, como Windows, MacOS o Linux, son multitarea.</p>"},{"location":"bloque_v/tema_19/page-2/#paralelismo-y-multiprogramacion","title":"Paralelismo y multiprogramaci\u00f3n","text":"<p>Para entender la computaci\u00f3n concurrente lo primero que debemos hacer es comprender la diferencia entre paralelismo y multiprogramaci\u00f3n.</p> <p>Paralelismo</p> <p>Para que exista paralelismo es necesario que el sistema disponga de al menos dos n\u00facleos de procesamiento, ya sean dentro de un \u00fanico procesador, o en varios procesadores, que ejecuten de manera simult\u00e1nea (paralela) ese mismo n\u00famero de instrucciones, una en cada n\u00facleo.</p> <p>Pero entonces, \u00bfc\u00f3mo podemos lograr la computaci\u00f3n concurrente si s\u00f3lo disponemos de un \u00fanico n\u00facleo de procesamiento? Mediante la t\u00e9cnica conocida como multiprogramaci\u00f3n.</p> <p>Multiprogramaci\u00f3n</p> <p>La multiprogramaci\u00f3n consiste en asignar por turnos el n\u00facleo de procesamiento durante un corto periodo de tiempo (milisegundos) a cada uno de los procesos en ejecuci\u00f3n, siguiendo un determinado m\u00e9todo de planificaci\u00f3n.</p> <p>En cada cambio de turno el sistema lleva a cabo el denominado cambio de contexto, que consiste en guardar la informaci\u00f3n del proceso saliente (su contador, su imagen y el estado de los registro del procesador) y recuperar la informaci\u00f3n correspondiente del proceso entrante.</p> <p>Debemos tener en cuenta que la t\u00e9cnica de multiprogramaci\u00f3n no mejora el tiempo de ejecuci\u00f3n global de los procesos, sino que lo empeora, ya que hay que tener en cuenta el tiempo necesario para llevar a cabo los m\u00faltiples cambios de contexto. Como contrapartida, la multiprogramaci\u00f3n consigue la percepci\u00f3n para el usuario de que los programas se est\u00e1n ejecutando simult\u00e1neamente.</p> <p>Cuando varios procesos se ejecutan concurrentemente puede haber procesos que colaboren para un determinado fin mientras que otros compitan por los recursos del sistema. Incluso aquellos procesos que colaboran deber\u00e1n competir a la hora de obtener tiempo de procesador. Para llevar a cabo las tareas de colaboraci\u00f3n y competencia por los recursos se hace necesaria la introducci\u00f3n de mecanismos de comunicaci\u00f3n y sincronizaci\u00f3n entre procesos.</p>"},{"location":"bloque_v/tema_19/page-2/#multiprocesamiento-y-procesamiento-distribuido","title":"Multiprocesamiento y procesamiento distribuido","text":"<p>Dentro de los sistemas con paralelismo, es decir con varios n\u00facleos de procesamiento, tenemos dos tipos:</p> <p>Multiprocesamiento</p> <p>En los sistemas con varios n\u00facleos de procesamiento hablaremos de multiprocesamiento cuando \u00e9stos compartan memoria.</p> <p>Los sistemas de multiprocesamiento se caracterizan porque los procesos que se est\u00e9n ejecutando en los diferentes n\u00facleos pueden comunicarse entre as\u00ed a trav\u00e9s de la memoria com\u00fan.</p> <p>Procesamiento distribuido</p> <p>En los sistemas con varios n\u00facleos de procesamiento que NO compartan memoria hablaremos de procesamiento distribuido.</p> <p>En los sistemas de procesamiento distribuido la comunicaci\u00f3n entre las procesos en ejecuci\u00f3n NO se podr\u00e1 llevar a cabo a trav\u00e9s de la memoria, ya que no poseen una memoria com\u00fan, por lo que ser\u00e1 necesario usar obligatoriamente otros mecanismos de comunicaci\u00f3n m\u00e1s complejos. Un ejemplo t\u00edpico de este tipo de sistema es la cooperaci\u00f3n de varios ordenadores distribuidos en red en la ejecuci\u00f3n de una serie de tareas. Cada uno de estos ordenadores posee su propio procesador y su propia memoria.</p>"},{"location":"bloque_v/tema_19/page-3/","title":"3 Procesos en el sistema operativo","text":""},{"location":"bloque_v/tema_19/page-3/#gestion-de-procesos-en-multiprogramacion","title":"Gesti\u00f3n de procesos en multiprogramaci\u00f3n","text":"<p>Si el sistema tiene que repartir el uso del microprocesador entre los distintos procesos, \u00bfqu\u00e9 le sucede a un proceso cuando no se est\u00e1 ejecutando? Y, si un proceso est\u00e1 esperando datos, \u00bfpor qu\u00e9 el equipo hace otras cosas mientras que un proceso queda a la espera de datos?</p> <p>Los procesos nuevos van entrando en una cola de procesos activos, a la espera de que llegue su turno y el sistema operativo les conceda el uso de la CPU.</p> <p>Cuando llega su turno, el sistema operativo concede la CPU al proceso durante un tiempo determinado y equitativo, denominado quantum.</p> <p>Cuando un proceso que consume su quantum, el proceso es pausado y enviado al final de la cola.</p> <p> Figura 1 - Estados de un proceso</p> <p>Si, teniendo asignada la CPU, un un proceso finaliza su ejecuci\u00f3n, sale del sistema de gesti\u00f3n de procesos, liberando la CPU.</p> <p>Si, teniendo asignada la CPU, el proceso realiza una operaci\u00f3n de E/S, como obtener leer o escribir de un archivo o una entrada de datos que deba suministrar el usuario, el proceso queda bloqueado hasta que haya finalizado dicha operaci\u00f3n de E/S, liberando la CPU.</p> <p>El proceso es bloqueado porque los dispositivos de E/S son mucho m\u00e1s lentos que la CPU, por lo que, mientras que uno de ellos est\u00e1 esperando una E/S, se puede asignar la CPU a otros procesos para que ejecuten sus instrucciones.</p> <p>Cuando termina la operaci\u00f3n de E/S que tenga un proceso bloqueado, el sistema operativo volver\u00e1 a colocar al proceso en la cola de procesos activos, para que recoja los datos y contin\u00fae con su tarea cuando se le conceda su quantum.</p> <p>Todo proceso en ejecuci\u00f3n, tiene que estar cargado en la RAM f\u00edsica del equipo o memoria principal, as\u00ed como todos los datos que necesite.</p> <p>Cuando la memoria RAM del equipo est\u00e1 llena, algunos procesos deber\u00e1n pasar a disco para dejar espacio en RAM que permita la ejecuci\u00f3n de otros procesos. A esta operaci\u00f3n se le conoce como suspender un proceso.</p> <p>Hay procesos en el equipo cuya ejecuci\u00f3n es cr\u00edtica para el sistema, como por ejemplo los correspondientes al propio sistema operativo, por lo que estos procesos tendr\u00e1n prioridad frente a los procesos de usuario.</p>"},{"location":"bloque_v/tema_19/page-3/#creacion-de-un-proceso","title":"Creaci\u00f3n de un proceso","text":"<p>Cuando se lanza la ejecuci\u00f3n de un ejecutable, el cargador de procesos del sistema operativo es el encargado de crear el proceso correspondiente. Para ello, en primer lugar reserva para el proceso un determinado espacio en la memoria RAM del sistema, que recibe el nombre de espacio de direcciones de memoria del proceso. En dicho espacio de memoria se copia desde el fichero ejecutable situado en disco todas las instrucciones de la aplicaci\u00f3n, y se determina una determinada cantidad de espacio de memoria para los datos de la aplicaci\u00f3n y su pila de llamadas.</p> <p> Figura 2 - Proceso en memoria</p> <p>Un proceso, durante su ejecuci\u00f3n, no podr\u00e1 hacer referencia a direcciones que se encuentren fuera de su espacio de memoria; si lo intentara, el sistema operativo lo detectar\u00e1 y generar\u00e1 una excepci\u00f3n (produciendo, por ejemplo, los t\u00edpicos pantallazos azules de Windows).</p> <p>Despu\u00e9s, el cargador crea una estructura de datos para proceso, denominada PCB (Process Control Block, Bloque de Control de Proceso). La informaci\u00f3n del PCB, es \u00fanica para cada proceso y permite controlarlo. Esta informaci\u00f3n, tambi\u00e9n la utilizar\u00e1 el planificador (scheduler) del sistema operativo.</p> <p>Entre otros datos, el PCB estar\u00e1 formado por:</p> <ul> <li>Identificador del proceso o PID. Es un n\u00famero \u00fanico para cada proceso.</li> <li>Estado actual del proceso: en ejecuci\u00f3n, listo, bloqueado, suspendido, finalizando.</li> <li>Espacio de direcciones de memoria: d\u00f3nde comienza la zona de memoria reservada para el proceso y cu\u00e1l es su tama\u00f1o.</li> <li>Informaci\u00f3n para la planificaci\u00f3n: prioridad, quantum, estad\u00edsticas, etc.</li> <li>Informaci\u00f3n para el cambio de contexto, es decir para poder cambiar la ejecuci\u00f3n de un proceso a otro. Incluye:</li> <li>El contador del programa: Indica la instrucci\u00f3n por donde se est\u00e1 ejecutando el proceso.</li> <li>El estado del procesador: Valores actuales de los registros del procesador sobre el que se est\u00e1 ejecutando el proceso.</li> <li>El puntero de pila de llamadas: En cada instante apunta a la parte superior de la pila del proceso en ejecuci\u00f3n.</li> <li>Recursos utilizados. Ficheros abiertos, conexiones, etc.</li> </ul>"},{"location":"bloque_v/tema_19/page-3/#planificacion-de-procesos","title":"Planificaci\u00f3n de procesos","text":"<p>Una vez que el proceso ya est\u00e1 cargado en memoria, ser\u00e1 el planificador (scheduler) el encargado de tomar las decisiones relacionadas con la ejecuci\u00f3n de los procesos.</p> <p>Planificador</p> <p>El planificador (scheduler) es un proceso del sistema operativo encargado de decidir qu\u00e9 proceso se ejecuta en cada momento y durante cu\u00e1nto tiempo.</p> <p>La pol\u00edtica en la toma de decisiones del planificador se denomina algoritmo de planificaci\u00f3n (scheduling algorithm). Existen distintos tipos de algoritmos de planificaci\u00f3n (que estudiasteis en en el curso anterior), con distintas caracter\u00edsticas, pero todos buscan conciliar los siguientes objetivos lo mejor posible:</p> <ul> <li>Equidad: que todos los procesos deben poder ejecutarse.</li> <li>Eficacia: que la CPU se mantenga ocupada el 100% del tiempo.</li> <li>Tiempo de respuesta: que el tiempo de respuesta al usuario sea el m\u00ednimo posible.</li> <li>Tiempo de finalizaci\u00f3n: que el tiempo de finalizaci\u00f3n del proceso sea el m\u00ednimo posible.</li> <li>Rendimiento: que el n\u00famero de tareas procesadas en una determinada unidad de tiempo sea el m\u00e1ximo posible.</li> </ul> <p>Una vez que el algoritmo de planificaci\u00f3n ha decidido el siguiente proceso que debe usar la CPU, entra en acci\u00f3n el m\u00f3dulo conocido como dispatcher (despachador).</p> <p>Dispatcher</p> <p>El dispatcher (despachador) del el m\u00f3dulo del planificador que realiza el cambio de contexto, de manera que el proceso elegido por el planificador pueda hacer uso de la CPU.</p> <p>El dispatcher debe ser lo m\u00e1s r\u00e1pido posible en realizar el cambio de contexto, ya que durante dicho tiempo, conocido como latencia, la CPU no est\u00e1 siendo usada.</p>"},{"location":"bloque_v/tema_19/page-3/#herramientas-de-gestion-de-procesos","title":"Herramientas de gesti\u00f3n de procesos","text":"<p>Todos los sistemas operativos con interfaz gr\u00e1fica disponen de alguna aplicaci\u00f3n de gesti\u00f3n de procesos. En Windows tenemos el Administrador de tareas, en Linux el Monitor del sistema y en MacOS Monitor de actividad. Todos son bastante parecidos, y nos ofrecen funcionalidad similares:</p> <ul> <li>Listado de todos los procesos que se encuentran activos en el sistema, mostrando su PID, usuario y ubicaci\u00f3n de su fichero ejecutable.</li> <li>Posibilidad de finalizar procesos.</li> <li>Informaci\u00f3n sobre el uso de CPU, memoria principal y virtual, red, \u2026</li> <li>Posibilidad de cambiar la prioridad de ejecuci\u00f3n de los procesos</li> </ul> <p>Sin embargo, es interesante que conozcamos los comandos (\u00f3rdenes) de consola para la gesti\u00f3n de procesos en los distintos sistemas operativos.</p> <p>As\u00ed, en Windows tenemos:</p> <ul> <li><code>tasklist</code>: para listar los procesos presentes en el sistema. Mostrar\u00e1 el nombre del ejecutable, su correspondiente identificador de proceso (PID) y el porcentaje de uso de memoria, entre otros datos.</li> <li><code>taskkill pid</code>: que nos permite finalizar (matar) el proceso especificado.</li> </ul> <p>En sistemas Linux, tenemos los siguiente comandos relacionados con los procesos:</p> <ul> <li><code>ps</code>: Lista los procesos presentes en el sistema. Con la opci\u00f3n <code>aux</code> muestra todos los procesos del sistema independientemente del usuario que los haya lanzado.</li> <li><code>pstree</code>: Muestra un listado de procesos en forma de \u00e1rbol, mostrando qu\u00e9 procesos han creado otros. Con la opci\u00f3n <code>AGu</code> construir\u00e1 el \u00e1rbol utilizando l\u00edneas gu\u00eda y mostrar\u00e1 el nombre de usuario propietario del proceso.</li> <li><code>kill</code>: Manda se\u00f1ales a los procesos. La se\u00f1al <code>-9</code>, matar\u00e1 al proceso. Se utiliza <code>kill -9 pid</code>.</li> <li><code>killall</code>: Mata procesos por su nombre. Se utiliza como <code>killall nombreDeAplicacion</code>.</li> <li><code>nice</code>: Cambia la prioridad de un proceso. <code>nice -n 5 comando</code> ejecutar\u00e1 el comando con una prioridad 5. Por defecto la prioridad es 0. Las prioridades est\u00e1n entre -20 (m\u00e1s alta) y 19 (m\u00e1s baja).</li> </ul>"},{"location":"bloque_v/tema_19/page-4/","title":"4 T\u00e9cnicas de programaci\u00f3n concurrente","text":""},{"location":"bloque_v/tema_19/page-4/#tecnicas-de-programacion-relacionadas-con-la-computacion-concurrente","title":"T\u00e9cnicas de programaci\u00f3n relacionadas con la computaci\u00f3n concurrente","text":"<p>La programaci\u00f3n concurrente es la disciplina que se encarga del estudio de las notaciones que permiten subdividir un programa en distintos procesos que se ejecuten concurrentemente en el sistema, as\u00ed como las t\u00e9cnicas para resolver los problemas inherentes a la ejecuci\u00f3n concurrente de \u00e9stos, que son b\u00e1sicamente comunicaci\u00f3n y sincronizaci\u00f3n. Como puede intuirse, el trabajar con procesos concurrentes va a a\u00f1adir complejidad a la tarea de programar.</p> <p>La programaci\u00f3n paralela es un tipo de programaci\u00f3n concurrente en el que se crean programas especialmente dise\u00f1ados para ejecutarse en sistemas con multiprocesamiento, esto es, en los que existen varios n\u00facleos de procesamiento y \u00e9stos comparten memoria.</p> <p>La programaci\u00f3n distribuida es un tipo de programaci\u00f3n concurrente en el que se crean programas especialmente dise\u00f1ados para ejecutarse en sistemas de procesamiento distribuido, esto es, en los que existen varios n\u00facleos de procesamiento que NO comparten memoria y est\u00e1n conectados en red.</p> <p>Warning</p> <p>Durante este curso estudiaremos la programaci\u00f3n concurrente, y de manera muy somera la programaci\u00f3n paralela. No trataremos nada sobre programaci\u00f3n distribuida.</p>"},{"location":"bloque_v/tema_19/page-4/#interaccion-entre-procesos-concurrentes","title":"Interacci\u00f3n entre procesos concurrentes","text":"<p>En un sistema con multiprogramaci\u00f3n, podemos distinguir los siguientes tipos b\u00e1sicos de interacci\u00f3n entre procesos concurrentes:</p> <ul> <li>Independientes: los procesos s\u00f3lo interfieren en el uso de la CPU.</li> <li>Cooperantes: Un proceso genera la informaci\u00f3n o proporciona un servicio que otro necesita.</li> <li>Competidores: Procesos que necesitan usar los mismos recursos de forma exclusiva.</li> </ul> <p>En el segundo y tercer caso, necesitamos componentes que nos permitan establecer acciones de sincronizaci\u00f3n y comunicaci\u00f3n entre los procesos, de manera que los procesos sigan funcionando de forma correcta.</p>"},{"location":"bloque_v/tema_19/page-5/","title":"5 Orden en Ejecuci\u00f3n","text":""},{"location":"bloque_v/tema_19/page-5/#orden-en-ejecucion","title":"Orden en Ejecuci\u00f3n","text":"<p>En un programa secuencial el orden de ejecuci\u00f3n de las instrucciones est\u00e1 establecido por el c\u00f3digo del mismo y los datos que maneja. Es decir, si ejecutamos varias veces el mismo programa con los mismos datos, sus instrucciones se ejecutar\u00e1n en el mismo orden. A esto se le conoce como orden total.</p> <p>Sin embargo, los programas concurrentes tiene un orden parcial. Si un programa tiene varios procesos concurrentes, el orden en el que se intercala la ejecuci\u00f3n de dichos procesos NO puede ser establecido de antemano, ya que depende de la planificaci\u00f3n del procesador y de a qu\u00e9 proceso se le conceda en cada momento. Dentro de cada proceso si sabemos el orden de ejecuci\u00f3n, pero NO sabemos como se intercalar\u00e1 respecto a otros procesos concurrentes.</p> <p>Si no dise\u00f1amos nuestros programas concurrentes con cuidado este hecho puede hacer que posean un comportamiento indeterminista (data race), es decir, que puedan arrojar resultados distintos ante distintas ejecuciones del programa con los mismos datos de entrada.</p> <p>Son las conocidas como condiciones de carrera (race conditions), que ocurren cuando el hecho de que un programa funcione correctamente depende de la secuencia o timing en el que el procesador ejecuta sus hilos. En el siguiente apartado vemos un ejemplo de este comportamiento.</p>"},{"location":"bloque_v/tema_19/page-6/","title":"6 Sincronizaci\u00f3n","text":""},{"location":"bloque_v/tema_19/page-6/#sincronizacion-de-tareas","title":"Sincronizaci\u00f3n de tareas","text":"<p>En sistemas concurrentes, podemos hablar de sincronizaci\u00f3n como la coordinaci\u00f3n de dos o m\u00e1s tareas para obtener el resultado deseado. Tenemos dos tipos de sincronizaci\u00f3n:</p> <ul> <li>Sincronizaci\u00f3n de acceso a datos: Cuando dos o m\u00e1s tareas tienen acceso a una variable compartida y en un momento dado s\u00f3lo una de las tareas deber\u00eda estar accediendo a ella. Se dice que un determinado c\u00f3digo es thread-safe (seguro para uso con hilos) si est\u00e1 protegido por mecanismos de sincronizaci\u00f3n que aseguran el acceso concurrente a los datos (o los objetos son inmutables y por tanto no hay problema con acceder concurrentemente a ellos).</li> <li>Sincronizaci\u00f3n de control: Cuando, por ejemplo, la continuidad de la ejecuci\u00f3n de una tarea depende de la terminaci\u00f3n de otra tarea.</li> </ul>"},{"location":"bloque_v/tema_19/page-6/#exclusion-mutua","title":"Exclusi\u00f3n mutua","text":"<p>Bernstein determin\u00f3 que dos conjuntos de instrucciones pueden ejecutarse concurrentemente siempre y cuando cumplan las siguientes condiciones:</p> <ul> <li>Que no haya intersecci\u00f3n entre el conjunto de variables le\u00eddas por el conjunto de instrucciones 1 y el conjunto de variables escritas por el conjunto de instrucciones 2 (y viceversa).</li> <li>Que no haya intersecci\u00f3n entre el conjunto de variables escritas por el conjunto de instrucciones 1 y el conjunto de variables escritas por el conjunto de instrucciones 2.</li> </ul> <p>Empecemos con la primera condici\u00f3n. Se pueden producir conflictos si un hilo est\u00e1 leyendo un objeto compartido mientras otro hilo lo est\u00e1 escribiendo, porque el objeto compartido puede quedar en un estado inconsistente.</p> <p>Para demostrarlo, supongamos que dos procesos en ejecuci\u00f3n comparten memoria y ambos quieren ejecutar la instrucci\u00f3n <code>x = x + 1</code>. Cuando dicha instrucci\u00f3n se traduce a lenguaje ensamblador se convierte en tres instrucciones independientes:</p> <ol> <li>Cargar desde memoria el valor de <code>x</code> en un registro (<code>LOAD X R1</code>).</li> <li>Incrementar el valor del registro (<code>ADD R1 1</code>).</li> <li>Almacenar el contenido del registro en la posici\u00f3n de memoria de <code>x</code> (<code>STORE R1 X</code>).</li> </ol> <p>Como hemos dicho anteriormente, no podemos determinar de antemano el orden exacto en el que se ejecutar\u00e1n ambos procesos. Esto implica que es posible que exista alg\u00fan orden de ejecuci\u00f3n entrelazado de las 6 l\u00edneas de c\u00f3digo (las 3 de cada proceso) que NO produzca el valor esperado. En principio el resultado de ejecutar ambos procesos concurrentemente deber\u00eda de producir un incremento de dos unidades en la variable <code>x</code>, sin embargo existen trazas (ordenes de ejecuci\u00f3n) que har\u00e1n que se pierda uno de los incrementos, por ejemplo si ambas instrucciones <code>LOAD X R1</code> se ejecutan antes de cualquiera de las instrucciones <code>ADD R1 1</code>.</p> <p>El motivo por el que ambos procesos no puedan ejecutarse concurrentemente es que no cumplen las condiciones de Bernstein, ya que existe solapamiento entre el conjunto de variables que escriben. El problema radica en que dos procesos distintos est\u00e1n accediendo al mismo tiempo a una variable compartida entre ambos para actualizarla. Pero \u00bfqu\u00e9 ocurrir\u00eda si esas tres instrucciones en ensamblador se ejecutaran seguidas de forma indivisible en un solo paso, sin ning\u00fan tipo de intercalado con las instrucciones del otro proceso? La respuesta es que no se habr\u00eda producido el problema.</p> <p>La secuencia de instrucciones que queremos que se ejecute de forma indivisible se denomina secci\u00f3n cr\u00edtica. Se llama as\u00ed porque es cr\u00edtico que dicha secci\u00f3n de c\u00f3digo se ejecute de forma at\u00f3mica, indivisible.</p> <p>La segunda condici\u00f3n de Berntein establece que se pueden producir conflictos si varios hilos escriben el mismo objeto compartido, porque el resultado pueden ser inconsistente. Estos problemas pueden ocurrir en procesadores con varios n\u00facleos que trabajen con cach\u00e9s para cada n\u00facleo que permitan la carga y almacenamiento de valores sin asegurar que no est\u00e9n siendo actualizados en otro n\u00facleo (ver).</p> <p> Figura 3 - Memory ordering</p> <p>Como consecuencia de estos conflictos, el de lectura-escritura y el de escritura-escritura, deberemos establecer alg\u00fan mecanismo para que cuando un proceso inicie la ejecuci\u00f3n de una secci\u00f3n cr\u00edtica, dicha ejecuci\u00f3n se realice en exclusi\u00f3n mutua, es decir que ning\u00fan otro proceso pueda ejecutar concurrentemente instrucciones problem\u00e1ticas para con la secci\u00f3n cr\u00edtica.</p> <p>Se denomina exclusi\u00f3n mutua porque no podemos determinar de antemano cu\u00e1l de los dos procesos ejecutar\u00e1n dichas instrucciones antes, pero lo que s\u00ed podemos asegurar es que en cuanto el primero que llegue comience la ejecuci\u00f3n de la secci\u00f3n cr\u00edtica el otro quedar\u00e1 excluido hasta que el primero termine de ejecutarla. Al fin y al cabo son dos procesos compitiendo por un recurso com\u00fan, que se conceder\u00e1 primero a uno o a otro, dependiendo del orden de ejecuci\u00f3n, pero NO a los dos a la vez. A esta competici\u00f3n por acceder a la secci\u00f3n cr\u00edtica se le conoce como lock contention.</p> <p>Los lenguajes de programaci\u00f3n que nos permiten crear programas concurrentes proporcionan distintos mecanismo que nos permitan asegurar la exclusi\u00f3n mutua.</p>"},{"location":"bloque_v/tema_19/page-6/#condicion-de-sincronizacion","title":"Condici\u00f3n de Sincronizaci\u00f3n","text":"<p>Otro de los problemas inherentes a la programaci\u00f3n concurrente es el hecho de que un recurso compartido por varios procesos, y por tanto protegido por exclusi\u00f3n mutua, como por ejemplo una estructura de datos como un array o una cola, se encuentre en un estado en el que un proceso que ha conseguido entrar en la secci\u00f3n cr\u00edtica no pueda llevar a cabo una determinada acci\u00f3n con la estructura de datos hasta que no cambie su estado. Es decir, que el proceso no puede continuar hasta que no se cumpla una determinada condici\u00f3n de sincronizaci\u00f3n. El principal inconveniente es que mientras no se d\u00e9 dicha condici\u00f3n, el proceso sigue estando en la secci\u00f3n cr\u00edtica y el recurso permanece inaccesible a otros procesos por exclusi\u00f3n mutua.</p> <p>El problema se agrava a\u00fan m\u00e1s si para que se cumpla dicha condici\u00f3n de sincronizaci\u00f3n es imprescindible que otro proceso pueda ejecutar una secci\u00f3n cr\u00edtica que acceda al mismo recurso (estructura de datos), lo cual es imposible dado que el primero proceso no ha abandonado la secci\u00f3n cr\u00edtica y por tanto el recurso est\u00e1 en exclusi\u00f3n mutua. Este hecho se conoce como el problema de productor-consumidor.</p> <p>La soluci\u00f3n a este problema consiste en que el lenguaje de programaci\u00f3n proporcione mecanismos que permitan suspender temporalmente la ejecuci\u00f3n de un proceso que est\u00e9 a la espera de que se cumpla la condici\u00f3n de sincronizaci\u00f3n, lo que har\u00e1 que se libere el recurso protegido por la secci\u00f3n cr\u00edtica. Cuando se produzca alg\u00fan evento que haga que la condici\u00f3n de sincronizaci\u00f3n se cumpla, se deber\u00e1 notificar al proceso que hab\u00eda sido suspendido, para que compita de nuevo por el recurso y si lo obtiene pueda continuar la ejecuci\u00f3n de su secci\u00f3n cr\u00edtica y finalmente abandonarla, liberando el recurso correspondiente.</p>"},{"location":"bloque_v/tema_19/page-7/","title":"7 Comunicaci\u00f3n","text":""},{"location":"bloque_v/tema_19/page-7/#comunicacion-de-tareas","title":"Comunicaci\u00f3n de Tareas","text":"<p>Las distintas tareas de un programa concurrente se pueden comunicar de dos maneras distintas:</p> <ul> <li>A trav\u00e9s de memoria compartida, habitualmente cuando las tareas se est\u00e1n ejecutando en el mismo ordenador. Requieren de mecanismos de sincronizaci\u00f3n de acceso a datos.</li> <li>A trav\u00e9s de paso de mensajes, normalmente cuando las tareas se est\u00e1n ejecutando en ordenadores distintos, aunque no necesariamente.</li> </ul> <p>El intercambio de mensajes, se puede realizar de dos formas:</p> <ul> <li>Utilizar un buffer de memoria: Se crea un canal de comunicaci\u00f3n entre dos procesos utilizando la memoria principal del sistema.</li> <li>Utilizar un socket: Se utilizan para intercambiar informaci\u00f3n entre procesos en distintas m\u00e1quinas a trav\u00e9s de la red.</li> </ul>"},{"location":"bloque_v/tema_19/page-7/#tipos-de-comunicacion","title":"Tipos de Comunicaci\u00f3n","text":"<p>En cualquier comunicaci\u00f3n, vamos a tener los siguientes elementos:</p> <ul> <li>Mensaje: Informaci\u00f3n que es el objeto de la comunicaci\u00f3n.</li> <li>Emisor: Entidad que emite, genera o es origen del mensaje.</li> <li>Receptor: Entidad que recibe, recoge o es destinataria del mensaje.</li> <li>Canal: Medio por el que viaja o es enviado y recibido el mensaje.</li> </ul> <p>Podemos clasificar el canal de comunicaci\u00f3n seg\u00fan su capacidad, y los sentidos en los que puede viajar la informaci\u00f3n:</p> <ul> <li>Simplex (s\u00edmplex): La comunicaci\u00f3n se produce en un s\u00f3lo sentido. El emisor es origen del mensaje y el receptor escucha el mensaje al final del canal. Por ejemplo, la reproducci\u00f3n de una pel\u00edcula en una sala de cine.</li> <li>Full duplex (d\u00faplex): Pueden viajar mensajes en ambos sentidos simult\u00e1neamente entre emisor y receptor. El emisor es tambi\u00e9n receptor y el receptor es tambi\u00e9n emisor. Por ejemplo, las comunicaciones telef\u00f3nicas.</li> <li>Half duplex (semid\u00faplex): El mensaje puede viajar en ambos sentidos, pero no al mismo tiempo. Por ejemplo, la comunicaci\u00f3n con walkie-talkies.</li> </ul> <p> Figura 4 - Comunicaci\u00f3n duplex</p>"},{"location":"bloque_v/tema_19/page-7/#tipos-de-canales-de-comunicacion","title":"Tipos de canales de comunicaci\u00f3n","text":"<p>Otra clasificaci\u00f3n dependiendo de la sincron\u00eda que mantengan el emisor y el receptor durante la comunicaci\u00f3n, ser\u00e1:</p> <ul> <li>S\u00edncrona: El emisor queda bloqueado hasta que el receptor recibe el mensaje. Ambos se sincronizan en el momento de la recepci\u00f3n del mensaje.</li> <li>As\u00edncrona: El emisor contin\u00faa con su ejecuci\u00f3n inmediatamente despu\u00e9s de emitir el mensaje, sin quedar bloqueado.</li> <li>Invocaci\u00f3n remota: El proceso emisor queda suspendido hasta que recibe la confirmaci\u00f3n de que el receptor ha recibido correctamente el mensaje. Despu\u00e9s emisor y receptor ejecutar\u00e1n s\u00edncronamente un segmento de c\u00f3digo com\u00fan.</li> </ul> <p>Dependiendo del comportamiento que tengan los interlocutores que intervienen en la comunicaci\u00f3n, tendremos comunicaci\u00f3n:</p> <ul> <li>Sim\u00e9trica: Todos los procesos pueden enviar y recibir informaci\u00f3n.</li> <li>Asim\u00e9trica: S\u00f3lo un proceso act\u00faa de emisor, el resto s\u00f3lo escuchar\u00e1n el o los mensajes.</li> </ul>"},{"location":"bloque_v/tema_19/page-8/","title":"8 Propiedad de Correcci\u00f3n en los programas concurrentes","text":""},{"location":"bloque_v/tema_19/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>El orden parcial e indeterminismo en la ejecuci\u00f3n de las instrucciones conllevan que conseguir que un programa concurrente sea correcto es m\u00e1s dif\u00edcil que en un programa secuencial.</p> <p>Para que un programa concurrente sea correcto, adem\u00e1s de satisfacer los requisitos funcionales correspondientes, debe cumplir una serie de propiedades inherentes a la concurrencia: las propiedades de seguridad y las propiedades de viveza.</p>"},{"location":"bloque_v/tema_19/page-8/#propiedades-de-seguridad","title":"Propiedades de Seguridad","text":"<p>Relacionadas con que no debe producirse algo que haga entrar al programa en un estado err\u00f3neo:</p>"},{"location":"bloque_v/tema_19/page-8/#exclusion-mutua","title":"Exclusi\u00f3n mutua","text":"<p>Hay recursos en el sistema que deben ser accedidos en exclusi\u00f3n mutua tal y como hemos visto anteriormente, garantizando que si un proceso adquiere el recurso, el resto deber\u00e1 esperar a que sea liberado.</p> <p> Figura 5 - Exclusi\u00f3n mutua</p>"},{"location":"bloque_v/tema_19/page-8/#condicion-de-sincronizacion","title":"Condici\u00f3n de sincronizaci\u00f3n","text":"<p>Hay situaciones en las que un proceso debe esperar por la ocurrencia de un evento para poder seguir ejecut\u00e1ndose. Cuando esto ocurre, hay que garantizar que el proceso no prosigue hasta que no se produce el evento. De lo contrario, el resultado puede ser imprevisto.</p> <p> Figura 6 - Condici\u00f3n de sincronizaci\u00f3n</p>"},{"location":"bloque_v/tema_19/page-8/#interbloqueo-deadlock","title":"Interbloqueo (deadlock)","text":"<p>Se produce una situaci\u00f3n de interbloqueo o interbloqueo pasivo cuando todos los procesos est\u00e1n suspendidos esperando en una condici\u00f3n de sincronizaci\u00f3n a un evento que nunca se producir\u00e1, dado que hay una espera circular. Hay que garantizar que la condici\u00f3n de sincronizaci\u00f3n llegar\u00e1 a cumplirse en alg\u00fan momento. Se suele conocer tambi\u00e9n como abrazo mortal. Por ejemplo la tarea 1 obtiene en exclusi\u00f3n mutua el recurso A, y es bloqueado hasta que obtenga el recurso B, mientras que la tarea 2 obtiene el recurso B y es suspendido hasta que obtenga el recurso A. La condici\u00f3n necesaria para que alguno de ellos termina de ejecutar su cometido nunca va a darse y ambas tareas terminar\u00e1n suspendidas indefinidamente.</p> <p>  Figura 7 - Interbloqueo</p> <p>Coffman defini\u00f3 las cuatros condiciones que deben darse simult\u00e1neamente en el sistema que para se produzca un interbloqueo:</p> <ul> <li>Que los recursos se encuentren en exclusi\u00f3n mutua.</li> <li>Que la tareas no libere un recurso obtenido en exclusi\u00f3n mutua mientras espera otro recurso.</li> <li>Que los recursos s\u00f3lo puedan ser liberados por las tareas que los han obtenido en exclusi\u00f3n mutua.</li> <li>Que se produzca una espera circular.</li> </ul> <p>Para evitar el interbloqueo, la estrategia m\u00e1s habitual es analizar los recursos que deben ser obtenidos por las tareas, de manera que podamos decidir en qu\u00e9 orden se obtienen y si deben obtener dependiendo de ciertas condiciones. Otra alternativa es que a la hora de tratar de adquirir un recurso se establezca un tiempo m\u00e1ximo transcurrido el cu\u00e1l se liberen todos los recursos que hubi\u00e9ramos adquirido.</p>"},{"location":"bloque_v/tema_19/page-8/#propiedades-de-viveza","title":"Propiedades de viveza","text":"<p>Relacionados con que cada sentencia que se ejecute conduce en alg\u00fan modo a un avance constructivo para alcanzar el objetivo funcional del programa. Son, en general, muy dependientes de la pol\u00edtica de planificaci\u00f3n que se utilice:</p>"},{"location":"bloque_v/tema_19/page-8/#interbloqueo-activo-livelock","title":"Interbloqueo activo (livelock)","text":"<p>Se produce un interbloqueo activo cuando varios procesos se est\u00e1n ejecutando pero ninguno es capaz de finalizar su ejecuci\u00f3n. Por ejemplo imaginemos que la tarea 1, obtiene el recurso A y la tarea 2 obtiene el recurso B. Como la tarea 1 necesita tambi\u00e9n el recurso B y \u00e9ste est\u00e1 siendo usado por la tarea 2, la tarea 1 libera el recurso A. Sin embargo, a la vez, como la tarea 2 necesita tambi\u00e9n el recurso A y \u00e9ste est\u00e1 siendo (en ese momento) usado por la tarea 1, la tarea 2 libera el recurso B. Y ambas tareas vuelven a intentar otra vez lo mismo, produci\u00e9ndose el mismo efecto indefinidamente. Se diferencia del deadlock en que en el livelock las tareas est\u00e1n siempre ejecut\u00e1ndose y cambiando de estado, aunque a pesar de ello no pueden terminar su cometido. Sin embargo en el deadlock las tareas est\u00e1n suspendidas (no en ejecuci\u00f3n), esperando algo que no va a suceder. La detecci\u00f3n de los livelock es muy compleja.</p> <p> Figura 8 - Interbloqueo activo</p>"},{"location":"bloque_v/tema_19/page-8/#inanicion-starvation","title":"Inanici\u00f3n (starvation)","text":"<p>Se produce cuando un proceso nunca tiene acceso a un recurso que necesita, ya que el sistema siempre se lo concede a alg\u00fan otro proceso. Para evitar la inanici\u00f3n se suele aplicar en los algoritmos el concepto de fairness (justicia), que implica que cualquier proceso que requiera un recurso lo obtendr\u00e1 en alg\u00fan momento, para lo que normalmente el sistema tiene en cuenta el momento en el que el proceso realiz\u00f3 la solicitud del mismo.</p> <p> Figura 9 - Inanici\u00f3n</p>"},{"location":"bloque_v/tema_19/page-8/#inversion-de-prioridad-priority-inversion","title":"Inversi\u00f3n de prioridad (priority inversion)","text":"<p>Se produce cuando una tarea de poca prioridad obtiene un recurso por delante de una de mayor prioridad, de manera que la menos prioritaria siempre termina su ejecuci\u00f3n antes que la m\u00e1s prioritaria.</p> <p> Figura 10 - Inversi\u00f3n de prioridad</p>"},{"location":"bloque_v/tema_20/page-1/","title":"2 Runtime","text":""},{"location":"bloque_v/tema_20/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Como sabemos, desde el punto de vista de los sistemas operativos, llamamos programa a la representaci\u00f3n en disco de una aplicaci\u00f3n, que contiene tanto el c\u00f3digo como los datos que maneja.</p> <p>Por otra parte, podr\u00edamos definir proceso como la representaci\u00f3n en el sistema de un programa en ejecuci\u00f3n. Cuando se inicia la ejecuci\u00f3n de un programa, por ejemplo por indicaci\u00f3n del usuario, el sistema operativo crea un proceso que representa la ejecuci\u00f3n de dicho programa en dicho sistema operativo.</p> <p>El proceso recibe un identificador \u00fanico conocido como PID (process identification), y contiene no s\u00f3lo el c\u00f3digo a ejecutar y los datos que gestiona, sino tambi\u00e9n toda la informaci\u00f3n necesaria para que el sistema operativo pueda ejecutar el programa, como vimos en el apartado anterior.</p> <p>Cuando un proceso finaliza su ejecuci\u00f3n puede indicar lo que se conoce como valor de terminaci\u00f3n (exit value), con el que el proceso puede indicar al sistema operativo si su ejecuci\u00f3n concluy\u00f3 con normalidad, representado normalmente por un exit value de <code>0</code>, o si se produjo alg\u00fan tipo de error.</p> <p>Toda aplicaci\u00f3n Java en ejecuci\u00f3n posee una instancia de la clase <code>Runtime</code>, que representa al entorno en el que se est\u00e1 ejecutando, que puede ser obtenida mediante su m\u00e9todo est\u00e1tico <code>Runtime.getRuntime()</code>. El m\u00e9todo <code>exit(exitValue)</code> del objeto <code>Runtime</code> permite terminar expl\u00edcitamente la ejecuci\u00f3n del proceso indicando un exit value. Por convenci\u00f3n, un exit value distinto de cero es indicativo de que se ha producido terminaci\u00f3n anormal, sintom\u00e1tica de alg\u00fan error. Si un proceso nunca llama a este m\u00e9todo, su ejecuci\u00f3n terminar\u00e1 con un exit value de cero.</p> <p>Note</p> <p>Existe un m\u00e9todo est\u00e1tico <code>System.exit(exitValue)</code>, que es que se utiliza tradicionalmente para indicar un exit value distinto de cero, que internamente simplemente llama a <code>Runtime.getRuntime().exit(exitValue)</code>.</p>"},{"location":"bloque_v/tema_20/page-1/#creacion-de-subprocesos-con-runtime","title":"Creaci\u00f3n de subprocesos con Runtime","text":"<p>Un proceso puede comenzar la ejecuci\u00f3n de otro proceso, al que denominaremos subproceso o proceso hijo, y ambos procesos, padre e hijo, podr\u00e1n comunicarse.</p> <p>Podemos utilizar el objeto <code>Runtime</code> para iniciar, desde nuestra aplicaci\u00f3n, la ejecuci\u00f3n de otro programa, para lo que utilizaremos su m\u00e9todo <code>exec()</code>, que recibe, en su forma m\u00e1s simple, el nombre del fichero ejecutable del programa u orden del sistema operativo que queremos que se ejecute, y que retorna un objeto de la clase <code>Process</code>, que representa el subproceso reci\u00e9n iniciado. Si se produce alg\u00fan error de entrada /salida se genera la excepci\u00f3n <code>IOException</code>, y si el gestor de seguridad no nos permite ejecutar la orden se lanzar\u00e1 la excepci\u00f3n <code>SecurityException</code>.</p> <p>Para ejecutar en Windows una orden (comando) de MS-DOS utilizaremos el int\u00e9rprete de comandos <code>CMD</code> con la sintaxis <code>CMD /C comando</code> si queremos el int\u00e9rprete de cierre tras ejecutar la orden o <code>CMD /K comando</code> si queremos que permanezca en ejecuci\u00f3n. En el caso de Linux/Mac podemos usar directamente el comando deseado o mediante el int\u00e9rprete de comandos <code>/bin/sh -c comando</code>.</p> <pre><code>Runtime runtime = Runtime.getRuntime();\nString command = \"CMD /C DIR\";\nProcess process = runtime.exec(command);\n</code></pre> <p>El m\u00e9todo <code>exec()</code> est\u00e1 sobrecargado, pudiendo recibir otros par\u00e1metros:</p> <ul> <li>Orden y argumentos (cmdarray): Array de cadenas correspondientes al nombre del fichero ejecutable u orden que debe ser invocado y sus argumentos. Debe ser v\u00e1lida para el sistema operativo en el que se ejecute el programa.</li> <li>Entorno (environment): variables de entorno con el que debe ejecutarse el programa, normalmente las mismas que las del programa llamador.</li> <li>Directorio de trabajo (dir): El directorio desde el que se debe ejecutar el programa. Por defecto el mismo que el del programa llamador.</li> </ul> <p>Por ejemplo, con <code>exec(\"CMD /C DIR\", null, new File(\"C:/WINDOWS\"))</code> estamos indicando que se liste el directorio de trabajo, especificando que \u00e9ste sea <code>C:\\WINDOWS</code>.</p>"},{"location":"bloque_v/tema_20/page-2/","title":"2 ProcessBuilder","text":""},{"location":"bloque_v/tema_20/page-2/#creacion-de-subprocesos-con-processbuilder","title":"Creaci\u00f3n de subprocesos con ProcessBuilder","text":"<p>A partir de la versi\u00f3n Java 5, el m\u00e9todo recomendado para crear un proceso desde nuestro programa consiste en crear un objeto de la clase <code>ProcessBuilder</code> (lanzador de procesos), cuyo constructor <code>ProcessBuilder(commandWords...)</code>, o <code>ProcessBuilder(commandWordsList)</code>, recibe una lista de cadenas con los atributos necesarios para iniciar un proceso (no pueden contener espacios).</p> <p>Una vez creado el objeto <code>ProcessBuilder</code>, podemos lanzar la ejecuci\u00f3n del subproceso llamando a su m\u00e9todo <code>start()</code>, que, al igual que el m\u00e9todo <code>exec()</code> de <code>Runtime</code>, nos retornar\u00e1 un objeto de la clase <code>Process</code> que representa el subproceso hijo reci\u00e9n iniciado.</p> <pre><code>ArrayList&lt;String&gt; command = new ArrayList&lt;&gt;(Arrays.asList(\"CMD\", \"/C\", \"DIR\"));\nProcessBuilder processBuilder = new ProcessBuilder(command);\nProcess process = processBuilder.start();\n</code></pre> <p>El m\u00e9todo <code>environment()</code> de la clase <code>ProcessBuilder</code> retorna un mapa <code>Map&lt;String, String&gt;</code> donde cada par corresponde a una variable de entorno, donde la clave es el nombre de la variable. El mapa inicialmente contendr\u00e1 una copia del valor de las variables de entorno del proceso actual, correspondiente al valor retornado por <code>System.getenv()</code>.</p> <p>El m\u00e9todo <code>directory(file)</code> permite establecer el directorio de trabajo del proceso.</p> <pre><code>ProcessBuilder processBuilder =\n      new ProcessBuilder(\"/bin/sh\", \"-c\", \"echo $horse $dog $HOME\");\nprocessBuilder.environment().put(\"horse\", \"oats\");\nprocessBuilder.environment().put(\"dog\", \"treats\");\nProcess process = pb.start()\n</code></pre>"},{"location":"bloque_v/tema_20/page-2/#obtener-informacion-sobre-el-subproceso","title":"Obtener informaci\u00f3n sobre el subproceso","text":"<p>Desde el punto de visto de Java un proceso (o subproceso) es representado por la clase <code>Process</code>. Esta clase ofrece distintos m\u00e9todos informativos sobre el proceso que representa:</p> <ul> <li><code>pid()</code>: Retorna al process ID (PID) que el sistema operativo le ha asignado al proceso. Disponible a partir de Java 9.</li> <li><code>info()</code>: Retorna un objeto de la clase <code>ProcessHandle.Info</code> con informaci\u00f3n sobre el proceso. Disponible a partir de Java 9.</li> <li><code>isAlive()</code>: Retorna un booleano indicativo de si el proceso est\u00e1 vivo, es decir, no ha terminado a\u00fan su ejecuci\u00f3n.</li> <li><code>exitValue()</code>: Cuando un proceso termina su ejecuci\u00f3n puede indicar un valor indicativo de si todo ha ido bien o no. El m\u00e9todo <code>exitValue()</code> retorna el valor que indic\u00f3 el proceso como valor de terminaci\u00f3n, que normalmente corresponde al valor 0 si todo ha ido bien.</li> <li><code>children</code>: Retorna un <code>Stream&lt;ProcessHandle&gt;</code>, un stream de objetos <code>ProcessHandle</code> asociados a los procesos que sean hijos directos del proceso, es decir que hayan sido creados directamente por \u00e9l. Disponible a partir de Java 9.</li> <li><code>descendants()</code>: Similar al anterior, pero retorna un stream de todos los subprocesos del proceso, incluyendo los que no hayan sido creados directamente por \u00e9l, sino por sus hijos, nietos, etc. Disponible a partir de Java 9.</li> </ul> <p>Como acabamos de comentar, el m\u00e9todo <code>info()</code> de la clase <code>Process</code> retorna un objeto de la clase <code>ProcessHandler.Info</code>, del que podemos extraer informaci\u00f3n adicional sobre el proceso, a trav\u00e9s de sus m\u00e9todos (disponibles a partir de Java 9):</p> <ul> <li><code>arguments()</code>: Retorna un <code>Optional&lt;String[]&gt;</code> con los argumentos del comando con el que se inici\u00f3 el subproceso.</li> <li><code>command()</code>: Retorna un <code>Optional&lt;String&gt;</code> con el nombre del comando con el que se inici\u00f3 el subproceso.</li> <li><code>commandLine()</code>: Retorna un <code>Optional&lt;String&gt;</code> con la l\u00ednea de comandos con la que se inici\u00f3 el subproceso.</li> <li><code>startInstant()</code>: Retorna un <code>Optional&lt;Instant&gt;</code> con el instante de inicio del subproceso.</li> <li><code>totalCpuDuration()</code>: Retorna un <code>Optional&lt;Direction&gt;</code> con el tiempo total de CPU acumulado por el subproceso.</li> <li><code>user()</code>: Retorna un <code>Optional&lt;String&gt;</code> con el usuario del subproceso.</li> </ul> <p>La disponibilidad de acceso a los atributos d un proceso var\u00eda dependiendo del sistema operativo y de los privilegios del proceso que est\u00e9 realizando la consulta. Por este motivo, todos los m\u00e9todos anteriores retornan un <code>Optional&lt;T&gt;</code>, por lo que deberemos siempre comprobar si realmente se nos ha proporcionado o no el valor.</p> <p>Veamos un ejemplo:</p> <pre><code>void getInfoTest() throws IOException {\n    ProcessBuilder processBuilder = new ProcessBuilder(\"echo\", \"Hello World!\");\n    String notAvailable = \"&lt;not available&gt;\";\n    Process process = processBuilder.start();\n    ProcessHandle.Info info = process.info();\n    System.out.printf(\"Process ID: %s\\n\", process.pid());\n    System.out.printf(\"Command name: %s\\n\", info.command().orElse(notAvailable));\n    System.out.printf(\"Command line: %s\\n\", info.commandLine().orElse(notAvailable));\n    System.out.printf(\"Start time: %s\\n\",\n                      info.startInstant().map(i -&gt; i.atZone(ZoneId.systemDefault())\n                                              .toLocalDateTime().toString())\n                      .orElse(notAvailable));\n    System.out.printf(\"Arguments: %s\\n\",\n                      info.arguments().map(arguments -&gt; Stream.of(arguments)\n                                           .collect(Collectors.joining(\" \")))\n                      .orElse(notAvailable));\n    System.out.printf(\"User: %s\\n\", info.user().orElse(notAvailable));\n}\n</code></pre>"},{"location":"bloque_v/tema_20/page-3/","title":"3 Flujos de comunicaci\u00f3n","text":""},{"location":"bloque_v/tema_20/page-3/#flujos-de-comunicacion-entre-proceso-padre-y-subproceso","title":"Flujos de comunicaci\u00f3n entre proceso padre y subproceso","text":"<p>Por defecto, los subprocesos hijos creados por un proceso padre no tienen su propio terminal y console. Todas la operaciones con le entrada y salida est\u00e1ndar (stdin, stdout, stderr) realizadas por el subproceso hijo ser\u00e1 redirigidas hacia el proceso padre, a trav\u00e9s de una tuber\u00eda (pipe) entre ambos.</p> <p>Para acceder a la salida del subproceso hijo desde el proceso padre, debemos leer del flujo de entrada (ojo, no el de salida) que va del subproceso hijo al proceso padre, que puede obtener mediante el m\u00e9todo <code>getInputStream()</code> del objeto <code>Process</code> correspondiente al subproceso hijo.</p> <p>De igual forma, si queremos que el subproceso hijo reciba alguna informaci\u00f3n desde el proceso padre, \u00e9ste deber\u00e1 escribir en el flujo de salida (ojo, no el de entrada) que va del proceso padre al subproceso hijo, que puede obtener mediante el m\u00e9todo <code>getOutputStream()</code> del objeto <code>Process</code> correspondiente al subproceso hijo.</p> <p>Finalmente, podremos leer del flujo de error que va desde el subproceso hijo al proceso padre, que podemos obtener mediante el m\u00e9todo <code>getErrorStream()</code> del objeto <code>Process</code> correspondiente al subproceso hijo.</p> <p>En el siguiente ejemplo construimos un programa que al ejecutarse crea un subproceso que usa el int\u00e9rprete de comandos de Windows para listar el directorio actual. El proceso padre leer\u00e1 la salida del subproceso y la escribir\u00e1 por pantalla.</p> <pre><code>void showLibrary() throws IOException {\n    ArrayList&lt;String&gt; command = new ArrayList&lt;&gt;(Arrays.asList(\"ls\", \"-ltra\", \"/Library\"));\n    ProcessBuilder processBuilder = new ProcessBuilder(command);\n    Process process = null;\n    process = processBuilder.start();\n    System.out.printf(\"Receiving from command %s ...\\n\\n\", String.join(\" \", command));\n    try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(\n        process.getInputStream()))) {\n        bufferedReader.lines().forEach(System.out::println);\n    }\n}\n</code></pre> <p>Un aspecto muy importante de los flujos de comunicaci\u00f3n entre proceso padre y subproceso es que la escritura y lectura en dichos flujos son bloqueantes, es decir, que cuando el proceso padre realiza una operaci\u00f3n de lectura sobre el flujo de salida del subproceso hijo a trav\u00e9s su <code>InputStream</code> queda bloqueado hasta que el hijo le devuelve los datos requeridos, lo que permite que para la comunicaci\u00f3n no sea necesario establecer mecanismos adicionales de sincronizaci\u00f3n (de hecho en el ejemplo anterior no los hemos establecido).</p>"},{"location":"bloque_v/tema_20/page-3/#redireccion-de-los-flujos-del-subproceso","title":"Redirecci\u00f3n de los flujos del subproceso","text":"<p>Antes de comenzar la ejecuci\u00f3n de un subproceso, podemos hacer que su entrada, salida o salida de error sea redirigida autom\u00e1ticamente a otro destino. Para ello, la clase <code>ProcessBuilder</code> proporciona los m\u00e9todos <code>redirectInput(redirect)</code>, <code>redirectOutput(redirect)</code> y <code>redirectError(redirect)</code>, disponibles desde Java 7. Estos m\u00e9todos reciben un objeto de la clase <code>ProcessBuilder.Redirect</code>, que representa un destino de la redirecci\u00f3n.</p> <p>La clase <code>ProcessBuilder.Redirect</code> define una serie de valor especiales:</p> <ul> <li><code>Redirect.PIPE</code>: El destinatario ser\u00e1 el proceso padre. Es el valor por defecto.</li> <li><code>Redirect.INHERIT</code>: El destinatario ser\u00e1 el mismo que el del proceso padre.</li> <li><code>Redirect.DISCARD</code>: No habr\u00e1 destinatario. El flujo ser\u00e1 descartado.</li> </ul> <p>Y tambi\u00e9n proporciona una serie de m\u00e9todos factor\u00eda para crear una redirecci\u00f3n a partir de un archivo:</p> <ul> <li><code>Redirect.from(file)</code>: El destinatario ser\u00e1 un fichero del que se leer\u00e1.</li> <li><code>Redirect.to(File)</code>: El destinatario ser\u00e1 un fichero en el que se escribir\u00e1.</li> <li><code>Redirect.appendTo(File)</code>: El destinatario ser\u00e1 un fichero en el que se escribir\u00e1 al final sin machacar el contenido original.</li> </ul> <p>La clase <code>ProcessBuilder</code> tiene sobrecargados los m\u00e9todos <code>redirectInput(file)</code>, <code>redirectOutput(file)</code> y <code>redirectError(file)</code>, de manera que puedan recibir directamente un fichero, siendo equivalentes, respectivamente, a <code>redirectInput(Redirect.from(file))</code>, <code>redirectOutput(Redirect.to(file))</code> y <code>redirectError(Redirect.to(file))</code>.</p> <p>Si queremos redireccionar tanto la entrada, com la salida y la salida de error a los mismos destinatarios que tenga el proceso padre, podemos usar el m\u00e9todo <code>inheritIO()</code> de la clase <code>ProcessBuilder</code>, que es equivalente a llamar a <code>redirectInput(Redirect.INHERIT)</code>, <code>.redirectOutput(Redirect.INHERIT)</code>y <code>.redirectError(Redirect.INHERIT)</code>.</p> <p>Como hemos visto, por defecto, la salida est\u00e1ndar y la salida de error del subprocesos son enviadas a dos flujos distintos. Sin embargo, podemos establecer que ambas salidas se env\u00eden combinadas al mismo flujo, para lo que utilizaremos el m\u00e9todo <code>redirectErrorStream(true)</code> del objeto <code>ProcessBuilder</code>. El flujo combinado ser\u00e1 accesible a trav\u00e9s del m\u00e9todo <code>getInputStream()</code> del objeto <code>Process</code>, y el m\u00e9todo <code>getErrorStream()</code> retornar\u00e1 un flujo nulo. Si hemos combinado salida est\u00e1ndar y salida de error, el flujo combinado puede ser redirigido mediante <code>redirectOutput(redirect)</code> o <code>redirectOutput(file)</code>.</p> <p>Veamos un ejemplo en el que se redirecciona el flujo de salida hacia un fichero y el flujo de error hacia el mismo destino que el del padre:</p> <pre><code>void redirectToFileTest() throws IOException {\n    File outFile = new File(\"out.tmp\");\n    Process p = new ProcessBuilder(\"ls\", \"-la\")\n        .redirectOutput(outFile)\n        .redirectError(ProcessBuilder.Redirect.INHERIT)\n        .start();\n}\n</code></pre>"},{"location":"bloque_v/tema_20/page-4/","title":"4 Finalizaci\u00f3n","text":""},{"location":"bloque_v/tema_20/page-4/#esperando-la-finalizacion-de-un-subproceso","title":"Esperando la finalizaci\u00f3n de un subproceso","text":"<p>Si queremos que el proceso padre espere a que un subproceso hijo finalice su ejecuci\u00f3n, llamaremos desde el proceso padre al m\u00e9todo <code>waitFor()</code> del objeto <code>Process</code> correspondiente al subproceso hijo. Como consecuencia el proceso padre permanece bloqueado hasta que el subproceso hijo finaliza su ejecuci\u00f3n, retornando el valor de finalizaci\u00f3n del subproceso (valor retornado por el main o por el m\u00e9todo <code>System.exit()</code> desde el hijo).</p> <p>Si para cuando se ejecuta el m\u00e9todo <code>waitFor()</code> en el padre el subproceso hijo ya ha finalizado su ejecuci\u00f3n, se retorna inmediatamente, y se puede obtener el valor de finalizaci\u00f3n del subproceso hijo mediante el m\u00e9todo <code>exitValue()</code> del objeto <code>Process</code> correspondiente. Aunque debemos tener cuidado con este m\u00e9todo porque si se utiliza sin que el subproceso haya finalizado su ejecuci\u00f3n se lanzar\u00e1 la excepci\u00f3n <code>IllegalThreadStateException</code>.</p> <p>El m\u00e9todo <code>waitFor()</code> lanza la excepci\u00f3n <code>InterruptedException</code> si el proceso padre es interrumpido mientras estaba esperando a la finalizaci\u00f3n del proceso hijo.</p> <p>Veamos un ejemplo, en el que se lanza un subproceso en el que se redir\u00edge su salida a un fichero y se espera a que dicho subproceso concluya, para posteriormente lanzar un segundo subproceso que usa el fichero generado por el primero. Finalmente se espera a que finalice este segundo subproceso:</p> <pre><code>void redirectToFileTest() throws IOException, InterruptedException {\n    File outFile = new File(\"out.tmp\");\n    Process p = new ProcessBuilder(\"ls\", \"-la\")\n        .redirectOutput(outFile)\n        .redirectError(ProcessBuilder.Redirect.INHERIT)\n        .start();\n    int status = p.waitFor();\n    if (status == 0) {\n        p = new ProcessBuilder(\"cat\" , outFile.toString())\n            .inheritIO()\n            .start();\n        p.waitFor();\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_20/page-4/#finalizacion-de-subprocesos","title":"Finalizaci\u00f3n de subprocesos","text":"<p>Una de las caracter\u00edsticas de la m\u00e1quina virtual de Java es que los subprocesos hijos creados por un proceso padre no finalizan autom\u00e1ticamente cuando \u00e9ste lo hace (terminaci\u00f3n en cascada), sino que pueden seguir ejecut\u00e1ndose incluso aunque el padre haya terminado su ejecuci\u00f3n.</p> <p>Sin embargo, el proceso padre puede finalizar la ejecuci\u00f3n de un subproceso que haya iniciado previamente, haciendo uso del m\u00e9todo <code>destroy()</code> del objeto <code>Process</code> correspondiente.</p> <p>Dependiendo de la plataforma en la que se est\u00e9 ejecutando (Windows, Linux, etc.), dicha finalizada podr\u00e1 ser ser normal o forzada. Para saber si el sistema permite la terminaci\u00f3n con normalidad, desde Java 9 podemos usar el m\u00e9todo <code>supportsNormalTermination()</code>, que retornar\u00e1 un booleano indicativo de si es posible o no.</p> <p>Si queremos forzar la terminaci\u00f3n del subproceso, podemos llamar al m\u00e9todo <code>destroyForcibly()</code>.</p>"},{"location":"bloque_v/tema_20/page-4/#ejecucion-asincrona-de-operaciones-tras-la-finalizacion-de-un-subproceso","title":"Ejecuci\u00f3n as\u00edncrona de operaciones tras la finalizaci\u00f3n de un subproceso","text":"<p>Si queremos ejecutar de forma as\u00edncrona alguna operaci\u00f3n cuando un subproceso termine su ejecuci\u00f3n, podemos usar su m\u00e9todo <code>onExit()</code> de la clase <code>Process</code>, que retorna un <code>CompletableFuture&lt;Process&gt;</code>, que ser\u00e1 marcado como \"completado\" cuando el subproceso haya finalizado su ejecuci\u00f3n, ya sea normalmente o porque lo hayamos destruido usando cualquiera de los m\u00e9todos anteriores.</p> <p>Si, en momento dado, queremos esperar la finalizaci\u00f3n del subproceso, podemos llamar al m\u00e9todo <code>get()</code> del <code>CompetableFuture&lt;Process&gt;</code> retornado por <code>onExit()</code>. Si llamamos a <code>cancel()</code> sobre el completableFuture, no tendr\u00e1 efecto sobre la ejecuci\u00f3n del subproceso.</p> <p>Veamos un ejemplo:</p> <pre><code>void startProcessesTest() throws IOException, InterruptedException {\n    ProcessBuilder processBuilder = new ProcessBuilder(\"ls\", \"-la\");\n    Process process = processBuilder.start();\n    process.onExit().thenAccept(p -&gt; printResults(p));\n    // The parent process can go on executing other things.\n    // ...\n    System.out.println(\"\\nPress enter to continue ...\\n\");\n    System.in.read();\n}\n\nprivate void printResults(Process p) {\n    try {\n        System.out.printf(\"Exit %d, status %d%n%s%n%n\",\n                          p.pid(), p.exitValue(), output(p.getInputStream()));\n    } catch (IOException e) {\n        System.out.println(\"Error printing results\");\n    }\n}\n\nprivate String output(InputStream inputStream) throws IOException {\n    try (BufferedReader br = new BufferedReader(new InputStreamReader(inputStream))) {\n        return\n            br.lines().collect(Collectors.joining(System.getProperty(\"line.separator\")));\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_20/page-5/","title":"5 ProcessHandle","text":""},{"location":"bloque_v/tema_20/page-5/#acceso-a-procesos-vivos-del-sistema-no-creados-por-nosotros","title":"Acceso a procesos vivos del sistema no creados por nosotros","text":"<p>La interfaz <code>ProcessHandle</code>, disponible a partir de Java 9, nos permite identificar y controlar procesos que no hayan sido creados por nosotros a trav\u00e9s de <code>Runtime.exec()</code> o <code>ProcessBuilder.start()</code>.</p> <p>Por ejemplo, podemos listar todos los procesos actualmente vivos en el sistema que sean visibles para nuestro proceso usando el m\u00e9todo est\u00e1tico <code>ProcessHandle.allProcesses()</code>, que retorna un <code>Stream&lt;ProcessHandle&gt;</code>, con los <code>ProcessHandle</code> de dichos procesos.</p> <p>Si queremos obtener el <code>ProcessHandle</code> del proceso actual, podemos ejecutar el m\u00e9todo est\u00e1tico <code>ProcessHandle.current()</code>, y si queremos el del proceso con un determinado pid, podemos llamar el m\u00e9todo est\u00e1tico <code>ProcessHandle.of(pid)</code>, que retornar\u00e1 un <code>Optional&lt;ProcessHandle&gt;</code>, por si no existe ning\u00fan proceso con dicho pid.</p> <p>Una vez obtenido un objeto <code>ProcessHandle</code> podemos usar m\u00e9todos similares a los de la clase <code>Process</code>, como por ejemplo: <code>isAlive()</code>, <code>pid()</code>, <code>info()</code>, <code>children()</code>, <code>descendants()</code>, <code>destroy()</code>, <code>destroyForcibly()</code> y <code>onExit()</code>, con el mismo significado que en la clase <code>Process</code>.</p> <p>Tambi\u00e9n tenemos disponible el m\u00e9todo <code>parent()</code>, que retorna un <code>Optional&lt;ProcessHandle&gt;</code> con el objeto <code>ProcessHandle</code> del proceso padre a \u00e9ste.</p> <p>Por ejemplo, podemos mostrar todos los procesos vivos en el sistema que pertenezcan al mismo usuario que el proceso actual de la siguiente manera:</p> <pre><code>void showUserProcesses() {\n    Optional&lt;String&gt; currUser = ProcessHandle.current().info().user();\n    ProcessHandle.allProcesses()\n        .filter(ph -&gt; ph.info().user().equals(currUser))\n        .forEach(ph -&gt; showProcess(ph));\n}\n\nvoid showProcess(ProcessHandle ph) {\n    ProcessHandle.Info info = ph.info();\n    System.out.printf(\"pid: %d, user: %s, cmd: %s%n\",\n                      ph.pid(), info.user().orElse(\"none\"),    \n                      info.command().orElse(\"none\"));\n}\n</code></pre>"},{"location":"bloque_v/tema_20/page-6/","title":"6 Alternativas de comunicaci\u00f3n","text":""},{"location":"bloque_v/tema_20/page-6/#alternativas-para-la-comunicacion-entre-procesos","title":"Alternativas para la comunicaci\u00f3n entre procesos","text":"<p>Adem\u00e1s de mediante flujos de datos, los procesos se pueden comunicar mediante otros m\u00e9todos:</p> <ul> <li>Los sockets de comunicaci\u00f3n (ya los veremos m\u00e1s adelante).</li> <li>La JNI (Java Native Interface, Intefaz Nativa de Java), que permite incluso acceder desde Java a aplicaciones desarrolladas en otros lenguajes de programaci\u00f3n de m\u00e1s bajo nivel, como C.</li> <li>Librer\u00edas de comunicaci\u00f3n no est\u00e1ndares, como por ejemplo CLIPC, que usa internamente JNI y permite utilizar m\u00e9todos m\u00e1s cercanos al sistema operativo, como el establecimiento de una regi\u00f3n de memoria compartida, la creaci\u00f3n de pipes (tuber\u00edas) entre los procesos y sincronizaci\u00f3n mediante sem\u00e1foros.</li> </ul> <p>Referencias</p> <ul> <li>https://docs.oracle.com/en/java/javase/11/core/process-api1.html</li> <li>https://www.baeldung.com/java-process-api</li> <li>https://www.baeldung.com/java-9-process-api</li> </ul>"},{"location":"bloque_v/tema_21/page-1/","title":"1 Introducci\u00f3n a la Gesti\u00f3n de Hilos","text":""},{"location":"bloque_v/tema_21/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>En el mundo de los ordenadores, cuando hablamos de concurrencia nos referimos a una serie de tareas que se ejecutan simult\u00e1neamente en un ordenador. Esta simultaneidad puede ser real, si el ordenador tiene m\u00e1s de un procesador o un procesador con varios n\u00facleos, o simulada, si s\u00f3lo dispone de un \u00fanico n\u00facleo de procesamiento.</p> <p>Proceso</p> <p>Un proceso es una unidad de reserva de memoria y de protecci\u00f3n, desde el punto de vista del sistema operativo.</p> <p>Todos los sistemas operativos modernos permiten la ejecuci\u00f3n de tareas concurrentes. Por ejemplo, podemos leer nuestros emails mientras escuchamos m\u00fasica o leemos las noticias en una p\u00e1gina web. Podr\u00edamos decir que este tipo de concurrencia corresponde a una concurrencia a nivel de proceso.</p> <p>Pero dentro de un proceso tambi\u00e9n podemos tener varias tareas simult\u00e1neas que se ejecutan dentro de \u00e9l, a las que llamamos hilos o hebras (threads en ingl\u00e9s).</p> <p> Figura 1 - Procesos e hilos</p> <p>Hilos</p> <p>Los hilos son unidades de ejecuci\u00f3n de conjuntos de instrucciones, de manera que dichos conjuntos pueden ejecutarse de forma concurrente en n\u00facleos de procesamiento (ver).</p> <p>Los procesos y los hilos mantienen una serie de diferencias importantes:</p> <ul> <li>Los hilos comparten el espacio de memoria del usuario, incluyendo datos, c\u00f3digo y recursos, mientras que los procesos generalmente disponen de espacios de memoria independientes e interact\u00faan a trav\u00e9s de mecanismos de sincronizaci\u00f3n dados por el sistema. Cada hilo dispone de su propio contador de programa, estado de los registros de la CPU y pila, para poder guardar el punto actual de ejecuci\u00f3n.</li> <li>El cambio de estado de un hilo es mucho menos costoso que el de un proceso.</li> <li>Los hilos no pueden ejecutarse por s\u00ed solos, necesitan estar contenidos en un proceso padre. Cuando se crea un proceso (cuando se lanza la ejecuci\u00f3n de un programa), se crea dentro de \u00e9l un hilo principal, que puede, a su vez, crear tantos hilos como desee, que pasar\u00e1n a ejecutarse contenidos dentro del proceso.</li> </ul> <p>Los hilos son usados normalmente para, dentro de un proceso, llevar a cabo distintas tareas simult\u00e1neamente, o para realizar tareas costosas en tiempo sin detener el resto del programa.</p> <p>Por ejemplo en un proceso correspondiente a un editor de textos, podemos tener un hilo encargado de estar llevando a cabo la comprobaci\u00f3n ortogr\u00e1fica del texto, o guardando autom\u00e1ticamente en documento en segundo plano cada cierto tiempo. Otro ejemplo t\u00edpico es el de un servidor web que cada vez que recibe una petici\u00f3n crea uno nuevo para atenderla, permitiendo seguir recibiendo peticiones en el hilo principal.</p> <p>En los entornos gr\u00e1ficos el hilo principal de una aplicaci\u00f3n corresponde normalmente a lo que se conoce como hilo de la interfaz de usuario, cuya misi\u00f3n es actualizar la interfaz cada vez que haya cambios y detectar las interacciones del usuario. En estos sistemas es muy importante, que dicho hilo no quede bloqueado por una operaci\u00f3n costosa, dado que el usuario tendr\u00e1 la sensaci\u00f3n de que la aplicaci\u00f3n no responde, dado que el hilo principal no podr\u00e1 atender a las interacciones del usuario. Por este motivo, en estos entornos, todas las tareas que no sean pr\u00e1cticamente inmediatas deben llevarse a cabo en un hilo secundario o hilo trabajador, de manera que puedan quedar bloqueados sin afectar a la capacidad de respuesta del hilo de la UI.</p> <p>Los hilos aportan una serie de beneficios:</p> <ul> <li>Mejoran el rendimiento de la aplicaci\u00f3n en hardware con varios n\u00facleos de procesamiento, ya que se ejecutan en paralelo.</li> <li>Incrementan el rendimiento de la aplicaci\u00f3n, ya que una llamada de E/S solamente bloquear\u00e1 el hilo en el que se realiza.</li> <li>Aumentan la capacidad de respuesta de la aplicaci\u00f3n, ya que un hilo de la UI puede estar atendiendo siempre las peticiones de usuario mientras otros hilos realizan otras tareas m\u00e1s costosas. El resultado es que el usuario no adquiere la sensaci\u00f3n de que el programa est\u00e9 \"colgado\".</li> <li>La comunicaci\u00f3n entre hilos se puede realizar mediante variables, ya que todos los hilos del proceso comparten la memoria y los recursos asignados a \u00e9ste. Sin embargo, este tipo de comunicaci\u00f3n hace necesario el establecimiento de m\u00e9todos de sincronizaci\u00f3n entre los hilos. En otros casos se lleva a cabo la comunicaci\u00f3n entre hilos a trav\u00e9s de paso de mensajes, como en el caso de entornos con un hilo dedicado a la IU.</li> <li>La creaci\u00f3n de nuevos hilos no conlleva la reserva adicional de memoria, ya que utilizan la del proceso al que pertenecen. Sin embargo, s\u00ed que necesitan una pila espec\u00edfica para cada uno de ellos.</li> </ul>"},{"location":"bloque_v/tema_21/page-1/#comunicacion-entre-hilos","title":"Comunicaci\u00f3n entre hilos","text":"<p>La comunicaci\u00f3n entre hilos de un mismo proceso se puede llevar a cabo de dos maneras distintas:</p> <p> Figura 2 - Comunicaci\u00f3n mediante objetos compartidos en memoria</p>"},{"location":"bloque_v/tema_21/page-1/#a-traves-de-objetos-compartidos-en-memoria","title":"A trav\u00e9s de objetos compartidos en memoria","text":"<p>As\u00ed, un hilo puede escribir en un objeto y otro hilo puede leer dicho objeto.</p> <p>Como consecuencia del acceso concurrente desde distintos hilos, ser\u00e1 necesario establecer mecanismos de sincronizaci\u00f3n de acceso a datos.</p> <p> Figura 3 - Paso de mensajes</p>"},{"location":"bloque_v/tema_21/page-1/#a-traves-de-paso-de-mensajes-entre-hilos","title":"A trav\u00e9s de paso de mensajes entre hilos","text":"<p>El hilo posee una cola de mensajes accesible desde ambos hilos.</p> <p>As\u00ed, un hilo enviar\u00e1 un mensaje a la cola de mensajes, que se insertar\u00e1 por un extremo, y otro hilo ir\u00e1 leyendo los mensajes de la cola, que los ir\u00e1 extrayendo del otro extremo.</p> <p>Este es el tipo de comunicaci\u00f3n que se utiliza habitualmente en los sistemas en lo que el hilo principal corresponde al hilo de la interfaz de usuario, que es el \u00fanico que puede actualizarla. Es el caso por ejemplo de Android.</p>"},{"location":"bloque_v/tema_21/page-1/#estados-de-un-hilo","title":"Estados de un hilo","text":"<p>A lo largo de su ejecuci\u00f3n, un hilo puede pasar por los siguientes estados:</p> <p> Figura 4 - Diagrama de estados de un hilo</p> <ul> <li>Nuevo / Naciendo (new): Se ha creado el objeto correspondiente al hilo (se ha hecho el <code>new</code>), pero a\u00fan NO se ha iniciado su ejecuci\u00f3n.</li> <li>Listo (runnable): El hilo est\u00e1 preparado para ser ejecutado, pero el planificador del sistema operativo no le ha asignado todav\u00eda el procesador para ejecutarse.</li> <li>Corriendo / En ejecuci\u00f3n (running): El hilo est\u00e1 ejecut\u00e1ndose en el procesador.</li> <li>Bloqueado (blocked): El hilo est\u00e1 bloqueado al intentar acceder a un recurso vigilado por un objeto monitor que no est\u00e1 libre.</li> <li>Suspendido (waiting): El hilo ha sido suspendido mediante c\u00f3digo en espera de que se le notifique desde c\u00f3digo que puede continuar.</li> <li>Suspendido por tiempo (timed waiting): El hilo ha sido suspendido mediante c\u00f3digo en espera de que pase un determinado tiempo.</li> <li>Terminado (terminated): El hilo ha finalizado su ejecuci\u00f3n ya sea naturalmente, al finalizar su m\u00e9todo <code>run()</code>, o abruptamente, por alguna excepci\u00f3n que se haya producido en dicho m\u00e9todo. El entorno de ejecuci\u00f3n de Java puede liberar los recursos asociados al hilo, como por ejemplo su memoria</li> </ul>"},{"location":"bloque_v/tema_21/page-10/","title":"10 ThreadGroup","text":""},{"location":"bloque_v/tema_21/page-10/#creacion-de-un-grupo-de-hilos","title":"Creaci\u00f3n de un grupo de hilos","text":"<p>Una funcionalidad interesante que nos ofrece Java es la posibilidad de agrupar hilos. Esto nos permite tratar los hilos de un grupo como una sola unidad a la hora de llevar a cabo ciertas operaciones con ellos. Por ejemplo, si tenemos varios hilos que est\u00e9n llevando a cabo una tarea conjunta podremos agruparlos bajo un grupo de manera que con una sola llamada se puedan, por ejemplo, interrumpir todos los hilos de dicho grupo.</p> <p>Java nos proporciona la clase <code>ThreadGroup</code> para trabajar con grupos de hilos. Un objeto <code>ThreadGroup</code> puede estar formado por objetos <code>Thread</code> o por otros objetos <code>ThreadGroup</code>, generando un grupo con estructura de \u00e1rbol.</p> <p>Si queremos crear un hilo y agregarlo a un determinado grupo de hilos existente, simplemente tendremos que especificar como primer par\u00e1metro del constructor el objeto correspondiente al grupo. El constructor de la clase <code>Thread</code> est\u00e1 sobrecargado para este cometido con las siguientes posibles sintaxis:</p> <ul> <li><code>Thread(ThreadGroup grupo, Runnable objeto)</code>.</li> <li><code>Thread(ThreadGroup grupo, Runnable objeto, String nombreHilo)</code>.</li> </ul> <p>La clase <code>ThreadGroup</code> proporciona el m\u00e9todo <code>interrupt()</code> para marcar para interrupci\u00f3n todos los hilos del grupo de una vez. Adem\u00e1s, pone a nuestra disposici\u00f3n algunos m\u00e9todos informativos, como <code>activeCount()</code>, que retorna el n\u00famero de hilos del grupo activos (en ejecuci\u00f3n), <code>list()</code>, que muestra por la salida est\u00e1ndar informaci\u00f3n sobre los hilos del grupo y <code>enumerate(Thread[] lista)</code>, que nos permite almacenar en un array pasado como argumento el conjunto de hilos activos del grupo.</p> <p>Por otro lado, como mencionamos cuando hablamos de <code>UncaughtExceptionHandler</code>, en caso se producirse una uncaught exception dentro del m\u00e9todo <code>run()</code> de un hilo, la JVM sigue el siguiente procedimiento trata de llamar al m\u00e9todo <code>uncaughtException()</code> del objeto manejador establecido individualmente para dicho hilo. Pero si no se ha establecido en el hilo un manejador para ese tipo de excepciones, la JVM llamar\u00e1 al m\u00e9todo <code>uncaughtException(Thread t, Throwable e)</code> del <code>ThreadGroup</code> grupo de hilos al que pertenezca el hilo. Por tanto si queremos manejar este tipo de excepciones a nivel de <code>ThreadGroup</code> simplemente tendremos que sobrescribir en el <code>TheadGroup</code> dicho m\u00e9todo.</p>"},{"location":"bloque_v/tema_21/page-10/#proyecto-grupo-de-hilos","title":"Proyecto Grupo de Hilos","text":"<p>En este proyecto crearemos 10 hilos que pertenecer\u00e1n a un mismo grupo de hilos. La tarea de estos hilos ser\u00e1 simular que se realiza una b\u00fasqueda en Internet, por lo que generaremos aleatoriamente el n\u00famero de segundos que tarda en realizarse la b\u00fasqueda (y que el hilo pasar\u00e1 durmiendo en la simulaci\u00f3n). Cuando cualquiera de los hilos finaliza la b\u00fasqueda, almacena el resultado en un objeto creado espec\u00edficamente para ello (que en nuestra simulaci\u00f3n contendr\u00e1 el nombre del hilo que ha finalizado la b\u00fasqueda). Cuando detectemos que uno de los hilos del grupo ha finalizado interrumpiremos a todos los hilos del grupo, ya que no tiene sentido que sigan ejecut\u00e1ndose una vez encontrado el resultado.</p> MainResultadoBuscador <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        // Crea un nuevo grupo de hilos llamado Buscadores.\n        ThreadGroup searchThreads = new ThreadGroup(\"Search threads\");\n        Resultado result=new Resultado();\n        // Crea un objeto buscador.\n        Buscador buscador = new Buscador(result);\n        // Crea e inicia cinco hilos que ejecutan el mismo objeto buscador\n        // a\u00f1adi\u00e9ndolo al grupo de hilo Buscadores.\n        for (int i = 0; i &lt; 10; i++) {\n            Thread hilo = new Thread(grupoBuscadores, buscador);\n            hilo.start();\n            // Espero 1 segundo entre la creaci\u00f3n de un hilo y la siguiente.\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        // Espera la finalizaci\u00f3n de todos los hilos del grupo.\n        esperarHiloGrupo(grupoBuscadores);\n        // Interrumpe todos los hilos del grupos.\n        grupoBuscadores.interrupt();\n    }\n\n    // Espera la finalizaci\u00f3n de alg\u00fan hilo del grupo\n    private static void esperarHiloGrupo(ThreadGroup grupoHilos) {\n        // Mientras todos los hilos del grupo est\u00e9n activos\n        // duerme durante un segundo.\n        while (grupoHilos.activeCount() &gt; 9) {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n</code></pre> <pre><code>// Almacena el resultado de la consulta (en la simulaci\u00f3n el nombre\n// del hilo que ha terminado antes de hacer la b\u00fasqueda).\npublic class Resultado {\n\n    private String name;    // Nombre del hilo.\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n}\n</code></pre> <pre><code>// Simula una operaci\u00f3n de b\u00fasqueda\npublic class Buscador implements Runnable {\n\n    private Resultado resultado; // Resultado de la b\u00fasqueda.\n\n    // Recibe el objeto donde se almacenar\u00e1 el resultado.\n    public Buscador(Resultado resultado) {\n        this.resultado = resultado;\n    }\n\n    @Override\n    public void run() {\n        String nombreHilo = Thread.currentThread().getName();\n        System.out.printf(\"Hilo %s: Comenzando b\u00fasqueda\\n\", nombreHilo);\n        try {\n            buscar();\n            // Establezce el resultado como el nombre del hilo.\n            resultado.setName(nombreHilo);\n        } catch (InterruptedException e) {\n            // Si el hilo es interrumpido mientras duerme se produce\n            // esta excepci\u00f3n, que se aprovecha para finalizar el hilo.\n            System.out.printf(\"Hilo %s: Ha sido interrumpido\\n\", nombreHilo);\n            // Finaliza la ejecuci\u00f3n del hilo.\n            return;\n        }\n        // Informa de que este hilo ha finalizado la b\u00fasqueda.\n        System.out.printf(\"Hilo %s: B\u00fasqueda finalizada\\n\", nombreHilo);\n    }\n\n    // Simula la operaci\u00f3n de b\u00fasqueda durmiendo durante un n\u00famero aleatorio \n    // de segundos (como m\u00e1ximo 30)\n    private void buscar() throws InterruptedException {\n        // Obtiene aleatoriamente el n\u00famero de segundos que va a dormir el hilo.\n        Random aleatorio = new Random();\n        int segundos = aleatorio.nextInt(30);\n        // Informa al usuario y duerme.\n        System.out.printf(\"Hilo %s: La b\u00fasqueda tardar\u00e1 %d segundos\\n\",\n                              Thread.currentThread().getName(), segundos);\n        // Si es interrumpido mientras duerme lanza la excepci\u00f3n InterruptedException.\n        TimeUnit.SECONDS.sleep(segundos);\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_21/page-11/","title":"11 ThreadFactory","text":""},{"location":"bloque_v/tema_21/page-11/#crear-hilos-mediante-una-fabrica-de-hilos","title":"Crear hilos mediante una f\u00e1brica de hilos","text":"<p>Uno de los patrones de dise\u00f1o m\u00e1s usados en el mundo de la programaci\u00f3n orientada a objetos es el conocido como f\u00e1brica de objetos (factory pattern, en ingl\u00e9s). Un objeto F\u00e1brica tiene la misi\u00f3n de crear otros objetos de uno o varias clases. Cuando queremos crear un objeto de una de esas clases usaremos un m\u00e9todo de la f\u00e1brica en vez de usar directamente el operador de instanciaci\u00f3n <code>new</code>.</p> <p>El hecho de centralizar la creaci\u00f3n de los objetos tiene algunas ventajas:</p> <ul> <li>Es f\u00e1cil cambiar la clase de los objetos creados o la forma en la que se crean.</li> <li>Es sencillo limitar el n\u00famero de objetos creados que usen un mismo recurso limitado. Por ejemplo, limitar que s\u00f3lo puedan crearse <code>n</code> objetos de una cierta clase.</li> <li>Nos facilita la generaci\u00f3n de datos estad\u00edsticos sobre la creaci\u00f3n de los objetos.</li> </ul> <p>Java nos proporciona la interfaz <code>ThreadFactory</code> para implementar una f\u00e1brica de objetos <code>Thread</code>, es decir, una f\u00e1brica de hilos.</p> <pre><code>package java.util.concurrent;\n\npublic interface ThreadFactory {\n    Thread newThread(Runnable r);\n}\n</code></pre> <p>La interfaz <code>ThreadFactory</code> posee un s\u00f3lo m\u00e9todo llamado <code>newThread()</code>, que deberemos implementar forzosamente. Este m\u00e9todo recibe el objeto <code>Runnable</code> que queremos que ejecute el hilo y retorna el objeto <code>Thread</code> correspondiente al hilo creado.</p> <p>Si utilizamos una f\u00e1brica de hilos, lo l\u00f3gico es asegurarnos de que todos los hilos de nuestro programa son creados a trav\u00e9s de dicha f\u00e1brica.</p>"},{"location":"bloque_v/tema_21/page-11/#proyecto-threadfactory","title":"Proyecto ThreadFactory","text":"<p>En el siguiente ejemplo crearemos un f\u00e1brica de hilos que construye los hilos con un nombre base personalizado y almacena un registro de la creaci\u00f3n de hilos. Al terminar de ejecutarse todos los hilos se muestra el registro de la f\u00e1brica de hilos.</p> MainTaskMyThreadFactory <pre><code>import java.util.ArrayList;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        final MyThreadFactory threadFactory = new MyThreadFactory(\"MyThreadFactory\");\n        ArrayList&lt;Thread&gt; threads = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 3; i++) {\n            Thread thread = threadFactory.newThread(new Task());\n            threads.add(thread);\n            thread.start();\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException exception) {\n                return;\n            }\n        }\n        for (Thread thread : threads) {\n            try {\n                thread.join();\n            } catch (InterruptedException exception) {\n                return;\n            }\n        }\n        System.out.printf(\"\\n\\nMyThreadFactory Log\\n\\n%s\", threadFactory.getLog());\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\npublic class Task implements Runnable {\n\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    @Override\n    public void run() {\n        try {\n            System.out.printf(\"%s -&gt; %s started\\n\",\n                    LocalTime.now().format(dateTimeFormatter), Thread.currentThread().getName());\n            // Simulate task working.\n            TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n            System.out.printf(\"%s -&gt; %s finished\\n\",\n                    LocalTime.now().format(dateTimeFormatter), Thread.currentThread().getName());\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.concurrent.ThreadFactory;\n\npublic class MyThreadFactory implements ThreadFactory {\n\n    private int count = 0;\n    private final String baseName;\n    private final ArrayList&lt;String&gt; log = new ArrayList&lt;&gt;();\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    public MyThreadFactory(String baseName) {\n        this.baseName = baseName;\n    }\n\n    @Override\n    public Thread newThread(Runnable runnable) {\n        Thread thread = new Thread(runnable, baseName + \"-\" + count++);\n        log.add(LocalTime.now().format(dateTimeFormatter) + \" -&gt; \" + thread.getName() + \" created\");\n        return thread;\n    }\n\n    public String getLog() {\n        return String.join(\"\\n\", log);\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que los hilos se crean usando la factor\u00eda y que se guarda un registro con la hora de creaci\u00f3n de los hilos:</p>"},{"location":"bloque_v/tema_21/page-12/","title":"12 ThreadLocal","text":""},{"location":"bloque_v/tema_21/page-12/#threadlocal","title":"ThreadLocal","text":"<p>Si creamos un objeto de una clase que implementa la interface <code>Runnable</code> e iniciamos varios hilos que hagan uso de dicho mismo objeto, por defecto los hilos creados compartir\u00e1n los mismos atributos, por lo que al cambiar cualquier atributo todos los hilos correspondientes se ver\u00e1n afectados.</p> <p>Sin embargo algunas veces desearemos que algunos atributos NO sean compartidos entre todos los hilos que hacen uso del objeto <code>Runnable</code>, sino que cada hilo disponga de su propia copia del atributo, de manera que al cambiar su valor NO se vean afectados el resto de hilos. Para ello la API de concurrencia de Java proporciona el mecanismo conocido como variables thread-local (locales al hilo), a trav\u00e9s de la clase <code>ThreadLocal&lt;T&gt;</code>. Al crear el objeto se suele suministrar el c\u00f3digo del m\u00e9todo <code>initialValue()</code> para establecer el valor inicial de la variable.</p> <p>El mecanismo de variables thread-local almacena un valor de la variable para cada hilo que la use, y nos proporciona una serie de m\u00e9todos para trabajar con dicho valor:</p> <ul> <li><code>get()</code>: Permite obtener el valor de la variable en el hilo en el que se ejecuta.</li> <li><code>set(valor)</code>: Permite establecer el valor de la variable en el hilo en el que se ejecuta.</li> <li><code>initialValue()</code>: La primera vez que se accede al valor de la variable si \u00e9sta no tiene valor se llamar\u00e1 a este m\u00e9todo para asignarle el valor inicial para el hilo en el que se ejecuta.</li> <li><code>remove()</code>: Elimina el valor de la variable para el hilo en el que se ejecuta, de manera que si posteriormente se trata de obtener, se llamar\u00e1 al m\u00e9todo <code>initialValue()</code>.</li> </ul> <pre><code>ThreadLocal&lt;Integer&gt; threadLocalValue = new ThreadLocal&lt;&gt;();\nthreadLocalValue.set(1);\nInteger result = threadLocalValue.get();\n</code></pre> <p>Tambi\u00e9n podeos crear una instancia de ThreadLocal usando el m\u00e9todo est\u00e1tico withInitial(), que recibe un supplier que es ejecutado para establecer el valor inicial:</p> <pre><code>ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 1);\n</code></pre> <p>Debemos tener en cuenta que las variables thread-local mantendr\u00e1n su valor mientras el hilo est\u00e9 vivo, lo que puede resultar problem\u00e1tico cuando reusemos hilos.</p> <p>La API de concurrencia de Java The Java Concurrency tambi\u00e9n incluye la clase <code>InheritableThreadLocal</code> para crear variables thread-local que puedan ser heredadas cuando un hilo crea otro hilo. Por defecto el hilo hijo tendr\u00e1 como valor inicial de la variable el valor que tuviera dicha variable en el hilo padre. Sin embargo, podemos sobrescribir el m\u00e9todo <code>childValue()</code> para establecer el valor inicial de la variable en el hilo hijo. Dicho m\u00e9todo recibir\u00e1 como par\u00e1metro el valor que posee la variable en el hilo padre.</p> <p>ThreadLocal se usa sobre todo en frameworks para almacenar un determinado contexto asoci\u00e1ndolo a cada hilo. De esta manera se reduce la necesidad de pasar dicho contexto a cada m\u00e9todo que lo necesita, ya que podr\u00e1 acceder a \u00e9l a trav\u00e9s del ThreadLocal, aunque tiene el inconveniente de que acopla el c\u00f3digo que lo usa al framework. Por tanto no debemos abusar del uso de ThreadLocal, al igual que no debemos abusar del uso de variable globales.</p>"},{"location":"bloque_v/tema_21/page-12/#proyecto-threadlocal","title":"Proyecto ThreadLocal","text":"<p>En este proyecto crearemos un programa que crear un \u00fanico objeto Tarea que es ejecutado por varios hilos. Crearemos dos versiones de la tarea, una err\u00f3nea, en cuyo caso los resultados mostrados por pantalla son incorrectos, dado que los hilos modifican el atributo compartido de la Tarea, y otra versi\u00f3n correcta, en la que cada hilo dispone de su propia copia del atributo.</p> MainTareaErroneaTareaCorrecta <pre><code>public class Main {\n\n    private static int NUM_HILOS = 10;\n\n    public static void main(String[] args) {\n\n        TareaCorrecta tarea = new TareaCorrecta();\n        Thread[] hilos = new Thread[NUM_HILOS];\n\n        // Se crean hilos que ejecutan la tarea insegura.\n        for (int i = 0; i &lt; NUM_HILOS; i++) {\n            hilos[i] = new Thread(tarea);\n            hilos[i].start();\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n</code></pre> <pre><code>public class TareaErronea implements Runnable {\n\n    private String mNombre;\n\n    @Override\n    public void run() {\n        // Se obtiene la hora de inicio. \n        // PROBLEMA: SE EST\u00c1 CAMBIANDO EL NOMBRE EN TODOS LOS HILOS.\n        mNombre = Thread.currentThread().getName();\n        System.out.printf(\"Hilo: %s - Nombre inicio: %s\\n\", \n                          Thread.currentThread().getId(), mNombre);\n        // Se simula el trabajo de la tarea.\n        try {\n            TimeUnit.SECONDS.sleep((int) Math.rint(Math.random() * 5));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.printf(\"Hilo: %s - Nombre fin: %s\\n\", \n                          Thread.currentThread().getId(), mNombre);\n    }\n\n}\n</code></pre> <pre><code>public class TareaCorrecta implements Runnable {\n\n    private ThreadLocal&lt;String&gt; mNombre;\n    @Override\n    public void run() {\n        // Se obtiene el nombre del hilo. SOLO SE ACTUALIZA LA COPIA DEL HILO CORRESPONDIENTE.\n        mNombre = new ThreadLocal&lt;String&gt;(){\n            @Override\n            protected String initialValue() {\n                return Thread.currentThread().getName();\n            }\n        };\n        System.out.printf(\"Hilo: %s - Nombre Inicio: %s\\n\", \n                          Thread.currentThread().getId(), mNombre.get());\n        // Se simula el trabajo de la tarea.\n        try {\n            TimeUnit.SECONDS.sleep((int) Math.rint(Math.random() * 5));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.printf(\"Hilo: %s - Nombre Fin: %s\\n\", \n                          Thread.currentThread().getId(), mNombre.get());\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_21/page-13/","title":"Ejercicios","text":"Ejercicio 1 <p>\u00bfPara qu\u00e9 sirve UncaughtExceptionHandler?</p> Soluci\u00f3n <p>Es una interfaz que sirve para evitar que un hilo se finalice cuando se comete un <code>unchecked exception</code></p> Ejercicio 2 <p>\u00bfPara qu\u00e9 sirve ThreadGroup?***</p> Soluci\u00f3n <p>Es una clase que nos permite agrupar varios hilos y tratarlos como uno solo.</p> Ejercicio 3 <p>\u00bfPara qu\u00e9 sirve una ThreadFactory?***</p> Soluci\u00f3n <p>Sirve para crear varios objetos de una clase o de varias clases.</p> Ejercicio 4 <p>\u00bfPara qu\u00e9 sirve ThreadLocal? \u00bfCu\u00e1ndo tiene sentido usarla?***</p> Soluci\u00f3n <p>Sirve cuando deseamos que todos los hilos de un objeto Runnable no compartan atributos. Tiene sentido usarla en frameworks para almacenar un determinado contexto asoci\u00e1ndolo a cada hilo.</p> Ejercicio 5 <p>Crea un programa en Java que muestre la tabla de potencias de los n\u00fameros del 1 al 10. Haz uso de los hilos</p> Ejercicio 6 <p>Realiza el mismo programa anterior, pero d\u00e1ndole prioridad a los n\u00fameros pares. La salida debe ser como la siguiente: <code>NombreHilo: 2 ^ 1 = 1</code></p>"},{"location":"bloque_v/tema_21/page-2/","title":"2 Thread","text":""},{"location":"bloque_v/tema_21/page-2/#la-clase-thread","title":"La clase Thread","text":"<p>En Java un hilo de ejecuci\u00f3n est\u00e1 representado por la clase <code>Thread</code>. Si queremos crear un hilo que ejecute un determinado c\u00f3digo deberemos definir una clase que extienda de la la clase <code>Thread</code> y sobrescribir su m\u00e9todo <code>run()</code>. Dicho m\u00e9todo ser\u00e1 ejecutado autom\u00e1ticamente por el sistema cuando iniciemos la ejecuci\u00f3n del hilo.</p> <p>Debemos tener en cuenta que si simplemente instanciamos la clase <code>Thread</code> usando su constructor vac\u00edo, <code>new Thread()</code> estaremos creando un hilo que no ejecuta ning\u00fan c\u00f3digo.</p> <p>De cara al sistema operativo, el nuevo hilo de ejecuci\u00f3n se crea cuando se llama a m\u00e9todo <code>start()</code> del objeto <code>Thread</code>, no cuando se crea la instancia (objeto) de la clase que extiende <code>Thread</code>. El entorno de ejecuci\u00f3n de Java, despu\u00e9s de obtener los recursos necesarios para el hilo, llama internamente al m\u00e9todo <code>run()</code>, ejecut\u00e1ndose de forma concurrente al hilo desde el que se llam\u00f3 a <code>start()</code>.</p> <pre><code>class MyThread extends Thread {\n\n    @Override\n    public void run() {\n        // ...\n    }\n\n}\n</code></pre> <p>Para iniciar un objeto de dicha clase deberemos instanciarlo y llamar a su m\u00e9todo <code>start()</code>:</p> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        new MyThread().start();\n    }\n\n}\n</code></pre> <p>Nunca hagas esto</p> <p>Debemos tener en cuenta que si llamamos directamente al m\u00e9todo <code>run()</code> de un objeto de una clase que extiende de <code>Thread</code> NO se crea un nuevo hilo de ejecuci\u00f3n, sino que se ejecuta su c\u00f3digo en el mismo hilo desde el que se ha llamado.</p> <p>Dentro del m\u00e9todo <code>run()</code> podemos ejecutar pr\u00e1cticamente cualquier c\u00f3digo. Sin embargo los entornos visuales con UI salen restringir los hilos que pueden acceder a los componentes de la UI, permitiendo que s\u00f3lo el hilo principal pueda acceder a ellos, como por ejemplo en el caso de Android.</p> <p>Un hilo finaliza su ejecuci\u00f3n en cuanto se retorne de su m\u00e9todo <code>run()</code>, ya sea por una salida anticipada mediante <code>return</code> o simplemente porque se haya ejecutado su \u00faltima instrucci\u00f3n. Tambi\u00e9n puede terminar con una excepci\u00f3n si el c\u00f3digo del m\u00e9todo <code>run()</code> lanza o produce una excepci\u00f3n que no es gestionada.</p> <p>Warning</p> <p>Un hilo se finaliza cuando termina de ejecutarse su m\u00e9todo <code>run()</code></p> <p>Por su parte, el planificador interno de hilos puede suspender y resumir la ejecuci\u00f3n de un hilo muchas veces durante su ciclo de vida, algunas veces atendiendo a determinadas sentencias especificadas por el desarrollador dentro del c\u00f3digo del hilo, y que estudiaremos m\u00e1s adelante, como <code>sleep()</code>, <code>wait()</code>, <code>notify()</code>, <code>join()</code>, etc.</p> <p>Debemos tener en cuenta que una vez que finaliza la ejecuci\u00f3n de hilo el entorno de ejecuci\u00f3n de Java recicla los recursos que fueron obtenidos para \u00e9l, como por ejemplo el almacenamiento reservado para \u00e9l, o su pila de ejecuci\u00f3n. Esto implica que no podemos reutilizar el objeto <code>Thread</code> correspondiente a un hilo ya finalizado (se ha retornado de <code>run()</code>) para ejecutar alguna otra tarea.</p> <p>Cuando un programa Java crea distintos hilos de ejecuci\u00f3n no debemos olvidar que dicho programa seguir\u00e1 en ejecuci\u00f3n mientras alguno de sus hilos est\u00e9 en ejecuci\u00f3n (a no ser que se trate de un hilo demonio, como veremos m\u00e1s adelante). Si el hilo principal, esto es, el que ejecuta el m\u00e9todo <code>main()</code>, termina, el resto de los hilos continuar\u00e1n su ejecuci\u00f3n hasta que terminen. Si uno de los hilos usa la instrucci\u00f3n <code>System.exit()</code> para terminar la ejecuci\u00f3n de un programa, finalizar\u00e1 la ejecuci\u00f3n de todos sus hilos.</p> <p>La clase <code>Thread</code> almacena ciertos atributos de informaci\u00f3n que nos pueden ayudar a identificar un hilo o conocer su estado. Veamos dichos atributos:</p> <ul> <li>ID: Identificador \u00fanico para el hilo.</li> <li>Name: Nombre del hilo.</li> <li>Priority: Prioridad del hilo (de <code>1</code> a <code>10</code>, donde <code>10</code> es la m\u00e1xima prioridad).</li> <li>Status: Estado del hilo. Puede ser uno de los siguientes: <code>new</code> (nuevo), <code>runnable</code> (ejecutable), <code>blocked</code> (bloqueado), <code>waiting</code> (esperando a otro hilo), <code>timed waiting</code> (esperando a otro hilo un tiempo determinado), o <code>terminated</code> (terminado).</li> </ul> <p>La M\u00e1quina Virtual de Java (JVM) usa la prioridad de los hilos para seleccionar el que debe usar la CPU en cada momento y actualiza autom\u00e1ticamente el estado de cada hilo dependiendo de su situaci\u00f3n. Entre todos los hilos en estado \"listo\", se escoge para ser ejecutado el hilo con mayor prioridad. Si hay dos o m\u00e1s hilos con dicha prioridad, se elige uno de ellos siguiendo un algoritmo round-robin.</p> <p>Si no se especifica un nombre para el hilo, la JVM le asigna autom\u00e1ticamente uno con el formato <code>Thread-XX</code> donde <code>XX</code> es un n\u00famero.</p> <p>Warning</p> <p>No se puede modificar los atributos <code>ID</code> o <code>Status</code> desde c\u00f3digo</p> <p>Debemos tener en cuenta que no es posible modificar los atributos <code>ID</code> o <code>Status</code> de un hilo desde c\u00f3digo. De hecho, la clase <code>Thread</code> no implementa los setters correspondientes.</p> <p>El m\u00e9todo <code>setPriority()</code> puede lanzar una excepci\u00f3n <code>IllegalArgumentException</code> si se intenta establecer una prioridad que no est\u00e9 entre <code>1</code> y <code>10</code>.</p> <p>Para asignar un determinado nombre a un hilo podemos pasarlo como argumento al constructor de la clase <code>Thread</code>.</p>"},{"location":"bloque_v/tema_21/page-2/#proyecto-thread","title":"Proyecto Thread","text":"<p>En el siguiente proyecto crearemos una aplicaci\u00f3n que muestra la tabla de multiplicar de los n\u00fameros desde el 1 al 10, usando para cada tabla un hilo de ejecuci\u00f3n distinto. Para representar la tabla de multiplicar de un n\u00famero definiremos una clase que extienda de la clase <code>Thread</code>.</p> <p>El c\u00f3digo corresponde a las clases descritas en los ejemplos anterior.</p> MainMultiplicationTable <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        for (int i = 1; i &lt;= 10; i++) {\n            new MultiplicationTable(i).start();\n        }\n    }\n\n}\n</code></pre> <pre><code>class MultiplicationTable extends Thread {\n\n    private final int number;\n\n    MultiplicationTable(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 1; i &lt;= 10; i++) {\n            System.out.printf(\"%s: %d * %d = %d\\n\", getName(), \n                    number, i, i * number);\n        }\n    }\n\n}\n</code></pre> <p>Al ejecutar el proyecto podemos comprobar como el orden en que se muestran las l\u00edneas de las diferentes tablas de multiplicar no es igual al de un programa con un \u00fanico hilo, e incluso puede ser diferentes en distintas ejecuciones.</p>"},{"location":"bloque_v/tema_21/page-3/","title":"3 Runnable","text":""},{"location":"bloque_v/tema_21/page-3/#la-interfaz-runnable","title":"La interfaz Runnable","text":"<p>La t\u00e9cnica anterior de definir una clase que extiende de <code>Thread</code> tiene un inconveniente: como sabemos Java no permite la herencia m\u00faltiple, por lo que si queremos que extienda de <code>Thread</code> no podr\u00e1 extender de ninguna otra clase. Para solucionar este problema, Java nos proporciona la interfaz <code>Runnable</code> que representa el comportamiento de una tarea (un conjunto de l\u00edneas de c\u00f3digo) que pueda ser ejecutada en un hilo de ejecuci\u00f3n.</p> <pre><code>package java.lang;\n\n@FunctionalInterface\npublic interface Runnable {\n    void run();\n}\n</code></pre> <p>De esta manera, en vez de definir una clase que extienda de <code>Thread</code>, definiremos una clase que implemente la interfaz <code>Runnable</code>, permiti\u00e9ndonos que la clase extienda de cualquier otra clase que nos interese.</p> <p>La interfaz <code>Runnable</code> posee un \u00fanico m\u00e9todo: el m\u00e9todo <code>run()</code>, que sobrescribiremos para indicar el c\u00f3digo que debe ser ejecutado. De hecho, la clase <code>Thread</code> implementa la interfaz <code>Runnable</code>, y por eso dispone del m\u00e9todo <code>run()</code>.</p> <p>Sin embargo, un objeto de una clase que implemente <code>Runnable</code> no puede ejecutarse por s\u00ed s\u00f3lo, sino que debe hacerlo dentro de un objeto <code>Thread</code>. Para que esto sea posible, la clase <code>Thread</code> nos proporciona un constructor que recibe como par\u00e1metro el objeto <code>Runnable</code> (la tarea) que queremos que ejecute dicho hilo cuando se inicie su ejecuci\u00f3n.</p> <p>As\u00ed, definiremos una clase que represente la \"tarea\" y que implementar\u00e1 la interfaz <code>Runnable</code>:</p> <pre><code>class MyRunnable implements Runnable {\n\n    // ...\n\n    @Override\n    public void run() {\n        // ...\n    }\n\n}\n</code></pre> <p>Para ejecutar la tarea en un nuevo hilo de ejecuci\u00f3n haremos:</p> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        new Thread(new MyRunnable()).start();\n    }\n\n}\n</code></pre> <p>Dado que la interfaz <code>Runnable</code> corresponde a una interfaz funcional, es decir, aquella que tiene un \u00fanico m\u00e9todo abstracto, si estamos empleando Java 8+ podemos usar una expresi\u00f3n lambda o una referencia a m\u00e9todo para representar el objeto <code>Runnable</code>. Por ejemplo:</p> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        new Thread(() -&gt; {\n            // ...\n        }).start();\n    }\n\n}\n</code></pre> <p>Debemos tener en cuenta que el m\u00e9todo si queremos pasar argumentos al c\u00f3digo que debe ejecutarse dentro de <code>run()</code> deberemos pasarlos como argumentos del constructor de la clase que implemente <code>Runnable</code> o mediante un setter, de manera que el argumento recibido se establezca como valor de un campo definido en tal clase. Estas dos t\u00e9cnicas son incompatibles con el empleo de lambdas, dadas las caracter\u00edsticas de \u00e9stas.</p> <p>La t\u00e9cnica de pasar argumento mediante el constructor se describe en el Proyecto Runnable que desarrollaremos a continuaci\u00f3n.</p> <p>Acceso al hilo desde el Runnable</p> <p><code>Thread.currentThread()</code> retorna el objeto <code>Thread</code> en el que nos estamos ejecutando</p> <p>Si desde el objeto <code>Runnable</code> necesitamos acceder a informaci\u00f3n sobre el hilo de ejecuci\u00f3n en el que se est\u00e1 ejecutando, podemos usar el m\u00e9todo est\u00e1tico <code>Thread.currentThread()</code>, que retorna el objeto <code>Thread</code> en el que est\u00e1 ejecutando dicha l\u00ednea de c\u00f3digo.</p> <p>En general, el uso de la interfaz <code>Runnables</code> es m\u00e1s flexible que heredar de <code>Thread</code>, ya que, como estudiaremos m\u00e1s adelante, podremos usarlos en otras clases Java, como por ejemplo con los executors (ejecutores).</p> <p>Un \u00faltimo aspecto curioso es que el m\u00e9todo <code>run()</code> de la interfaz <code>Runnable</code> no retorna nada. Entonces \u00bfc\u00f3mo podemos hace que un hilo secundario calcule un resultado y lo devuelva? No podemos hacer que lo retorne, pero s\u00ed que podemos almacenar el resultado en alguna variable compartida entre el hilo llamador y el hilo secundario, o incluso definir un campo en el <code>Runnable</code> y almacenar en \u00e9l el resultado. Cuando termine la ejecuci\u00f3n del hilo secundario el hilo que lo inici\u00f3 podr\u00e1 acceder al resultado a trav\u00e9s del campo del <code>Runnable</code>.</p>"},{"location":"bloque_v/tema_21/page-3/#proyecto-runnable","title":"Proyecto Runnable","text":"<p>En el siguiente proyecto crearemos una aplicaci\u00f3n que muestra la tabla de multiplicar de los n\u00fameros desde el 1 al 10, usando para cada tabla un hilo de ejecuci\u00f3n distinto. Para representar la tabla de multiplicar de un n\u00famero definiremos una clase que implemente la interfaz <code>Runnable</code>.</p> <p>El c\u00f3digo corresponde a las clases descritas en los ejemplos anterior.</p> MainMultiplicationTable <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        for (int i = 1; i &lt;= 10; i++) {\n            new Thread(new MultiplicationTable(i)).start();\n        }\n    }\n\n}\n</code></pre> <pre><code>class MultiplicationTable implements Runnable {\n\n    private final int number;\n\n    MultiplicationTable(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 1; i &lt;= 10; i++) {\n            System.out.printf(\"%s: %d * %d = %d\\n\", Thread.currentThread()\n                    .getName(), number, i, i * number);\n        }\n    }\n\n}\n</code></pre> <p>Al ejecutar el proyecto podemos comprobar como el orden en que se muestran las l\u00edneas de las diferentes tablas de multiplicar no es igual al de un programa con un \u00fanico hilo, e incluso puede ser diferentes en distintas ejecuciones.</p>"},{"location":"bloque_v/tema_21/page-4/","title":"4 Prioridad de los hilos","text":""},{"location":"bloque_v/tema_21/page-4/#prioridad-en-los-hilos","title":"Prioridad en los hilos","text":"<p>Como hemos visto anteriormente cuando hablamos de la clase <code>Thread</code>, uno de los datos gestionados internamente por un hilo es su prioridad. Mediante el m\u00e9todo <code>setPriority(priority)</code> podemos establecer la prioridad de un determinado hilo.</p> <p>La clase <code>Thread</code> nos proporciona una serie de constantes con los valores de prioridad m\u00ednima, normal y m\u00e1xima, denominadas respectivamente <code>Thread.MIN_PRIORITY</code>, <code>Thread.NORM_PRIORITY</code> y <code>Thread.MAX_PRIORITY</code>.</p> <p>Sin embargo, no es recomendable cambiar la prioridad de los hilos porque los problemas de inanici\u00f3n que puede producir.</p> <p>Warning</p> <p>Debemos tener en cuenta que al establecer la prioridad de un hilo tan s\u00f3lo estaremos haciendo una sugerencia al sistema operativo, sin ninguna garant\u00eda de que dicha sugerencia sea tenida en cuenta.</p>"},{"location":"bloque_v/tema_21/page-4/#proyecto-priority","title":"Proyecto Priority","text":"<p>Similar al proyecto anterior, pero a cada hilo se le asigna una prioridad. Estableceremos la prioridad m\u00e1xima para los hilos pares y la prioridad m\u00ednima para los impares y comprobaremos el orden en el que se ejecutan los hilos.</p> MainMultiplicationTable <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        for (int i = 1; i &lt;= 10; i++) {\n            Thread thread = new Thread(new MultiplicationTable(i));\n            if ((i % 2) == 0) {\n                thread.setPriority(Thread.MAX_PRIORITY);\n            } else {\n                thread.setPriority(Thread.MIN_PRIORITY);\n            }\n            thread.start();\n        }\n    }\n\n}\n</code></pre> <pre><code>class MultiplicationTable implements Runnable {\n\n    private final int number;\n\n    MultiplicationTable(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 1; i &lt;= 10; i++) {\n            System.out.printf(\"%s: %d * %d = %d\\n\", Thread.currentThread()\n                    .getName(), number, i, i * number);\n        }\n    }\n\n}\n</code></pre> <p>Al ejecutar el proyecto podemos comprobar como el orden en que se muestran las l\u00edneas de las diferentes tablas de multiplicar no es igual al de un programa con un \u00fanico hilo, e incluso puede ser diferentes en distintas ejecuciones. Adem\u00e1s vemos como establecer la prioridad no es ninguna garant\u00eda de ejecuci\u00f3n temprana.</p>"},{"location":"bloque_v/tema_21/page-5/","title":"5 Interrumpir","text":""},{"location":"bloque_v/tema_21/page-5/#interrumpir-un-hilo","title":"Interrumpir un hilo","text":"<p>Como hemos visto, un programa Java con m\u00e1s de un hilo de ejecuci\u00f3n finaliza solamente cuando ha finalizado la ejecuci\u00f3n de todos sus hilos (que no sean demonios) o cuando uno de sus hilos usa el m\u00e9todo <code>System.exit()</code>.</p> <p>Algunas veces, sin embargo, es necesario finalizar un hilo concreto, ya sea porque se quiera cancelar la tarea que el hilo est\u00e1 llevando a cabo o porque sea el \u00fanico hilo que queda en ejecuci\u00f3n y queramos finalizar el programa.</p> <p>Para ello Java proporciona un mecanismo de interrupci\u00f3n para indicar a un hilo que queremos que finalice su ejecuci\u00f3n. Este mecanismo tiene la peculiaridad de que es el propio hilo el que debe comprobar si ha sido interrumpido o no, y decidir si aceptar la solicitud de finalizaci\u00f3n o ignorarla y seguir con su ejecuci\u00f3n, aunque no es el comportamiento que se espera de \u00e9l. Si decide finalizar, simplemente retornar\u00e1 (har\u00e1 <code>return</code>) del m\u00e9todo <code>run()</code>.</p> <p>La clase <code>Thread</code> tiene un atributo que almacena un valor booleano que indica si el hilo ha sido interrumpido o no (flag o bandera). Cuando se llama al m\u00e9todo <code>interrupt()</code> de un hilo, se establece dicho atributo a <code>true</code>. Podemos usar el m\u00e9todo <code>isInterrupted()</code> para conocer el valor de dicho atributo.</p> <p>Nunca hagas esto</p> <p>Nunca uses el m\u00e9todo <code>stop()</code> de la clase Thread</p> <p>La clase <code>Thread</code> dispone de un m\u00e9todo <code>stop()</code>, que fuerza que un hilo deje de ejecutarse inmediatamente. Sin embargo, esta forma de actuar es totalmente insegura, ya que no permite al hilo liberar antes de terminar su ejecuci\u00f3n los recursos que hubiera adquirido. Por tanto no se recomienda bajo ninguna circunstancia el uso de el m\u00e9todo <code>stop()</code>, y de hecho se trata de un m\u00e9todo deprecated (obsoleto).</p> <p>Existe otro m\u00e9todo en la clase <code>Thread</code>, en este caso est\u00e1tico, llamado <code>interrupted()</code> que retorna si el hilo que se est\u00e1 ejecutando ha sido interrumpido o no, y establece dicho atributo a <code>false</code>.</p> <p>La diferencia entre <code>isInterrupted()</code> y <code>Thread.interrupted()</code> es que este \u00faltimo borra el estado de interrupci\u00f3n del hilo, mientras que el otro no.</p> <p>Si el c\u00f3digo que comprueba el estado de la interrupci\u00f3n es el \"propietario\" del hilo, en ciertos casos muy concretos puede ser apropiado borrar la bandera de interrumpido, siempre y cuando el propietario est\u00e1 implementando la pol\u00edtica de cancelaci\u00f3n del hilo.</p> <p>Tips</p> <p>En general se prefiere usar <code>isInterrupted()</code> frente a <code>Thread.interrupted()</code>.</p> <p>Sin embargo, en la gran mayor\u00eda de los casos, incluyendo cuando el c\u00f3digo ejecutado por el hilo corresponde a un Runnable, el c\u00f3digo en cuesti\u00f3n no es el propietario del hilo y por tanto no debe borrar la bandera de interrupci\u00f3n, dado que no es quien implementa la pol\u00edtica de cancelaci\u00f3n.</p> <p>Por tanto, dentro del m\u00e9todo <code>run()</code> del hilo deberemos comprobar peri\u00f3dicamente el valor de <code>isInterrupted()</code> para comprobar si se ha solicitado la interrupci\u00f3n del hilo.</p> <pre><code>public class MyRunnable implements Runnable {\n\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            // ...\n        }\n    }\n\n}\n</code></pre> <p>Un aspecto muy importante de la interrupci\u00f3n es que si el hilo trata de ejecutar alguna operaci\u00f3n bloqueante (que vaya a bloquear el hilo), como por ejemplo las operaciones <code>wait()</code>, <code>join()</code>, <code>sleep()</code> (que veremos m\u00e1s adelante), o las llamadas de E/S bloqueantes, y dicho hilo tiene activado el valor booleano de interrupci\u00f3n, la llamada a dicho m\u00e9todo lanzar\u00e1 autom\u00e1ticamente la excepci\u00f3n <code>InterruptedException</code>, por lo que deberemos capturar la interrupci\u00f3n o hacer que el m\u00e9todo dicha excepci\u00f3n.</p> <p>Igualmente, si el hilo est\u00e1 bloqueado en alguna de estas operaciones bloqueantes y se le activa el valor booleano de interrupci\u00f3n desde otro hilo, el hilo que estaba bloqueado ser\u00e1 desbloqueado inmediatamente y se le lanzar\u00e1 autom\u00e1ticamente la excepci\u00f3n <code>InterruptedException</code>.</p> <pre><code>public class MyRunnable implements Runnable {\n\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            // ...\n            try {\n                Thread.sleep(sleepingTime);\n            } catch (InterruptedException e) {\n                // The thread has been interrupted\n                return;\n            }\n        }\n    }\n\n}\n</code></pre> <p>Cuando el c\u00f3digo de un hilo no es sencillo, como por ejemplo en el caso de que sea recursivo, el m\u00e9todo descrito anteriormente de capturar directamente la interrupci\u00f3n del hilo puede llegar a ser complejo. En estos casos es mejor opci\u00f3n dejar que el propio m\u00e9todo lance la excepci\u00f3n <code>InterruptedException</code> cuando se detecte que se el hilo ha sido marcado como interrumpido, propagando la excepci\u00f3n hacia el llamador. Al final de la cadena de llamadas, en el m\u00e9todo <code>run()</code> capturaremos la excepci\u00f3n.</p> <pre><code>public class MyRunnable implements Runnable {\n\n    @Override\n    public void run() {\n        try {\n            recursiveMethod(initialValue);\n        } catch (InterruptedException e) {\n            // The thread has been interrupted\n            return;\n        }\n    }\n\n    private void recursiveMethod(int value) throws InterruptedException {\n        // ...\n    }\n\n}\n</code></pre> <p>En general, debemos decidir qu\u00e9 hacer cuando detectamos que el hilo ha sido marcado para interrupci\u00f3n. Tenemos varias opciones:</p> <ul> <li>Propagar la excepci\u00f3n <code>InterruptedException</code> simplemente no captur\u00e1ndola.</li> <li>Capturar la excepci\u00f3n, realizar operaciones de liberaciones de recursos obtenidos por el hilo y despu\u00e9s relanzar la excepci\u00f3n.</li> <li>Capturar la excepci\u00f3n y terminar.</li> <li>Capturar la excepci\u00f3n, restaurar el indicador de interrupci\u00f3n y terminar.</li> </ul>"},{"location":"bloque_v/tema_21/page-5/#proyecto-interrupt","title":"Proyecto Interrupt","text":"<p>En este proyecto desarrollaremos un programa que crea un hilo dedicado a mostrar por pantalla n\u00fameros primeros. Transcurridos unos segundos el hilo principal solicita al hilo impresor de n\u00fameros primos que finalice usando el mecanismo de interrupci\u00f3n descrito anteriormente.</p> MainPrimeNumberPrinter <pre><code>public class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new PrimeNumberPrinter(), \"Prime number printer\");\n        thread.start();\n        // Sleep for 2 second.\n        Thread.sleep(2000);\n        // Active interruption flag in thread.\n        thread.interrupt();\n    }\n\n}\n</code></pre> <pre><code>public class PrimeNumberPrinter implements Runnable {\n\n    @Override\n    public void run() {\n        // Print prime numbers until someone interrupts the thread.\n        for (long i = 1L; !Thread.currentThread().isInterrupted(); i++) {\n            if (isPrimeNumber(i)) {\n                System.out.printf(\"%d is a prime number\\n\", i);\n                // If the thread is interrupted while sleeping\n                // InterruptedException will be thrown.\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    System.out.println(\"I've been interrupted while sleeping\");\n                    return;\n                }\n            }\n        }\n        System.out.println(\"I've been interrupted\");\n    }\n\n    private boolean isPrimeNumber(long number) {\n        if (number &lt; 1) {\n            throw new IllegalArgumentException();\n        }\n        for (long i = 2; i * i &lt; number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n</code></pre> <p>Si ejecutamos el proyecto veremos que tan s\u00f3lo se imprimen n\u00fameros durante dos segundos, dado que transcurrido dicho tiempo el hilo principal interrumpe el hilo secundario.</p>"},{"location":"bloque_v/tema_21/page-5/#proyecto-interruptedrecursivefactorial","title":"Proyecto InterruptedRecursiveFactorial","text":"<p>En este proyecto desarrollaremos un programa que crea un hilo dedicado a mostrar por pantalla el factorial de los n\u00famero naturales. Dicho hilo usa una funci\u00f3n recursiva para calcular el factorial. Transcurridos unos segundos el hilo principal solicita al hilo impresor de factoriales que finalice usando el mecanismo de interrupci\u00f3n descrito anteriormente.</p> MainFactorialPrinter <pre><code>public class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new FactorialPrinter(), \"Factorial printer\");\n        thread.start();\n        Thread.sleep(2000);\n        thread.interrupt();\n    }\n\n}\n</code></pre> <pre><code>public class FactorialPrinter implements Runnable {\n\n    @Override\n    public void run() {\n        // Print factorials until it is interrupted\n        for (int i = 1; !Thread.currentThread().isInterrupted(); i++) {\n            try {\n                System.out.printf(\"factorial(%d) = %d\\n\", i, factorial(i));\n            } catch (InterruptedException e) {\n                System.out.println(\"I've been interrupted\");\n                return;\n            }\n        }\n\n    }\n\n    private int factorial(int number) throws InterruptedException {\n        if (number &lt; 0) {\n            throw new IllegalArgumentException();\n        }\n        Thread.sleep(50);\n        if (number == 0 || number == 1) {\n            return 1;\n        } else {\n            return number * factorial(number - 1);\n        }\n    }\n\n}\n</code></pre> <p>Si ejecutamos el proyecto veremos que tan s\u00f3lo se imprimen factoriales durante dos segundos, dado que transcurrido dicho tiempo el hilo principal interrumpe el hilo secundario.</p>"},{"location":"bloque_v/tema_21/page-6/","title":"6 Dormir","text":""},{"location":"bloque_v/tema_21/page-6/#dormir-un-hilo","title":"Dormir un hilo","text":"<p>Algunas veces ser\u00e1 interesante suspender la ejecuci\u00f3n de un hilo durante un determinado periodo de tiempo, como por ejemplo en el caso de un hilo que se dedique a comprobar el estado de un sensor cada minuto. Una vez realizada la comprobaci\u00f3n, el hilo debe pasar al estado de dormido durante aproximadamente un minuto, liberando cualquier recurso que estuviera utilizando, incluyendo el procesador. Una vez pasado el minuto, el hilo ser\u00e1 despertado por el sistema y estar\u00e1 listo para continuar con su ejecuci\u00f3n cuando el sistema lo determine.</p> <p>Para dormir un hilo podremos usar el m\u00e9todo <code>sleep(milliseconds)</code> de la clase <code>Thread</code>, que recibe un entero en el que indicamos el n\u00famero de milisegundos que queremos que el hilo suspenda su ejecuci\u00f3n. Cuando concluye el tiempo indicado, el hilo contin\u00faa su ejecuci\u00f3n en la instrucci\u00f3n siguiente a <code>sleep()</code>, cuando el sistema as\u00ed lo determine.</p> <p>Cuando se llama al m\u00e9todo <code>sleep()</code>, el hilo libera la CPU y detiene su ejecuci\u00f3n el tiempo especificado, durante el cual la CPU puede estar ejecutando otras tareas.</p> <p>Uso de sleep()</p> <p>Nosotros usaremos <code>sleep()</code> para simular tareas que tardan un determinado tiempo en ejecutarse</p> <p>En todo caso, debemos tener en cuenta que, no tenemos garant\u00eda de que la cantidad de tiempo que pasamos al m\u00e9todo <code>sleep()</code> sea exactamente el tiempo que est\u00e9 durmiendo el hilo correspondiente, ya que depender\u00e1 de la funcionalidad proporcionada por el sistema operativo.</p> <p>Existe otra posibilidad para dormir un hilo, que consiste en usar el m\u00e9todo <code>sleep()</code> de alg\u00fan elemento de la enumeraci\u00f3n <code>TimeUnit</code>, definida en el paquete <code>java.util.concurrent</code>, que recibir\u00e1 el tiempo de suspensi\u00f3n en la unidad correspondiente a dicha enumeraci\u00f3n, en vez de en milisegundos. Por ejemplo, <code>TimeUnit.SECONDS.sleep(1)</code> duerme el hilo correspondiente durante 1 segundo.</p> <p>Si se trata de echar a dormir un hilo que ha sido marcado como interrupci\u00f3n, o si un hilo est\u00e1 durmiendo y se marca como interrumpido, se lanza inmediatamente en el hilo la excepci\u00f3n <code>InterruptedException</code>, sin esperar a que concluya el tiempo durante el cual el hilo debe estar dormido.</p> <p>En nuestros proyectos usaremos la t\u00e9cnica de dormir un hilo para simular el tiempo que se tarda en realizar una determinada tarea.</p> <p>Warning</p> <p>No se recomienda el uso del m\u00e9todo <code>yield()</code></p> <p>La clase <code>Thread</code> posee otro m\u00e9todo que permite liberar la CPU para que ejecute otra tarea. Se trata del m\u00e9todo <code>yield()</code> (ceder), aunque la JVM no garantiza que dicha cesi\u00f3n se lleve a cabo siempre, por lo que no se recomienda su uso, y s\u00f3lo puede utilizarse cuando estemos depurando nuestro c\u00f3digo.</p>"},{"location":"bloque_v/tema_21/page-6/#proyecto-clock","title":"Proyecto Clock","text":"<p>En este proyecto desarrollaremos un programa que cree un hilo que muestre por pantalla cada segundo la hora actual con horas, minutos y segundos. Haremos uso del m\u00e9todo <code>sleep()</code> para dormir el hilo durante un segundo entre muestra y muestra. Transcurridos unos segundos el hilo principal interrumpir\u00e1 al hilo reloj.</p> MainSecondsHand <pre><code>import java.util.concurrent.TimeUnit;\n\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new SecondsHand(), \"Seconds hand\");\n        thread.start();\n        TimeUnit.SECONDS.sleep(5);\n        thread.interrupt();\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.TimeUnit;\n\npublic class SecondsHand implements Runnable {\n\n    private DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            System.out.println(LocalDateTime.now().format(dateTimeFormatter));\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                System.out.println(\"I've been interrupted while sleeping\");\n                return;\n            }\n        }\n        System.out.println(\"I've been interrupted\");\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que se va mostrando la hora segundo a segundo hasta que pasan 5 segundos, momento en el que el hilo principal interrumpe al hilo secundario.</p>"},{"location":"bloque_v/tema_21/page-7/","title":"7 Esperar la finalizaci\u00f3n","text":""},{"location":"bloque_v/tema_21/page-7/#esperar-la-finalizacion-de-un-hilo","title":"Esperar la finalizaci\u00f3n de un hilo","text":"<p>Imaginemos que dise\u00f1amos un programa que lanza varios hilos que llevan a cabo tareas de inicializaci\u00f3n del programa. Una vez iniciados estos hilos, el hilo principal del programa deber\u00e1 esperar a que concluya la ejecuci\u00f3n de los mismos para poder continuar con su funci\u00f3n, ya que es estrictamente necesario que se haya llevado a cabo completamente la inicializaci\u00f3n antes de seguir con otras tareas. Es evidente que en este caso el hilo principal debe esperar la finalizaci\u00f3n de los otros hilos.</p> <p>Para este cometido la clase <code>Thread()</code> dispone del m\u00e9todo <code>join()</code>. Cuando ejecutamos este m\u00e9todo sobre un objeto hilo, se suspende la ejecuci\u00f3n del hilo llamador hasta que el objeto hilo sobre el que hemos hecho <code>join()</code> concluye su ejecuci\u00f3n. De esta manera podr\u00edamos decir que el hilo llamador espera la uni\u00f3n (join) del hilo llamado. Por ejemplo, si desde el hilo principal de la aplicaci\u00f3n se realiza la llamada <code>hilo2.join()</code>, el hilo principal de la aplicaci\u00f3n suspende su ejecuci\u00f3n hasta que finaliza la ejecuci\u00f3n de <code>hilo2</code>.</p> <p>Sincronizaci\u00f3n final</p> <p><code>join()</code> supone un punto de sincronizaci\u00f3n con la terminaci\u00f3n de otro hilo</p> <p>Java proporciona una sobrecarga adicional del m\u00e9todo <code>join()</code> con el formato <code>join(long milisegundos)</code>, que permite que la espera no sea indefinida, sino que si el hilo llamado no ha finalizado a\u00fan su ejecuci\u00f3n en el n\u00famero de milisegundos indicados, el hilo llamador contin\u00faa su ejecuci\u00f3n. Por ejemplo, si desde el hilo principal de la aplicaci\u00f3n se realiza la llamada <code>hilo2.join(3000)</code>, el hilo principal de la aplicaci\u00f3n suspende su ejecuci\u00f3n hasta que finaliza la ejecuci\u00f3n de <code>hilo2</code> o hasta que hayan transcurrido 3 segundos (lo que ocurra antes). Si pasamos un valor negativo como tiempo m\u00e1ximo de espera se lanza la excepci\u00f3n <code>IllegalArgumentException</code>. Si pasamos el valor <code>0</code> como tiempo m\u00e1ximo de espera, se esperar\u00e1 indefinidamente la finalizaci\u00f3n del hilo sobre el que se ha hecho <code>join()</code>.</p> <p>Como ocurre con la mayor\u00eda de los m\u00e9todos bloqueantes (que bloquean un hilo), si el un hilo ha sido marcado para interrupci\u00f3n y trata de hacer <code>join()</code> sobre otro hilo, o si es marcada para interrupci\u00f3n mientras est\u00e1 bloqueado esperando a que finalice el hilo sobre el que ha hecho <code>join()</code>, se lanzar\u00e1 inmediatamente la excepci\u00f3n <code>InterruptedException</code> sin esperar a que finalice el hilo sobre el que ha hecho <code>join()</code>.</p> <p>No debemos olvidar que cualquier hilo puede esperar la finalizaci\u00f3n de otro hilo, no s\u00f3lo el hilo principal.</p>"},{"location":"bloque_v/tema_21/page-7/#proyecto-join","title":"Proyecto Join","text":"<p>En el siguiente proyecto crearemos una aplicaci\u00f3n que muestra la tabla de multiplicar de los n\u00fameros desde el 1 al 10, usando para cada tabla un hilo de ejecuci\u00f3n distinto. Una vez lanzados los hilos, el hilo principal esperar\u00e1 su finalizaci\u00f3n, tras lo cual mostrar\u00e1 un mensaje en pantalla informativo de que ha concluido la operaci\u00f3n.</p> MainMultiplicationTable <pre><code>public class Main {\n\n    private static final int LAST_NUMBER = 10;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread[] threads = new Thread[LAST_NUMBER + 1];\n        for (int i = 1; i &lt;= LAST_NUMBER; i++) {\n            threads[i-1] = new Thread(new MultiplicationTable(i), \"Table of \" + i);\n            threads[i-1].start();\n        }\n        for (int i = 1; i &lt;= LAST_NUMBER; i++) {\n            threads[i-1].join();\n        }\n        System.out.println(\"All multiplication tables printed\");\n    }\n\n}\n</code></pre> <pre><code>class MultiplicationTable implements Runnable {\n\n    private final int number;\n\n    MultiplicationTable(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 1; i &lt;= 10; i++) {\n            System.out.printf(\"%s: %d * %d = %d\\n\", Thread.currentThread()\n                    .getName(), number, i, i * number);\n        }\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que hasta que no hayan terminado de ejecutarse todos los hilos secundarios el hilo principal no mostrar\u00e1 el mensaje de que todas las tablas se han imprimido.</p>"},{"location":"bloque_v/tema_21/page-8/","title":"8 Daemons","text":""},{"location":"bloque_v/tema_21/page-8/#daemons","title":"Daemons","text":"<p>En Java podemos especificar que un determinado hilo sea considerado como un hilo daemon (demonio), que posee la caracter\u00edstica de que si es el \u00fanico hilo que queda en ejecuci\u00f3n en un programa, la JVM da por finalizado el programa, aunque el hilo demonio siga en ejecuci\u00f3n.</p> <p>Hilo demonio</p> <p>Realizan una determinada tarea y luego se echan a dormir durante un cierto tiempo, en un bucle</p> <p>Por tanto, los hilos demonios se emplean principalmente como hilos proveedores de servicios a otros hilos del programa. Normalmente poseen un bucle infinito que les hace estar siempre en ejecuci\u00f3n, en espera de que le llegue una petici\u00f3n de servicio, o realizando una determinada tarea cada cierto tiempo. Un ejemplo t\u00edpico de este comportamiento es el recolector de basura (garbage collector) de Java.</p> <p>Para indicar que un determinado hilo debe comportarse como hilo demonio deberemos llamar a se m\u00e9todo <code>setDaemon()</code> antes de llamar al m\u00e9todo <code>start()</code>. Una vez que el hilo est\u00e9 en ejecuci\u00f3n no podremos modificar dicho comportamiento, y si llamamos al m\u00e9todo <code>setDaemon()</code> se producir\u00e1 al excepci\u00f3n <code>IllegalThreadStateException</code>.</p> <p>Para saber si un hilo es un hilo demonio podemos llamar al m\u00e9todo <code>isDaemon()</code>.</p>"},{"location":"bloque_v/tema_21/page-9/","title":"9 UncaughtExceptionHandler","text":""},{"location":"bloque_v/tema_21/page-9/#uncaughtexceptionhandler","title":"UncaughtExceptionHandler","text":"<p>Como sabemos, en general en la JVM se pueden producir dos tipos de excepciones:</p> <ul> <li>Checked exceptions (excepciones comprobadas): Son aquellas que deben ser capturadas mediante <code>try-catch</code> o relanzadas incluyendo la cl\u00e1usula <code>throws</code> en la declaraci\u00f3n del m\u00e9todo. Ejemplos de este tipo de excepciones son <code>IOException</code> o <code>ClassNotFoundException</code>.</li> <li>Unchecked exceptions (excepciones no comprobadas): Son aquellas que NO es necesario capturar o relanzar, como por ejemplo <code>NumberFormatException</code>.</li> </ul> <p>Cuando se genera una checked exception dentro del m\u00e9todo <code>run()</code> de un hilo (o de un objeto que implemente <code>Runnable</code>), no tenemos m\u00e1s remedio que capturarla mediante <code>try catch</code>, ya que NO podemos redefinir el m\u00e9todo <code>run()</code> a\u00f1adi\u00e9ndole la cl\u00e1usula <code>throws</code>.</p> <p>Por su parte, si se produce una unchecked exception dentro del m\u00e9todo <code>run()</code> de un hilo, simplemente se mostrar\u00e1 el error en la consola y terminar\u00e1 la ejecuci\u00f3n del programa.</p> <p>Sin embargo, podemos modificar dicho comportamiento por defecto creando un objeto manejador (handler) que implemente la interfaz <code>Thread.UncaughtExceptionHandler</code>, y asign\u00e1ndoselo al hilo mediante el m\u00e9todo <code>setUncaughtExceptionHandler(handler)</code> de la clase <code>Thread</code>.</p> <pre><code>@FunctionalInterface\npublic interface UncaughtExceptionHandler {\n    void uncaughtException(Thread t, Throwable e);\n}\n</code></pre> <p>De esta manera, cuando se produzca una uncaught exception dentro del m\u00e9todo <code>run()</code> de dicho hilo, la JVM llamar\u00e1 al m\u00e9todo <code>uncaughtException()</code> del objeto manejador, pas\u00e1ndole el objeto <code>Thead</code> y el objeto <code>Exception</code> para que decida c\u00f3mo manejar la situaci\u00f3n, evitando as\u00ed la finalizaci\u00f3n autom\u00e1tica de ejecuci\u00f3n de la aplicaci\u00f3n.</p> <p>La clase <code>Thead</code> proporciona tambi\u00e9n el m\u00e9todo est\u00e1tico <code>Thread.setDefaultUncaughtExceptionHandler(handler)</code> que permite establecer el objeto manejador cuyo m\u00e9todo <code>uncaughtException()</code> debe ser llamado cuando se produzca una unchecked exception en cualquiera de los hilos del programa. De esta manera no ser\u00e1 necesario indicar el manejador individualmente para cada hilo.</p> <p>As\u00ed, en caso se producirse una unchecked exception dentro del m\u00e9todo <code>run()</code> de un hilo, la JVM sigue el siguiente procedimiento:</p> <ol> <li>Llamar\u00e1 al m\u00e9todo <code>uncaughtException()</code> del objeto manejador establecido individualmente para dicho hilo.</li> <li>Si no existe, llamar\u00e1 al m\u00e9todo <code>uncaughtException()</code> del manejador establecido para el grupo de hilos al que pertenezca el hilo (<code>ThreadGroup</code>, lo veremos m\u00e1s adelante).</li> <li>Si no existe, llamar\u00e1 al del manejador por defecto establecido para la aplicaci\u00f3n,</li> <li>Si ninguno de los anteriores existe, mostrar\u00e1 el error en la consola y finalizar\u00e1 la ejecuci\u00f3n de la aplicaci\u00f3n.</li> </ol>"},{"location":"bloque_v/tema_21/page-9/#proyecto-uncaughtexceptionhandler","title":"Proyecto UncaughtExceptionHandler","text":"<p>En este proyecto crearemos un programa que a conciencia produce una unchecked exception en un hilo, para que sea manejada por un objeto <code>UncaughtExceptionHandler</code> que ser\u00e1 asociado al mismo.</p> MainExceptionHandlerTask <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new Task());\n        thread.setUncaughtExceptionHandler(new ExceptionHandler());\n        thread.start();\n    }\n\n}\n</code></pre> <pre><code>import java.lang.Thread.UncaughtExceptionHandler;\n\npublic class ExceptionHandler implements UncaughtExceptionHandler {\n\n    @Override\n    public void uncaughtException(Thread t, Throwable e) {\n        System.out.printf(\"Thread: %s\\n\", t.getId());\n        System.out.printf(\"Exception: %s: %s\\n\", e.getClass().getName(), e.getMessage());\n        System.out.printf(\"Stack Trace: \\n\");\n        e.printStackTrace(System.out);\n    }\n\n}\n</code></pre> <pre><code>public class Task implements Runnable {\n\n    @Override\n    public void run() {\n        // Throws a checked exception.\n        int num = Integer.parseInt(\"Baldomero\");\n        // It will never be executed.\n        System.out.printf(\"Number: %d \", num);\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que se captura la excepci\u00f3n y se muestran datos sobre ella</p>"},{"location":"bloque_v/tema_22/page-1/","title":"1 Introducci\u00f3n a la Sincronizaci\u00f3n","text":""},{"location":"bloque_v/tema_22/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Uno de los problemas m\u00e1s frecuentes cuando realizamos programaci\u00f3n concurrente consiste en el hecho de que varios hilos compartan un recurso. Es bastante usual que distintos hilos deban leer y escribir sobre las mismas variables de datos o tener acceso al mismo fichero o conexi\u00f3n de base de datos. Estos recursos compartidos pueden provocar errores de acceso o de inconsistencia de datos, por lo que tendremos que implementar mecanismos que los eviten.</p> <p>Para ayudar a los programadores a implementar secciones cr\u00edticas, Java (y la mayor\u00eda de los lenguajes de programaci\u00f3n) ofrecen distintos mecanismos de sincronizaci\u00f3n. En general, llamamos mecanismo de sincronizaci\u00f3n a la palabra reservada o clase que es usada para controlar el flujo de hilos cooperativos en base a su estado (ver).</p> <p>Los distintos mecanismos de sincronizaci\u00f3n incorporan una o varias de las siguientes capacidades:</p> <ul> <li>Visibilidad: Asegura que los cambios realizados por un hilo en un recurso compartido son visibles para el siguiente hilo que acceda a dicho recurso. Si no se cumpliera este requisito, los hilos podr\u00edan estar trabajando con valores inconsistentes para el recurso. La visibilidad no est\u00e1 implementada por defecto en los tipos primitivos de Java.</li> <li>Exclusi\u00f3n mutua: Permite el acceso concurrente y la actuaci\u00f3n de datos compartidos mutables sin producir race conditions. Para ello se implementa el concepto de secci\u00f3n cr\u00edtica, que consiste en un bloque de c\u00f3digo que accede a un recurso compartido y que no puede ser ejecutado a la vez por m\u00e1s de un hilo en un momento dado. Cuando un hilo quiere acceso a una secci\u00f3n cr\u00edtica, usa el mecanismo de sincronizaci\u00f3n para averiguar si ya hay alg\u00fan otro hilo ejecut\u00e1ndola. Si la secci\u00f3n cr\u00edtica est\u00e1 disponible, el hilo entra en ella. Si, por el contrario, ya est\u00e1 ocupada, el hilo es suspendido por el mecanismo de sincronizaci\u00f3n hasta que el hilo que la est\u00e1 ocupando termine la ejecuci\u00f3n de la secci\u00f3n cr\u00edtica. Cuando haya m\u00e1s de un hilo esperando para poder ejecutar la misma secci\u00f3n cr\u00edtica, la JVM elige uno de ellos, y el resto esperan su turno.</li> <li>Coordinaci\u00f3n: Asegura que el c\u00f3digo se ejecuta en el orden correcto, en el momento correcto y bajo las condiciones necesarias.</li> <li>Barrera de sincronizaci\u00f3n: Aseguro que varios hilos deben suspender su ejecuci\u00f3n en un determinado punto de sincronizaci\u00f3n (barrera) hasta que todos los hilos hayan llegado a dicho punto.</li> </ul>"},{"location":"bloque_v/tema_22/page-10/","title":"10 StampedLock","text":""},{"location":"bloque_v/tema_22/page-10/#introduccion","title":"Introducci\u00f3n","text":"<p>En las versiones Java 5 y Java 6 el empleo de la clase <code>ReentrantReadWriteLock</code> presenta el problema de que puede producir inanici\u00f3n (starvation) en alguno de los hilos, es decir, que sea tan frecuente los accesos (por ejemplo de lectura) que un hilo que quiera acceder al recurso para escritura no puedan adquirir nunca el cerrojo. Incluso si no se produce inanici\u00f3n, es probable que la adquisici\u00f3n del cerrojo para escritura se retrase en demas\u00eda.</p> <p>StampedLock</p> <p>Cerrojo que proporciona un modo de adquisici\u00f3n optimista para lectura, adem\u00e1s de los modos pesimistas para lectura y para escritura</p> <p>Para solucionar este problema, Java 8 trajo consigo un nuevo tipo de cerrojo denominado <code>StampedLock</code>, que supone en la pr\u00e1ctica una mejora de las prestaciones proporcionadas por <code>ReentrantReadWriteLock</code>, siendo m\u00e1s eficiente y escalable. Una de dichas prestaciones adicionales es la posibilidad de llevar a cabo una adquisici\u00f3n optimista del cerrojo de lectura, algo que no es posible mediante <code>ReentrantReadWriteLock</code> que siempre emplea una adquisici\u00f3n pesimista.</p> <p>Cabe destacar que la clase <code>StampedLock</code> no implementa las interfaces <code>Lock</code> ni <code>ReadWriteLock</code>, aunque proporciona una funcionalidad muy similar e incluso adicional a esta \u00faltima.</p> <p>Al igual que en el caso de <code>synchronized</code> y los cerrojos \u00edntr\u00ednsecos, y de la interfaz <code>Lock</code>, al usar <code>StampedLock</code> no s\u00f3lo aseguramos la atomicidad sino tambi\u00e9n la visibilidad, por lo que no ser\u00e1 necesario definir las variables protegidas con <code>volatile</code>.</p> <p>La clase <code>StampedLock</code> proporciona tres modos distintos de obtener el cerrojo. En todos estos modos el hecho de la adquisici\u00f3n del cerrojo se retorna de forma de un valor de tipo <code>long</code> conocido como stamp (sello, ticket), de ah\u00ed el nombre de la clase. Dicho stamp contiene internamente un n\u00famero de versi\u00f3n y un modo de adquisici\u00f3n. Veamos los distintos modos de adquisici\u00f3n:</p>"},{"location":"bloque_v/tema_22/page-10/#adquisicion-pesimista-para-escritura","title":"Adquisici\u00f3n pesimista para escritura","text":"<p>Se realiza mediante el m\u00e9todo <code>writeLock()</code>. Si un hilo obtiene el cerrojo para escritura, ning\u00fan otro hilo puede obtener el cerrojo para escritura ni para lectura. Si otro hilo ya hab\u00eda adquirido el cerrojo para escritura, el hilo que llama a <code>writeLock()</code> ser\u00e1 suspendido. Retorna un stamp.</p> <p>Podemos usar tambi\u00e9n el m\u00e9todo <code>tryWriteLock()</code>, que trata de adquirir el cerrojo para escritura y si no puede NO suspende al hilo desde el que se llama, sino que simplemente retorna inmediatamente un sello (stamp) con valor <code>0</code>. Tambi\u00e9n tenemos la versi\u00f3n sobrecargada <code>tryWriteLock(long time, TimeUnit unit)</code>, que trata de adquirir el cerrojo para escritura y si no puede porque otro hilo ya lo ha adquirido para escritura, suspende al hilo desde el que se llama como m\u00e1ximo el tiempo indicado. Si transcurrido dicho tiempo no se ha conseguido adquirir el cerrojo para escritura, retorna un sello con el valor 0.</p> <p>En este caso podemos afirmar que este modo es pesimista, en el sentido de que se asume que puede haber dos hilos intentando acceder para escritura, por lo que se proh\u00edbe que esto suceda, haciendo que la adquisici\u00f3n sea en exclusiva. Como vemos, su funcionamiento es similar al del cerrojo de escritura de la clase <code>ReentrantReadWriteLock</code>.</p>"},{"location":"bloque_v/tema_22/page-10/#adquisicion-pesimista-para-lectura","title":"Adquisici\u00f3n pesimista para lectura","text":"<p>Se realiza mediante el m\u00e9todo <code>readLock()</code> o <code>readLockInterruptibly()</code>. Si un hilo obtiene el cerrojo para lectura, ning\u00fan otro hilo puede obtener el cerrojo para escritura, pero s\u00ed para lectura. Si otro hilo ya hab\u00eda adquirido el cerrojo para escritura, el hilo que llama a <code>readLock()</code> ser\u00e1 suspendido. Estos m\u00e9todos retornan un stamp.</p> <p>Podemos usar tambi\u00e9n el m\u00e9todo <code>tryReadLock()</code>, que trata de adquirir el cerrojo para lectura, y si no puede porque otro hilo ya lo ha adquirido para escritura, NO suspende al hilo desde el que se llama, sino que simplemente retorna inmediatamente un sello (stamp) con valor 0.</p> <p>Tambi\u00e9n tenemos la versi\u00f3n sobrecargada <code>tryReadLock(long time, TimeUnit unit)</code>, que trata de adquirir el cerrojo para lectura. Si no puede porque otro hilo ya lo ha adquirido para escritura, suspende al hilo desde el que se llama como m\u00e1ximo el tiempo indicado. Si transcurrido dicho tiempo no se ha conseguido adquirir el cerrojo para lectura, retorna un sello (stamp) con el valor 0.</p> <p>En este caso podemos afirmar que este modo es pesimista, en el sentido de que se asume que adem\u00e1s del hilo que quiere acceder al cerrojo para lectura puede haber otro hilo intentando acceder para escritura, por lo que se proh\u00edbe que esto suceda, haciendo que la adquisici\u00f3n del cerrojo para escritura s\u00f3lo pueda realizarse cuando se libere el cerrojo de lectura. Como vemos, su funcionamiento es similar al del cerrojo de lectura de la clase <code>ReentrantReadWriteLock</code>.</p>"},{"location":"bloque_v/tema_22/page-10/#adquisicion-optimista-para-lectura","title":"Adquisici\u00f3n optimista para lectura","text":"<p>Se realiza mediante el m\u00e9todo <code>tryOptimisticRead()</code>, que, independientemente de si el cerrojo est\u00e1 realmente disponible, nunca suspende al hilo llamador, sino que retorna un stamp. Si el cerrojo no est\u00e1 disponible porque ha sido adquirido para escritura, el valor retornado ser\u00e1 0.</p> <p>Al obtener optimistamente el cerrojo de lectura, NO se bloquea la adquisici\u00f3n inmediata del cerrojo para para escritura por parte de otro hilo, a diferencia de c\u00f3mo ocurre con <code>readLock()</code>.</p> <p>Se dice que la adquisici\u00f3n es optimista porque estamos presuponiendo que es muy improbable que alg\u00fan otro hilo obtenga el cerrojo para escritura, por lo que ni siquiera nos suspendemos. Si realmente el acceso para escritura es muy poco frecuente entonces el rendimiento de este tipo de adquisici\u00f3n es muy alto, ya que el hilo nunca ser\u00e1 suspendido. Por este motivo, la adquisici\u00f3n optimista es especialmente eficiente si vamos a ejecutar un fragmento de c\u00f3digo corto que s\u00f3lo realice lectura de valores. Cuando m\u00e1s largo sea el fragmento de c\u00f3digo m\u00e1s probable sea que el stamp deje de ser v\u00e1lido porque otro hilo haya adquirido el cerrojo para escritura.</p> <p>Sin embargo, debemos ser conscientes de que, aunque improbable, es posible que despu\u00e9s de haber adquirido el cerrojo para lectura de forma optimista, otro hilo adquiera el cerrojo para escritura, y lo podr\u00e1 hacer sin problema, dado que el acceso optimista para lectura no lo evita. En este caso, el stamp que recibi\u00f3 el hilo como respuesta a la llamada al m\u00e9todo <code>tryOptimisticRead()</code> deja de ser v\u00e1lido y seguir\u00e1 siendo inv\u00e1lido incluso despu\u00e9s de que el hilo libere el cerrojo de escritura.</p> <p>Por este motivo, despu\u00e9s de haber obtenido el cerrojo para lectura de forma optimista ser\u00e1 necesario que validemos el stamp recibido para comprobar que realmente podemos leer del recurso con seguridad. Para ello llamaremos al m\u00e9todo <code>validate(stamp)</code>, que retornar\u00e1 <code>true</code> s\u00f3lo si el stamp sigue siendo v\u00e1lido (seguro de usar), es decir, s\u00f3lo si no se ha adquirido el cerrojo de escritura desde el momento en el que obtuvo dicho stamp.</p> <p>Si tenemos \u00e9xito con el m\u00e9todo <code>validate()</code>, la sobrecarga por sincronizaci\u00f3n habr\u00e1 sido pr\u00e1cticamente inexistente, y ni siquiera deberemos liberar ning\u00fan cerrojo, porque de hecho no se habr\u00e1 obtenido realmente.</p> <p>Si no hemos tenido \u00e9xito con el m\u00e9todo <code>validate()</code> lo normal es que realicemos un segundo intento de adquisici\u00f3n del cerrojo para lectura, pero esta vez de forma pesimista, para asegurarnos de no tener que intentarlo una tercera vez.</p> <p>Como vemos, la adquisici\u00f3n optimista para lectura es inherentemente fr\u00e1gil y obliga a que validemos el stamp despu\u00e9s de haber realizado la lectura.</p> <p>Pese a tener algunas similitudes, la clase <code>StampedLock</code> NO es una extensi\u00f3n de la clase <code>ReentrantReadWriteLock</code>, y de hecho NO implementa la interfaces <code>Lock</code> ni <code>ReadWriteLock</code>. A diferencia de <code>ReadWriteLock</code>, todos los m\u00e9todos de adquisici\u00f3n del cerrojo en la clase <code>StampedLock</code> retornan un stamp, que puede ser usado posteriormente para otras operaciones, como liberar el cerrojo, comprobar si el acceso al cerrojo es a\u00fan v\u00e1lido o convertir el modo de acceso al mismo.</p> <p>Para liberar un cerrojo adquirido previamente de forma pesimista usaremos alguno de los siguientes m\u00e9todos, dependiendo del modo para el que se adquiri\u00f3 el cerrojo. Todos ellos reciben el stamp que representa la adquisici\u00f3n del cerrojo:</p> <ul> <li><code>unlockWrite(stamp)</code>: Para liberar un cerrojo que se adquiri\u00f3 para escritura de forma pesimista.</li> <li><code>unlockRead(stamp)</code>: Para liberar un cerrojo que se adquiri\u00f3 para lectura de forma pesimista.</li> <li><code>unlock(stamp)</code>: Para liberar un cerrojo independientemente del modo para el que se adquiri\u00f3. Es menos eficiente que los anteriores.</li> </ul> <p>Normalmente la llamada a estos m\u00e9todos se incluir\u00e1 dentro de la rama <code>finally</code> de un <code>try finally</code>, para asegurarnos de que el cerrojo es liberado independientemente de si se produce un error o no.</p> <p>Si hemos adquirido el cerrojo para lectura de forma optimista y ha sido validado entonces no ser\u00e1 necesario liberarlo, ya que realmente no se habr\u00e1 suspendido a ning\u00fan hilo.</p> <p>Veamos un ejemplo:</p> <pre><code>class Point {\n\n    // Variables a proteger.\n    private double x, y;\n    // Lock que las protege\n    private final StampedLock stampedLock = new StampedLock();\n\n    // Desplaza el punto\n    void move(double deltaX, double deltaY) {\n        // Adquiere el cerrojo para escritura (pesimista).\n        long stamp = stampedLock.writeLock();\n        try {\n            x += deltaX;\n            y += deltaY;\n        } finally {\n            // Lo libera.\n            stampedLock.unlockWrite(stamp);\n        }\n    }\n\n    // Retorna la distancia respecto al origen.\n    double distanceFromOrigin() {\n        // Obtiene el cerrojo para lectura de forma optimista.\n        long stamp = stampedLock.tryOptimisticRead();\n        // Se leen los valores.\n        double currentX = x, currentY = y;\n        // Debe validar que el stamp es a\u00fan v\u00e1lido antes de retornar, porque\n        // puede que otro hilo haya llamado mientras tanto al m\u00f3todo move()\n        // y haya obtenido el cerrojo para escritura, cambiando los valores\n        // x e y.\n        if (!stampedLock.validate(stamp)) {\n            // Si no es v\u00e1lido debemos volver a leer los valores, pero antes\n            // obtenemos el cerrojo de lectura de forma optimista.\n            stamp = stampedLock.readLock();\n            try {\n                currentX = x;\n                currentY = y;\n            } finally {\n                // Se libera el cerrojo de lectura.\n                stampedLock.unlockRead(stamp);\n            }\n        }\n        // Si hemos llegado aqu\u00ed, es porque hemos leido los valores, ya haya\n        // sido de forma optimista o pesimista.\n        return Math.sqrt(currentX * currentX + currentY * currentY);\n    }\n}\n</code></pre> <p>Otra diferencia importante de <code>StampedLock</code> respecto a <code>ReentrantReadWriteLock</code>, que s\u00f3lo permit\u00eda lock downgrading es que <code>StampedLock</code> proporciona m\u00e9todos espec\u00edficos para convertir el modo de adquisici\u00f3n de un cerrojo ya adquirido previamente, permitiendo realizar lock upgrading, es decir cambiar a un modo de adquisici\u00f3n m\u00e1s severo:</p> <ul> <li><code>tryConvertToWriteLock(stamp)</code>: Trata de adquirir para escritura un cerrojo adquirido anteriormente en otro modo. Este m\u00e9todo nunca suspender\u00e1 al hilo llamador, sino que retornar\u00e1 un nuevo stamp, cuyo valor ser\u00e1 0 si la conversi\u00f3n no es posible porque otro hilo ya haya adquirido el cerrojo para escritura.</li> <li><code>tryConvertToReadLock(stamp)</code>: Trata de adquirir para lectura un cerrojo adquirido anteriormente en otro modo. Este m\u00e9todo nunca suspender\u00e1 al hilo llamador, sino que retornar\u00e1 un nuevo stamp, cuyo valor ser\u00e1 0 si la conversi\u00f3n no es posible porque otro hilo ya haya adquirido el cerrojo para escritura.</li> <li><code>tryConvertToOptmisticRead(stamp)</code>: Trata de adquirir optimistamente para lectura un cerrojo adquirido anteriormente en otro modo. Este m\u00e9todo nunca suspender\u00e1 al hilo llamador, sino que retornar\u00e1 un nuevo stamp.</li> </ul> <p>Continuemos el ejemplo anterior, a\u00f1adiendo a la clase <code>Point</code> un nuevo m\u00e9todo en el que primero se adquiere el cerrojo para lectura de forma pesimista y una vez le\u00eddos los datos se trata de convertirlo a un cerrojo de escritura pesimista para poder modificarlos:</p> <pre><code>class Point {\n\n    private double x, y;\n    private final StampedLock stampedLock = new StampedLock();\n\n    // ...\n\n    // Mueve el punto s\u00f3lo si \u00e9ste se encuentra en el origen de coordenadas.\n    void moveIfAtOrigin(double newX, double newY) { \n        // Obtenemos el cerrojo para lectura de forma pesimista.\n        // (tambi\u00e9n lo podr\u00edamos haber hecho de forma optimista).\n        long stamp = stampedLock.readLock();\n        try {\n            // Solo intentamos cambiar los datos si el punto se encuentre en el origen\n            // de coordenadas. \n            // Debe ser un bucle para que volvamos a intentarlo si no\n            // ha sido posible la conversi\u00f3n, teniendo en cuenta que otro hilo ha podido\n            // cambiar la posici\u00f3n del punto entre las sentencias de las l\u00edneas 39 y 40.\n            while (x == 0.0 &amp;&amp; y == 0.0) {\n                // Intentamos convertir el cerrojo a uno para escritura.\n                long writeStamp = stampedLock.tryConvertToWriteLock(stamp);\n                if (writeStamp != 0L) {\n                    // Si ha sido posible la conversi\u00f3n del cerrojo, se guarda\n                    // como stamp para luego liberarlo.\n                    stamp = writeStamp;\n                    // Se cambia la posici\u00f3n del punto.\n                    x = newX;\n                    y = newY;\n                    // Para que se salga del bucle una vez hechos los cambios.\n                    break;\n                }\n                else {\n                    // Si no ha sido posible la conversi\u00f3n del cerrojo, se libera\n                    // el cerrojo de lectura y se obtiene el de escritura de forma \n                    // pesimista.\n                    // Al tratarse de un bucle while, se vovler\u00e1 a entrar y la conversi\u00f3n\n                    // obligatoriamente ser\u00e1 posible, ya que estaremos convirtiendo en \n                    // cerrojo de escrtura uno que ya lo es, por lo que finalmente\n                    // se cambiar\u00e1 al punto de posici\u00f3n, saliendo del bucle.\n                    stampedLock.unlockRead(stamp);\n                    stamp = stampedLock.writeLock();\n                }\n            }\n        } finally {\n            // Se libera el cerrojo (el \u00faltimo obtenido, proveniente de la conversi\u00f3n).\n            stampedLock.unlock(stamp);\n        }\n    }\n\n }\n</code></pre> <p>La clase <code>StampedLock</code> tambi\u00e9n nos proporciona una serie de m\u00e9todos informativos, como <code>isReadLocked()</code> y <code>isWriteLocked()</code>, que retornan si el cerrojo ha sido adquirido, respectivamente, en modo de lectura pesimista o en modo de escritura pesimista.</p> <p>Debemos tener en cuenta que <code>StampedLock</code> no implementa la caracter\u00edstica de readquisici\u00f3n autom\u00e1tica (reentrant) del cerrojo. Cada llamada a un m\u00e9todo de adquisici\u00f3n del cerrojo retorna un nuevo stamp y puede bloquear el hilo incluso aunque \u00e9ste ya hubiera adquirido el cerrojo, por lo que debemos prestar especial atenci\u00f3n a no incurrir en deadlocks.</p> <p>Otra diferencia importante es que <code>StampedLock</code> no tiene noci\u00f3n de propiedad del cerrojo, lo que implica que puede ser adquirido por un hilo y liberado por otro, siempre y cuando se use el mismo stamp.</p> <p>Adem\u00e1s, no se puede aplicar un modo justo (fair mode), porque no se implementa ninguna pol\u00edtica sobre cu\u00e1l es el hilo que debe obtener el cerrojo a continuaci\u00f3n.</p> <p>Por lo general, el empleo de <code>StampedLock</code> hace que nuestro c\u00f3digo se ejecute m\u00e1s r\u00e1pido que si usamos <code>ReentrantReadWriteLock</code>, aunque no en todas las ocasiones. Por otra parte, el uso de cerrojos de lectura y escritura frente al uso de <code>ReentrantLock</code> s\u00f3lo mejora el rendimiento cuando el n\u00famero de hilos lectores es muy superior al de hilos escritores, las operaciones de lectura no sean triviales y dispongamos de bastantes n\u00facleos de procesamiento.</p>"},{"location":"bloque_v/tema_22/page-10/#proyecto-stampedlock","title":"Proyecto StampedLock","text":"<p>En este proyecto crearemos una aplicaci\u00f3n que simula la venta de un producto. Por un lado existir\u00e1n clientes que consultar\u00e1n el precio del producto y por otra parte un hilo que representa la tienda vendedora puede cambiar el precio del producto. Usaremos la clase <code>StampedLock</code> para permitir que varios clientes consulten el precio a la vez de manera optimista.</p> MainProductClientShop <pre><code>import java.util.concurrent.TimeUnit;\n\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        Product product = new Product(100.00);\n        Thread[] clientThreads= new Thread[4];\n        for (int i = 0; i &lt; 4; i++) {\n            clientThreads[i] = new Thread(new Client(product), \"Client \" + i);\n        }\n        Thread shopThread = new Thread(new Shop(product), \"Shop\");\n        shopThread.start();\n        // Wait to start some clients.\n        TimeUnit.SECONDS.sleep(1);\n        for (int i = 0; i &lt; 2; i++){\n            clientThreads[i].start();\n        }\n        // Wait to start the rest of the clients.\n        TimeUnit.SECONDS.sleep(3);\n        for (int i = 2; i &lt; 4; i++){\n            clientThreads[i].start();\n        }\n        // Try to check a client thread blocks the shop thread but not other clients threads.\n        // Try to check the shop thread blocks client threads.\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.StampedLock;\n\npublic class Product {\n\n    private double price;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n    private final StampedLock stampedLock = new StampedLock();\n\n    public Product(double initialPrice) {\n        this.price = initialPrice;\n    }\n\n    public double getPrice() throws InterruptedException {\n        long stamp = stampedLock.tryOptimisticRead();\n        return consultPrice(stamp);\n    }\n\n    private double consultPrice(long stamp) throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s - Consulting price...\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName());\n        TimeUnit.SECONDS.sleep(3);\n        double value = price;\n        if (!stampedLock.validate(stamp)) {\n            stamp = stampedLock.readLock();\n            try {\n                value = price;\n            } finally {\n                stampedLock.unlockRead(stamp);\n            }\n        }\n        System.out.printf(\"%s -&gt; %s - Price: %.2f\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName(),\n                value);\n        return value;\n    }\n\n    public void updatePrice(double increment) throws InterruptedException {\n        long stamp = stampedLock.writeLock();\n        try {\n            incrementPrice(increment);\n        } finally {\n            stampedLock.unlock(stamp);\n        }\n    }\n\n    private void incrementPrice(double increment) throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s - Updating price...\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName());\n        TimeUnit.SECONDS.sleep(1);\n        this.price += increment;\n        System.out.printf(\"%s -&gt; %s - New price: %.2f\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName(),\n                this.price);\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\n\npublic class Client implements Runnable {\n\n    private final Product product;\n\n    public Client(Product product) {\n        Objects.requireNonNull(product);\n        this.product = product;\n    }\n\n    @Override\n    public void run() {\n        try {\n            @SuppressWarnings(\"unused\")\n            double price = product.getPrice();\n        } catch (InterruptedException e) {\n            System.out.println(\"I've been interrupted while consulting the price\");\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class Shop implements Runnable {\n\n    private final Product product;\n\n    public Shop(Product product) {\n        Objects.requireNonNull(product);\n        this.product = product;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 3; i++) {\n            try {\n                product.updatePrice(20.0);\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                System.out.println(\"I've been interrupted while updating the price\");\n                return;\n            }\n        }\n    }\n\n}\n</code></pre> <p>Si ejecutamos la aplicaci\u00f3n veremos que varios lectores pueden estar leyendo a la vez, pero s\u00f3lo uno puede estar escribiendo. Cambia los tiempos de los <code>sleep()</code> para tratar que un hilo cliente bloquee a un hilo tienda pero no a otros hilos cliente. Despu\u00e9s trata de que un hilo tienda bloquee a hilos clientes.</p>"},{"location":"bloque_v/tema_22/page-11/","title":"11 Semaphore","text":""},{"location":"bloque_v/tema_22/page-11/#semaphore","title":"Semaphore","text":"<p>Un sem\u00e1foro es un contador que protege el acceso a uno o m\u00e1s recursos compartidos. El concepto de sem\u00e1foro fue introducido por Edsger Dijkstra en 1965.</p> <p>Cuando un hilo quiere acceder a uno de estos recursos compartidos, primero debe adquirir (acquire) el sem\u00e1foro. Si el contador interno del sem\u00e1foro es mayor que 0, el sem\u00e1foro decrementa el contador interno y permite el acceso del hilo al recurso compartido. Un valor mayor que 0 en el contador significa que hay recursos libres que pueden ser usados, por lo que el hilo puede acceder y obtener uno de ellos.</p> <p>Si, por el contrario, el contador interno del sem\u00e1foro es 0, el sem\u00e1foro suspende el hilo solicitante hasta que el contador sea mayor que 0. Un valor de 0 en el contador interno del sem\u00e1foro significa que todos los recursos compartidos est\u00e1n siendo usados por otros hilos, por lo que el hilo solicitante debe esperar hasta que se libere uno de ellos.</p> <p>Cuando un hilo termina de usar un recurso compartido, debe liberar el sem\u00e1foro, de manera que su contador interno se incrementa y se reactiva autom\u00e1ticamente alguno de los hilos que estaban esperando uno de los recursos compartidos gestionados por el sem\u00e1foro.</p> <p>Los sem\u00e1foros cuyo valor inicial del contador es 1 reciben el nombre de sem\u00e1foros binarios.</p> <p>La clase <code>Semaphore</code> nos permite crear sem\u00e1foros en nuestras aplicaciones. El constructor de dicha clase recibe el valor inicial para el contador interno del sem\u00e1foro, que deber\u00eda corresponder, en principio, al n\u00famero de instancias del recursos compartido controlados por el sem\u00e1foro. Curiosamente, Java permite proporcionar un valor que no tenga mucho sentido, como por ejemplo <code>-1</code>.</p> <p>Opcionalmente, el constructor puede recibir adem\u00e1s un valor booleano (fair) para indicar si queremos que funcione el modo justo, es decir, que los hilos sean reactivados en el orden en que solicitaron el sem\u00e1foro cuando haya disponible de nuevo un recurso compartido. Por defecto el valor de dicho par\u00e1metro es <code>false</code>. Al usar sem\u00e1foros con el modo justo activado evitaremos la inanici\u00f3n, aunque su rendimiento es peor que el de los sem\u00e1foros no justos.</p> <p>La clase <code>Semaphore</code> nos proporciona distintas formas de adquirir el sem\u00e1foro. La primera de ellas es mediante el m\u00e9todo <code>acquire()</code>, que como la mayor\u00eda de los m\u00e9todos bloqueantes, lanzar\u00e1 la excepci\u00f3n <code>InterruptedException</code> si el hilo es interrumpido mientras se encuentra esperando a poder acceder a alguna instancia del recurso, o si ya hab\u00eda sido marcado para interrupci\u00f3n antes de ejecutar <code>acquire()</code>, reactivando el hilo inmediatamente.</p> <p>Si queremos que no se lance la excepci\u00f3n en dichos casos, deberemos usar el m\u00e9todo <code>acquireUninterruptedly()</code>, que no hace caso al estado de interrupci\u00f3n del hilo.</p> <p>Una tercera forma de adquirir el sem\u00e1foro es mediante el m\u00e9todo <code>tryAcquire()</code>, que no suspende el hilo si no es posible adquirir el sem\u00e1foro, retornando simplemente un valor booleano indicativo de si se ha adquirido o no. Debemos tener en cuenta que a <code>tryAcquire()</code> no le afecta el hecho de que el sem\u00e1foro est\u00e1 funcionando en modo justo o no y puede que el hilo adquiera el sem\u00e1foro si justo en el momento en que llama a <code>tryAcquire()</code> otro hilo libera un recurso, incluso aunque hubiera otros hilos esperando adquirir el sem\u00e1foro.</p> <p>Una cuarta forma de adquirir el sem\u00e1foro es mediante el m\u00e9todo <code>tryAcquire(timeout, timeUnit)</code>, al que pasamos el tiempo m\u00e1ximo que el hilo podr\u00e1 ser suspendido en espera de adquirir el sem\u00e1foro, transcurrido el cu\u00e1l es reactivado inmediatamente, retornando el m\u00e9todo el valor <code>false</code>. Si el hilo consigue adquirir el sem\u00e1foro el m\u00e9todo retornar\u00e1 <code>true</code>. Al igual que con <code>acquire()</code>, si el hilo es interrumpido mientras est\u00e1 suspendido tratando de adquirir el sem\u00e1foro o ya hab\u00eda sido marcado para interrupci\u00f3n antes de llamar al m\u00e9todo <code>tryAcquire(time, timeUnit)</code>, se lanzar\u00e1 la excepci\u00f3n <code>InterruptedException</code> y se reactivar\u00e1 inmediatamente el hilo. Sin embargo, y a diferencia de lo que ocurre con <code>tryAcquire()</code>, <code>tryAcquire(timeout, timeUnit)</code> s\u00ed respeta el hecho de que el sem\u00e1foro sea justo, incluso aunque establezcamos <code>tryAcquire(0, TimeUnit.SECOND</code>).</p> <p>Para liberar un sem\u00e1foro haremos uso del m\u00e9todo <code>release()</code>, que normalmente se incluye dentro de <code>finally</code> para asegurarnos de que la instancia del recurso gestionada por el sem\u00e1foro es liberada independientemente de que se produzca una excepci\u00f3n o no despu\u00e9s de haberlo adquirido, de esta manera que dicha instancia pueda ser m\u00e1s adelante usada por otro hilo.</p> <pre><code>semaphore.acquire();\ntry {\n    // ...\n} finally {\n    semaphore.release();\n}\n</code></pre> <p>Debemos tener en cuenta que la llamada a <code>release()</code> incrementar\u00e1 el contador interno del sem\u00e1foro, incluso si \u00e9ste no ha sido adquirido nunca. Esto quiere decir, impl\u00edcitamente, que el valor recibido por el constructor de la clase <code>Semaphore</code> NO corresponde al n\u00famero m\u00e1ximo de instancias gestionadas por el sem\u00e1foro, sino tan s\u00f3lo al valor inicial del contador interno. Como consecuencia es posible que err\u00f3neamente estemos realizando <code>release()</code> cuando no debi\u00e9ramos, ya que Java no nos avisar\u00e1, por lo que hay que ser especialmente cuidadoso.</p> <p>Un aspecto curioso es que Java no exige que el hilo que libere el sem\u00e1foro sea el mismo que lo adquiri\u00f3, aunque lo habitual ser\u00e1 que sea el mismo hilo.</p> <p>Los m\u00e9todos <code>acquire(permits)</code>, <code>tryAcquire(permits)</code>, <code>acquireUninterruptedly(permits)</code> y <code>release(permits)</code> est\u00e1n sobrecargados, de manera que pueden recibir un par\u00e1metro entero que represente el n\u00famero de instancias del recurso compartido que se quieren adquirir o liberar, que corresponder\u00e1 al valor que se decrementar\u00e1 o incrementar\u00e1 el contador interno del sem\u00e1foro. Es preferible usar esta opci\u00f3n frente a hacer un bucle que llame repetidamente a la versi\u00f3n sin par\u00e1metro. Debemos tener en cuenta que en el caso de la adquisici\u00f3n, el hilo ser\u00e1 suspendido hasta que est\u00e9n disponibles al menos el n\u00famero de recursos compartidos pasados en dicho argumento. Todos estos m\u00e9todos lanzar\u00e1n la excepci\u00f3n <code>IllegalArgumentException</code> si se pasa un n\u00famero negativo para el par\u00e1metro <code>permits</code>.</p> <p>Un aspecto muy importante de los sem\u00e1foros es que implementan la sincronizaci\u00f3n necesaria para restringir el acceso al conjunto de instancias del recurso, de decir, que gestionan el n\u00famero de instancias disponibles, pero no qu\u00e9 instancias est\u00e1n disponibles, es decir, que no asegura la consistencia del conjunto de recursos en s\u00ed, para lo que deberemos usar posteriormente alg\u00fan otro sistema que asegure la atomicidad, como por ejemplo un <code>ReentrantLock</code>. Este aspecto es estudiado con m\u00e1s detenimiento en el proyecto Semaphore mostrado a continuaci\u00f3n.</p> <p>La clase <code>Semaphore</code> proporciona una serie de m\u00e9todos informativos que permite realizar un seguimiento de su funcionamiento:</p> <ul> <li><code>availablePermits()</code>: Retorna el n\u00famero de recursos disponibles del sem\u00e1foro (cu\u00e1ntos hilos m\u00e1s podr\u00e1n pasar).</li> <li><code>hasQueuedThreads()</code>: Retorna <code>true</code> si hay hilos esperando un recurso protegido por el sem\u00e1foro.</li> <li><code>getQueueLength()</code>: Retorna el n\u00famero de hilos esperando un recurso protegido por el sem\u00e1foro.</li> <li><code>isFair()</code>: Retorna <code>true</code> si el sem\u00e1foro tiene activado el modo justo, lo que indica que cuando debe seleccionarse uno de los hilos esperando por un recurso, se elige el que lleve m\u00e1s tiempo esperando.</li> </ul> <p>Los sem\u00e1foros son un tipo de sincronizador que no s\u00f3lo sirven para controlar el acceso a un n\u00famero de recursos, sino que adem\u00e1s permiten la coordinaci\u00f3n de hilos, aunque no son muy \u00fatiles cuando la sincronizaci\u00f3n es compleja. En estos casos es mejor usar objetos <code>Condition</code>.</p> <p>En general los sem\u00e1foros son m\u00e1s flexibles que los cerrojos, por dos motivos principales, porque nos permiten adquirir y liberar varias instancias del recurso protegido, y porque se pueden adquirir y liberar las instancias desde hilos distintos (not fully bracket). Dicha flexibilidad supone sin embargo un coste adicional en rendimiento.</p>"},{"location":"bloque_v/tema_22/page-11/#proyecto-semaphore","title":"Proyecto Semaphore","text":"<p>En este proyecto vamos a simular una cola de impresi\u00f3n \u00fanica que recibe los documentos a imprimir por parte de los distintos hilos y que los imprime en alguna de las tres impresoras disponibles. Para gestionar el acceso a las impresoras usaremos un sem\u00e1foro. Para comprobar la disponibilidad de las impresoras usaremos un array protegido con un objeto <code>ReentrantLock</code>.</p> MainPrintingQueuePrinterPrintJob <pre><code>public class Main {\n\n    public static void main (String[] args){\n        PrintingQueue printingQueue = new PrintingQueue(3);\n        Thread[] printJobThreads = new Thread[10];\n        for (int i = 0; i &lt; 10; i++) {\n            printJobThreads[i] = new Thread(new PrintJob(printingQueue, \"Document #\" + i), \"Print job #\" + i);\n        }\n        for (int i = 0; i &lt; 10; i++) {\n            printJobThreads[i].start();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.Semaphore;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class PrintingQueue {\n\n    private static final int NO_PRINTER = -1;\n\n    private final Semaphore semaphore;\n    private final Lock reentrantLock = new ReentrantLock(true);\n    private final Printer[] printers;\n    private final boolean[] printerAvailable;\n\n    public PrintingQueue(int numberOfPrinters) {\n        semaphore = new Semaphore(numberOfPrinters, true);\n        printers = new Printer[numberOfPrinters];\n        printerAvailable = new boolean[numberOfPrinters];\n        for (int i = 0; i &lt; numberOfPrinters; i++) {\n            printers[i] = new Printer(i);\n            printerAvailable[i] = true;\n        }\n    }\n\n    public void addDocument(String document) throws InterruptedException {\n        try {\n            semaphore.acquire();\n            int printerNumber = selectPrinter();\n            if (printerNumber != NO_PRINTER) {\n                printers[printerNumber].printDocument(document);\n            }\n            printerAvailable[printerNumber] = true;\n        } finally {\n            // This is called even if an exception is thrown.\n            semaphore.release();\n        }\n    }\n\n    private int selectPrinter() {\n        reentrantLock.lock();\n        try {\n            for (int i = 0; i &lt; printers.length; i++) {\n                if (printerAvailable[i]) {\n                    printerAvailable[i] = false;\n                    return i;\n                }\n            }\n        } finally {\n            reentrantLock.unlock();\n        }\n        return NO_PRINTER;\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\n\npublic class Printer {\n\n    private final int printerNumber;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n    private final Random random = new Random();\n\n    public Printer(int printerNumber) {\n        this.printerNumber = printerNumber;\n    }\n\n    public void printDocument(String document) throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s: Document printing started on printer %d\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName(), printerNumber);\n        System.out.printf(\"%s -&gt; %s: %s...\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName(), document);\n        TimeUnit.SECONDS.sleep(random.nextInt(5));\n        System.out.printf(\"%s -&gt; %s: Printing finished on printer %d\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName(), printerNumber);\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\n\npublic class PrintJob implements Runnable {\n\n    private final PrintingQueue printingQueue;\n    private final String document;\n\n    public PrintJob(PrintingQueue printingQueue, String document) {\n        Objects.requireNonNull(printingQueue);\n        Objects.requireNonNull(document);\n        this.printingQueue = printingQueue;\n        this.document = document;\n    }\n\n    @Override\n    public void run() {\n        try {\n            printingQueue.addDocument(document);\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s -&gt; I've been interrupted while printing document\\n\",\n                    Thread.currentThread().getName());\n        }\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que s\u00f3lo tres documentos se pueden estar imprimiendo a la vez, y que se har\u00e1 en impresoras distintas.</p>"},{"location":"bloque_v/tema_22/page-12/","title":"Ejercicios","text":"Proyecto SynchronizedMethod <p>Realiza un proyecto Java haciendo uso de hilos (Runnables) y haciendo uso de los m\u00e9todos sincronizados, en el que se quiere calcular las veces que las caras de un dado son lanzadas al azar. Ten en cuenta que un dado puede ser lanzado un m\u00e1ximo de 10.000 veces por hilo, crea un programa en Java en el que se cree 3 hilos que lancen dados, almacenando el n\u00famero de veces que se obtiene cada una de las caras de un dado (1-6).</p> <p>Adem\u00e1s, deber\u00e1s mostrar:</p> <ul> <li>El resultado obtenido por cada vez que se lanza el dado, mostrando tambi\u00e9n desde que hilo ha sido lanzado.</li> <li>El resultado total de cada una de las caras del dado.</li> <li>El n\u00famero total de tiradas en todos los hilos.</li> </ul> Proyecto SynchronizedStatement <p>Realiza un proyecto en Java con las mismas condiciones que el anterior, pero teniendo en haciendo uso de los bloques sincronizados.</p> Proyecto WaitNotify <p>En una fiesta de cumplea\u00f1os de Julian, tres amigos le han preparado una fiesta sorpresa, Luc\u00eda, Marcos y Andrea. Tras cenar, han decidido hacer una cadena humana para limpiar los platos de la mesa (en total 10 platos sucios). </p> <p>Luc\u00eda se encargar\u00e1 de fregar los platos sucios. Cada vez que limpia un plato lo a\u00f1ade a la pila de platos para secar y suele tardar entre 2 y 4 segundos en fregarlos. Marcos es el encargado de secar los platos fregados y depositarlos en la pila de platos a guardar y suele tardar entre 1 y 3 segundos en secarlos. Por \u00faltimo lugar, Andrea se encargar\u00e1 de obtener los platos fregados y almacenarlos en la alacena, y suele tardar entre 1 y 2 segundos.</p> <p>Solo tiene 60 segundos para limpiar los platos antes de ser interrumpidos por Juli\u00e1n para cantarles cumplea\u00f1os feliz.</p> <p>Crea una simulaci\u00f3n en Java, haciendo uso de los bloques o m\u00e9todos sincronizados y de los m\u00e9todos de espera y notificaci\u00f3n necesarios.</p> Proyecto ReentrantLockCondition <p>Realiza la misma aplicaci\u00f3n del ejercicio anterior pero haciendo uso de la interfaz <code>Condition</code> y la clase <code>ReentrantLock</code></p> Proyecto ReentrantReadWriteLock <p>Un almac\u00e9n se encarga de almacenar diferentes productos. Un consultor es un encargado de un tienda que puede comprobar los stock de los productos que hay en el almac\u00e9n, mientras que un Actualizador es una persona encargada de a\u00f1adir los productos al almac\u00e9n. </p> <p>Crea una aplicaci\u00f3n en Java haciendo uso de hilos y de la clase <code>ReentrantReadWriteLock</code> en la cual permitan consultar de forma concurrente a 3 tiendas diferentes, as\u00ed como poder actualizar los productos.</p> <p>Ten en cuenta lo siguiente:</p> <ul> <li>La consulta del stock de un producto tarda 2 segundos en realizarse.</li> <li>A\u00f1adir un producto al almac\u00e9n es una operaci\u00f3n que dura 3 segundos.</li> <li>El actualizador se encargar\u00e1 de a\u00f1adir productos durante un minuto, luego de \u00e9ste ser\u00e1 interrumpido.</li> <li>Las tiendas podr\u00e1n consultar el n\u00famero de productos que hay en stock hasta pasado veinte segundos posteriores al interrumpirse el actualizador. </li> </ul> Proyecto StampedLock <p>Realiza el proyecto anterior haciendo uso del mecanismo <code>StampedLock</code>.</p> Proyecto Semaphore <p>En un Supermercado hay cuatro cajas diferentes para que los clientes puedan ir pasando por cada una de las cajas a realizar las compras pertinentes. Cada una de las cajas est\u00e1 identificada con un n\u00famero. Cuando una caja no est\u00e1 disponible el cliente deber\u00e1 esperar a que alguna se quede disponible. La acci\u00f3n de comprar de un cliente puede llegar a durar entre 1 y 4 segundos. </p> <p>Se desea crear una aplicaci\u00f3n que simule la situaci\u00f3n en que 50 clientes entran al supermercado a realizar las compras. Mostrando cada instante del cliente, desde que entra al supermercado y realiza la comprar, hasta que la finaliza y abandona. Hay que tener en cuenta que un cliente tarda entre 1 y 3 segundos en realizar la compra. Utiliza el <code>Semaphore</code> para el acceso a las cajas, y un <code>Lock</code> para la comprobar su disponibilidad.</p>"},{"location":"bloque_v/tema_22/page-2/","title":"2 Volatile","text":""},{"location":"bloque_v/tema_22/page-2/#volatile","title":"Volatile","text":"<p>Podemos pensar en las variables volatile como un mecanismo de sincronizaci\u00f3n ligero, ya que requiere poco c\u00f3digo y suponen muy poca sobrecarga en tiempo de ejecuci\u00f3n. El inconveniente es que s\u00f3lo pueden ser usados para resolver un cierto tipo de problemas concretos, un subconjunto de los que pueden ser resueltos con otros tipos de mecanismos de sincronizaci\u00f3n.</p> <p>El motivo es que, de las capacidades descritas en el apartado anterior, las variables volatile s\u00f3lo cumplen con la primera de ellas, la visibilidad, pero no con el resto.</p> <p>Los hilos que accedan a una variables volatile compartida siempre ver\u00e1n autom\u00e1ticamente su \u00faltimo valor actualizado, por lo que cumple con la propiedad de visibilidad. Sin embargo, al no cumplir con la exclusi\u00f3n mutua, las variables volatile s\u00f3lo pueden ser usadas como mecanismo de sincronizaci\u00f3n en aquellos casos en los que no existen restricciones respecto a varias variables a la vez o entre el valor actual de la variable y sus valores futuros.</p> <p> Figura 1 - Conflicto de escritura-lectura</p> <p>Para definir una variable como volatile simplemente debemos comenzar su declaraci\u00f3n con la palabra reservada <code>volatile</code>, como en:</p> <pre><code>public volatile int value;\n</code></pre> <p>En general, para poder utilizar una variable volatile de manera thread-safe, deben cumplirse las siguientes dos condiciones:</p> <ul> <li>Que la escritura de la variable no dependa de su valor actual. El motivo es que el declarar la variable como <code>volatile</code> NO asegura que la operaci\u00f3n de lectura del valor actual m\u00e1s el de escritura del nuevo valor se vaya a realizar de forma at\u00f3mica. Por tanto no deben utilizarse para, por ejemplo, contadores, a no ser que estemos seguros de que s\u00f3lo va a ser modificada por un \u00fanico hilo y que el resto de hilos tan s\u00f3lo va a leer su valor.</li> <li>Que la variable no participa en invariantes (condici\u00f3n que no var\u00eda) con otras variables. El motivo es que si la variable en cuesti\u00f3n, por ejemplo <code>extremo_inferior</code> est\u00e1 relacionada con otra, por ejemplo <code>extremo_superior</code> mediante alguna condici\u00f3n que no puede variar, <code>extremo_inferior &lt;= extremo_superior</code>, definir ambas variables como <code>volatile</code> NO asegura que se siga cumpliendo el invariante, al no realizarse la comprobaci\u00f3n del invariante y la escritura de forma at\u00f3mica.</li> </ul> <p>El uso de variables volatile tiene, sin embargo, una serie de ventajas:</p> <ul> <li>Son mucho m\u00e1s f\u00e1ciles de usar.</li> <li>Como no bloquean los hilos que acceden al recurso, es menos probable que se produzcan problemas de escalabilidad al aumentar el n\u00famero de hilos.</li> <li>Cuando los accesos al recurso es mayoritariamente para lectura y no para escritura, suponen una mejora de rendimiento frente a otros sistemas de sincronizaci\u00f3n.</li> </ul> <p>Algunos casos t\u00edpicos en los que podemos usar variables <code>volatile</code> frente a otros mecanismos de sincronizaci\u00f3n son los siguientes:</p> <ul> <li>Con variables que act\u00faan como flags de estado.</li> <li>Con variables que s\u00f3lo se actualizan una \u00fanica vez.</li> <li>Con variables que son actualizadas desde un \u00fanico hilo, como por ejemplo un hilo en segundo plano que almacena el valor de la temperatura actual y el resto de hilos simplemente leen dicha variable.</li> </ul> <p>Para saber m\u00e1s</p> <ul> <li>http://www.ibm.com/developerworks/java/library/j-jtp06197/index.html</li> <li>https://dzone.com/articles/java-volatile-keyword-0</li> <li>https://www.youtube.com/watch?v=8oafyFFqp38</li> </ul>"},{"location":"bloque_v/tema_22/page-2/#proyecto-volatile","title":"Proyecto Volatile","text":"<p>En este proyecto vamos a realizar un programa que demuestra un caso extremo en el que es necesario el empleo de la palabra reservada <code>volatile</code>. El hilo principal define una variable accesible desde otros dos hilos: uno que simplemente detecta cambios en el valor de la variable y otro cuyo cometido es producir dichos cambios.</p> <pre><code>public class Main {\n\n    // Try and remove volatile keyword and run. See what happens.\n    private static volatile int value = 0;\n\n    public static void main(String[] args) {\n        new ChangeListener().start();\n        new ChangeMaker().start();\n    }\n\n    static class ChangeListener extends Thread {\n        @Override\n        public void run() {\n            int localValue = value;\n            // JVM can't update cache value of \"value\" variable, because is occupied\n            // permforming the infinite loop. So we have to define the variable as \n            // volatile\n            // to ensure it's cache value is updated when updated from another thread.\n            while (localValue &lt; 5) {\n                if (localValue != value) {\n                    System.out.printf(\"Detected new value: %d\\n\", value);\n                    localValue = value;\n                }\n            }\n        }\n    }\n\n    static class ChangeMaker extends Thread {\n        @Override\n        public void run() {\n            int localValue = value;\n            while (value &lt; 5) {\n                System.out.printf(\"Incrementing value to %d\\n\", localValue + 1);\n                value = ++localValue;\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n        }\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que uno de hilos secundarios detecta los cambios producidos en la variable desde el otro hilo secundario. Sin embargo, si quitamos la palabra reservada <code>volatile</code> en la definici\u00f3n de la variable, el hilo secundario no ser\u00e1 capaz de detectar los cambios que produzca el otro hilo sobre la variable.</p>"},{"location":"bloque_v/tema_22/page-3/","title":"3 Cerrojo Intr\u00ednseco","text":""},{"location":"bloque_v/tema_22/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>La exclusi\u00f3n mutua no est\u00e1 implementada por defecto en los tipos de Java, por lo que tendremos que usar alg\u00fan mecanismo de sincronizaci\u00f3n.</p> <p>El mecanismo b\u00e1sico de sincronizaci\u00f3n para conseguir la exclusi\u00f3n mutua en Java se construye en base a un entidad interna conocida como monitor, cerrojo monitor o cerrojo intr\u00ednseco.</p> <p>Monitor, cerrojo monitor, cerrojo intr\u00ednseco o mutex</p> <p>Objeto que act\u00faa como vigilante de que el acceso a una determinada secci\u00f3n cr\u00edtica se realice en exclusi\u00f3n mutua</p> <p>Los monitores act\u00faan sobre dos propiedades de los mecanismos de sincronizaci\u00f3n: por un lado hacer cumplir el acceso exclusivo al estado de un objeto, es decir, la exclusi\u00f3n mutua, y, por otro lado, asegurar la visibilidad de los cambios en todos los hilos, garantizando que determinadas acciones se llevan a cabo antes que otras (lo que se conoce como relaciones happens-before). Por este motivo, si el acceso a un determinado campo est\u00e1 siendo protegido con un cerrojo intr\u00ednseco no ser\u00e1 necesario definir dicho campo como <code>volatile</code>, debido a que cuando un hilo trata de liberar el cerrojo intr\u00ednseco, los valores cacheados son escritos en las variables compartidas en memoria principal, lo que implica que el siguiente hilo que adquiera el mismo cerrojo siempre ver\u00e1 los valores m\u00e1s recientes de dichas variables compartidas.</p> <p>Cada objeto tiene un cerrojo intr\u00ednseco asociado a \u00e9l. Por convenci\u00f3n, un hilo que necesita acceso exclusivo y consistente a los campos de un objeto tiene que adquirir el bloqueo intr\u00ednseco del objeto antes de acceder a ellos, y luego liberar el cerrojo intr\u00ednseco cuando haya terminado de usarlos. Se dice que un hilo es propietario (est\u00e1n en posesi\u00f3n) del cerrojo intr\u00ednseco en el periodo de tiempo transcurrido desde que adquiere el cerrojo hasta que lo libera. Mientras un hilo posea un el cerrojo intr\u00ednseco, ning\u00fan otro hilo puede adquirir el mismo cerrojo, y al intentarlo quedar\u00e1 bloqueado hasta que el cerrojo haya sido liberado por el hilo que lo pose\u00eda.</p> <p>Cuando un hilo libera un cerrojo intr\u00ednseco, el sistema garantiza que dicha liberaci\u00f3n se realizar\u00e1 antes de que otro hilo que estuviera bloqueado en espera del cerrojo lo adquiera (esta es la relaci\u00f3n happens-before que comentamos anteriormente).</p> <p>En Java, podemos usar la palabra reservada <code>synchronized</code> para controlar el acceso concurrente a un objeto. Cuando declaramos un m\u00e9todo de una clase como <code>synchronized</code>, estamos indicando que cuando un hilo llame a dicho m\u00e9todo en un determinado objeto autom\u00e1ticamente tratar\u00e1 de adquirir el cerrojo intr\u00ednseco asociado a dicho objeto antes de poder ejecutarlo, y que liberar\u00e1 autom\u00e1ticamente el cerrojo intr\u00ednseco cuando se termine de ejecutar el m\u00e9todo, tanto si ha retornado satisfactoriamente como si se ha producido una excepci\u00f3n.</p> <pre><code>public class Account {\n    // ...\n    public synchronized void deposit(float amount) {\n        // ...\n    }\n}\n</code></pre> <p>En la pr\u00e1ctica esto implica que cuando un hilo est\u00e9 ejecutando un m\u00e9todo declarado como <code>synchronized</code> de un determinado objeto, ning\u00fan otro hilo podr\u00e1 ejecutar dicho m\u00e9todo ni cualquier otro m\u00e9todo <code>synchronized</code> del mismo objeto, siendo bloqueado hasta que el hilo que est\u00e1 en posesi\u00f3n del cerrojo intr\u00ednseco asociado al objeto lo libere.</p> <p>M\u00e9todo synchronized</p> <p>Al definir un m\u00e9todo como <code>synchronized</code> convertimos su c\u00f3digo en una secci\u00f3n cr\u00edtica accesible bajo exclusi\u00f3n mutua</p> <p>La definici\u00f3n de m\u00e9todos <code>synchronized</code> no afecta a la ejecuci\u00f3n de otros m\u00e9todos de la clase que no se hayan definido como <code>synchronized</code>, ya que para ejecutar \u00e9stos no es necesario adquirir el cerrojo intr\u00ednseco.</p> <p>De esta manera, al usar la palabra reservada <code>synchronized</code> en la definici\u00f3n de un m\u00e9todo, convertimos su c\u00f3digo en una secci\u00f3n cr\u00edtica accesible bajo exclusi\u00f3n mutua.</p> <p>El cerrojo intr\u00ednseco recibe tambi\u00e9n el nombre de monitor, ya que act\u00faa como \"vigilante\" que monitorea el acceso a sus m\u00e9todos, y recibe el adjetivo de intr\u00ednseco porque no es ning\u00fan elemento externo el que act\u00faa como cerrojo, sino un elemento interno asociado a \u00e9l.</p> <p> Figura 2 - Conflicto de escritura</p> <p>El comportamiento de la palabra reservada <code>synchronized</code> es ligeramente diferente si el m\u00e9todo es adem\u00e1s est\u00e1tico (<code>static</code>), ya que en dicho caso, el cerrojo intr\u00ednseco estar\u00e1 asociada a la clase y no a una determinada instancia (objeto) de la clase. En ese caso, cuando un hijo ejecute un m\u00e9todo <code>static synchronized</code> de la clase estar\u00e1 adquiriendo el cerrojo intr\u00ednseco asociado al objeto <code>Class</code> correspondiente a la clase. Por tanto, el acceso a los campos <code>static synchronized</code> es controlado por un cerrojo intr\u00ednseco distinto al cerrojo intr\u00ednseco asociado a cada instancia de la clase.</p> <p>Como consecuencia, dos hilos no podr\u00e1n estar ejecutando a la vez el mismo m\u00e9todo <code>static synchronized</code> o dos m\u00e9todos distintos <code>static synchronized</code> de la misma clase, pero s\u00ed es posible que un hilo est\u00e9 ejecutando un m\u00e9todo <code>static synchronized</code> de una clase y otro hilo est\u00e9 ejecutando un m\u00e9todo <code>synchronized</code> de una instancia de esa misma clase.</p> <p>Debemos tener en cuenta que el uso de m\u00e9todos sincronizados penaliza en cierta manera el rendimiento de la aplicaci\u00f3n, ya que si tenemos varios hilos llamando a un m\u00e9todo sincronizado, s\u00f3lo uno de ellos podr\u00e1 estar ejecut\u00e1ndolo en un momento dado y los dem\u00e1s tendr\u00e1n que esperar, aumentando el tiempo real de ejecuci\u00f3n de la aplicaci\u00f3n. As\u00ed que la palabra reservada <code>synchronized</code> debe ser usada solamente con m\u00e9todos que sepamos que van a ser llamados por varios hilos y que adem\u00e1s modifiquen datos compartidos por varios hilos en un entorno concurrente.</p> <p>Debemos tener en cuenta que si dentro de un m\u00e9todo <code>synchronized</code> se llama al m\u00e9todo <code>Thread.sleep(milliseconds)</code>, el hilo sigue siendo poseedor del cerrojo intr\u00ednseco durante el tiempo que est\u00e1 durmiendo.</p> <p>En Java, la capacidad de tener asociado un cerrojo intr\u00ednseco y por tanto tener m\u00e9todos <code>synchronized</code> est\u00e1 incorporada en la clase <code>Object</code>, por lo que es heredada por todas las clases, lo que implica que cualquier objeto Java tiene asociado un objeto monitor y contener m\u00e9todos <code>synchronized</code>.</p> <p>Sincronizaci\u00f3n reentrante</p> <p>Si un hilo ejecutando un m\u00e9todo <code>synchronized</code> de un objeto llama internamente a otro m\u00e9todo <code>synchronized</code> del mismo objeto, no tiene que adquirir de nuevo el cerrojo, porque ya lo tiene</p> <p>Una de las caracter\u00edsticas de la sincronizaci\u00f3n mediante la palabra reservada <code>synchronized</code> es que un hilo puede adquirir m\u00e1s de una vez un cerrojo intr\u00ednseco que ya posee. Esta casu\u00edstica se produce en situaciones en las que un c\u00f3digo protegido mediante <code>synchronized</code> invoca directamente o indirectamente a otro m\u00e9todo (o a \u00e9l mismo recursivamente) que tambi\u00e9n contiene c\u00f3digo <code>synchronized</code> protegido por el mismo cerrojo intr\u00ednseco. Se dice por tanto que se trata de una sincronizaci\u00f3n reentrante (reentrant synchronization), con objeto de que un hilo no se bloquee a s\u00ed mismo.</p> <p>Si queremos saber si el hilo en el que nos encontramos tiene adquirido en un momento dado el cerrojo intr\u00ednseco asociado a un determinado objeto, podemos llamar al m\u00e9todo est\u00e1tico <code>Thread.holdsLock(object)</code>.</p> <p>Debemos tener en cuenta que el cerrojo intr\u00ednseco no proporciona ninguna garant\u00eda respecto al orden en el que los hilos que est\u00e9n esperando adquirir el cerrojo finalmente lo adquieren. Esto implica que, te\u00f3ricamente, existe riesgo de que alg\u00fan hilo sufra de inanici\u00f3n, si el cerrojo intr\u00ednseco es adquirido constantemente por otros hilos, lo que no permite a nuestro hilo adquirirlo nunca. La soluci\u00f3n a este problema consiste en usar la clase <code>ReentrantLock</code> y su modo justo (fair mode), como estudiaremos dentro de poco.</p> <p>Info</p> <p>Para saber m\u00e1s visite https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.php</p>"},{"location":"bloque_v/tema_22/page-3/#proyecto-synchronizedmethod","title":"Proyecto SynchronizedMethod","text":"<p>En este proyecto vamos a realizar un programa que simule una cuenta bancaria en la que un hilo que realiza una serie de abonos a la cuenta y otro hilo realiza una serie de cargos. Debemos recordar que el orden de ejecuci\u00f3n de hilos no est\u00e1 garantizado por la JVM, por lo que podr\u00edan intercalarse las operaciones de manera que el saldo no reflejara el valor correcto. Usaremos m\u00e9todos <code>synchronized</code> para asegurar que el saldo final es el correcto incluso aunque se pretendieran realizar ambas operaciones simult\u00e1neamente.</p> MainAccountAccountConsumerAccountSaver <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        Account account = new Account(0);\n        // Show initial balance.\n        System.out.printf(\"%s -&gt; Initial balance: %.2f\u20ac\\n\",\n                LocalTime.now().format(dateTimeFormatter), account.getBalance());\n        // Start both saver and consumer threads. Both threads share the same account.\n        Thread saverThread = new Thread(new AccountSaver(account));\n        saverThread.start();\n        Thread consumerThread = new Thread(new AccountConsumer(account));\n        consumerThread.start();\n        // Wait for both threads to finish.\n        saverThread.join();\n        consumerThread.join();\n        // Show final balance.\n        System.out.printf(\"\\n%s -&gt; Final balance: %.2f\u20ac\\n\",\n                LocalTime.now().format(dateTimeFormatter), account.getBalance());\n    }\n\n}\n</code></pre> <pre><code>public class Account {\n\n    private float balance;\n\n    public Account(float initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public float getBalance() {\n        return balance;\n    }\n\n    // Try and remove synchronized keyword and see what happens.\n    public synchronized void deposit(float amount) {\n        balance += amount;\n        System.out.print(\".\");\n    }\n\n    // Try and remove synchronized keyword and see what happens.\n    public synchronized void debit(float amount) {\n        balance -= amount;\n        System.out.print(\".\");\n    }\n\n}\n</code></pre> <pre><code>public class AccountConsumer implements Runnable {\n\n    private final Account account;\n\n    public AccountConsumer(Account account) {\n        this.account = account;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 10000; i++) {\n            account.debit(5);\n        }\n    }\n\n}\n</code></pre> <pre><code>public class AccountSaver implements Runnable {\n\n    private final Account account;\n\n    public AccountSaver(Account account) {\n        this.account = account;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 10000; i++) {\n            account.deposit(10);\n        }\n    }\n}\n</code></pre> <p>Si ejecutamos el programa veremos que el saldo final es el esperado, es decir <code>50000</code>, pero si no usamos la palabra reservada <code>synchronized</code> en los m\u00e9todos de la clase <code>Account</code> el resultado ser\u00e1 erroneo y diferente en cada ejecuci\u00f3n.</p>"},{"location":"bloque_v/tema_22/page-3/#sentencias-synchronized","title":"Sentencias Synchronized","text":"<p>Con objeto de minimizar en la medida de lo posible la penalizaci\u00f3n en tiempo de ejecuci\u00f3n que pueden producir los m\u00e9todos sincronizados, podemos emplear la t\u00e9cnica consistente en proteger el acceso al bloque de c\u00f3digo conflictivo del m\u00e9todo en vez de al m\u00e9todo completo.</p> <p>Para ello usaremos la palabra reservada <code>synchronized</code> para crear un bloque con acceso protegido que contenga exclusivamente las l\u00edneas de c\u00f3digo del m\u00e9todo que accedan a datos compartidos, dejando el resto de operaciones fuera del bloque, lo que mejora el rendimiento de la aplicaci\u00f3n. El objetivo es hacer la secci\u00f3n cr\u00edtica lo m\u00e1s peque\u00f1a posible.</p> <p>Cuando se usa la palabra reservada <code>synchronized</code> de esta manera la sintaxis que emplea es distinta a cuando se usa en la definici\u00f3n de un m\u00e9todo. De hecho, le tendremos que pasar como par\u00e1metro a <code>synchronized</code> la referencia a un objeto, cuyo cerrojo intr\u00ednseco ser\u00e1 usado para proteger el c\u00f3digo contenido en el bloque.</p> <pre><code>synchronized (intrinsicLockSupplierObject) {\n    // Critic section with mutual exclusion.\n    // ...\n}\n</code></pre> <p>Antes de ejecutar la primera l\u00ednea de c\u00f3digo del bloque <code>synchronized</code> el hilo que lo ejecuta deber\u00e1 adquirir el cerrojo intr\u00ednseco asociado al objeto proporcionado. Cuando se termine de ejecutar la \u00faltima l\u00ednea de c\u00f3digo del bloque se liberar\u00e1 el cerrojo intr\u00ednseco. Como consecuencia, la JVM garantiza que en un momento dado un \u00fanico hilo podr\u00e1 tener acceso a cualquiera de los bloques de c\u00f3digo protegidos por el cerrojo intr\u00ednseco de dicho objeto.</p> <p>Normalmente usaremos como cerrojo intr\u00ednseco el asociado al propio objeto en el que est\u00e1 ejecutando el m\u00e9todo, para lo que emplearemos la palabra clave <code>this</code>, aunque en realidad podr\u00edamos haber especificado cualquier otro objeto, incluso uno creado expresamente para ello, como veremos m\u00e1s adelante.</p> <pre><code>synchronized (this) {\n    // Critic section with mutual exclusion.\n    // ...\n}\n</code></pre>"},{"location":"bloque_v/tema_22/page-3/#proyecto-synchronizedstatement","title":"Proyecto SynchronizedStatement","text":"<p>Consiste en el mismo proyecto del enunciado anterior, pero sincronizando solamente el bloque correspondiente a la secci\u00f3n cr\u00edtica en vez de el m\u00e9todo completo.</p> MainAccountAccountConsumerAccountSaver <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        Account account = new Account(0);\n        // Show initial balance.\n        System.out.printf(\"%s -&gt; Initial balance: %.2f\u20ac\\n\",\n                LocalTime.now().format(dateTimeFormatter), account.getBalance());\n        // Start both saver and consumer threads. Both threads share the same account.\n        Thread saverThread = new Thread(new AccountSaver(account));\n        saverThread.start();\n        Thread consumerThread = new Thread(new AccountConsumer(account));\n        consumerThread.start();\n        // Wait for both threads to finish.\n        saverThread.join();\n        consumerThread.join();\n        // Show final balance.\n        System.out.printf(\"\\n%s -&gt; Final balance: %.2f\u20ac\\n\",\n                LocalTime.now().format(dateTimeFormatter), account.getBalance());\n    }\n\n}\n</code></pre> <pre><code>public class Account {\n\n    private float balance;\n\n    public Account(float initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public float getBalance() {\n        return balance;\n    }\n\n    public void deposit(float amount) {\n        synchronized (this) {\n            balance += amount;\n        }\n    }\n\n    public void debit(int amount) {\n        synchronized (this) {\n            balance -= amount;\n        }\n    }\n\n}\n</code></pre> <pre><code>public class AccountConsumer implements Runnable {\n\n    private final Account account;\n\n    public AccountConsumer(Account account) {\n        this.account = account;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 10000; i++) {\n            account.debit(5);\n        }\n    }\n\n}\n</code></pre> <pre><code>public class AccountSaver implements Runnable {\n\n    private final Account account;\n\n    public AccountSaver(Account account) {\n        this.account = account;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 10000; i++) {\n            account.deposit(10);\n        }\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que el saldo final es el esperado, es decir <code>50000</code>, pero si no usamos la palabra reservada <code>synchronized</code> en los m\u00e9todos de la clase <code>Account</code> el resultado ser\u00e1 erroneo y diferente en cada ejecuci\u00f3n.</p>"},{"location":"bloque_v/tema_22/page-4/","title":"4 Sincronizaci\u00f3n independiente (lock Striping)","text":""},{"location":"bloque_v/tema_22/page-4/#sincronizacion-independiente-lock-striping","title":"Sincronizaci\u00f3n independiente (lock Striping)","text":"<p>Cuando usamos la palabra reservada <code>synchronized</code> para proteger un bloque de c\u00f3digo, debemos pasarle como par\u00e1metro la referencia a un objeto cuyo cerrojo intr\u00ednseco act\u00faa como protector. Normalmente, usaremos como par\u00e1metro el propio objeto que est\u00e1 ejecutando el m\u00e9todo, por lo que usaremos la palabra reservada <code>this</code>. Sin embargo, hay ocasiones en las que es conveniente usar como par\u00e1metro un objeto independiente creado espec\u00edficamente para este prop\u00f3sito.</p> <p>De esta manera conseguiremos restringir lo m\u00e1ximo posible el coste de ejecuci\u00f3n asociado a la sincronizaci\u00f3n, haciendo que un cerrojo intr\u00ednseco proteja un \u00fanico campo, lo que se conoce como fine-grained synchronization (sincronizaci\u00f3n de grano fino) o lock striping (cinta de cerrojos).</p> <p>Por ejemplo, supongamos que tenemos en una misma clase dos atributos cuyo acceso debe ser protegido, pero el hecho de que un hilo est\u00e9 accediendo a uno de los atributos no implica problema alguno sobre que otro hilo est\u00e9 accediendo al otro atributo. En este caso no deber\u00edamos usar el mismo objeto (por ejemplo this) para proteger ambos atributos, sino que cada atributo deber\u00eda ser protegido por un objeto distinto, que crearemos expresamente para dicho cometido. Esto permitir\u00e1 que un hilo pueda acceder al primer atributo mientras que otro hilo acceda al segundo, ya que est\u00e1n protegidos por objetos distintos.</p>"},{"location":"bloque_v/tema_22/page-4/#proyecto-movietheater","title":"Proyecto MovieTheater","text":"<p>En este proyecto desarrollaremos una aplicaci\u00f3n que simula el funcionamiento de un cine con dos taquillas y la cola de venta de entradas de cada una de ellas para las salas del cine. El n\u00famero de butacas de cada sala debe ser sincronizada de manera independiente, para que mientras se est\u00e9 realizando la venta de entradas a una sala en una taquilla, en la otra taquilla se puedan vender entradas para otra sala.</p> MainCinemaBoxOffice1QueueBoxOffice2Queue <pre><code>public class Main {\n\n    private static final int BOX_OFFICES = 2;\n    private static final int MOVIE_THEATER_CAPACITY = 20;\n\n    public static void main(String[] args) {\n        int movieTheaters[] = { MOVIE_THEATER_CAPACITY, MOVIE_THEATER_CAPACITY };\n        Cinema cinema = new Cinema(movieTheaters, BOX_OFFICES);\n        Thread boxOffice1Thread = new Thread(new BoxOffice1Queue(cinema, 1), \n                                            \"Box office 1\");\n        Thread boxOffice2Thread = new Thread(new BoxOffice2Queue(cinema, 2), \n                                            \"Box office 2\");\n        boxOffice1Thread.start();\n        boxOffice2Thread.start();\n        try {\n            boxOffice1Thread.join();\n            boxOffice2Thread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        for (int i = 0; i &lt; movieTheaters.length; i++) {\n            System.out.printf(\"Movie theater %d: %d seats available\\n\", i + 1,\n                    cinema.getAvailableSeats(i));\n        }\n    }\n\n}\n</code></pre> <pre><code>public class Cinema {\n\n    private final int[] movieTheatersCapacity;\n    private final int boxOffices;\n    private int[] availableSeats;\n    private Object[] movieTheatersLock;\n\n    public Cinema(int[] movieTheatersCapacity, int boxOffices) {\n        if (movieTheatersCapacity == null || boxOffices &lt; 1) {\n            throw new IllegalArgumentException();\n        }\n        for (int aMovieTheatersCapacity : movieTheatersCapacity) {\n            if (aMovieTheatersCapacity &lt; 1) {\n                throw new IllegalArgumentException();\n            }\n        }\n        this.movieTheatersCapacity = movieTheatersCapacity;\n        this.boxOffices = boxOffices;\n        availableSeats = new int[movieTheatersCapacity.length];\n        movieTheatersLock = new Object[movieTheatersCapacity.length];\n        for (int i = 0; i &lt; movieTheatersCapacity.length; i++) {\n            movieTheatersLock[i] = new Object();\n        }\n        resetMovieTheaters();\n    }\n\n    private void resetMovieTheaters() {\n        System.arraycopy(movieTheatersCapacity, 0, availableSeats, 0, \n                        movieTheatersCapacity.length);\n    }\n\n    public boolean buyTickets(int boxOffice, int movieTheater, int tickets) \n        throws InterruptedException {\n        if (movieTheater &lt; 0 || movieTheater &gt;= availableSeats.length || tickets &lt; 1 || \n            boxOffice &lt; 1 || boxOffice &gt; boxOffices) {\n            throw new IllegalArgumentException();\n        }\n        synchronized (movieTheatersLock[movieTheater]) {\n            if (tickets &lt;= availableSeats[movieTheater]) {\n                availableSeats[movieTheater] -= tickets;\n                System.out.printf(\n                    \"Movie theater #%d: %d tickets bought in box office #%d\\n\", \n                    movieTheater,\n                        tickets, boxOffice);\n                Thread.sleep(1000);\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    public boolean returnTickets(int boxOffice, int movieTheater, int tickets) {\n        if (movieTheater &lt; 0 || movieTheater &gt;= availableSeats.length || tickets &lt; 1 || \n            boxOffice &lt; 1 || boxOffice &gt; boxOffices) {\n            throw new IllegalArgumentException();\n        }\n        synchronized (movieTheatersLock[movieTheater]) {\n            if (tickets + availableSeats[movieTheater] &lt;= \n                    movieTheatersCapacity[movieTheater]) {\n                availableSeats[movieTheater] += tickets;\n                System.out.printf(\n                    \"Movie theater %d: %d tickets returned in box office #%d\\n\", \n                    movieTheater, tickets, boxOffice);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    public int getAvailableSeats(int movieTheater) {\n        return availableSeats[movieTheater];\n    }\n\n}\n</code></pre> <pre><code>public class BoxOffice1Queue implements Runnable {\n\n    private final Cinema cinema;\n    private final int boxOffice;\n\n    public BoxOffice1Queue(Cinema cinema, int boxOffice) {\n        this.cinema = cinema;\n        this.boxOffice = boxOffice;\n    }\n\n    @Override\n    public void run() {\n        try {\n            cinema.buyTickets(boxOffice, 0, 3);\n            cinema.buyTickets(boxOffice,0, 2);\n            cinema.buyTickets(boxOffice,1, 2);\n            cinema.returnTickets(boxOffice,0, 3);\n            cinema.buyTickets(boxOffice,0, 5);\n            cinema.buyTickets(boxOffice,1, 2);\n            cinema.buyTickets(boxOffice,1, 2);\n            cinema.buyTickets(boxOffice,1, 2);\n        } catch (InterruptedException e) {\n            System.out.println(\"Box office #%d has been closed\");\n        }\n    }\n\n}\n</code></pre> <pre><code>public class BoxOffice2Queue implements Runnable {\n\n    private final Cinema cinema;\n    private final int boxOffice;\n\n    public BoxOffice2Queue(Cinema cinema, int boxOffice) {\n        this.cinema = cinema;\n        this.boxOffice = boxOffice;\n    }\n\n    @Override\n    public void run() {\n        try {\n            cinema.buyTickets(boxOffice, 1, 2);\n            cinema.buyTickets(boxOffice, 1, 4);\n            cinema.buyTickets(boxOffice, 0, 2);\n            cinema.buyTickets(boxOffice, 0, 1);\n            cinema.returnTickets(boxOffice, 1, 2);\n            cinema.buyTickets(boxOffice, 0, 3);\n            cinema.buyTickets(boxOffice, 1, 2);\n            cinema.buyTickets(boxOffice, 0, 2);\n        } catch (InterruptedException e) {\n            System.out.printf(\"Box office #%d has been closed\\n\", boxOffice);\n        }\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que a la vez se pueden estar comprando entradas para distintas salas del cine.</p>"},{"location":"bloque_v/tema_22/page-5/","title":"5 Busy Waiting","text":""},{"location":"bloque_v/tema_22/page-5/#espera-activa-busy-waiting","title":"Espera activa (busy-waiting)","text":"<p>En programaci\u00f3n, se denomina espera activa o espera ocupada a una t\u00e9cnica donde un hilo o proceso repetidamente verifica una condici\u00f3n, tal como esperar una entrada de teclado o si se da una determinada condici\u00f3n, en espera de que \u00e9sta se de en alg\u00fan momento futuro debido a la acci\u00f3n de alg\u00fan otro hilo.</p> <p>Como norma general, debe ser evitada, ya que consume tiempo de CPU sin realizar ninguna operaci\u00f3n, ya que el hilo que se encuentra en la espera activa no cede el procesador.</p> <p>Info</p> <p>Con el m\u00e9todo <code>Thread.onSpinWait()</code> de Java 9 indicamos al sistema que estamos en espera activa</p> <p>El m\u00e9todo est\u00e1tico <code>Thread.onSpinWait()</code>, a\u00f1adido en Java 9, permite indicar al entorno de ejecuci\u00f3n que el hilo moment\u00e1neamente no es capaz de progresar, hasta que ocurra alguna condici\u00f3n que se est\u00e1 comprobando en espera activa. Como consecuencia, el entorno de ejecuci\u00f3n puede llevar a cabo determinadas acciones para mejorar el rendimiento del sistema, como asignar m\u00e1s recursos a otros hilos. De esta manera se consigue retrasar la ejecuci\u00f3n de la siguiente instrucci\u00f3n del hilo en espera activa durante un determinado n\u00famero de ciclos de procesador, con la esperanza de que la ejecuci\u00f3n de otros hilos hagan que la condici\u00f3n que lo bloquea deje de producirse y el hilo pueda avanzar, minimizando el consumo de energ\u00eda. El n\u00famero de ciclos de retraso puede variar de una familia de procesadores a otra.</p> <p>En este caso el uso de <code>Thread.onSpinWait()</code> es m\u00e1s efectivo que el de <code>Thread.sleep(milliseconds)</code>, en el que se obliga al hilo a abandonar el procesador durante el tiempo indicado, obligando a un cambio de contexto adicional, que conlleva un coste adicional de tiempo.</p>"},{"location":"bloque_v/tema_22/page-5/#proyecto-busywaiting","title":"Proyecto BusyWaiting","text":"<p>En este proyecto crearemos una aplicaci\u00f3n para simular el inicio de una carrera de f\u00f3rmula 1. As\u00ed, el hilo principal crear\u00e1 un hilo director de carrera y 10 hilos cada uno de los cuales represente un piloto que participa en la carrera. Adem\u00e1s el hilo principal crear\u00e1 un objeto compartido que representa el sistema de luces en forma de sem\u00e1foros que se usa para dar inicio a la carrera, que inicialmente tiene el color rojo. Los pilotos calientan motores en espera de que el sistema de luces est\u00e9 en verde. Transcurridos tres segundos, el director de carrera pone el sistema de luces en amarillo y transcurridos otros tres segundos lo pone en verde. Los pilotos, que se encuentran en una espera activa hasta que el sistema de luces se ponga en verde, en cuento detectan que dicho evento se ha producido, inician la carrera.</p> MainLightSystemRaceDirectorPilot <pre><code>class Main {\n\n    private static final int NUMBER_OF_PILOTS = 10;\n\n    public static void main(String[] args) {\n        LightSystem lightSystem = new LightSystem();\n        Thread raceDirectorThread = new Thread(new RaceDirector(lightSystem), \n                                            \"Race director\");\n        Thread[] pilots = new Thread[NUMBER_OF_PILOTS];\n        for (int i = 0; i &lt; NUMBER_OF_PILOTS; i++) {\n            pilots[i] = new Thread(new Pilot(i, lightSystem), \"Pilot \" + i);\n        }\n        raceDirectorThread.start();\n        for (int i = 0; i &lt; NUMBER_OF_PILOTS; i++) {\n            pilots[i].start();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\nclass LightSystem {\n\n    public enum Color {\n        RED, YELLOW, GREEN\n    }\n\n    private final DateTimeFormatter dateTimeFormatter = \n        DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    private volatile Color currentColor = Color.RED;\n\n    void setColor(Color newColor) {\n        currentColor = newColor;\n        System.out.printf(\"%s - Light system in %s\\n\", \n                        LocalDateTime.now().format(dateTimeFormatter), newColor);\n    }\n\n    Color getColor() {\n        return currentColor;\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\n\npublic class RaceDirector implements Runnable {\n\n    private final LightSystem lightSystem;\n\n    public RaceDirector(LightSystem lightSystem) {\n        Objects.requireNonNull(lightSystem);\n        this.lightSystem = lightSystem;\n    }\n\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(3000);\n            lightSystem.setColor(LightSystem.Color.YELLOW);\n            Thread.sleep(3000);\n            lightSystem.setColor(LightSystem.Color.GREEN);\n        } catch (InterruptedException e) {\n            return;\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Objects;\n\nclass Pilot implements Runnable {\n\n    private final int number;\n    private final LightSystem lightSystem;\n\n    private final DateTimeFormatter dateTimeFormatter = \n        DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    Pilot(int number, LightSystem lightSystem) {\n        Objects.requireNonNull(lightSystem);\n        this.number = number;\n        this.lightSystem = lightSystem;\n    }\n\n    @Override\n    public void run() {\n        warmup();\n        while (!Thread.currentThread().isInterrupted() &amp;&amp; \n            lightSystem.getColor() != LightSystem.Color.GREEN) {\n            Thread.onSpinWait();\n        }\n        if (!Thread.currentThread().isInterrupted()) {\n            start();\n        }\n    }\n\n    private void start() {\n        System.out.printf(\"%s - Pilot %d starts the race!!!\\n\", \n                        LocalDateTime.now().format(dateTimeFormatter), number);\n    }\n\n    private void warmup() {\n        System.out.printf(\"%s - Pilot %d is warming up car engine\\n\", \n                        LocalDateTime.now().format(dateTimeFormatter), number);\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_22/page-6/","title":"6 Wait Notify","text":""},{"location":"bloque_v/tema_22/page-6/#condiciones-en-un-bloque-sincronizado","title":"Condiciones en un bloque sincronizado","text":"<p>Cuando usamos varios bloques sincronizados sobre el mismo cerrojo intr\u00ednseco debemos tener en cuenta que si existe alguna condici\u00f3n por la que el hilo no pueda continuar la ejecuci\u00f3n de la secci\u00f3n cr\u00edtica, el hilo deber\u00eda suspender su ejecuci\u00f3n y liberar cerrojo, en espera de que deje de cumplirse la condici\u00f3n que no le permite continuar. De esta manera, otro hilo podr\u00e1 ejecutar el mismo u otro bloque sincronizado sobre protegido por dicho cerrojo. Esto es de vital importancia cuando el hecho de que la condici\u00f3n que bloquea al hilo deje de cumplirse depende de que otro hilo acceda a otra secci\u00f3n cr\u00edtica protegida por el mismo cerrojo, ya que si el primer hilo no liberara dicho cerrojo, el segundo nunca podr\u00eda entrar en dicha secci\u00f3n cr\u00edtica y por tanto la condici\u00f3n que bloquea al primer hilo nunca dejar\u00eda de cumplirse.</p> <p>Por otra parte, el hecho de que el hilo se suspenda esperando que la condici\u00f3n que lo bloquea deje de cumplirse implica que habr\u00e1 que notificarle en el futuro cuando deber\u00eda volver a estar listo para comprobar de nuevo la condici\u00f3n. As\u00ed, cuando otro hilo realice alguna acci\u00f3n que suponga que la condici\u00f3n que bloquea al primer hilo pueda dejar de cumplirse deber\u00e1 notificarlo al sistema para que el primer hilo trate de volver a adquirir el cerrojo y retome la secci\u00f3n cr\u00edtica, volviendo a comprobar la condici\u00f3n, de manera que si deja de cumplirse, contin\u00fae con la ejecuci\u00f3n de la secci\u00f3n cr\u00edtica.</p> <p>Esta condici\u00f3n de bloqueo recibe habitualmente el nombre de centinela (guard en ingl\u00e9s) o condici\u00f3n de paso.</p> <p>El ejemplo t\u00edpico de lo que acabamos de explicar es el llamado problema del productor-consumidor, que se describe a continuaci\u00f3n. Tenemos un buffer de datos en el que uno o m\u00e1s productores almacenan datos y del que uno o m\u00e1s consumidores extraen datos. Como el buffer es una estructura de datos compartida por ellos, deberemos controlar su acceso usando el mecanismo de sincronizaci\u00f3n descrito en el apartado anterior. Sin embargo, tenemos m\u00e1s limitaciones, como el hecho de que un proveedor no puede almacenar m\u00e1s datos en el buffer si \u00e9ste est\u00e1 lleno o que un consumidor no puede extraer datos del buffer si est\u00e1 vac\u00edo.</p> <p>M\u00e9todo wait()</p> <p>Al llamar a <code>wait()</code> desde un bloque o m\u00e9todo sincronizado, el hilo se suspende y se libera el cerrojo intr\u00ednseco que lo protege</p> <p>Para este tipo de situaciones, Java proporciona una serie de m\u00e9todos espec\u00edficos en la clase <code>Object</code>. Una vez obtenido mediante <code>synchronized</code> el cerrojo intr\u00ednseco asociado a un determinado objeto, un hilo puede llamar al m\u00e9todo <code>wait()</code> sobre dicho objeto. Al llamar a <code>wait()</code>, el hilo se suspende y se libera el cerrojo que protege el bloque sincronizado, lo que permite que otros hilos ejecuten otros bloques de c\u00f3digo sincronizados protegidos por el mismo cerrojo.</p> <p>El m\u00e9todo <code>wait(timeoutMillis)</code> se encuentra sobrecargado para que podamos especificar un tiempo m\u00e1ximo que un hilo puede estar suspendido esperando a que deje de cumplirse la condici\u00f3n de bloqueo, transcurrido el cual el hilo ser\u00e1 reactivado autom\u00e1ticamente. Si se pasa un valor negativo para el par\u00e1metro <code>timeoutMilllis</code> se lanza la excepci\u00f3n <code>IllegalArgumentException</code>. Sin embargo, bajo nuestro punto de vista, el m\u00e9todo <code>wait(timoutMillis)</code> tiene el inconveniente de que no nos informa de si se ha dejado de esperar porque nos han notificado o porque se ha consumido el tiempo m\u00e1ximo especificado.</p> <p>Como la mayor\u00eda de m\u00e9todos bloqueantes, los m\u00e9todo <code>wait()</code> y <code>wait(timeoutMillis)</code> lanzan la excepci\u00f3n <code>InterruptedException</code> si el hilo correspondiente es interrumpido mientras est\u00e1 suspendido en espera de que deje de cumplirse la condici\u00f3n de bloqueo, o si ya hab\u00eda sido marcado como interrumpido antes de llamar a <code>wait()</code> o <code>wait(timeoutMillis)</code>, reactivando inmediatamente el hilo en ambos casos.</p> <p>Si se llama a <code>wait()</code> o <code>wait(timeoutMillis)</code> desde hace fuera de un bloque o m\u00e9todo <code>synchronized</code>, se lanzar\u00e1 la excepci\u00f3n <code>IllegalMonitorStateException</code>, ya que el empleo de estos m\u00e9todos est\u00e1 asociado al cerrojo intr\u00ednseco del objeto sobre el que se ejecutan.</p> <p> Figura 3 - Wait y notifyAll</p> <p>Para reactivar un hilo que ha sido bloqueado mediante <code>wait()</code> o <code>wait(timeoutMillis)</code>, otro hilo debe llamar al m\u00e9todo <code>notify()</code> o <code>notifyAll()</code>, tambi\u00e9n desde dentro de un bloque de c\u00f3digo protegido por el mismo cerrojo intr\u00ednseco, para notificar que se ha producido alg\u00fan \"evento\" que hace que sea posible que alguna condici\u00f3n de bloqueo (guard) deje de cumplirse, y por tanto los hilos que estaban bloqueados en dicha condici\u00f3n puedan continuar.</p> <p>Como consecuencia de la llamada a <code>notifyAll()</code> todos los hilos que hubieran sido bloqueados mediante <code>wait()</code> o <code>wait(timeMillis)</code> en dicho cerrojo intr\u00ednseco por cualquier condici\u00f3n de bloqueo ser\u00e1n reactivados.</p> <p>Un aspecto importante es que cuando se hace <code>notifyAll()</code> no hay garant\u00eda de que el evento concreto que se est\u00e1 notificando sea por el que est\u00e1n interesados los hilos bloqueados en dicho cerrojo. De hecho, existe otro m\u00e9todo, llamado <code>notify()</code> que reactiva un s\u00f3lo hilo, pero no se recomienda su uso cuando haya distintas condiciones de espera, porque el hilo reactivado podr\u00eda no estar interesado en dicho \"evento\" y otros hilos que s\u00ed estar\u00edan interesados no ser\u00edan reactivados.</p> <p>Adem\u00e1s, el m\u00e9todo <code>notify()</code> no proporciona ninguna garant\u00eda sobre qu\u00e9 hilo ser\u00e1 reactivado si varios hilos est\u00e1n esperando en el mismo objeto monitor, lo que puede llevar a que un determinado hilo sufra inanici\u00f3n, es decir que nunca sea reactivado cuando se llama <code>notify()</code> porque siempre es reactivado alg\u00fan otro hilo que estuviera esperando. Para solucionar este problema, como estudiaremos m\u00e1s adelante, deberemos usar un objeto <code>ReentrantLock</code> con el modo fair activado y definir un objeto <code>Condition</code> por el que esperar, asociado a dicho cerrojo.</p> <p>Si existe una \u00fanica condici\u00f3n de espera en dicho objeto monitor y el evento s\u00f3lo va a permitir a un \u00fanico hilo continuar, entonces es m\u00e1s adecuado llamar a <code>notify()</code> en vez de llamar a <code>notifyAll()</code>, ya que estar\u00edamos reactivando a varios hilos innecesariamente, a lo que se conoce como el thundering herd problem (problema de la \"manada atronadora\").</p> <p>Este problema ocurre cuando un gran n\u00famero de procesos o hilos en espera de un evento (\"la manada\") son despertados repentinamente cuando se produce el evento, pero en realidad un s\u00f3lo hilo es capaz de sacar provecho de ello y avanzar. Todos los hilos lo intentar\u00e1n, compitiendo por los recursos, consumiendo ciclos de procesamiento, pero s\u00f3lo uno de ellos lo conseguir\u00e1. Ese consumo de recursos cesar\u00e1 cuando los hilos descubran que no pueden avanzar y vuelvan a esperar, es decir, \"cuando la manada vuelve a calmarse\".</p> <p>Warning</p> <p>Si comprobamos la condici\u00f3n de bloque una sola vez, puede que avancemos sin que debi\u00e9ramos</p> <p>Al usar <code>notifyAll()</code> debemos tener en cuenta que todos los hilos reactivados compiten por volver a adquirir el cerrojo, lo que puede implicar que para cuando un hilo reactivado consiga adquirir el cerrojo para continuar con la ejecuci\u00f3n de su secci\u00f3n cr\u00edtica la condici\u00f3n de bloqueo que lo bloqueaba vuelva a cumplirse, a pesar de que en alg\u00fan momento dej\u00f3 de cumplirse y otro hilo lo notific\u00f3. Por este motivo se debe evaluar la condici\u00f3n de bloqueo en un bucle <code>while</code> y no en un simple <code>if</code>.</p> <pre><code>synchronized(this) {\n    while(condicion_bloqueo) {\n        wait();\n    }\n    // ...\n}\n</code></pre>"},{"location":"bloque_v/tema_22/page-6/#proyecto-waitnotify","title":"Proyecto WaitNotify","text":"<p>En este proyecto crearemos una aplicaci\u00f3n que ejecuta dos hilos, un hilo productor dedicado a producir donuts y almacenarlos en una bandeja de la pasteler\u00eda y otro hilo consumidor dedicado a extraer elementos de la bandeja de la pasteler\u00eda y consumirlos. El problema radica en que ambos pueden acceder simult\u00e1neamente a la misma estructura de datos para agregar o extraer un donut, lo que implica que deberemos proveer mecanismos de sincronizaci\u00f3n sobre dichos accesos. Por otra parte, un productor no puede agregar un donut a la estructura de datos si la bandeja ya esta llena y un consumidor no puede extraer un elemento de la bandeja si \u00e9sta est\u00e1 vac\u00eda. Estas condiciones de bloqueo se ejecutan dentro del bloque sincronizado, por lo que deberemos usar el m\u00e9todo <code>wait()</code> para suspender los hilos mientras no puedan continuar y usar el m\u00e9todo <code>notifyAll()</code> para reactivarlos cuando deba volver a evaluarse la condici\u00f3n centinela.</p> MainBakeryDoughnutConsumerDoughnutProducer <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        Bakery bakery = new Bakery();\n        Thread doughnutProducerThread = new Thread(new DoughnutProducer(bakery), \"Doughnut producer\");\n        Thread doughnutConsumerThread = new Thread(new DoughnutConsumer(bakery), \"Doughnut consumer\");\n        doughnutProducerThread.start();\n        doughnutConsumerThread.start();\n    }\n\n}\n</code></pre> <pre><code>import java.util.ArrayList;\n\npublic class Bakery {\n\n    private static final int TRAY_CAPACITY = 10;\n\n    private final ArrayList&lt;Integer&gt; tray = new ArrayList&lt;&gt;();\n\n    public void addToTray(Integer doughnut) throws InterruptedException {\n        synchronized (this) {\n            while (tray.size() &gt;= TRAY_CAPACITY) {\n                System.out.println(\"Producer waiting for the tray to have room\");\n                wait();\n            }\n            tray.add(doughnut);\n            System.out.printf(\"Producer puts doughnut #%d on the tray\\n\", doughnut);\n            notifyAll();\n        }\n    }\n\n    public Integer extractFromTray() throws InterruptedException {\n        Integer doughnut;\n        synchronized (this) {\n            while (tray.isEmpty()) {\n                System.out.println(\"Consumer waiting for the tray to have a doughnut\");\n                wait();\n            }\n            doughnut = tray.remove(0);\n            System.out.printf(\"Consumer extracts doughnut #%d from tray\\n\", doughnut);\n            notifyAll();\n            return doughnut;\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutConsumer implements Runnable {\n\n    private final Bakery bakery;\n\n    public DoughnutConsumer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        Integer doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = bakery.extractFromTray();\n            } catch (InterruptedException e) {\n                System.out.println(\"Consumer has been interrupted while extracting from tray\");\n                return;\n            }\n            try {\n                eat(doughnut);\n            } catch (InterruptedException e) {\n                System.out.println(\"Consumer has been interrupted while eating\");\n                return;\n            }\n        }\n        System.out.println(\"Consumer has been interrupted\");\n    }\n\n    private void eat(int doughnut) throws InterruptedException {\n        System.out.printf(\"Consumer is eating doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(1);\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutProducer implements Runnable {\n\n    private final Bakery bakery;\n    private int doughnutNumber;\n\n    public DoughnutProducer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        Integer doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = makeDoughnut();\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while making a doughnut\");\n                return;\n            }\n            try {\n                bakery.addToTray(doughnut);\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while adding a doughnut to the tray\");\n                return;\n            }\n        }\n        System.out.println(\"Producer has been interrupted\");\n    }\n\n    private int makeDoughnut() throws InterruptedException {\n        Integer doughnut = ++doughnutNumber;\n        System.out.printf(\"Producer is making doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(3);\n        return doughnut;\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_22/page-7/","title":"7 Lock","text":""},{"location":"bloque_v/tema_22/page-7/#la-interfaz-lock","title":"La interfaz Lock","text":"<p>Java 5 trajo consigo un nuevo paquete de clases dise\u00f1ado espec\u00edficamente para proporcionar herramientas \u00fatiles para el desarrollo de aplicaciones concurrentes con m\u00faltiples hilos de ejecuci\u00f3n, denominado <code>java.util.concurrent</code>.</p> <p>En ese paquete Java proporciona otro mecanismo m\u00e1s potente y flexible que los cerrojos intr\u00ednsecos para la sincronizaci\u00f3n de bloques de c\u00f3digo, conocido como sincronizaci\u00f3n expl\u00edcita, basado en la interfaz <code>Lock</code> y las clases que la implementan, como por ejemplo la clase <code>ReentrantLock</code>.</p> <p>Al igual que en el caso de <code>synchronized</code> y los cerrojos intr\u00ednsecos, al usar la interfaz <code>Lock</code> no s\u00f3lo aseguramos la atomicidad sino tambi\u00e9n la visibilidad, por lo que no ser\u00e1 necesario definir con <code>volatile</code> las variables protegidas mediante un <code>Lock</code>.</p> <p>Este mecanismo presenta una serie de ventajas respecto al empleo de <code>synchronized</code> y los cerrojos intr\u00ednsecos, proporcionando funcionalidades adicionales. En primer lugar, permite que estructuras m\u00e1s complejas implementen una secci\u00f3n cr\u00edtica, dado que no est\u00e1 limitado por la construcci\u00f3n de un bloque sint\u00e1ctico <code>synchronized</code>.</p> <p>Adem\u00e1s, permite a un hilo adquirir el cerrojo de distintas formas. La primera de ella es adquirirla de forma similar a si us\u00e1ramos <code>synchronized</code>. Para ello usaremos el m\u00e9todo <code>lock()</code> de la interfaz <code>Lock</code>, que trata de adquirir el cerrojo y si no es posible bloquea al hilo en espera de poder adquirirlo. Si el hilo es interrumpido mientras est\u00e1 bloqueado esperando la adquisici\u00f3n del cerrojo, nada sucede, hasta que no consiga adquirir el hilo no podr\u00e1 ser consciente de que ha sido interrumpido. Se trata por tanto de una adquisici\u00f3n bloqueante no interrumpible.</p> <p> Figura 4 - Lock</p> <p>Otra forma de adquisici\u00f3n, no disponible mediante <code>synchronized</code>, es usar el m\u00e9todo <code>lockInterruptibly()</code> de la interfaz <code>Lock</code>, que trata de adquirir el cerrojo y si no es posible bloquea al hilo en espera de poder adquirirlo. Si el hilo es interrumpido mientras est\u00e1 bloqueado esperando la adquisici\u00f3n del cerrojo, el hilo es reactivado y se lanza la excepci\u00f3n <code>InterruptedException</code>. Si el hilo ya hab\u00eda sido marcado para interrupci\u00f3n antes de llamar a <code>lockInteruptibly()</code>, dicho m\u00e9todo lanzar\u00e1 directamente la excepci\u00f3n <code>InterruptedException</code> sin conceder el cerrojo al hilo. Se trata por tanto de una adquisici\u00f3n bloqueante interrumpible.</p> <p>Una tercera forma de adquisici\u00f3n, tampoco disponible mediante <code>synchronized</code>, es intentar adquirir el cerrojo sin tener que bloquearse si no puede hacerlo. Para tal fin, la interfaz <code>Lock</code> proporciona el m\u00e9todo <code>tryLock()</code>, que no bloquea el hilo, sino que retorna un valor booleano para indicar si se ha adquirido el cerrojo o no, permitiendo que el hilo decida qu\u00e9 hacer si no lo ha adquirido. Se trata por tanto de una adquisici\u00f3n no bloqueante</p> <p>Existe una cuarta alternativa intemedia, tampoco disponible mediante <code>synchronized</code>, consistente en usar el m\u00e9todo <code>tryLock(time, timeUnit)</code> sobrecargado de manera que recibe el tiempo m\u00e1ximo que queremos que sea bloqueado el hilo en espera de poder adquirir el cerrojo, transcurrido el cual retornar\u00e1 <code>true</code>. Esta llamada es bloqueante, pero con un l\u00edmite de tiempo. Si el hilo es interrumpido mientras est\u00e1 bloqueado en espera de adquirir el cerrojo, el hilo ser\u00e1 reactivado y se lanzar\u00e1 la excepci\u00f3n <code>InterruptedException</code>. De igual forma, si el hilo ya hab\u00eda sido marcado como interrumpido antes de llamar a <code>tryLock(timeout, timeUnit)</code>, se lanzar\u00e1 la misma excepci\u00f3n. Se trata por tanto de una adquisici\u00f3n bloqueante interrumpible con un tiempo m\u00e1ximo de espera. Si el valor pasado como tiempo es menor o igual a 0, se comportar\u00e1 igual que <code>tryLock()</code> y no se bloquear\u00e1.</p> <p>Podemos usar el m\u00e9todo <code>tryLock(timeout, timeUnit)</code> para evitar el problema conocido como dead lock (abrazo mortal), en el que dos hilos quedan interbloqueados en espera de adquisici\u00f3n de un cerrojo. Por ejemplo, si el hilo 1 adquiere el recurso A y trata de adquirir el recurso B, y el hilo 2 adquiere el recurso B y trata de adquirir el recurso A, ambos estar\u00e1n interbloqueados para siempre. Sin embargo, si usamos <code>tryLock(timeout, timeUnit)</code> a la hora de adquirir los cerrojos correspondientes a los recursos, entonces podemos programar que si transcurrido el tiempo no se ha adquirido liberemos el recurso que ya ten\u00edamos, permitiendo al otro hilo avanzar, deshaciendo as\u00ed el interbloqueo.</p> <p>A la hora de liberar el cerrojo que hayamos adquirido, deberemos llamar al m\u00e9todo <code>unlock()</code> de la interfaz <code>Lock</code>. Si no lo hici\u00e9ramos, los otros hilos que estuvieran esperando a adquirir el cerrojo estar\u00edan bloqueados indefinidamente, provocando una situaci\u00f3n de punto muerto (deadlock). Por este motivo, si usamos bloques <code>try-catch-finally</code> dentro de nuestra secci\u00f3n cr\u00edtica, debemos hacer la llamada a <code>unlock()</code> dentro de <code>finally</code>. De esta manera tanto si la secci\u00f3n cr\u00edtica es ejecutada satisfactoriamente como si se produce una excepci\u00f3n, el cerrojo ser\u00e1 liberado.</p> <p>Debemos tener en cuenta que el cerrojo debe ser liberado desde el mismo hilo que lo adquiri\u00f3. Esto parece bastante obvio, pero como estudiaremos m\u00e1s adelante, en otros tipos de sincronizadores, llamados sem\u00e1foros, la regla anterior no es obligatoria.</p> <p>El m\u00e9todo <code>unlock()</code> lanza la excepci\u00f3n <code>IllegalMonitorStateException</code> si se llama sin haber adquirido el cerrojo.</p> <p>Ve\u00e1moslo en c\u00f3digo:</p> <pre><code>lock.lock();\ntry {\n    // Secci\u00f3n cr\u00edtica\n    // ...\n} finally {\n    // De esta manera, el cerrojo ser\u00e1 liberado tanto \n    lock.unlock();\n}\n</code></pre> <p> Figura 5 - Unlock</p> <p>Al usar <code>synchronized</code> la adquisici\u00f3n y liberaci\u00f3n del cerrojo se realizaba de forma estructurada en forma de m\u00e9todo o de bloque de sentencias (fully bracket). De hecho, cuando se adquieren varios cerrojos intr\u00ednsecos, \u00e9stos son liberados obligatoriamente en el orden inverso en el que fueron adquiridos. Sin embargo al usar la interface <code>Lock</code>, la adquisici\u00f3n y liberaci\u00f3n de cerrojo no es estructurada (not fully bracket), sino que corresponde a simples llamadas a los m\u00e9todos vistos anteriormente. Este sistema es m\u00e1s flexible, pero obliga al programador a ser muy cuidadoso al establecer el orden en el que se llama a dichos m\u00e9todos.</p> <p>Otro aspecto muy importante con el que debemos tener cuidado a la hora de usar la interfaz <code>Lock</code> es evitar crear interbloqueos (deadlock) debido a que dos o m\u00e1s hilos queden bloqueados esperando la liberaci\u00f3n de cerrojos que nunca llegar\u00e1n a ser liberados. Por ejemplo, supongamos que un hilo A adquiere un cerrojo X y otro hilo B adquiere otro cerrojo Y. Si ahora el hilo A trata de adquirir el cerrojo Y y el hilo B simult\u00e1neamente trata de adquirir el cerrojo X, ambos hilos estar\u00e1n interbloqueados indefinidamente, porque est\u00e1n esperando la liberaci\u00f3n de cerrojos que nunca ser\u00e1n liberados. En este caso el problema ocurre porque ambos hilos tratan de obtener los cerrojos en el orden inverso uno respecto al otro.</p> <p>Otro aspecto diferenciador respecto a <code>synchronized</code> es que, como veremos en un apartado posterior, la interfaz <code>Lock</code> es usada por la interfaz <code>ReadWriteLock</code> y la clase <code>ReentrantReadWriteLock</code>, que permite que existan varios hilos lectores realizando operaciones de lectura sobre la estructura de datos protegida, algo que no es posible con los bloques o los m\u00e9todos <code>synchronized</code>.</p> <p>Una \u00faltima diferencia respecto a <code>synchronized</code> es que, como estudiaremos en un apartado posterior, la interfaz <code>Lock</code> permite definir m\u00e1s de una condici\u00f3n de bloqueo por la que los hilos pueden tener que ser bloqueados dentro de la secci\u00f3n cr\u00edtica una vez adquirido el cerrojo. Gracias a ello, cuando se produce un evento que puede hacer que deja de cumplirse una determinada condici\u00f3n de bloqueo, se puede notificar dicho evento a esa condici\u00f3n en concreto, de manera que s\u00f3lo sean reactivados los hilos que estuvieran bloqueados esperando en dicha condici\u00f3n de bloqueo, y no en otras. Esto es especialmente interesante porque nos permite \"notificar\" del evento a un \u00fanico hilo que estuviera esperando, de manera que s\u00f3lo se reactive un \u00fanico hilo. En la pr\u00e1ctica, con los bloques <code>synchronized</code>, al no disponer de distintas colas de espera no es tan seguro \"notificar\" del evento a un \u00fanico hilo, ya que puede que el hilo reactivado no estuviera esperando por dicho evento, con lo que ning\u00fan hilo que realmente estuviera esperando dicho evento ser\u00eda despertado.</p>"},{"location":"bloque_v/tema_22/page-7/#reentrantlock","title":"ReentrantLock","text":"<p>La clase <code>ReentrantLock</code> es la clase principal de implementa la interfaz <code>Lock</code>. Adem\u00e1s de la funcionalidad definida por dicha interfaz, la clase <code>ReentrantLock</code> proporciona una serie de m\u00e9todos informativos que permiten hacer un seguimiento del cerrojo:</p> <ul> <li><code>getOwner()</code>: Retorna el nombre del hilo que ha adquirido el lock.</li> <li><code>getQueuedThreads()</code>: Retorna la lista de hilos que est\u00e1n esperando a entrar en la secci\u00f3n cr\u00edtica protegida por el lock.</li> <li><code>hasQueuedThreads()</code>: Retorna <code>true</code> si hay hilos esperando en el lock.</li> <li><code>getQueueLength()</code>: Retorna el n\u00famero de hilos esperando en el lock.</li> <li><code>isLocked()</code>: Retorna <code>true</code> si alg\u00fan hilo ha obtenido el lock.</li> <li><code>isFair()</code>: Retorna <code>true</code> si el lock tiene activado el modo justo.</li> <li><code>getHoldCount()</code>: Retorna el n\u00famero de veces que el hilo actual ha adquirido el lock.</li> <li><code>isHeldByCurrentThread()</code>: Retorna si el lock ha sido adquirido por el hilo actual.</li> </ul> <p>El cerrojo definido por <code>ReentrantLock</code> es tambi\u00e9n reentrante (de ah\u00ed su nombre), al igual que el cerrojo intr\u00ednseco usado por <code>synchronized</code>, por lo que cuando un hilo obtiene en un m\u00e9todo el control de un cerrojo y realiza una llamada a otro m\u00e9todo o a ese mismo m\u00e9todo de forma recursiva, contin\u00faa teniendo el control del cerrojo, y si se trata de adquirir de nuevo no queda bloqueado por \u00e9l mismo.</p> <p> Figura 6 - ReentrantLock</p> <p>El constructor de la clase <code>ReentrantLock</code> est\u00e1 sobrecargado para admitir un par\u00e1metro booleano denominado <code>fair</code> (justo), que permite establecer si queremos que se active en el cerrojo el modo justo (fair-mode). Por defecto, los cerrojos tienen desactivados este modo, pero podemos activarlo pasando el valor <code>true</code> para dicho par\u00e1metro en el constructor.</p> <p>Al activar el modo justo, cuando varios hilos est\u00e9n esperando en el cerrojo, y \u00e9ste deba seleccionar un hilo para darle acceso a la secci\u00f3n cr\u00edtica, al haber sido liberado por el hilo que pose\u00eda, se seleccionar\u00e1 el hilo que lleve m\u00e1s tiempo esperando para obtener el cerrojo (cola FIFO), y no se seleccionar\u00e1 aleatoriamente, como sucede cuando el modo justo est\u00e1 desactivado.</p> <p>La ventaja principal del modo justo es que impide que se produzca inanici\u00f3n en la adquisici\u00f3n del cerrojo por parte de los hilos.</p> <p>El modo justo es respetado por los m\u00e9todos <code>lock()</code>, <code>lockInterruptibly()</code> y <code>tryLock(time, timeUnit)</code>, pero no por el m\u00e9todo <code>tryLock()</code>, que puede hacer que el hilo que lo llama \"se cuele\". Si queremos formar a que lo respete deberemos llamar a <code>tryLock(0, timeUnit)</code>.</p> <p>Finalmente, debemos tener en cuenta que la aplicaci\u00f3n del modo justo a un cerrojo a\u00f1ade un determinado coste en tiempo de ejecuci\u00f3n, por lo que s\u00f3lo debemos establecerlo cuando los requerimientos as\u00ed lo especifiquen.</p>"},{"location":"bloque_v/tema_22/page-7/#proyecto-reentrantlock","title":"Proyecto ReentrantLock","text":"<p>En este proyecto crearemos un programa que simula el env\u00edo de documentos a la cola de impresi\u00f3n de una impresora, teniendo en cuenta que s\u00f3lo un documento puede estar imprimi\u00e9ndose en un momento dado. Para la sincronizaci\u00f3n usaremos un objeto de la clase <code>ReentrantLock</code>, que implementa la interfaz <code>Lock</code>.</p> MainPrinterPrintJob <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        Printer printer = new Printer();\n        Thread[] printJobThreads = new Thread[10];\n        for (int i = 0; i &lt; 10; i++) {\n            printJobThreads[i] = new Thread(new PrintJob(printer, \"Document #\" + i), \"Print job #\" + i);\n        }\n        for (int i = 0; i &lt; 10; i++) {\n            printJobThreads[i].start();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Printer {\n\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n    private final Lock reentrantLock = new ReentrantLock(true);\n\n    public void print(String document) throws InterruptedException {\n        reentrantLock.lock();\n        try {\n            printDocument(document);\n        } finally {\n            // This is called even if an exception is thrown.\n            reentrantLock.unlock();\n        }\n    }\n\n    private void printDocument(String document) throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s: Document printing started\\n\",\n                LocalTime.now().format(dateTimeFormatter), Thread.currentThread().getName());\n        System.out.printf(\"%s -&gt; %s: %s...\\n\",\n                LocalTime.now().format(dateTimeFormatter), Thread.currentThread().getName(), document);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5));\n        System.out.printf(\"%s -&gt; %s: Printing finished\\n\",\n                LocalTime.now().format(dateTimeFormatter), Thread.currentThread().getName());\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\n\npublic class PrintJob implements Runnable {\n\n    private final Printer printer;\n    private final String document;\n\n    public PrintJob(Printer printer, String document) {\n        Objects.requireNonNull(printer);\n        Objects.requireNonNull(document);\n        this.printer = printer;\n        this.document = document;\n    }\n\n    @Override\n    public void run() {\n        try {\n            printer.print(document);\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s -&gt; I've been interrupted while printing document\\n\",\n                    Thread.currentThread().getName());\n        }\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_22/page-8/","title":"8 Condition","text":""},{"location":"bloque_v/tema_22/page-8/#condition","title":"Condition","text":"<p>Un cerrojo puede tener asociados una o m\u00e1s condiciones, tambi\u00e9n llamadas colas de condici\u00f3n (condition queues) o variables de condici\u00f3n (condition variables). Las condiciones son definidas por la interfaz <code>Condition</code> y proporcionan un mecanismo para suspender a un hilo que haya obtenido el cerrojo al que est\u00e1 asociado la condici\u00f3n, porque \u00e9sta no se cumpla, liberando el cerrojo para que otro hilo lo pueda adquirir.</p> <p>Cuando otro hilo que haya adquirido el cerrojo genere un evento por el que sospeche que la condici\u00f3n por la que han sido suspendidos otros hilos pueda cumplirse, podr\u00e1 notificarlo para que sean reactivados uno o m\u00e1s hilos, de manera que se pongan a la cola de adquisici\u00f3n del cerrojo y, una vez adquirido, volver a evaluar la condici\u00f3n (bucle).</p> <p>Este mecanismo es similar al que hab\u00edamos utilizado con los bloques <code>synchronized</code> y los m\u00e9todos <code>wait()</code> y <code>notify()</code>. Sin embargo, para un cerrojo podremos determinar distintas condiciones de suspensi\u00f3n independientes con distintas \"colas de espera\", a diferencia de los bloques <code>synchronized</code> que poseen una \u00fanica cola de espera de eventos (una \u00fanica condici\u00f3n).</p> <p>Para crear una condici\u00f3n de un cerrojo utilizaremos el m\u00e9todo factor\u00eda <code>newCondition()</code>de la interfaz <code>Lock</code>, que retornar\u00e1 un objeto <code>Condition</code> asociado a dicho cerrojo y que normalmente almacenaremos en una variable cuyo nombre refleje la condici\u00f3n por la que un hilo deber\u00e1 esperar. Por ejemplo:</p> <pre><code>Lock lock = new ReentrantLock();\nCondition notFull  = lock.newCondition(); \nCondition notEmpty = lock.newCondition();\n</code></pre> <p>Si queremos que un hilo sea suspendido en la cola correspondiente a una determinada condici\u00f3n usaremos el m\u00e9todo <code>await()</code> de dicho objeto <code>Condition</code>. El m\u00e9todo <code>await()</code> tiene una funcionalidad similar al m\u00e9todo <code>wait()</code> de los cerrojos intr\u00ednsecos usados por <code>synchronized</code>.</p> <pre><code>lock.lock();\ntry {\n    while (items.length == CAPACITY) {\n        notFull.await();\n    }\n    // ...\n} finally {\n    lock.unlock();\n}\n</code></pre> <p>El m\u00e9todo <code>await(timeout, timeUnit)</code> se encuentra sobrecargado para que podamos especificar un tiempo m\u00e1ximo que un hilo puede estar suspendido esperando por una determinada condici\u00f3n, transcurrido el cual el hilo ser\u00e1 reactivado autom\u00e1ticamente, retornando el valor <code>false</code>. En caso contrario retorna <code>true</code>.</p> <p>Como la mayor\u00eda de m\u00e9todos bloqueantes, los m\u00e9todo <code>await()</code> y <code>await(timeout, timeUnit)</code> lanzan la excepci\u00f3n <code>InterruptedException</code> si el hilo correspondiente es interrumpido mientras est\u00e1 suspendido en espera en una condici\u00f3n, o si ya hab\u00eda sido marcado como interrumpido antes de llamar a <code>await()</code> o <code>await(timeout, timeUnit)</code>, reactivando inmediatamente el hilo en ambos casos.</p> <p>La interfaz <code>Condition</code> nos ofrece otra alternativa, no disponible en la clase <code>Object</code> y los cerrojos intr\u00ednsecos, consistente en el m\u00e9todo <code>awaitUninterruptedly()</code>, que funciona de forma similar a <code>await()</code>, pero si el hilo es marcado para interrupci\u00f3n mientras est\u00e1 suspendido en la condici\u00f3n, o ya hab\u00eda sido marcado para interrupci\u00f3n antes de llamar a <code>awaitUninterruptedly()</code>, el hilo no ser\u00e1 reactivado inmediatamente ni se lanzar\u00e1 la excepci\u00f3n <code>InterruptedException</code>.</p> <p>Si se llama a <code>await()</code>, <code>await(timeout, timeUnit)</code> o <code>awaitUninterruptedly()</code> sobre una condici\u00f3n de un cerrojo sin estar en posesi\u00f3n de dicho cerrojo, se lanzar\u00e1 la excepci\u00f3n <code>IllegalMonitorStateException</code>, ya que la condici\u00f3n est\u00e1 asociada a la posesi\u00f3n del cerrojo correspondiente.</p> <p>Para reactivar un hilo que ha sido bloqueado mediante <code>await()</code> o <code>await(timeout, timeUnit)</code> o <code>awaitUninterruptedly()</code> en una determinada condici\u00f3n, otro hilo debe llamar al m\u00e9todo <code>signal()</code> o al m\u00e9todo <code>signalAll()</code> de dicha condici\u00f3n, estando en posesi\u00f3n del cerrojo correspondiente, para notificar que se ha producido alg\u00fan \"evento\" que hace que sea posible que dicha condici\u00f3n se cumpla.</p> <p>Como consecuencia de la llamada a <code>signal()</code> el primer los hilos que estuvieran esperando en la cola de dicha condici\u00f3n al haber llamado a <code>await()</code>, <code>await(timeout, timeUnit)</code> o <code>awaitUninterruptedly()</code> en dicha condici\u00f3n ser\u00e1 reactivado, coloc\u00e1ndose en la cola de adquisici\u00f3n del cerrojo, de manera que una vez adquirido vuelva a comprar la condici\u00f3n (bucle).</p> <p>Si usamos <code>signalAll()</code> para la notificaci\u00f3n, entonces ser\u00e1 reactivados todos los hilos que estuvieran esperando en dicha condici\u00f3n, siendo a\u00f1adido a la cola de adquisici\u00f3n del cerrojo.</p> <p>Un aspecto importante es que se debe hacer <code>signal()</code> o <code>signalAll()</code>sobre la condici\u00f3n relacionada con el \"evento\" que se ha producido, y no sobre cualquier condici\u00f3n asociada al cerrojo correspondiente, ya que queremos reactivar a los hilos adecuados, aquellos para los que el \"evento\" puede ser relevante.</p> <p> Figura 7 - Condition</p> <p>Al ser reactivados debemos tener en cuenta que los hilos deben volver a adquirir el cerrojo, lo que puede implicar que para cuando un hilo reactivado consiga adquirir el cerrojo para continuar con la ejecuci\u00f3n de su secci\u00f3n cr\u00edtica la condici\u00f3n que lo bloqueaba vuelva a dejar de cumplirse, a pesar de que en alg\u00fan momento s\u00ed se cumpli\u00f3 y otro hilo lo notific\u00f3. Por este motivo se debe evaluar la condici\u00f3n en un bucle <code>while</code> y no en un simple <code>if</code>.</p> <pre><code>lock.lock();\ntry {\n    while (items.length == CAPACITY) {\n        notFull.await();\n    }\n    // ...\n} finally {\n    lock.unlock();\n}\n</code></pre> <p>Nunca hagas esto</p> <p>Nunca uses los m\u00e9todos <code>wait()</code>, <code>notify</code> y <code>notifyAll</code> del objeto <code>Condition</code></p> <p>Algo que debemos tener en cuenta es que, dado que <code>Condition</code> extiende de <code>Object</code>, nuestro objeto <code>Condition</code> tambi\u00e9n posee los m\u00e9todos <code>wait()</code>, <code>notify</code> y <code>notifyAll</code>, pero nunca debemos usarlos. Estos m\u00e9todos s\u00f3lo deben ser usados desde bloques o m\u00e9todos <code>synchronized</code>.</p> <p>Si creamos condiciones en un <code>Lock</code> en el que ha establecido el modo justo, cuando los hilos sean reactivados mediante una notificaci\u00f3n, se a\u00f1adir\u00e1n \"en orden\" a la cola de adquisici\u00f3n del cerrojo.</p>"},{"location":"bloque_v/tema_22/page-8/#proyecto-condition","title":"Proyecto Condition","text":"<p>En este proyecto realizaremos el ejemplo del productor-consumidor que vimos en un apartado anterior, pero usando los cerrojos y las condiciones en vez de bloques <code>synchronized</code>.</p> MainBakeryDoughnutConsumerDoughnutProducer <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        Bakery bakery = new Bakery();\n        Thread doughnutProducerThread = new Thread(new DoughnutProducer(bakery), \"Doughnut producer\");\n        Thread doughnutConsumerThread = new Thread(new DoughnutConsumer(bakery), \"Doughnut consumer\");\n        doughnutProducerThread.start();\n        doughnutConsumerThread.start();\n    }\n\n}\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Bakery {\n\n    private static final int TRAY_CAPACITY = 10;\n\n    private final ArrayList&lt;Integer&gt; tray = new ArrayList&lt;&gt;();\n    private final ReentrantLock lock = new ReentrantLock(true);\n    private final Condition isNotFull = lock.newCondition();\n    private final Condition isNotEmpty = lock.newCondition();\n\n    public void addToTray(Integer doughnut) throws InterruptedException {\n        lock.lock();\n        try {\n            while (tray.size() &gt;= TRAY_CAPACITY) {\n                System.out.println(\"Producer waiting for the tray to have room\");\n                isNotFull.await();\n            }\n            tray.add(doughnut);\n            System.out.printf(\"Producer puts doughnut #%d on the tray\\n\", doughnut);\n            isNotEmpty.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public Integer extractFromTray() throws InterruptedException {\n        Integer doughnut;\n        lock.lock();\n        try {\n            while (tray.isEmpty()) {\n                System.out.println(\"Consumer waiting for the tray to have a doughnut\");\n                isNotEmpty.await();\n            }\n            doughnut = tray.remove(0);\n            System.out.printf(\"Consumer extracts doughnut #%d from tray\\n\", doughnut);\n            isNotFull.signal();\n            return doughnut;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutConsumer implements Runnable {\n\n    private final Bakery bakery;\n\n    public DoughnutConsumer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        Integer doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = bakery.extractFromTray();\n            } catch (InterruptedException e) {\n                System.out.println(\"Consumer has been interrupted while extracting from tray\");\n                return;\n            }\n            try {\n                eat(doughnut);\n            } catch (InterruptedException e) {\n                System.out.println(\"Consumer has been interrupted while eating\");\n                return;\n            }\n        }\n        System.out.println(\"Consumer has been interrupted\");\n    }\n\n    private void eat(int doughnut) throws InterruptedException {\n        System.out.printf(\"Consumer is eating doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(1);\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutProducer implements Runnable {\n\n    private final Bakery bakery;\n    private int doughnutNumber;\n\n    public DoughnutProducer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        Integer doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = makeDoughnut();\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while making a doughnut\");\n                return;\n            }\n            try {\n                bakery.addToTray(doughnut);\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while adding a doughnut to the tray\");\n                return;\n            }\n        }\n        System.out.println(\"Producer has been interrupted\");\n    }\n\n    private int makeDoughnut() throws InterruptedException {\n        Integer doughnut = ++doughnutNumber;\n        System.out.printf(\"Producer is making doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(3);\n        return doughnut;\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que funciona de manera similar al \"Proyecto WaitNotify\".</p>"},{"location":"bloque_v/tema_22/page-9/","title":"9 ReentrantReadWriteLock","text":""},{"location":"bloque_v/tema_22/page-9/#reentrantreadwritelock","title":"ReentrantReadWriteLock","text":"<p>En algunas ocasiones, el recurso que estamos protegiendo mediante un cerrojo es accedido para lectura con una frecuencia mucho mayor que para escritura. Como ya sabemos, el acceso concurrente para lectura no es problem\u00e1tico, por lo que en estos casos, el uso de un objeto <code>ReentrantLock</code> para proteger el acceso al recurso supone un coste de ejecuci\u00f3n excesivo teniendo en cuenta que el acceso para escritura es muy poco frecuente y que el acceso concurrente para lectura no deber\u00eda bloquear a los hilos.</p> <p>Cabr\u00eda preguntarse los siguiente: \u00bfsi varios hilos s\u00f3lo van a leer el recurso y otros van a modificar el recurso, por qu\u00e9 es necesario que los hilos que s\u00f3lo van a leer adquieran un cerrojo de lectura? \u00bfpor qu\u00e9 no pueden simplemente leer el recurso?</p> <p>La respuesta es que es necesario que adquieran un cerrojo de lectura porque de lo contrario puede que cuando un hilo lea el recurso otro hilo est\u00e9 en medio de una operaci\u00f3n de actualizaci\u00f3n del recurso, y entonces el hilo que lee el recurso obtendr\u00eda un recurso inconsiste a medio actualizar.</p> <p>Por ejemplo, supongamos que el recurso es un producto y el hilo escritor est\u00e1 actualizando su nombre y su precio, para lo que usa un cerrojo de escritura. Si los hilos lectores no usaran un cerrojo de lectura, y simplemente accedieran al recurso, podr\u00eda ocurrir que recibieran una copia del producto en el que s\u00f3lo estuviera actualizado el nombre del producto pero no el precio, si da la casualidad de que dicha lectura se produce justo entre el momento en el que el hilo de escritura actualiza el nombre y el momento en el que actualiza el precio.</p> <p>ReentrantReadWriteLock</p> <p>Cerrojo que proporciona dos modos distintos de adquisici\u00f3n independientes, uno para lectura y otro para escritura</p> <p>Para estos casos concretos, la librer\u00eda de concurrencia de Java proporciona la interfaz <code>ReadWriteLock</code> y la clase <code>ReentrantReadWriteLock</code>, la \u00fanica que la implementa. La interfaz <code>ReadWriteLock</code> proporciona dos cerrojos <code>Lock</code> distintos, uno para operaciones de lectura y otro para operaciones de escritura.</p> <p>Cuando un hilo adquiere el cerrojo de lectura, ning\u00fan otro hilo puede adquirir el cerrojo de escritura, pero si que es posible que otros hilos adquieran tambi\u00e9n el cerrojo de lectura, y por tanto ejecuten operaciones de lectura simult\u00e1neamente.</p> <p> Figura 8 - Lectores en un ReadWriteLock</p> <p>Por otra parte, si un hilo adquiere el cerrojo de escritura, ning\u00fan otro hilo puede adquirir el cerrojo de escritura ni el de lectura.</p> <p> Figura 9 - Escritor en un ReadWriteLock</p> <p>Si hemos activado el modo justo, el comportamiento es algo m\u00e1s complejo:</p> <ul> <li>Si un hilo lector trata de adquirir el cerrojo de lectura (de forma no reentrante), ser\u00e1 bloqueado si el cerrojo de escritura ha sido adquirido o hay alg\u00fan hilo escritor m\u00e1s antiguo que \u00e9l esperando adquirirlo.</li> <li>Si un hilo escritor trata de adquirir el cerrojo de escritura (de forma no reentrante), ser\u00e1 bloqueado si el cerrojo de escritura o el cerrojo de lectura han sido adquiridos, o si hay alg\u00fan hilo esperando para adquirirlo. Debemos tener en cuenta que el m\u00e9todo <code>tryLock()</code> no respeta el modo justo, por lo que el hilo adquirir\u00eda el cerrojo si no ha sido adquirido, independientemente de que haya alg\u00fan hilo esperando.</li> </ul> <p>En teor\u00eda, el incremento de la concurrencia proporcionado por el uso de un cerrojo <code>ReadWriteLock</code> conllevar\u00e1 una mejora del rendimiento frente al uso de un simple cerrojo de exclusi\u00f3n mutua <code>Lock</code>. Sin embargo esto depender\u00e1 de la frecuencia con la que se producen acceso de lectura frente a los accesos de escritura, la duraci\u00f3n del acceso y el n\u00famero de accesos concurrentes, por lo que s\u00f3lo debemos usar cerrojos <code>ReadWriteLock</code> cuando se den las condiciones adecuadas.</p> <p>La interfaz <code>ReadWriteLock</code> proporciona dos m\u00e9todos, el m\u00e9todo <code>readLock()</code>, que retorna el objeto <code>Lock</code> correspondiente al cerrojo de lectura, y el m\u00e9todo <code>writeLock()</code>, que retorna el objeto <code>Lock</code> correspondiente al cerrojo de escritura.</p> <p>Una vez obtenido el objeto <code>Lock</code> deseado, podremos usar sobre \u00e9l los m\u00e9todos que ya estudiamos para adquirir o liberar el cerrojo, como <code>lock()</code>, <code>unlock()</code>, <code>tryLock()</code>, <code>lockInterruptibly()</code> y <code>newCondition()</code>.</p> <pre><code>Lock readLock = reentrantReadWriteLock.readLock();\nreadLock.lock();\ntry {\n    // Acceso s\u00f3lo para lectura.\n    // ...\n} finally {\n    readLock.unlock();    \n}\n</code></pre> <p>Warning</p> <p>Es responsabilidad del programador usar el cerrojo adecuado, lectura o escritura, dependiendo de las operaci\u00f3n que se quiera realizar</p> <p>Un aspecto muy importante es que es responsabilidad del programador asegurar el uso correcto de los cerrojos, realizando con ellos las operaciones para las que han sido dise\u00f1ados. Por ejemplo, cuando obtenemos un cerrojo de lectura, no deber\u00edamos modificar el valor de la variable o estructura de datos protegida, o de lo contrario podemos tener problemas de inconsistencia de datos.</p> <p>La clase principal que implementa la interfaz es <code>ReadWriteLock</code> es <code>ReentrantReadWriteLock</code>, que como su nombre indica implementa cerrojos de lectura y escritura reeentrantes, es decir que no es necesario readquirirlo si el hilo ya lo posee cuando llama a un determinado m\u00e9todo que lo requiere, incluso recursivamente. El constructor de la clase <code>ReentrantReadWriteLock(boolean)</code>puede recibir un valor booleano indicativo de si hay que activar el modo justo.</p> <p>El cerrojo de escritura de <code>ReentrantReadWriteLock</code> proporciona una implementaci\u00f3n del m\u00e9todo <code>newCondition()</code> similar a la de la clase <code>ReentrantLock</code>, por lo que podremos establecer condiciones para el cerrojo de escritura. Sin embargo, el cerrojo de lectura no permite el uso de objetos <code>Condition</code> y lanzar\u00e1 la excepci\u00f3n <code>UnsupportedOperationException</code> si llamamos a su m\u00e9todo <code>newCondition()</code> sobre \u00e9l.</p> <p>Otra posibilidad es la operaci\u00f3n conocida como degradado de cerrojo (lock downgrading), seg\u00fan la cu\u00e1l en un cerrojo <code>ReentrantReadWriteLock</code> podemos adquirir el cerrojo de escritura y, sin haberlo liberado a\u00fan expl\u00edcitamente, adquirir el cerrojo de lectura. Posteriormente, una vez adquirido el de lectura, podemos liberar el de escritura, leer el valor y finalmente liberar el de lectura. \u00bfQu\u00e9 conseguimos con esta operaci\u00f3n? Pasar de un cerrojo de escritura a uno de lectura sin tener que volver a competir por obtener el de lectura.</p> <pre><code>```java\n// Adquire write lock from the readWriteLock.\nLock lock = readWriteLock.writeLock();\nlock.lock();\ntry {\n    // Perform write operation.\n    // ...\n    // Adquire the read lock from the readWriteLock.\n    final readLock = readWriteLock.readLock();\n    readLock.lock();\n    try {\n        // Try to release write lock. From this moment on, other threads can read the resource.\n        lock.unlock();\n        // Perform read operation.\n        // ...\n    } finally {\n        // The lock to release eventually is the readLock\n        lock = readLock;\n    }\n} finally {\n    // Release the reaming lock.\n    lock.unlock();\n}\n```\n</code></pre> <p>Sin embargo la operaci\u00f3n contraria (lock upgrading) no est\u00e1 permitida, es decir, si obtenemos el cerrojo de lectura y despu\u00e9s queremos obtener el de escritura deberemos antes liberar expl\u00edcitamente el cerrojo de lectura, volviendo a competir para adquirir el de escritura.</p>"},{"location":"bloque_v/tema_22/page-9/#proyecto-readwritelock","title":"Proyecto ReadWriteLock","text":"<p>En este proyecto crearemos una aplicaci\u00f3n que simula la venta de un producto en una tienda online. Por un lado existir\u00e1n hilos clientes que consultar\u00e1n el precio del producto y por otra parte un hilo que representa la tienda vendedora que incrementa el precio del producto de vez en cuando. Usaremos la clase <code>ReentrantReadWriteLock</code> para permitir que varios hilos clientes consulten el precio a la vez.</p> MainProductClientShop <pre><code>import java.util.concurrent.TimeUnit;\n\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        Product product = new Product(100.00);\n        Thread[] clientThreads= new Thread[4];\n        for (int i = 0; i &lt; 4; i++) {\n            clientThreads[i] = new Thread(new Client(product), \"Client \" + i);\n        }\n        Thread shopThread = new Thread(new Shop(product), \"Shop\");\n        shopThread.start();\n        // Wait to start some clients.\n        TimeUnit.SECONDS.sleep(1);\n        for (int i = 0; i &lt; 2; i++){\n            clientThreads[i].start();\n        }\n        // Wait to start the rest of the clients.\n        TimeUnit.SECONDS.sleep(3);\n        for (int i = 2; i &lt; 4; i++){\n            clientThreads[i].start();\n        }\n        // Try to check a client thread blocks the shop thread but not other clients threads.\n        // Try to check the shop thread blocks client threads.\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class Product {\n\n    private double price;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n    private final ReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();\n    private final Lock readLock = reentrantReadWriteLock.readLock();\n    private final Lock writeLock = reentrantReadWriteLock.writeLock();\n\n    public Product(double initialPrice) {\n        this.price = initialPrice;\n    }\n\n    public double getPrice() throws InterruptedException {\n        readLock.lock();\n        try {\n            return consultPrice();\n        } finally {\n            readLock.unlock();\n        }\n    }\n\n    private double consultPrice() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s - Consulting price...\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName());\n        TimeUnit.SECONDS.sleep(3);\n        System.out.printf(\"%s -&gt; %s - Price: %.2f\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName(),\n                price);\n        return price;\n    }\n\n    public void updatePrice(double increment) throws InterruptedException {\n        writeLock.lock();\n        try {\n            incrementPrice(increment);\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    private void incrementPrice(double increment) throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s - Updating price...\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName());\n            TimeUnit.SECONDS.sleep(1);\n        this.price += increment;\n        System.out.printf(\"%s -&gt; %s - New price: %.2f\\n\",\n                LocalTime.now().format(dateTimeFormatter),\n                Thread.currentThread().getName(),\n                this.price);\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\n\npublic class Client implements Runnable {\n\n    private final Product product;\n\n    public Client(Product product) {\n        Objects.requireNonNull(product);\n        this.product = product;\n    }\n\n    @Override\n    public void run() {\n        try {\n            @SuppressWarnings(\"unused\")\n            double price = product.getPrice();\n        } catch (InterruptedException e) {\n            System.out.println(\"I've been interrupted while consulting the price\");\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class Shop implements Runnable {\n\n    private final Product product;\n\n    public Shop(Product product) {\n        Objects.requireNonNull(product);\n        this.product = product;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 3; i++) {\n            try {\n                product.updatePrice(20.0);\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                System.out.println(\"I've been interrupted while updating the price\");\n                return;\n            }\n        }\n    }\n\n}\n</code></pre> <p>Si ejecutamos la aplicaci\u00f3n veremos que varios lectores pueden estar leyendo a la vez, pero s\u00f3lo uno puede estar escribiendo. Cambia los tiempos de los <code>sleep()</code> para tratar que un hilo cliente bloquee a un hilo tienda pero no a otros hilos cliente. Despu\u00e9s trata de que un hilo tienda bloquee a hilos clientes.</p>"},{"location":"bloque_v/tema_23/page-1/","title":"1 Barreras","text":""},{"location":"bloque_v/tema_23/page-1/#barreras","title":"Barreras","text":"<p>Todos los mecanismos vistos en el tema anterior correspond\u00edan a herramientas para asegurar la visibilidad (siempre se obtiene el valor actualizado) y la atomicidad (exclusi\u00f3n mutua).</p> <p>Barrera</p> <p>Elemento que permite sincronizar la ejecuci\u00f3n de varios hilos en uno o varios puntos</p> <p>Sin embargo, en este tema vamos a ver herramientas que no se usan para proteger el acceso a un recurso compartido o secci\u00f3n cr\u00edtica, sino para sincronizar la ejecuci\u00f3n de varios hilos en uno o varios puntos. Estas herramientas son conocidas como barreras (barriers).</p> <p>En un tema anterior, ya vimos una herramienta de este tipo, el m\u00e9todo <code>join()</code> de la clase <code>Thread</code>, pero dicho m\u00e9todo proporciona \u00fanicamente sincronizaci\u00f3n final, es decir sincronizarse con el momento en que otro hilo termina de ejecutarse. No permite realizar una sincronizaci\u00f3n inicial, es decir, que ambos hilos se sincronicen para empezar a trabajar, ni una sincronizaci\u00f3n en punto intermedio de ejecuci\u00f3n de ambos hilos, ni una sincronizaci\u00f3n por fases con varios puntos de sincronizaci\u00f3n.</p> <p>Para solucionar este problema, el paquete <code>java.util.concurrent</code> proporciona varias clases que permiten llevar a cabo distintos de tipos de sincronizaci\u00f3n.</p>"},{"location":"bloque_v/tema_23/page-2/","title":"2 CountDownLatch","text":""},{"location":"bloque_v/tema_23/page-2/#countdownlatch","title":"CountDownLatch","text":"<p>La API de concurrencia de Java nos proporciona la clase <code>CountDownLatch</code>, que permite a uno o m\u00e1s hilos esperar hasta que un conjunto de operaciones son ejecutadas.</p> <p>CountDownLatch</p> <p>Barrera de sincronizaci\u00f3n basada en el valor de un contador no reutilizable</p> <p>El constructor de esta clase recibe un par\u00e1metro entero que indica el n\u00famero de operaciones que los hilos deber\u00e1n esperar antes de poder continuar su ejecuci\u00f3n. Se trata, por tanto, de un sistema de control de avance (pestillo) que s\u00f3lo se abre cuando su cuenta atr\u00e1s es 0.</p> <p>Cuando un hilo ejecuta el m\u00e9todo <code>await()</code> de un objeto de esta clase, el hilo se suspende hasta que sean completadas el n\u00famero de operaciones indicadas al crear el objeto <code>CountDownLatch</code>.</p> <p> Figura 1 - CountDownLatch</p> <p>El m\u00e9todo <code>await(timeout, timeUnit)</code> est\u00e1 sobrecargado de manera que le podemos pasar el tiempo m\u00e1ximo que el hilo estar\u00e1 esperando a que finalice la cuenta atr\u00e1s del objeto <code>CountDownLatch</code>, transcurrido el cual ser\u00e1 reactivado y continuar\u00e1 su ejecuci\u00f3n aunque la cuenta atr\u00e1s no haya llegado a <code>0</code>, retornando el valor <code>false</code>. Si el contador interno llega al valor <code>0</code> el m\u00e9todo retornar\u00e1 el valor <code>true</code>.</p> <p>Como la mayor\u00eda de los m\u00e9todos bloqueantes, <code>await()</code> y <code>await(timeout, timeUnit)</code> lanzar\u00e1n la excepci\u00f3n <code>InterruptedException</code> si el hilo es interrumpido mientras estaba esperando en dichos m\u00e9todos para poder avanzar, o si ya hab\u00eda sido marcado para interrupci\u00f3n antes de ejecutarlos, reactivando inmediatamente el hilo correspondiente.</p> <p>Cada vez que termina la ejecuci\u00f3n de una de las operaciones gestionadas que afecten a la cuenta atr\u00e1s del <code>CountDownLatch</code>, debe llamarse al m\u00e9todo <code>countDown()</code> del mismo, que decrementa el contador interno del pestillo en una unidad. Cuando este contador llega a 0, la clase reactiva todos los hilos que estuvieran suspendidos por el m\u00e9todo <code>await()</code> o <code>await(timeout, timeUnit)</code>, que contin\u00faan su ejecuci\u00f3n.</p> <p>Debemos tener en cuenta que un hilo puede gestionar m\u00e1s de una operaci\u00f3n que afecte a la cuenta atr\u00e1s del <code>CountDownLatch</code> y por tanto llamar a su m\u00e9todo <code>countDown()</code> m\u00e1s de una vez. Podr\u00edamos por tanto decir que un <code>CountDownLatch</code> no sincroniza hilos en un determinado punto de ejecuci\u00f3n, sino que bloquea el avance de hilos hasta que ocurra un determinado n\u00famero de eventos, independientemente de en qu\u00e9 hilos se generen dichos eventos.</p> <p>No hay ninguna manera de reinicializar el contador interno del objeto <code>CountDownLatch</code> o de modificar directamente su valor. Una vez que el contador se inicializa al crear el objeto, el \u00fanico m\u00e9todo que modifica su valor es <code>countDown()</code>, como vimos en el p\u00e1rrafo anterior. Si que tenemos un m\u00e9todo informativo, <code>getCount()</code> que retorna el valor actual del contador interno del <code>CountDownLatch</code>.</p> <p>El objeto <code>CountDownLatch</code> admite un \u00fanico uso. Una vez que el contador interno llega a 0 todas las llamadas a sus m\u00e9todos no tienen efecto alguno, de manera que los hilos que los llaman contin\u00faan su ejecuci\u00f3n normalmente. Se tendr\u00eda que crear un nuevo objeto de dicha clase para llevar a cabo la misma sincronizaci\u00f3n de nuevo. Se dice, por tanto, que los <code>CountDownLatch</code> no son c\u00edclicos, sino que son de un solo \"tiro\" (one-shot).</p> <p>Otro aspecto curioso es que la clase <code>CountDownLatch</code> no implementa ning\u00fan modo de justicia, y que no existe una versi\u00f3n de <code>await()</code> en la que no sea posible interrumpir al hilo.</p>"},{"location":"bloque_v/tema_23/page-2/#proyecto-countdownlatch","title":"Proyecto CountDownLatch","text":"<p>En este proyecto simularemos una reuni\u00f3n de delegaciones de pa\u00edses para la que cada pa\u00eds aporta un n\u00famero de participantes. La reuni\u00f3n no puede comenzar hasta que no haya un quorum de al menos 10 participantes, independiente de qu\u00e9 pa\u00eds procedan. Para controlar que la reuni\u00f3n no comienza hasta que no haya quorum usaremos una <code>CountDownLatch</code>. Una vez haya comenzado la reuni\u00f3n las delegaciones podr\u00e1n realizar propuestas para la misma.</p> MainMeetingCountry <pre><code>import java.util.concurrent.ThreadLocalRandom;\n\npublic class Main {\n\n    private static final int QUORUM = 10;\n\n    public static void main(String[] args) {\n        Meeting meeting = new Meeting(QUORUM);\n        new Thread(meeting).start();\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(new Country(\n                    ThreadLocalRandom.current().nextInt(5) + 1,\n                    meeting, \"Country #\" + i)).start();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.CountDownLatch;\n\npublic class Meeting implements Runnable {\n\n    private final CountDownLatch countDownLatch;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    public Meeting(int quorum) {\n        countDownLatch = new CountDownLatch(quorum);\n    }\n\n    @Override\n    public void run() {\n        System.out.printf(\"%s -&gt; Waiting for quorum to start the meeting\\n\",\n                LocalTime.now().format(dateTimeFormatter));\n        try {\n            countDownLatch.await();\n            System.out.printf(\"%s -&gt; We have quorum. Meeting started...\\n\",\n                    LocalTime.now().format(dateTimeFormatter));\n        } catch (InterruptedException e) {\n            System.out.println(\"Meeting has been interrupted while waiting to have quorum\");\n        }\n    }\n\n    public void join(int participants, String countryName) {\n        System.out.printf(\"%s -&gt; %d participants from %s have joined the meeting\\n\",\n                LocalTime.now().format(dateTimeFormatter), participants, countryName);\n        for (int i = 0; i &lt; participants; i++) {\n            countDownLatch.countDown();\n        }\n    }\n\n    public void propose(String countryName) {\n        System.out.printf(\"%s -&gt; Delegation from %s has made some proposals\\n\",\n                LocalTime.now().format(dateTimeFormatter), countryName);\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\npublic class Country implements Runnable {\n\n    private final int participants;\n    private final String countryName;\n    private final Meeting meeting;\n\n    public Country(int participants, Meeting meeting, String countryName) {\n        if (participants &lt; 1 || meeting == null || countryName == null) {\n            throw new IllegalArgumentException();\n        }\n        this.participants = participants;\n        this.countryName = countryName;\n        this.meeting = meeting;\n    }\n\n    @Override\n    public void run() {\n        try {\n            goToMeeting();\n        } catch (InterruptedException e) {\n            System.out.println(\"I've been interrupted while going to the meeting\");\n            return;\n        }\n        meeting.join(participants, countryName);\n        try {\n            makeProposals();\n        } catch (InterruptedException e) {\n            System.out.println(\"I've been interrupted while making proposals\");\n        }\n    }\n\n    private void goToMeeting() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5));\n    }\n\n    private void makeProposals() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(3));\n        meeting.propose(countryName);\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que hasta que no haya quorum no comenzar\u00e1 la reuni\u00f3n.</p>"},{"location":"bloque_v/tema_23/page-3/","title":"3 CyclicBarrier","text":""},{"location":"bloque_v/tema_23/page-3/#cyclicbarrier","title":"CyclicBarrier","text":"<p>La API de concurrencia de Java nos proporciona la clase <code>CyclicBarrier</code>, que permite la sincronizaci\u00f3n de un n\u00famero fijo de dos o m\u00e1s hilos que deben esperarse unos a los otros en un determinado punto de sincronizaci\u00f3n com\u00fan antes de continuar su ejecuci\u00f3n. La barrera (barrier) no dejar\u00e1 avanzar a los hilos que lleguen a un determinado punto de sincronizaci\u00f3n hasta que todos hayan llegado a dicho punto.</p> <p>CyclicBarrier</p> <p>Barrera de sincronizaci\u00f3n de un n\u00famero predeterminado de hilos, que se reinicia autom\u00e1ticamente</p> <p>La gran ventaja de <code>CyclicBarrier</code> es que puede usar tanto una sincronizaci\u00f3n inicial como para una intermedia o una final.</p> <p> Figura 2 - Barrera</p> <p>El constructor de esta clase recibe un par\u00e1metro entero que indica el n\u00famero de hilos que ser\u00e1n sincronizados (denominado internamente parties). Si pasamos un valor negativo para dicho par\u00e1metro se lanzar\u00e1 la excepci\u00f3n <code>IllegalArgumentException</code>.</p> <p>Un objeto <code>CyclicBarrier</code> posee un contador interno para controlar cu\u00e1ntos hilos han llegado al punto de sincronizaci\u00f3n. Cuando uno de estos hilos llega al punto establecido, llama al m\u00e9todo <code>await()</code> para esperar al resto de los hilos, de manera que queda suspendido.</p> <p>El m\u00e9todo <code>await(timeout, timeUnit)</code> est\u00e1 sobrecargado de manera que recibe un tiempo m\u00e1ximo de espera, transcurrido el cu\u00e1l el hilo es reactivado autom\u00e1ticamente y se lanza la excepci\u00f3n <code>TimeoutException</code>. Si el <code>timeout</code> pasado al m\u00e9todo es menor o igual que 0, el hilo no esperar\u00e1.</p> <p>Tanto <code>await()</code> como <code>await(timeout, timeUnit)</code> retornan el orden en el que el hilo ha llegado a la barrera, donde el primer en llegar recibe el valor <code>participantes - 1</code> y el \u00faltimo en llegar recibe el valor <code>0</code>.</p> <p>Cuando el \u00faltimo de los hilos llama al m\u00e9todo <code>await()</code> del objeto <code>CyclicBarrier</code>, es decir, cuando el contador interno llega a <code>0</code>, se dice que se \"abre la barrera\" y el resto de hilos que estaban esperando en la misma son reactivados y contin\u00faan su ejecuci\u00f3n.</p> <p> Figura 3 - CyclicBarrier</p> <p>Como la mayor\u00eda de los m\u00e9todos bloqueantes, <code>await()</code> y <code>await(timeout, timeUnit)</code> lanzan la excepci\u00f3n <code>InterruptedException</code> si el hilo es interrumpido mientras est\u00e1 esperando en la barrera o si ya hab\u00eda sido marcado para interrupci\u00f3n antes de llamar a estos m\u00e9todos, de manera que el hilo es reactivado inmediatamente.</p> <p>Pero entonces, \u00bfqu\u00e9 ocurre entonces con los otros hilos que estaban esperando en la barrera? Dado que un hilo ha sido interrumpido podemos afirmar que las condiciones que deb\u00edan de darse para permitir avanzar a los hilos no van a poder darse, porque el contador interno de la barrera no podr\u00e1 llegar a 0. En ese caso, podemos decir que la barrera \"se ha roto\", pasando a un estado interno conocido como broken.</p> <p>Igualmente, si en un hilo que est\u00e1 ejecutando el m\u00e9todo <code>await(timeout, timeUnit)</code> se lanza la excepci\u00f3n <code>TimeoutException</code> porque el hilo haya esperado \"demasiado\", la barrera quedar\u00e1 \"rota\".</p> <p>Cuando una barrera \"se rompe\" los hilos que estuvieran esperando en dicha barrera son reactivados autom\u00e1ticamente lanzando la excepci\u00f3n <code>BrokenBarrierException</code>. Podemos saber si una barrera est\u00e1 rota llamando al m\u00e9todo <code>isBroken()</code>.</p> <p>Si un hilo llama al m\u00e9todo <code>await()</code> o <code>await(timeout, timeUnit)</code> una vez que la barrera ha sido marcada como rota, el hilo no ser\u00e1 bloqueado y se lanzar\u00e1 directamente la excepci\u00f3n <code>BrokenBarrierException</code>.</p> <p>Un aspecto interesante de la clase <code>CyclicBarrier</code> es que su constructor puede recibir un par\u00e1metro adicional consistente en un objeto <code>Runnable</code> que ser\u00e1 ejecutado autom\u00e1ticamente cuando el \u00faltimo de los hilos participantes haya indicado que han llegado a la barrera ejecutando el m\u00e9todo <code>await()</code> o <code>await(timeout, timeUnit)</code>. La tarea representada por el <code>Runnable</code> ser\u00e1 ejecutada en dicho hilo antes reactivar a los hilos que estaban esperando en la barrera para que contin\u00faen con su ejecuci\u00f3n. Suele emplearse para actualizar un estado com\u00fan a todos los hilos antes de que estos puedan continuar su ejecuci\u00f3n.</p> <p>Si se produjera una excepci\u00f3n no gestionada en el objeto <code>Runnable</code> la excepci\u00f3n ser\u00e1 propagada a dicho hilo y la barrera pasar\u00e1 al estado de rota, lanzando la excepci\u00f3n <code>BrokenBarrierException</code> en el resto de hilos que estaban esperando en la barrera.</p> <p>Debemos tener en cuenta que un objeto <code>CyclicBarrier</code> corresponde, como su nombre indica, a una barrera c\u00edclica. Esto quiere decir, que el contador interno es reseteado autom\u00e1ticamente a su valor inicial cuando todos los hilos participantes llegan a punto de sincronizaci\u00f3n y llaman al m\u00e9todo <code>await()</code> o <code>await(timeout, timeUnit)</code>, siempre y cuando la barrera no se encuentre o pase al estado de rota. Por tanto podremos reutilizar el mismo objeto <code>CyclicBarrier</code> para volver a sincronizar m\u00e1s adelante a los mismos hilos en un punto de sincronizaci\u00f3n posterior.</p> <p>En algunas ocasiones complejas es necesario reiniciar el proceso de sincronizaci\u00f3n de la barrera como si nada hubiera ocurrido. Para ello se necesita resetear expl\u00edcitamente el contador interno de la barrera a su valor inicial, para lo que podemos usar el m\u00e9todo <code>reset()</code>. Debemos tener en cuenta que en cuanto un hilo llama al m\u00e9todo <code>reset()</code> de la barrera los hilos que estuvieran esperando en la misma ser\u00e1n reactivados inmediatamente y se lanzar\u00e1 en ellos la excepci\u00f3n <code>BrokenBarrierException</code>. En general la operaci\u00f3n de reseteo puede ser compleja de gestionar por lo que puede resultar m\u00e1s conveniente simplemente crear un nuevo objeto <code>CyclicBarrier</code>.</p> <p>El objeto <code>CyclicBarrier</code> presenta una serie de diferencias importantes respecto a <code>CountDownLatch</code>:</p> <ul> <li><code>CyclicBarrier</code> sincroniza hilos en un determinado punto de ejecuci\u00f3n, mientras <code>CountDownLatch</code> bloquea el avance de hilos hasta que ocurra un determinado n\u00famero de eventos, independientemente de en qu\u00e9 hilos se generen dichos eventos. Dicho de manera sencilla, cada hilo participante en un <code>CyclicBarrier</code> s\u00f3lo puede aportar un \u00fanico evento (y no varios).</li> <li>Una <code>CyclicBarrier</code> es por definici\u00f3n c\u00edclica, mientras que un <code>CountDownLatch</code> no puede ser reutilizado para una segunda sincronizaci\u00f3n una vez que su contador interno llega a <code>0</code>.</li> <li>Podemos resetear expl\u00edcitamente una <code>CyclicBarrier</code>, mientras que los <code>CountDownLatch</code> no pueden ser reseteados.</li> </ul> <p>Otra caracter\u00edstica importante de la clase <code>CyclicBarrier</code> es que no se permite incrementar o decrementar din\u00e1micamente el n\u00famero de hilos que deben sincronizarse en la barrera, sino que la barrera siempre funcionar\u00e1 con el n\u00famero de hilos que le hayamos indicado en el constructor.</p> <p>La clase <code>CyclicBarrier</code> posee tambi\u00e9n una serie de m\u00e9todos informativos sobre el estado de la barrera, como:</p> <ul> <li><code>getNumberWaiting()</code>: Retorna el n\u00famero de hilos que est\u00e1n suspendidos en la barrera.</li> <li><code>getParties()</code>: Retorna el n\u00famero de hilos participantes que van a ser sincronizados en la barrera.</li> </ul>"},{"location":"bloque_v/tema_23/page-3/#proyecto-cyclicbarrier","title":"Proyecto CyclicBarrier","text":"<p>En este proyecto desarrollaremos una aplicaci\u00f3n que simula tres amigos que quedan en un bar para tomar dos cervezas. Como son bueno amigos, ninguno de ellos empieza a beber la primera cerveza hasta que todos han llegado al bar. De igual forma, hasta que todos no se han bebido la primera cerveza, ninguno comienza a beberse la segunda cerveza. Finalmente, cuando todos han terminado la segunda cerveza, los amigos se van cada uno a su casa. Para llevar a cabo la sincronizaci\u00f3n entre los amigos usaremos un objeto <code>CyclicBarrier</code> y lo configuraremos de manera que cada vez que los amigos dejen de esperarse se lance un mensaje de cambio de actividad.</p> MainFriendOpenedBarrierAction <pre><code>import java.util.concurrent.CyclicBarrier;\n\npublic class Main {\n\n    private static final int NUMBER_OF_FRIENDS = 3;\n\n    public static void main(String[] args) {\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(NUMBER_OF_FRIENDS,\n                new OpenedBarrierAction());\n        for (int i = 0; i &lt; NUMBER_OF_FRIENDS; i++) {\n            new Thread(new Friend(\"Friend #\" + i, cyclicBarrier), \"Friend #\" + i).start();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Objects;\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\npublic class Friend implements Runnable {\n\n    private final String name;\n    private final CyclicBarrier cyclicBarrier;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    public Friend(String name, CyclicBarrier cyclicBarrier) {\n        Objects.requireNonNull(name);\n        Objects.requireNonNull(cyclicBarrier);\n        this.name = name;\n        this.cyclicBarrier = cyclicBarrier;\n    }\n\n    @Override\n    public void run() {\n        try {\n            goToPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while going to the pub\\n\", name);\n            return;\n        }\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while waiting for friends in the pub\\n\", name);\n            return;\n        } catch (BrokenBarrierException e) {\n            System.out.printf(\"%s doesn't wait any more for friends in the pub because someone isn't coming\\n\", name);\n        }\n        try {\n            firstBeerInPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while drinking the first beer\\n\", name);\n            return;\n        }\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while waiting for friends to finish their fist beer\\n\", name);\n            return;\n        } catch (BrokenBarrierException e) {\n            System.out.printf(\"%s doesn't wait any more for friends to finish their first beer because someone isn't going to finish it\\n\", name);\n        }\n        try {\n            secondBeerInPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while drinking the second beer\\n\", name);\n            return;\n        }\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while waiting for friends to finish their second beer\\n\", name);\n            return;\n        } catch (BrokenBarrierException e) {\n            System.out.printf(\"%s doesn't wait any more for friends to finish their second beer because someone isn't going to finish it\\n\", name);\n        }\n        try {\n            goHome();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while going back home\\n\", name);\n        }\n    }\n\n    private void goToPub() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s is leaving home\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has arrived in the pub\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void firstBeerInPub() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has finished the first beer\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void secondBeerInPub() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has finished the first beer\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void goHome() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s is leaving the pub\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s is at home\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Locale;\n\npublic class OpenedBarrierAction implements Runnable {\n\n    private final DateTimeFormatter dateTimeFormatter =\n            DateTimeFormatter.ofPattern(\"HH:mm:ss\", Locale.getDefault());\n\n    @Override\n    public void run() {\n        System.out.printf(\"%s -&gt; Phase change (executed in %s)\\n\",\n                LocalTime.now().format(dateTimeFormatter), Thread.currentThread().getName());\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que unos amigos se esperan a los otros.</p>"},{"location":"bloque_v/tema_23/page-4/","title":"4 Phaser","text":""},{"location":"bloque_v/tema_23/page-4/#phaser","title":"Phaser","text":"<p>Una de las funcionalidades m\u00e1s potentes de la API de concurrencia de Java es la posibilidad de ejecutar tareas concurrentes que se sincronicen en distintas fases, para lo que utiliza la clase <code>Phaser</code> (secuenciador por fases).</p> <p>Phaser</p> <p>Barrera de sincronizaci\u00f3n de un n\u00famero variable de hilos que se reinicia autom\u00e1ticamente</p> <p>Este mecanismo es \u00fatil cuando las tareas concurrentes se dividen en varias fases (pasos o etapas). La clase <code>Phaser</code> nos proporciona el mecanismo para sincronizar los hilos al final de cada fase, de manera que ning\u00fan hilo comienza una nueva fase hasta que todos los hilos hayan concluido la fase anterior.</p> <p>Internamente, un objeto <code>Phaser</code> mantiene cuatro datos muy importantes para su funcionamiento:</p> <ul> <li>phase: N\u00famero de fase en el que se encuentra. Inicialmente vale 0.</li> <li>registered parties: N\u00famero de participantes registrados para participar en la siguiente fase.</li> <li>unarrived: N\u00famero de participantes que a\u00fan no han concluido la fase actual. Al comenzar una fase se reinicializa su valor al correspondiente a registered parties.</li> <li>terminated: Indicador booleano de si el proceso de sincronizaci\u00f3n a trav\u00e9s del Phaser se puede considerar como terminado o no. Su valor inicial es false.</li> </ul> <p>A diferencia de con otros tipos de barreras, como <code>CyclicBarrier</code>, el n\u00famero de hilos participantes en una sincronizaci\u00f3n con <code>Phaser</code> puede variar durante el proceso de sincronizaci\u00f3n.</p> <p>Para indicar el n\u00famero inicial de hilos participantes registrados podemos pasar un valor entero al constructor <code>Phaser(parties)</code> de la clase <code>Phaser</code>. Si le pasamos un valor negativo se lanzar\u00e1 la excepci\u00f3n <code>IllegalArgumentException</code>. Dicho valor ser\u00e1 establecido como valor inicial de unarrived y de registered parties.</p> <p>Si usamos el constructor vac\u00edo <code>Phaser()</code>, el valor de unarrived y de registered parties ser\u00e1 inicializado a 0.</p> <p>A diferencia de los <code>CyclicBarrier</code>, los propios hilos pueden registrarse como participantes en la sincronizaci\u00f3n, para lo que llamar\u00e1n al m\u00e9todo <code>register()</code>, que registra un nuevo participante en la fase actual, o al m\u00e9todo <code>bulkRegister(parties)</code>, que registra el n\u00famero de hilos indicados como participantes de la fase actual. Estos m\u00e9todos retornan el n\u00famero de fase en el que se han registrado (el valor actual de phase).</p> <p>En ambos casos, los hilos registrados son contabilizados como hilos que a\u00fan no han concluido la fase actual, incrementando el valor de unarrived, y como hilos registrados para la pr\u00f3xima fase, incrementando el valor de registered parties.</p> <p>Si el proceso de sincronizaci\u00f3n ya ha sido marcada como terminado para cuando el hilo se registra, es decir, si el valor de terminated es true para cuando un hilo llama a <code>register()</code> o <code>bulkRegister(parties)</code>, estos m\u00e9todos no tendr\u00e1n ning\u00fan efecto sobre los hilos ni sobre el <code>Phaser</code>, y retornar\u00e1n un valor negativo como n\u00famero de fase.</p> <p>Si un hilo trata de registrarse justo en el momento de un cambio de fase, es decir, como veremos m\u00e1s adelante, mientras se est\u00e1 ejecutando el m\u00e9todo <code>onAdvance()</code> del <code>Phaser</code>, el registro de los nuevos hilo esperar\u00e1 hasta que dicho m\u00e9todo concluya su ejecuci\u00f3n, registrando a los hilos como participantes de la nueva fase.</p> <p>El hecho de que los propios hilos puedan registrarse en el proceso de sincronizaci\u00f3n otorga una flexibilidad adicional que no posee CyclicBarrier. Gracias a ello, si usamos Phaser no tenemos por qu\u00e9 saber de antemano el n\u00famero de hilos a sincronizar, ya que cada uno de ellos puede registrarse personalmente, algo que no era posible en el caso de CyclicBarrier.</p> <p>Cada vez que un hilo concluye una fase debe informar de ello al <code>Phaser</code>. Dicha operaci\u00f3n se denomina arrive. Por otra parte, si queremos que el hilo espere a que el resto de hilos concluya la fase actual del <code>Phaser</code> deber\u00e1 de comunic\u00e1rselo expresamente a trav\u00e9s de una operaci\u00f3n conocida como await advance. Esta es otra de las diferencias principales respecto a otro tipos de barreras, en las que ambas operaciones, la indicaci\u00f3n de haber llegado a la barrera y la operaci\u00f3n de esperar al resto de hilos que deben llegar a la barrera correspond\u00eda a una \u00fanica operaci\u00f3n indivisible, como en el caso del m\u00e9todo <code>await()</code> de <code>CyclicBarrier</code>.</p> <p>La clase <code>Phaser</code> nos ofrece distintos m\u00e9todos para llevar a cabo las operaciones arrive y await advance. El primero de ellos es el m\u00e9todo <code>arrive()</code>, mediante el que un hilo informa al <code>Phaser</code> de que ha concluido la fase actual del mismo, sin ponerse a esperar a que el resto de hilos lo haga. Como consecuencia el <code>Phaser</code> decrementar\u00e1 el valor de unarrived. Este m\u00e9todo retorna la fase actual del <code>Phaser</code> a la que el hilo ha llegado, o un valor negativo si el <code>Phaser</code> ya ha sido marcado como terminado, es decir, si terminated es true.</p> <p>Gracias a esta separaci\u00f3n entre las operaciones arrive y await advance, el n\u00famero de participantes no tiene por qu\u00e9 corresponder obligatoriamente con el n\u00famero de hilos a sincronizar, aunque lo habitual es que coincidan.</p> <p>Como complemento a <code>arrive()</code>, tenemos el m\u00e9todo <code>awaitAdvance(phase)</code>, que permite al hilo indicar que desea esperar a que los hilos concluyan la fase pasada como argumento, es decir, a que el valor de unarrived sea 0. Si el <code>Phaser</code> no se encuentra en ese momento en dicha fase, o ya ha sido marcado como terminado (terminated es true), el m\u00e9todo no bloquear\u00e1 al hilo que lo ejecuta, retornando inmediatamente.</p> <p>El valor proporcionado como argumento a <code>awaitAdvance(phase)</code> provendr\u00e1 normalmente del valor retornado por una llamada anterior al m\u00e9todo <code>arrive()</code>. De hecho, si queremos realizar ambas operaciones arrive y await advance seguidas una detr\u00e1s de la otra har\u00edamos <code>awaitAdvance(arrive())</code>.</p> <p>Como esta opci\u00f3n de hacer ambas operaciones una seguida de la otra es la m\u00e1s habitual, la clase <code>Phaser</code> proporciona un m\u00e9todo para ejecutarlas con una \u00fanica llamada, a trav\u00e9s del m\u00e9todo <code>arriveAndAwaitAdvance()</code>, que informa de que el hilo la concluido la fase actual del <code>Phaser</code> (arrive), decrementando unarrived, y lo suspende hasta que todos los hilos participantes en dicha fase de la sincronizaci\u00f3n hayan informado de que la han concluido (awaitAdvance). Como vemos, el funcionamiento del m\u00e9todo <code>arriveAndAwaitAdvance()</code> es similar al del m\u00e9todo <code>await()</code> de un <code>CyclicBarrier</code>.</p> <p>Otra opci\u00f3n disponible para los hilos es indicar que se ha concluido la fase actual y que ya no se quiere participar en el resto de fases de la sincronizaci\u00f3n, por lo que ni siquiera va a esperar al resto de hilos. Para ello har\u00e1 uso del m\u00e9todo <code>arriveAndDeregister()</code>, que decrementa el valor de unarrived y adem\u00e1s hace que en las siguientes fases de la sincronizaci\u00f3n haya un participante menos, decrementando el valor de registered parties.</p> <p>Este m\u00e9todo es usado habitualmente por el hilo que controla la inicializaci\u00f3n del Phaser, por ejemplo el hilo principal, que desea coordinador el inicio del proceso de ejecuci\u00f3n de los otros hilos, como veremos m\u00e1s adelante en un ejemplo en el que se usa el Phaser como barrera inicial.</p> <p>Es importante que cuando un hilo ya no quiera participar en las siguientes fases de la sincronizaci\u00f3n haga <code>arriveAndDeregister()</code> ya que si tan s\u00f3lo hace <code>arrive()</code> no decrementar\u00e1 registered parties, afectando al correcto funcionamiento del <code>Phaser</code> y del resto de hilos que contin\u00faen en la sincronizaci\u00f3n, que estar\u00e1n esperando a que dicho hilo haga el arrive en la fase siguiente para poder continuar.</p> <p> Figura 4 - Phaser</p> <p>Los m\u00e9todos <code>arrive()</code>, <code>awaitAdvance()</code>, <code>arriveAndAwaitAdvance()</code> y <code>arriveAndDeregister()</code> no se ven afectados por el hecho de que el hilo ya estuviera marcado para interrupci\u00f3n.</p> <p>Adem\u00e1s, los m\u00e9todos <code>arriveAndAwaitAdvance()</code> y <code>awaitAdvance()</code> ni siquiera se ven afectados por el hecho de que el hilo sea interrumpido mientras est\u00e1 esperando a que el resto de hilos concluyan la fase actual del <code>Phaser</code>. Si queremos que se lance la interrupci\u00f3n <code>InterruptedException</code> en este caso, deberemos usar el m\u00e9todo <code>awaitAdvanceInterruptibly(phase)</code> o la versi\u00f3n con timeout explicado en el siguiente p\u00e1rrafo.</p> <p>El m\u00e9todo <code>awaitAdvanceInterruptibly(phase, timeout, timeUnit)</code> se encuentra sobrecargado para indicar un tiempo m\u00e1ximo que deseamos que el hilo sea suspendido en espera de que el resto de hilos concluyan la fase actual del <code>Phaser</code>, transcurrido el cu\u00e1l se lanzar\u00e1 la excepci\u00f3n <code>TimeoutException</code> y el hilo ser\u00e1 reactivado inmediatamente.</p> <p>A diferencia de en el caso de <code>CyclicBarrier</code>, en el que la generaci\u00f3n de la excepci\u00f3n <code>InterruptedException</code> o de <code>TimeoutException</code> en el m\u00e9todo <code>await()</code> produc\u00eda que la barrera fuera marcada como rota, la generaci\u00f3n de la excepci\u00f3n <code>InterruptedException</code> en los m\u00e9todos anteriores del <code>Phaser</code> no produce ning\u00fan cambio de estado en el mismo.</p> <p>Todos los m\u00e9todos vistos con anterioridad para realizar las operaciones de arrive y await advance retornan el n\u00famero de fase en el que se encuentra el <code>Phaser</code> cuando se llaman, o un valor negativo si la sincronizaci\u00f3n ya hab\u00eda concluido para cuando se llama a estos m\u00e9todos, es decir, cuando el <code>Phaser</code> ya hab\u00eda sido marcado como terminado.</p> <p>Cuando el hecho de que un hilo ejecute la operaci\u00f3n arrive hace el valor de unarrived pase a ser 0, se considera que la fase actual ha concluido, y en dicho hilo se ejecuta el m\u00e9todo <code>onAdvance(phase, registeredParties)</code> del <code>Phaser</code>, que recibe el n\u00famero de fase que se acaba de concluir y el n\u00famero de hilos que est\u00e1n registrados para la pr\u00f3xima fase. Al cambiar de fase, unarrived se reinicializa al valor de registered parties y el valor de phase es incrementado en una unidad.</p> <p>El m\u00e9todo <code>onAdvance()</code> debe retornar un valor booleano indicativo de si el proceso de sincronizaci\u00f3n o ha concluido o no y por tanto si el <code>Phaser</code> debe ser marcado como terminado, activando el valor terminated. La implementaci\u00f3n por defecto de este m\u00e9todo retornar\u00e1 <code>false</code>, a no ser que el n\u00famero de participantes registrados para la nueva fase sea <code>0</code>:</p> <pre><code>// Default implementation of onAdvance\nprotected boolean onAdvance(int phase, int registeredParties) {\n    return registeredParties == 0;\n}\n</code></pre> <p>Si se produce una excepci\u00f3n en este m\u00e9todo, dicha excepci\u00f3n ser\u00e1 propagada al hilo que propici\u00f3 su ejecuci\u00f3n al concluir la fase y el <code>Phaser</code> no avanzar\u00e1 a la siguiente fase.</p> <p>Para saber si un <code>Phaser</code> ha sido marcado como terminado podemos usar el m\u00e9todo <code>isTerminated()</code>. Si queremos forzar el marcado como terminado del <code>Phaser</code> podemos usar su m\u00e9todo <code>forceTermination()</code>, que establece el valor true en terminated, independientemente del n\u00famero de participantes que hayan ejecutado el m\u00e9todo <code>arriveAndDeregister()</code>, o de que hayamos sobrescrito el m\u00e9todo <code>onAdvance()</code>. Si hab\u00eda hilos esperando que otros finalizaran la fase actual, son reactivados.</p> <p>Cuando un objeto <code>Phaser</code> entra en este estado de terminaci\u00f3n, es decir cuando terminated es true, los m\u00e9todos relacionados con la operaci\u00f3n await advance retornan un valor negativo, en vez del valor positivo correspondiente al n\u00famero de fase actual que retornan habitualmente, algo que deberemos comprobar cuando el objeto <code>Phaser</code> pueda ser terminado abruptamente.</p> <p>La clase <code>Phaser</code> define adem\u00e1s una serie de m\u00e9todos informativos que nos permiten hacer un seguimiento del estado del mismo:</p> <ul> <li><code>getPhase()</code>: Retorna la fase en la que se encuentra el <code>Phaser</code>.</li> <li><code>getRegisteredParties()</code>: Retorna el n\u00famero de participantes registrados en la fase actual del <code>Phaser</code>.</li> <li><code>getArrivedParties()</code>: Retorna el n\u00famero de participantes que han concluido la fase actual del <code>Phaser</code>.</li> <li><code>getUnarrivedParties()</code>: Retorna el n\u00famero de participantes registrados que no han concluido a\u00fan la fase actual del <code>Phaser</code>.</li> </ul> <p>Veamos distintos casos de uso de <code>Phaser</code>.</p>"},{"location":"bloque_v/tema_23/page-4/#phaser-como-barrera-de-sincronizacion","title":"Phaser como barrera de sincronizaci\u00f3n","text":"<pre><code>void runTasks(List&lt;Runnable&gt; tasks) {\n    // The thread than calls runTasks creates the Phaser and registers itself.\n    final Phaser phaser = new Phaser(1);\n    // Create and starts the tasks\n    for (final Runnable task : tasks) {\n        // Register the task. It must be done before running the tasks, so they\n        // can wait each other.\n        phaser.register();\n        new Thread() {\n            public void run() {\n                // The first thing each task does is awaiting creation of all tasks.\n                phaser.arriveAndAwaitAdvance();\n                task.run();\n            }\n        }.start();\n    }\n    // After registering the task the thread that calls runTasks can continue\n    // without any later synchronization\n    phaser.arriveAndDeregister();\n}\n</code></pre> <p>Como vemos el c\u00f3digo anterior es bastante parecido al funcionamiento de una CyclicBarrier que act\u00fae como barrera inicial. Sin embargo el uso de Phaser lo hace m\u00e1s flexible, porque no tenemos por qu\u00e9 saber de antemano el n\u00famero de hilos a sincronizar, ya que cada uno de ellos puede registrarse, algo que no era posible en el caso de CyclicBarrier.</p>"},{"location":"bloque_v/tema_23/page-4/#phaser-como-barrera-ciclica-con-un-numero-de-ciclos","title":"Phaser como barrera c\u00edclica con un n\u00famero de ciclos","text":"<pre><code>void startTasks(List&lt;Runnable&gt; tasks, final int iterations) {\n    // The thread that calls startTasks creates and custom phaser is marked\n    // as terminated when the number of iterations is done or no\n    // parties are registered.\n    final Phaser phaser = new Phaser() {\n        protected boolean onAdvance(int phase, int registeredParties) {\n            return phase &gt;= iterations || registeredParties == 0;\n        }\n    };\n    // The thread that calls startTasks register itself and each task before\n    // stating them\n    phaser.register();\n    for (final Runnable task : tasks) {\n        phaser.register();\n        new Thread() {\n            public void run() {\n                do {\n                    // Each task runs and then await to the rest to advance\n                    // to the next iteration until the phaser is terminated.\n                    task.run();\n                    phaser.arriveAndAwaitAdvance();\n                } while (!phaser.isTerminated());\n            }\n        }.start();\n    }\n    // The thread that calls startTasks can continue without any later synchronization\n    phaser.arriveAndDeregister();\n }\n</code></pre>"},{"location":"bloque_v/tema_23/page-4/#proyecto-phaser","title":"Proyecto Phaser","text":"<p>En este proyecto desarrollaremos una aplicaci\u00f3n que simula una conjunto de amigos que han quedado para tomar unas cervezas en un pub. El plan consiste en salir de casa y quedar en el pub, esperando a que lleguen todos los amigos para tomar la primera cerveza. Cuando todos hayan terminado de beber la primera cerveza, se tomar\u00e1n una segunda cerveza, y cuando todos se la hayan tomado, se despedir\u00e1n y se ir\u00e1n a casa.</p> <p>En esta demo tendremos diferentes tipos de amigos:</p> <ul> <li>Tres amigos que realizan al completo todas las fases cumpliendo con las esperas de rigor (friend #0, #1 y #2, representados por la clase Friend).</li> <li>Un amigo impaciente que realizar al completo todas la fases pero que no piensa esperar a nadie (friend #3, representado por la clase ImpacientFriend).</li> <li>Un amigo que s\u00f3lo se tomar\u00e1 una cerveza, pero que esperar\u00e1 a los amigos en el pub y esperar\u00e1 a que se terminen la primera cerveza antes de irse a casa (friend #4, representado por la clase OneBeerFriend).</li> <li>Un amigo que va a unirse m\u00e1s tarde, y que se tomar\u00e1 las cervezas que pueda dependiendo que cuando haya informado a los amigos de su incorporaci\u00f3n. Los amigos respetuosos lo esperar\u00e1n en la fase en la que se encuentren (friend #5, representado por la clase TardyFriend).</li> <li>Un amigo que para cuando trata de unirse es demasiado tarde porque el resto de amigos ya no est\u00e1n tomando cervezas (friend #6, representado tambi\u00e9n por la clase TardyFriend, pero que ser\u00e1 lanzado mucho m\u00e1s tarde, cuando el phaser ya se encuentre terminado).</li> </ul> <p>Para la sincronizaci\u00f3n se crear\u00e1 una clase que extienda de <code>Phaser</code> en la que sobrescribiremos el m\u00e9todo <code>onAdvance()</code> para mostrar mensajes personalizados cuando se cambie de fase, y que de por terminada la secuenciaci\u00f3n cuando los amigos se terminen la segunda cerveza.</p> MainFriendPhaserFriendImpatientFriendOneBeerFriendTardyFriend <pre><code>import java.util.concurrent.TimeUnit;\n\npublic class Main {\n\n    private static final int NORMAL_FRIENDS = 3;\n\n    public static void main(String[] args) throws InterruptedException {\n        int i;\n        FriendsPhaser phaser = new FriendsPhaser();\n        for (i = 0; i &lt; NORMAL_FRIENDS; i++) {\n            new Thread(new Friend(\"Friend #\" + i, phaser), \"Friend #\" + i).start();\n        }\n        // This friend won't wait for anybody.\n        new Thread(new ImpacientFriend(\"Friend #\" + i, phaser), \"Friend #\" + i).start();\n        i++;\n        // This friend will drink just one beer and will go home.\n        new Thread(new OneBeerFriend(\"Friend #\" + i, phaser), \"Friend #\" + i).start();\n        i++;\n        // This friend will join be late, maybe when other friends are drinking.\n        TimeUnit.SECONDS.sleep(9);\n        new Thread(new TardyFriend(\"Friend #\" + i, phaser), \"Friend #\" + i).start();\n        i++;\n        // This friend will join very very late.\n        TimeUnit.SECONDS.sleep(12);\n        new Thread(new TardyFriend(\"Friend #\" + i, phaser), \"Friend #\" + i).start();\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.Phaser;\n\npublic class FriendsPhaser extends Phaser {\n\n    public static final int ARRIVE_TO_PUB_PHASE = 0;\n    public static final int FINISH_FIST_BEER_PHASE = 1;\n    public static final int FINISH_SECOND_BEER_PHASE = 2;\n\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    @Override\n    protected boolean onAdvance(int phase, int registeredParties) {\n        switch (phase) {\n            case ARRIVE_TO_PUB_PHASE:\n                System.out.printf(\"%s -&gt; All %d friends arrived to pub (executed in %s)\\n\",\n                        LocalTime.now().format(dateTimeFormatter), registeredParties,\n                        Thread.currentThread().getName());\n                break;\n            case FINISH_FIST_BEER_PHASE:\n                System.out.printf(\"%s -&gt; All %d friends finished their first beer (executed in %s)\\n\",\n                        LocalTime.now().format(dateTimeFormatter), registeredParties,\n                        Thread.currentThread().getName());\n                break;\n            case FINISH_SECOND_BEER_PHASE:\n                System.out.printf(\"%s -&gt; All %d friends finished their second beer (executed in %s)\\n\",\n                        LocalTime.now().format(dateTimeFormatter), registeredParties,\n                        Thread.currentThread().getName());\n                // The phaser is marked as terminated.\n                return true;\n        }\n        return super.onAdvance(phase, registeredParties);\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Objects;\nimport java.util.concurrent.Phaser;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\npublic class Friend implements Runnable {\n\n    private final String name;\n    private final Phaser phaser;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    public Friend(String name, Phaser phaser) {\n        Objects.requireNonNull(name);\n        Objects.requireNonNull(phaser);\n        this.name = name;\n        this.phaser = phaser;\n    }\n\n    @Override\n    public void run() {\n        phaser.register();\n        try {\n            goToPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while going to the pub\\n\", name);\n            return;\n        }\n        try {\n            phaser.awaitAdvanceInterruptibly(phaser.arrive());\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while waiting for friends in the pub\\n\", name);\n            return;\n        }\n        try {\n            firstBeerInPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while drinking the first beer\\n\", name);\n            return;\n        }\n        try {\n            phaser.awaitAdvanceInterruptibly(phaser.arrive());\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while waiting for friends to finish their fist beer\\n\", name);\n            return;\n        }\n        try {\n            secondBeerInPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while drinking the second beer\\n\", name);\n            return;\n        }\n        try {\n            phaser.awaitAdvanceInterruptibly(phaser.arrive());\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while waiting for friends to finish their second beer\\n\", name);\n            return;\n        }\n        try {\n            goHome();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while going back home\\n\", name);\n        }\n    }\n\n    private void goToPub() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s is leaving home\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has arrived in the pub\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void firstBeerInPub() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has finished the first beer\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void secondBeerInPub() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has finished the second beer\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void goHome() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s is leaving the pub\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s is at home\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Objects;\nimport java.util.concurrent.Phaser;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\npublic class ImpacientFriend implements Runnable {\n\n    private final String name;\n    private final Phaser phaser;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    public ImpacientFriend(String name, Phaser phaser) {\n        Objects.requireNonNull(name);\n        Objects.requireNonNull(phaser);\n        this.name = name;\n        this.phaser = phaser;\n    }\n\n    @Override\n    public void run() {\n        phaser.register();\n        try {\n            goToPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while going to the pub\\n\", name);\n            return;\n        }\n        phaser.arriveAndDeregister();\n        try {\n            firstBeerInPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while drinking the first beer\\n\", name);\n            return;\n        }\n        try {\n            secondBeerInPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while drinking the second beer\\n\", name);\n            return;\n        }\n        try {\n            goHome();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while going back home\\n\", name);\n        }\n    }\n\n    private void goToPub() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s is leaving home\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has arrived in the pub\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void firstBeerInPub() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has finished the first beer\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void secondBeerInPub() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has finished the second beer\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void goHome() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s is leaving the pub\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s is at home\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Objects;\nimport java.util.concurrent.Phaser;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\npublic class OneBeerFriend implements Runnable {\n\n    private final String name;\n    private final Phaser phaser;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    public OneBeerFriend(String name, Phaser phaser) {\n        Objects.requireNonNull(name);\n        Objects.requireNonNull(phaser);\n        this.name = name;\n        this.phaser = phaser;\n    }\n\n    @Override\n    public void run() {\n        phaser.register();\n        try {\n            goToPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while going to the pub\\n\", name);\n            return;\n        }\n        try {\n            phaser.awaitAdvanceInterruptibly(phaser.arrive());\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while waiting for friends in the pub\\n\", name);\n            return;\n        }\n        try {\n            firstBeerInPub();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while drinking the first beer\\n\", name);\n            return;\n        }\n        try {\n            phaser.awaitAdvanceInterruptibly(phaser.arrive());\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while waiting for friends to finish their fist beer\\n\", name);\n            return;\n        }\n        // No more beers.\n        phaser.arriveAndDeregister();\n        try {\n            goHome();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s has been interrupted while going back home\\n\", name);\n        }\n    }\n\n    private void goToPub() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s is leaving home\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has arrived in the pub\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void firstBeerInPub() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has finished the first beer\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void goHome() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s is leaving the pub\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s is at home\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Objects;\nimport java.util.concurrent.Phaser;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\npublic class TardyFriend implements Runnable {\n\n    private final String name;\n    private final Phaser phaser;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    public TardyFriend(String name, Phaser phaser) {\n        Objects.requireNonNull(name);\n        Objects.requireNonNull(phaser);\n        this.name = name;\n        this.phaser = phaser;\n    }\n\n    @Override\n    public void run() {\n        if (!phaser.isTerminated()) {\n            int joinPhase = phaser.register();\n            System.out.printf(\"%s -&gt; %s has joined friends in phase #%d\\n\",\n                    LocalTime.now().format(dateTimeFormatter), name, joinPhase);\n            try {\n                goToPub();\n            } catch (InterruptedException e) {\n                System.out.printf(\"%s has been interrupted while going to the pub\\n\", name);\n                return;\n            }\n            // Tardy friends shouln't do arrive on previous phases in order not to\n            // interfere with the synchonization process or the current phase of the\n            // phaser.\n            if (joinPhase &lt;= FriendsPhaser.ARRIVE_TO_PUB_PHASE) {\n                try {\n                    phaser.awaitAdvanceInterruptibly(phaser.arrive());\n                } catch (InterruptedException e) {\n                    System.out.printf(\"%s has been interrupted while waiting for friends in the pub\\n\", name);\n                    return;\n                }\n            }\n            try {\n                firstBeerInPub();\n            } catch (InterruptedException e) {\n                System.out.printf(\"%s has been interrupted while drinking the first beer\\n\", name);\n                return;\n            }\n            if (joinPhase &lt;= FriendsPhaser.FINISH_FIST_BEER_PHASE) {\n                try {\n                    phaser.awaitAdvanceInterruptibly(phaser.arrive());\n                } catch (InterruptedException e) {\n                    System.out.printf(\"%s has been interrupted while waiting for friends to finish their fist beer\\n\", name);\n                    return;\n                }\n            }\n            try {\n                secondBeerInPub();\n            } catch (InterruptedException e) {\n                System.out.printf(\"%s has been interrupted while drinking the second beer\\n\", name);\n                return;\n            }\n            if (joinPhase &lt;= FriendsPhaser.FINISH_SECOND_BEER_PHASE) {\n                try {\n                    phaser.awaitAdvanceInterruptibly(phaser.arrive());\n                } catch (InterruptedException e) {\n                    System.out.printf(\"%s has been interrupted while waiting for friends to finish their second beer\\n\", name);\n                    return;\n                }\n            }\n            try {\n                goHome();\n            } catch (InterruptedException e) {\n                System.out.printf(\"%s has been interrupted while going back home\\n\", name);\n            }\n        } else {\n            System.out.printf(\"%s -&gt; %s called his friends too late\\n\",\n                    LocalTime.now().format(dateTimeFormatter), name);\n        }\n    }\n\n    private void goToPub() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s is leaving home\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has arrived in the pub\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void firstBeerInPub() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has finished the first beer\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void secondBeerInPub() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s has finished the second beer\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    private void goHome() throws InterruptedException {\n        System.out.printf(\"%s -&gt; %s is leaving the pub\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        System.out.printf(\"%s -&gt; %s is at home\\n\",\n                LocalTime.now().format(dateTimeFormatter), name);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private void awaitPhase(Phaser phaser, int currentPhase, int expectedPhase) {\n        while (currentPhase &lt; expectedPhase &amp;&amp; !phaser.isTerminated()) {\n            System.out.printf(\"%s -&gt; %s is waiting phase #%d to finish\\n\",\n                    LocalTime.now().format(dateTimeFormatter), name, currentPhase);\n            currentPhase = phaser.arriveAndAwaitAdvance();\n        }\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos el comportamiento de los distintos tipos de amigos respecto al phaser.</p>"},{"location":"bloque_v/tema_23/page-5/","title":"5 Exchanger","text":""},{"location":"bloque_v/tema_23/page-5/#exchanger","title":"Exchanger","text":"<p>La API de concurrencia de Java nos proporciona un tipo adicional de barrera, a trav\u00e9s de la clase <code>Exchanger&lt;T&gt;</code> (intercambiador), que permite definir un punto de sincronizaci\u00f3n entre dos hilos de manera que el primero de los dos en llegar es bloqueado en espera del otro, de manera que cuando ambos llegan a dicho punto se sincronizaci\u00f3n intercambian entre ellos un determinado objeto de tipo <code>T</code>.</p> <p>Exchanger</p> <p>Barrera de sincronizaci\u00f3n entre dos hilos para el intercambio de una estructura de datos</p> <p>Ambos hilos tendr\u00e1n definido un objeto del tipo <code>T</code> cuyas direcciones de memoria ser\u00e1n intercambiadas al llegar al punto de sincronizaci\u00f3n.</p> <p>Para poder llevar a cabo el intercambio ambos hilos deben compartir el objeto <code>Exchanger&lt;T&gt;</code> y tener definido un objeto propio del tipo <code>T</code>. Al llegar al punto de sincronizaci\u00f3n, cada hilo llamar\u00e1 al m\u00e9todo <code>exchange(T_object)</code> del objeto <code>Exchanger</code> pas\u00e1ndole el objeto <code>T</code> que aporta al intercambio. Si el otro hilo a\u00fan no ha llegado al punto de sincronizaci\u00f3n el hilo es suspendido hasta que el otro hilo ejecute el mismo m\u00e9todo. Cuando ambos hilos hayan llamado al m\u00e9todo <code>exchange(T_object)</code>, el hilo que estuviera esperando (el primero que lleg\u00f3) ser\u00e1 reactivado y el otro ni siquiera ser\u00e1 bloqueado, y como valor de retorno de la llamada a <code>exchange(T_object)</code>, cada hilo recibir\u00e1 el objeto proporcionando por el otro hilo, que normalmente asignar\u00e1 a la variable que albergaba su objeto. De esta manera, ambos hilos pueden continuar su ejecuci\u00f3n, pero ahora su objeto en realidad corresponde al que conten\u00eda el otro hilo antes del intercambio.</p> <p>El m\u00e9todo <code>exchange(T_object, timeout, timeUnit)</code> est\u00e1 sobrecargado de manera que recibe un tiempo m\u00e1ximo de espera, transcurrido el cu\u00e1l el hilo es reactivado autom\u00e1ticamente y se lanza la excepci\u00f3n <code>TimeoutException</code>. Si el <code>timeout</code> pasado al m\u00e9todo es menor o igual que 0, el hilo no esperar\u00e1.</p> <p>Como la mayor\u00eda de los m\u00e9todos bloqueantes, <code>exchange(T_object)</code> y <code>exchange(T_object, timeout, timeUnit)</code> lanzar\u00e1n la excepci\u00f3n <code>InterruptedException</code> si el hilo es interrumpido mientras estaba esperando en dichos m\u00e9todos, o si ya hab\u00eda sido marcado para interrupci\u00f3n antes de ejecutarlos, reactivando inmediatamente el hilo correspondiente.</p> <p> Figura  - Exchanger</p> <p>Esta clase puede ser muy \u00fatil en problemas parecidos al del productor-consumidor, aunque con la limitaci\u00f3n de poder sincronizar un \u00fanico productor y un \u00fanico consumidor, dado que la clase <code>Exchanger&lt;T&gt;</code> s\u00f3lo funciona entre dos hilos.</p>"},{"location":"bloque_v/tema_23/page-5/#proyecto-exchanger","title":"Proyecto Exchanger","text":"<p>En este proyecto desarrollaremos una aplicaci\u00f3n para simular el problema del productor-consumidor con un solo productor y un solo consumidor, que intercambiar\u00e1n el buffer de datos una vez \u00e9ste se haya llenado, para lo que har\u00e1 uso de la clase <code>Exchanger</code>.</p> MainDoughnutProducerDoughnutConsumer <pre><code>import java.util.List;\nimport java.util.concurrent.Exchanger;\n\npublic class Main {\n\n    public static final int BUFFER_SIZE = 10;\n\n    public static void main(String[] args) {\n        Exchanger&lt;List&lt;Integer&gt;&gt; exchanger = new Exchanger&lt;&gt;();\n        Thread doughnutProducerThread = new Thread(new DoughnutProducer(exchanger), \n                                                \"Doughnut producer\");\n        Thread doughnutConsumerThread = new Thread(new DoughnutConsumer(exchanger), \n                                                \"Doughnut consumer\");\n        doughnutProducerThread.start();\n        doughnutConsumerThread.start();\n    }\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.Exchanger;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class DoughnutProducer implements Runnable {\n\n    private final Exchanger&lt;List&lt;Integer&gt;&gt; exchanger;\n    private List&lt;Integer&gt; buffer = new ArrayList&lt;&gt;();\n    private int doughnutNumber;\n\n    public DoughnutProducer(Exchanger&lt;List&lt;Integer&gt;&gt; exchanger) {\n        Objects.requireNonNull(exchanger);\n        this.exchanger = exchanger;\n    }\n\n    @Override\n    public void run() {\n        Integer doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            // Fill the buffer and then exchange.\n            for (int i = 0; i &lt; Main.BUFFER_SIZE; i++){\n                try {\n                    doughnut = makeDoughnut();\n                } catch (InterruptedException e) {\n                    System.out.println(\n                        \"Producer has been interrupted while making a doughnut\");\n                    return;\n                }\n                System.out.printf(\"Producer has made doughnut #%d\\n\", doughnut);\n                buffer.add(doughnut);\n            }\n            System.out.println(\"Producer ready for exchange\");\n            try {\n                buffer = exchanger.exchange(buffer, 20, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                System.out.println(\n                    \"Producer has been interrupted while exchanging buffer\");\n                return;\n            } catch (TimeoutException e) {\n                System.out.println(\"Producer can't wait for the consumer anymore\");\n                return;\n            }\n        }\n        System.out.println(\"Producer has been interrupted\");\n    }\n\n    private int makeDoughnut() throws InterruptedException {\n        int doughnut = ++doughnutNumber;\n        TimeUnit.SECONDS.sleep(1);\n        return doughnut;\n    }\n\n}\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.Exchanger;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class DoughnutConsumer implements Runnable {\n\n    private final Exchanger&lt;List&lt;Integer&gt;&gt; exchanger;\n    private List&lt;Integer&gt; buffer = new ArrayList&lt;&gt;();\n\n    public DoughnutConsumer(Exchanger&lt;List&lt;Integer&gt;&gt; exchanger) {\n        Objects.requireNonNull(exchanger);\n        this.exchanger = exchanger;\n    }\n\n    @Override\n    public void run() {\n        Integer doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            // Exchage the empty buffer for a full one and then consume it.\n            System.out.println(\"Consumer ready for exchange\");\n            try {\n                buffer = exchanger.exchange(buffer, 20, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                System.out.println(\n                    \"Consumer has been interrupted while exchanging buffer\");\n                return;\n            } catch (TimeoutException e) {\n                System.out.println(\"Consumer can't wait for the producer anymore\");\n                return;\n            }\n            for (int i = 0; i &lt; Main.BUFFER_SIZE; i++){\n                doughnut = buffer.remove(0);\n                try {\n                    eat(doughnut);\n                } catch (InterruptedException e) {\n                    System.out.println(\"Consumer has been interrupted while eating\");\n                    return;\n                }\n            }\n        }\n        System.out.println(\"Consumer has been interrupted\");\n    }\n\n    private void eat(int doughnut) throws InterruptedException {\n        System.out.printf(\"Consumer is eating doughnut #%d\\n\", doughnut);\n        TimeUnit.MILLISECONDS.sleep(500);\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_23/page-6/","title":"Ejercicios","text":"Proyecto CountDownLatch <p>Seis alumnos de un instituto quieren comprarle un regalo a su profesor para el final de curso. Han elegido por mayor\u00eda absoluta, que uno de ellos ser\u00e1 el que recoja el dinero. A este alumno se la ha denominado como hermano mayor, y recoger\u00e1 el dinero hasta completarlo, luego ir\u00e1 a comprar el regalo.</p> <p>El regalo a comprar tiene un costo de $10, y cada alumno deber\u00e1 poner entre $2 y $5 y tardar\u00e1 entre 3 y 10 segundo en pagarlo.</p> <p>Realiza una aplicaci\u00f3n de Java haciendo uso de la clase <code>CountDownLatch</code> y mostrando mensajes en cada instante.</p> Proyecto CyclicBarrier <p>Diez amigos deciden ir el fin de semana a realizar una ruta de ciclismo siguiendo las siguientes etapas:</p> <ol> <li>En primer lugar, salen de casan y van hacia la gasolinera. El amigo m\u00e1s cercano est\u00e1 a un segundo y el m\u00e1s lejano a 3.</li> <li>Una vez lleguen a la gasolinera, comienza la etapa, que dura entre 5 y 10 segundos. Cuando finalizan la etapa llegan a un bar para poder refrescarse.</li> <li>Una vez que se refrescan, deciden volver a la gasolinera (tardan el mismo tiempo).</li> <li>Por \u00faltimo, deciden volver a casa.</li> </ol> <p>Ten en cuenta, que no todos los amigos ciclistas tardan el mismo tiempo en realizar las etapas, por lo que si hay alguno que se adelante debe esperar al resto. Crea una simulaci\u00f3n mostrando mensajes de informaci\u00f3n en cada etapa haciendo uso de <code>CyclicBarrier</code>.</p> Proyecto Phaser <p>Realiza el mismo ejercicio anterior, teniendo en cuenta lo siguiente: </p> <ul> <li>10 amigos realizan todas las fases, esperando a que el resto las realice.</li> <li>Hay un amigo impaciente, que no esperar\u00e1 al resto de amigos.</li> <li>Hay un amigo, que llega tarde y que intentar\u00e1 ponerse a la altura de sus amigos, realizando las etapas sin necesidad de esperar si \u00e9stos ya lo han realizado,</li> <li>Por \u00faltimo, hay un amigo que llega cuando todos los dem\u00e1s est\u00e1n terminando las etapas</li> </ul> <p>Crea una simulaci\u00f3n, pero en est\u00e1 ocasi\u00f3n haciendo uso de <code>Phaser</code>.</p>"},{"location":"bloque_v/tema_24/page-1/","title":"1 Paquete atomic","text":""},{"location":"bloque_v/tema_24/page-1/#paquete-javautilconcurrentatomic","title":"Paquete java.util.concurrent.atomic","text":"<p>En un tema anterior vimos que si tenemos una variable que puede ser le\u00edda y escrita desde distintos hilos deberemos incorporar alg\u00fan mecanismo que asegure la exclusi\u00f3n mutua, como <code>synchronize</code> o <code>ReentrantLock</code>. El simple hecho de poder incrementar una variable entera desde distintos hilos ya nos obliga a incorporar alguno de estos mecanismos.</p> <p>Sin embargo, debemos tener en cuenta que el empleo de estas herramientas de sincronizaci\u00f3n implica una ralentizaci\u00f3n del tiempo de ejecuci\u00f3n de nuestro c\u00f3digo, debido al tiempo empleado por estas herramientas para asegurar la integridad.</p> <p>Con objeto de solucionar este problema es casos tan simples como el descrito anteriormente, Java 5 incorpor\u00f3 el paquete <code>java.util.concurrent.atomic</code>, que incluye clases wrapper (envoltura) que permiten mantener la integridad de un determinado tipo de dato sin tener que usar sincronizaci\u00f3n.</p> <p>Para que estas clases puedan asegurar la integridad hacen uso de una operaci\u00f3n a bajo nivel proporcionada por el procesador denominado compare and swap, o tambi\u00e9n compare and set (CAS), que recibe el valor que se espera que tenga actualmente una variable y el nuevo valor que se le pretende asignar, y s\u00f3lo se realiza la asignaci\u00f3n si el valor que se espera que tenga actualmente es realmente el que contiene.</p> <p>Esta t\u00e9cnica es \u00fatil es operaciones del tipo check then act (comprobar y luego actuar). El problema de este tipo de operaciones en programas multihilo es que debemos asegurar que desde que se comprueba hasta que se act\u00faa no ha cambiado el valor.</p> <p>Veamos un ejemplo de operaci\u00f3n que puede dar problemas en programas multihilo:</p> <pre><code>public class Count {\n\n    private volatile long count = 0;\n\n    public void increment() {\n       count++;\n    }\n\n}\n</code></pre> <p>Para asegurar la atomicidad de la operaci\u00f3n de incremento podemos usar, por ejemplo <code>synchronized</code>:</p> <pre><code>public class Count {\n\n    // No hace falta definirla volatile porque synchronized asegura tambi\u00e9n la\n    // visibilidad.\n    private long count = 0;\n\n    public synchronized void increment() {\n       count++;\n    }\n\n}\n</code></pre> <p>Sin embargo, tenemos una manera m\u00e1s \u00f3ptima de asegurar la atomicidad del incremento sin tener que usar alg\u00fan mecanismo de sincronizaci\u00f3n. La soluci\u00f3n consiste en usar una de las clases incluidas en el paquete <code>java.util.concurrent.atomic</code>, en este caso <code>AtomicLong</code>. Esta clase envuelve un valor entero proporcionando la funcionalidad del mantenimiento de la integridad mediante el empleo de la operaci\u00f3n de bajo nivel compare and swap del procesador. As\u00ed, modificaremos nuestro c\u00f3digo de la siguiente manera:</p> <pre><code>public class Count {\n\n    // No hace falta definirla volatile porque AtomicInteger usa internamente\n    // una variable volatile.\n    private AtomicLong count = new AtomicLong(0);\n\n    public void increment() {\n       count.incrementAndGet();\n    }\n\n}\n</code></pre> <p>La operaci\u00f3n compare and swap (CAS) es optimista, en el sentido de que se obtiene el valor y luego trata de actualizarla. Si al ir a actualizarla se detecta que el valor existente es igual que el valor que hab\u00eda sido obtenido, entonces simplemente se actualiza, sin que haya sido necesario llevar a cabo ning\u00fan tipo de sincronizaci\u00f3n. Si, por el contrario para cuando se va a realizar la actualizaci\u00f3n se detecta que el valor actual es distinto al que hab\u00eda sido obtenido, es porque en el periodo de tiempo desde que se obtuvo el valor hasta que se trata de actualizar otro hilo ha cambiado el valor de la variable. En ese caso, no se realiza la actualizaci\u00f3n, sino que se vuelve a iniciar el proceso de nuevo, es decir obtener el valor y tratar de actualizar (espera activa, busy wait). En alg\u00fan instante futuro no muy lejano la operaci\u00f3n compare and swap podr\u00e1 ser realizada, y no habr\u00e1 sido necesario usar ning\u00fan tipo de sincronizaci\u00f3n.</p> <p>Para comprender la t\u00e9cnica descrita anteriormente, veamos el c\u00f3digo interno del m\u00e9todo <code>incrementAndGet()</code>:</p> <pre><code>public final long incrementAndGet() {\n    for (;;) {\n        long current = get();\n        // Dangerous zone\n        long next = current + 1;\n        // End of dangerous zone\n        if (compareAndSet(current, next))\n          return next;\n    }\n}\n</code></pre> <p>En Java 8 el c\u00f3digo anterior se ha cambiado por una versi\u00f3n m\u00e1s reducida (pero el funcionamiento es el mismo):</p> <pre><code>public final long incrementAndGet() {\n    return unsafe.getAndAddLong(this, valueOffset, 1L) + 1L;\n}\n</code></pre> <p>En realidad el c\u00f3digo anterior es convertido a una \u00fanica instrucci\u00f3n m\u00e1quina que en el caso de la arquitectura de procesadores x86 corresponde a <code>LOCK XADD</code>, que proporciona un mejor rendimiento que el cl\u00e1sico bucle CAS.</p>"},{"location":"bloque_v/tema_24/page-2/","title":"2 Variables at\u00f3micas","text":""},{"location":"bloque_v/tema_24/page-2/#variables-atomicas","title":"Variables at\u00f3micas","text":"<p>Java proporciona clases wrappers at\u00f3micas para los tipos m\u00e1s habituales, como <code>AtomicInteger</code>, <code>AtomicLong</code> y <code>AtomicBoolean</code>, junto con una versi\u00f3n para la referencia a cualquier variable, <code>AtomicReference</code>.</p> <p>Estas clases proporcionan m\u00e9todos espec\u00edficos para realizar operaciones b\u00e1sicas sobre las variables de manera at\u00f3mica, como:</p> <ul> <li><code>get()</code>: Obtiene el valor contenido en la variable, asegurando la visibilidad (volatile)</li> <li><code>set(newValue)</code>: Establece el valor de la variable, asegurando la visibilidad (volatile).</li> <li><code>getAndSet(newValue)</code>: Establece el valor de la variable, y retorna el valor antiguo, todo ello de manera at\u00f3mica.</li> <li><code>compareAndSet(expectedValue, newValue)</code>: Actualiza el valor de la variable a <code>newValue</code> s\u00f3lo si el valor actual corresponde a <code>expectedValue</code>, todo ello de manera at\u00f3mica. Retorna <code>true</code> si se ha realizado la actualizaci\u00f3n.</li> </ul> <p>Para las clases at\u00f3micas correspondientes a tipos num\u00e9ricos tendremos tambi\u00e9n disponibles adem\u00e1s operaciones at\u00f3micas de suma/resta, incremento y decremento:</p> <ul> <li><code>addAndGet(cantidad)</code>: Suma la cantidad indicada al valor de la variable, lo establece como nuevo valor de la misma y lo retorna, todo ello de forma at\u00f3mica.</li> <li><code>getAndAdd(cantidad)</code>: Suma la cantidad indicada al valor de la variable, lo establece como nuevo valor de la misma, pero retorna el valor que ten\u00eda la variable antes de la actualizaci\u00f3n, todo ello de forma at\u00f3mica.</li> <li><code>decrementAndGet()</code> y <code>getAndDecrement()</code>:</li> <li><code>incrementAndGet()</code> y <code>getAndIncrement()</code>:</li> </ul> <p>Adem\u00e1s, tambi\u00e9n proporciona clases wrappers at\u00f3micas para los tipos de arrays m\u00e1s habituales, como <code>AtomicIntegerArray</code>, <code>AtomicLongArray</code> y <code>AtomicReferenceArray</code>.</p> <p>Una de las operaciones t\u00edpicas del tipo check then act (comprobar y luego actuar) es cuando se quiere realizar una tarea una \u00fanica vez y para ello se utiliza variable booleana que act\u00faa como bandera (flag). Si el objeto que contiene la bandera es accedido para escritura desde varios hilos es posible que se produzcan condiciones de carrera (race conditions) seg\u00fan los cuales la tarea sea ejecutada m\u00e1s de una vez, porque se solapen la comprobaci\u00f3n del valor de la bandera desde dichos hilos antes de que cambien el valor de la misma. Para solucionar este problema podemos hacer que la bander sea una variable <code>AtomicBoolean</code>. Veamos un ejemplo:</p> <pre><code>public class Event&lt;T&gt; {\n\n    private T content;\n    private AtomicBoolean handled = new AtomicBoolean(false);\n\n    public Event(T content) {\n        this.content = content;    \n    }\n\n    // Retorna el contenido si a\u00fan no ha sido consumido, o null en caso contrario.\n    public T getContentIfNotHandled() {\n        if (handled.compareAndSet(false, true)) {\n            return content;\n        } else {\n            return null;\n        }\n    }\n\n}\n</code></pre> <p>Como vemos, la librer\u00eda de concurrencia de Java s\u00f3lo proporciona clases atomic para los tipos m\u00e1s frecuentes, pero carece de las clases <code>AtomicFloat</code> o <code>AtomicDouble</code>.</p> <p>Para esos casos podemos usar la clase <code>AtomicInteger</code> y a la hora de retornar o recibir los datos usar los m\u00e9todos <code>Float.floatToIntBits</code> y <code>Float.intBitsToFloat</code> o <code>Double.doubleToLongBits</code>y <code>Double.longBitsToDouble</code> para realizar las conversiones adecuadas (puede ver las clases correspondientes en el proyecto AtomicLong, aunque no se usan en \u00e9l, obtenidas de este enlace). Puede utilizar tambi\u00e9n las clases<code>DoubleAccumulator</code> o <code>DoubleAdder</code> que veremos en el siguiente apartado.</p>"},{"location":"bloque_v/tema_24/page-2/#proyecto-atomiclong","title":"Proyecto AtomicLong","text":"<p>En este proyecto simularemos el funcionamiento de una cuenta bancaria, en la que una empresa realiza abonos desde un hilo y el banco realiza cargos desde otro hilo. El saldo de la cuenta ser\u00e1 almacenado usando una variable at\u00f3mica.</p> MainAccountAccountConsumerAccountSaver <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        Account account = new Account(0);\n        // Show initial balance.\n        System.out.printf(\"%s -&gt; Initial balance: %d\u20ac\\n\",\n                LocalTime.now().format(dateTimeFormatter), account.getBalance());\n        // Start both saver and consumer threads. Both threads share the same account.\n        Thread saverThread = new Thread(new AccountSaver(account));\n        saverThread.start();\n        Thread consumerThread = new Thread(new AccountConsumer(account));\n        consumerThread.start();\n        // Wait for both threads to finish.\n        saverThread.join();\n        consumerThread.join();\n        // Show final balance.\n        System.out.printf(\"\\n%s -&gt; Final balance: %d\u20ac\\n\",\n                LocalTime.now().format(dateTimeFormatter), account.getBalance());\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.atomic.AtomicLong;\n\npublic class Account {\n\n    private final AtomicLong balance;\n\n    public Account(long initialBalance) {\n        balance = new AtomicLong(initialBalance);\n    }\n\n    public long getBalance() {\n        return balance.get();\n    }\n\n    public void deposit(long amount) {\n        balance.addAndGet(amount);\n    }\n\n    public void debit(long amount) {\n        balance.addAndGet(-amount);\n    }\n\n}\n</code></pre> <pre><code>public class AccountConsumer implements Runnable {\n\n    private final Account account;\n\n    public AccountConsumer(Account account) {\n        this.account = account;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 100000; i++) {\n            account.debit(5);\n        }\n    }\n\n}\n</code></pre> <pre><code>public class AccountSaver implements Runnable {\n\n    private final Account account;\n\n    public AccountSaver(Account account) {\n        this.account = account;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 100000; i++) {\n            account.deposit(10);\n        }\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_24/page-3/","title":"3 Acumuladores At\u00f3micos","text":""},{"location":"bloque_v/tema_24/page-3/#acumuladores-atomicos","title":"Acumuladores At\u00f3micos","text":"<p>Si tenemos muchos hilos actualizando simult\u00e1neamente una variable at\u00f3mica, el n\u00famero de fallos y reintentos que produce la t\u00e9cnica compare and swap es muy alto. Con objeto de minimizar el tiempo de ejecuci\u00f3n asociado a dichos reintentos, Java 8 introdujo clases espec\u00edficas para crear variables contadoras o acumuladoras thread-safe que internamente emplean t\u00e9cnicas de atomicidad distintas a las de las variables at\u00f3micas y que pueden proporcionar mejoras en el rendimiento respecto a ellas en determinadas situaciones como la descrita anteriormente.</p> <p>Acumulador at\u00f3mico</p> <p>Variable que no almacena un \u00fanico valor que se va modificando, sino una lista de celdas de acumulaci\u00f3n at\u00f3micas</p> <p>Estas clases no almacenan un \u00fanico valor que va modificando conforme se actualiza el valor del acumulador, sino que almacenan una lista de celdas de acumulaci\u00f3n at\u00f3micas en la que almacenan los valores acumulados.</p> <p>Al intentar acumular un valor en el acumulador, se busca alguna celda de acumulaci\u00f3n que no est\u00e9 siendo usada en ese momento y se realiza en ella la acumulaci\u00f3n.</p> <p>Cuando se quiere obtener el valor resultante se ejecuta una funci\u00f3n de acumulaci\u00f3n sobre los elementos de la lista de celdas para obtener el resultado de la acumulaci\u00f3n.</p> <p>Las clases incorporadas son:</p> <ul> <li><code>DoubleAccumulator</code>: Corresponde a uno o m\u00e1s valores que al aplicarles una determinada funci\u00f3n conforman un \u00fanico valor de tipo <code>Double</code>. La funci\u00f3n a utilizar debe implementar la interfaz funcional <code>DoubleBinaryOperator</code> y ser pasado al constructor del objeto <code>DoubleAccumulator</code>, que tambi\u00e9n recibir\u00e1 el valor inicial (llamado identity, identidad).</li> <li><code>DoubleAdder</code>: Corresponde a uno o m\u00e1s valores que sumados a partir del valor 0 conforman un \u00fanico valor de tipo <code>Double</code>. Es caso especial de <code>DoubleAccumulator</code> donde la funci\u00f3n de acumulaci\u00f3n corresponde a la suma y el valor inicial es 0, es decir, equivalente a <code>new DoubleAccumulator((x, y) -&gt; x + y, 0.0)</code></li> <li><code>LongAccumulator</code>: Similar a <code>DoubleAccumulator</code> pero para tipos <code>Long</code>.</li> <li><code>LongAdder</code>: Similar a <code>DoubleAdder</code> pero para tipos <code>Long</code>.</li> </ul> <p>Para acumular un nuevo valor a un objeto de alguna de estas clases usaremos el m\u00e9todo <code>accumulate(value)</code>. Para obtener el valor resultante de la acumulaci\u00f3n usaremos el m\u00e9todo <code>get()</code>, en <code>DoubleAccumulator</code> y <code>LongAccumulator</code>, o el m\u00e9todo <code>sum()</code> en <code>DoubleAdder</code> y <code>LongAdder</code>. Tambi\u00e9n tendremos disponibles m\u00e9todos <code>tipoValue()</code> para obtener el valor resultante en un tipo determinado, por ejemplo <code>intValue()</code> retornar\u00e1 el valor resultante de la acumulaci\u00f3n en forma de entero.</p> <p>Finalmente, mediante el m\u00e9todo <code>reset()</code> podemos resetear el valor del acumulador a la identidad (valor inicial).</p> <p>Se recomienda el empleo de estas clases respecto a las variables Atomic cuando la frecuencia de operaciones de acumulaci\u00f3n sea mucho mayor que el de operaciones de lectura del valor.</p>"},{"location":"bloque_v/tema_24/page-3/#proyecto-doubleadder","title":"Proyecto DoubleAdder","text":"<p>En este proyecto simularemos el funcionamiento de una cuenta bancaria, en la que una empresa realiza abonos desde un hilo y el banco realiza cargos desde otro hilo. El saldo de la cuenta ser\u00e1 almacenado usando una variable <code>DoubleAdder</code>.</p> MainAccountAccountConsumerAccountSaver <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        Account account = new Account(0);\n        // Show initial balance.\n        System.out.printf(\"%s -&gt; Initial balance: %d\u20ac\\n\",\n                LocalTime.now().format(dateTimeFormatter), account.getBalance());\n        // Start both saver and consumer threads. Both threads share the same account.\n        Thread saverThread = new Thread(new AccountSaver(account));\n        saverThread.start();\n        Thread consumerThread = new Thread(new AccountConsumer(account));\n        consumerThread.start();\n        // Wait for both threads to finish.\n        saverThread.join();\n        consumerThread.join();\n        // Show final balance.\n        System.out.printf(\"\\n%s -&gt; Final balance: %d\u20ac\\n\",\n                LocalTime.now().format(dateTimeFormatter), account.getBalance());\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.atomic.DoubleAdder;\n\npublic class Account {\n\n    private final DoubleAdder balance = new DoubleAdder();\n\n    public Account(double initialBalance) {\n        balance.add(initialBalance);\n    }\n\n    public double getBalance() {\n        return balance.doubleValue();\n    }\n\n    public void deposit(long amount) {\n        balance.add(amount);\n    }\n\n    public void debit(long amount) {\n        balance.add(-amount);\n    }\n\n}\n</code></pre> <pre><code>public class AccountConsumer implements Runnable {\n\n    private final Account account;\n\n    public AccountConsumer(Account account) {\n        this.account = account;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 100000; i++) {\n            account.debit(5);\n        }\n    }\n\n}\n</code></pre> <pre><code>public class AccountSaver implements Runnable {\n\n    private final Account account;\n\n    public AccountSaver(Account account) {\n        this.account = account;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 100000; i++) {\n            account.deposit(10);\n        }\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que siempre produce el resultado correcto.</p>"},{"location":"bloque_v/tema_24/page-4/","title":"4 VarHandle","text":""},{"location":"bloque_v/tema_24/page-4/#varhandle","title":"VarHandle","text":"<p>Java 9 incorpor\u00f3 la clase <code>VarHandle</code>, como una forma de almacenar una referencia tipada (con tipo) a un determinado atributo (est\u00e1tico o no) de una clase o un elemento de array, de manera que se puede acceder al valor de dicho atributo en un determinado objeto a trav\u00e9s del <code>VarHandle</code>. El objetivo de esta clase es proporcionar una funcionalidad de acceso equivalente a la de las variables at\u00f3micas en propiedades de objetos (campos, fields) y en elementos de arrays.</p> <p>VarHandle</p> <p>Referencia a una variable que permite acceder a ella con distintos m\u00e9todos de acceso</p> <p>La ventaja de este acceso referenciado es que podemos usar m\u00e9todos de nuestro <code>VarHandle</code> para acceder de diferentes formas al atributo referenciado de un determinado objeto, sin tener que usar ning\u00fan mecanismo de sincronizaci\u00f3n ni usar ning\u00fan wrapper al definir el atributo. As\u00ed tendremos diferentes modos de acceso: acceso normal de lectura y escritura, acceso vol\u00e1til de lectura y escritura y, el m\u00e1s interesante, acceso mediante CAS (compare and swap), mediante el cu\u00e1l podemos ofrecer una acceso thread-safe al valor de dicho atributo en cualquier objeto de la clase correspondiente.</p> <p>Hasta ahora esta opci\u00f3n de acceso thread-safe sin usar ning\u00fan mecanismo de sincronizaci\u00f3n s\u00f3lo estaba disponible a trav\u00e9s de la clases Atomic, Accumulator o Adder, que actuaban como wrappers de los tipos m\u00e1s b\u00e1sicos. Sin embargo, gracias a <code>VarHandle</code> podemos extender esta funcionalidad de acceso thread-safe a cualquier tipo de atributo, no s\u00f3lo a los de tipo primitivo b\u00e1sico.</p> <p>Por ejemplo, si tenemos definida una clase como la siguiente:</p> <pre><code>public class Account { \n\n    public double amount; \n\n    public Account() { \n        this.amount = 0; \n    } \n\n}\n</code></pre> <p>en el siguiente c\u00f3digo podemos ver c\u00f3mo obtener la referencia al atributo <code>amount</code> de dicha clase y almacenarla en un <code>VarHandle</code>, para posteriormente acceder de forma thread-safe al valor dicho atributo en un determinado objeto:</p> <pre><code>public class Incrementer implements Runnable { \n\n    private Account account; \n\n    public Incrementer(Account account) { \n        this.account = account;\n    }\n\n    @Override \n    public void run() {\n        VarHandle varHandle; \n        try {\n            // Se obtiene una referencia al atributo amount de la clase Account, que es\n            // de tipo double. La referencia es gen\u00e9rica a dicho atributo, y podremos usarla\n            // sobre cualquier objeto de la clase Account.\n            varHandle = MethodHandles.lookup().in(Account.class)\n                            .findVarHandle(Account.class, \"amount\", double.class); \n            // Se accede de forma thread-safe al atributo amount del objeto Account\n            // recibido en el contructor, en este caso para incrementar su valor.\n            for (int i = 0; i &lt; 10000; i++) { \n                varHandle.getAndAdd(account, 100); \n            } \n        } catch (NoSuchFieldException | IllegalAccessException e) { \n            // El atributo no existe en la clase Account o se ha producido un acceso ilegal.\n            e.printStackTrace(); \n        }\n    }\n\n}\n</code></pre> <p>Warning</p> <p>Este ejemplo podr\u00eda haber realizado definiendo el atributo <code>amount</code> como un <code>DoubleAdder</code>, pero lo hemos elegido para demostrar la clase <code>VarHandle</code> por su simplicidad.</p> <p>Si queremos acceder para lectura al atributo de una variable a trav\u00e9s de un <code>VarHandle</code> tenemos a nuestra disposici\u00f3n una serie de m\u00e9todos, entre los que destacamos:</p> <ul> <li><code>get(object)</code>: Lee el valor del atributo de <code>object</code> referenciado por el <code>VarHandle</code>, como si el atributo hubiera sido definido como no vol\u00e1til (sin la palabra reservada <code>volatile</code>).</li> <li><code>getVolatile(object)</code>: Lee el valor del atributo de <code>object</code> referenciado por el <code>VarHandle</code>, como si el atributo hubiera sido definido como vol\u00e1til (<code>volatile</code>).</li> </ul> <p>Si queremos acceder para escritura podemos usar:</p> <ul> <li><code>get(object, newValue)</code>: Escribe <code>newValue</code> como valor del atributo de <code>object</code> referenciado por el <code>VarHandle</code>, como si el atributo hubiera sido definido como no vol\u00e1til (sin la palabra reservada <code>volatile</code>).</li> <li><code>setVolatile(object, newValue)</code>: Escribe <code>newValue</code> como valor del atributo de <code>object</code> referenciado por el <code>VarHandle</code>, como si el atributo hubiera sido definido como vol\u00e1til (<code>volatile</code>).</li> <li><code>compareAndSet(object, expectedValue, newValue)</code>: Escribe <code>newValue</code> como valor del atributo de <code>object</code> referenciado por el <code>VarHandle</code>, como si el atributo hubiera sido definido como vol\u00e1til (<code>volatile</code>), s\u00f3lo si el valor actual del atributo corresponde con <code>expectedValue</code>.</li> </ul> <p>Info</p> <p>Para saber m\u00e1s visite https://www.baeldung.com/java-variable-handles</p>"},{"location":"bloque_v/tema_24/page-4/#proyecto-varhandle","title":"Proyecto VarHandle","text":"<p>En este proyecto simularemos el funcionamiento de una cuenta bancaria, en la que una empresa realiza abonos desde un hilo y el banco realiza cargos desde otro hilo. El saldo de la cuenta ser\u00e1 almacenado usando una propiedad p\u00fablica <code>double</code>.</p> MainAccountAccountSaverAccountConsumer <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        Account account = new Account(0);\n        // Show initial balance.\n        System.out.printf(\"%s -&gt; Initial balance: %.2f\u20ac\\n\",\n                LocalTime.now().format(dateTimeFormatter), account.balance);\n        // Start both saver and consumer threads. Both threads share the same account.\n        Thread saverThread = new Thread(new AccountSaver(account));\n        saverThread.start();\n        Thread consumerThread = new Thread(new AccountConsumer(account));\n        consumerThread.start();\n        // Wait for both threads to finish.\n        saverThread.join();\n        consumerThread.join();\n        // Show final balance.\n        System.out.printf(\"\\n%s -&gt; Final balance: %.2f\u20ac\\n\",\n                LocalTime.now().format(dateTimeFormatter), account.balance);\n    }\n\n}\n</code></pre> <pre><code>public class Account {\n\n    public double balance;\n\n    public Account(double initialBalance) {\n        balance = initialBalance;\n    }\n\n}\n</code></pre> <pre><code>import java.lang.invoke.MethodHandles;\nimport java.lang.invoke.VarHandle;\n\npublic class AccountSaver implements Runnable {\n\n    private final Account account;\n\n    public AccountSaver(Account account) {\n        this.account = account;\n    }\n\n    @Override\n    public void run() {\n        VarHandle varHandle;\n        try {\n            varHandle = MethodHandles.lookup().in(Account.class)\n                    .findVarHandle(Account.class, \"balance\", double.class);\n            for (int i = 0; i &lt; 100000; i++) {\n                varHandle.getAndAdd(account, 10);\n            }\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.lang.invoke.MethodHandles;\nimport java.lang.invoke.VarHandle;\n\npublic class AccountConsumer implements Runnable {\n\n    private final Account account;\n\n    public AccountConsumer(Account account) {\n        this.account = account;\n    }\n\n    @Override\n    public void run() {\n        VarHandle varHandle;\n        try {\n            varHandle = MethodHandles.lookup().in(Account.class).findVarHandle(Account.class, \"balance\", double.class);\n            for (int i = 0; i &lt; 100000; i++) {\n                varHandle.getAndAdd(account, -5);\n            }\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_24/page-5/","title":"Ejercicios","text":"Proyecto Atomic <p>Realiza un proyecto Java haciendo uso de hilos (Runnables) y haciendo uso de las clases wrapper at\u00f3micas, en el que se quiere calcular las veces que las caras de un dado son lanzadas al azar. Ten en cuenta que un dado puede ser lanzado un m\u00e1ximo de 10.000 veces por hilo, crea un programa en Java en el que se cree 3 hilos que lancen dados, almacenando el n\u00famero de veces que se obtiene cada una de las caras de un dado (1-6).</p> <p>Adem\u00e1s, deber\u00e1s mostrar:</p> <ul> <li>El resultado obtenido por cada vez que se lanza el dado, mostrando tambi\u00e9n desde que hilo ha sido lanzado.</li> <li>El resultado total de cada una de las caras del dado.</li> <li>El n\u00famero total de tiradas en todos los hilos.</li> </ul> Proyecto Accumulator <p>Realiza el proyecto haciendo uso de acumuladores.</p>"},{"location":"bloque_v/tema_25/page-1/","title":"1 Tipos de Colecciones Thread-Safe","text":""},{"location":"bloque_v/tema_25/page-1/#tipos-de-colecciones-thread-safe","title":"Tipos de Colecciones Thread-safe","text":"<p>Cuando desarrollamos programas multihilo debemos ser muy ciudadosos con el uso de las colecciones de datos, ya que la mayor\u00eda de las estas clases no est\u00e1n preparadas para trabajar con aplicaciones concurrentes, ya que no controlan autom\u00e1ticamente el acceso concurrente a sus datos. Si distintas tareas concurrentes comparten una estructura de datos y no se implementan estrategias de acceso concurrente, pueden producirse errores de inconsistencia de datos que afectar\u00e1n a correctitud de nuestro programa.</p> <p>Por defecto, las colecciones habituales de Java, como <code>ArrayList</code> o <code>HashMap</code> no est\u00e1n sincronizadas, lo que implica que no es seguro usarlas desde distintos hilos de ejecuci\u00f3n (no son thread-safe). Por ejemplo, si varios hilos llaman a m\u00e9todos que var\u00edan la estructura de una <code>ArrayList</code>, como <code>add()</code> o <code>remove()</code> pueden producirse condiciones de carrera que generen errores en la estructura de la colecci\u00f3n.</p> <p>Con las distintas versiones de Java han ido apareciendo distintas formas de conseguir estructuras de datos thread-safe, cada una de ellas con sus ventajas e inconvenientes:</p> <ul> <li>Unmodifiable collections: Colecciones inmodificables que envuelven una colecci\u00f3n mutable.</li> <li>Copy on write collections: Colecciones creadas a partir de una colecci\u00f3n mutable, que cada vez que son modificadas crean una nueva versi\u00f3n de la colecci\u00f3n.</li> <li>Inmutable collections: Colecciones inmodificables creadas a partir de los elementos de una colecci\u00f3n, pero que no la envuelven.</li> <li>Synchronized collections: Colecciones que envuelven otra colecci\u00f3n para proporcionar un acceso sincronizado a trav\u00e9s de un objeto cerrojo asociado. Son thread-safe, pero no proporcionan un rendimiento \u00f3ptimo en casos de concurrencia intensiva.</li> <li>Concurrent-aware collections: Colecciones que no solamente son thread-safe, sino que adem\u00e1s est\u00e1n especialmente dise\u00f1adas para que el acceso concurrente sea lo m\u00e1s \u00f3ptimo posible en relaci\u00f3n a su rendimiento. Existen dos subtipos: las que usan cerrojos y proporcionan un modo bloqueante, y las que no usan cerrojos, sino operaciones CAS (lock-free).</li> </ul>"},{"location":"bloque_v/tema_25/page-2/","title":"2 Unmodifiable Collections","text":""},{"location":"bloque_v/tema_25/page-2/#unmodifiable-collection","title":"Unmodifiable Collection","text":"<p>Una unmodifiable collection es un wrapper de s\u00f3lo lectura sobre otra colecci\u00f3n existente. Estos wrappers no permiten realizar a trav\u00e9s de ellos las operaciones de agregar o eliminar en la colecci\u00f3n. Sin embargo, la colecci\u00f3n original que envuelve s\u00ed que puede ser modificada directamente y los cambios se ver\u00e1n reflejados en la versi\u00f3n inmodificable, e incluso podemos establecer <code>null</code> como elemento.</p> <p>La clase <code>Collections</code> proporciona una serie de m\u00e9todos est\u00e1ticos para crear unmodified collections a partir de distintos tipos de colecciones, como por ejemplo <code>Collections.unmodifiableCollection(collection)</code>, <code>Collections.unmodifiableList(list)</code>, <code>Collections.unmodifiableMap(map)</code>o <code>Collections.unmodifiableSet(set)</code>.</p> <p>Veamos un ejemplo:</p> <pre><code>List&lt;String&gt; mutableList = new ArrayList&lt;&gt;(Arrays.asList(\"C\", \"C++\", \"Java\"));\nList&lt;String&gt; unmodifiableList = Collections.unmodifiableList(mutableList);\n// Any attempt to modify the unmodifiableList will throw UnsupportedOperationException\ntry {\n    unmodifiableList.add(\"Python\");\n}\ncatch (UnsupportedOperationException ex) {\n    System.out.println(\"java.lang.UnsupportedOperationException\");\n}\n// Any changes made to the original list will be reflected back in the unmodifiable list\nmutableList.add(\"Go\");\n// You can use null as an element of the list\nmutableList.add(null);\nSystem.out.println(unmodifiableList);\n</code></pre> <p>Otro ejemplo de colecci\u00f3n inmodificable (parcialmente) es la lista retornada por el m\u00e9todo est\u00e1tico <code>Arrays.asList()</code>, que retorna una lista que act\u00faa como wrapper sobre un array. Dado que lo arrays no pueden cambiar su tama\u00f1o, no es posible a\u00f1adir o eliminar elementos en la lista retornada por este m\u00e9todo, lanz\u00e1ndose la excepci\u00f3n <code>UnsupportedOperationException</code>. Sin embargo, s\u00ed que es posible modificar el valor de un elemento de la lista usando el m\u00e9todo <code>set(index, element)</code> o modificando el array original.</p> <p>Veamos un ejemplo:</p> <pre><code>String[] lang = new String[]{\"C\", \"C++\", \"Java\"};\nList&lt;String&gt; fixedLengthList = Arrays.asList(lang);\ntry {\n    // any add or remove operation on the list will result in\n    // an UnsupportedOperationException\n    fixedLengthList.add(\"Python\");\n    System.out.println(\"List  : \" + fixedLengthList);\n} catch (UnsupportedOperationException ex) {\n    System.out.println(\"java.lang.UnsupportedOperationException\");\n}\n// List can be modified by calling set() method\nfixedLengthList.set(1, \"Go\");\n// Any changes made to the original array will be reflected in the list\nlang[2] = \"JS\";\n// You can use null as an element of the list\nlang[2] = null;\nSystem.out.println(\"Array : \" + Arrays.toString(lang));\n</code></pre> <p>Debemos tener en cuenta que si una colecci\u00f3n no es modificable podemos decir que es thread-safe, ya que los distintos hilos no podr\u00e1n modificarla y por tanto no podr\u00e1n crearse conflictos.</p>"},{"location":"bloque_v/tema_25/page-3/","title":"3 Copy on write collections","text":""},{"location":"bloque_v/tema_25/page-3/#copy-on-write-collections","title":"Copy on write collections","text":"<p>La clase <code>CopyOnWriteArrayList</code> crea una versi\u00f3n thread-safe de la clase <code>ArrayList</code> en la que la ejecuci\u00f3n de cualquier operaci\u00f3n que cambie la estructura de datos, como <code>add(e)</code>, <code>set(index, e)</code> o <code>remove(e)</code> produce una nueva copia de la lista en vez de modificar la existente. Est\u00e1 permitido la inserci\u00f3n de valores <code>null</code> en la lista.</p> <p>Una vez creado un objeto <code>CopyOnWriteArrayList</code>, los cambios en \u00e9l no afectan a la lista original y viceversa.</p> <p>Al crear un iterador de un CopyOnWriteArrayList, obtenemos una captura de los datos de la lista en ese momento, por lo que si posteriormente a\u00f1adimos un elemento a la lista el iterador no ser\u00e1 consciente de ello.</p> <p>La clase <code>CopyOnWriteArrayList</code> fue creada principalmente para permitir la iteraci\u00f3n segura sobre los elementos de una lista mientras que la lista original es modificada desde otros hilos. Debido al mecanismo de copia, la operaci\u00f3n <code>remove()</code> en el iterado no est\u00e1 permitida, lanzando la excepci\u00f3n <code>UnsupportedOperationException</code>.</p> <pre><code>List&lt;String&gt; mutableList = new ArrayList&lt;&gt;();\nmutableList.add(\"C\");\nmutableList.add(\"C++\");\nmutableList.add(\"Java\");\nList&lt;String&gt; copyOnWriteList = new CopyOnWriteArrayList&lt;&gt;(mutableList);\nIterator&lt;String&gt; iterator = copyOnWriteList.iterator();\n// Each modification of the list creates a new copy of the list.\ncopyOnWriteList.add(\"Go\");\n// Null is allowed as element.\ncopyOnWriteList.add(null);\n// Changes in original list don't affect copyOnWriteList.\nmutableList.add(\"Typescript\");\nSystem.out.println(copyOnWriteList);\n// Changes in copyOnWriteList don't affect original list.\nSystem.out.println(mutableList);\n// Iterator has an \"old copy\" of the list\niterator.forEachRemaining(System.out::println);\nIterator&lt;String&gt; iterator2 = copyOnWriteList.iterator();\nwhile (iterator2.hasNext()) {\n    try {\n        iterator2.remove();\n    } catch (Exception e) {\n        System.out.println(\"remove() in iterator is unsupported\");\n        return;\n    }\n}\n</code></pre> <p>Por otra parte, tenemos la clase <code>CopyOnWriteArraySet</code>, que nos permite crear una estructura de datos conjunto (set) que envuelve otro conjunto, y que usa internamente un objeto <code>CopyOnWriteArrayList</code> para sus operaciones, por los que comparte todas sus caracter\u00edsticas b\u00e1sicas.</p> <p>Warning</p> <p>Evidentemente esta caracter\u00edstica puede ser muy costosa en tiempo y memoria, pero puede ser muy eficiente en casos muy concretos, en los que las operaciones de modificaci\u00f3n de la estructura de datos son \u00ednfimas en relaci\u00f3n al n\u00famero de operaciones de consulta y recorrido de la misma.</p>"},{"location":"bloque_v/tema_25/page-4/","title":"4 Inmutable Collections","text":""},{"location":"bloque_v/tema_25/page-4/#inmutable-collections","title":"Inmutable Collections","text":"<p>Java 9 trajo consigo una serie de m\u00e9todos est\u00e1ticos factor\u00eda en las interfaces <code>List</code>, <code>Set</code> y <code>Map</code> para la creaci\u00f3n de listas, conjuntos y mapas inmutables, respectivamente. As\u00ed, por ejemplo, tenemos los m\u00e9todos <code>List.of(element...)</code> o <code>List.copyOf(collection)</code> para crear listas inmutables, <code>Set.of(element...)</code> o <code>Set.copyOf(collection)</code> para crear conjuntos inmutables, y <code>Map.of(key1, value1, key2, value2)</code>, <code>Map.ofEntries(mapEntries...)</code>, o <code>Map.copyOf(map)</code> para crear mapas inmutables.</p> <p>Podemos considerar un objeto como inmutable si su estado no puede cambiar despu\u00e9s de ser construido, manteniendo durante toda su vida los mismos datos. Si las colecciones creadas usando los m\u00e9todos anteriores contienen a su vez objetos inmutables, entonces podemos afirmar que la colecci\u00f3n es autom\u00e1ticamente thread-safe, ya que no se podr\u00e1 modificar ni su estructura ni los elementos contenidos en ella. Si, por el contrario, la colecci\u00f3n contiene objetos que son mutables, entonces no podr\u00e1 ser considerada thread-safe, por mucho que no podamos cambiar su estructura.</p> <p>Al crear una colecci\u00f3n en la que no se puede modificar su estructura, podemos hacer que sea lo m\u00e1s eficiente posible en relaci\u00f3n al consumo de espacio en memoria.</p> <p>Debemos tener en cuenta que las colecciones inmutables no son lo mismo que las unmodifiable collections, ya que no son wrappers sobre una colecci\u00f3n mutable. Corresponden a nuevas colecciones cuyos elementos son obtenidos a partir de la colecci\u00f3n dada, pero una vez creada, la nueva colecci\u00f3n no tiene relaci\u00f3n alguna con la usada para establecer los elementos.</p> <p>As\u00ed, las colecciones inmutables no permiten las operaciones de a\u00f1adir, eliminar o reemplazar elementos, lanzando la excepci\u00f3n <code>UnsupportedOperationException</code>. Sin embargo, si los elementos contenidos en la colecci\u00f3n son mutables, entonces es posible que la colecci\u00f3n parezca que haya sido modificada, cuando en realidad lo que se han reemplazado son los valores de sus elementos</p> <p>Otra caracter\u00edstica importante de las colecciones inmutables es que no pueden contener elementos <code>null</code>. Cualquier intento de crear una colecci\u00f3n inmutable con elementos <code>null</code> lanzar\u00e1 la excepci\u00f3n <code>NullPointerException</code>.</p> <p>Veamos un ejemplo:</p> <pre><code>List&lt;String&gt; mutableList = new ArrayList&lt;&gt;();\nmutableList.add(\"C\");\nmutableList.add(\"C++\");\nmutableList.add(\"Java\");\nList&lt;String&gt; inmutableList = List.copyOf(mutableList);\n// Any attempt to modify list throws UnsupportedOperationException\ntry {\n    inmutableList.add(\"Go\");\n} catch (UnsupportedOperationException e) {\n    System.out.println(\"Add is an unsupported operation\");\n}\ntry {\n    inmutableList.set(0, \"Go\");\n} catch (UnsupportedOperationException e) {\n    System.out.println(\"Set is an unsupported operation\");\n}\n// Changes in original list don't affect inmutableList.\nmutableList.add(\"Typescript\");\nSystem.out.println(inmutableList);\n// Null is forbidden as value in inmutableList. Throws NullPointerException\nList&lt;String&gt; mutableList2 = new ArrayList&lt;&gt;();\nmutableList2.add(\"C\");\nmutableList2.add(\"C++\");\nmutableList2.add(null);\ntry {\n    List&lt;String&gt; inmutableList2 = List.copyOf(mutableList2);\n} catch (NullPointerException e) {\n    System.out.println(\"Can't create an inmutable list with a null element\");\n}\ntry {\n    List&lt;String&gt; inmutableList2 = List.of(\"C\", \"C++\", null);\n} catch (NullPointerException e) {\n    System.out.println(\"Can't create an inmutable list with a null element\");\n}\n</code></pre>"},{"location":"bloque_v/tema_25/page-5/","title":"5 Synchronized Collections","text":""},{"location":"bloque_v/tema_25/page-5/#synchronized-collections","title":"Synchronized Collections","text":"<p>Hasta ahora hemos visto distintas herramientas que nos proporciona Java para crear colecciones que tengan restringidas las operaciones de modificaci\u00f3n de la misma, con objeto de convertirlas en thread-safe.</p> <p>Sin embargo, hay ocasiones en las que es necesario obligatoriamente poder modificar la colecci\u00f3n desde distintos hilos. Para eso casos Java nos proporciona distintas posibilidades.</p> <p>La primera de ellas en las conocidas como synchronized collection (colecciones sincronizadas), que no son m\u00e1s que wrappers de las principales colecciones a las que se asocia un \u00fanico objeto monitor para sincronizar las operaciones sobre ella.</p> <p>Para crear objetos de estas clases wrapper usaremos alguno de los m\u00e9todos est\u00e1ticos disponibles para tal fin en la clase <code>Collections</code>, que reciben la colecci\u00f3n que se quiere proteger: <code>Collections.synchronizedCollection(collection)</code>, <code>Collections.synchronizedList(list)</code>, <code>`Collections.synchronizedMap(map)</code> y <code>Collections.synchronizedSet(set)</code>.</p> <p>Sin embargo aunque estas clases wrapper son thread-safe, no est\u00e1n dise\u00f1adas ni optimizadas para acceso concurrente, ya que simplemente usan un \u00fanico objeto monitor (cerrojo intr\u00ednseco) para toda la colecci\u00f3n.</p> <p>De hecho, se recomienda que usemos un acceso sincronizado cuando iteremos sobre la colecci\u00f3n, o de lo contrario podemos obtener un comportamiento no deseado. Para a\u00f1adir o eliminar elementos de la colecci\u00f3n no es necesario usar un acceso sincronizado.</p> <p>Veamos un ejemplo:</p> <pre><code>List&lt;String&gt; synchronizedList = Collections.synchronizedList(new ArrayList&lt;String&gt;());\nsynchronizedList.add(\"Alex\");\nsynchronizedList.add(\"Brian\");\nsynchronized(synchronizedList) {\n    Iterator&lt;String&gt; iterator = synchronizedList.iterator(); \n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_25/page-6/","title":"6 Concurrent-aware collections","text":""},{"location":"bloque_v/tema_25/page-6/#concurrent-aware-collections","title":"Concurrent-aware collections","text":"<p>Para facilitar el uso de estructuras de datos en programas concurrentes, Java proporciona una serie de interfaces y de clases para estructuras de datos dise\u00f1adas espec\u00edficamente para ser usados en programas multihilo sin que se produzcan errores de inconsistencia de datos.</p> <p>Concurrent-aware</p> <p>Dise\u00f1ado espec\u00edficamente para que uso concurrente</p> <p>Se dice que dichas clases son no solo thread-safe, sino tambi\u00e9n concurrent-aware (adecuadas para uso concurrente). Estas clases pueden clasificarse en los siguientes grupos:</p> <ul> <li>Colecciones concurrentes que usan cerrojos: Aseguran la integridad haciendo uso de varios cerrojos de sincronizaci\u00f3n independientes. Un ejemplo de este tipo de colecciones es <code>LinkedBlockingQueue</code>. Suelen tener dos modos de funcionamiento:<ul> <li>Modo bloqueante: Incluye operaciones para a\u00f1adir y eliminar datos, de manera que si la operaci\u00f3n no puede ser realizada inmediatamente, ya sea porque la colecci\u00f3n est\u00e1 llena o vac\u00eda, el hilo que realiza la llamada a la operaci\u00f3n ser\u00e1 bloqueado hasta que la operaci\u00f3n pueda llevarse a cabo.</li> <li>Modo no bloqueante: Incluye operaciones para a\u00f1adir y eliminar datos, pero en este caso si la operaci\u00f3n no se puede realizar inmediatamente, la operaci\u00f3n retorna el valor <code>null</code> o lanza una excepci\u00f3n, y el hilo que realiz\u00f3 la llamada NO ser\u00e1 bloqueado.</li> </ul> </li> <li>Colecciones concurrentes que no usan cerrojos (lock-free): Aseguran la integridad sin tener que usan ning\u00fan tipo de cerrojo, sino operaciones CAS (compare and swap). Por su naturaleza s\u00f3lo pueden funcionar en modo no bloqueante. Un ejemplo de este tipo de colecciones es <code>ConcurrentLinkedQueue</code>.</li> </ul> <p>Aunque las colecciones concurrentes que usan cerrojos se pueden usar en modo no bloqueante, en ese caso es m\u00e1s \u00f3ptimo usar colecciones concurrentes que no usen cerrojos (lock-free).</p> <p>Las colecciones concurrentes bloqueantes est\u00e1n recomendadas en aquellos casos en los que los consumidores y los productores trabajen de forma conjunta. En ese caso, por ejemplo, los consumidores pueden llegar a vaciar la cola, en cuyo caso debe bloquearse hasta que alg\u00fan productor agregue alg\u00fan elemento a la misma.</p> <p>Sin embargo, si los productores y los consumidores no trabajan sobre la colecci\u00f3n conjuntamente, es decir, si los productores s\u00f3lo compiten entre ellos o los consumidores s\u00f3lo compiten entre ellos, no hay necesidad de bloqueo, y por tanto se recomienda usar una colecci\u00f3n concurrente que no use cerrojo.</p> <p>El paquete <code>java.util.concurrent</code> define una serie de interfaces para colecciones que puedan funcionar en modo bloqueante:</p> <ul> <li><code>BlockingQueue</code>: Define una estructura de datos cola FIFO concurrent-aware. Es implementada por las clases <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code> y <code>PriorityBlockingQueue</code>.</li> <li><code>TransferQueue</code>: Define una estructura de datos cola FIFO concurrent-aware en las que los productores (los que insertan datos) pueden decidir esperar a que los consumidores (los que extraen datos) reciban los elementos. Es implementada por la clase <code>LinkedTransferQueue</code>.</li> <li><code>BlockingDeque</code>: Define una estructura de datos cola LIFO y FIFO concurrent-aware (con inserciones y extracciones en ambos extremos).</li> </ul> <p>Tambi\u00e9n define una serie de interfaces para colecciones que funcionen s\u00f3lo en modo no bloqueante:</p> <ul> <li><code>ConcurrentMap</code>: Define una estructura de datos mapa concurrent-aware. Es implementada por las clases <code>ConcurrentHashMap</code> y <code>ConcurrentSkipListMap</code>.</li> <li><code>ConcurrentNavigableMap</code>: Define una estructura de datos de mapa navegable concurrent-aware. Es implementado por la clase <code>ConcurrentSkipListMap</code>.</li> </ul>"},{"location":"bloque_v/tema_25/page-7/","title":"7 Concurrent-aware collections que usan cerrojos","text":""},{"location":"bloque_v/tema_25/page-7/#arrayblockingqueue-y-linkedblockingqueue","title":"ArrayBlockingQueue y LinkedBlockingQueue","text":"<p>La interfaz <code>BlockingQueue</code> define una estructura de datos en forma de cola FIFO proporcionando operaciones optimizadas concurrent-aware.</p> <p><code>BlockingQueue</code> proporciona cuatro grupos de m\u00e9todos, dependiendo de lo que queremos que ocurra si no se puede realizar la operaci\u00f3n solicitada inmediatamente porque otro hilo est\u00e1 haciendo otra operaci\u00f3n que lo imposibilita, pero puede realizarse m\u00e1s adelante. As\u00ed, tendremos m\u00e9todos que lanzar\u00e1n una excepci\u00f3n, otros que retornan un valor especial (<code>null</code> o <code>false</code>), otros que bloquean al hilo llamador indefinidamente y otros que bloquean al hilo llamador una cantidad m\u00e1xima de tiempo antes de darse por vencido.</p> <p>En la siguiente tabla se muestran las operaciones, los grupos y los m\u00e9todos:</p> Lanzan un excepci\u00f3n Retornan valor especial Bloquean Bloquean con limite tiempo Inserci\u00f3n <code>add(e)</code> <code>offer(e)</code> <code>put(e)</code> <code>offer(e, time, unit)</code> Eliminaci\u00f3n <code>remove()</code> <code>poll()</code> <code>take()</code> <code>poll(time, unit)</code> Consulta <code>element()</code> <code>peek()</code> - - <p>Las estructuras de datos <code>BlockingQueue</code> no acepta el valor <code>null</code> como elemento, dado que dicho valor es usado como valor centinela para indicar fallos en las operaciones <code>poll()</code>. De hecho, si pasamos el valor <code>null</code> a los m\u00e9todos <code>add()</code>, <code>put()</code> o <code>offer()</code> se lanzar\u00e1 la excepci\u00f3n <code>NullPointerException</code>.</p> <p>Se puede definir un l\u00edmite de capacidad a una <code>BlockingQueue</code>, de manera que si una vez alcanzada la capacidad m\u00e1xima se intenta agregar un elemento mediante <code>put()</code>, el hilo llamador quede bloqueado, en espera de que haya espacio disponible.</p> <p>Por su parte, si la cola est\u00e1 vac\u00eda y un hilo llama al m\u00e9todo <code>take()</code> el hilo quedar\u00e1 bloqueada hasta que haya alg\u00fan elemento en la cola.</p> <p>La interfaz <code>BlockingQueue</code> es implementada por diferentes clases que usan distintos tipos de estructuras para almacenar los datos:</p> <ul> <li><code>ArrayBlockingQueue</code>: Una blocking queue FIFO, limitada en capacidad, y en la que los elementos se almacenan en un array. Una vez creada, no se puede modificar su capacidad. Corresponde al t\u00edpico buffer de capacidad fija. Podemos activar un modo justo (fair mode) para la espera de los hilos bloqueados para la inserci\u00f3n con <code>put()</code> o la extracci\u00f3n con <code>take()</code>.</li> <li><code>LinkedBlockingQueue</code>: Una blocking queue FIFO, que opcionalmente podemos limitar en capacidad, y en la que los elementos se almacenan como nodos enlazados. Los nodos son creados din\u00e1micamente cuando se insertan los elementos, siempre y cuando no se haya llegado a la capacidad m\u00e1xima, si \u00e9sta ha sido especificada.</li> <li><code>PriorityBlockingQueue</code>: Una blocking queue, no limitada en capacidad, en la que los elementos son ordenados atendiendo a un determinado criterio o prioridad. Los elementos deben implementar la interfaz <code>Comparable</code> para poder llevar a cabo la ordenaci\u00f3n.</li> <li><code>DelayQueue</code>: Una blocking queue, no limitada en capacidad, en la que cada elemento tiene asociado un determinado delay o tiempo de expiraci\u00f3n, antes del cual no pueden ser extra\u00eddos de la cola. As\u00ed, la cola est\u00e1 ordenada por tiempo de expiraci\u00f3n.</li> <li><code>SynchronousQueue</code>: Una blocking queue en la que cada operaci\u00f3n de inserci\u00f3n debe esperar a su correspondiente operaci\u00f3n de extracci\u00f3n, y viceversa. En realidad la cola no almacena ning\u00fan elemento y por tanto no tiene ninguna capacidad, ya que simplemente act\u00faa como intermediario de entrega de datos. Por tanto no se puede consultar elementos en la cola, ni iterar sobre ellos, y s\u00f3lo pueden insertarse si otro hilo va a extraerlo.</li> </ul>"},{"location":"bloque_v/tema_25/page-7/#proyecto-arrayblockingqueue","title":"Proyecto ArrayBlockingQueue","text":"<p>Este proyecto es similar al Proyecto WaitNotify pero haciendo uso de una estructura de datos <code>ArrayBlockingQueue</code>, en vez de usar cerrojos intr\u00ednsecos.</p> MainBakeryDoughnut ConsumerDoughnut Producer <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        Bakery bakery = new Bakery();\n        Thread doughnutProducerThread = new Thread(new DoughnutProducer(bakery), \"Doughnut producer\");\n        Thread doughnutConsumerThread = new Thread(new DoughnutConsumer(bakery), \"Doughnut consumer\");\n        doughnutProducerThread.start();\n        doughnutConsumerThread.start();\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.ArrayBlockingQueue;\n\npublic class Bakery {\n\n    private static final int TRAY_CAPACITY = 10;\n\n    private final ArrayBlockingQueue&lt;Integer&gt; tray = new ArrayBlockingQueue&lt;&gt;(TRAY_CAPACITY);\n\n    public void addToTray(Integer doughnut) throws InterruptedException {\n        tray.put(doughnut);\n        System.out.printf(\"Producer puts doughnut #%d on the tray\\n\", doughnut);\n    }\n\n    public Integer extractFromTray() throws InterruptedException {\n        Integer doughnut = tray.take();\n        System.out.printf(\"Consumer extracts doughnut #%d from tray\\n\", doughnut);\n        return doughnut;\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutConsumer implements Runnable {\n\n    private final Bakery bakery;\n\n    public DoughnutConsumer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        Integer doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = bakery.extractFromTray();\n            } catch (InterruptedException e) {\n                System.out.println(\"Consumer has been interrupted while extracting from tray\");\n                return;\n            }\n            try {\n                eat(doughnut);\n            } catch (InterruptedException e) {\n                System.out.println(\"Consumer has been interrupted while eating\");\n                return;\n            }\n        }\n        System.out.println(\"Consumer has been interrupted\");\n    }\n\n    private void eat(int doughnut) throws InterruptedException {\n        System.out.printf(\"Consumer is eating doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(30);\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutProducer implements Runnable {\n\n    private final Bakery bakery;\n    private int doughnutNumber;\n\n    public DoughnutProducer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        int doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = makeDoughnut();\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while making a doughnut\");\n                return;\n            }\n            try {\n                bakery.addToTray(doughnut);\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while adding a doughnut to the tray\");\n                return;\n            }\n        }\n        System.out.println(\"Producer has been interrupted\");\n    }\n\n    private int makeDoughnut() throws InterruptedException {\n        int doughnut = ++doughnutNumber;\n        System.out.printf(\"Producer is making doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(1);\n        return doughnut;\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_25/page-7/#proyecto-delayedqueue","title":"Proyecto DelayedQueue","text":"<p>Este proyecto es parecido al Proyecto ArrayBlockingQueue pero haciendo que no sea posible extraer un donut de la bandeja si \u00e9ste no lleva en ella al menos tres segundos (para dar tiempo a que el glaseado se condense adecuadamente). Por tanto, el consumidor ser\u00e1 bloqueado si no hay en la bandeja ning\u00fan donut que cumpla dicha caracter\u00edstica. Para proporcionar dicha funcionalidad usaremos una <code>DelayedQueue</code>.</p> MainDoughnutBakeryDoughnutConsumerDoughnutProducer <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        Bakery bakery = new Bakery();\n        Thread doughnutProducerThread = new Thread(new DoughnutProducer(bakery), \"Doughnut producer\");\n        Thread doughnutConsumerThread = new Thread(new DoughnutConsumer(bakery), \"Doughnut consumer\");\n        doughnutProducerThread.start();\n        doughnutConsumerThread.start();\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.Delayed;\nimport java.util.concurrent.TimeUnit;\n\npublic class Doughnut implements Delayed {\n\n    private static final long DONUT_GLAZE_DELAY_MILLIS = 3000;\n\n    private final int number;\n    private final long startTime;\n\n    public Doughnut(int number) {\n        this.number = number;\n        this.startTime = System.currentTimeMillis() + DONUT_GLAZE_DELAY_MILLIS;\n    }\n\n    public int getNumber() {\n        return number;\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) {\n        long diff = startTime - System.currentTimeMillis();\n        return unit.convert(diff, TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    public int compareTo(Delayed o) {\n        return (int) (this.startTime - ((Doughnut) o).startTime);\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.DelayQueue;\n\npublic class Bakery {\n\n    final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n    private final DelayQueue&lt;Doughnut&gt; tray = new DelayQueue&lt;&gt;();\n\n    public void addToTray(Doughnut doughnut) {\n        tray.put(doughnut);\n        System.out.printf(\"%s -&gt; Producer puts doughnut #%d on the tray\\n\",\n                LocalTime.now().format(dateTimeFormatter), doughnut.getNumber());\n    }\n\n    public Doughnut extractFromTray() throws InterruptedException {\n        System.out.printf(\"%s -&gt; Consumer tries to extract a doughnut from tray\\n\",\n                LocalTime.now().format(dateTimeFormatter));\n        Doughnut doughnut = tray.take();\n        System.out.printf(\"%s -&gt; Consumer extracts doughnut #%d from tray\\n\",\n                LocalTime.now().format(dateTimeFormatter), doughnut.getNumber());\n        return doughnut;\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutConsumer implements Runnable {\n\n    private final Bakery bakery;\n\n    public DoughnutConsumer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        Doughnut doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = bakery.extractFromTray();\n            } catch (InterruptedException e) {\n                System.out.println(\"Consumer has been interrupted while extracting from tray\");\n                return;\n            }\n            try {\n                eat(doughnut);\n            } catch (InterruptedException e) {\n                System.out.println(\"Consumer has been interrupted while eating\");\n                return;\n            }\n        }\n        System.out.println(\"Consumer has been interrupted\");\n    }\n\n    private void eat(Doughnut doughnut) throws InterruptedException {\n        System.out.printf(\"Consumer is eating doughnut #%d\\n\", doughnut.getNumber());\n        TimeUnit.SECONDS.sleep(1);\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutProducer implements Runnable {\n\n    private final Bakery bakery;\n    private int doughnutNumber;\n\n    public DoughnutProducer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        Doughnut doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = makeDoughnut();\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while making a doughnut\");\n                return;\n            }\n            bakery.addToTray(doughnut);\n        }\n        System.out.println(\"Producer has been interrupted\");\n    }\n\n    private Doughnut makeDoughnut() throws InterruptedException {\n        int doughnut = ++doughnutNumber;\n        System.out.printf(\"Producer is making doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(4);\n        return new Doughnut(doughnut);\n    }\n\n}\n</code></pre> <p>Si ejecutamos la aplicaci\u00f3n veremos que no rd posible extraer un donut de la bandeja si \u00e9ste no lleva en ella al menos tres segundos.</p>"},{"location":"bloque_v/tema_25/page-7/#proyecto-synchronousqueue","title":"Proyecto SynchronousQueue","text":"<p>Este proyecto es parecido al Proyecto ArrayBlockingQueue pero haciendo que el productor sea bloqueado en la bandeja cada vez de agrega un donuts a ella, hasta que el cliente lo extraiga de la misma. De esta manera el productor se asegura que no produce mas de un donut por adelantado.</p> MainBakeryDoughnutConsumerDoughnutProducer <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        Bakery bakery = new Bakery();\n        Thread doughnutProducerThread = new Thread(new DoughnutProducer(bakery), \"Doughnut producer\");\n        Thread doughnutConsumerThread = new Thread(new DoughnutConsumer(bakery), \"Doughnut consumer\");\n        doughnutProducerThread.start();\n        doughnutConsumerThread.start();\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.SynchronousQueue;\n\npublic class Bakery {\n\n    private final SynchronousQueue&lt;Integer&gt; tray = new SynchronousQueue&lt;&gt;();\n\n    public void addToTray(Integer doughnut) throws InterruptedException {\n        System.out.printf(\"Producer puts doughnut #%d on the tray\\n\", doughnut);\n        tray.put(doughnut);\n    }\n\n    public Integer extractFromTray() throws InterruptedException {\n        Integer doughnut = tray.take();\n        System.out.printf(\"Consumer extracts doughnut #%d from tray\\n\", doughnut);\n        return doughnut;\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutConsumer implements Runnable {\n\n    private final Bakery bakery;\n\n    public DoughnutConsumer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        Integer doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = bakery.extractFromTray();\n            } catch (InterruptedException e) {\n                System.out.println(\"Consumer has been interrupted while extracting from tray\");\n                return;\n            }\n            try {\n                eat(doughnut);\n            } catch (InterruptedException e) {\n                System.out.println(\"Consumer has been interrupted while eating\");\n                return;\n            }\n        }\n        System.out.println(\"Consumer has been interrupted\");\n    }\n\n    private void eat(int doughnut) throws InterruptedException {\n        System.out.printf(\"Consumer is eating doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(20);\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutProducer implements Runnable {\n\n    private final Bakery bakery;\n    private int doughnutNumber;\n\n    public DoughnutProducer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        int doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = makeDoughnut();\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while making a doughnut\");\n                return;\n            }\n            try {\n                bakery.addToTray(doughnut);\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while adding a doughnut to the tray\");\n                return;\n            }\n        }\n        System.out.println(\"Producer has been interrupted\");\n    }\n\n    private int makeDoughnut() throws InterruptedException {\n        int doughnut = ++doughnutNumber;\n        System.out.printf(\"Producer is making doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(1);\n        return doughnut;\n    }\n\n}\n</code></pre> <p>Si ejecutamos la aplicaci\u00f3n veremos que los donuts se entregan \"en mano\" uno a uno entre el productor y el consumidor.</p>"},{"location":"bloque_v/tema_25/page-7/#linkedtransferqueue","title":"LinkedTransferQueue","text":"<p>Una <code>TransferQueue</code> es una blocking queue, que opcionalmente podemos limitar en capacidad, con una funcionalidad adicional a la <code>BlockingQueue</code>, la de permitir al hilo que realiza la inserci\u00f3n bloquearse esperando a que un consumidor extraiga dicho elemento, es decir, esperar a que la transferencia se hace efectiva (de ah\u00ed su nombre).</p> <p>Para ello, adem\u00e1s de los m\u00e9todos habituales de inserci\u00f3n proporcionados por la interfaz <code>BlockingQueue</code>, la interfaz <code>TransferQueue</code> proporciona el m\u00e9todo <code>transfer(e)</code> para tal fin, que har\u00e1 que el hilo que lo ejecute ser\u00e1 bloqueado hasta que alg\u00fan otro hilo llame al m\u00e9todo <code>take()</code> o al m\u00e9todo <code>poll()</code> para obtener dicho elemento. Si cuando se llama al m\u00e9todo <code>transfer(e)</code> ya hab\u00eda elementos en la lista, el hilo ser\u00e1 bloqueado mientras otros hilos procesan todos los elementos anteriores de la cola y s\u00f3lo ser\u00e1 desbloqueado cuando otro hilo extraiga de la cola elemento transferido.</p> <p>Es posible tambi\u00e9n llamar al m\u00e9todo <code>hasWaitingConsumer()</code> para consultar si hay alg\u00fan consumidor esperando a que haya elementos en la cola.</p> <p>La clase que implementa esta interfaz es <code>LinkedTransferQueue</code>, en la que los elementos se almacenan como nodos enlazados.</p> <p>La clase <code>LinkedTransferQueue</code> proporciona un modo de funcionamiento similar al de <code>SynchronousQueue</code>. Sin embargo, a diferencia de \u00e9sta, <code>LinkedTransferQueue</code> proporciona otros modos de funcionamiento, en concreto los proporcionados por la interfaz <code>BlockingQueue</code>, por lo que nos permite decidir en cada momento qu\u00e9 modo usar.</p>"},{"location":"bloque_v/tema_25/page-7/#proyecto-linkedtransferqueue","title":"Proyecto LinkedTransferQueue","text":"<p>Este proyecto es parecido al Proyecto ArrayBlockingQueue pero haciendo que el productor sea bloqueado en la bandeja cada tres donuts, hasta que el cliente extraiga de la misma el tercer donut. De esta manera el productor se asegura que no produce mas de tres donuts por adelantado.</p> MainBakeryDoughnutConsumerDoughnutProducer <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        Bakery bakery = new Bakery();\n        Thread doughnutProducerThread = new Thread(new DoughnutProducer(bakery), \"Doughnut producer\");\n        Thread doughnutConsumerThread = new Thread(new DoughnutConsumer(bakery), \"Doughnut consumer\");\n        doughnutProducerThread.start();\n        doughnutConsumerThread.start();\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.LinkedTransferQueue;\n\npublic class Bakery {\n\n    private final LinkedTransferQueue&lt;Integer&gt; tray = new LinkedTransferQueue&lt;&gt;();\n\n    public void addToTray(Integer doughnut) {\n        System.out.printf(\"Producer puts doughnut #%d on the tray\\n\", doughnut);\n        tray.put(doughnut);\n    }\n\n    public void addToTrayAndBlock(Integer doughnut) throws InterruptedException {\n        System.out.printf(\"Producer puts doughnut #%d on the tray and waits to the consumer to extract it\\n\", doughnut);\n        tray.transfer(doughnut);\n    }\n\n    public Integer extractFromTray() throws InterruptedException {\n        Integer doughnut = tray.take();\n        System.out.printf(\"Consumer extracts doughnut #%d from tray\\n\", doughnut);\n        return doughnut;\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutProducer implements Runnable {\n\n    private final Bakery bakery;\n    private int doughnutNumber;\n\n    public DoughnutProducer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        int doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = makeDoughnut();\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while making a doughnut\");\n                return;\n            }\n            try {\n                if (doughnut % 3 == 0) {\n                    bakery.addToTrayAndBlock(doughnut);\n                } else {\n                    bakery.addToTray(doughnut);\n                }\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while adding a doughnut to the tray\");\n                return;\n            }\n        }\n        System.out.println(\"Producer has been interrupted\");\n    }\n\n    private int makeDoughnut() throws InterruptedException {\n        int doughnut = ++doughnutNumber;\n        System.out.printf(\"Producer is making doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(1);\n        return doughnut;\n    }\n\n}\n</code></pre> <pre><code>import java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\npublic class DoughnutProducer implements Runnable {\n\n    private final Bakery bakery;\n    private int doughnutNumber;\n\n    public DoughnutProducer(Bakery bakery) {\n        Objects.requireNonNull(bakery);\n        this.bakery = bakery;\n    }\n\n    @Override\n    public void run() {\n        int doughnut;\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                doughnut = makeDoughnut();\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while making a doughnut\");\n                return;\n            }\n            try {\n                if (doughnut % 3 == 0) {\n                    bakery.addToTrayAndBlock(doughnut);\n                } else {\n                    bakery.addToTray(doughnut);\n                }\n            } catch (InterruptedException e) {\n                System.out.println(\"Producer has been interrupted while adding a doughnut to the tray\");\n                return;\n            }\n        }\n        System.out.println(\"Producer has been interrupted\");\n    }\n\n    private int makeDoughnut() throws InterruptedException {\n        int doughnut = ++doughnutNumber;\n        System.out.printf(\"Producer is making doughnut #%d\\n\", doughnut);\n        TimeUnit.SECONDS.sleep(1);\n        return doughnut;\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_25/page-7/#linkedblockingdequeue","title":"LinkedBlockingDequeue","text":"<p>La interfaz <code>BlockingDequeue</code> define una estructura de datos en forma de cola bidireccional proporcionando operaciones optimizadas concurrent-aware. Se caracteriza porque se pueden realizar inserciones y extracciones en ambos extremos de la cola.</p> <p><code>BlockingDequeue</code> proporciona cuatro grupos de m\u00e9todos, dependiendo de lo que queremos que ocurra si no se puede realizar la operaci\u00f3n solicitada inmediatamente porque otro hilo est\u00e1 haciendo otra operaci\u00f3n que lo imposibilita, pero puede realizarse m\u00e1s adelante. As\u00ed, tendremos m\u00e9todos que lanzar\u00e1n una excepci\u00f3n, otros que retornan un valor especial (<code>null</code> o <code>false</code>), otros que bloquean al hilo llamador indefinidamente y otros que bloquean al hilo llamador una cantidad m\u00e1xima de tiempo antes de darse por vencido.</p> <p>En las siguientes tablas se muestran las operaciones, los grupos, los extremos y los m\u00e9todos:</p> Extremo head Lanzan un excepci\u00f3n Retornan valor especial Bloquean Bloquean con l\u00edmite tiempo Inserci\u00f3n <code>addFirst(e)</code> <code>offerFirst(e)</code> <code>putFirst(e)</code> <code>offerFirst(e, time, unit)</code> Eliminaci\u00f3n <code>removeFirst(e)</code> <code>pollFirst()</code> <code>takeFirst()</code> <code>pollFirst(time, unit)</code> Consulta <code>getFirst()</code> <code>peekFirst()</code> - - Extremo tail Lanzan un excepci\u00f3n Retornan valor especial Bloquean Bloquean con l\u00edmite tiempo Inserci\u00f3n <code>addLast(e)</code> <code>offerLast(e)</code> <code>putLast(e)</code> <code>offerLast(e, time, unit)</code> Eliminaci\u00f3n <code>removeLast(e)</code> <code>pollLast()</code> <code>takeLast()</code> <code>pollLast(time, unit)</code> Consulta <code>getLast()</code> <code>peekLast()</code> - - <p>Al igual que <code>BlockingQueue</code>, las estructuras de datos <code>BlockingDequeue</code> no aceptan el valor <code>null</code> como elemento.</p> <p>Una implementaci\u00f3n de <code>BlockingDeque</code> pude ser usada directamente como una cola <code>BlockingQueue</code>, ya que hereda de ella, haciendo m\u00e9todos equivalentes. Por ejemplo, <code>add(e)</code> es equivalente a <code>addLst(e)</code>, <code>remove()</code> es equivalente a <code>removeFirst()</code> y <code>element()</code> es equivalente a <code>getFirst()</code>.</p> <p>La clase que implementa esta interfaz es <code>LinkedBlockingDequeue</code>, que opcionalmente podemos limitar en capacidad, y en la que los elementos se almacenan como nodos enlazados.</p>"},{"location":"bloque_v/tema_25/page-7/#concurrenthashmap","title":"ConcurrentHashMap","text":"<p>La interfaz <code>ConcurrentMap</code> define una estructura de datos mapa concurrent-aware, que garantiza la atomicidad de las operaciones.</p> <p>Proporciona m\u00e9todos del tipo check-then-act (comprueba y despu\u00e9s act\u00faa) que son realizados at\u00f3micamente, como:</p> <ul> <li><code>replace(K key, V oldValue, V newValue)</code>: S\u00f3lo reemplaza el valor asociado a la clave si en ese momento contiene el valor <code>oldValue</code>.</li> <li><code>putIfAbsent(K key, V value)</code>: S\u00f3lo asocia el valor a la clave si \u00e9sta no tiene ning\u00fan valor asociado.</li> <li><code>computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>: S\u00f3lo si la clave no tiene asociado ning\u00fan valor ejecuta la funci\u00f3n recibida como argumento y asocia el valor retornado por \u00e9sta a la clave.</li> <li><code>computeIfPresent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>: S\u00f3lo si la clave tiene asociado alg\u00fan valor ejecuta la funci\u00f3n recibida como argumento y asocia el valor retornado por \u00e9sta a la clave.</li> </ul> <p>La clase principal que implementa la interfaz <code>ConcurrentMap</code> es <code>ConcurrentHashMap</code>, que usa internamente una tabla *hash* para almacenar los datos.</p> <p>Para la mayor\u00eda de las operaciones de actualizaci\u00f3n <code>ConcurrentHashMap</code> usa operaciones CAS (compare and swap), por los que proporciona buen rendimiento. Sin embargo si se produce una colisi\u00f3n en el hash entre dos elementos, usar\u00e1 un cerrojo. Por este motivo no se puede clasificar totalmente como lock-free.</p>"},{"location":"bloque_v/tema_25/page-8/","title":"8 Concurrent-aware collections","text":""},{"location":"bloque_v/tema_25/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Las colecciones thread-safe que vamos a estudiar a continuaci\u00f3n se basan en el algoritmo de Michael &amp; Scott algorithm para colas no bloqueantes sin cerrojos (non blocking lock-free queues).</p> <p>Estas colecciones NO proporcionan un modo bloqueante, dado que emplea un algoritmo no bloqueante muy eficiente. Por este motivo, estas clases no implementan la interfaz <code>BlockingQueue</code> o <code>BlockingDequeue</code>, y no proporcionan los m\u00e9todos bloqueantes incluidos en ellas.</p> <p>Por tanto su uso no est\u00e1 recomendado en escenarios en los que los productores deban bloquearse esperando a consumidores o viceversa, ya que no podr\u00e1n hacerlo.</p> <p>Debemos tener en cuenta que los iteradores creados para recorrer estas colecciones son d\u00e9bilmente consistentes, devolviendo elementos que reflejan el estado de la colecci\u00f3n en alg\u00fan momento desde la creaci\u00f3n del iterador. No lanzan la excepci\u00f3n <code>ConcurrentModificationException</code>, y pueden funcionar concurrentemente con otras operaciones. Los elementos contenidos en la colecci\u00f3n desde la creaci\u00f3n del iterador ser\u00e1n devueltos exactamente una vez.</p> <p>Otro aspecto que debemos vigilar es que, a diferencia de en la mayor\u00eda de las colecciones, y debido a la naturaleza asincr\u00f3nica de estas colas, la determinaci\u00f3n del n\u00famero actual de elementos requiere una traves\u00eda de los elementos, y por lo tanto el m\u00e9todo <code>size()</code> puede devolver resultados inexactos si esta colecci\u00f3n se modifica durante el recorrido para calcular el tama\u00f1o.</p> <p>Al igual que en otras colecciones concurrentes, se asegura que si concurrentemente un hilo est\u00e1 agregando un objeto a la colecci\u00f3n y otro lo est\u00e1 accediendo o eliminando, esta segunda operaci\u00f3n se realizar\u00e1 despu\u00e9s de la de inserci\u00f3n.</p> <p>Estas colecciones tampoco permite insertar en ella valores <code>null</code>, al igual de todas las colecciones concurrentes vistas anteriormente.</p> <p>Para saber m\u00e1s</p> <p>https://www.codejava.net/java-core/collections/understanding-collections-and-thread-safety-in-java</p>"},{"location":"bloque_v/tema_25/page-8/#concurrentlinkedqueue","title":"ConcurrentLinkedQueue","text":"<p>La clase <code>ConcurrentLinkedQueue</code> proporciona una estructura de datos en forma de cola FIFO thread-safe, sin limitaci\u00f3n de capacidad, en la que los elementos son nodos enlazados.</p> <p>A diferencia de <code>LinkedBlockingQueue</code>, la clase <code>ConcurrentLinkedQueue</code> NO proporcionan un modo bloqueante.</p> <p>En la siguiente tablas se muestran las operaciones principales y sus m\u00e9todos:</p> M\u00e9todo Inserci\u00f3n <code>add(e)</code> Eliminaci\u00f3n <code>remove()</code> Consulta <code>element()</code> <p>Esta colecci\u00f3n tampoco permite insertar en ella valores <code>null</code>, al igual de todas las colecciones concurrentes vistas anteriormente.</p>"},{"location":"bloque_v/tema_25/page-8/#concurrentlinkeddequeue","title":"ConcurrentLinkedDequeue","text":"<p>La clase <code>ConcurrentLinkedQueue</code> proporciona una estructura de datos en forma de cola FIFO y LIFO thread-safe, sin limitaci\u00f3n de capacidad, en la que los elementos son nodos enlazados.</p> <p>A diferencia de <code>LinkedBlockingDequeue</code>, la clase <code>ConcurrentLinkedDequeue</code> NO proporciona un modo bloqueante.</p> <p>En la siguiente tabla se muestran las operaciones principales y sus m\u00e9todos:</p> Extremo head Extremo tail Inserci\u00f3n <code>addFirst(e)</code> <code>addLast(e)</code> Eliminaci\u00f3n <code>removeFirst(e)</code> <code>removeFirst(e)</code> Consulta <code>getFirst()</code> <code>getLast()</code> <p>Esta colecci\u00f3n tampoco permite insertar en ella valores <code>null</code>, al igual de todas las colecciones concurrentes vistas anteriormente.</p>"},{"location":"bloque_v/tema_25/page-9/","title":"Ejercicios","text":"ArrayBlockingQueue <p>Realiza el ejercicio de los platos haciendo uso de la clase <code>ArrayBlockingQueue</code>.</p>"},{"location":"bloque_v/tema_26/page-1/","title":"1 Introducci\u00f3n","text":""},{"location":"bloque_v/tema_26/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Normalmente, cuando se desarrolla una aplicaci\u00f3n concurrente simple en Java se crean varios objetos <code>Runnable</code> y los correspondientes objetos <code>Thread</code> para ejecutarlos. Si nuestro programa debe ejecutar muchas tareas concurrentes, este m\u00e9todo tiene varias desventajas:</p> <ul> <li>Se debe implementar toda la informaci\u00f3n relacionada con el c\u00f3digo para la gesti\u00f3n de los objetos <code>Thread</code> (creaci\u00f3n, terminaci\u00f3n, obtenci\u00f3n de resultados, etc.).</li> <li>Se debe crear un objeto <code>Thread</code> por cada tarea. Si se debe ejecutar un gran n\u00famero de tareas, este hecho puede afectar al rendimiento de la aplicaci\u00f3n.</li> <li>Se debe controlar y gestionar eficientemente los recursos del ordenador. Si se crean demasiados hilos, se puede saturar el sistema.</li> </ul> <p>Desde Java 5, la API de concurrencia de Java proporciona un mecanismo para resolver estos problemas, llamado Executor framework (entorno de trabajo de ejecuci\u00f3n), que se construye en base a la interfaz <code>Executor</code> (ejecutor), su subinterfaz <code>ExecutorService</code> (servicio de ejecuci\u00f3n) y la clase <code>ThreadPoolExecutor</code> (ejecutor mediante grupos de hilos), que implementa ambas interfaces.</p> <p>Este mecanismo separa por un lado la creaci\u00f3n de tareas y por otro lado su ejecuci\u00f3n, aplicando el patr\u00f3n de dise\u00f1o conocido como command. Tan s\u00f3lo ser\u00e1 necesario implementar los objetos <code>Runnable</code> correspondientes a las tareas y envi\u00e1rselos al ejecutor, quien ser\u00e1 responsable de su ejecuci\u00f3n. Para ello el ejecutor gestiona un grupo de hilos (threadpool) en el que va ejecutando las tareas que se le van enviando. Dependiendo del tipo de ejecutor del que se trate, en algunos casos es posible aumentar o decrementar el n\u00famero de hilos del threadpool atendiendo a las necesidades.</p> <p>El objetivo del empleo de un threadpool de work thread es la posibilidad de reutilizar hilos secundarios para ejecutar varias tareas, minimizando as\u00ed el tiempo necesario para crear hilos. As\u00ed cada hilo del threadpool ejecuta un bucle en el que cada iteraci\u00f3n trata de obtener (take) la siguiente tarea de una cola de tareas <code>BlockingQueue</code> del ejecutor (workQueue), en la se van insertando (offer) conforme son enviadas (submit). Si no existe ninguna tarea en la cola el hilo quedar\u00e1 bloqueado esperando (normalmente un determinado tiempo m\u00e1ximo). Una vez obtenido la tarea la ejecuta (run). Si transcurrido el tiempo m\u00e1ximo de espera el hilo no tiene tarea que ejecutar, dependiendo del tipo de ejecutor, puede que el hilo sea directamente finalizado, reduciendo el n\u00famero de hilos del threadpool del ejecutor.</p> <p> Figura 1 - ThreadPoolExecutor</p>"},{"location":"bloque_v/tema_26/page-10/","title":"10 InvokeAll()","text":""},{"location":"bloque_v/tema_26/page-10/#invokeall","title":"invokeAll()","text":"<p>Como hemos visto en el ejemplo anterior, cuando queremos enviar una colecci\u00f3n de tareas callable al ejecutor para que sean ejecutadas debemos enviarlas una a una e ir almacenando en una <code>List&lt;Future&lt;V&gt;&gt;</code> los objetos <code>Future&lt;V&gt;</code> retornados por las repetidas llamadas al m\u00e9todo <code>submit(callableV)</code> del ejecutor. Posteriormente recorreremos dicha lista de objetos <code>Future&lt;V&gt;</code> obteniendo uno a uno el resultado retornado por cada tarea callable, esperando en orden a que el resultado de cada tarea est\u00e9 disponible.</p> <p>Sin embargo, la interfaz <code>ExecutorService</code> define un m\u00e9todo adicional que nos permite en un solo realizar lo descrito en el apartado anterior. As\u00ed el m\u00e9todo <code>invokeAll(callableVCollection)</code> recibe una colecci\u00f3n de objetos <code>Callable&lt;V&gt;</code> que queremos que sean ejecutadas por el ejecutor, y retorna una <code>List&lt;Future&lt;V&gt;&gt;</code>, es decir una lista que contendr\u00e1 un objeto <code>Future</code> por cada tarea en la lista recibida como par\u00e1metro, y en el mismo orden, cada uno de los cuales contendr\u00e1 m\u00e1s adelante el valor retornado por la tarea <code>Callable&lt;V&gt;</code> correspondiente.</p> <p>Si le pasamos <code>null</code> como <code>callableVCollection</code> el m\u00e9todo lanzar\u00e1 la excepci\u00f3n <code>NullPointerException</code>. Si cualquiera de las tareas enviadas es rechazada por el ejecutor, por ejemplo porque \u00e9ste ya haya sido terminado, el m\u00e9todo lanzar\u00e1 la excepci\u00f3n <code>RejectedExecutionException</code>.</p> <p>Lo m\u00e1s interesante de este m\u00e9todo es que es bloqueante, en el sentido de que el hilo desde el que se llama queda bloqueado hasta que todas las tareas de la lista hayan finalizado su ejecuci\u00f3n, ya sea correctamente o lanzando una excepci\u00f3n. Si alguna de la tareas callable lanz\u00f3 una excepci\u00f3n, cuando accedamos al resultado de dicha tarea a trav\u00e9s del m\u00e9todo <code>get()</code> del correspondiente objeto <code>Future</code> se lanzar\u00e1 la excepci\u00f3n <code>ExecutionException</code>.</p> <p>Si mientras est\u00e1 bloqueado esperando en el m\u00e9todo <code>invokeAll(callableVCollection)</code> es hilo desde el que se llam\u00f3 es interrumpido, se lanzar\u00e1 la excepci\u00f3n <code>InterruptedException</code> y se cancelar\u00e1n las tareas de la lista que no hayan comenzado su ejecuci\u00f3n y aquellas que no la hayan completado, marcando como interrumpidos los correspondientes hilos del threadpool del ejecutor.</p> <p>Un aspecto muy importante es que debemos asegurarnos de no agregar o quitar elementos de la lista de callables pasada como argumento mientras se est\u00e1n ejecutando las tareas en el ejector, o de lo contrario se podr\u00e1n producir errores y el resultado no est\u00e1 definido.</p> <p>Este m\u00e9todo se encuentra sobrecargado <code>invokeAll(callableList, timeout, timeUnit)</code>, para que podamos especificar el tiempo m\u00e1ximo que queremos que el hilo desde el que se llama est\u00e9 bloqueado esperando a que finalicen todas las tareas. Si todas las tareas no han finalizado su ejecuci\u00f3n antes de dicho tiempo m\u00e1ximo, cuando \u00e9ste se alcance todas las tareas de la lista que est\u00e9n en ejecuci\u00f3n o pendientes de ejecuci\u00f3n ser\u00e1n canceladas, marcando como interrumpidos los correspondientes hilos de threadpool del ejecutor.</p>"},{"location":"bloque_v/tema_26/page-10/#proyecto-invokeall","title":"Proyecto InvokeAll","text":"<p>En este proyecto desarrollaremos una aplicaci\u00f3n similar a la del proyecto anterior, en la que se calcula el factorial de 10 n\u00fameros distintos. Crearemos un tarea <code>Callable</code> que calcule el factorial de un n\u00famero y un ejecutor con un threadpool fijo de 2 hilos que lance las diez tareas y obtenga el resultado de cada una de ellas, usando objetos <code>Future</code>, y lo almacene en una lista, para finalmente mostrar todos los resultados.</p> MainTask <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n        ThreadPoolExecutor fixedThreadPool =\n                (ThreadPoolExecutor) Executors.newFixedThreadPool(2);\n        List&lt;Task&gt; tasks = new ArrayList&lt;&gt;();\n        int[] numbers = new int[10];\n        for (int i = 0; i &lt; 10; i++) {\n            numbers[i] = ThreadLocalRandom.current().nextInt(15) - 5;\n            tasks.add(new Task(numbers[i]));\n        }\n        try {\n            List&lt;Future&lt;Integer&gt;&gt; futureList = \n                fixedThreadPool.invokeAll(tasks, 2, TimeUnit.SECONDS);\n            System.out.print(\"Results:\\n\");\n            for (int i = 0; i &lt; futureList.size(); i++) {\n                // This get returns inmediately.\n                Future&lt;Integer&gt; future = futureList.get(i);\n                try {\n                    Integer factorial = future.get();\n                    System.out.printf(\"Task %d -&gt; factorial(%d) = %d\\n\", i + 1,\n                            numbers[i], factorial);\n                } catch (ExecutionException e) {\n                    System.out.printf(\"Task %d -&gt; factorial(%d) threw an exception\\n\",\n                            i + 1, numbers[i]);\n                } catch (CancellationException e) {\n                    System.out.printf(\"Task %d -&gt; factorial(%d) was cancelled\\n\",\n                            i + 1, numbers[i]);\n                }\n            }\n        } catch (InterruptedException ignored) {\n        } finally {\n            fixedThreadPool.shutdown();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\nclass Task implements Callable&lt;Integer&gt; {\n\n    private final int number;\n\n    Task(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public Integer call() throws InterruptedException {\n        return factorial(number);\n    }\n\n    private Integer factorial(int number) throws InterruptedException {\n        if (number &lt; 0) throw new IllegalArgumentException(\"Number can't be negative\");\n        int factorial = 1;\n        for (int i = 2; i &lt;= number; i++) {\n            factorial *= i;\n            TimeUnit.MILLISECONDS.sleep(200);\n        }\n        return factorial;\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos c\u00f3mo se env\u00edan al ejecutor todas la tareas de c\u00e1lculo de una vez y el hilo principal queda bloqueado hasta que todas hayan terminado.</p>"},{"location":"bloque_v/tema_26/page-11/","title":"11 InvokeAny()","text":""},{"location":"bloque_v/tema_26/page-11/#invokeany","title":"invokeAny()","text":"<p>Una de las estrategias de resoluci\u00f3n de problemas con programaci\u00f3n concurrente consiste en ejecutar simult\u00e1neamente varias tareas que resuelven el mismo problema y quedarnos con el resultado de la primera tarea que lo resuelva. Por ejemplo, supongamos que queremos ordenar un array, por lo que creamos una tarea por cada algoritmo de ordenaci\u00f3n que hayamos implementado. Podemos lanzar todas estas tareas y quedarnos con el resultado del algoritmo que tarde menos en ordenar el array.</p> <p>Para llevar a cabo esta estrategia deberemos agrupar los objetos <code>Callable</code> correspondientes a las distintas tareas en una lista de tareas y enviar dicha lista al ejecutor mediante el m\u00e9todo <code>invokeAny(callableList)</code>.</p> <p>El m\u00e9todo <code>invokeAny(callableList)</code> de la clase <code>ThreadPoolExecutor</code> recibe una lista de tareas, inicia su ejecuci\u00f3n y retorna el resultado de la primera tarea que finalice sin lanzar una excepci\u00f3n. En cuanto una tarea finaliza, el resto de tareas son marcadas para cancelaci\u00f3n autom\u00e1ticamente, marcando como interrumpidos los hilos del threadpool del ejecutor de aquellas que se est\u00e9n ejecutando.</p> <p>El hilo que llama a <code>invokeAny(callableList)</code> es bloqueado hasta que la primera tarea finalice sin lanzar una excepci\u00f3n o a que todas finalicen con una excepci\u00f3n.</p> <p>Si todas las tareas enviadas al ejecutor mediante el m\u00e9todo <code>invokeAny()</code> lanzaran una excepci\u00f3n, el propio m\u00e9todo generar\u00e1 la excepci\u00f3n <code>ExecutionException</code> y el resultado del m\u00e9todo ser\u00eda indefinido.</p> <p>No podemos olvidar que el m\u00e9todo <code>invokeAny(callableList)</code> no retorna un <code>Future</code>, sino directamente un valor del tipo <code>V</code> correspondiente al tipo retornado por los callables de la lista enviada al ejecutar a trav\u00e9s de dicho m\u00e9todo.</p> <p>La clase <code>ThreadPoolExecutor</code> proporciona una versi\u00f3n sobrecargada del m\u00e9todo <code>invokeAny(callableList, time, timeUnit)</code>, para que podamos especificar el tiempo m\u00e1ximo que queremos que el hilo llamador est\u00e9 bloqueado esperando a que finalice alguna de las tareas sin lanzar una excepci\u00f3n. Si transcurrido dicho tiempo ninguna tarea ha finalizado satisfactoriamente, pero a\u00fan quedan tareas en ejecuci\u00f3n o por ejecutarse, se lanzar\u00e1 las excepci\u00f3n <code>TimeoutException</code>.</p>"},{"location":"bloque_v/tema_26/page-11/#proyecto-invokeany","title":"Proyecto InvokeAny","text":"<p>En este proyecto vamos a desarrollar una aplicaci\u00f3n para la autenticaci\u00f3n de un usuario en el sistema. La comprobaci\u00f3n se llevar\u00e1 a cabo mediante dos m\u00e9todos: comprobaci\u00f3n sobre una base de datos local y comprobaci\u00f3n sobre una base de datos remota. En realidad, en cuanto una de las dos autenticaciones tengan \u00e9xito y nos indique que el usuario es un usuario registrado en el sistema, el resultado de la otra comprobaci\u00f3n no nos ser\u00e1 de inter\u00e9s, y de hecho ser\u00e1 cancelada. Finalmente mostraremos por pantalla el m\u00e9todo que ha autenticado al usuario, si es que alguno lo ha hecho. Si ninguno lo ha hecho, se mostrar\u00e1 un mensaje de que el usuario no se ha autenticado.</p> MainAuthenticationSystemLocalDataBaseRemoteDatabaseAuthenticationTask <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\nclass Main {\n\n    public static void main(String[] args) {\n        String username = \"username\";\n        String password = \"password\";\n        RemoteDatabase remoteDatabase = new RemoteDatabase();\n        LocalDatabase localDatabase = new LocalDatabase();\n        AuthenticationTask remoteDatabaseTask = \n            new AuthenticationTask(remoteDatabase, username, password);\n        AuthenticationTask localDatabaseTask = \n            new AuthenticationTask(localDatabase, username, password);\n        List&lt;AuthenticationTask&gt; tasks = new ArrayList&lt;&gt;();\n        tasks.add(remoteDatabaseTask);\n        tasks.add(localDatabaseTask);\n        ThreadPoolExecutor fixedThreadPoolExecutor =\n                (ThreadPoolExecutor) Executors.newFixedThreadPool(2);\n        try {\n            AuthenticationSystem authenticationSystem = \n                fixedThreadPoolExecutor.invokeAny(tasks);\n            System.out.printf(\"User authenticated by %s\\n\", \n                            authenticationSystem.getName());\n        } catch (InterruptedException ignored) {\n        } catch (ExecutionException e) {\n            System.out.print(\"User not authenticated\\n\");\n        } finally {\n            fixedThreadPoolExecutor.shutdown();\n        }\n    }\n\n}\n</code></pre> <pre><code>public interface AuthenticationSystem {\n    String getName();\n    @SuppressWarnings(\"unused\")\n    boolean authenticate(String username, String password) throws InterruptedException;\n}\n</code></pre> <pre><code>import java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\npublic class LocalDatabase implements AuthenticationSystem {\n\n    @Override\n    public String getName() {\n        return \"Local database\";\n    }\n\n    @Override\n    public boolean authenticate(String username, String password) \n        throws InterruptedException {\n        int searchDuration = ThreadLocalRandom.current().nextInt(5) + 1;\n        System.out.print(\"Local database -&gt; Authenticating...\\n\");\n        search(searchDuration);\n        boolean authenticated = ThreadLocalRandom.current().nextBoolean();\n        if (authenticated) {\n            System.out.printf(\"Local database -&gt; Authenticated in %d seconds\\n\", \n                            searchDuration);\n        } else {\n            System.out.printf(\"Local database -&gt; Not authenticated in %d seconds\\n\", \n                            searchDuration);\n        }\n        return authenticated;\n    }\n\n    private void search(int searchDuration) throws InterruptedException {\n        try {\n            TimeUnit.SECONDS.sleep(searchDuration);\n        } catch (InterruptedException e) {\n            System.out.print(\"Local database -&gt; Authentication cancelled\\n\");\n            throw new InterruptedException();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\npublic class RemoteDatabase implements AuthenticationSystem {\n\n    @Override\n    public String getName() {\n        return \"Remote database\";\n    }\n\n    @Override\n    public boolean authenticate(String username, String password) \n        throws InterruptedException {\n        int searchDuration = ThreadLocalRandom.current().nextInt(5) + 1;\n        System.out.print(\"Remote database -&gt; Authenticating...\\n\");\n        search(searchDuration);\n        boolean authenticated = ThreadLocalRandom.current().nextBoolean();\n        if (authenticated) {\n            System.out.printf(\"Remote database -&gt; Authenticated in %d seconds\\n\", \n                            searchDuration);\n        } else {\n            System.out.printf(\"Remote database -&gt; Not authenticated in %d seconds\\n\", \n                            searchDuration);\n        }\n        return authenticated;\n    }\n\n    private void search(int searchDuration) throws InterruptedException {\n        try {\n            TimeUnit.SECONDS.sleep(searchDuration);\n        } catch (InterruptedException e) {\n            System.out.print(\"Remote database -&gt; Authentication cancelled\\n\");\n            throw new InterruptedException();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.Callable;\n\nclass AuthenticationTask implements Callable&lt;AuthenticationSystem&gt; {\n\n    private final AuthenticationSystem authenticationSystem;\n    private final String username;\n    private final String password;\n\n    AuthenticationTask(AuthenticationSystem authenticationSystem, String username, \n                    String password) {\n        this.authenticationSystem = authenticationSystem;\n        this.username = username;\n        this.password = password;\n    }\n\n    @Override\n    public AuthenticationSystem call() throws InterruptedException {\n        boolean authenticated = authenticationSystem.authenticate(username, password);\n        if (!authenticated) {\n            throw new RuntimeException(\"Authentication failed\");\n        }\n        return authenticationSystem;\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_26/page-12/","title":"12 ThreadFactory","text":""},{"location":"bloque_v/tema_26/page-12/#threadfactory","title":"ThreadFactory","text":"<p>Si queremos personalizar la forma en que los ejecutores crean los hilos cuando es necesario, podemos proporcionarle al ejecutor un objeto factor\u00eda de una clase que implemente la interfaz <code>ThreadFactory</code>, ya sea a trav\u00e9s del constructor del ejecutor, a trav\u00e9s de alg\u00fan m\u00e9todo est\u00e1tico factor\u00eda de la clase <code>Executors</code> o del propio m\u00e9todo <code>setThreadFactory(threadFactory)</code> del ejecutor.</p> <p><code>ThreadFactory</code> corresponde a una interfaz funcional cuyo m\u00e9todo <code>newThread(runnable)</code> recibe el runnable que debe ejecutar el hilo, de manera que debe construir y retornar un objeto <code>Thread</code> que lo ejecute. As\u00ed, podemos personalizar la creaci\u00f3n del hilo, por ejemplo estableciendo una determinada pol\u00edtica de nombres o de prioridades.</p> <pre><code>ThreadPoolExecutor cachedThreadPoolExecutor = \n    (ThreadPoolExecutor) Executors.newCachedThreadPool(new ThreadFactory() {\n            @Override\n            public Thread newThread(Runnable runnable) {\n                Thread thread = new Thread(runnable);\n                // Customize thread\n                // ...\n                return thread;\n            }\n    });\n</code></pre>"},{"location":"bloque_v/tema_26/page-13/","title":"13 RejectedExecutionHandler","text":""},{"location":"bloque_v/tema_26/page-13/#controlar-las-tareas-rechazadas-por-el-ejecutor","title":"Controlar las tareas rechazadas por el ejecutor","text":"<p>Cuando deseamos finalizar la ejecuci\u00f3n de un ejecutor usamos su m\u00e9todo <code>shutdown()</code> o <code>shutdownNow()</code> para indicarle que debe concluir su ejecuci\u00f3n. En ese momento el ejecutor deja de aceptar nuevas tareas.</p> <p>Si enviamos una tarea al ejecutor despu\u00e9s de haberle informado de que debe terminarse, es decir, despu\u00e9s de llamar al m\u00e9todo <code>shutdown()</code> o <code>shutdownNow()</code>, dicha tarea es rechazada y, por defecto, la llamada al m\u00e9todo con el que se ha enviado la tarea lanzar\u00e1 una excepci\u00f3n <code>RejectedExecutionException</code>.</p> <p>La clase <code>ThreadPoolExecutor</code> proporciona un mecanismo para personalizar la respuesta ante el hecho de que una tarea sea rechazada. Para ello, podemos proporcionar al ejecutor un objeto de una clase que implemente la interfaz <code>RejectedExecutionHandler</code>, ya sea a trav\u00e9s del constructor o a trav\u00e9s del m\u00e9todo <code>setRejectedExecutionHandler(rejectedExecutionHandler)</code>.</p> <p>La interfaz <code>RejectedExecutionHandler</code> define un \u00fanico m\u00e9todo <code>rejectedExecution(runnable, threadPoolExecutor)</code>, que recibe el objeto <code>Runnable</code> correspondiente a la tarea rechazada y el ejecutor.</p> <p>Si le hemos proporcionado al ejecutor un objeto <code>RejectedExecutionHandler</code>, cuando el ejecutor rechace una tarea, no lanzar\u00e1 la excepci\u00f3n <code>RejectedExecutionException</code>, sino que llamar\u00e1 al m\u00e9todo <code>rejectedExecution(runnable, threadPoolExecutor)</code>, pas\u00e1ndole la tarea rechazada y \u00e9l mismo como ejecutor.</p>"},{"location":"bloque_v/tema_26/page-13/#proyecto-rejectedexecutionhandler","title":"Proyecto RejectedExecutionHandler","text":"<p>Este proyecto es similar al proyecto FixedThreadPool que estudiamos anteriormente, pero se usar\u00e1 un objeto <code>ThreadFactory</code> para que el ejecutor cree sus hilos y un objeto <code>RejectedExecutionHandler</code> para tratar las tareas que hayan sido rechazadas por haber sido enviadas despu\u00e9s de que el el servidor se haya terminado.</p> MainServerTask <pre><code>class Main {\n\n    public static void main(String[] args) {\n        Server server = new Server();\n        for (int i = 0; i &lt; 50; i++) {\n            Task task = new Task(\"Task \" + i);\n            server.execute(task);\n            try {\n                // The less time you sleep the greater the thread pool size gets.\n                // Try to reduce the time sleeping and see what happens to thread pool size.\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n        try {\n            // server.shutdown();\n            // Try shutdownNow instead and see what happens.\n            server.shutdownNow();\n        } catch (InterruptedException exception) {\n            return;\n        }\n        Task task = new Task(\"Task sent after shutdown\");\n        server.execute(task);\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.*;\n\nclass Server {\n\n    static class ServerThreadFactory implements ThreadFactory {\n\n        int threadNumber = 1;\n\n        @Override\n        public Thread newThread(Runnable runnable) {\n            return new Thread(runnable, \"Server thread \" + threadNumber++);\n        }\n\n    }\n\n    private final ThreadPoolExecutor fixedThreadPool =\n            (ThreadPoolExecutor) Executors.newFixedThreadPool(5);\n\n    Server() {\n        fixedThreadPool.setThreadFactory(new ServerThreadFactory());\n        fixedThreadPool.setRejectedExecutionHandler((runnable, executor) -&gt;\n                System.out.printf(\"Handler -&gt; Task rejected: %s\\n\",\n                        ((Task) runnable).getName()));\n    }\n\n    void execute(Task task) {\n        fixedThreadPool.execute(task);\n    }\n\n    @SuppressWarnings(\"unused\")\n    void shutdown() throws InterruptedException {\n        fixedThreadPool.shutdown();\n        if (fixedThreadPool.awaitTermination(5, TimeUnit.SECONDS)) {\n            System.out.printf(\"Server -&gt; Terminated. Completed: %d\\n\",\n                    fixedThreadPool.getCompletedTaskCount());\n        } else {\n            System.out.printf(\"Server -&gt; Await termination timeout. Completed: %d\\n\",\n                    fixedThreadPool.getCompletedTaskCount());\n        }\n    }\n\n    void shutdownNow() throws InterruptedException {\n        fixedThreadPool.shutdownNow();\n        if (fixedThreadPool.awaitTermination(5, TimeUnit.SECONDS)) {\n            System.out.printf(\"Server -&gt; Terminated. Completed: %d\\n\",\n                    fixedThreadPool.getCompletedTaskCount());\n        } else {\n            System.out.printf(\"Server -&gt; Await termination timeout. Completed: %d\\n\",\n                    fixedThreadPool.getCompletedTaskCount());\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\nclass Task implements Runnable {\n\n    private final String name;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    Task(String name) {\n        this.name = name;\n    }\n\n    String getName() {\n        return name;\n    }\n\n    @Override\n    public void run() {\n        System.out.printf(\"%s -&gt; %s -&gt; Started at: %s\\n\",\n                Thread.currentThread().getName(), name, dateTimeFormatter.format(LocalDateTime.now()));\n        try {\n            work();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s -&gt; %s -&gt; Interrupted at: %s\\n\",\n                    Thread.currentThread().getName(), name, dateTimeFormatter.format(LocalDateTime.now()));\n            return;\n        }\n        System.out.printf(\"%s -&gt; %s -&gt; Finished at: %s\\n\",\n                Thread.currentThread().getName(), name, dateTimeFormatter.format(LocalDateTime.now()));\n    }\n\n    private void work() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(10));\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_26/page-14/","title":"14 ScheduledThreadPoolExecutor","text":""},{"location":"bloque_v/tema_26/page-14/#scheduledthreadpoolexecutor","title":"ScheduledThreadPoolExecutor","text":"<p>Como hemos visto, el Executor framework proporciona la clase <code>ThreadPoolExecutor</code> para ejecutar tareas <code>Callable</code> y <code>Runnable</code> con un grupo de hilos, sin que tengamos que preocuparnos de las operaciones de creaci\u00f3n de los hilos. Cuando se env\u00eda una tarea al ejecutor, \u00e9sta es ejecutada lo m\u00e1s pronto que sea posible, teniendo en cuenta la configuraci\u00f3n del ejecutor.</p> <p>Sin embargo, algunas veces este comportamiento no es precisamente el deseado, sino que queremos que la tarea sea ejecutada una vez haya transcurrido un cierto lapso de tiempo.</p> <p>Para este cometido, el Executor framework pone a nuestra disposici\u00f3n la interfaz <code>ScheduledExecutorService</code>, que extiende de <code>ExecutorService</code>, para definir una serie de m\u00e9todos que van a permitir planificar cu\u00e1ndo queremos que se ejecute una tarea aproximadamente, e incluso que \u00e9sta se ejecute de forma peri\u00f3dica.</p> <p>Veamos la definici\u00f3n de la interfaz <code>ScheduledExecutorService</code>:</p> <pre><code>public interface ScheduledExecutorService extends ExecutorService {\n\n    // M\u00e9todos para retrasar un determinado tiempo la ejecuci\u00f3n\n    // de una tarea en el ejecutor.\n    public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit);\n    public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, \n                                           TimeUnit unit);\n\n    // M\u00e9todos para planificar la ejecuci\u00f3n peri\u00f3dica de una tarea\n    // en el ejecutor.\n    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay,\n                                                  long period, TimeUnit unit);\n    public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay,\n                                                     long delay, TimeUnit unit);\n\n}\n</code></pre> <p>La clase <code>ScheduledThreadPoolExecutor</code> extiende de <code>ThreadPoolExecutor</code>, por lo que incorpora toda su funcionalidad, pero adem\u00e1s implementa la interfaz <code>ScheduledExecutorService</code>.</p> <p>Esta clase ofrece distintos constructores sobrecargados, que nos permiten configurar el corePoolSize, el threadFactory y el rejectedExecutionHandler. Por ejemplo:</p> <pre><code>public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor \n    implements ScheduledExecutorService {\n\n    public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE,\n              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,\n              new DelayedWorkQueue());\n    }\n\n    // ...\n\n}\n</code></pre> <p>Como vemos, por defecto se crea un cached threadpool executor, que mantendr\u00e1 como m\u00ednimo el n\u00famero de hilos pasado como argumento al constructor. Por defecto, los hilos ser\u00e1n destruidos si est\u00e1n 10 milisegundos inactivos, siempre y cuando el n\u00famero de hilos sea mayor que el valor m\u00ednimo pasado como argumento al constructor. Las tareas se mantendr\u00e1n en un tipo especial de <code>BlockingQueue&lt;Runnable&gt;</code> llamada <code>DelayedWorkQueue</code>.</p> <p>La clase <code>Executors</code> proporciona el m\u00e9todo est\u00e1tico factor\u00eda <code>Executors.newScheduledThreadPool(corePoolSize)</code>, que recibir\u00e1 el n\u00famero de hilos m\u00ednimos que queremos que tenga el threadpool del ejecutor. Tambi\u00e9n proporciona el m\u00e9todo <code>Executors.newSingleThreadScheduledExecutor()</code>, en el que el n\u00famero m\u00ednimo de hilos a mantener en el threadpool ser\u00e1 1.</p>"},{"location":"bloque_v/tema_26/page-15/","title":"15 Planificaci\u00f3n del inicio de ejecuci\u00f3n de una tarea","text":""},{"location":"bloque_v/tema_26/page-15/#planificacion-del-inicio-de-ejecucion-de-una-tarea","title":"Planificaci\u00f3n del inicio de ejecuci\u00f3n de una tarea","text":"<p>Para poder planificar el momento en el que debe ejecutarse una tarea en el ejecutor, la interfaz <code>ScheduledExecutorService</code> proporciona el m\u00e9todo <code>schedule(runnable, delay, timeUnit)</code>, en el que la tarea se pasa en forma de <code>Runnable</code>. Recibe adem\u00e1s el periodo de tiempo que queremos que el ejecutor espere antes de ejecutarla respecto al momento en el que se recibe, a lo que se conoce como delay, y la unidad de tiempo en la que debe medirse dicha cantidad de tiempo (timeUnit). Este m\u00e9todo retorna un <code>ScheduledFuture&lt;?&gt;</code> que representa la tarea as\u00edncrona enviada que no va a retornar ning\u00fan valor, ya que se trata de un runnable.</p> <p><code>ScheduledFuture&lt;V&gt;</code> es una interfaz que extiende de <code>Future&lt;V&gt;</code>, por lo que incluye toda la funcionalidad que ya conocemos para obtener el valor o cancelar la tarea, pero adem\u00e1s extiende de la interfaz <code>Delayed</code>, que proporciona el m\u00e9todo <code>getDelay(timeUnit)</code> para poder obtener el delay restante para iniciar la ejecuci\u00f3n de la tarea asociada.</p> <p> Figura 3 - ScheduledExecutorService</p> <p>Si la tarea que queremos planificar es un <code>Callable&lt;V&gt;</code>, podemos usar el m\u00e9todo <code>schedule(callableV, delay, timeUnit)</code>, que recibe el callable y los par\u00e1metros delay y timeUnit que estudiamos en el m\u00e9todo anterior. La llamada a este m\u00e9todo retornar\u00e1 un <code>ScheduledFuture&lt;V&gt;</code> que podremos usar para obtener el valor retornado por el callable, cancelar la tarea e incluso consultar cu\u00e1nto tiempo falta para su ejecuci\u00f3n.</p> <p>Un aspecto muy importante de ambos m\u00e9todos es que el valor de delay debe ser expresado respecto al momento del env\u00edo de la tarea al ejecutor, por lo que si queremos que la tarea se ejecute en un momento concreto, deberemos calcular la diferencia entre dicho momento y la fecha/hora actual y usarla como delay.</p> <p>El ejecutor garantiza que la tarea no comenzar\u00e1 su ejecuci\u00f3n antes de que haya transcurrido el delay especificado, ya que su ejecuci\u00f3n no estar\u00e1 habilitada hasta que no pase dicho lapso de tiempo. Sin embargo, una vez habilitada la posibilidad de ejecuci\u00f3n, no hay una garant\u00eda del momento exacto en el que \u00e9sta comenzar\u00e1. Si varias tareas son habilitadas para ejecuci\u00f3n exactamente en el mismo momento, se ejecutar\u00e1n en el orden en el que fueron enviadas.</p>"},{"location":"bloque_v/tema_26/page-15/#proyecto-schedule","title":"Proyecto Schedule","text":"<p>En este proyecto crearemos un ejecutor <code>ScheduledThreadPoolExecutor</code> con uno s\u00f3lo hilo al que enviaremos , de manera que las tareas se ejecuten en orden y con un retardo de 1 segundo entre ellas. La tarea en s\u00ed ser\u00e1 simulada con la escritura de un mensaje y retornar\u00e1 una cadena con un saludo.</p> MainGreetTaskFactorialTask <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        ScheduledExecutorService scheduledExecutor =\n                Executors.newScheduledThreadPool(5);\n        GreetTask greetTask = new GreetTask(\"Hello\");\n        ScheduledFuture&lt;?&gt; greetScheduledFuture = scheduledExecutor.schedule(greetTask, 5, TimeUnit.SECONDS);\n        System.out.printf(\"%s -&gt; %s - Greet task sent. Still %d seconds left\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                greetScheduledFuture.getDelay(TimeUnit.SECONDS));\n        int number = -10;\n        // Try with\n        //int number = -1;\n        int factorialTaskDelay = 10;\n        // Try with\n        // int factorialTaskDelay = 1;\n        FactorialTask factorialTask = new FactorialTask(number);\n        ScheduledFuture&lt;Integer&gt; factorialScheduledFuture =\n                scheduledExecutor.schedule(factorialTask, factorialTaskDelay, TimeUnit.SECONDS);\n        System.out.printf(\"%s -&gt; %s - factorial(%d) task sent\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                number);\n        System.out.printf(\"%s -&gt; %s - Waiting for factorial(%d) result. Still %d seconds left\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                number,\n                factorialScheduledFuture.getDelay(TimeUnit.SECONDS));\n        try {\n            Integer factorial = factorialScheduledFuture.get();\n            System.out.printf(\"%s -&gt; %s - factorial(%d) = %d\\n\",\n                    Thread.currentThread().getName(),\n                    dateTimeFormatter.format(LocalTime.now()),\n                    number, factorial);\n        } catch (InterruptedException ignored) {\n        } catch (ExecutionException e) {\n            System.out.printf(\"%s -&gt; %s - factorial(%d) launched an exception\\n\",\n                    Thread.currentThread().getName(),\n                    dateTimeFormatter.format(LocalTime.now()),\n                    number);\n        } finally {\n            scheduledExecutor.shutdown();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.TimeUnit;\n\nclass GreetTask implements Runnable {\n\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    private final String greet;\n\n    @SuppressWarnings(\"SameParameterValue\")\n    GreetTask(String greet) {\n        this.greet = greet;\n    }\n\n    @Override\n    public void run() {\n        try {\n            TimeUnit.SECONDS.sleep(6);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.printf(\"%s -&gt; %s - %s\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                greet);\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\nclass FactorialTask implements Callable&lt;Integer&gt; {\n\n    private final int number;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    FactorialTask(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public Integer call() throws InterruptedException {\n        Integer result = factorial(number);\n        System.out.printf(\"%s -&gt; %s - factorial(%d) calculated\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                number);\n        return result;\n    }\n\n    private Integer factorial(int number) throws InterruptedException {\n        if (number &lt; 0) throw new IllegalArgumentException(\"Number can't be negative\");\n        int factorial = 1;\n        for (int i = 2; i &lt;= number; i++) {\n            factorial *= i;\n            TimeUnit.MILLISECONDS.sleep(20);\n        }\n        TimeUnit.SECONDS.sleep(2);\n        return factorial;\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_26/page-16/","title":"16 Ejecutar una tarea de manera peri\u00f3dica","text":""},{"location":"bloque_v/tema_26/page-16/#ejecutar-una-tarea-de-manera-periodica","title":"Ejecutar una tarea de manera peri\u00f3dica","text":"<p>Algunas veces queremos enviar al ejecutor una misma tarea de manera peri\u00f3dico, para que sea ejecutada cada cierto tiempo. Para ello, la interfaz <code>ScheduledExecutorService</code> nos define el m\u00e9todo <code>scheduledAtFixedRate(runnable, initialDelay, period, timeUnit)</code>, que recibe como argumento la tarea a ejecutar en forma de <code>Runnable</code>, el tiempo de espera para la primera ejecuci\u00f3n (initial delay), el tiempo entre ejecuciones (period) y la unidad de tiempo en la que medir los par\u00e1metros anteriores (timeUnit). La llamada a este m\u00e9todo retornar\u00e1 un objeto <code>ScheduledFuture&lt;?&gt;</code>.</p> <p>Debemos tener en cuenta que el periodo entre ejecuciones se refiere al momento del inicio de la ejecuci\u00f3n, no al tiempo transcurrido desde la finalizaci\u00f3n de una ejecuci\u00f3n anterior y el inicio de la siguiente.</p> <p>Pero, \u00bfqu\u00e9 ocurre si, por ejemplo, la tarea tarda en ejecutarse 5 segundos y el periodo entre ejecuciones se establece en 3 segundos? Pues que la tarea vuelve a ser habilitada para ejecuci\u00f3n 3 segundos despu\u00e9s de que lo fuera la vez anterior. Sin embargo, es probable que la tarea est\u00e9 en ese momento en ejecuci\u00f3n. Cuando dicha ejecuci\u00f3n finalice, y dado que la tarea ha vuelto a ser habilitada, puede comenzar a ejecutarse de nuevo inmediatamente.</p> <p>Si en vez de querer habilitar para ejecuci\u00f3n la tarea cada \"x\" tiempo lo que queremos es hacer que se vuelve a habilitar para ejecuci\u00f3n cuando haya transcurrido tiempo desde que finalizara su \u00faltima ejecuci\u00f3n, entonces podemos usar el m\u00e9todo <code>scheduleWithFixedDelay(runnable, initialDelay, delay, timeUnit)</code>, muy parecido al anterior, pero en el que el par\u00e1metro relativo al periodo de tiempo (delay) hace referencia al tiempo transcurrido entre la finalizaci\u00f3n de la ejecuci\u00f3n de la tarea y el inicio de la siguiente habilitaci\u00f3n. La llamada a este m\u00e9todo retornar\u00e1 un objeto <code>ScheduledFuture&lt;?&gt;</code>.</p> <p>Como vemos en ambos m\u00e9todos la tarea debe ser enviada en forma de runnable, ya que no tiene sentido tener una tarea de c\u00e1lculo en forma de callable que sea ejecutada peri\u00f3dicamente.</p> <p>Warning</p> <p>La versi\u00f3n 1.3 del JDK introdujo la clase <code>java.util.Timer</code>, que permite planificar la ejecuci\u00f3n de una tarea e incluso su ejecuci\u00f3n peri\u00f3dica. Usa un \u00fanico hilo trabajador, por lo que si s\u00f3lo una de las tareas que le hayamos enviado podr\u00e1 estar ejecut\u00e1ndose en un momento dado, incluso aunque por su delay inicial o periodicidad indicara que debiera estar ejecut\u00e1ndose.</p> <p>La tareas con las que puede trabajar un objeto <code>Timer</code> deber\u00e1n ser objetos de la clase <code>TimerTask</code> o de alguna clase que la extienda. Esta clase implementa la interfaz <code>Runnable</code>, de manera que en su m\u00e9todo <code>run()</code> especificaremos el c\u00f3digo que debe ejecutar la tarea.</p> <p>La clase <code>Timer</code> proporciona distintos m\u00e9todos para poder enviarle una tarea, como por ejemplo <code>schedule()</code> o <code>scheduleAtFixedRate()</code>. Para cancelar la ejecuci\u00f3n de las tareas enviadas objeto <code>Timer</code> podemos llamar a su m\u00e9todo <code>cancel()</code>.</p> <p>Se recomienda no usar las clases Timer o TimerTask, sino un <code>ScheduledThreadPoolExecutor</code>, dado que \u00e9ste ofrece una mayor flexibilidad en la planificaci\u00f3n y puede emplear varios hilos de ejecuci\u00f3n.</p>"},{"location":"bloque_v/tema_26/page-16/#proyecto-scheduledperiodictask","title":"Proyecto ScheduledPeriodicTask","text":"<p>En este proyecto enviaremos la misma tarea de saludo del proyecto anterior pero esta vez para que se ejecute de forma peri\u00f3dica, de manera que transcurridos unos segundos se termina el ejecutor.</p> MainGreetTask <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nclass Main {\n\n    public static void main(String[] args) {\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        ScheduledThreadPoolExecutor scheduledExecutor =\n                (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1);\n        GreetTask greetTask = new GreetTask(\"Hello\");\n        int periodSeconds = 5;\n        ScheduledFuture&lt;?&gt; greetScheduledFuture =\n                scheduledExecutor.scheduleAtFixedRate(greetTask, 5, periodSeconds, TimeUnit.SECONDS);\n        System.out.printf(\"%s -&gt; %s - Greet task sent to be executed every %d seconds. Still %d seconds left to first execution\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                periodSeconds,\n                greetScheduledFuture.getDelay(TimeUnit.SECONDS));\n        int sleepSeconds = 25;\n        try {\n            TimeUnit.SECONDS.sleep(sleepSeconds);\n        } catch (InterruptedException ignored) {\n        } finally {\n            System.out.printf(\"%s -&gt; %s - Executor shut down after %d seconds\\n\",\n                    Thread.currentThread().getName(),\n                    dateTimeFormatter.format(LocalTime.now()),\n                    sleepSeconds);\n            scheduledExecutor.shutdownNow();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\n\nclass GreetTask implements Runnable {\n\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n    private final String greet;\n\n    @SuppressWarnings(\"SameParameterValue\")\n    GreetTask(String greet) {\n        this.greet = greet;\n    }\n\n    @Override\n    public void run() {\n        System.out.printf(\"%s -&gt; %s - %s\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                greet);\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_26/page-17/","title":"17 Cancelaci\u00f3n de tareas y terminaci\u00f3n del ScheduledThreadPoolExecutor","text":""},{"location":"bloque_v/tema_26/page-17/#cancelacion-de-tareas-y-terminacion-del-scheduledthreadpoolexecutor","title":"Cancelaci\u00f3n de tareas y terminaci\u00f3n del ScheduledThreadPoolExecutor","text":"<p>Cuando marcamos como cancelada una tarea del ejecutor llamando al m\u00e9todo <code>cancel()</code> del <code>ScheduledFuture</code> correspondiente, si dicha tarea estaba deshabilitada para ejecuci\u00f3n esperando que transcurriera el delayed indicado cuando se envi\u00f3, la tarea nunca llegar\u00e1 a ejecutarse.</p> <p>Por defecto, las tareas canceladas no son inmediatamente eliminadas de la work queue, sino que se espera a que transcurra el delay especificado cuando se enviaron. Sin embargo podemos cambiar dicha pol\u00edtica llamando al m\u00e9todo <code>setRemoveOnCancelPolicy(true)</code>, que har\u00e1 que se eliminen inmediatamente. Este m\u00e9todo est\u00e1 disponible desde Java 7.</p> <p>Cuando llamamos al m\u00e9todo <code>shutdown()</code> para finalizar el <code>ScheduledThreadPoolExecutor</code>, al igual que ocurr\u00eda con la clase <code>ThreadPoolExecutor</code>, se dejar\u00e1n de aceptar nuevas tareas, por lo que si se le env\u00edan nuevas tareas \u00e9stas son rechazadas. Adem\u00e1s, por defecto, se permitir\u00e1 completar su ejecuci\u00f3n tanto las tareas que ya est\u00e9n en ejecuci\u00f3n como aquellas que est\u00e9n esperando para comenzar su ejecuci\u00f3n, incluso las que est\u00e9n deshabilitadas para ejecuci\u00f3n en ese momento al no haber transcurrido a\u00fan el delay especificado cuando se enviaron.</p> <p>Sin embargo, la clase <code>ScheduledThreadPoolExecutor</code> nos permite cambiar la pol\u00edtica concreta de qu\u00e9 hacer con las tareas que est\u00e1n deshabilitadas para ejecuci\u00f3n cuando se llama a <code>shutdown()</code>. As\u00ed, si llamamos al m\u00e9todo <code>setExecuteExistingDelayedTasksAfterShutdownPolicy(false)</code> configuraremos el ejecutor para que dichas tareas no lleguen a ser ejecutadas.</p> <p>De forma similar, mediante el m\u00e9todo <code>setContinueExistingPeriodicTasksAfterShutdownPolicy(false)</code> podemos hacer que las tareas peri\u00f3dicas esperando la siguiente ejecuci\u00f3n no lleguen a ser ejecutadas m\u00e1s.</p> <p>Si llamamos al m\u00e9todo <code>shutdownNow(mayInterruptIfRunning)</code>, en vez de a <code>shutdown()</code>, el funcionamiento de este m\u00e9todo ser\u00e1 exactamente igual que en el caso de <code>ThreadPoolExecutor</code>, es decir, todas las tareas pendientes de ejecuci\u00f3n, peri\u00f3dicas o no, no llegar\u00e1n a ejecutarse, independientemente de las pol\u00edticas establecidas anteriormente.</p>"},{"location":"bloque_v/tema_26/page-17/#proyecto-cancelperiodictask","title":"Proyecto CancelPeriodicTask","text":"<p>En este proyecto modificamos el proyecto anterior para cancelar la tarea peri\u00f3dica antes de terminar el ejecutor.</p> MainGreetTask <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nclass Main {\n\n    public static void main(String[] args) {\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        ScheduledThreadPoolExecutor scheduledExecutor =\n                (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(1);\n        scheduledExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n        scheduledExecutor.setRemoveOnCancelPolicy(true);\n        GreetTask greetTask = new GreetTask(\"Hello\");\n        int periodSeconds = 5;\n        ScheduledFuture&lt;?&gt; greetScheduledFuture =\n                scheduledExecutor.scheduleAtFixedRate(greetTask, 5, periodSeconds, TimeUnit.SECONDS);\n        System.out.printf(\"%s -&gt; %s - Greet task sent to be executed every %d seconds. Still %d seconds left to first ejecution\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                periodSeconds,\n                greetScheduledFuture.getDelay(TimeUnit.SECONDS));\n        int sleepSeconds = 25;\n        try {\n            TimeUnit.SECONDS.sleep(sleepSeconds);\n        } catch (InterruptedException ignored) {\n        } finally {\n            greetScheduledFuture.cancel(true);\n            System.out.printf(\"%s -&gt; %s - Greet periodic task cancelled after %d seconds\\n\",\n                    Thread.currentThread().getName(),\n                    dateTimeFormatter.format(LocalTime.now()),\n                    sleepSeconds);\n            scheduledExecutor.shutdownNow();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\n\nclass GreetTask implements Runnable {\n\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n    private final String greet;\n\n    @SuppressWarnings(\"SameParameterValue\")\n    GreetTask(String greet) {\n        this.greet = greet;\n    }\n\n    @Override\n    public void run() {\n        System.out.printf(\"%s -&gt; %s - %s\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                greet);\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_26/page-18/","title":"18 ExecutorCompletionService","text":""},{"location":"bloque_v/tema_26/page-18/#executorcompletionservice","title":"ExecutorCompletionService","text":"<p>Normalmente, cuando ejecutamos tareas concurrentes mediante un ejecutor, le enviamos la tarea <code>Runnable</code> o <code>Callable</code> mediante alguno de sus m\u00e9todos, que nos retorna un objeto <code>Future</code>, con el que podremos, m\u00e1s adelante, obtener el resultado retornado por la tarea. Pero tanto el env\u00edo como el procesado del resultado se realiza en el mismo hilo (en nuestros proyectos anteriores en el hilo principal correspondiente a la clase <code>Main</code>). Adem\u00e1s, la obtenci\u00f3n del valor mediante el m\u00e9todo <code>get()</code> es bloqueante, por lo que se suele decir que se trata de un modelo de \"procesamiento futuro s\u00edncrono\" (synchronous future processing).</p> <p>Sin embargo, en algunas ocasiones es necesario independizar el env\u00edo de tareas al ejecutor en un hilo y el procesamiento de los resultados en otro hilo distinto o simplemente nos gustar\u00eda realizar un procesamiento as\u00edncrono del resultado (en contraste con el procesamiento futuro as\u00edncrono descrito en el p\u00e1rrafo anterior).</p> <p>Para ello, la API de Concurrencia de Java proporciona un mecanismo, conocido como <code>CompletionService</code>, que nos permite crear un objeto que act\u00faa como servicio intermedio de almacenaje de los objetos <code>Future</code> correspondientes a tareas <code>Callable</code> que han completado su ejecuci\u00f3n. De esta manera el procesamiento de los resultados puede llevarse a cabo as\u00edncronamente en hilos diferentes a los que enviaron las tareas.</p> <p>La clase principal de este mecanismo es <code>ExecutorCompletionService</code>, que usa internamente un objeto ejecutor que implemente la interfaz <code>ExecutorService</code> y que deberemos suministrarlo en la construcci\u00f3n. Adem\u00e1s, la clase <code>ExecutorCompletionService</code> implementa la interfaz <code>CompletionService</code>, que establece los m\u00e9todos para enviar tareas al servicio y para extraer objetos <code>Future</code> del mismo.</p> <p> Figura 4 - ExecutorCompletionService</p> <p>De esta manera, el objeto <code>ExecutorCompletionService</code> act\u00faa como puente entre una serie de hilos productores que le env\u00edan tareas a trav\u00e9s de su m\u00e9todo <code>submit()</code>, y otra serie de hilos consumidores que extraen los objetos <code>Future</code> resultantes de la ejecuci\u00f3n de las tareas, por ejemplo a trav\u00e9s de su m\u00e9todo <code>poll()</code> para procesar resultados.</p> <p>Este mecanismo tiene la limitaci\u00f3n de que los hilos consumidores de resultados tan solo puede obtener los objetos <code>Future</code> de aquellas tareas que hayan finalizado su ejecuci\u00f3n, por lo que \u00fanicamente pueden ser usados para obtener el resultado de las tareas y no para otras operaciones de control, como por ejemplo la cancelaci\u00f3n de las tareas. De hecho, cuando un hilo consumidor extraiga un <code>Future</code> de la cola del <code>ExecutorCompletionService</code> dicho <code>Future</code> forzosamente habr\u00e1 sido completado (<code>isDone()</code> retornar\u00e1 <code>true</code>), por lo que si se llama al m\u00e9todo <code>get()</code> sobre dicho <code>Future</code> nunca quedar\u00e1 bloqueado.</p> <p>La interfaz <code>CompletionService</code> proporciona los siguientes m\u00e9todos para enviar tareas:</p> <ul> <li><code>submit(callable)</code>: Env\u00eda un <code>Callable</code> al ejecutor para que sea ejecutado. El resultado de la tarea ser\u00e1 encolado en el servicio.</li> <li><code>submit(runnable, returnValue)</code>: Env\u00eda un <code>Runnable</code> al ejecutor. Una vez concluida su ejecuci\u00f3n el <code>returnValue</code> indicado se establece como valor del <code>Future</code> que es encolado en el servicio.</li> </ul> <p>\u00a1OJO!</p> <p>Aunque estos m\u00e9todos retornan un <code>Future</code>, no debemos usarlo, ya que todo el prop\u00f3sito de usar un <code>CompletionService</code> es que los hilos productores no act\u00faen como consumidores de los resultados.</p> <p>Por otra parte, la interfaz <code>CompletionService</code> proporciona los siguientes m\u00e9todos para obtener los objetos <code>Future</code> correspondiente al resultado de la ejecuci\u00f3n de las tareas:</p> <ul> <li><code>Future&lt;V&gt; poll()</code>: Extrae de la cola interna del servicio el objeto <code>Future</code> correspondiente al resultado de la siguiente tarea completada o <code>null</code> si no hay ninguno.</li> <li><code>Future&lt;V&gt; poll(long timeout, TimeUnit unit)</code>: Extrae de la cola interna el objeto <code>Future</code> correspondiente al resultado de la siguiente tarea completada, esperando si es necesario el tiempo m\u00e1ximo pasado como argumento. Lanza la excepci\u00f3n <code>InterruptedException</code> si el hilo es interrumpido mientras esperaba.</li> <li><code>Future&lt;V&gt; take()</code>: Extrae de la cola interna el objeto <code>Future</code> correspondiente al resultado de la siguiente tarea completada, bloqueando el hilo hasta que la cola tenga alg\u00fan elemento. Lanza la excepci\u00f3n <code>InterruptedException</code> si el hilo es interrumpido mientras esperaba.</li> </ul>"},{"location":"bloque_v/tema_26/page-18/#proyecto-executorcompletionservice","title":"Proyecto ExecutorCompletionService","text":"<p>En este proyecto vamos a desarrollar una aplicaci\u00f3n en la que varios hilos solicitantes solicitan el c\u00e1lculo de factoriales a un <code>ExecutorCompletionService</code>. Por otro lado, un hilo consumidor de resultados va obteniendo del <code>ExecutorCompletionService</code> los resultados uno a uno y los muestra por pantalla.</p> <p>La tarea de c\u00e1lculo que se env\u00eda est\u00e1 representada por la clase <code>Task</code>, que implementa la interfaz <code>Callable&lt;FactorialCalculation&gt;</code>. El resultado del c\u00e1lculo est\u00e1 representado por la clase <code>FactorialCalculation</code>, que contiene informaci\u00f3n sobre qui\u00e9n la solicit\u00f3, cu\u00e1ndo, con qu\u00e9 valor, y el resultado obtenido o la excepci\u00f3n lanzada durante el c\u00e1lculo.</p> <p>Para representar el hecho de que haya un resultado o se haya producido una excepci\u00f3n definimos una clase <code>ResultOrThrowable&lt;T&gt;</code>.</p> MainResultOrThrowableFactorialCalculationTaskTaskProducerTaskConsumer <pre><code>import java.util.concurrent.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        CompletionService&lt;FactorialCalculation&gt; completionService\n                = new ExecutorCompletionService&lt;&gt;(executor);\n        Thread taskProducer1 = new Thread(new TaskProducer(\"Task producer 1\", completionService));\n        Thread taskProducer2 = new Thread(new TaskProducer(\"Task producer 2\", completionService));\n        Thread taskConsumer = new Thread(new TaskConsumer(completionService));\n        taskProducer1.start();\n        taskProducer2.start();\n        taskConsumer.start();\n        try {\n            TimeUnit.SECONDS.sleep(15);\n            taskConsumer.interrupt();\n            taskConsumer.join();\n        } catch (InterruptedException ignored) {\n        } finally {\n            executor.shutdownNow();\n        }\n    }\n\n}\n</code></pre> <pre><code>class ResultOrThrowable&lt;T&gt; {\n\n    private final T result;\n    private final Throwable throwable;\n\n    private ResultOrThrowable(T result, Throwable throwable) {\n        this.result = result;\n        this.throwable = throwable;\n    }\n\n    T getResult() {\n        return result;\n    }\n\n    Throwable getThrowable() {\n        return throwable;\n    }\n\n    static &lt;T&gt; ResultOrThrowable&lt;T&gt; newResult(T result) {\n        return new ResultOrThrowable&lt;&gt;(result, null);\n    }\n\n    static &lt;T&gt; ResultOrThrowable&lt;T&gt; newThrowable(Throwable throwable) {\n        return new ResultOrThrowable&lt;&gt;(null, throwable);\n    }\n\n}\n</code></pre> <pre><code>class FactorialCalculation {\n\n    private final String requester;\n    private final int value;\n    private final String when;\n    private final ResultOrThrowable&lt;Integer&gt; resultOrThrowable;\n\n    FactorialCalculation(String requester, int value, String when, \n                        ResultOrThrowable&lt;Integer&gt; resultOrException) {\n        this.requester = requester;\n        this.value = value;\n        this.when = when;\n        this.resultOrThrowable = resultOrException;\n    }\n\n    String getRequester() {\n        return requester;\n    }\n\n    int getValue() {\n        return value;\n    }\n\n    String getWhen() {\n        return when;\n    }\n\n    Integer getResult() {\n        return resultOrThrowable.getResult();\n    }\n\n    Throwable getThrowable() {\n        return resultOrThrowable.getThrowable();\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.Callable;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\nclass Task implements Callable&lt;FactorialCalculation&gt; {\n\n    private final String requester;\n    private final int value;\n    private final String when;\n\n    Task(String requester, int value, String when) {\n        this.requester = requester;\n        this.value = value;\n        this.when = when;\n    }\n\n    @Override\n    public FactorialCalculation call() {\n        Integer factorial;\n        ResultOrThrowable&lt;Integer&gt; resultOrThrowable;\n        try {\n            factorial = factorial(value);\n            resultOrThrowable = ResultOrThrowable.newResult(factorial);\n        } catch (Exception e) {\n            resultOrThrowable = ResultOrThrowable.newThrowable(e);\n        }\n        return new FactorialCalculation(requester, value, when, resultOrThrowable);\n    }\n\n    private Integer factorial(int number) throws InterruptedException {\n        if (number &lt; 0) throw new IllegalArgumentException(\"Number can't be negative\");\n        int factorial = 1;\n        for (int i = 2; i &lt;= number; i++) {\n            factorial *= i;\n        }\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5) + 1);\n        return factorial;\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.CompletionService;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\nclass TaskProducer implements Runnable {\n\n    private final DateTimeFormatter dateTimeFormatter =\n            DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n    private final String name;\n    private final CompletionService&lt;FactorialCalculation&gt; completionService;\n\n    TaskProducer(String name, CompletionService&lt;FactorialCalculation&gt; completionService) {\n        this.name = name;\n        this.completionService = completionService;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 10; i++) {\n            int value = ThreadLocalRandom.current().nextInt(15) - 5;\n            String when = dateTimeFormatter.format(LocalTime.now());\n            System.out.printf(\"%s -&gt; %s requests factorial(%d) at %s\\n\",\n                    Thread.currentThread().getName(), name, value, when);\n            completionService.submit(new Task(name, value, when));\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                System.out.printf(\"%s -&gt; %s interrupted\\n\",\n                        Thread.currentThread().getName(), name);\n                return;\n            }\n        }\n        System.out.printf(\"%s -&gt; %s finished\\n\",\n                Thread.currentThread().getName(), name);\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.CompletionService;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\n\nclass TaskConsumer implements Runnable {\n\n    private final CompletionService&lt;FactorialCalculation&gt; completionService;\n\n    TaskConsumer(CompletionService&lt;FactorialCalculation&gt; completionService) {\n        this.completionService = completionService;\n    }\n\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            Future&lt;FactorialCalculation&gt; taskResultFuture;\n            try {\n                taskResultFuture = completionService.take();\n                if (taskResultFuture != null) {\n                    FactorialCalculation factorialCalculation = taskResultFuture.get();\n                    if (factorialCalculation.getThrowable() == null) {\n                        showResult(factorialCalculation);\n                    } else {\n                        showError(factorialCalculation);\n                    }\n                }\n            } catch (InterruptedException e) {\n                System.out.printf(\"%s -&gt; Task consumer interrupted\\n\",\n                        Thread.currentThread().getName());\n                return;\n            } catch (ExecutionException e) {\n                System.out.printf(\"%s -&gt; Task consumer calculation poll - Error calculating factorial\\n\",\n                        Thread.currentThread().getName());\n            }\n        }\n        System.out.printf(\"%s -&gt; Task consumer finished\\n\",\n                Thread.currentThread().getName());\n    }\n\n    private void showError(FactorialCalculation factorialCalculation) {\n        System.out.printf(\"%s -&gt; Task consumer calculation poll - factorial(%d) threw %s, requested by %s at %s\\n\",\n                Thread.currentThread().getName(), factorialCalculation.getValue(),\n                factorialCalculation.getThrowable().getClass().getSimpleName(), factorialCalculation.getRequester(),\n                factorialCalculation.getWhen());\n    }\n\n    private void showResult(FactorialCalculation factorialCalculation) {\n        System.out.printf(\"%s -&gt; Task consumer calculation poll - factorial(%d) = %d requested by %s at %s\\n\",\n                Thread.currentThread().getName(), factorialCalculation.getValue(),\n                factorialCalculation.getResult(), factorialCalculation.getRequester(),\n                factorialCalculation.getWhen());\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_26/page-19/","title":"19 FutureTask","text":""},{"location":"bloque_v/tema_26/page-19/#futuretask","title":"FutureTask","text":"<p>La clase <code>FutureTask</code> permite encapsular en un mismo objeto las funcionalidades de operaci\u00f3n ejecutable y de un resultado futuro, es decir, de un <code>Runnable</code> y de un <code>Future</code>. De hecho, esta clase implementa la interfaz <code>RunnableFuture&lt;V&gt;</code>, que a su vez extiende de las interfaces <code>Runnable</code> y <code>Future&lt;V&gt;</code>.</p> <pre><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {\n    void run();\n}\n</code></pre> <p>Representa por tanto una operaci\u00f3n as\u00edncrona con una serie de caracter\u00edsticas muy importantes:</p> <ul> <li>Se puede ejecutar directamente en un hilo gestionado por nosotros mismos, o puede ser enviada a un ejecutor para que la ejecute, dado que implementa la interfaz <code>Runnable</code>, y por tanto dispone del m\u00e9todo <code>run()</code>.</li> <li>Puede ser cancelada en cualquier momento, dado que implementa la interfaz <code>Future</code>, a trav\u00e9s de su m\u00e9todo <code>cancel(mayInterruptIfRunning)</code></li> <li>Permite consultar si la operaci\u00f3n se ha completado, dado que implementa la interfaz <code>Future</code>, a trav\u00e9s de su m\u00e9todo <code>isDone()</code>.</li> <li>Podemos obtener el resultado de la operaci\u00f3n, dado que implementa la interfaz <code>Future</code>, a trav\u00e9s del m\u00e9todo <code>get()</code>, que es bloqueante.</li> </ul> <p>La clase <code>FutureTask</code> nos permite envolver un <code>Callable</code> que queramos ejecutar, que es recibido a trav\u00e9s del constructor. El m\u00e9todo <code>run()</code> del <code>FutureTask</code> llamar\u00e1 al m\u00e9todo <code>call()</code> del <code>Callable</code> que envuelve, y establecer\u00e1 el valor resultante de la llamada como valor del propio <code>FutureTask</code>.</p> <p>Existe otra opci\u00f3n, consistente en pasar al constructor de la clase <code>FutureTask</code> un runnable junto a un valor de retorno. Internamente se crear\u00e1 un <code>Callable</code> cuyo m\u00e9todo <code>call()</code> consiste en llamar al m\u00e9todo <code>run()</code>del runnable y retornar el valor indicado. El m\u00e9todo <code>run()</code> del <code>FutureTask</code> llamar\u00e1 al m\u00e9todo <code>call()</code> del <code>Callable</code> creado, y establecer\u00e1 el valor resultante de la llamada como valor del propio <code>FutureTask</code>.</p> <p>Adem\u00e1s de toda la funcionalidad proporcionada por las interfaces <code>Runnable</code> y <code>Future</code>, la clase <code>FutureTask</code> proporciona un m\u00e9todo llamado <code>done()</code>, que es llamado internamente cuando el <code>FutureTask</code> se da por completado, estos es, cuando <code>isDone()</code> pasa a ser <code>true</code>, independientemente de si la tarea ha sido cancelada, la llamada al m\u00e9todo <code>call()</code> ha finalizado normalmente y se ha establecido el valor retornado como valor del propio <code>FutureTask</code>, o el m\u00e9todo <code>call()</code> del callable ha lanzado una excepci\u00f3n.</p> <p>Podemos sobrescribir este m\u00e9todo <code>done()</code>, permiti\u00e9ndonos ejecutar c\u00f3digo una vez haya terminado de ejecutarse la tarea. Podemos usar esta caracter\u00edstica para realizar operaciones de post-procesamiento, generar un informe, enviar resultados por e-mail, o liberar alg\u00fan recurso que estuvi\u00e9ramos utilizando, etc., aunque no podremos cambiar el valor retornado o el estado de la tarea. Si desde el m\u00e9todo <code>done()</code> queremos acceder al valor retornado por la tarea podemos usar el m\u00e9todo <code>get()</code> del <code>FutureTask</code>.</p> <p>Por ejemplo, la clase <code>ExecutorCompletionService</code> hace uso de una extensi\u00f3n de la clase <code>FutureTask</code>, llamada <code>ExecutorCompletionService.QueueingFuture</code>, que sobrescribe el m\u00e9todo <code>done()</code> para que cada <code>Future</code> ejecutado por el ejecutor asociado al <code>ExecutorCompletionService</code> cuando termine su ejecuci\u00f3n se auto encole en la cola de tareas completadas.</p>"},{"location":"bloque_v/tema_26/page-19/#proyecto-futuretask","title":"Proyecto FutureTask","text":"<p>En este proyecto crearemos dos FutureTask que envuelve dos Callable que calculan dos factoriales distintos. La primera FutureTask ser\u00e1 ejecutada a trav\u00e9s de un hilo que crearemos expresamente para ello y la segunda FutureTask ser\u00e1 enviada a un ejecutor.</p> <p>Las FutureTask est\u00e1n dise\u00f1adas para que muestren por pantalla cuando se han completado si ha sido cancelada, ha finalizado el c\u00e1lculo correctamente o se ha producido una excepci\u00f3n.</p> MainLogFutureTaskFactorialTask <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        final DateTimeFormatter dateTimeFormatter =\n                DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        ExecutorService executor = Executors.newCachedThreadPool();\n        LogFutureTask&lt;Integer&gt; task1 = new LogFutureTask&lt;&gt;(new FactorialTask(-1));\n        LogFutureTask&lt;Integer&gt; task2 = new LogFutureTask&lt;&gt;(new FactorialTask(4));\n        Thread thread = new Thread(task1);\n        System.out.printf(\"%s - %s - Task1 started\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()));\n        thread.start();\n        System.out.printf(\"%s - %s - Task2 sent\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()));\n        executor.submit(task2);\n        executor.shutdown();\n        TimeUnit.SECONDS.sleep(2);\n        //task1.cancel(true);\n        //task2.cancel(true);\n        thread.join();\n        executor.awaitTermination(1, TimeUnit.MINUTES);\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class LogFutureTask&lt;V&gt; extends FutureTask&lt;V&gt; {\n\n    private final DateTimeFormatter dateTimeFormatter =\n            DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    LogFutureTask(Callable&lt;V&gt; callable) {\n        super(callable);\n    }\n\n    @Override\n    protected void done() {\n        if (isCancelled()) {\n            System.out.printf(\"%s - %s - Operation cancelled\\n\",\n                    Thread.currentThread().getName(),\n                    dateTimeFormatter.format(LocalTime.now()));\n        } else {\n            try {\n                V value = get();\n                System.out.printf(\"%s - %s - Result: %s\\n\",\n                        Thread.currentThread().getName(),\n                        dateTimeFormatter.format(LocalTime.now()),\n                        value);\n            } catch (InterruptedException ignored) {\n            } catch (ExecutionException e) {\n                System.out.printf(\"%s - %s - %s\\n\",\n                        Thread.currentThread().getName(),\n                        dateTimeFormatter.format(LocalTime.now()),\n                        e.getClass().getSimpleName());\n            }\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\nclass FactorialTask implements Callable&lt;Integer&gt; {\n\n    private final int number;\n\n    FactorialTask(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public Integer call() throws InterruptedException {\n        return factorial(number);\n    }\n\n    private Integer factorial(int number) throws InterruptedException {\n        if (number &lt; 0) throw new IllegalArgumentException(\"Number can't be negative\");\n        int factorial = 1;\n        for (int i = 2; i &lt;= number; i++) {\n            factorial *= i;\n            TimeUnit.SECONDS.sleep(1);\n        }\n        return factorial;\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_26/page-2/","title":"2 La Interfaz Executor","text":""},{"location":"bloque_v/tema_26/page-2/#la-interfaz-executor","title":"La interfaz Executor","text":"<p>La interfaz <code>Executor</code> es una interfaz funcional que implementan (indirectamente) todos los ejecutores que iremos estudiando, y que posee el m\u00e9todo <code>execute(runnable)</code>para enviar al ejecutor una tarea en forma de objeto runnable para que sea ejecutada en alguno de los hilos que gestiona. La llamada al m\u00e9todo no retornar\u00e1 ning\u00fan valor.</p> <pre><code>public interface Executor {\n    void execute(Runnable command);\n}\n</code></pre> <p>El m\u00e9todo lanzar\u00e1 la excepci\u00f3n <code>NullPointerException</code> si le pasamos <code>null</code> como runnable, o <code>RejectedExecutionException</code> si la tarea no pudo ser aceptada para su ejecuci\u00f3n, por ejemplo porque el ejecutor ya ha sido terminado, como estudiaremos m\u00e1s adelante.</p> <p>La interfaz <code>Executor</code> tiene importantes limitaciones:</p> <ul> <li>S\u00f3lo admite enviar tareas en forma de objetos runnable. Dado que el m\u00e9todo <code>run()</code> de los runnables no retorna un valor, es complicado hacer que una tarea retorne un valor a qui\u00e9n lo haya llamado.</li> <li>No proporciona ninguna forma de hacer un seguimiento del progreso de la ejecuci\u00f3n de las tareas runnable enviadas al ejecutor, cancelar la tarea, o simplemente determinar cu\u00e1ndo ha concluido su ejecuci\u00f3n.</li> <li>No proporciona una forma directa de ejecutar una colecci\u00f3n de runnables.</li> <li>No proporciona a la aplicaci\u00f3n una forma de terminar (detener) un ejecutor y sus hilos, liberando los recursos obtenidos.</li> </ul> <p>Como veremos m\u00e1s adelante, estas limitaciones ser\u00e1n solventadas por la interfaz <code>ExecutorService</code>, que extiende <code>Executor</code>.</p>"},{"location":"bloque_v/tema_26/page-20/","title":"Ejercicios","text":"CachedThreadPool Project <p>Realiza un proyecto haciendo uso de <code>CachedThreadPool</code> que ejecute la tabla de potencias de los n\u00fameros del 1 al 10. Entre cada tabla debe pasar 200 milisegundos. Luego, apaga/cierra el CachedTreadPool.</p> FixedThreadPool Project <p>Realiza un proyecto igual que el anterior, pero en esta ocasi\u00f3n haz uso de <code>FixedThreadPool</code>.</p> InvokeAll Project <p>Realiza un programa multihilo en Java que dada una matriz de dos dimensiones, halle la suma de sus filas, siendo cada una de \u00e9stas un hilo en Java. Haz uso de <code>ThreadPoolExecutor</code> y el m\u00e9todo <code>invokeAll</code>. Finalmente, muestra la suma completa de la matriz.</p> InvokeAny Project <p>Realiza una aplicaci\u00f3n multihilo que dada una matriz de dimensiones NxM y un n\u00famero, busque dicho n\u00famero por cada fila de la matriz, retornando como resultado la columna y la fila en la que se encuentra. Realiza el proyecto haciendo uso de un <code>ThreadPoolExecutor</code> y su m\u00e9todo <code>invokeAny</code>.</p> Schedule Project <p>Realiza un programa en Java haciendo uso del multihilo, que se asemeje al juego de MARCO-POLO. Haz uso de <code>ScheduleExecutorsService</code> teniendo en cuenta lo siguiente:</p> <ul> <li>La tarea encargada de decir Marco se ejecutar\u00e1 al segundo de ser enviada.</li> <li>La tarea encargada de decir Polo se ejecutar\u00e1 a los dos segundos de ser enviada.</li> <li>Las tareas se repetir\u00e1n en un per\u00edodo de dos segundos.</li> <li>Si las tareas son canceladas, deben ser eliminadas inmediatamente desde su cancelaci\u00f3n.</li> <li>Si se para al executor las tareas peri\u00f3dicas que est\u00e1n en espera, no ser\u00e1n ejecutadas jam\u00e1s.</li> </ul> ExecutorCompletionService Project <p>Realiza el proyecto InvokeAll haciendo uso de un CompletionService.</p>"},{"location":"bloque_v/tema_26/page-3/","title":"3 Creaci\u00f3n de un ThreadPoolExecutor","text":""},{"location":"bloque_v/tema_26/page-3/#creacion-de-un-threadpoolexecutor","title":"Creaci\u00f3n de un ThreadPoolExecutor","text":"<p>El primer paso para trabajar con el Executor framework es crear un objeto ejecutor. Todas la clases que representan ejecutores extienden de la clase abstracta <code>AbstractExecutorService</code>, que a su vez implementa la interfaz <code>ExecutorService</code>, y por ello <code>Executor</code>.</p> <p>Aunque existen distintas clases que definen tipos de ejecutores, comenzaremos con la clase <code>ThreadPoolExecutor</code>, que extiende <code>AbstractExecutorService</code>.</p> <p>Internamente un <code>ThreadPoolExecutor</code> se configura en base a los siguientes par\u00e1metros:</p> <ul> <li>corePoolSize: N\u00famero de hilos que deben mantenerse en el pool incluso aunque est\u00e9n sin ejecutar ninguna tarea.</li> <li>maximumPoolSize: N\u00famero m\u00e1ximo de hilos que puede haber en el threadpool.</li> <li>keepAliveTime: Indica el tiempo m\u00e1ximo que un hilo esperar\u00e1 a que le entreguen una nueva tarea antes de finalizar, siempre y cuando el n\u00famero actual de hilos del threadpool sea mayor que corePoolSize. Esto permite que los hilos se vayan finalizando cuando ya no son necesarios y que el tama\u00f1o del threadpool vaya decreciendo.</li> <li>keepAliveTimeUnit: Unidad de tiempo correspondiente al valor de keepAliveTime.</li> <li>workQueue: Cola de trabajo <code>BlockingQueue&lt;Runnable&gt;</code>en la que se almacenan las tareas antes de ser ejecutadas.</li> <li>threadFactory: Factor\u00eda de hilos que usa el ejecutor para crear un hilo cuando es necesario. Corresponder\u00e1 a un objeto de una clase que implemente la interfaz <code>ThreadFactory</code>. Si no se establece se crea una por defecto, correspondiente al objeto retornado por el m\u00e9todo est\u00e1tico factor\u00eda <code>Executors.defaultThreadFactory()</code>.</li> <li>rejectedExecutionHandler: Gestor de tareas que hayan sido rechazadas por el ejecutor. Corresponder\u00e1 a un objeto de una clase que implemente la interfaz <code>RejectedExecutionHandler</code>. Si no se establece uno, la excepci\u00f3n <code>RejectedException</code> no ser\u00e1 gestionada por el ejecutor sino que simplemente ser\u00e1 lanzada.</li> </ul> <p>La clase <code>ThreadPoolExecutor</code> posee distintos constructores sobrecargados para crear un threadpool executor configurando los par\u00e1metros anteriores. Por ejemplo, el m\u00e1s simple corresponde a:</p> <pre><code>ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, \n                   keepAliveTimeUnit, workQueue)\n</code></pre> <p>Tambi\u00e9n tendremos los m\u00e9todos getter y setter correspondientes a dichos par\u00e1metros de configuraci\u00f3n del ejecutor, como <code>getCorePoolSize()</code>, <code>setCorePoolSize()</code>, etc., excepto <code>setQueue(blockingQueue)</code>, que no existe.</p> <p>Dado que se tratan de muchos par\u00e1metros y que hay que entender bien el funcionamiento interno del ejecutor para poder configurarlos, la clase <code>Executors</code> nos facilita la construcci\u00f3n de ejecutores proporcion\u00e1ndonos una serie de m\u00e9todos est\u00e1ticos factor\u00eda especializados en la creaci\u00f3n de los tipos de threadpool executors mas habituales, que llaman al constructor de la clase <code>ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, keepAliveTimeUnit, workQueue)</code> con los argumentos adecuados.</p> <p>As\u00ed tenemos los m\u00e9todos factor\u00eda <code>Executors.newCachedThreadPool()</code>, <code>Executors.newFixedThreadPool(numberOfThreads)</code>, <code>Executors.newSingleThreadExecutor()</code>, etc. Estudiaremos estos m\u00e9todos dentro de poco.</p> <p>La clase <code>ThreadPoolExecutor</code> proporciona algunos m\u00e9todos informativos que nos permiten obtener informaci\u00f3n sobre las tareas que ejecuta el ejecutor:</p> <ul> <li><code>getPoolSize()</code>: Retorna el n\u00famero actual de hilos en el threadpool gestionado por el ejecutor.</li> <li><code>getActiveCount()</code>: Retorna el n\u00famero de hilos que est\u00e1n actualmente ejecutando tareas en el ejecutor.</li> <li><code>getCompletedTaskCount()</code>: Retorna el n\u00famero de tareas completadas por el ejecutor.</li> <li><code>getTaskCount()</code>: Retorna el n\u00famero de tareas que han sido enviadas al ejecutor.</li> <li><code>getLargestPoolSize()</code>: Retorna el n\u00famero m\u00e1ximo de hilos que han sido utilizados a la vez por el ejecutor en un momento dado. Es decir, el tama\u00f1o m\u00e1ximo que ha alcanzado el threadpool.</li> </ul>"},{"location":"bloque_v/tema_26/page-4/","title":"4 Terminaci\u00f3n de un ejecutor","text":""},{"location":"bloque_v/tema_26/page-4/#terminacion-de-un-ejecutor","title":"Terminaci\u00f3n de un ejecutor","text":"<p>La interfaz <code>ExecutorService</code> extiende la interfaz <code>Executor</code> para proporcionar la funcionalidad que solvente las limitaciones de \u00e9sta \u00faltima. Este aspecto es muy importante, ya que los ejecutores est\u00e1n dise\u00f1ados de manera que si no se termina su ejecuci\u00f3n expl\u00edcitamente, el programa que lo uso nunca terminar\u00e1, incluso aunque el ejecutor no tenga ninguna tarea para ejecutar, dado que los hilos del ejecutor seguir\u00e1n vivos.</p> <p>Por este motivo, la interfaz <code>ExecutorService</code> proporciona, entre otras cosas, una serie de m\u00e9todos que permitan a la aplicaci\u00f3n terminar (detener) un ejecutor y sus hilos, liberando los recursos obtenidos.</p> <p>Veamos parte de la definici\u00f3n de la interfaz <code>ExecutorService</code>:</p> <pre><code>public interface ExecutorService extends Executor {\n\n    // M\u00e9todos relacionados con el control del ciclo de vida de los ejecutores\n    void shutdown();\n    List&lt;Runnable&gt; shutdownNow();\n    boolean isShutdown();\n    boolean isTerminated();\n    boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    // ...\n\n}\n</code></pre> <p>As\u00ed, tenemos el m\u00e9todo <code>shutdown()</code>, que termina el ejecutor, de manera que ya no se aceptan m\u00e1s tareas nuevas en \u00e9l, que son rechazadas, pero a las tareas que estuvieran ejecut\u00e1ndose o las que ya hubieran sido recibidas y a\u00fan no se hayan ejecutado se les permitir\u00e1 concluir su ejecuci\u00f3n. A este se le conoce como terminaci\u00f3n \"ordenada\".</p> <p>Pero si queremos llevar a cabo una terminaci\u00f3n de ejecutor mucho m\u00e1s dr\u00e1stica, podemos llamar al m\u00e9todo <code>shutdownNow()</code>, que termina el ejecutor inmediatamente, de manera que las nuevas tareas que le lleguen son rechazadas y los hilos del threadpool en los que se est\u00e1n ejecutando tareas en ese momento son marcados para interrupci\u00f3n, aunque no hay garant\u00eda de que las tareas decidan detectar la interrupci\u00f3n y finalizar su ejecuci\u00f3n. Las tareas que estuvieran en el ejecutor pendientes de comenzar su ejecuci\u00f3n no llegar\u00e1n a ser ejecutadas, y se retornar\u00e1 un lista <code>List&lt;Runnable&gt;</code>con \u00e9stas. El m\u00e9todo retorna inmediatamente, sin esperar a que las tareas que ya est\u00e1n en ejecuci\u00f3n terminen de ejecutarse.</p> <p>Si despu\u00e9s de haber llamado al m\u00e9todo <code>shutdown()</code> o <code>shutdownNow()</code> tratamos de enviar alguna otra tarea al ejecutor, \u00e9sta ser\u00e1 rechazada y el ejecutor lanzar\u00e1 una excepci\u00f3n <code>RejectedExecutionException</code> en la llamada al m\u00e9todo que ha sido usado para el env\u00edo.</p> <p>Si queremos esperar a la terminaci\u00f3n del ejecutor, es decir a que todas las tareas que gestiona terminen de ejecutarse, podemos llamar al m\u00e9todo <code>awaitTermination(long timeout, TimeUnit unit)</code>, que bloquea el hilo en el que se realiza la llamada hasta que las tareas del ejecutor hayan terminado o transcurre el tiempo m\u00e1ximo de espera (timeout). Este m\u00e9todo retorna un booleano indicativo de si realmente termin\u00f3 el ejecutor. Si se sobrepasa el tiempo de espera m\u00e1ximo se retornar\u00e1 <code>false</code>.</p> <p>Debemos tener en cuenta que si llamamos a <code>awaitTermination()</code> sin haber llamado antes a <code>shutdown()</code> o <code>shutdownNow()</code>, la llamada a <code>awaitTermination()</code> retornar\u00e1 inmediatamente y no tendr\u00e1 ning\u00fan efecto.</p> <p>Una de las opciones recomendadas para terminar un ejecutor es usar una combinaci\u00f3n de los m\u00e9todos anteriores, tratando de finalizar el ejecutor de forma ordenada, esperando un tiempo prudencial a su terminaci\u00f3n, transcurrido el cu\u00e1l se fuerza la finalizaci\u00f3n:</p> <pre><code>executorService.shutdown();\ntry {\n    if (!executorService.awaitTermination(1, TimeUnit.SECONDS)) {\n        executorService.shutdownNow();\n    } \n} catch (InterruptedException e) {\n    executorService.shutdownNow();\n}\n</code></pre> <p>Adem\u00e1s tendremos disponibles otros m\u00e9todos informativos relacionados con la finalizaci\u00f3n del ejecutor:</p> <ul> <li><code>isShutdown()</code>: Retorna <code>true</code> si se ha llamado al m\u00e9todo <code>shutdown()</code> o <code>shutdownNow()</code> del ejecutor.</li> <li><code>isTerminating()</code>: Retorna <code>true</code> si el ejecutor est\u00e1 realizando la operaci\u00f3n de finalizar su ejecuci\u00f3n, despu\u00e9s de haber sido llamado el m\u00e9todo <code>shutdown)</code> o <code>shutdownNow()</code>, pero no ha concluido a\u00fan.</li> <li><code>isTerminated()</code>: Retorna <code>true</code> si se ha llamado al m\u00e9todo <code>shutdown()</code> o <code>shutdownNow()</code> del ejecutor y todas las tareas han finalizado su ejecuci\u00f3n.</li> </ul>"},{"location":"bloque_v/tema_26/page-5/","title":"5 CachedThreadPool","text":""},{"location":"bloque_v/tema_26/page-5/#cachedthreadpool","title":"CachedThreadPool","text":"<p>Uno de los tipos de ThreadPoolExecutor que podemos crear es lo que se conoce como cached thread pool (grupo de hilos cacheado), que se caracteriza porque cuando recibe una nueva tarea que ejecutar, trata de ejecutarla en alg\u00fan hilo del thread pool que est\u00e9 \"libre\", y si todos los hilos del threadpool est\u00e1n ocupados ejecutando otras tareas, el ejecutor crea un nuevo hilo que es a\u00f1adido al thread pool y ejecuta en \u00e9l la tarea recibida.</p> <p>Para crear un cached thread pool executor usaremos el m\u00e9todo est\u00e1tico factor\u00eda <code>Executors.newCachedThreadPool()</code>, que retorna un objeto de la interfaz <code>ExecutorService</code>, al que haremos un cast a <code>ThreadPoolExecutor</code>.</p> <pre><code>ThreadPoolExecutor cachedThreadPoolExecutor = \n    (ThreadPoolExecutor) Executors.newCachedThreadPool();\n</code></pre> <p>Este m\u00e9todo factor\u00eda est\u00e1 sobrecargado <code>Executors.newCachedThreadPool(threadFactory)</code> para recibir como argumento un objeto de la interfaz <code>ThreadFactory</code> (factor\u00eda de hilos) que ser\u00e1 usado para construir los hilos del threadpool cuando sea necesario, permiti\u00e9ndonos as\u00ed personalizar dicha construcci\u00f3n.</p> <p>Este tipo de ejecutor tiene el problema de que si enviamos muchas tareas a la vez o de manera muy seguida podremos sobrecargar el sistema, dado que el threadpool ir\u00e1 creciendo con cada nueva tarea recibida al estar todos sus hilos ocupados con otras tareas.</p> <p>Por otra parte, tenemos la ventaja de que las tareas siempre ser\u00e1n ejecutadas inmediatamente en cuanto hayan sido recibidas por el ejecutor, tanto si finalmente son ejecutadas en un hilo ya existente en el threadpool como si se hace crecer \u00e9ste creando y a\u00f1adiendo un nuevo hilo para ejecutar la tarea.</p> <p>Por tanto, cuanto m\u00e1s espaciadas en el tiempo lleguen en el tiempo y menos tiempo de ejecuci\u00f3n requieran, mejor ser\u00e1 el rendimiento de este tipo de ejecutor.</p> <p>Veamos la definici\u00f3n interna del m\u00e9todo <code>Executors.newCachedThreadPool()</code>, lo que nos servir\u00e1 para entender correctamente su funcionamiento:</p> <pre><code>public static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue&lt;Runnable&gt;());\n}\n</code></pre> <p>Como vemos, no es obligatorio mantener un n\u00famero m\u00ednimo de hilos, no hay un n\u00famero m\u00e1ximo de hilos, los hilos ser\u00e1n destruidos autom\u00e1ticamente tras 60 segundos de inactividad y la cola de trabajo corresponde a una <code>SynchronousQueue&lt;Runnable&gt;</code>, que se caracteriza porque la inserci\u00f3n en la cola de trabajo espera directamente a su extracci\u00f3n, dado que en realidad nunca habr\u00e1 m\u00e1s de una tarea en la cola puesto que se extraer\u00e1 inmediatamente de ella en cuanto llegue, creando un hilo adicional si todos los hilos actuales est\u00e1n ocupados.</p>"},{"location":"bloque_v/tema_26/page-5/#proyecto-cachedthreadpool","title":"Proyecto CachedThreadPool","text":"<p>En este proyecto simularemos el funcionamiento de un servidor web que procesa peticiones de varios clientes. Internamente el servidor har\u00e1 uso de un cached thread pool executor para ejecutar las tareas que le vayan llegando.</p> MainServerTask <pre><code>class Main {\n\n    public static void main(String[] args) {\n        Server server = new Server();\n        for (int i = 0; i &lt; 50; i++) {\n            Task task = new Task(\"Task \" + i);\n            server.execute(task);\n            try {\n                // The less time you sleep the greater the thread pool size gets.\n                // Try to reduce the time sleeping and see what happens to thread pool size.\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n        try {\n            server.shutdown();\n            // Try shutdownNow instead and see what happens.\n            // server.shutdownNow();\n        } catch (InterruptedException e) {\n            return;\n        }\n        Task task = new Task(\"Task sent after shutdown\");\n        server.execute(task);\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nclass Server {\n\n    private final ThreadPoolExecutor cachedThreadPool =\n            (ThreadPoolExecutor) Executors.newCachedThreadPool();\n\n    void execute(Task task) {\n        try {\n            cachedThreadPool.execute(task);\n            System.out.printf(\"Server -&gt; Thread pool size: %d\\n\", cachedThreadPool.getPoolSize());\n            System.out.printf(\"Server -&gt; Active threads count: %d\\n\", cachedThreadPool.getActiveCount());\n        } catch (Exception e) {\n            System.out.printf(\"Server -&gt; Task rejected: %s\\n\", task.getName());\n        }\n    }\n\n    void shutdown() throws InterruptedException {\n        cachedThreadPool.shutdown();\n        if (cachedThreadPool.awaitTermination(5, TimeUnit.SECONDS)) {\n            System.out.printf(\"Server -&gt; Terminated. Completed: %d\\n\",\n                    cachedThreadPool.getCompletedTaskCount());\n        } else {\n            System.out.printf(\"Server -&gt; Await termination timeout. Completed: %d\\n\",\n                    cachedThreadPool.getCompletedTaskCount());\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    void shutdownNow() throws InterruptedException {\n        cachedThreadPool.shutdownNow();\n        if (cachedThreadPool.awaitTermination(5, TimeUnit.SECONDS)) {\n            System.out.printf(\"Server -&gt; Terminated. Completed: %d\\n\",\n                    cachedThreadPool.getCompletedTaskCount());\n        } else {\n            System.out.printf(\"Server -&gt; Await termination timeout. Completed: %d\\n\",\n                    cachedThreadPool.getCompletedTaskCount());\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\nclass Task implements Runnable {\n\n    private final String name;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    Task(String name) {\n        this.name = name;\n    }\n\n    String getName() {\n        return name;\n    }\n\n    @Override\n    public void run() {\n        System.out.printf(\"%s -&gt; %s -&gt; Started at: %s\\n\",\n                Thread.currentThread().getName(), name, dateTimeFormatter.format(LocalDateTime.now()));\n        try {\n            work();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s -&gt; %s -&gt; Interrupted at: %s\\n\",\n                    Thread.currentThread().getName(), name, dateTimeFormatter.format(LocalDateTime.now()));\n            return;\n        }\n        System.out.printf(\"%s -&gt; %s -&gt; Finished at: %s\\n\",\n                Thread.currentThread().getName(), name, dateTimeFormatter.format(LocalDateTime.now()));\n    }\n\n    private void work() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(10));\n    }\n\n}\n</code></pre> <p>Si ejecutamos la aplicaci\u00f3n veremos que el servidor hace uso de un cached thread pool executor para ejecutar las tareas que le vayan llegando.</p>"},{"location":"bloque_v/tema_26/page-6/","title":"6 FixedThreadPool","text":""},{"location":"bloque_v/tema_26/page-6/#fixedthreadpool","title":"FixedThreadPool","text":"<p>Como vimos en el apartado anterior, si usamos un <code>ThreadPoolExecutor</code> creado mediante el m\u00e9todo <code>newCachedThreadPool()</code> de la clase <code>Executors</code> corremos el riesgo de sobrecargar el sistema, especialmente si el n\u00famero de tareas es alto y de larga duraci\u00f3n.</p> <p>Para evitar este problema, la clase <code>Executors</code> proporciona el m\u00e9todo est\u00e1tico factor\u00eda <code>Executors.newFixedThreadPool(numberOfThreads)</code> para crear un ejecutor que use como m\u00e1ximo el n\u00famero fijo de hilos que recibe como argumento.</p> <p>Este m\u00e9todo est\u00e1 sobrecargado <code>Executors.newFixedThreadPool(numberOfThreads, threadFactory)</code> para recibir tambi\u00e9n un objeto que implemente la interfaz <code>ThreadFactory</code>, cuyo m\u00e9todo <code>newThread(runnable)</code> ser\u00e1 llamado cuando sea necesario crear un hilo para el threadpool del ejecutor.</p> <p>Veamos la definici\u00f3n interna del m\u00e9todo factor\u00eda para comprender su funcionamiento:</p> <pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue&lt;Runnable&gt;());\n}\n</code></pre> <p>Por defecto, los hilos del thread pool se van creando bajo demanda conforme son necesarios, hasta alcanzar el n\u00famero de hilos indicado, pero una vez alcanzado dicho m\u00e1ximo dichos hilos no podr\u00e1n ser eliminados.</p> <p>Adem\u00e1s, cuando el ejecutor recibe una tarea y todos los hilos de su threadpool est\u00e1n ocupados y dicho n\u00famero corresponde al m\u00e1ximo permitido, el ejecutor no crear\u00e1 nuevos hilos, sino que la tarea ser\u00e1 almacenada en en la LinkedBlockingQueue proporcionada, esperando a que haya alg\u00fan hilo del threadpool disponible para ejecutarla.</p> <p>Si queremos que en el threadpool se cree directamente el n\u00famero de hilos con el que se ha configurado el ejecutor, podemos llamar a su m\u00e9todo <code>preStartAllCoreThreads()</code>, que crear\u00e1 e iniciar\u00e1 dichos hilos, que quedar\u00e1n en espera de tener alguna tarea que ejecutar. Tambi\u00e9n tenemos el m\u00e9todo <code>preStartCoreThreads()</code>, que crea e inicia un hilo del thead pool, quedando en espera de alguna tarea.</p> <p>Gracias a estos m\u00e9todos sobrescribimos la pol\u00edtica por defecto de crear e iniciar los hilos solo cuando llega una nueva tarea y no hay ning\u00fan hilo disponible.</p> <p>Cuando el ejecutor recibe una tarea y todos los hilos de su threadpool est\u00e1n ocupados y dicho n\u00famero corresponde al m\u00e1ximo permitido, el ejecutor no crear\u00e1 nuevos hilos, sino que, por defecto, la tarea ser\u00e1 almacenada en la LinkedBlockingQueue proporcionada, esperando a que haya alg\u00fan hilo del threadpool disponible para ejecutarla.</p> <p>El n\u00famero recomendado de hilos depende normalmente del n\u00famero de n\u00facleos de procesamiento disponibles y del tipo de tareas que se env\u00edan (intensivas de CPU o intensivas de E/S). Podemos obtener el n\u00famero de n\u00facleos de procesamiento disponibles en la m\u00e1quina en la que no estamos ejecutando mediante <code>Runtime.getRuntime().availableProcessors()</code>.</p> <p>Como norma general, si se van a enviar al ejecutor tareas intensivas de CPU (normalmente de corta duraci\u00f3n), se recomienda usar un tama\u00f1o de threadpool igual al n\u00famero de n\u00facleos de procesamiento + 1 (para prevenir potenciales pausas). Sin embargo, si se van a enviar al ejecutor tareas intensivas de entrada y salida, como por ejemplo de acceso a Internet o a una base de datos, se recomienda usar un tama\u00f1o de threadpool mayor, dado que los hilos ser\u00e1n bloqueados en entrada / salida, permitiendo as\u00ed a m\u00e1s tareas ejecutarse.</p> <p>Un caso extremo de este tipo de ejecutor es el que se obtiene llamando al m\u00e9todo est\u00e1tico factor\u00eda <code>Executors.newSingleThreadExecutor()</code>, que crea un ejecutor cuyo threadpool s\u00f3lo podr\u00e1 contener como m\u00e1ximo un solo hilo, por lo que, en la pr\u00e1ctica, las tareas son ejecutadas en dicho ejecutor de una en una de forma secuencial. El m\u00e9todo tambi\u00e9n est\u00e1 sobrecargado <code>Executor.newSingleThreadExecutor(threadFactory)</code> para recibir la factor\u00eda a usar para crear el hilo.</p> <p>La definici\u00f3n interna de este m\u00e9todo factor\u00eda es (m\u00e1s o menos) la siguiente:</p> <pre><code>public static ExecutorService newSingleThreadExecutor() {\n    return new ThreadPoolExecutor(1, 1,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue&lt;Runnable&gt;());\n}\n</code></pre>"},{"location":"bloque_v/tema_26/page-6/#politicas-de-saturacion","title":"Pol\u00edticas de saturaci\u00f3n","text":"<p>Llamamos saturaci\u00f3n, cuando llega una tarea al ejecutor y todos los hilos de su thread pool est\u00e1n ocupados ejecutando alguna tarea. La pol\u00edtica por defecto corresponder\u00e1 a que la tarea esperar\u00e1 en una cola hasta que pueda ser ejecutada por alguno de los hilos del ejecutor.</p> <p>Sin embargo, podemos configurar nuestro ejecutor para que implemente otras pol\u00edcitas, usando el m\u00e9todo <code>setRejectedExecutionHandler(handler)</code>.</p> <p>As\u00ed, tenemos predefinidos una serie de handlers que implementan distintas pol\u00edticas de rechazo:</p> <ul> <li><code>ThreadPoolExecutor.AbortPolicy</code>: Se lanza una excepci\u00f3n <code>RejectedExecutionException</code>.</li> <li><code>ThreadPoolExecutor.CallerRunsPolicy</code>: La tarea se ejecuta en el hilo que envi\u00f3 la tarea al ejecutor. De esta manera se implementa un mecanismo de control natural que hace que se ralentice la frecuencia de env\u00edo de tareas al ejecutor por parte del hilo emisor.</li> <li><code>ThreadPoolExecutor.DiscardPolicy</code>: Se descarta la tarea, que no es ejecutada.</li> <li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>: Si el ejecutor no est\u00e1 terminado, la tarea m\u00e1s antigua en la cola de espera es descartada y no llegar\u00e1 a ejecutarse, y se trata de ejecutar de nuevo la tarea enviada.</li> </ul>"},{"location":"bloque_v/tema_26/page-6/#proyecto-fixedthreadpool","title":"Proyecto FixedThreadPool","text":"<p>En este proyecto simularemos el funcionamiento de un servidor web que procesa peticiones de varios clientes usando internamente un fixed thread pool executor de como m\u00e1ximo 5 hilos.</p> MainServerTask <pre><code>class Main {\n\n    public static void main(String[] args) {\n        Server server = new Server();\n        for (int i = 0; i &lt; 50; i++) {\n            Task task = new Task(\"Task \" + i);\n            server.execute(task);\n            try {\n                // The less time you sleep the greater the thread pool size gets.\n                // Try to reduce the time sleeping and see what happens to thread pool size.\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n        try {\n            server.shutdown();\n            // Try shutdownNow instead and see what happens.\n            // server.shutdownNow();\n        } catch (InterruptedException exception) {\n            return;\n        }\n        Task task = new Task(\"Task sent after shutdown\");\n        server.execute(task);\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.Executors;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nclass Server {\n\n    private final ThreadPoolExecutor fixedThreadPool =\n            (ThreadPoolExecutor) Executors.newFixedThreadPool(5);\n\n    void execute(Task task) {\n        try {\n            fixedThreadPool.execute(task);\n            System.out.printf(\"Server -&gt; Thread pool size: %d\\n\", fixedThreadPool.getPoolSize());\n            System.out.printf(\"Server -&gt; Active threads count: %d\\n\", fixedThreadPool.getActiveCount());\n        } catch (RejectedExecutionException e) {\n            System.out.printf(\"Server -&gt; Task rejected: %s\\n\", task.getName());\n        }\n    }\n\n    void shutdown() throws InterruptedException {\n        fixedThreadPool.shutdown();\n        if (fixedThreadPool.awaitTermination(5, TimeUnit.SECONDS)) {\n            System.out.printf(\"Server -&gt; Terminated. Completed: %d\\n\",\n                    fixedThreadPool.getCompletedTaskCount());\n        } else {\n            System.out.printf(\"Server -&gt; Await termination timeout. Completed: %d\\n\",\n                    fixedThreadPool.getCompletedTaskCount());\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    void shutdownNow() throws InterruptedException {\n        fixedThreadPool.shutdownNow();\n        if (fixedThreadPool.awaitTermination(5, TimeUnit.SECONDS)) {\n            System.out.printf(\"Server -&gt; Terminated. Completed: %d\\n\",\n                    fixedThreadPool.getCompletedTaskCount());\n        } else {\n            System.out.printf(\"Server -&gt; Await termination timeout. Completed: %d\\n\",\n                    fixedThreadPool.getCompletedTaskCount());\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\n\nclass Task implements Runnable {\n\n    private final String name;\n    private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n\n    Task(String name) {\n        this.name = name;\n    }\n\n    String getName() {\n        return name;\n    }\n\n    @Override\n    public void run() {\n        System.out.printf(\"%s -&gt; %s -&gt; Started at: %s\\n\",\n                Thread.currentThread().getName(), name, dateTimeFormatter.format(LocalDateTime.now()));\n        try {\n            work();\n        } catch (InterruptedException e) {\n            System.out.printf(\"%s -&gt; %s -&gt; Interrupted at: %s\\n\",\n                    Thread.currentThread().getName(), name, dateTimeFormatter.format(LocalDateTime.now()));\n            return;\n        }\n        System.out.printf(\"%s -&gt; %s -&gt; Finished at: %s\\n\",\n                Thread.currentThread().getName(), name, dateTimeFormatter.format(LocalDateTime.now()));\n    }\n\n    private void work() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(10));\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos que el servidor no puede procesar m\u00e1s de 5 peticiones a la vez.</p>"},{"location":"bloque_v/tema_26/page-7/","title":"7 Callable","text":""},{"location":"bloque_v/tema_26/page-7/#la-interfaz-callable","title":"La interfaz Callable","text":"<p>Una de las ventajas de los ejecutores es que se pueden ejecutar tareas concurrentes que retornen un resultado. Para ello la API de concurrencia de Java proporciona la interfaz <code>Callable&lt;V&gt;</code>.</p> <p>La interfaz <code>Callable&lt;T&gt;</code> corresponde a una interfaz funcional parametrizada que permite representar una computaci\u00f3n (tarea) que, a diferencia de <code>Runnable</code>, retorna un valor. Contiene un \u00fanico m\u00e9todo llamado <code>call()</code>, que retorna un valor de tipo <code>T</code>.</p> <p>Veamos la definici\u00f3n interna de la interfaz <code>Callable&lt;V&gt;</code>.</p> <pre><code>@FunctionalInterface\npublic interface Callable&lt;V&gt; {\n    V call() throws Exception\n}\n</code></pre> <p>Debemos tener en cuenta que el m\u00e9todo <code>call()</code> puede lanzar tanto unchecked exceptions como checked exceptions, que podremos procesar implementando nuestro propio ejecutor que sobrescriba el m\u00e9todo <code>afterExecute()</code>.</p>"},{"location":"bloque_v/tema_26/page-8/","title":"8 Future","text":""},{"location":"bloque_v/tema_26/page-8/#la-interfaz-future","title":"La interfaz future","text":"<p>La interfaz <code>Future&lt;V&gt;</code> representa una tarea as\u00edncrona enviada a un ejecutor, cuyo resultado ser\u00e1 obtenido en un momento futuro. En otras palabras, corresponde a una promesa de valor. Se trata de una interfaz parametrizable, cuyo tipo <code>V</code> corresponder\u00e1 al tipo del valor retornado por la tarea.</p> <p>Veamos la definici\u00f3n de la interfaz <code>Future&lt;V&gt;</code>:</p> <pre><code>public interface Future&lt;V&gt; {\n\n    // M\u00e9todos relacionados con la obtenci\u00f3n del valor retornado\n    // por la tarea as\u00edncrona.\n    V get() throws InterruptedException, ExecutionException;\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n\n    // M\u00e9todos relacionados con la cancelaci\u00f3n de la tarea as\u00edncrona.\n    boolean cancel(boolean mayInterruptIfRunning);\n    boolean isCancelled();\n\n    // M\u00e9todos relacionados con la completitud de la tarea as\u00edncrona.\n    boolean isDone();\n\n}\n</code></pre> <p>Como vemos, cuando el hilo que env\u00edo la tarea as\u00edncrona al ejecutor desee acceder al valor que \u00e9sta haya retornado podr\u00e1 llamar al m\u00e9todo <code>get()</code> del objeto <code>Future&lt;V&gt;</code> que fue obtenido en respuesta al env\u00edo de la tarea al ejecutor.</p> <p>Si cuando llamamos al m\u00e9todo <code>get()</code> la tarea correspondiente ya ha terminado su ejecuci\u00f3n correctamente, directamente se nos retornar\u00e1 el valor del tipo <code>V</code> que haya retornado la tarea. Si la tarea hab\u00eda sido cancelada, se nos lanzar\u00e1 la excepci\u00f3n <code>CancellationException</code>.</p> <p>Si, por el contrario, para cuando llamamos al m\u00e9todo <code>get()</code> la tarea correspondiente a\u00fan no ha terminado de ejecutarse, el hilo que llama al m\u00e9todo <code>get()</code> quedar\u00e1 bloqueado en espera de que la tarea termine su ejecuci\u00f3n y retorne un valor del tipo <code>V</code>. Cuando la tarea concluya el valor retornado por \u00e9sta ser\u00e1 almacenado en el <code>Future</code> y se reactivar\u00e1 el hilo que fue bloqueado retorn\u00e1ndole el valor correspondiente. Si estando bloqueado el hilo que llam\u00f3 a <code>get()</code> \u00e9ste es interrumpido, se le lanzar\u00e1 la excepci\u00f3n <code>InterruptedException</code>.</p> <p>El m\u00e9todo <code>get(timeout, timeUnit)</code> est\u00e1 sobrecargado de manera que podamos pasarle el tiempo m\u00e1ximo que queremos que el hilo est\u00e9 esperando a que termine de ejecutarse la tarea correspondiente. Si transcurrido dicho tiempo la tarea no ha finalizado su ejecuci\u00f3n, el m\u00e9todo <code>get(time, timeUnit)</code> lanzar\u00e1 la excepci\u00f3n <code>TimeoutException</code>.</p> <p>Finalmente, si la tarea correspondiente termin\u00f3 su ejecuci\u00f3n lanzando una excepci\u00f3n, cuando llamemos al m\u00e9todo <code>get()</code> del objeto <code>Future</code> correspondiente, se lanzar\u00e1 la excepci\u00f3n <code>ExecutionException</code>, indicativa que en la tarea ejecutada en el ejecutor se produjo una excepci\u00f3n.</p> <p>Otra de las funcionalidades que nos proporciona la interfaz <code>Future</code>, a parte de obtener el valor retornado por la tarea, es la poder cancelar la tarea si ya no estamos interesados en que se ejecute o termine su ejecuci\u00f3n. Para ello, tenemos disponible el m\u00e9todo <code>cancel(mayInterruptIfRunning)</code>, que trata de marcar la tarea asociada como cancelada, retornando si se consigui\u00f3 marcar o no. As\u00ed, pueden darse los siguientes casos:</p> <ul> <li>Si la tarea ya hab\u00eda concluido su ejecuci\u00f3n, ya sea correctamente o con una excepci\u00f3n, evidentemente no podr\u00e1 ser marcada como cancelada, porque ya concluy\u00f3 su ejecuci\u00f3n, por lo que el m\u00e9todo <code>cancel(mayInterruptIfRunning)</code> retornar\u00e1 <code>false</code>.</li> <li>De igual forma, si la tarea ya hab\u00eda sido cancelada con anterioridad, no podr\u00e1 ser cancelada de nuevo, en cuyo caso tambi\u00e9n se retornar\u00e1 <code>false</code>.</li> <li>Si la tarea estaba en el ejecutor esperando poder comenzar su ejecuci\u00f3n, se marcar\u00e1 como cancelada, la tarea nunca llegar\u00e1 a ejecutarse, y se retornar\u00e1 <code>true</code>.</li> <li>Si la tarea estaba en ejecuci\u00f3n en el ejecutor para cuando se llama al m\u00e9todo <code>cancel(mayInterruptIfRunning)</code>, se marcar\u00e1 como cancelada y se retornar\u00e1 <code>true</code>. Adem\u00e1s, si el par\u00e1metro <code>mayInterruptIfRunning</code> recibe el valor <code>true</code> entonces el hilo del threadpool del ejecutor en el que se est\u00e1 ejecutando la tarea ser\u00e1 marcado como interrumpido. Depender\u00e1 ya del c\u00f3digo de la propia tarea detectar que el hilo ha sido interrumpido y finalizar su ejecuci\u00f3n. Como vemos la cancelaci\u00f3n real es colaborativa, es decir, que requiere de la colaboraci\u00f3n de la propia tarea. Si no pasamos el valor <code>true</code> para <code>mayInterruptIfRunning</code> o la tarea no hace caso al hecho de que el hilo en el que se est\u00e1 ejecutando haya sido marcado para interrupci\u00f3n, la tarea completar\u00e1 su ejecuci\u00f3n.</li> </ul> <p>Debemos tener en cuenta que una tarea ha sido marcada como cancelada, si llamamos al m\u00e9todo <code>get()</code> del objeto para obtener su valor <code>Future</code> correspondiente se lanzar\u00e1 la excepci\u00f3n <code>CancellationException</code>.</p> <p>Si queremos saber si la tarea asociada a un objeto <code>Future</code> ha sido marcada como cancelada podemos llamar a su m\u00e9todo <code>isCancelled()</code>.</p> <p>Finalmente, la interfaz <code>Future</code> proporciona el m\u00e9todo <code>isDone()</code>, que retorna <code>true</code> si la tarea asociada termin\u00f3 su ejecuci\u00f3n, ya sea correctamente, lanzando una excepci\u00f3n o porque no lleg\u00f3 a ejecutarse al ser cancelada antes de poder iniciar su ejecuci\u00f3n.</p>"},{"location":"bloque_v/tema_26/page-9/","title":"9 M\u00e9todos de env\u00edo de tareas en la interfaz ExecutorService","text":""},{"location":"bloque_v/tema_26/page-9/#metodos-de-envio-de-tareas-en-la-interfaz-executorservice","title":"M\u00e9todos de env\u00edo de tareas en la interfaz ExecutorService","text":"<p>La interfaz <code>ExecutorService</code>, adem\u00e1s de los m\u00e9todos para la terminaci\u00f3n de un ejecuci\u00f3n, que hemos estudiado anteriormente, define una serie de m\u00e9todos para el env\u00edo de tareas:</p> <pre><code>public interface ExecutorService extends Executor {\n\n    // ...\n\n    // M\u00e9todos relacionados con el env\u00edo de runnables.\n    Future&lt;?&gt; submit(Runnable task);\n    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);\n\n    // M\u00e9todos relacionados con el env\u00edo de callables.\n    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);\n    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n        throws InterruptedException;\n    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,\n                                  long timeout, TimeUnit unit)\n    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n        throws InterruptedException, ExecutionException;\n    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,\n                    long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n\n}\n</code></pre> <p>As\u00ed, la interfaz <code>ExecutorService</code> proporciona nuevos m\u00e9todos para enviar runnables a un ejecutor, pero que, a diferencia del m\u00e9todo <code>execute(runnable)</code> de la interfaz <code>Executor</code>, retornan un objeto de la interfaz <code>Future</code> que representa la tarea as\u00edncrona enviada al ejecutor.</p> <p>El primero de ellos es el m\u00e9todo <code>submit(runnable)</code>, que env\u00eda al ejecutor la tarea correspondiente al runnable. Retorna un <code>Future&lt;?&gt;</code> que representa la tarea as\u00edncrona que se est\u00e1 ejecutando, y que podemos usar para cancelar la tarea. El objeto Future no contendr\u00e1 ning\u00fan valor.</p> <p>Una mejora a este \u00faltimo es el m\u00e9todo <code>submit(runnable, V value)</code>, que env\u00eda al ejecutor la tarea correspondiente al runnable. Retorna un <code>Future&lt;T&gt;</code>, cuyo valor ser\u00e1 establecido a <code>value</code> cuando el runnable termine de ejecutarse correctamente, sin que se haya producido una excepci\u00f3n o haya sido cancelada antes de llegar a comenzar su ejecuci\u00f3n. Como vemos, nos permite establecer el valor del <code>Future</code> asociado a la tarea aunque \u00e9sta realmente no haya retornado dicho valor.</p> <p>Aparte de las mejoras para el env\u00edo de runnables al ejecutor, la interfaz <code>ExecutorService</code> proporciona una serie de m\u00e9todos espec\u00edficos para el env\u00edo al ejecutor de tareas en forma de objetos <code>Callable</code>.</p> <p>El primero de ellos es el m\u00e9todo <code>submit(callable&lt;V&gt;)</code>, que env\u00eda al ejecutor la tarea representada por el callable. Retorna un <code>Future&lt;T&gt;</code>, cuyo valor ser\u00e1 el valor retornado por el m\u00e9todo <code>call()</code> del callable.</p> <p>Dentro de poco estudiaremos en su propio apartado los otros dos m\u00e9todos disponibles en esta interfaz para el env\u00edo de listas de objetos <code>Callable</code>, llamados <code>invokeAll(callableCollection)</code> y <code>invokeAny(callableCollection</code>.</p> <p> Figura  - Executor Service</p>"},{"location":"bloque_v/tema_26/page-9/#proyecto-callable","title":"Proyecto Callable","text":"<p>En este proyecto desarrollaremos una aplicaci\u00f3n que calcula el factorial de 10 n\u00fameros distintos. Crearemos un tarea <code>Callable</code> que calcule el factorial de un n\u00famero y un ejecutor con un threadpool fijo de 2 hilos que lance las diez tareas y obtenga el resultado de cada una de ellas, usando objetos <code>Future</code>, y lo almacene en una lista, para finalmente mostrar todos los resultados.</p> MainTask <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n        ThreadPoolExecutor fixedThreadPool =\n                (ThreadPoolExecutor) Executors.newFixedThreadPool(2);\n        List&lt;Future&lt;Integer&gt;&gt; futureList = new ArrayList&lt;&gt;();\n        int[] numbers = new int[10];\n        for (int i = 0; i &lt; 10; i++) {\n            numbers[i] = ThreadLocalRandom.current().nextInt(15) - 5;\n            Task task = new Task(numbers[i]);\n            futureList.add(fixedThreadPool.submit(task));\n        }\n        // Main thread can do some work here.\n        // ...\n        System.out.print(\"Results:\\n\");\n        try {\n            for (int i = 0; i &lt; futureList.size(); i++) {\n                Future&lt;Integer&gt; future = futureList.get(i);\n                try {\n                    Integer factorial = future.get();\n                    System.out.printf(\"Task %d -&gt; factorial(%d) = %d\\n\", i + 1,\n                            numbers[i], factorial);\n                } catch (ExecutionException e) {\n                    System.out.printf(\"Task %d -&gt; factorial(%d) threw an exception\\n\",\n                            i + 1, numbers[i]);\n                }\n            }\n        } catch (InterruptedException ignored) {\n        } finally {\n            fixedThreadPool.shutdown();\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.util.concurrent.Callable;\nimport java.util.concurrent.TimeUnit;\n\nclass Task implements Callable&lt;Integer&gt; {\n\n    private final int number;\n\n    Task(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public Integer call() throws InterruptedException {\n        return factorial(number);\n    }\n\n    private Integer factorial(int number) throws InterruptedException {\n        if (number &lt; 0) throw new IllegalArgumentException(\"Number can't be negative\");\n        int factorial = 1;\n        for (int i = 2; i &lt;= number; i++) {\n            factorial *= i;\n            TimeUnit.MILLISECONDS.sleep(20);\n        }\n        return factorial;\n    }\n\n}\n</code></pre> <p>Si ejecutamos el programa veremos c\u00f3mo se utiliza la interfaz <code>Future</code> para acceder a los resultados de las tareas de c\u00e1lculo enviadas al ejecutor.</p>"},{"location":"bloque_v/tema_27/page-1/","title":"1 Introducci\u00f3n al ForkJoin framework","text":""},{"location":"bloque_v/tema_27/page-1/#intro","title":"Intro","text":"<p>Como hemos visto, Java 5 introdujo el concepto de ejecutor, a trav\u00e9s de las interfaces <code>Executor</code> y <code>ExecutorService</code>, y de las clases que las implementan, como <code>ThreadPoolExecutor</code>. El uso de ejecutores permite separar por un lado la creaci\u00f3n de la tarea y por otro lado su ejecuci\u00f3n. Tan s\u00f3lo es necesario crear las tareas y envi\u00e1rselas al ejecutor, que es quien crea, gestiona y finaliza los hilos necesarios para la ejecuci\u00f3n de las tareas.</p> <p>Java 7 va un paso m\u00e1s all\u00e1 proporcion\u00e1ndonos una implementaci\u00f3n adicional de la interfaz <code>ExecutorService</code>, conocida como fork/join framework, que proporciona un entorno de trabajo de alto rendimiento para el paralelismo de datos en Java, es decir para que se realicen tareas sobre una colecci\u00f3n de datos de forma concurrente, aprovechando la disponibilidad de varios n\u00facleos de procesamiento.</p> <p>Este framework est\u00e1 dise\u00f1ado para ser usado con tareas que pueden descomponerse en subtareas. Est\u00e1 orientado a la resoluci\u00f3n concurrente de un problema mediante la t\u00e9cnica divide y vencer\u00e1s, consistente en descomponer un problema en subproblemas m\u00e1s simples, cuya operaci\u00f3n se conoce como fork, obtener la soluci\u00f3n de dichos subproblemas, y componer la soluci\u00f3n total en base a la soluci\u00f3n de los subproblemas, a lo que se conoce como join. El algoritmo ser\u00eda algo as\u00ed:</p> <pre><code>if problem is small enough\n    solve problem directly (sequential algorithm)\nelse\n    split problem into independent parts\n    fork new sub-tasks to solve each part\n    sub-tasks are solved in parallel, even in different threads\n    join all sub-tasks\n    compose result from sub-results\n</code></pre> <p>As\u00ed, el framework se basa en dos operaciones principales:</p> <ul> <li>Descomposici\u00f3n (fork): Divide una tarea en subtareas m\u00e1s peque\u00f1as y las ejecuta.</li> <li>Composici\u00f3n (join): La tarea espera la finalizaci\u00f3n de las subtareas en las que se ha descompuesto. Cuando una tarea se encuentra en esta situaci\u00f3n, el hilo en el que se est\u00e1 ejecutando es asignado a otra tarea del ejecutor que no haya sido ejecutada a\u00fan. A este mecanismo se le conoce como algoritmo de robo de trabajo (work-stealing algorithm).</li> </ul> <p> Figura 1 - Fork y Join</p> <p>Las tareas que pueden ser utilizadas con este framework tienen una serie de limitaciones:</p> <ul> <li>S\u00f3lo pueden utilizar como mecanismos de sincronizaci\u00f3n los m\u00e9todos <code>fork()</code> y <code>join()</code>. Si utilizan otros mecanismos de sincronizaci\u00f3n, no podr\u00e1 ser usado el algoritmo de robo de trabajo, es decir, que los hilos del ejecutor no podr\u00e1n ser reusados por otras tareas mientras la tarea est\u00e9 en una operaci\u00f3n de sincronizaci\u00f3n (por ejemplo si se pone a dormir).</li> <li>No deben realizar operaciones de Entrada/Salida, como leer o escribir datos en un archivo.</li> <li>No deben lanzar excepciones chequeadas (checked exceptions). Deben incluir el c\u00f3digo necesario para procesar dichas excepciones.</li> </ul> <p>El n\u00facleo del entorno est\u00e1 formado por las siguientes dos clases: <code>ForkJoinPool</code> y <code>ForkJoinTask</code>.</p>"},{"location":"bloque_v/tema_27/page-2/","title":"2 ForkJoinPool","text":""},{"location":"bloque_v/tema_27/page-2/#intro","title":"Intro","text":"<p>La clase <code>ForkJoinPool</code> es un tipo de ejecutor, que al igual que <code>ThreadPoolExecutor</code>, hereda de <code>AbstractExecutorService</code>, y por tanto implementa las interfaces <code>ExecutorService</code> y <code>Executor</code>.</p> <p>Al heredar de <code>AbstractExecutorService</code>, implementa todos los m\u00e9todos caracter\u00edsticos de la interfaz <code>ExecutorService</code> que hemos estudiado antes, tanto para el env\u00edo de objetos <code>Runnable</code> y <code>Callable</code>, como <code>execute(runnable)</code>, <code>submit(callable)</code>, <code>invokeAll(callableCollection)</code> e <code>invokeAny(callableCollection)</code>, y los m\u00e9todos relacionados con la terminaci\u00f3n expl\u00edcita del ejecutor, como <code>shutdown()</code>, <code>shutdownNow()</code> o <code>awaitTermination()</code>.</p> <p>En los m\u00e9todos anteriores, un ejecutor ForkJoinPool se comporta de forma similar a un ThreadPoolExecutor.</p> <p>Sin embargo, la clase <code>ForkJoinPool</code> proporciona una caracter\u00edstica adicional que lo hace muy especial: implementa el algoritmo de robo de trabajo. Esta caracter\u00edsticas s\u00f3lo est\u00e1 disponible en un tipo especial de tareas dise\u00f1adas para trabajar con este tipo de ejecutor, representadas por la clase <code>ForkJoinTask</code>.</p> <p>Podemos crear un ejecutor ForkJoinPool a trav\u00e9s del constructor de dicha clase <code>ForkJoinPool()</code>, que hace que el ejecutor se cree con un threadpool de un tama\u00f1o igual al n\u00famero de n\u00facleos de procesamiento disponibles en el sistema. El constructor est\u00e1 sobrecargado <code>ForkJoinPool(parallelism)</code> para recibir el n\u00famero de hilos que debe tener el threadpool del ejecutor, lo que nos puede ser \u00fatil para indicar un n\u00famero inferior al n\u00famero real de n\u00facleos de procesamiento disponibles.</p> <p>Aunque es posible crear un ejecutor ForkJoinPool a trav\u00e9s de alguno de sus constructores, la opci\u00f3n recomendada es usar el m\u00e9todo est\u00e1tico <code>ForkJoinPool.commonPool()</code>, que retorna un ForkJoinPool ya existente, creado por el sistema, com\u00fan a todas la aplicaciones, y que que usa tantos hilos como n\u00facleos de procesamiento haya disponibles en el sistema. El objetivo de usar este ForkJoinPool com\u00fan es el de reducir el uso de recursos. De hecho, y como veremos m\u00e1s adelante, los objetos <code>ForkJoinTask</code> lo usan si no se indica expl\u00edcitamente el ForkJoinPool que debe usarse.</p> <p> Figura 2 - Diagrama de clases de ForkJoinPool</p> <p>La clase <code>ForkJoinPool</code> proporciona nuevos m\u00e9todos para poder enviar objetos <code>ForkJoinTask</code> al ejecutor. Estos m\u00e9todos ser\u00e1n usados por clientes externos al propio ForkJoinPool (non ForkJoinTask clients). Debemos tener en cuenta que las propias tareas ForkJoinTask que se est\u00e9n ejecutando en el ejecutor pueden a su vez enviar subtareas al ejecutor, pero no lo hacen usando estos m\u00e9todos, sino otros m\u00e9todos que estudiaremos dentro de poco:</p> <ul> <li><code>execute(ForkJoinTask&lt;?&gt; tarea)</code>: Env\u00eda al ejecutor una tarea ForkJoinTask que no retorna ning\u00fan valor. El hilo desde el que se realiza el env\u00edo NO es bloqueado, por lo que puede continuar con su ejecuci\u00f3n. La llamada a este m\u00e9todo no retorna nada.</li> <li><code>submit(ForkJoinTask&lt;T&gt; tarea)</code>: Env\u00eda al ejecutor una tarea ForkJoinTask que retorna un valor de tipo <code>T</code>. El hilo desde el que se realiza el env\u00edo NO es bloqueado, por lo que puede continuar con su ejecuci\u00f3n. La llamada a este m\u00e9todo retorna un <code>ForkJoinTask&lt;T&gt;</code>, que extiende de <code>Future&lt;T&gt;</code>, en el que se almacenar\u00e1 el valor del tipo <code>T</code> retornado por la tarea cuando \u00e9sta termine de ejecutarse.</li> <li><code>invoke(ForkJoinTask&lt;T&gt; tarea)</code>: Env\u00eda al ejecutor una tarea ForkJoinTask que retorna un valor de tipo <code>T</code>. El hilo desde el que se realiza el env\u00edo es bloqueado hasta que termine de ejecutarse la tarea enviada. La llamada a este m\u00e9todo retorna el valor del tipo <code>T</code> retornado por la tarea.</li> </ul> <p>El ForkJoinPool dispone de una cola compartida (shared queue) en la que se encolan las ForkJoinTasks enviadas por clientes externos. Por su parte, cada hilo del threadpool del ejecutor posee su propia cola de trabajo (work queue) de la que extraen las tareas para ejecutarlas, que corresponde a una cola de doble extremo (dequeue, double-ended queue), es decir, una cola en la que se pueden realizar inserciones y extracciones por ambos extremos.</p> <p>Cuando se recibe una ForkJoinTask en la cola compartida y alg\u00fan hilo con su cola de trabajo vac\u00eda, la tarea se extrae de la cola compartida y se lleva a la cola de trabajo de dicho hilo.</p> <p> Figura 3 - Cola compartida del ForkJoin pool</p> <p>La clase <code>ForkJoinPool</code> proporciona una serie de m\u00e9todos informativos para obtener informaci\u00f3n sobre su ejecuci\u00f3n:</p> <ul> <li><code>getPoolSize()</code>: Retorna el n\u00famero de hilos trabajadores usados por el ejecutor.</li> <li><code>getParallelism()</code>: Retorna el nivel deseado de paralelismo establecido para el ejecutor.</li> <li><code>getActiveThreadCount()</code>: Retorna el n\u00famero de hilos del ejecutor que est\u00e1n ejecutando tareas en este momento.</li> <li><code>getRunningThreadCount()</code>: Retorna el n\u00famero de hilos que no est\u00e1n bloqueados en ning\u00fan mecanismo de sincronizaci\u00f3n.</li> <li><code>getQueuedSubmissionCount()</code>: Retorna el n\u00famero de tareas que han sido enviadas al ejecutor y que a\u00fan no han comenzado su ejecuci\u00f3n.</li> <li><code>getQueuedTaskCount()</code>: Retorna el n\u00famero de tareas que han sido enviadas al ejecutor y que ya han comenzado su ejecuci\u00f3n.</li> <li><code>hasQueuedSubmissions()</code>: Retorna <code>true</code> si el ejecutor tiene tareas pendientes de comenzar a ejecutar.</li> <li><code>getStealCount()</code>: Retorna el n\u00famero de veces que se ha producido robo de trabajo (lo estudiaremos dentro de poco).</li> <li><code>isTerminated()</code>: Retorna <code>true</code> si el ejecutor ya ha finalizado su ejecuci\u00f3n.</li> </ul>"},{"location":"bloque_v/tema_27/page-3/","title":"3 ForkJoinTask","text":""},{"location":"bloque_v/tema_27/page-3/#intro","title":"Intro","text":"<p>La clase <code>ForkJoinTask&lt;V&gt;</code> es la clase base de las tareas que pueden ser ejecutadas por un ejecutor <code>ForkJoinPool</code>, e implementa la interfaz <code>Future&lt;V&gt;</code>.</p> <p>El objetivo de esta clase es asociar una determinada colecci\u00f3n de datos con la computaci\u00f3n que se debe realizar con ellos. Proporciona mecanismos para ejecutar las operaciones de descomposici\u00f3n (fork) y de reunificaci\u00f3n (join) dentro de la tarea y los m\u00e9todos de control del estado de la tarea, permiti\u00e9ndonos utilizar una estrategia divide y vencer\u00e1s para llevar a cabo el trabajo encomendado.</p> <p>Para ello, dentro de la tarea usemos alg\u00fan algoritmo del tipo de descomposici\u00f3n y reunificaci\u00f3n recursivo, como el siguiente:</p> <pre><code>Si el tama\u00f1o de la tarea es suficientemente peque\u00f1o\n    Resolver la tarea directamente de forma secuencial\n    Obtener resultado (opcional)\nsino\n    Subdividir la tarea en subtareas independientes\n    Ejecutar cada una de las subtareas en paralelo, incluso en hilo diferentes\n    Esperar a que todas las subtareas terminen de ejecutarse\n    Obtener resultado componiendo el resultado de cada una de las subtareas (opcional)\nRetornar resultado (opcional)\n</code></pre> <p>La ventaja principal de aplicar este algoritmo de divide y vencer\u00e1s es que podemos ejecutar un alto n\u00famero de ForkJoinTasks en un n\u00famero peque\u00f1o de hilos del fork-join pool, sin tener que sobrecargar el sistema creando muchos hilos.</p> <p>Como vemos en este sencillo algoritmo, la propia tarea deber\u00e1 ejecutar una serie de subtareas. Y esta es una de las diferencias m\u00e1s notables entre el Executor Framework y el Fork/Join Framework. Mientras que en el primero todas las tareas deben ser enviadas al ejecutor, en el segundo las propias tareas incluyen m\u00e9todos para ejecutar y controlar subtareas.</p> <p>A la hora de crear nuestras tareas no extenderemos directamente la clase <code>ForkJoinTask</code>, sino alguna de sus subclases:</p> <ul> <li><code>RecursiveAction</code>: Lo usaremos si nuestra tarea no va a retornar ning\u00fan resultado.</li> <li><code>RecursiveTask</code>: Lo usaremos si nuestra tarea retornar\u00e1 un resultado.</li> <li><code>CountedCompleter</code>: Lo usaremos si al completarse nuestra tarea se deben lanzar otras tareas. Representa \u00e1rboles jer\u00e1rquicos de tareas recursivas. Fue agregada en Java 8.</li> </ul> <p> Figura 4 - Diagrama de clases de ForkJoinTask</p> <p>El m\u00e9todo principal de estas clases, y que deberemos sobrescribir para implementar su funcionalidad, es el m\u00e9todo <code>void compute()</code>, que no retorna nada, en el caso de la clase <code>RecursiveAction</code>, o <code>V compute()</code>, que s\u00ed retorna un valor cuyo tipo <code>V</code> corresponde al tipo gen\u00e9rico de la clase, en el caso de la clase <code>RecursiveTask&lt;V&gt;</code>.</p> <p>Desgraciadamente, estas clases no son interfaces funcionales, por lo que no podemos usar expresiones lambda, sino que estamos obligados a crear clases que hereden de ellas. Debemos tener en cuenta que estas clases fueron dise\u00f1adas para Java 7, versi\u00f3n que a\u00fan no incorporaba las lambdas.</p> <p>Dentro de este m\u00e9todo se realizar\u00e1 la descomposici\u00f3n de la tarea en subtareas. Una vez creadas las subtareas, deberemos envi\u00e1rselas al ejecutor <code>ForkJoinPool</code> para que sean ejecutadas. Para ello usaremos alguno de los siguiente m\u00e9todos existentes en la clase <code>ForkJoinTask</code>, y que son heredados por <code>RecursiveAction</code> y <code>RecursiveTask</code>.</p> <p>La primera opci\u00f3n es usar el m\u00e9todo <code>fork()</code> sobre una subtarea, para que \u00e9sta sea enviada internamente al mismo ForkJoinPool, en el que se se inicie su ejecuci\u00f3n de manera as\u00edncrona, de manera que la tarea padre continuar su ejecuci\u00f3n (no es bloqueado). Como consecuencia, la subtarea es insertada al principio de la cola de trabajo asociada al mismo hilo en el que se est\u00e1 ejecutando la tarea padre. La llamada a este m\u00e9todo retorna la propia subtarea sobre la que se ejecuta.</p> <p>Si la tarea padre desea posteriormente esperar a que termine la subtarea, deber\u00e1 llamar al m\u00e9todo <code>join()</code> de la subtarea, que har\u00e1 que la tarea padre quede suspendida hasta que la subtarea finalice su ejecuci\u00f3n, de manera que el hilo trabajador que estaba ejecutando la tarea padre es asignado a otra tarea del ejecutor (algoritmo de robo de trabajo). Es importante recalcar que el hilo en el que se est\u00e1 ejecutando la tarea padre NO es bloqueado, lo que es bloqueada es la tarea padre en s\u00ed, y de hecho el hilo que estaba asignado a la tarea padre es resignado a otra tarea. Cuando la subtarea sobre la que se ha hecho <code>join()</code> es completado, satisfactoriamente o con una excepci\u00f3n, cuando <code>isDone()</code> sea <code>true</code>, la tarea padre es reactivada y recibe el valor retornado el <code>join()</code>, pudiendo continuar con su ejecuci\u00f3n.</p> <p>Si la ejecuci\u00f3n de la subtarea retorna un valor, dicho valor ser\u00e1 retornado por el propio m\u00e9todo <code>join()</code>, de manera que la tarea padre pueda hacer uso de \u00e9l. Si la tarea no retorna un valor, el m\u00e9todo <code>join()</code> retornar\u00e1 <code>null</code>.</p> <p>Si al ejecutar la subarea se produjera una excepci\u00f3n, al hacer <code>join()</code> sobre ella se lanzar\u00e1 una <code>RuntimeException</code> o <code>Error</code>, pero no <code>ExecutionException</code>, a diferencia de lo que ocurr\u00eda el m\u00e9todo <code>get()</code> de la interfaz <code>Future</code>. Otra diferencia, es que si el hilo desde el que se ha llamado a <code>join()</code>, que est\u00e1 bloqueado esperando que termine de ejecutarse la subtarea, es interrumpido, dicha interrupci\u00f3n no provocar\u00e1 a que la llamada retorne abruptamente lanzando la excepci\u00f3n <code>InterruptedException</code>.</p> <p>Una segunda opci\u00f3n es usar sobre la subtarea el m\u00e9todo <code>invoke()</code> que realiza ambas operaciones, la de fork y la de join, por lo env\u00eda la subarea al ForkJoinPool para que sea ejecutada, de manera que la tarea padre quedar\u00e1 suspendida hasta que la subtarea finalice su ejecuci\u00f3n, por lo que el hilo trabajador que estaba ejecutando la tarea padre es asignado a otra tarea del ejecutor (algoritmo de robo de trabajo). La llamada a este m\u00e9todo retornar\u00e1 el valor retornado por la subtarea. Si la ejecuci\u00f3n de la subtarea lanzara una excepci\u00f3n, la llamada al m\u00e9todo lanzar\u00e1 una <code>RuntimeException</code>.</p> <p>Debemos recalcar que <code>fork()</code>, <code>join()</code> y <code>invoke()</code> deben ser ejecutados sobre el objeto subtarea que hayamos creado en el m\u00e9todo <code>compute()</code> de la tarea, y NO sobre la tarea padre en s\u00ed.</p> <p> Figura 5 - Relaci\u00f3n entre tarea ForkJoinTask padre y tareas ForkJoinTask hijas</p> <p>Una tercera opci\u00f3n es que la tarea padre llame al m\u00e9todo est\u00e1tico <code>ForkJoinTask.invokeAll(forkJoinSubTask&lt;?&gt;...)</code>, que comienza la ejecuci\u00f3n de cada una de las subtareas pasadas como argumento, quedando la tarea padre desde la que se realiza la llamada suspendida hasta que terminen de ejecutarse las subtareas, de manera que hilo trabajador que estaba ejecutando la tarea padre es asignado a otra tarea del ejecutor (algoritmo de robo de trabajo). Este m\u00e9todo est\u00e1 sobrecargado, de manera que pueda recibir como par\u00e1metros un par de subtareas, <code>ForkJoinTask.invokeAll(forkJoinSubTask1, forkJoinSubTask2)</code>. La llamada a estos m\u00e9todos no retorna nada. Este comportamiento ofrece una gesti\u00f3n de tareas m\u00e1s eficiente que la proporcionada por los objetos <code>Runnable</code> y <code>Callable</code>.</p> <p>Finalmente, tambi\u00e9n es posible obtener un objeto <code>ForkJoinTask</code> a partir de un objeto <code>Runnable</code> o <code>Callable</code>, mediante los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>ForkJoinTask.adapt(runnable)</code>: Retorna un <code>ForkJoinTask&lt;?&gt;</code>.</li> <li><code>ForkJoinTask.adapt(runnable, resultT)</code>: Retorna un <code>ForkJoinTask&lt;T&gt;</code>.</li> <li><code>ForkJoinTask.adapt(callableT)</code>: Retorna un <code>ForkJoinTask&lt;T&gt;</code>.</li> </ul>"},{"location":"bloque_v/tema_27/page-4/","title":"4 Algoritmo de robo de trabajo","text":""},{"location":"bloque_v/tema_27/page-4/#intro","title":"Intro","text":"<p>Como ya hemos dicho, cada hilo del threadpool del ejecutor posee su propia cola de trabajo (work queue) de la que se extrae una a una las tareas para ejecutarlas y en la que se insertan nuevas tareas que deben ser ejecutadas.</p> <p>La cola de trabajo de cada hilo corresponde a lo que se conoce como una cola de doble extremo (dequeue, double-ended queue), es decir, una cola en la que se pueden realizar inserciones y extracciones por ambos extremos. Uno de los extremos recibe el nombre de head y el otro extremo recibe el nombre de tail.</p> <p>Cada hilo trabajador se encuentra ejecutando una especie de bucle infinito en el que conforme termina de ejecutar una tarea, extrae otra del head de la dequeue (operaci\u00f3n pop) y la ejecuta. Dado que cada hilo dispone de su propia dequeue, no debe competir con otros hilos y por tanto se disminuye la contenci\u00f3n (el hecho de tener que bloquear un hilo por estar esperando en un cerrojo).</p> <p>Cuando una tarea padre hace <code>fork()</code> sobre una subtarea, dicha subtarea es insertada en el head de la dequeue de trabajo asociada al mismo hilo en el que se est\u00e1 ejecutando la tarea padre (operaci\u00f3n push). Por tanto, si la tarea padre hace <code>fork()</code> de varias subtareas, \u00e9stas se van encolando en orden LIFO (last input first output), de manera que la \u00faltima subtarea sobre la que se ha hecho fork() es la que ocupar\u00e1 el head de la dequeue de trabajo (como si fuera una pila).</p> <p>Cuando durante su ejecuci\u00f3n una tarea padre hace <code>join()</code> sobre una subtarea porque necesita esperar a que \u00e9sta termine su ejecuci\u00f3n, la tarea padre queda bloqueada y el hilo trabajador es asignada a otra tarea.</p> <p>Con el objetivo de tener a los hilos del threadpool del ejecutor lo m\u00e1s ocupados que sea posible, \u00e9stos implementan el conocido como algoritmo de robo de trabajo (work-stealing algorithm), que consiste en que si un hilo del threadpool debe extraer una nueva tarea del head de su dequeue de trabajo y detecta que \u00e9sta est\u00e1 vac\u00eda, comprueba las dequeue de trabajo del resto de hilos del threadpool del ejecutor y, de entre aquellas que contengan tareas pendientes de ejecuci\u00f3n, elige una aleatoriamente para extraer del tail de dicha dequeue de trabajo una tarea (operaci\u00f3n poll) y comenzar su ejecuci\u00f3n.</p> <p>Como vemos, las tareas extraen del tail de otra dequeue de trabajo, por lo que digamos que \"se roban\" en orden FIFO (fist input first output), es decir que las subtareas sobre las que se hicieron primero <code>fork()</code> en el hilo original son las primeras en poder ser robadas por otros hilos (como si fuera una cola). El objetivo de que el robo se realice desde el extremo contrario al que se extraen las tareas normalmente para su ejecuci\u00f3n es minimizar la contenci\u00f3n entre el hilo poseedor de la dequeue y el hilo que pretende hacer el robo, dado que los dos extremos de la dequeue est\u00e1n protegidos por mecanismo de locking distintos.</p> <p> Figura 6 - Algoritmo de robo de trabajo (1 de 2)</p> <p> Figura 7 - Algoritmo de robo de trabajo (2 de 2)</p> <p>Si el hilo no encuentra ninguna tarea que \"robar\" de las colas de trabajo del resto de hilos, el hilo accede a la cola com\u00fan del ejecutor, extrae una tarea de ella y comienza su ejecuci\u00f3n.</p> <p>Si dos hilos tratan de \"robar\" tareas de la misma cola de trabajo, se producir\u00e1 contenci\u00f3n, pero \u00e9sta es normalmente insignificante.</p> <p>Antes hemos comentado que cuando durante su ejecuci\u00f3n una tarea padre hace <code>join()</code> sobre una subtarea porque necesita esperar a que \u00e9sta termine su ejecuci\u00f3n, la tarea padre queda bloqueada y el hilo trabajador es asignada a otra tarea. Pero \u00bfa qu\u00e9 otra tarea?:</p> <ul> <li>Si, para cuando la tarea padre llama a <code>join()</code> sobre una subtarea, dicha subtarea a\u00fan no ha comenzado su ejecuci\u00f3n, dicha subtarea ser\u00e1 extra\u00edda de la pila y el hilo que antes estaba asignado a la tarea padre ser\u00e1 asignado a la subtarea, que comenzar\u00e1 su ejecuci\u00f3n.</li> <li>Si, para cuando la tarea padre llama a <code>join()</code> sobre una subtarea, dicha subtarea ya ha comenzado su ejecuci\u00f3n porque ha sido robada por otro hilo trabajador, el hilo que estaba asociado a la tarea padre extrae la siguiente tarea de la head de su cola de trabajo y la ejecuta en dicho hilo, o \"roba\" una tarea de la cola de trabajo de otro hilo, si su cola de trabajo est\u00e1 vac\u00eda, y as\u00ed sucesivamente, hasta que la subtarea sobre la que se hice <code>join()</code> termine su ejecuci\u00f3n en el hilo que la \"rob\u00f3\".</li> </ul> <p>Cada vez que el hilo termina de ejecutar una tarea, comprueba si la subtarea sobre la que hab\u00eda hecho <code>join()</code> ha termina su ejecuci\u00f3n, de manera que en el momento en el que eso sea cierto, en vez de obtener otra tarea de su cola de trabajo para ejecutarla (o robar otra tarea), contin\u00faa con la ejecuci\u00f3n de la tarea padre.</p>"},{"location":"bloque_v/tema_27/page-5/","title":"5 RecursiveAction","text":""},{"location":"bloque_v/tema_27/page-5/#proyecto-recursiveaction","title":"Proyecto RecursiveAction","text":"<p>En este proyecto implementaremos una tarea recursiva que consiste en incrementar en un determinado valor todos los elementos de un array. Si el rango de elementos a incrementar tiene menos de 10 valores, se realizar\u00e1 el incremento de manera secuencial. Si el rango de elementos a incrementar tiene 10 valores o m\u00e1s seguiremos una de las siguientes dos estrategias:</p> <ul> <li>Estrategia 1: Dividir el rango por la mitad y crear dos subtareas cada una de las cuales incremente un subrango aplicando recursivamente el mismo algoritmo anterior.</li> <li>Estrategia 2: Dividir el rango por la mitad y hacer que el primer subrango sea incrementado secuencialmente y crear una subtarea para el segundo subrango aplicando recursivamente el mismo algoritmo anterior.</li> </ul> MainIncrementTask <pre><code>import java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ForkJoinPool;\n\nclass Main {\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        new Main().start();\n    }\n\n    private void start() throws InterruptedException, ExecutionException {\n        int size = 1000;\n        int increment = 5;\n        int[] values = createArray(size);\n        incrementSecuentially(values, increment);\n        incrementInParallel(values, increment);\n    }\n\n    private void incrementSecuentially(int[] values, int increment) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i &lt; values.length; i++) {\n            values[i] = values[i] + increment;\n        }\n        System.out.printf(\"Secuential increment done in %d millis\\n\", System.currentTimeMillis() - start);\n    }\n\n    private void incrementInParallel(int[] values, int increment) throws InterruptedException, ExecutionException {\n        long start = System.currentTimeMillis();\n        IncrementTask incrementTask = new IncrementTask(values, 0, values.length, increment);\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\n        forkJoinPool.execute(incrementTask);\n        incrementTask.get();\n        System.out.printf(\"Parallel increment done in %d millis\\n\", System.currentTimeMillis() - start);\n        System.out.printf(\"Work steal count: %d\\n\", forkJoinPool.getStealCount());\n        forkJoinPool.shutdown();\n    }\n\n    private int[] createArray(int size) {\n        int[] values = new int[size];\n        for (int i = 0; i &lt; size; i++) {\n            values[i] = 10;\n        }\n        return values;\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.RecursiveAction;\n\npublic class IncrementTask extends RecursiveAction {\n\n    private final DateTimeFormatter dateTimeFormatter =\n            DateTimeFormatter.ofPattern(\"HH:mm:ss:SSS\");\n\n    private final int[] values;\n    private final int from;\n    private final int to;\n    private final int increment;\n\n    IncrementTask(int[] values, int from, int to,\n                int increment) {\n        this.values = values;\n        this.from = from;\n        this.to = to;\n        this.increment = increment;\n    }\n\n    @Override\n    protected void compute() {\n        // If range is small enough update directly secuentially.\n        if (to - from &lt; 10) {\n            incrementValues(values, from, to, increment);\n        } else {\n            applyStrategy1(values, from, to, increment);\n//            applyStrategy2(values, from, to, increment);\n        }\n    }\n\n    private void applyStrategy1(int[] values, int from, int to, int increment) {\n        int pivot = (to + from) / 2;\n        System.out.printf(\"%s - %s - [%d,%d) split in [%d,%d) y [%d,%d)\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, to, from, pivot, pivot, to);\n        // Create two subtasks, one for each half.\n        IncrementTask subTask1 = new IncrementTask(values, from, pivot, increment);\n        IncrementTask subTask2 = new IncrementTask(values, pivot, to, increment);\n        // Fork and join them.\n        subTask1.fork();\n        subTask2.fork();\n        subTask1.join();\n        subTask2.join();\n        System.out.printf(\"%s - %s - [%d, %d) and [%d, %d) joined. [%d, %d] done\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, pivot, pivot, to, from, to);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private void applyStrategy2(int[] values, int from, int to, int increment) {\n        // Split range in two.\n        int pivot = (to + from) / 2;\n        System.out.printf(\"%s - %s - [%d,%d) split in [%d,%d) y [%d,%d)\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, to, from, pivot, pivot, to);\n        IncrementTask subTask2 = new IncrementTask(values, pivot, to, increment);\n        subTask2.fork();\n        incrementValues(values, from, pivot, increment);\n        subTask2.join();\n        System.out.printf(\"%s - %s - [%d, %d) and [%d, %d) joined. [%d, %d] done\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, pivot, pivot, to, from, to);\n    }\n\n    private void incrementValues(int[] values, int from, int to, int increment) {\n        for (int i = from; i &lt; to; i++) {\n            values[i] = values[i] * (1 + increment);\n        }\n        System.out.printf(\"%s - %s - [%d, %d) done secuentially\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, to);\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_27/page-6/","title":"6 RecursiveTask","text":""},{"location":"bloque_v/tema_27/page-6/#proyecto-recursivetask","title":"Proyecto RecursiveTask","text":"<p>En este proyecto implementaremos una tarea recursiva que consiste en sumar todos los elementos de un array. Si el rango de elementos a sumar tiene menos de 10 valores, se calcular\u00e1 la suma recorriendo el rango de manera secuencial. Si el rango de elementos a sumar tiene 10 valores o m\u00e1s, seguiremos una de las siguientes dos estrategias:</p> <ul> <li>Estrategia 1: Dividir el rango por la mitad y crear dos subtareas cada una de las cuales sume un subrango aplicando recursivamente el mismo algoritmo anterior.</li> <li>Estrategia 2: Dividir el rango por la mitad y hacer que el primer subrango sea sumado secuencialmente y crear una subtarea para el segundo subrango aplicando recursivamente el mismo algoritmo anterior.</li> </ul> MainSumTask <pre><code>import java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ThreadLocalRandom;\n\nclass Main {\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        new Main().start();\n    }\n\n    private void start() throws InterruptedException, ExecutionException {\n        int size = 1000;\n        int[] values = createArray(size);\n        findSumSecuentially(values);\n        findSumInParallel(values);\n    }\n\n    private void findSumSecuentially(int[] values) {\n        long start = System.currentTimeMillis();\n        long sum = 0;\n        for (int value : values) {\n            sum += value;\n        }\n        System.out.printf(\"Secuential sum done in %d millis with result %d\\n\", System.currentTimeMillis() - start, sum);\n    }\n\n    private void findSumInParallel(int[] values) throws InterruptedException, ExecutionException {\n        long start = System.currentTimeMillis();\n        SumTask sumTask = new SumTask(values, 0, values.length);\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\n        long max = forkJoinPool.invoke(sumTask);\n        System.out.printf(\"Parallel sum done in %d millis with result %d\\n\", System.currentTimeMillis() - start, max);\n        System.out.printf(\"Work steal count: %d\\n\", forkJoinPool.getStealCount());\n        forkJoinPool.shutdown();\n    }\n\n    private int[] createArray(int size) {\n        int[] values = new int[size];\n        for (int i = 0; i &lt; size; i++) {\n            values[i] = ThreadLocalRandom.current().nextInt(100);\n        }\n        return values;\n    }\n\n}\n</code></pre> <pre><code>import java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.RecursiveTask;\n\npublic class SumTask extends RecursiveTask&lt;Long&gt; {\n\n    private final DateTimeFormatter dateTimeFormatter =\n            DateTimeFormatter.ofPattern(\"HH:mm:ss:SSS\");\n\n    private final int[] values;\n    private final int from;\n    private final int to;\n\n    SumTask(int[] values, int from, int to) {\n        this.values = values;\n        this.from = from;\n        this.to = to;\n    }\n\n    @Override\n    protected Long compute() {\n        // If range is small enough update directly secuentially.\n        if (to - from &lt; 10) {\n            return sum(values, from, to);\n        } else {\n            long sum = applyStrategy1(values, from, to);\n//            long sum = applyStrategy2(values, from, to);\n            return sum;\n        }\n    }\n\n    private long applyStrategy1(int[] values, int from, int to) {\n        int pivot = (to + from) / 2;\n        System.out.printf(\"%s - %s - [%d,%d) split in [%d,%d) y [%d,%d)\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, to, from, pivot, pivot, to);\n        SumTask subTask1 = new SumTask(values, from, pivot);\n        SumTask subTask2 = new SumTask(values, pivot, to);\n        subTask1.fork();\n        subTask2.fork();\n        long sum1 = subTask1.join();\n        long sum2 = subTask2.join();\n        long sum = sum1 + sum2;\n        System.out.printf(\"%s - %s - [%d, %d) joined with %d\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, pivot, sum1);\n        System.out.printf(\"%s - %s - [%d, %d) joined with %d\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                pivot, to, sum2);\n        System.out.printf(\"%s - %s - [%d, %d) done with %d\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, to, sum);\n        return sum;\n    }\n\n    private long applyStrategy2(int[] values, int from, int to) {\n        int pivot = (to + from) / 2;\n        System.out.printf(\"%s - %s - [%d,%d) split in [%d,%d) y [%d,%d)\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, to, from, pivot, pivot, to);\n        SumTask subTask2 = new SumTask(values, pivot, to);\n        subTask2.fork();\n        long sum1 = sum(values, from, pivot);\n        long sum2 = subTask2.join();\n        long sum = sum1 + sum2;\n        System.out.printf(\"%s - %s - [%d, %d) joined with %d\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                pivot, to, sum2);\n        System.out.printf(\"%s - %s - [%d, %d) done with %d\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, to, sum);\n        return sum;\n    }\n\n    private long sum(int[] values, int from, int to) {\n        long sum = 0;\n        for (int i = from; i &lt; to; i++) {\n            sum += values[i];\n        }\n        System.out.printf(\"%s - %s - [%d, %d] done secuentially with %d\\n\",\n                Thread.currentThread().getName(),\n                dateTimeFormatter.format(LocalTime.now()),\n                from, to, sum);\n        return sum;\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_27/page-7/","title":"7 Common Fork-Join pool","text":""},{"location":"bloque_v/tema_27/page-7/#intro","title":"Intro","text":"<p>A partir de Java 8, la forma m\u00e1s conveniente de acceder a una instancia de <code>ForkJoinPool</code> es usar el m\u00e9todo est\u00e1tico <code>ForkJoinPool.commonPool()</code>.</p> <p>Como su nombre indica, esta llamada retorna una referencia al un objeto <code>ForkJoinPool</code> com\u00fan, predefinido por el sistema, que usa tantos hilos como n\u00facleos de procesamiento est\u00e9n disponibles.</p> <p>El uso del pool com\u00fan predefinido reduce el consumo de recursos, ya que no es necesaria la creaci\u00f3n de un thread pool independiente para cada tarea.</p> <p>Sin embargo, no siempre tiene por qu\u00e9 ser el pool id\u00f3neo. Por ejemplo, en el caso de tareas intensivas de entrada/salida, que van a ser bloqueadas en operaciones de E/S, ser\u00e1 interesante que el pool tuviera un mayor n\u00famero de hilos.</p> <p>Otro aspecto que debemos tener en cuenta es que el common fork join pool es com\u00fan a todas las aplicaciones, y, como veremos m\u00e1s adelante, es usado por defecto por otras api de Java, como los streams paralelos o CompletableFuture, por lo que puede que los hilos de dicho ejecutor est\u00e9n muy ocupados.</p>"},{"location":"bloque_v/tema_27/page-8/","title":"Ejercicios","text":"<p>Realiza un proyecto multihilo en Java haciendo uso del framework <code>ForkJoinPool</code> para buscar en un array de 100 elementos un n\u00famero. Cada elemento del array es un n\u00famero comprendido entre el 0 y el 255.</p>"},{"location":"bloque_v/tema_28/page-1/","title":"1 Introducci\u00f3n a CompletableFuture","text":""},{"location":"bloque_v/tema_28/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La interfaz <code>Future</code> fue incorporada en Java 5 para representar el resultado de operaciones as\u00edncronas, para indicar que dicho resultado estar\u00eda disponible en el futuro. Sin embargo, dicha interfaz no inclu\u00eda ning\u00fan m\u00e9todo que permitiera combinar estas operaciones de manera as\u00edncrona o de gestionar los posibles errores. As\u00ed, si deb\u00edamos encadenar dos tareas as\u00edncronas, deb\u00edamos bloquearnos hasta que terminara de ejecutarse la primera, normalmente llamando al m\u00e9todo <code>get()</code> del objeto <code>Future</code> retornado por la tarea, para posteriormente lanzar la segunda tarea pas\u00e1ndole el resultado obtenido por la primera para que se ejecutara de manera as\u00edncrona. Como vemos, en realidad no pod\u00edamos desentendernos de la ejecuci\u00f3n de la cadena de tareas, ya que \u00e9ramos nosotros los que deb\u00edamos de encadenar la finalizaci\u00f3n de la ejecuci\u00f3n de la primera tarea con el inicio de la ejecuci\u00f3n de la segunda.</p> <p>Con el objetivo de mejorar la funcionalidad aportada por la interfaz <code>Future</code>, la API de concurrencia de Java 8 incluy\u00f3 la clase <code>CompletableFuture&lt;T&gt;</code>. Esta clase implementa la interfaz <code>Future&lt;T&gt;</code>, por lo que podemos usar un objeto de <code>CompletableFuture&lt;T&gt;</code> dentro de nuestra tarea para retornar en alg\u00fan momento futuro un resultado de la clase <code>T</code>, de igual manera a c\u00f3mo hac\u00edamos con <code>Future&lt;T&gt;</code>, pero adem\u00e1s <code>CompletableFuture&lt;T&gt;</code> implementa la interfaz <code>CompletionStage&lt;T&gt;</code>, y es esta interfaz, la que le proporciona la funcionalidad necesaria para encadenar la ejecuci\u00f3n as\u00edncrona de otras tareas cuando la ejecuci\u00f3n de nuestra tarea haya finalizado y se haya obtenido el resultado.</p> <p>Debemos tener en cuenta que la clase <code>CompletableFuture</code> proporciona much\u00edsimos m\u00e9todos, m\u00e1s de 60, por lo que m\u00e1s que una clase es todo un framework, que proporciona un modelo de programaci\u00f3n concurrente as\u00edncrona. Sus principales caracter\u00edsticas son:</p> <ul> <li>Permite el disparo autom\u00e1tico y as\u00edncrono de operaciones dependientes de otras cuando \u00e9stas \u00faltimas son completadas.</li> <li>Las operaciones as\u00edncronas pueden ser ejecutadas concurrentemente en thread pools, permiti\u00e9ndonos usar por defecto un fork-join pool com\u00fan, o especificar expl\u00edcitamente el thead pool a usar.</li> <li>Puede combinarse con los streams de Java 8.</li> <li>Al usar el framework de CompletableFuture habitualmente no es necesario desarrollar ning\u00fan mecanismo de sincronizaci\u00f3n entre los hilos. En aquellos casos donde es necesaria la sincronizaci\u00f3n podemos usar las estructuras de datos thread-safe disponibles en Java.</li> <li>Mejora las caracter\u00edsticas la interfaz <code>Future</code>, ya que permite completar expl\u00edcitamente un CompletableFuture, algo que no era posible hacer en un Future.</li> <li>Se pueden encadenar operaciones usando una sintaxis fluida, para manejar operaciones as\u00edncronas de forma eficiente y clara.</li> </ul>"},{"location":"bloque_v/tema_28/page-10/","title":"10 CompletableFuture.allOf()","text":""},{"location":"bloque_v/tema_28/page-10/#introduccion","title":"Introducci\u00f3n","text":"<p>Podemos crear un CompletableFuture que sea completado cuando sean completados n CompletableFutures pasados como argumento. Para ello usaremos el m\u00e9todo est\u00e1tico <code>CompletableFuture.allOf(completableFuture...)</code>.</p> <p>Este m\u00e9todo retorna un <code>CompletableFuture&lt;Void&gt;</code>, por lo que no tenemos acceso a trav\u00e9s de \u00e9l a los valores con los que se han completado los CompletableFuture pasados como argumento. Si queremos acceder a dichos valores, deberemos usar el m\u00e9todo <code>join()</code> individualmente sobre cada uno de dichos CompletableFuture.</p> <p>Si cualquiera de los CompletableFuture pasados como argumentos se completa con una excepci\u00f3n, <code>allOf()</code> esperar\u00e1 a que se completen el resto de los CompletableFuture recibidos.</p> <p>De esta manera el objetivo de <code>allOf()</code> es b\u00e1sicamente una manera de detectar que una serie de CompletableFuture han sido completados, sin tener en cuenta los valores con los que se completan o si se completan con una excepci\u00f3n.</p>"},{"location":"bloque_v/tema_28/page-10/#mejorando-completablefutureallof","title":"Mejorando CompletableFuture.allOf()","text":"<p>Tal y como est\u00e1 dise\u00f1ado, el m\u00e9todo est\u00e1tico <code>CompletableFuture.allOf()</code> presenta varias decisiones de dise\u00f1o algo controvertidas, con el objetivo de hacerlo lo m\u00e1s general posible:</p> <ul> <li>Acepta como argumento objetos <code>CompletableFuture&lt;?&gt;</code> de distintos tipos (de ah\u00ed el car\u00e1cter comod\u00edn <code>?</code>).</li> <li>Retorna un <code>CompletableFuture&lt;Void&gt;</code>, es decir que el CompletableFuture no contendr\u00e1 los resultados de los CompletableFuture pasados como argumento.</li> <li>Define como par\u00e1metro un <code>vararg</code>, en vez de una <code>&lt;List&lt;CompletableFuture&lt;?&gt;&gt;</code>, lo que hace algo m\u00e1s complejo su uso cuando queremos pasarle una lista de CompletableFutures.</li> </ul> <p>Sin embargo, en algunas ocasiones, los CompletableFutures que queremos pasarle al m\u00e9todo <code>allOf()</code> son del mismo tipo de resultado. Para esos casos, podemos crear una versi\u00f3n espec\u00edfica de <code>allOf()</code> con un dise\u00f1o menos general pero m\u00e1s limpio.</p> <p>As\u00ed, vamos a hacer que la nueva versi\u00f3n de nuestro m\u00e9todo reciba una <code>Collection&lt;CompletableFuture&lt;T&gt;&gt;</code>, es decir una colecci\u00f3n de CompletableFutures del mismo tipo (como por ejemplo una lista). Adem\u00e1s, el m\u00e9todo retornar\u00e1 un CompletableFuture con la lista de resultados de los CompletableFuture de la lista pasada como argumento, es decir, un <code>CompletableFuture&lt;List&lt;T&gt;&gt;</code>:</p> <pre><code>public static &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; allOf(\nCollection&lt;CompletableFuture&lt;T&gt;&gt; futures\n) {\n    // ...\n}\n</code></pre> <p>El m\u00e9todo debe retornar un CompletableFuture que ser\u00e1 completado cuando se hayan completado todos los CompletableFuture de la colecci\u00f3n recibida como argumento. Esto ya lo hace la versi\u00f3n original de <code>allOf()</code>, pero nosotros ahora vamos a hacer que en vez de retornar un <code>CompletableFuture&lt;Void&gt;</code>, retorne un CompletableFuture con la lista de resultados de los CompletableFuture recibidos:</p> <pre><code>public static &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; allOf(\nCollection&lt;CompletableFuture&lt;T&gt;&gt; futures\n) {\n    return\n        // Convertimos la colecci\u00f3n en un stream.\n        futures.stream()\n        // Lo recolectamos a una lista y una vez recolectado...\n        .collect(collectingAndThen(toList(),\n            // ...debemos esperar a que todos los CompletableFuture de\n            // la colecci\u00f3n se hayan completado, para lo que usamos el\n            // m\u00e9todo allOf() original.\n            l -&gt; CompletableFuture.allOf(\n                // Como recibe una vararg, convertimos la lista\n                // en un array de CompletableFuture&lt;T&gt; para pas\u00e1rselo\n                // al m\u00e9todo (un vararg es como un array)\n                l.toArray(new CompletableFuture[0])\n            )\n            // Una vez se han completados todos los CompletableFuture\n            // recibidos extraemos los resultados de todos ellos y\n            // retornamos un CompletableFuture con la lista de \n            // resultados.\n            .thenApply(nada -&gt;\n                // La lista se convierte en un stream.\n                l.stream()\n                    // Para cada CompletableFuture de la lista se\n                    // obtiene sus valor.\n                    .map(cf -&gt; cf.join())\n                    // Se recolecta el stream hacia una lista.\n                    .collect(Collectors.toList())\n            )\n        ));\n}\n</code></pre> <p>Por otra parte, y como ya hemos comentado, si cualquiera de los CompletableFuture pasados como argumentos se completa con una excepci\u00f3n, <code>allOf()</code> esperar\u00e1 a que se completen el resto de los CompletableFuture recibidos.</p> <p>Sin embargo, en algunas ocasiones querremos hacer un cortocircuito, es decir, que en cuanto alguno de los CompletableFuture recibidos se complete con una excepci\u00f3n, el propio CompletableFuture retornado se complete inmediatamente con una excepci\u00f3n. Para ello vamos a crear una nueva versi\u00f3n del m\u00e9todo, que vamos a llamar <code>allOfOrException()</code>:</p> <pre><code>public static &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; allOfOrException(\n    Collection&lt;CompletableFuture&lt;T&gt;&gt; futures\n) {\n    // Creamos el CompletableFuture que vamos a retornar\n    // llamado a la versi\u00f3n mejorada del m\u00e9todo.\n    CompletableFuture&lt;List&lt;T&gt;&gt; result = allOf(futures);\n    // En cuanto alguno de los recibido se completa con una excepci\u00f3n\n    // nosotros completamos con una excepci\u00f3n el que vamos a retornar\n    for (CompletableFuture&lt;?&gt; f : futures) {\n        f.handle((__, ex) -&gt; \n            ex == null || result.completeExceptionally(ex)\n        );\n    }\n    return result;\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-10/#anyof","title":"anyOf()","text":"<p>Si lo que queremos es obtener el valor con el que se ha completado el primero en completarse de entre n CompletableFutures, podemos usar el m\u00e9todo est\u00e1tico <code>CompletableFuture.anyOf(completableFuture...)</code>, que retorna un <code>CompletableFuture&lt;Object&gt;</code> que ser\u00e1 completado con el valor con el que se completado el primero en completarse de los CompletableFutures pasados como argumento.</p> <p>Si todos los CompletableFuture a recibir son del mismo tipo, entonces podemos crear una versi\u00f3n mejorada de <code>anyOf()</code>, que reciba una lista de CompletableFuture u que retorne un CompletableFuture con el valor retornado por el primero en completarse:</p> <pre><code>public static &lt;T&gt; CompletableFuture&lt;T&gt; anyOf(\n    List&lt;CompletableFuture&lt;T&gt;&gt; cfs\n) {\n    return \n        CompletableFuture.anyOf(cfs.toArray(new CompletableFuture[0]))\n        .thenApply(o -&gt; (T) o);\n}\n</code></pre> <p>con la ventaja de que en vez de retornar un <code>CompletableFuture&lt;Object&gt;</code>, retorna directamente un <code>CompletableFuture&lt;T&gt;</code>.</p> <p>Para saber m\u00e1s sobre CompletableFuture</p> <ul> <li>http://www.dre.vanderbilt.edu/~schmidt/cs892/index.html</li> <li>https://www.youtube.com/watch?v=-MBPQ7NIL_Y</li> <li>http://www.baeldung.com/java-completablefuture</li> <li>https://www.youtube.com/watch?v=Ehl16G8BaZA&amp;list=PLq3w0suTCPzbDVkE7RCKrj5MWjneNudfJ&amp;index=1</li> <li>http://www.nurkiewicz.com/2013/05/java-8-definitive-guide-to.html?m=1</li> <li>https://dzone.com/articles/20-examples-of-using-javas-completablefuture</li> <li>https://4comprehension.com/improving-completablefutureallof-anyof-api-java-methods/</li> </ul>"},{"location":"bloque_v/tema_28/page-2/","title":"2 Nomenclatura de los m\u00e9todos","text":""},{"location":"bloque_v/tema_28/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>La mayor\u00eda de los m\u00e9todos de la clase <code>CompletableFuture</code> tienen nombres que contienen palabras que nos permiten clasificarlos, atendiendo a tres caracter\u00edsticas:</p> <p>a) Formato en el que se aporta la tarea que debe ejecutarse:</p> <ul> <li>En forma de Function: Se usan los verbos apply y compose, por ejemplo: <code>thenApply(function)</code>, <code>thenCompose</code>, <code>applyToEither</code></li> <li>En forma de Consumer: Se usa el verbo accept, por ejemplo: <code>thenAccept(consumer)</code>, <code>thenAcceptBoth</code>, <code>acceptEither</code></li> <li>En forma de <code>Runnable:</code> Se usa con el verbo \"run\", por ejemplo: <code>CompletableFuture.runAsync(runnable)</code>, <code>thenRun(runnable)</code>, <code>runAfterBoth</code>, <code>runAfterEither</code></li> </ul> <p>b) Tipo de operaci\u00f3n que se quiere realizar:</p> <ul> <li>Encadenamiento: La ejecuci\u00f3n de un CompletableFuture se inicia despu\u00e9s de que se complete el CompletableFuture de la cadena, pasando el resultado de \u00e9ste al siguiente. Se usa la palabra then. Por ejemplo: <code>thenRun(runnable)</code>, <code>thenAccept(consumer)</code>, <code>thenApply(function)</code>.</li> <li>Composici\u00f3n: Se quiere componer el resultado de varios CompletableFuture. Se usa el verbo compose. Por ejemplo: <code>thenCompose(function)</code>.</li> <li>Combinaci\u00f3n esperando ambos resultados y combin\u00e1ndolos en una \u00fanico CompletableFuture. Se usa la palabra both o el verbo combine. Por ejemplo: <code>thenCombine</code>, <code>thenAcceptBoth</code>, <code>runAfterBoth</code></li> <li>Aplicaci\u00f3n con el primer resultado de dos posibles: Se ejecuta la tarea en cuanto se obtiene el resultado de uno de los dos CompletableFuture de los que se depende. Se usa con la palabra either. Por ejemplo: <code>applyToEither</code>, <code>acceptEither</code>, <code>runAfterEither</code></li> </ul> <p>c) En qu\u00e9 thread pool debe ejecutarse la tarea:</p> <ul> <li>En el mismo hilo que el llamador. Corresponde a los m\u00e9todos que no terminan en la palabra Async. Por ejemplo: <code>thenRun(runnable)</code>, <code>thenAccept(consumer)</code>, <code>thenApply(function)</code>. Debemos tener en cuenta que el hilo llamador puede corresponder al hilo principal, por lo que deben ser usados con cuidado.</li> <li>As\u00edncronamente en el common fork join pool. Corresponde a los m\u00e9todos cuyo nombre termina en la palabra Async y no reciben un executor como par\u00e1metro. Por ejemplo: <code>thenRunAsync(runnable)</code>, <code>thenConsumeAsync(consumer)</code>, <code>thenApplyAsync(function)</code>. Debemos tener en cuenta que el common fork join pool usa tantos hilos como n\u00facleos de procesamiento est\u00e9n disponibles, lo que puede que no sea lo m\u00e1s adecuado si las operaciones que se van a realizar a trav\u00e9s de CompletableFuture son intensivas de entrada / salida. Por otro lado, dado que el common fork join pool es com\u00fan a todas las aplicaciones y es usado por defecto por los streams paralelos, puede que los hilos de dicho ejecutor est\u00e9n muy ocupados.</li> <li>En el executor pasado como argumento. Corresponde a los m\u00e9todos que terminan en la palabra Async y reciben un ejecutor como par\u00e1metro. Por ejemplo: <code>thenRunAsync(runnable, executor)</code>, <code>thenConsumeAsync(consumer, executor)</code>, <code>thenApplyAsync(function, executor)</code>. \u00c9sta es la opci\u00f3n que proporciona un mayor control al desarrollador.</li> </ul>"},{"location":"bloque_v/tema_28/page-3/","title":"3 M\u00e9todos factor\u00eda para construir CompletableFutures","text":""},{"location":"bloque_v/tema_28/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>La clase <code>CompletableFuture</code> incorpora una serie de m\u00e9todos est\u00e1ticos factor\u00eda para la creaci\u00f3n de objetos <code>CompletableFuture</code> que ejecutan tareas de forma as\u00edncrona.</p>"},{"location":"bloque_v/tema_28/page-3/#para-ejecutar-un-runnable","title":"Para ejecutar un Runnable","text":"<p>La manera m\u00e1s sencilla de crear una tarea as\u00edncrona que haga uso de <code>CompletableFuture</code> es usar el m\u00e9todo est\u00e1tico <code>CompletableFuture.runAsync(runnable)</code>. Este m\u00e9todo recibe el c\u00f3digo a ejecutar as\u00edncronamente en forma de objeto <code>Runnable</code> y retorna un <code>CompletableFuture&lt;Void&gt;</code>, ya que un <code>Runnable</code> no retorna nada. Por ejemplo:</p> <pre><code>private void runAsyncExample() {\n    CompletableFuture.runAsync(this::printInfo);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n}\n\nprivate void printInfo() {\n    System.out.printf(\"%s - Runnable\\n\", Thread.currentThread().getName());\n}\n</code></pre> <p>La tarea as\u00edncrona ser\u00e1 ejecutada en un hilo del <code>ForkJoinPool.commonPool()</code>.</p> <p>El m\u00e9todo est\u00e1 sobrecargado <code>runAsync(runnable, executor)</code> de manera que podemos pasarle un segundo par\u00e1metro con el ejecutor que debe usarse para ejecutar la tarea secundaria. Por ejemplo:</p> <pre><code>private void runAsyncExecutorExample() {\n    CompletableFuture.runAsync(this::printInfo, Executors.newCachedThreadPool());\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n}\n\nprivate void printInfo() {\n    System.out.printf(\"%s - Runnable\\n\", Thread.currentThread().getName());\n}\n</code></pre> <p>En este ejemplo usamos la sintaxis de referencia a m\u00e9todo a la de especificar el <code>Runnable</code>.</p> <p>Dado que el m\u00e9todo <code>run()</code> del objeto <code>Runnable</code> no retorna nada, <code>runAsync()</code> retorna un <code>CompletableFuture&lt;Void&gt;</code>, que NO podremos encadenar con ninguna otra operaci\u00f3n, por lo que su utilidad no va m\u00e1s all\u00e1 de ejecutar una tarea de forma as\u00edncrona sin que \u00e9sta retorne ning\u00fan valor.</p>"},{"location":"bloque_v/tema_28/page-3/#para-ejecutar-un-supplier","title":"Para ejecutar un Supplier","text":"<p>Sin embargo, lo habitual es que la tarea que queremos que se ejecute de forma as\u00edncrona retorna alg\u00fan valor, por lo que la clase <code>CompletableFuture</code> proporciona el m\u00e9todo est\u00e1tico <code>supplyAsync(supplier)</code>, que en vez de recibir un <code>Runnable</code>, recibe un <code>Supplier</code>. Este m\u00e9todo retorna un <code>CompletableFuture&lt;T&gt;</code>, donde <code>T</code> el el tipo de retorno de la funci\u00f3n del <code>Supplier</code>. Por ejemplo:</p> <pre><code>private void supplyAsyncExample() {\n    CompletableFuture&lt;Integer&gt; cf = CompletableFuture.supplyAsync(this::generateNumber);\n    try {\n        Integer value = cf.get();\n        printNumber(value);\n    } catch (InterruptedException ignored) {\n    } catch (ExecutionException e) {\n        System.out.println(\"Exception thrown getting value from supplier\");\n    }\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    return 2;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre> <p>La tarea as\u00edncrona ser\u00e1 ejecutada en un hilo del <code>ForkJoinPool.commonPool()</code>.</p> <p>El m\u00e9todo est\u00e1 sobrecargado, <code>supplyAsync(supplier, executor)</code>, de manera que podemos pasarle un segundo par\u00e1metro con el objeto <code>Executor</code> que debe usarse para ejecutar la tarea secundaria.</p>"},{"location":"bloque_v/tema_28/page-4/","title":"4 Obtenci\u00f3n del valor con el que se ha completado","text":""},{"location":"bloque_v/tema_28/page-4/#bloqueante-y-con-checked-exceptions","title":"Bloqueante y con checked exceptions","text":"<p>En el ejemplo anterior hemos usado el m\u00e9todo <code>get()</code> para obtener el valor con el que se ha completado el CompletableFuture. Este m\u00e9todo hace que el hilo actual espere a que el CompletableFuture sea completado, retornando finalmente su valor. Lanza la excepci\u00f3n <code>CancellationException</code>, si el CompletableFuture fue cancelado, <code>ExecutionException</code> si el CompletableFuture fue completado con una excepci\u00f3n, o <code>InterruptedException</code>, si el hilo actual fue interrumpido mientras estaba esperando a que el CompletableFuture fuera completado. Debemos tener en cuenta que estas dos \u00faltimas excepciones son checked exceptions, por lo que estamos obligados a capturarlas.</p> <p>El m\u00e9todo <code>get(timeout, timeoutUnit)</code> est\u00e1 sobrecargado para que podamos establecer un tiempo m\u00e1ximo de espera, especificado en una determinada unidad de tiempo. Si transcurrido dicho tiempo m\u00e1ximo el CompletableFuture no ha sido completo, se lanzar\u00e1 la excepci\u00f3n <code>TimeoutException</code>.</p>"},{"location":"bloque_v/tema_28/page-4/#bloqueante-sin-checked-exceptions","title":"Bloqueante sin checked exceptions","text":"<p>Los m\u00e9todos anteriores ya estaban presentes en la interfaz <code>Future</code>. Sin embargo, la clase <code>CompletableFuture</code> incorpora dos m\u00e9todos parecidos a <code>get()</code>, pero con matices distintos. El primero de ellos es el m\u00e9todo <code>join()</code>, que tiene la misma funcionalidad que <code>get()</code> pero a diferencia de \u00e9ste no lanza ninguna checked excepci\u00f3n permiti\u00e9ndonos una sintaxis m\u00e1s legible. Lanza la excepci\u00f3n <code>CancellationException</code> si el CompletableFuture fue cancelado o <code>CompletionException</code>, si el CompletableFuture se complet\u00f3 con una excepci\u00f3n o la tarea lanz\u00f3 una excepci\u00f3n.</p> <p>As\u00ed el ejemplo anterior usando <code>join()</code> quedar\u00eda como:</p> <pre><code>private void joinExample() {\n    CompletableFuture&lt;Integer&gt; cf = CompletableFuture.supplyAsync(this::generateNumber);\n    Integer value = cf.join();\n    printNumber(value);\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    return 2;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-4/#no-bloqueante-con-valor-por-defecto","title":"No bloqueante con valor por defecto","text":"<p>Pero adem\u00e1s tenemos disponible una nueva posibilidad, correspondiente al m\u00e9todo <code>getNow(default)</code>, que obtiene el valor con el que se ha completado el CompletableFuture y si \u00e9ste no est\u00e1 a\u00fan no se ha completado retorna el valor recibido como par\u00e1metro como default. Por tanto, se trata de un m\u00e9todo NO bloqueante, ya siempre retornar\u00e1 un valor inmediatamente, ya sea porque ya se haya obtenido desde la tarea as\u00edncrona o porque se retorne el valor por defecto. Lanza la excepci\u00f3n <code>CancellationException</code> si el CompletableFuture fue cancelado o <code>CompletionException</code>, si el CompletableFuture se complet\u00f3 con una excepci\u00f3n o la tarea lanz\u00f3 una excepci\u00f3n.</p> <p>Modifiquemos el ejemplo anterior:</p> <pre><code>private void getNowExample() {\n    CompletableFuture&lt;Integer&gt; cf = CompletableFuture.supplyAsync(this::generateNumber);\n    Integer value = cf.getNow(0);\n    printNumber(value);\n    sleep(3000);\n    Integer value2 = cf.getNow(0);\n    printNumber(value2);\n}\n\nprivate int generateNumber() {\n    sleep(2000);\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    return 2;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Main - %d\\n\", \n                    Thread.currentThread().getName(), value);\n}\n\nprivate boolean sleep(long timeInMilis) {\n    try {\n        Thread.sleep(timeInMilis);\n        return true;\n    } catch (InterruptedException e) {\n        return false;\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-5/","title":"5 Ejecutar un runnable as\u00edncronamente","text":""},{"location":"bloque_v/tema_28/page-5/#cuando-se-complete-un-completablefuture","title":"Cuando se complete un CompletableFuture","text":"<p>El m\u00e9todo <code>thenRun(runnable)</code> nos permite encadenar la ejecuci\u00f3n de determinada tarea, correspondiente al runnable recibido, cuando termine de ejecutarse la tarea representada por un <code>CompletableFuture</code>, y se ejecutar\u00e1 en el mismo hilo que la tarea previa.</p> <p>La segunda tarea NO recibir\u00e1 el resultado de la tarea anterior, ya que al tratarse de un runnable su m\u00e9todo <code>run()</code> no recibe nada, por lo que simplemente se trata de una tarea terminal independiente.</p> <p>Un aspecto importante es que cuando encadenamos tareas con <code>CompletableFuture</code>, cada operaci\u00f3n siempre produce un nuevo <code>CompletableFuture</code>, no se modifica el anterior.</p> <p>Veamos un ejemplo:</p> <pre><code>private void thenRunExample() {\n    CompletableFuture&lt;Void&gt; cf = \n        CompletableFuture.runAsync(this::printInfo)\n                        .thenRun(this::printMoreInfo);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cf.join();\n}\n\nprivate void printInfo() {\n    System.out.printf(\"%s - Runnable1\\n\", Thread.currentThread().getName());\n}\n\nprivate void printMoreInfo() {\n    System.out.printf(\"%s - Runnable2\\n\", Thread.currentThread().getName());\n}\n</code></pre> <p>Este m\u00e9todo retorna un <code>CompletableFuture&lt;Void&gt;</code>, ya que el runnable no retorna nada.</p> <p>Debemos tener en cuenta que, bajo ciertas circunstancias, la segunda tarea puede estar ejecut\u00e1ndose en el hilo principal. En el ejemplo anterior, al encadenarlo con <code>CompletableFuture.runAsync()</code>, la segunda tarea se ejecutar\u00e1 en el mismo hilo en el que se ejecut\u00f3 la primera (que en este caso ser\u00e1 del common fork-join pool). Sin embargo, simplemente con usar una estructura diferente en nuestro c\u00f3digo puede darse el caso de que la segunda tarea se ejecute en el hilo principal:</p> <pre><code>private void thenRun2Example() {\n    CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(this::printInfo);\n    sleep(1000);\n    cf.thenRun(this::printMoreInfo);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n}\n\nprivate void printInfo() {\n    System.out.printf(\"%s - Task1\\n\", Thread.currentThread().getName());\n}\n\nprivate void printMoreInfo() {\n    System.out.printf(\"%s - Task2\\n\", Thread.currentThread().getName());\n}\n\nprivate boolean sleep(long timeInMilis) {\n    try {\n        Thread.sleep(timeInMilis);\n        return true;\n    } catch (InterruptedException e) {\n        return false;\n    }\n}\n</code></pre> <p>Warning</p> <p>Por este motivo, debemos ser cautos a los hora de usar m\u00e9todos de encadenamiento que no lleven el sufijo Async.</p> <p>En este caso, existe un m\u00e9todo alternativo, llamado <code>thenRunAsync(runnable)</code>, similar a <code>thenRun(runnable)</code>, pero en el que el runnable encadenada no tiene por qu\u00e9 ejecutarse en el mismo hilo que la tarea previa, sino que se elige otro hilo de entre los disponibles en el ejecutor por defecto.</p> <pre><code>private void thenRunAsyncExample() {\n    CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(this::printInfo);\n    sleep(1000);\n    cf.thenRunAsync(this::printMoreInfo);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n}\n\nprivate void printInfo() {\n    System.out.printf(\"%s - Task1\\n\", Thread.currentThread().getName());\n}\n\nprivate void printMoreInfo() {\n    System.out.printf(\"%s - Task2\\n\", Thread.currentThread().getName());\n}\n\nprivate boolean sleep(long timeInMilis) {\n    try {\n        Thread.sleep(timeInMilis);\n        return true;\n    } catch (InterruptedException e) {\n        return false;\n    }\n}\n</code></pre> <p>Al ejecutar este ejemplo veremos que la segunda tarea puede que se ejecute o no en el mismo hilo que la primera tarea.</p> <p>Este m\u00e9todo est\u00e1 sobrecargado <code>thenRunAsync(runnable, executor)</code> para poder especificar el ejecutor en que queremos que se ejecute la tarea encadenada.</p>"},{"location":"bloque_v/tema_28/page-5/#cuando-se-complete-el-primero-de-dos-completablefuture","title":"Cuando se complete el primero de dos CompletableFuture","text":"<p>En algunas ocasiones lanzamos dos cadenas de operaciones as\u00edncronas, pero s\u00f3lo estamos interesados en ejecutar una determinada acci\u00f3n cuando se complete la primera de las dos en hacerlo, independiente del valor con el que se haya completado.</p> <p>Para este cometido tenemos disponible el m\u00e9todo <code>runAfterEitherAsync(completableFuture, runnable)</code>, que ejecuta el runnable pasado como argumento en cuanto uno de los dos CompletableFuture (sobre que el se ha ejecuta el m\u00e9todo y el que se ha pasado como argumento) sea completado.</p> <p>Este m\u00e9todo retorna un <code>CompletableFuture&lt;Void&gt;</code>, ya que el runnable no retorna nada, por lo que no se podr\u00e1 encadenar m\u00e1s operaciones tras \u00e9l. Por este motivo solo se puede usar este m\u00e9todo al final de una cadena de operaciones.</p> <p>El m\u00e9todo se encuentra sobrecargado <code>runAfterEitherAsync(completableFuture, runnable, executor)</code>, para recibir el executor en el que queremos ejecutar el runnable.</p> <p>Un aspecto muy importante es que este m\u00e9todo no cancela la ejecuci\u00f3n de la segunda operaci\u00f3n una vez que es completada la primera en ser completada.</p> <p>M\u00e9todo runAfterEither</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>runAfterEither(completableFuture, runnable)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que el consumer se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <pre><code>private void runAfterEitherAsyncExample() {\n    CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(this::generateNumber1);\n    CompletableFuture&lt;Integer&gt; cf2 = CompletableFuture.supplyAsync(this::generateNumber2);\n    CompletableFuture&lt;Void&gt; cfAfterFirst = cf1.runAfterEitherAsync(cf2, this::printInfo);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cfAfterFirst.join();\n    cf1.join();\n    cf2.join();\n}\n\nprivate int generateNumber1() {\n    int value = ThreadLocalRandom.current().nextInt(5) + 1;\n    sleep(value * 1000);\n    System.out.printf(\"%s - Supplier1 - %d\\n\", Thread.currentThread().getName(), value);\n    return value;\n}\n\nprivate int generateNumber2() {\n    int value = ThreadLocalRandom.current().nextInt(5) + 1;\n    sleep(value * 1000);\n    System.out.printf(\"%s - Supplier2 - %d\\n\", Thread.currentThread().getName(), value);\n    return value;\n}\n\nprivate void printInfo() {\n    System.out.printf(\"%s - Task\\n\", Thread.currentThread().getName());\n}\n\nprivate boolean sleep(long timeInMilis) {\n    try {\n        Thread.sleep(timeInMilis);\n        return true;\n    } catch (InterruptedException e) {\n        return false;\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-5/#cuando-se-completen-dos-completablefuture","title":"Cuando se completen dos CompletableFuture","text":"<p>En algunas ocasiones lanzamos dos cadenas de operaciones as\u00edncronas y estamos interesados en ejecutar una determinada acci\u00f3n cuando se completen las dos operaciones, independiente de los valores con el que se hayan completado.</p> <p>Para este cometido tenemos disponible el m\u00e9todo <code>runAfterBothAsync(completableFuture, runnable)</code>, que ejecuta el runnable pasado como argumento cuando los dos CompletableFuture (sobre que el se ha ejecuta el m\u00e9todo y el que se ha pasado como argumento) son completados.</p> <p>Este m\u00e9todo retorna un <code>CompletableFuture&lt;Void&gt;</code>, ya que el runnable no retorna nada, por lo que no se podr\u00e1 encadenar m\u00e1s operaciones tras \u00e9l. Por este motivo solo se puede usar este m\u00e9todo al final de una cadena de operaciones.</p> <p>El m\u00e9todo se encuentra sobrecargado <code>runAfterBothAsync(completableFuture, runnable, executor)</code>, para recibir el executor en el que queremos ejecutar el runnable.</p> <p>M\u00e9todo runAfterBoth</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>runAfterBoth(completableFuture, runnable)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que el consumer se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <pre><code>private void runAfterBothAsyncExample() {\n    CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(this::generateNumber1);\n    CompletableFuture&lt;Integer&gt; cf2 = CompletableFuture.supplyAsync(this::generateNumber2);\n    CompletableFuture&lt;Void&gt; cfAfterBoth = cf1.runAfterBothAsync(cf2, this::printInfo);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cfAfterBoth.join();\n}\n\nprivate int generateNumber1() {\n    int value = ThreadLocalRandom.current().nextInt(5) + 1;\n    sleep(value * 1000);\n    System.out.printf(\"%s - Supplier1 - %d\\n\", Thread.currentThread().getName(), value);\n    return value;\n}\n\nprivate int generateNumber2() {\n    int value = ThreadLocalRandom.current().nextInt(5) + 1;\n    sleep(value * 1000);\n    System.out.printf(\"%s - Supplier2 - %d\\n\", Thread.currentThread().getName(), value);\n    return value;\n}\n\nprivate void printInfo() {\n    System.out.printf(\"%s - Task\\n\", Thread.currentThread().getName());\n}\n\nprivate boolean sleep(long timeInMilis) {\n    try {\n        Thread.sleep(timeInMilis);\n        return true;\n    } catch (InterruptedException e) {\n        return false;\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-6/","title":"6 Consumir el resultado de manera as\u00edncrona","text":""},{"location":"bloque_v/tema_28/page-6/#cuando-se-complete-un-completablefuture","title":"Cuando se complete un CompletableFuture","text":"<p>El m\u00e9todo <code>thenAcceptAsync(consumer)</code> permite pasar el resultado de la tarea de un <code>CompletableFuture</code> a un consumidor para que haga uso de \u00e9l.</p> <p>El m\u00e9todo <code>thenAcceptAsync()</code> retorna un <code>CompletableFuture&lt;Void&gt;</code>, ya que la funci\u00f3n consumidora no retorna nada, por lo que no se podr\u00e1 encadenar otra operaci\u00f3n despu\u00e9s de \u00e9l. Corresponde a una tarea terminal, por lo que siempre se utiliza al final de una cadena de operaciones.</p> <p>La ventaja que tiene el m\u00e9todo <code>thenAcceptAsync(consumer)</code> es que la ejecuci\u00f3n encadenada de ambas operaciones se realiza de manera as\u00edncrona sin que sea necesaria la intervenci\u00f3n del hilo principal, es decir sin que \u00e9ste tenga que hacer <code>get()</code>.</p> <p>Este m\u00e9todo se encuentra sobrecargado, <code>thenAcceptAsync(consumer, executor)</code>, de manera que recibe un segundo par\u00e1metro en el que indicaremos el ejecutor en el que debe consumirse el valor.</p> <p>M\u00e9todo thenAccept</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>thenAccept(consumer)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que el consumer se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <p>Veamos un ejemplo:</p> <pre><code>private void thenAcceptAsyncExample() {\n    CompletableFuture&lt;Void&gt; cf = \n        CompletableFuture.supplyAsync(this::generateNumber)\n        .thenAcceptAsync(this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cf.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    return 2;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-6/#cuando-se-complete-un-completablefuture-retornando-el-valor-con-el-que-se-ha-completado","title":"Cuando se complete un CompletableFuture retornando el valor con el que se ha completado","text":"<p>Como hemos comentado en el apartado anterior, el m\u00e9todo <code>thenAcceptAsync()</code> retorna un <code>CompletableFuture&lt;Void&gt;</code>, ya que la funci\u00f3n consumidora no retorna nada, por lo que no se podr\u00e1 encadenar otra operaci\u00f3n despu\u00e9s de \u00e9l, al ser una operaci\u00f3n terminal.</p> <p>Sin embargo hay ocasiones en las que queremos consumir el valor simplemente para realizar alguna tarea auxiliar colateral, pero que podamos continuar la cadena de operaciones. Para ello tenemos disponible el m\u00e9todo <code>whenCompleteAsync(biConsumer)</code>, al que pasamos un biConsumer que recibir\u00e1 el valor con el que se ha completado el CompletableFuture y un Throwable con la excepci\u00f3n que se ha producido. Uno de los dos argumentos ser\u00e1 <code>null</code> dependiendo de si el CompletableFuture ha sido completado con una excepci\u00f3n o completado correctamente produciendo un valor.</p> <p>El m\u00e9todo <code>whenCompleteAsync(biConsumer)</code> retorna un <code>CompletableFuture&lt;T&gt;</code>, donde <code>T</code> es el tipo del CompletableFuture sobre el que se ejecuta, ya que retorna el valor con el que \u00e9ste es completado. Por tanto, podemos encadenar m\u00e1s operaciones despu\u00e9s de esta operaci\u00f3n. En este sentido es similar a la operaci\u00f3n peek() de los Streams.</p> <p>Este m\u00e9todo se encuentra sobrecargado, <code>whenCompleteAsync(biConsumer, executor)</code>, de manera que recibe un segundo par\u00e1metro en el que indicaremos el ejecutor en el que debe ejecutarse el biConsumer.</p> <p>M\u00e9todo whenComplete</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>whenComplete(biConsumer)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que el biConsumer se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <pre><code>private void whenCompleteAsyncExample() {\n    CompletableFuture&lt;Void&gt; cf =\n        CompletableFuture.supplyAsync(this::generateNumber)\n        .whenCompleteAsync(this::log)\n        .thenApplyAsync(this::duplicate)\n        .thenAcceptAsync(this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cf.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    return 2;\n}\n\nprivate void log(Integer value, Throwable throwable) {\n    if (value != null) {\n        System.out.printf(\"%s - Before Duplication - %d\\n\",\n                        Thread.currentThread().getName(), value);\n    }\n}\n\nprivate Integer duplicate(Integer value) {\n    int duplicated = value * 2;\n    System.out.printf(\"%s - Function - Duplicated: %d\\n\",\n                    Thread.currentThread().getName(), duplicated);\n    return duplicated;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-6/#cuando-se-complete-el-primero-de-dos-completablefuture","title":"Cuando se complete el primero de dos CompletableFuture","text":"<p>Algunas veces lanzamos dos cadenas de operaciones as\u00edncronas, pero s\u00f3lo estamos interesados en el primer resultado obtenido de los dos posibles. Si queremos consumir dicho resultado podemos usar el m\u00e9todo <code>acceptEitherAsync(completableFuture, consumer)</code>. Evidentemente el tipo del resultado de ambos CompletableFuture (sobre el que se ejecuta el m\u00e9todo y el pasado como argumento) tiene que ser el mismo.</p> <p>Este m\u00e9todo retorna un <code>CompletableFuture&lt;Void&gt;</code>, ya que se usa para consumir un valor, por lo que no se podr\u00e1 encadenar m\u00e1s operaciones tras \u00e9l. Por este motivo solo se puede usar este m\u00e9todo al final de una cadena de operaciones.</p> <p>El m\u00e9todo se encuentra sobrecargado <code>acceptEitherAsync(completableFuture, consumer, executor)</code> para recibir el executor en el que queremos ejecutar el consumer.</p> <p>Un aspecto muy importante es que este m\u00e9todo no cancela la ejecuci\u00f3n de la segunda operaci\u00f3n una vez que es completada la primera en ser completada.</p> <p>M\u00e9todo acceptEither</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>acceptEither(completableFuture, consumer)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que el consumer se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <pre><code>private void acceptEitherAsyncExample() {\n    CompletableFuture&lt;Integer&gt; cf1 = \n        CompletableFuture.supplyAsync(this::generateNumber1);\n    CompletableFuture&lt;Integer&gt; cf2 = \n        CompletableFuture.supplyAsync(this::generateNumber2);\n    CompletableFuture&lt;Void&gt; cfFirstConsumed = \n        cf1.acceptEitherAsync(cf2, this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cfFirstConsumed.join();\n    cf1.join();\n    cf2.join();\n}\n\nprivate int generateNumber1() {\n    int value = ThreadLocalRandom.current().nextInt(5) + 1;\n    sleep(value * 1000);\n    System.out.printf(\"%s - Supplier1 - %d\\n\", Thread.currentThread().getName(), value);\n    return value;\n}\n\nprivate int generateNumber2() {\n    int value = ThreadLocalRandom.current().nextInt(5) + 1;\n    sleep(value * 1000);\n    System.out.printf(\"%s - Supplier2 - %d\\n\", Thread.currentThread().getName(), value);\n    return value;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %s\\n\",\n                    Thread.currentThread().getName(), value);\n}\n\nprivate boolean sleep(long timeInMilis) {\n    try {\n        Thread.sleep(timeInMilis);\n        return true;\n    } catch (InterruptedException e) {\n        return false;\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-6/#cuando-se-completen-dos-completablefuture","title":"Cuando se completen dos CompletableFuture","text":"<p>Algunas veces lanzamos dos cadenas de operaciones as\u00edncronas y estamos interesados en consumir sus resultados de forma conjunta cuando ambas han completado. Para ello podemos usar el m\u00e9todo <code>thenAcceptBothAsync(completableFuture, biConsumer)</code>.</p> <p>Este m\u00e9todo retorna un <code>CompletableFuture&lt;Void&gt;</code>, ya que se usa para consumir dos valores, por lo que no se podr\u00e1 encadenar m\u00e1s operaciones tras \u00e9l. Por este motivo solo se puede usar este m\u00e9todo al final de una cadena de operaciones.</p> <p>El m\u00e9todo se encuentra sobrecargado <code>thenAcceptBothAsync(completableFuture, biConsumer, executor)</code> para recibir el executor en el que queremos ejecutar el consumer.</p> <p>M\u00e9todo thenAcceptBoth</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>thenAcceptBoth(completableFuture, biConsumer)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que el consumer se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <pre><code>private void thenAcceptBothAsyncExample() {\n    CompletableFuture&lt;Integer&gt; cf1 = \n        CompletableFuture.supplyAsync(this::generateNumber1);\n    CompletableFuture&lt;Integer&gt; cf2 = \n        CompletableFuture.supplyAsync(this::generateNumber2);\n    CompletableFuture&lt;Void&gt; cfBothConsumed = cf1.thenAcceptBothAsync(cf2, this::add);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cfBothConsumed.join();\n}\n\nprivate int generateNumber1() {\n    int value = ThreadLocalRandom.current().nextInt(5) + 1;\n    sleep(value * 1000);\n    System.out.printf(\"%s - Supplier1 - %d\\n\", Thread.currentThread().getName(), value);\n    return value;\n}\n\nprivate int generateNumber2() {\n    int value = ThreadLocalRandom.current().nextInt(5) + 1;\n    sleep(value * 1000);\n    System.out.printf(\"%s - Supplier2 - %d\\n\", Thread.currentThread().getName(), value);\n    return value;\n}\n\nprivate void add(Integer value1, Integer value2) {\n    System.out.printf(\"%s - BiConsumer - %d + %d = %d\\n\",\n                    Thread.currentThread().getName(), value1, value2, value1 + value2);\n}\n\nprivate boolean sleep(long timeInMillis) {\n    try {\n        Thread.sleep(timeInMillis);\n        return true;\n    } catch (InterruptedException e) {\n        return false;\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-7/","title":"7 Transformar el resultado de manera as\u00edncrona","text":""},{"location":"bloque_v/tema_28/page-7/#cuando-se-complete-un-completablefuture","title":"Cuando se complete un CompletableFuture","text":"<p>El m\u00e9todo <code>thenApplyAsync(function)</code> retornar\u00e1 un nuevo <code>CompletableFuture&lt;T&gt;</code> donde <code>T</code> corresponder\u00e1 al tipo de retorno de la funci\u00f3n de transformaci\u00f3n pasada como argumento, que se aplicar\u00e1 sobre el valor del CompletableFuture original sobre el que se ejecuta.</p> <p>M\u00e9todo thenApply</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>thenApply(function)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que la function se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <pre><code>private void thenApplyAsyncExample() {\n    CompletableFuture&lt;Void&gt; cf =\n        CompletableFuture.supplyAsync(this::generateNumber)\n                        .thenApplyAsync(this::duplicate)\n                        .thenAcceptAsync(this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cf.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    return 2;\n}\n\nprivate Integer duplicate(Integer value) {\n    int duplicated = value * 2;\n    System.out.printf(\"%s - Function - Duplicated: %d\\n\",\n                    Thread.currentThread().getName(), duplicated);\n    return duplicated;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre> <p>El tipo <code>T</code> del valor de retorno de la funci\u00f3n de transformaci\u00f3n NO tiene por qu\u00e9 ser el mismo del tipo del valor del <code>CompletableFuture</code> original. Por ejemplo:</p> <pre><code>private void thenApplyAsyncExample() {\n    CompletableFuture&lt;Void&gt; cf =\n        CompletableFuture.supplyAsync(this::generateNumber)\n                        .thenApplyAsync(this::duplicate)\n                        .thenAcceptAsync(this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cf.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    return 2;\n}\n\nprivate String duplicate(Integer value) {\n    String duplicated = \"value \" + (value * 2);\n    System.out.printf(\"%s - Function - Duplicated: %s\\n\",\n                    Thread.currentThread().getName(), duplicated);\n    return duplicated;\n}\n\nprivate void printNumber(String value) {\n    System.out.printf(\"%s - Consumer - %s\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre> <p>Funciona por tanto como el map cl\u00e1sico de la programaci\u00f3n funcional.</p>"},{"location":"bloque_v/tema_28/page-7/#cuando-se-complete-un-completablefuture-y-la-function-retorne-un-completablefuture-compose","title":"Cuando se complete un CompletableFuture y la function retorne un CompletableFuture (compose)","text":"<p>Supongamos que encadenamos una tarea mediante <code>thenApplyAsync(function)</code>. Como ya sabemos, dicho m\u00e9todo retornar\u00e1 un <code>CompletableFuture&lt;T&gt;</code>, donde <code>T</code> corresponde al tipo de valor de retorno de la funci\u00f3n suministrada a <code>thenApplyAsync()</code>. Pero \u00bfqu\u00e9 ocurre si dicha funci\u00f3n no puede calcular el valor inmediatamente sino que retorna un valor futuro en forma de <code>CompletableFuture&lt;Integer&gt;</code>? Como consecuencia, el tipo de retorno del m\u00e9todo <code>thenApplyAsync</code> ser\u00e1 <code>CompletableFuture&lt;CompletableFuture&lt;Integer&gt;&gt;</code>. Si encadenamos varias operaciones de este tipo el tipo de retorno cada vez se hace m\u00e1s problem\u00e1tico <code>CompletableFuture&lt;CompletableFuture&lt;CompletableFuture&lt;...</code>, lo que hace que no sea pr\u00e1ctico.</p> <p>Para solucionar este problema, cuando la funci\u00f3n vaya a retornar un <code>CompletableFuture</code>, en vez de usar el m\u00e9todo <code>thenApplyAsync(function)</code>, deberemos usar el m\u00e9todo <code>thenComposeAsync(functionReturnsCompletableFuture)</code>, que retorna directamente el valor de retorno de la funci\u00f3n suministrada, que deber\u00e1 ser un CompletableFuture, evitando as\u00ed encapsular el CompletableFuture retornado dentro dentro de otro CompletableFuture.</p> <p>El m\u00e9todo est\u00e1 sobrecargado <code>thenComposeAsync(functionReturnsCompletableFuture, executor)</code> para que podamos indicar en qu\u00e9 ejecutor queremos que se ejecute la funci\u00f3n.</p> <p>Su comportamiento corresponde a la operaci\u00f3n <code>flatMap</code> de la programaci\u00f3n funcional.</p> <p>M\u00e9todo thenCompose</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>thenCompose(functionReturnsCompletableFuture)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que la function se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <pre><code>private void thenComposeAsyncExample() {\n    CompletableFuture&lt;Void&gt; cf = \n        CompletableFuture.supplyAsync(this::generateNumber)\n                        .thenComposeAsync(this::duplicate)\n                        .thenAcceptAsync(this::printNumber(value));\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cf.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    return 2;\n}\n\nprivate CompletableFuture&lt;Integer&gt; duplicate(Integer value) {\n    return CompletableFuture.supplyAsync(() -&gt; {\n        int duplicated = value * 2;\n        System.out.printf(\"%s - Function - Duplicated: %d\\n\",\n                        Thread.currentThread().getName(), duplicated);\n        return duplicated;\n    });\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-7/#cuando-se-complete-el-primero-de-dos-completablefuture","title":"Cuando se complete el primero de dos CompletableFuture","text":"<p>Algunas veces lanzamos dos cadenas de operaciones as\u00edncronas, pero s\u00f3lo estamos interesados en el primer resultado obtenido de los dos posibles. Si queremos transformar dicho resultado podemos usar el m\u00e9todo <code>applyToEitherAsync(completableFuture, function)</code>. Evidentemente el tipo del resultado de ambos CompletableFuture (sobre el que se ejecuta el m\u00e9todo y el pasado como argumento) tiene que ser el mismo.</p> <p>Este m\u00e9todo retorna un <code>CompletableFuture&lt;T&gt;</code>, donde <code>T</code> es el tipo de retorno de la function. Podemos encadenar m\u00e1s operaciones detr\u00e1s de la llamada a este m\u00e9todo.</p> <p>El m\u00e9todo se encuentra sobrecargado <code>applyToEitherAsync(completableFuture, function, executor)</code> para recibir el executor en el que queremos ejecutar la function.</p> <p>Un aspecto muy importante es que este m\u00e9todo no cancela la ejecuci\u00f3n de la segunda operaci\u00f3n una vez que es completada la primera en ser completada.</p> <p>M\u00e9todo applyToEither</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>applyToEither(completableFuture, function)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que la function se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <pre><code>private void applyToEitherAsyncExample() {\n    CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(this::generateNumber1);\n    CompletableFuture&lt;Integer&gt; cf2 = CompletableFuture.supplyAsync(this::generateNumber2);\n    CompletableFuture&lt;Void&gt; cfFirstTransformedAndConsumed =\n        cf1.applyToEitherAsync(cf2, this::duplicate)\n        .thenAccept(this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cfFirstTransformedAndConsumed.join();\n    cf1.join();\n    cf2.join();\n}\n\nprivate int generateNumber1() {\n    int value = ThreadLocalRandom.current().nextInt(5) + 1;\n    sleep(value * 1000);\n    System.out.printf(\"%s - Supplier1 - %d\\n\", Thread.currentThread().getName(), value);\n    return value;\n}\n\nprivate int generateNumber2() {\n    int value = ThreadLocalRandom.current().nextInt(5) + 1;\n    sleep(value * 1000);\n    System.out.printf(\"%s - Supplier2 - %d\\n\", Thread.currentThread().getName(), value);\n    return value;\n}\n\nprivate Integer duplicate(Integer value) {\n    int duplicated = value * 2;\n    System.out.printf(\"%s - Function - Duplicated: %d\\n\",\n                    Thread.currentThread().getName(), duplicated);\n    return duplicated;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n\nprivate boolean sleep(long timeInMilis) {\n    try {\n        Thread.sleep(timeInMilis);\n        return true;\n    } catch (InterruptedException e) {\n        return false;\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-7/#cuando-se-completen-dos-completablefuture-combine","title":"Cuando se completen dos CompletableFuture (combine)","text":"<p>Algunas veces lanzamos dos cadenas de operaciones as\u00edncronas y estamos interesados en combinar sus resultados cuando ambas han completado, mediante una funci\u00f3n de combinaci\u00f3n que produzca un resultado combinado con el que seguir la cadena de operaciones.</p> <p>Para ello tenemos disponible el m\u00e9todo <code>thenCombineAsync(completableFuture, biFunction)</code>, que retorna un <code>CompletableFuture&lt;U&gt;</code> donde <code>U</code> corresponde al tipo de retorno de la biFunction. La biFunction recibir\u00e1 dos par\u00e1metros, el primero de un tipo <code>T</code>, correspondiente al tipo del valor al que se ha completado el CompletableFuture sobre el que estamos ejecutando el m\u00e9todo <code>thenCombineAsync()</code>, y el segundo par\u00e1metro de un tipo <code>R</code>, correspondiente al tipo del valor al que se ha completado el CompletableFuture pasado como argumento a <code>thenCombineAsync()</code>.</p> <p>La biFunction s\u00f3lo ser\u00e1 ejecutada cuando ambos CompletableFuture (sobre el que se est\u00e1 ejecutando y el pasado como argumento) han completado su ejecuci\u00f3n.</p> <p>El m\u00e9todo est\u00e1 sobrecargado <code>thenCombineAsync(completableFuture, biFunction, executor)</code> para recibir un tercer argumento con el ejecutor en el que queremos que se ejecute la biFunction.</p> <p>M\u00e9todo thenCombine</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>thenCombine(completableFuture, biFunction)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que la biFunction se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <pre><code>private void thenCombineAsyncExample() {\n    CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(this::generateNumber);\n    CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(this::generateName);\n    CompletableFuture&lt;Void&gt; cfCombined = \n        cf1.thenCombineAsync(cf2, this::combineNumberAndName)\n        .thenAcceptAsync(this::printCombination);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cfCombined.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Number Supplier\\n\", Thread.currentThread().getName());\n    return 2;\n}\n\nprivate String generateName() {\n    System.out.printf(\"%s - Name Supplier\\n\", Thread.currentThread().getName());\n    return \"Baldomero\";\n}\n\nprivate String combineNumberAndName(Integer number, String name) {\n    String combination = name + \" \" + number;\n    System.out.printf(\"%s - Bifunction: %s\\n\", \n                    Thread.currentThread().getName(), combination);\n    return combination;\n}\n\nprivate void printCombination(String combination) {\n    System.out.printf(\"%s - Consumer - %s\\n\",\n                    Thread.currentThread().getName(), combination);\n}\n</code></pre> <p>Digamos que corresponde a una reducci\u00f3n simple de dos CompletableFutures en uno solo.</p>"},{"location":"bloque_v/tema_28/page-8/","title":"8 Gesti\u00f3n de excepciones","text":""},{"location":"bloque_v/tema_28/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Internamente, un <code>CompletableFuture</code> contiene dos canales distintos, el canal de datos en el que se almacenan los resultados de la cadena de operaciones, y el canal de error, en el que albergan las excepciones generadas en la cadena de operaciones.</p> <p>Si alguna tarea de la cadena de tareas genera una excepci\u00f3n, el m\u00e9todo <code>isCompletedExceptionally()</code> del <code>CompletableFuture</code> retornar\u00e1 <code>true</code>, el m\u00e9todo <code>get()</code> producir\u00e1 una excepci\u00f3n <code>ExecutionException</code>, y los m\u00e9todos <code>join()</code> y <code>getNow()</code> producir\u00e1n una excepci\u00f3n <code>CompletionException</code>.</p> <p>Por defecto, las operaciones posteriores a la que gener\u00f3 el error dentro de la cadena de operaciones NO ser\u00e1n ejecutadas, ya que el canal de datos de la cadena deja de producir datos tras la excepci\u00f3n, que se propaga por el canal de error de la cadena de operaciones.</p> <p>Veamos un ejemplo:</p> <pre><code>private void exceptionExample() {\n    CompletableFuture&lt;Void&gt; cf =\n        CompletableFuture.supplyAsync(this::generateNumber)\n        .thenApplyAsync(this::duplicate)\n        .thenAcceptAsync(this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    // Esta operaci\u00f3n lanza la excepci\u00f3n CompletionException porque \n    // el CompletableFuture resultante de la cadena de operaciones \n    // fue completado con una excepci\u00f3n.\n    cf.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    throw new RuntimeException();\n}\n\nprivate Integer duplicate(Integer value) {\n    int duplicated = value * 2;\n    System.out.printf(\"%s - Function - Duplicated: %d\\n\",\n                    Thread.currentThread().getName(), duplicated);\n    return duplicated;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-8/#manejo-de-valor-o-excepcion-handle","title":"Manejo de valor o excepci\u00f3n (handle)","text":"<p>Si queremos gestionar una excepci\u00f3n lanzada en la cadena de operaciones podemos usar el m\u00e9todo <code>handleAsync(biFunction)</code>, a la que pasamos una biFunction que recibe el valor con el que se ha completado el CompletableFuture y el Throwable si ha sido completado con excepci\u00f3n, uno de los cuales ser\u00e1 <code>null</code>.</p> <p>La biFunction ser\u00e1 ejecutada en un hilo del <code>ForkJoinPool.commonPool()</code>, y deber\u00e1 retornar el nuevo resultado con el que se debe seguir la cadena de operaciones, permitiendo as\u00ed la recuperaci\u00f3n del error. Si no queremos recuperarnos de error o lanzar otro distinto, simplemente deberemos de hacer que la biFunction lance una excepci\u00f3n.</p> <p>Este m\u00e9todo se encuentra sobrecargado, <code>handleAsync(biFunction, executor)</code>, para recibir el executor en el que queremos que se ejecute la biFunction.</p> <p>M\u00e9todo handle con ejecutor</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>handle(biFunction, executor)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que la biFunction se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <p>El m\u00e9todo <code>handleAsync(biFunction)</code> es llamado siempre, tanto si la operaci\u00f3n anterior ha sido completada correctamente como si se ha generado una excepci\u00f3n, lo que determinar\u00e1 cu\u00e1l de los dos par\u00e1metros de la biFunction recibir\u00e1 un valor real y cu\u00e1l recibir\u00e1 <code>null</code>.</p> <pre><code>private void handleExample() {\n    CompletableFuture&lt;Void&gt; cf =\n        CompletableFuture.supplyAsync(this::generateNumber)\n        .handle(this::handler)\n        .thenApplyAsync(this::duplicate)\n        .thenAcceptAsync(this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cf.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    int value = ThreadLocalRandom.current().nextInt(10) + 1;\n    if (value &gt; 5) {\n        throw new RuntimeException();\n    } else {\n        return value;\n    }\n}\n\nprivate Integer handler(Integer value, Throwable throwable) {\n    Integer valueToReturn = value;\n    if (throwable != null) {\n        valueToReturn = 100;\n    }\n    System.out.printf(\"%s - Handler returning %d\\n\", \n                    Thread.currentThread().getName(), valueToReturn);\n    return valueToReturn;\n}\n\nprivate Integer duplicate(Integer value) {\n    int duplicated = value * 2;\n    System.out.printf(\"%s - Function - Duplicated: %d\\n\",\n                    Thread.currentThread().getName(), duplicated);\n    return duplicated;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-8/#manejo-exclusivo-de-la-excepcion-exceptionally","title":"Manejo exclusivo de la excepci\u00f3n (exceptionally)","text":"<p>Si queremos que se ejecute una determinada function s\u00f3lo cuando se produzca una excepci\u00f3n en la cadena de operaciones, de manera que podamos recuperarnos del error, podemos hacer uso del m\u00e9todo <code>exceptionally(function)</code>, a la que pasaremos una function que recibe el throwable correspondiente a la excepci\u00f3n lanzada, y que crear\u00e1 una nuevo CompletableFuture que ser\u00e1 completado con el valor retornado por la function, de manera que la cadena de operaciones puede proseguir a partir de ese punto, recuper\u00e1ndonos de error.</p> <p>Si en vez de de recuperarnos de error lo que queremos es lanzar uno distintos, simplemente deberemos hacer que la function lance una nueva excepci\u00f3n.</p> <p>Debemos tener en cuenta que el m\u00e9todo <code>exceptionally()</code> s\u00f3lo ser\u00e1 llamado si hay alguna excepci\u00f3n en el canal de error del <code>CompletableFuture</code> al que se aplica.</p> <pre><code>private void exceptionallyExample() {\n    CompletableFuture&lt;Void&gt; cf =\n        CompletableFuture.supplyAsync(this::generateNumber)\n        .exceptionally(this::recover)\n        .thenApplyAsync(this::duplicate)\n        .thenAcceptAsync(this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cf.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    int value = ThreadLocalRandom.current().nextInt(10) + 1;\n    if (value &gt; 5) {\n        throw new RuntimeException();\n    } else {\n        return value;\n    }\n}\n\nprivate Integer recover(Throwable throwable) {\n    int recoveringValue = 100;\n    System.out.printf(\"%s - Recovering to %d\\n\", \n                    Thread.currentThread().getName(), recoveringValue);\n    return recoveringValue;\n}\n\nprivate Integer duplicate(Integer value) {\n    int duplicated = value * 2;\n    System.out.printf(\"%s - Function - Duplicated: %d\\n\",\n                    Thread.currentThread().getName(), duplicated);\n    return duplicated;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre> <p>En el ejemplo anterior, nos recuperamos del error producido en el m\u00e9todo <code>generateNumber()</code> haciendo que la function pasada al m\u00e9todo <code>exceptionally(function)</code> retorne el valor <code>100</code>, produciendo un CompletableFuture completado con dicho valor, de manera que la cadena de operaciones puede continuar</p> <p>Las operaciones de la cadena posteriores a la excepci\u00f3n y anteriores al m\u00e9todo <code>exceptionally(function)</code> no ser\u00e1n ejecutadas, por lo que si queremos tener control sobre cada operaci\u00f3n podemos incluir una operaci\u00f3n <code>exceptionally(function)</code> despu\u00e9s de cada operaci\u00f3n que pueda lanzar una excepci\u00f3n.</p> <p>A partir de Java 12 tenemos disponible el m\u00e9todo <code>exceptionallyAsync(function)</code>, similar a <code>exceptionally(function)</code> pero en la que la function es ejecutada en un un hilo del <code>ForkJoinPool.commonPool()</code>, evitando as\u00ed que bajo ciertas circunstancias pueda ser ejecutada en el hilo principal, como ocurre con <code>exceptionally(function)</code>.</p> <p>Este m\u00e9todo se encuentra sobrecargado, <code>exceptionallyAsync(function, executor)</code>, para recibir el executor en el que queremos que se ejecute la function.</p>"},{"location":"bloque_v/tema_28/page-8/#manejo-exclusivo-de-la-excepcion-ejecutando-otro-completablefuture","title":"Manejo exclusivo de la excepci\u00f3n ejecutando otro CompletableFuture","text":"<p>Si el valor de recuperaci\u00f3n ante una excepci\u00f3n proviene de la ejecuci\u00f3n de otra cadena de operaciones, usar <code>exceptionally(function)</code> puede no ser la mejor opci\u00f3n, ya que si la function retorna un CompletableFuture en vez de un simple valor el CompletableFuture resultante ser\u00eda del tipo <code>CompletableFuture&lt;CompletableFuture&lt;T&gt;&gt;</code>, dificult\u00e1ndonos el encadenamiento de m\u00e1s operaciones.</p> <p>Por este motivo, Java 12 introdujo el m\u00e9todo <code>exceptionallyComposeAsync(function)</code>, que permite a la function retornar un CompletableFuture, cuyo valor ser\u00e1 usado internamente para crear el Completable retornado por el m\u00e9todo, cuyo tipo ser\u00e1 <code>CompletableFuture&lt;T&gt;</code>. La function ser\u00e1 ejecutada en un hilo del <code>ForkJoinPool.commonPool()</code>.</p> <p>Este m\u00e9todo se encuentra sobrecargado, <code>exceptionallyComposeAsync(function, executor)</code>, para recibir el executor en el que queremos que se ejecute la function.</p> <p>exceptionallyCompose</p> <p>Tambi\u00e9n existe el m\u00e9todo <code>exceptionallyCompose(function)</code>, pero debemos tener en cuenta que bajo ciertas circunstancias es posible que la function se ejecute en el hilo principal, como vimos anteriormente en el caso de <code>thenRun(runnable)</code>.</p> <p>Debemos tener en cuenta que el m\u00e9todo <code>exceptionallyComposeAsync()</code> s\u00f3lo ser\u00e1 llamado si hay alguna excepci\u00f3n en el canal de error del <code>CompletableFuture</code> al que se aplica.</p> <pre><code>private void exceptionallyComposeAsyncExample() {\n    CompletableFuture&lt;Void&gt; cf =\n        CompletableFuture.supplyAsync(this::generateNumber)\n        .exceptionallyComposeAsync(this::recover)\n        .thenApplyAsync(this::duplicate)\n        .thenAcceptAsync(this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cf.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    int value = ThreadLocalRandom.current().nextInt(10) + 1;\n    if (value &gt; 5) {\n        throw new RuntimeException();\n    } else {\n        return value;\n    }\n}\n\nprivate CompletableFuture&lt;Integer&gt; recover(Throwable throwable) {\n    System.out.printf(\"%s - Recovering\\n\", \n                    Thread.currentThread().getName());\n    return CompletableFuture.supplyAsync(this::generateRecoveringValue);\n}\n\nprivate int generateRecoveringValue() {\n    int recoveringValue = 100;\n    System.out.printf(\"%s - Generating recovery value %d\\n\", \n                    Thread.currentThread().getName(), recoveringValue);\n    return recoveringValue;\n}\n\nprivate Integer duplicate(Integer value) {\n    int duplicated = value * 2;\n    System.out.printf(\"%s - Function - Duplicated: %d\\n\",\n                    Thread.currentThread().getName(), duplicated);\n    return duplicated;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-8/#manejo-de-la-excepcion-sin-recuperacion","title":"Manejo de la excepci\u00f3n sin recuperaci\u00f3n","text":"<p>En algunas ocasiones simplemente queremos saber si se ha obtenido un resultado o se ha propagado un error producido en alguna de las operaciones anteriores. Para gestionar este caso tenemos disponible el m\u00e9todo <code>whenCompleteAsync(biFunction)</code>, que ya conocemos cuya biFunction recibe un resultado y un Throwable, uno de los cuales ser\u00e1 <code>null</code>.</p> <p>La diferencia principal con respecto a <code>handle(biFunction)</code> es que no trata de recuperarse de la excepci\u00f3n (no es necesario retornar nada) y si no se ha producido un error y se ha obtenido resultado, autom\u00e1ticamente el <code>CompletableFuture</code> resultante ser\u00e1 completado con dicho resultado, sin que nosotros tengamos que retornarlo como hac\u00edamos con <code>handle(biFunction)</code>.</p>"},{"location":"bloque_v/tema_28/page-9/","title":"9 Completando expl\u00edcitamente un CompletableFuture","text":""},{"location":"bloque_v/tema_28/page-9/#introduccion","title":"Introducci\u00f3n","text":"<p>Como hemos podido comprobar, un <code>CompletableFuture</code> es una especie de contenedor de un resultado futuro. Hasta ahora hemos usado alg\u00fan m\u00e9todo est\u00e1tico para construir el <code>CompletableFuture</code> indicando la tarea que debe ejecutar.</p> <p>Sin embargo, tenemos otra posibilidad a\u00fan m\u00e1s flexible, que consiste en crear un objeto <code>CompletableFuture</code> como un simple contenedor, sin asociarle inicialmente ninguna tarea, y posteriormente cuando se haya terminado de ejecutar la tarea deseada, se indique expl\u00edcitamente que se ha completado el <code>CompletableFuture</code> proporcionando el valor de resultado.</p> <p>Si en un momento dado queremos saber si un <code>CompletableFuture</code> ha sido completado o no, podemos llamar a su m\u00e9todo <code>isDone()</code> que retornar\u00e1 un valor booleano indicativo de si ya ha sido completado.</p>"},{"location":"bloque_v/tema_28/page-9/#con-un-valor","title":"Con un valor","text":"<p>Para crear un <code>CompletableFuture</code> de esta manera tan s\u00f3lo tendremos que llamar a su constructor con el operador <code>new</code>, igual que har\u00edamos con cualquier otra clase. Cuando se desee indicar expl\u00edcitamente que se ha completado el <code>CompletableFuture</code> y ya tengamos el valor resultado disponible, llamaremos a su m\u00e9todo <code>complete(resultado)</code>.</p> <p>En el siguiente ejemplo se crea una funci\u00f3n que ejecuta una tarea as\u00edncrona que retorna un <code>CompletableFuture</code> que posteriormente es completado de forma expl\u00edcita:</p> <pre><code>public static CompletableFuture&lt;String&gt; asyncGreet() {\n    CompletableFuture&lt;String&gt; completableFuture = new CompletableFuture&lt;&gt;();\n    Executors.newCachedThreadPool().submit(() -&gt; {\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        String greeting = \"Quillo que\";\n        System.out.printf(\"%s - Greeting - %s\\n\", \n                        Thread.currentThread().getName(), greeting);\n        completableFuture.complete(greeting);\n    });\n    return completableFuture;\n}\n</code></pre> <p>Y para dicha funci\u00f3n har\u00edamos, por ejemplo:</p> <pre><code>// Se construye la cadena de operaciones, \n// que no es ejecutada hasta que no se completa expl\u00edcitamente \n// el CompletableFuture original.\nCompletableFuture&lt;String&gt; completableFuture = asyncGreet();\ncompletableFuture.thenAccept(greeting -&gt; System.out.printf(\"%s - Consumer - %s\\n\",\n    Thread.currentThread().getName(), greeting));\nSystem.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n</code></pre>"},{"location":"bloque_v/tema_28/page-9/#con-un-valor-por-defecto-tras-un-tiempo-maximo","title":"Con un valor por defecto tras un tiempo m\u00e1ximo","text":"<p>Desde Java 9, podemos hacer que un CompletableFuture sea completado con un valor por defecto si transcurrido un determinado tiempo m\u00e1ximo (timeout) \u00e9ste no ha sido completado de forma natural. Para ello usaremos el m\u00e9todo <code>completeOnTimeout(value, timeout, timeUnit)</code> sobre dicho CompletableFuture, que retornar\u00e1 un nuevo CompletableFuture que ser\u00e1 completado con el valor (o excepci\u00f3n) del CompletableFuture anterior si \u00e9ste es completado antes del timeout, o con el valor pasado como argumento si transcurrido dicho tiempo el CompletableFuture anterior no ha sido completado.</p> <p>Veamos un ejemplo:</p> <pre><code>private void completeOnTimeoutExample() {\n    CompletableFuture&lt;Void&gt; cf =\n        CompletableFuture.supplyAsync(this::generateNumber)\n        .completeOnTimeout(100, 5, TimeUnit.SECONDS)\n        .thenAcceptAsync(this::printNumber);\n    System.out.printf(\"%s - Main\\n\", Thread.currentThread().getName());\n    cf.join();\n}\n\nprivate int generateNumber() {\n    System.out.printf(\"%s - Supplier\\n\", Thread.currentThread().getName());\n    int value = ThreadLocalRandom.current().nextInt(10) + 1;\n    sleep(value * 1000);\n    return value;\n}\n\nprivate void printNumber(Integer value) {\n    System.out.printf(\"%s - Consumer - %d\\n\",\n                    Thread.currentThread().getName(), value);\n}\n\nprivate boolean sleep(long timeInMilis) {\n    try {\n        Thread.sleep(timeInMilis);\n        return true;\n    } catch (InterruptedException e) {\n        return false;\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_28/page-9/#con-una-excepcion","title":"Con una excepci\u00f3n","text":"<p>Si queremos completar un <code>CompletableFuture</code> pero generando una excepci\u00f3n en vez de retornando un valor, podemos hacer uso del m\u00e9todo <code>completeExceptionally(throwable)</code>, que recibe el <code>Throwable</code> correspondiente a la excepci\u00f3n. Por ejemplo:</p> <pre><code>completableFuture.completeExceptionally(\n        new RuntimeException(\"Something went wrong\"));\n</code></pre>"},{"location":"bloque_v/tema_28/page-9/#con-una-excepcion-por-cancelacion","title":"Con una excepci\u00f3n por cancelaci\u00f3n","text":"<p>La tarea as\u00edncrona tambi\u00e9n puede cancelarse expl\u00edcitamente por alg\u00fan motivo. Para ello usar\u00e1 el m\u00e9todo <code>cancel(false)</code>, que completar\u00e1 el <code>CompletableFuture</code> generando la excepci\u00f3n <code>CancellationException</code>.</p> <p>Las siguientes operaciones de la cadena ser\u00e1n completadas con la excepci\u00f3n <code>CompletionException</code>.</p> <p>Veamos un ejemplo:</p> <pre><code>public CompletableFuture&lt;String&gt; asyncGreet() throws InterruptedException {\n    CompletableFuture&lt;String&gt; completableFuture = new CompletableFuture&lt;&gt;();\n    Executors.newCachedThreadPool().submit(() -&gt; {\n        Thread.sleep(500);\n        // Evidentemente esto se har\u00eda s\u00f3lo en unas determinadas circunstancias.\n        completableFuture.cancel(false);\n        return null;\n    });\n    return completableFuture;\n}\n</code></pre> <p>Y al usarlo se generar\u00eda la excepci\u00f3n <code>CancellationException</code>. Por ejemplo:</p> <pre><code>CompletableFuture&lt;String&gt; futuroResultado = saludoAsincronoConCancelacion();\n// ... \n// Esta l\u00ednea puede generar CancellationException.\nString resultado = futuroResultado.get();\n</code></pre> <p>Si en un momento dado queremos saber si un <code>CompletableFuture</code> ha sido cancelado, podemos llamar a su m\u00e9todo <code>isCancelled()</code> que retornar\u00e1 un valor booleano indicativo de si ha sido cancelado.</p> <p>Un aspecto muy importante es que la cancelaci\u00f3n de un CompletableFuture no interrumpe el hilo que est\u00e1 ejecutando, simplemente completa el CompletableFuture con la excepci\u00f3n <code>CancellationException</code>. Por este motivo, el valor que le pasemos al m\u00e9todo <code>cancel(boolean)</code> es totalmente irrelevante.</p>"},{"location":"bloque_v/tema_28/page-9/#con-una-excepcion-por-timeout","title":"Con una excepci\u00f3n por timeout","text":"<p>En algunas ocasiones si un CompletableFuture no ha sido completado en un tiempo m\u00e1ximo deseamos completarlo con una excepci\u00f3n <code>TimeoutException</code>. Para ello, desde Java 9, podemos usar el m\u00e9todo <code>orTimeout(timeout, timeUnit)</code>, que ejecutado sobre un CompletableFuture retorna un nuevo CompletableFuture que es completado con el valor (o excepci\u00f3n) del anterior si \u00e9ste es completado antes del timeout especificado. En caso contrario es completado con la excepci\u00f3n <code>TimeoutException</code>.</p> <pre><code>CompletableFuture&lt;Integer&gt; cf = CompletableFuture.supplyAsync(this::computeEndlessly)\n    .orTimeout(1, TimeUnit.SECONDS);\nfuture.get();\n</code></pre>"},{"location":"bloque_v/tema_28/page-9/#creacion-de-un-completablefuture-ya-completado","title":"Creaci\u00f3n de un CompletableFuture ya completado","text":"<p>Si de antemano conocemos el resultado de debe producir el <code>CompletableFuture</code> podemos simplificar a\u00fan m\u00e1s el proceso usando el m\u00e9todo est\u00e1tico <code>CompletableFuture.completedFuture(resultado)</code>, que crear\u00e1 para nosotros un CompletableFuture completado con el indicado. Por ejemplo:</p> <pre><code>Future&lt;String&gt; futuroResultado = CompletableFuture.completedFuture(\"Quillo que\");\n// ...\nString resultado = futuroResultado.get();\n</code></pre> <p>De forma similar, tenemos disponible el m\u00e9todo est\u00e1tico <code>CompletableFuture.failedFuture(throwable)</code>, que crear\u00e1 un CompletableFuture completado con la excepci\u00f3n indicada.</p> <p>Estos m\u00e9todos son \u00fatiles principalmente para los tests.</p>"},{"location":"bloque_v/tema_29/page-1/","title":"1 Arquitectura Cliente-Servidor","text":""},{"location":"bloque_v/tema_29/page-1/#arquitectura-cliente-servidor","title":"Arquitectura Cliente-Servidor","text":"<p>La forma m\u00e1s cl\u00e1sica de comunicar dispositivos digitales es aplicando el modelo de cliente-servidor. El servidor es un dispositivo que contiene informaci\u00f3n a compartir con otros agentes llamados clientes, pero no sabe cuando los clientes necesitar\u00e1n su informaci\u00f3n. Por ello el servidor deber\u00e1 estar escuchando a la espera de que alg\u00fan cliente le haga una petici\u00f3n, pidiendo qu\u00e9 parte de la informaci\u00f3n necesita. La petici\u00f3n es emitida por un cliente y codificada de tal forma que el servidor pueda interpretar. Cuando el mensaje llega al servidor, \u00e9ste detecta que la petici\u00f3n es para \u00e9l, la interpreta, genera la respuesta adecuada y la env\u00eda al cliente peticionario. Una vez resuelta la demanda, el servidor quedar\u00e1 de nuevo a la espera de nuevas peticiones.</p> <p> Figura 1 - Arquitectura cliente-servidor <p>Actualmente muchas aplicaciones siguen modelos mixtos en que los dispositivos pueden hacer de clientes y servidores a la vez, as\u00ed permiten una mayor distribuci\u00f3n de los datos y los procesos y consiguen un abaratamiento del hardware. Sin embargo, los papeles de servidor y cliente no se han perdido sino que conviven en un mismo dispositivo, a menudo como procesos independientes ejecutados a la hora.</p> <p>No se debe confundir tampoco el rol del servidor con el del receptor, ya que el servidor adem\u00e1s de recibir las peticiones de los clientes las debe procesar, obtener una respuesta y enviarla de vuelta al cliente. El cliente por su parte, debe detectar qu\u00e9 petici\u00f3n necesita realizar, debe hacer el env\u00edo de la petici\u00f3n, quedarse a la espera de la respuesta y, cuando llegue, procesarla adecuadamente.s</p>"},{"location":"bloque_v/tema_29/page-2/","title":"2 TCP / IP","text":""},{"location":"bloque_v/tema_29/page-2/#tcp-ip","title":"TCP / IP","text":"<p>TCP/IP es una familia de protocolos desarrollados para permitir la comunicaci\u00f3n entre cualquier par de ordenadores de cualquier red o fabricante, respetando los protocolos de cada red individual. Esta familia de protocolos tiene cuatros capas o niveles de abstracci\u00f3n:</p> <ul> <li>Capa de aplicaci\u00f3n: En este nivel se encuentran las aplicaciones disponibles para los usuarios, como por ejemplo HTTP, FTP, etc.</li> <li>Capa de transporte: Suministra a la capa de aplicaci\u00f3n servicio de comunicaciones de extremo a extremo utilizando dos tipos de protocolos: TCP (Transmission Control Protocol), orientado a conexi\u00f3n, y UDA (User Datagram Protocol), no orientado a conexi\u00f3n.</li> <li>Capa de red: Da servicio a la capa de transporte. Selecciona la mejor ruta para enviar paquetes por la red. Su protocolo principal es IP (Internet Protocol).</li> <li>Capa de enlace o de interfaz de red: Es la interfaz de la red real. Recibe los paquetes de la capa de red y los transmite al hardware de la red.</li> </ul> <p> Figura 2 - Pilas de capas TCP/IP <p>La cantidad de informaci\u00f3n enviada puede acabar superando ampliamente la cantidad de datos originales, ya que cada capa a\u00f1ade informaci\u00f3n extra que ser\u00e1 \u00fatil para la gesti\u00f3n. El proceso inverso en el que la informaci\u00f3n recibida asciende desde las capas bajas sufre una transformaci\u00f3n similar pero al rev\u00e9s. Es decir, a cada paso se elimina la parte de informaci\u00f3n espec\u00edfica del nivel en cuesti\u00f3n y s\u00f3lo se pasa a la capa superior la informaci\u00f3n que le es propia. Los datos extras se localizan en una cabecera para que sea f\u00e1cil de a\u00f1adir, eliminar y de leer.</p> <p> Figura 3 - Datos agregados por cada capa TCP/IP <p>Para que no nos tengamos que preocupar de las distintas capas, Java proporciona una serie de clases para trabajar con redes. Estas clases tienen distintos niveles de abstracci\u00f3n. Por un lado tenemos la clases de bajo nivel de abstracci\u00f3n, que nos van a permitir gestionar las direcciones IP, los sockets y las interfaces de red. Por otro lado, clases de m\u00e1s alto nivel de abstracci\u00f3n, como las que nos van a permitir representar URIs, URLs o conexiones con una URL. Comenzaremos por estudiar las de bajo nivel y posteriormente pasaremos a las de alto nivel.</p>"},{"location":"bloque_v/tema_29/page-3/","title":"3 InetAddress","text":""},{"location":"bloque_v/tema_29/page-3/#inetaddress","title":"InetAddress","text":"<p>Como seguramente ya sepamos, todo ordenador conectado a Internet, al que se conoce normalmente como host, debe tener una direcci\u00f3n IP. Una direcci\u00f3n IPv4 est\u00e1 formada por cuatro bytes sin signo separados por puntos, en un rango de 0 a 255, como por ejemplo ejemplo: <code>152.2.21.2</code>.</p> <p>Por su parte, una direcci\u00f3n IPv6 est\u00e1 formada por ocho bloques de cuatro d\u00edgitos hexadecimales cada uno separados por el car\u00e1cter dos puntos, no siendo obligatorio escribir los ceros a la izquierda de cada bloque, incluso aunque el bloque quede sin ning\u00fan d\u00edgito. Un ejemplo ser\u00eda <code>2001:250:2FF::250:8BFF:FEDE:67C8</code>. En redes mixtas de IPv6 y IPv4, los \u00faltimos cuatro bytes de la direcci\u00f3n se escriben algunas veces con la dotaci\u00f3n IPv4. Por ejemplo <code>FEDC:BA98:7654:3210:FEDC:BA98:7654:3210</code> se puede escribir como <code>FEDC:BA98:7654:3210:FEDC:BA98:118.84.50.16</code>.</p> <p>Para evitar tener que recordar las direcciones IP, los dise\u00f1adores de Internet crearon el sistema DNS, que asocia un nombre legible a la direcci\u00f3n IP. Por ejemplo podemos asociar el nombre <code>hermes.oit.unc.edu</code> a la IP <code>152.2.21.2</code>.</p> <p>Los ordenadores que no tienen una direcci\u00f3n IP permanente, como la mayor\u00eda de los PC de nuestra casa, no suelen poseer un nombre de dominio asociado. Por otra parte, es posible que varios nombres de dominios apunten a una misma IP. Por ejemplo <code>www.ibiblio.org</code> y <code>helios.metalab.unc.edu</code> hacen referencia a la misma m\u00e1quina. Puede suceder tambi\u00e9n que un mismo nombre de dominio apunte a varias direcciones IP, siendo responsabilidad del servidor DNS elegir aleatoriamente la m\u00e1quina a la que direccionar cada petici\u00f3n. Esta funcionalidad es utilizada principalmente con portales web con mucha carga de peticiones. Por ejemplo <code>www.oreilly.com</code>, apunta en realidad a dos m\u00e1quinas, <code>208.201.239.36</code> y <code>208.201.239.37</code>.</p> <p>Para que un equipo cliente pueda hacer uso de los nombres de dominio es necesario que tenga acceso a Internet y en concreto a alg\u00fan servidor de dominios DNS. La mayor\u00eda de estos servidores s\u00f3lo contienen la direcciones de su red local, m\u00e1s las direcciones de otros pocos servidores de dominios de otros sitios, de manera que si no es capaz de responder a una solicitud pasan la petici\u00f3n a otro servidor de dominios.</p> <p>La clase <code>InetAddress</code> representa en Java una direcci\u00f3n IP, tanto en formato IPv4 como en IPv6. Posee dos subclases, <code>Inet4Address</code> y <code>Inet6Address</code>, una para cada formato. Internamente, un objeto <code>InetAddress</code> queda representado por el par de datos <code>hostname / IP</code>.</p> <p>Para crear un un objeto de esta clase, debemos tener en cuenta que NO tiene constructores p\u00fablicos, sino que proporciona tres m\u00e9todos est\u00e1ticos factor\u00eda que retornan un objeto ya inicializado con alguna informaci\u00f3n:</p> <ul> <li><code>getByName(hostName)</code>, que retorna un objeto <code>InetAddress</code> con la direcci\u00f3n IP correspondiente a dicho nombre de m\u00e1quina.</li> <li><code>getAllByName(hostName)</code>, que retorna un <code>InetAddress[]</code> con las direcciones IP asociadas a dicho nombre de m\u00e1quina.</li> <li><code>getLocalHost()</code>, que retorna un <code>InetAddress</code> con la IP de la m\u00e1quina en la que se est\u00e1 ejecutando.</li> </ul> <p>Todos estos m\u00e9todos realizan conexiones de red para obtener toda la informaci\u00f3n que necesitan, por ejemplo consultando a un servidor de DNS si es necesario, lanzando una excepci\u00f3n <code>UnknownHostException</code> si no se puede encontrar el host indicado.</p> <p>Dado que estas operaciones puede ser costosas en tiempo, la clase <code>InetAddress</code> almacena en la cach\u00e9 el resultado de la b\u00fasqueda, para no tener que realizarla de nuevo si se crea otro objeto <code>InetAddress</code> para el mismo host.</p> <p>Existen otros dos m\u00e9todos factor\u00eda est\u00e1ticos que no chequean la direcci\u00f3n contra un servidor DNS, sino que simplemente almacenan en el objeto creado los datos que les proporcionamos:</p> <ul> <li><code>getByAddress(ipAddressByteArray)</code>, en el que proporcionamos un <code>byte[]</code> con la IP.</li> <li><code>getByAddress(hostName, ipAddressByteArray)</code>, en la que proporcionamos el nombre de la m\u00e1quina y un <code>byte[]</code> con la IP.</li> </ul> <p>Estos m\u00e9todos no garantizan que dicha m\u00e1quina exista o que est\u00e9 asociada la dicha IP. Lanzan la excepci\u00f3n <code>UnknownHostException</code> si el <code>byte[]</code> no tiene la longitud adecuada.</p> <p>Si tenemos que conectarnos a una m\u00e1quina que la que no conozcamos su hostname sino tan s\u00f3lo su IP, podemos usar el m\u00e9todo <code>getByName(ipAddressString)</code>, que recibir\u00e1 la representaci\u00f3n en cadena de caracteres de la IP correspondiente. En este caso no se realizar\u00e1 petici\u00f3n al servidor DNS, sino que el hostname almacenado ser\u00e1 la propia representaci\u00f3n textual de la IP. S\u00f3lo si una vez obtenido el objeto <code>InetAddress</code> consultamos el hostname directamente mediante el m\u00e9todo <code>getHostName()</code> o indirectamente mediante el m\u00e9todo <code>toString()</code>, se llevar\u00e1 a cabo el chequeo de la IP en el servidor DNS, y de hecho si no se encuentra, simplemente no se modifica el dato en el objeto <code>InetAddress</code> y ni siquiera se genera la excepci\u00f3n <code>UnknownHostException</code>.</p> <p>En el siguiente c\u00f3digo vemos un ejemplo de obtenci\u00f3n de un objeto <code>InetAddress</code> mediante la llamada al m\u00e9todo factor\u00eda :</p> <pre><code>try {\n    InetAddress address = InetAddress.getByName(\"www.informaticasaladillo.es\");\n    System.out.println(address);\n}\ncatch (UnknownHostException e) {\n    System.out.println(\"No se puedo encontrar www.informaticasaladillo.es\");\n}\n</code></pre> <p>Una vez construido u obtenido un objeto <code>InetAddress</code> podremos usar los siguientes m\u00e9todos informativos:</p> <ul> <li><code>getHostName()</code>: Retorna una cadena de caracteres con el hostname y la IP de un objeto <code>InetAddress</code>. Si el objeto no posee hostname, se retorna la IP en su lugar. Algunas veces el servidor DNS utiliza como hostname un nombre corto, como por ejemplo <code>titan</code> en vez del nombre completo <code>titan.oit.unc.edu</code>. Es especialmente \u00fatil si hemos creado el objeto <code>InetAddress</code> aport\u00e1ndole la IP al m\u00e9todo <code>getByName(ipAddressString)</code>, ya que nos va a permitir obtener el nombre del host.</li> <li><code>getAddress()</code>: Retorna la direcci\u00f3n IP de un objeto <code>InetAddress</code> en forma de <code>byte[]</code>, cuyo tama\u00f1o depende de si se trata de una IPv4 o IPv6. Debemos tener en cuenta que Java no define ning\u00fan tipo primitivo <code>unsigned byte</code>, por lo que este m\u00e9todo retorna un array de <code>byte</code> con signo. El problema es que en este tipo los valores mayores de 127 son tratados como n\u00famero negativos. As\u00ed si queremos trabajar con los bytes retornados por este m\u00e9todo, tendremos que convertir el <code>byte</code> con signo a un entero <code>int</code> mediante la siguiente instrucci\u00f3n: <code>int unsignedByte = signedByte &lt; 0 ? signedByte + 256 : signedByte;</code></li> <li><code>getHostAddress()</code>: Retorna la direcci\u00f3n IP de un objeto <code>InetAddress</code> en forma de cadena de caracteres.</li> </ul> <p>Por otra parte, el m\u00e9todo <code>equals()</code> retornar\u00e1 <code>true</code> si ambos objetos <code>InetAddress</code> apuntan a la misma direcci\u00f3n IP, independientemente del hostname.</p> <p>Algunas direcciones IP y algunos patrones de direcciones tienen un significado especial. Por ejemplo, <code>127.0.0.1</code> corresponde a la direcci\u00f3n de bucle de retorno (loopback) local y las direcciones en el rango <code>224.0.0.0</code> a <code>239.255.255.255</code> corresponden a direcciones de multidifusi\u00f3n (multicast). La clase <code>InetAddress</code> incorpora varios m\u00e9todos para comprobar si se trata de una direcci\u00f3n especial, como <code>isAnyLocalAddress()</code>, <code>isLoopbackAddress()</code> o <code>isMulticastAddress()</code>.</p> <p>Debemos tener en cuenta que la conexiones a un host pueden ser bloqueadas por diversos motivos, como firewalls, servidores proxy, routers mal configurados, etc. La clase <code>InetAddress</code> proporciona el m\u00e9todo <code>isReachable(timeout)</code> para poder comprobar si el host referenciado en un objeto <code>InetAddress</code> es accesible o no. Este m\u00e9todo trata de conectarse al puerto de echo del host para descubrir si es accesible o no. Si recibe respuesta antes del tiempo en milisegundos pasado como par\u00e1metro, retornar\u00e1 true. Si se produce un error en la red se generar\u00e1 la excepci\u00f3n <code>IOException</code>. Desgraciadamente este m\u00e9todo no es muy fiable para la comprobaci\u00f3n de un host en Internet, debido principalmente a los firewalls. Sin embargo s\u00ed que nos puede ser \u00fatil para comprobar la accesibilidad de un host dentro de una intranet.</p> <p>Las clases <code>Inet4Address</code> y <code>Inet6Address</code> son subclases de <code>InetAddress</code> y permiten distinguir entre los dos tipo de direcciones IP. Sin embargo, normalmente no tendremos que preocuparnos de si una IP es IPv4 o IPv6, ya que los m\u00e9todos que vayan a usarlas no har\u00e1n distinci\u00f3n entre ellas a la hora de especificarlas, por lo que habitualmente s\u00f3lo trabajaremos con la clase <code>InetAddress</code>. La clase <code>Inet6Address</code> incorpora el m\u00e9todo <code>isIPv4CompatibleAddress()</code>, para comprobar si la IP es b\u00e1sicamente una IPv4 contenida dentro de una IPv6 (es decir, tiene el formato <code>0:0:0:0:0:0:0:xxxx</code>).</p>"},{"location":"bloque_v/tema_29/page-4/","title":"4 Concepto de Socket","text":""},{"location":"bloque_v/tema_29/page-4/#concepto-de-socket","title":"Concepto de Socket","text":"<p>Las aplicaciones que hacen uso de Internet utilizan habitualmente la conocida como arquitectura, que descompone el problema en dos componentes distintos: por un lado el servidor, que ofrece (sirve) el servicio y, por otro lado, el cliente, que interact\u00faa con el usuario y hace uso del servicio proporcionado por el servidor. El correo electr\u00f3nico o la World Wide Web son ejemplos de este patr\u00f3n de dise\u00f1o.</p> <p>Para poder implementar esta arquitectura cliente/servidor en nuestras aplicaciones es necesario que exista alguna herramienta para establecer a trav\u00e9s de la red la conexi\u00f3n necesaria entre cliente y servidor, y en concreto los puntos extremos de dicha conexi\u00f3n.</p> <p>Como sabemos, la comunicaciones en red se realizan a trav\u00e9s de una pila de protocolos que trabajan de forma coordinada, de manera que los protocolos de una capa hacen uso de los protocolos de la capa inferior. La capa de transporte define dos protocolos muy importantes: el protocolo TCP, orientado a conexi\u00f3n, y el protocolo UDP, no orientado a conexi\u00f3n.</p> <p>Pues bien, los protocolos TCP y UDP utilizan el concepto de socket para definir y proporcionar los conectores o puntos extremos de la comunicaci\u00f3n entre aplicaciones o procesos. Un conector vendr\u00e1 determinado por las siguientes propiedades:</p> <ul> <li>La direcci\u00f3n IP de la m\u00e1quina en la que la aplicaci\u00f3n est\u00e1 ejecut\u00e1ndose.</li> <li>El puerto local a trav\u00e9s del cual se comunica la aplicaci\u00f3n. Un puerto es un punto de destino que identifica a qu\u00e9 aplicaci\u00f3n o proceso deben dirigirse los datos recibidos</li> </ul> <p>Socket</p> <p>Conector extremo de conexi\u00f3n entre aplicaciones o procesos a trav\u00e9s de la red</p> <p>Los protocolos TCP y UDP son los encargados de transmitir la informaci\u00f3n necesaria desde el conector de la aplicaci\u00f3n emisora al conector de la aplicaci\u00f3n receptora, de manera que los mensajes enviados a dicha IP y puerto se entreguen al proceso receptor.</p> <p>Si queremos utilizar los sockets en una aplicaci\u00f3n cliente/servidor debemos tener en cuenta que el cliente debe conocer de antemano la IP del servidor y el puerto en el que espera recibir la solicitud de conexi\u00f3n, para que \u00e9sta pueda llevarse a cabo.</p> <p>Podemos clasificar los sockets en dos tipos distintos, atendiendo al protocolo de la capa de transporte que utilicen:</p> <ul> <li>Sockets orientados a conexi\u00f3n o stream sockets, que utilizan el protocolo TCP para la comunicaci\u00f3n.</li> <li>Sockets no orientados a conexi\u00f3n o datagram sockets, que usan el protocolo UDP para la comunicaci\u00f3n.</li> </ul>"},{"location":"bloque_v/tema_29/page-5/","title":"5 Sockets orientados a conexi\u00f3n","text":""},{"location":"bloque_v/tema_29/page-5/#sockets-orientados-a-conexion","title":"Sockets orientados a conexi\u00f3n","text":"<p>Los sockets orientados a conexi\u00f3n o streams sockets son aquellos que utilizan el protocolo TCP para la comunicaci\u00f3n. Al emplear dicho protocolo, se garantiza la entrega de los mensajes en el orden en el que fueron enviados. En el protocolo TCP los mensajes llevan un acuse de recibo, de manera que si el emisor no recibe el acuse de recibo de un determinado mensaje, vuelve a transmitirlo.</p> <p> Figura 4 - Conexi\u00f3n TCP/IP <p>Una vez establecida la conexi\u00f3n los procesos pueden intercambiar mensajes a trav\u00e9s de un flujo o stream bidireccional de conexi\u00f3n (full-duplex) con acceso secuencial, sin tener que volver a preocuparse de la direcci\u00f3n IP o el puerto al que se ha realizado la conexi\u00f3n.</p> <p>En los stream sockets el servidor suele seguir los siguientes pasos:</p> <p>Algoritmo del servidor</p> <ol> <li>Inicia el servicio, poni\u00e9ndose a la espera de que alg\u00fan cliente se conecte (listen).</li> <li>Cuando un cliente solicita la conexi\u00f3n al servicio, el servidor recibe la solicitud y la acepta (accept).</li> <li>Se establece un canal de comunicaci\u00f3n bidireccional entre los conectores de ambas aplicaciones o procesos. En un bucle, el servidor recibe una petici\u00f3n de informaci\u00f3n desde el cliente (receive), la procesa y le env\u00eda la respuesta (send).</li> <li>El servidor cierra el servicio en alg\u00fan momento (close).</li> </ol> <p>Los pasos 2 y 3 pueden llevarse a cabo de manera simult\u00e1nea con varios clientes, mediante el uso de distintos hilos de ejecuci\u00f3n.</p> <p>El cliente, por su parte, suele llevar a cabo las siguientes acciones:</p> <p>Algoritmo del servidor</p> <ol> <li>Solicita la conexi\u00f3n al servicio ofrecido por el servidor (debe conocer de antemano su direcci\u00f3n y su puerto) (connect).</li> <li>Una vez aceptada la solicitud de conexi\u00f3n, en un bucle, env\u00eda una petici\u00f3n de informaci\u00f3n al servidor (send), recibe la respuesta (receive) y la procesa.</li> <li>Cuando ya no requiere de m\u00e1s informaci\u00f3n, cierra la conexi\u00f3n con el servidor (close).</li> </ol> <p>En la siguiente imagen se muestra el esquema de funcionamiento de una aplicaci\u00f3n cliente/servidor en la que el servidor es capaz de gestionar simult\u00e1neamente varios clientes:</p> <p> Figura 5 - Sockets <p>El paquete <code>java.net</code> proporciona dos clases principales para trabajar desde Java con sockets orientados a conexi\u00f3n: la clase <code>ServerSocket</code>, para crear el conector en el lado del servidor, y la clase <code>Socket</code> para solicitar una conexi\u00f3n desde el cliente, o para representar en el servidor una conexi\u00f3n establecida.</p> <p>Los pasos que debe seguir el servidor son los siguientes:</p> <p>Algoritmo detallado del servidor</p> <ol> <li>Crear un objeto <code>ServerSocket</code> llamando a su constructor <code>ServerSocket(port)</code>, proporcion\u00e1ndole el puerto por el que desea a recibir las peticiones.</li> <li>Utilizar el m\u00e9todo <code>accept()</code> del objeto <code>ServerSocket</code> para indicar que queda a la espera de que alg\u00fan cliente solicite conectarse a \u00e9l. Se trata de un m\u00e9todo s\u00edncrono bloqueante, que hace que el hilo de ejecuci\u00f3n del servidor quede bloqueado hasta que el cliente solicite la conexi\u00f3n mediante la creaci\u00f3n de un objeto <code>Socket</code> que apunte a la direcci\u00f3n del servidor y al puerto establecido. Cuando esto sucede, se crea la conexi\u00f3n y el m\u00e9todo <code>accept()</code> retorna un objeto <code>Socket</code> que representa el conector de la conexi\u00f3n en el lado del servidor.</li> <li>Si queremos que el servidor pueda atender simult\u00e1neamente a varios clientes es necesario que, una vez establecida la conexi\u00f3n, se traslade la gesti\u00f3n de la comunicaci\u00f3n con un cliente a un hilo de ejecuci\u00f3n distinto, de manera que el hilo principal del servidor pueda dedicarse a aceptar m\u00e1s clientes. De esta manera, la comunicaci\u00f3n con cada cliente se realizar\u00e1 desde un hilo independiente.</li> <li>En el hilo de comunicaci\u00f3n con el cliente, el servidor puede utilizar el m\u00e9todo <code>getOutputStream()</code> del objeto <code>Socket</code> para obtener el flujo de salida desde el servidor, de manera que pueda enviarle datos al cliente, y el m\u00e9todo <code>getInputStream()</code> para obtener el flujo de entrada al servidor, de manera que pueda recibir datos del cliente.</li> <li>Para leer o escribir en dichos flujos se utilizar\u00e1n los objetos lectores y escritores habituales, como <code>DataInputStream</code> y <code>DataOutputStream</code>, <code>BufferedReader</code> y <code>PrintWriter</code>, o <code>ObjectInputStream</code> y <code>ObjectOutputStream</code> (en cuyo caso la clase de los objetos deber\u00e1 implementar la interfaz <code>Serializable</code>). Si se trata de leer del flujo de un socket que ya ha sido cerrado por el cliente, se producir\u00e1 una exception <code>IOException</code>.</li> <li>Cuando ya no desee leer o escribir en el socket correspondiente el servidor deber\u00e1 cerrar el lector y el escritor llamando a sus m\u00e9todos <code>close()</code>. Finalmente para cerrar la conexi\u00f3n con el cliente, el servidor puede ejecutar el m\u00e9todo <code>close()</code> del objeto <code>Socket</code>. Con esta operaci\u00f3n, normalmente el hilo de gesti\u00f3n de la comunicaci\u00f3n con el cliente finalizar\u00e1 su ejecuci\u00f3n.</li> <li>Para no aceptar m\u00e1s peticiones de conexi\u00f3n con clientes, el servidor ejecutar\u00e1 el m\u00e9todo <code>close()</code> del objeto <code>ServerSocket</code>.</li> </ol>"},{"location":"bloque_v/tema_29/page-5/#proyecto-streamsocket","title":"Proyecto StreamSocket","text":"<p>En este proyecto vamos a realizar una aplicaci\u00f3n de demostraci\u00f3n en el que el hilo principal lanza por un lado un hilo servidor, y por otro lado 10 hilos cliente que tratar\u00e1n de conectarse al servidor. Lo hacemos con hilos servidor y clientes por tenerlo todo en el mismo proyecto, pero en la realidad corresponder\u00eda a aplicaciones independientes.</p> <p>Cada vez que el servidor acepte una conexi\u00f3n con un cliente se crear\u00e1 un nuevo hilo de gesti\u00f3n de la comunicaci\u00f3n con dicho cliente.</p> <p>La comunicaci\u00f3n entre el cliente y el servidor tendr\u00e1 el siguiente protocolo:</p> <ul> <li>Nada m\u00e1s establecerse la conexi\u00f3n, el cliente enviar\u00e1 un mensaje de saludo al servidor en forma de objeto de la clase <code>Message</code>, que contendr\u00e1 un atributo con el autor y otro con el contenido del mensaje.</li> <li>El servidor al establecerse la conexi\u00f3n entra en un bucle de lectura de mensajes del cliente, que termina cuando el mensaje recibido sea <code>null</code> o se produzca una <code>IOException</code> porque el cliente haya cerrado la conexi\u00f3n. Al terminar la conexi\u00f3n el servidor cerrar\u00e1 el socket correspondiente.</li> <li>Por cada mensaje de saludo recibido por el servidor, \u00e9ste lo muestra por pantalla y env\u00eda al cliente un mensaje de confirmaci\u00f3n de que ha recibido el mensaje de saludo.</li> <li>El cliente, una vez enviado el mensaje de saludo, se pone a leer el mensaje de confirmaci\u00f3n de recepci\u00f3n del mensaje que deber\u00e1 mandar el servidor. Cuando lo reciba, lo mostrar\u00e1 por pantalla.</li> <li>Finalmente el cliente cerrar\u00e1 la comunicaci\u00f3n, dado que tan s\u00f3lo quer\u00eda saludar.</li> </ul> <p>Veamos en primer lugar el c\u00f3digo del hilo principal, representado por la clase <code>Main</code>:</p> <pre><code>public class Main {\n\n    private static final int SERVER_PORT = 60000;\n    private static final int NUMBER_OF_CLIENTS = 10;\n\n    public static void main(String[] args) {\n        String serverAddress = \"localhost\";\n        Thread server = new Thread(new Server(SERVER_PORT));\n        server.start();\n        Thread[] clients = new Thread[NUMBER_OF_CLIENTS];\n        for (int i = 0; i &lt; NUMBER_OF_CLIENTS; i++) {\n            clients[i] = new Thread(new Client(i + 1, serverAddress, SERVER_PORT));\n            clients[i].start();\n        }\n\n    }\n\n}\n</code></pre> <p>La clase <code>Server</code> representa el comportamiento del servidor. Cada conexi\u00f3n ser\u00e1 identificada por un n\u00famero entero, que se va incrementando cada vez que se establece una conexi\u00f3n con un cliente.</p> <p>Usamos la estructura try-with-resources, para que el serverSocket sea cerrado autom\u00e1ticamente incluso si se produce una excepci\u00f3n.</p> <p>La llamada al m\u00e9todo <code>accept()</code> es bloqueante, por lo que el hilo servidor queda a la espera de que alg\u00fan hilo cliente establezca un socket para su direcci\u00f3n IP y el puerto correspondiente. Una vez establecida la conexi\u00f3n, con objeto de que el servidor pueda aceptar m\u00e1s clientes inmediatamente, se crea un nuevo hilo de gesti\u00f3n de la conexi\u00f3n y se le pasa el objeto <code>Socket</code> retornado por <code>accept()</code>, que representa la conexi\u00f3n establecida. Tambi\u00e9n se le pasa el n\u00famero de conexi\u00f3n que la identifica.</p> <pre><code>public class Server implements Runnable {\n\n    private final int port;\n    private int connections = 0;\n\n    public Server(int port) {\n        this.port = port;\n    }\n\n    @Override\n    public void run() {\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            while(!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                new Thread(new ServerConnection(++connections, socket)).start();\n            }\n        } catch (IOException e) {\n            System.out.println(\"Server: Input / Output error in server socket\");\n        }\n    }\n\n}\n</code></pre> <p>Veamos ahora la clase <code>Client</code>, que representa el cliente que se quiere conectar al servidor. Su constructor recibe el n\u00famero de cliente que servir\u00e1 para identificarlo, la direcci\u00f3n IP y el puerto del servidor con el que se debe conectar.</p> <p>Para simular el tiempo que tarda el cliente en escribir el mensaje o el tiempo que tarde en cerrar la conexi\u00f3n, usaremos un valor aleatorio de 1 a 10 segundos.</p> <pre><code>public class Client implements Runnable {\n\n    private final int clientNumber;\n    private final String serverAddress;\n    private final int serverPort;\n\n    public Client(int clientNumber, String serverAddress, int serverPort) {\n        this.clientNumber = clientNumber;\n        this.serverAddress = serverAddress;\n        this.serverPort = serverPort;\n    }\n\n    @Override\n    public void run() {\n        try (Socket socket = new Socket(serverAddress, serverPort);\n            ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());\n            ObjectInputStream input = new ObjectInputStream(socket.getInputStream())\n        ) {\n            sendMessage(output);\n            receiveMessage(input);\n            closeConnection();\n        } catch (IOException e) {\n            showConnectionError();\n        } catch (ClassNotFoundException e) {\n            showMessageFormatError();\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    private void sendMessage(ObjectOutputStream output) \n            throws InterruptedException, IOException {\n        Thread.sleep(ThreadLocalRandom.current().nextInt(1, 10) * 1000);\n        output.writeObject(new Message(\"Client #\" + clientNumber, \"Hello from client \" + \n                                    clientNumber));\n    }\n\n    private void receiveMessage(ObjectInputStream input) \n            throws IOException, ClassNotFoundException {\n        Message message = (Message) input.readObject();\n        System.out.printf(\"Client #%d - Message from %s: %s\\n\", clientNumber, \n                        message.getAuthor(), message.getContent());\n    }\n\n    private void closeConnection() throws InterruptedException {\n        Thread.sleep(ThreadLocalRandom.current().nextInt(1, 10) * 1000);\n    }\n\n    private void showConnectionError() {\n        System.out.printf(\"Client #%d: Can't connect with server in %s:%d\\n\", \n                        clientNumber, serverAddress, serverPort);\n    }\n\n    private void showMessageFormatError() {\n        System.out.printf(\"Client #%d: Incorrect message format\\n\", clientNumber);\n    }\n}\n</code></pre> <p>La clase <code>Message</code> es una clase POJO, que debe implementar Serializable, dado que vamos a usarla con <code>ObjectOutputStream</code> y <code>ObjectInputStream</code>, y que contiene informaci\u00f3n sobre el autor del mensaje y sobre su contenido:</p> <pre><code>public class Message implements Serializable {\n\n    private final String author;\n    private final String content;\n\n    public Message(String author, String content) {\n        this.author = author;\n        this.content = content;\n    }\n\n    public String getAuthor() {\n        return author;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n}\n</code></pre> <p>Finalmente, la clase <code>ServerConnection</code> representa la conexi\u00f3n establecida entre un cliente y un servidor, desde el punto de vista del servidor.</p> <pre><code>class ServerConnection implements Runnable {\n\n    private final int connectionNumber;\n    private final Socket socket;\n\n    ServerConnection(int connectionNumber, Socket socket) {\n        this.connectionNumber = connectionNumber;\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try (ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());\n            ObjectInputStream input = new ObjectInputStream(socket.getInputStream())\n        ) {\n            Message receivedMessage;\n            while ((receivedMessage = receiveMessage(input)) != null){\n                sendConfirmationMessage(output, receivedMessage);\n            }\n        } catch (IOException e) {\n            showConnectionClosed();\n        } catch (ClassNotFoundException e) {\n            showMessageFormatError();\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    private Message receiveMessage(ObjectInputStream input) \n            throws IOException, ClassNotFoundException {\n        Message message = (Message) input.readObject();\n        if (message != null) {\n            System.out.printf(\"Server - Message from %s: %s\\n\", message.getAuthor(), \n                            message.getContent());\n        }\n        return message;\n    }\n\n    private void sendConfirmationMessage(ObjectOutputStream output, Message message) \n            throws IOException, InterruptedException {\n        Thread.sleep(ThreadLocalRandom.current().nextInt(1, 10) * 1000);\n        output.writeObject(new Message(\"Server\", \"Received message from \" + \n                                    message.getAuthor() + \": \" + \n                                    message.getContent()));\n    }\n\n    private void showConnectionClosed() {\n        System.out.printf(\"Server: connection #%d closed\\n\", connectionNumber);\n    }\n\n    private void showMessageFormatError() {\n        System.out.printf(\"Server: Incorrect message format in connection #%d\\n\", \n                        connectionNumber);\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_29/page-6/","title":"6 Sockets no orientados a conexi\u00f3n","text":""},{"location":"bloque_v/tema_29/page-6/#sockets-no-orientados-a-conexion","title":"Sockets no orientados a conexi\u00f3n","text":"<p>Los sockets no orientados a conexi\u00f3n o datagram sockets utilizan el protocolo UDP para la comunicaci\u00f3n. Este protocolo no garantiza la entrega de los mensajes ni el orden en el que se reciben.</p> <p>Los mensajes, conocidos como datagramas (datagrams), se env\u00edan de un proceso emisor a otro receptor sin establecer una conexi\u00f3n previa, y sin existir un protocolo de reenv\u00edo basado en acuses de recibo. Cada vez que el emisor env\u00eda un mensaje es necesario que indique expl\u00edcitamente la direcci\u00f3n IP y el puerto del destinatario del paquete.</p> <p> Figura 6 - Datagram <p>Adem\u00e1s, con el mensaje, el receptor recibe tambi\u00e9n la IP y el puerto del conector del emisor desde el que se ha enviado. El receptor podr\u00e1 extraer esta informaci\u00f3n y usarla para enviar una respuesta al emisor.</p> <p>El puerto desde que el emisor env\u00eda sus datagramas no tiene por qu\u00e9 coincidir con el puerto en el que debe recibirlos el receptor.</p> <p>Este tipo de sockets es usado cuando nos importa mucho m\u00e1s la rapidez del env\u00edo que la garant\u00eda de entrega, como en el caso de de transmisi\u00f3n de audio y v\u00eddeo en tiempo real, donde no es posible el reenv\u00edo de paquetes retrasados, o en el caso del servicio de DNS (Domain Name Server).</p> <p>Veamos una comparaci\u00f3n entre el protocolo UDP y el protocolo TCP:</p> Protocolo UDP Protocolo TCP Descripci\u00f3n Envoltura simple y r\u00e1pida, que sirve b\u00e1sicamente de interfaz de las aplicaciones con respecto a la capa de red y no hace pr\u00e1cticamente nada m\u00e1s. Protocolo de funcionalidad completa que permite a las aplicaciones enviar datos de forma confiable sin tener que preocuparse por los problemas en la capa de red. Conexi\u00f3n Sin conexi\u00f3n. Los datos son enviados sin configuraci\u00f3n previa. Orientado a conexi\u00f3n. La conexi\u00f3n debe ser establecida antes de poder realizar una transmisi\u00f3n. Interfaz de datos para la aplicaci\u00f3n Basada en mensajes. Los datos son enviados en paquetes espec\u00edficos indicados por la aplicaci\u00f3n. Basado en un flujo de conexi\u00f3n. Los datos son enviados por la aplicaci\u00f3n sin una estructura particular. Confiabilidad y acuse de recibo No confiable. Intenta realizar el env\u00edo lo mejor posible, pero sin usar acuse de recibo. Env\u00edo confiable de mensajes. Todos los datos requieren acuse de recibo. Retransmisiones No se realizan retransmisiones. La aplicaci\u00f3n debe detectar la p\u00e9rdida de datos y retransmitir si es necesario. El env\u00edo de todos los datos es gestionado por el protocolo, de manera que los datos que se hayan perdido son retransmitidos autom\u00e1ticamente. Sobrecarga Muy baja. Baja, pero m\u00e1s alta que en el protocolo UDP. Velocidad de transmisi\u00f3n Muy alta. Alta, pero no tan alta como UDP. Cantidad de datos adecuada Peque\u00f1a o moderada (hasta unos pocos cientos de bytes). De peque\u00f1a a muy grande (hasta gigabytes). Tipos de aplicaciones Aplicaciones donde la velocidad en la entrega es m\u00e1s importante que el hecho de que se entreguen todos los datos. Aplicaciones donde la entrega de datos debe ser confiable. <p>Para representar los datagramas, Java nos proporciona la clase <code>DatagramPacket</code>. Internamente un objeto <code>DatagramPacket</code> contendr\u00e1 un <code>byte[]</code>, conocido como buffer, en el que podremos almacenar el mensaje a enviar o el mensaje recibido. Normalmente, emisor y receptor est\u00e1n de acuerdo en el tama\u00f1o m\u00e1ximo de los mensajes, de manera que todos son de la misma longitud.</p> <p>El constructor de esta clase <code>DatagramPacket(bufferBytes, bufferLength, targetInetAddress, targetPort)</code>, recibe los bytes correspondientes al mensaje que se quiere enviar, que ser\u00e1 almacenado en el buffer interno, la longitud del mensaje, la direcci\u00f3n IP del destinatario en forma de objeto <code>InetAddress</code> y el puerto del destinatario al que se debe enviar el datagrama.</p> <p>Construcci\u00f3n de un DatagramPacket</p> <pre><code>InetAddress targetInetAddress = InetAddress.getByName(\"localhost\");\nint targetPort = 60100;\nbyte[] buffer = new byte[1024];\nString message = \"Hello\";\nbuffer = message.getBytes;  \nDatagramPacket datagramPacket = new DatagramPacket(buffer, buffer.length, \n                                                targetInetAddress, targetPort);\n</code></pre> <p>La clase <code>DatagramSocket</code> permite crear un socket o conector en el que recibir datagramas y desde el que poder enviarlos. El constructor de esta clase <code>DatagramSocket(port)</code> recibe el puerto en el que queremos recibirlos y desde el que queremos enviarlos.</p> <pre><code>DatagramSocket datagramSocket = new DatagramSocket(60000);\n</code></pre> <p>Una vez creado el objeto <code>DatagramSocket</code> podemos enviar datagramas a trav\u00e9s de \u00e9l, usando su m\u00e9todo <code>send(datagramPacket)</code>, que recibe el objeto <code>DatagramPacket</code> que queremos enviar.</p> <pre><code>datagramSocket.send(datagramPacket);\n</code></pre> <p>Si lo que queremos es recibir un datagrama a trav\u00e9s del objeto <code>DatagramSocket</code>, entonces podemos llamar a su m\u00e9todo <code>receive(datagramPacket)</code>, que recibe un objeto <code>DatagramPacket</code> en el que \"escribir\" el datagrama recibido. Se trata de una llamada bloqueante, ya que el hilo en el que se ejecuta ser\u00e1 bloqueado hasta recibir el datagrama.</p> <p>Como vemos, el m\u00e9todo <code>receive()</code> no retorna nada, sino que tenemos que proporcionarle un objeto <code>DatagramPacket</code> para que rellene su buffer interno. Por este motivo, previamente deberemos crear un objeto <code>DatagramPacket</code> usando el constructor <code>DatagramPacket(bufferBytes, bufferLength)</code>, al que pasaremos un <code>byte[]</code> correspondiente al buffer que debe rellenar con el mensaje recibido, as\u00ed como la longitud de dicho buffer.</p> <p>Si el mensaje recibido tiene una longitud superior al buffer suministrado al datagramPacket, el mensaje ser\u00e1 simplemente truncado.</p> <pre><code>DatagramSocket datagramSocket = new DatagramSocket(60100);\nbytes[] buffer = new bytes[1024];\nDatagramPacket datagramPacket = new DatagramPacket(buffer, buffer.length);\ndatagramSocket.receive(datagramPacket);\n</code></pre> <p>Un vez recibido el datagrama, podemos usar el m\u00e9todo <code>getData()</code> para obtener su buffer, y el m\u00e9todo getLength() para obtener su longitud. De igual forma, podemos usar el m\u00e9todo <code>getAddress()</code> para obtener la <code>InetAddress</code> desde la que se env\u00edo, y el m\u00e9todo <code>getPort()</code> para obtener el puerto desde el que se hizo.</p> <pre><code>int dataLength = datagramPacket.getLength();\nbyte[] data = datagramPacket.getData();\nString message = new String(data, 0, dataLength).trim();\nInetAddress senderInetAddress = datagramPacket.getAddress();\nint senderPort = datagramPacket.getPort();\n</code></pre> <p>Como ya hemos indicado, el m\u00e9todo <code>receive()</code> es, por defecto, bloqueante de manera que el hilo queda bloqueado hasta que se reciba un datagrama. Si queremos especificar un tiempo m\u00e1ximo de espera (timeout), podemos usar el m\u00e9todo <code>setSoTimeout(timeoutInMilis)</code> antes de llamar a <code>receive()</code>. Si pasado dicho tiempo despu\u00e9s de llamar a <code>receive()</code> no se ha recibido un datagrama, el propio m\u00e9todo <code>receive()</code> lanzar\u00e1 la excepci\u00f3n <code>SocketTimeoutException</code>.</p> <p>Cuando ya no queramos enviar o recibir m\u00e1s datagramas a trav\u00e9s del objeto <code>DatagramSocket</code> deberemos llamar a su m\u00e9todo <code>close()</code>.</p> <p>Si en vez de cadenas de texto queremos enviar datagramas que contengan objetos, entonces tendremos que convertir dichos objetos en <code>byte[]</code> para enviarlos, y posteriormente, una vez recibido el <code>byte[]</code> volver a convertirlo a objeto. As\u00ed, usaremos las clases <code>ObjectOutputStream</code> y <code>ByteArrayOutputStream</code> para convertir un objeto en un <code>byte[]</code>, y las clases <code>ObjectInputStream</code> y <code>ByteArrayInputStream</code> para convertir un <code>byte[]</code> en un objeto. A continuaci\u00f3n se muestran dos m\u00e9todos de utilidad para ello:</p> <pre><code>public final class ByteArrayUtils {\n\n    private ByteArrayUtils() {\n    }\n\n    public static byte[] serialize(Object object) throws IOException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream objectOutputStream = \n            new ObjectOutputStream(byteArrayOutputStream);\n        objectOutputStream.writeObject(object);\n        return byteArrayOutputStream.toByteArray();\n    }\n\n    public static Object deserialize(byte[] byteArray) \n            throws IOException, ClassNotFoundException {\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);\n        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n        return objectInputStream.readObject();\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_29/page-7/","title":"Ejercicios","text":"<p>Realiza un proyecto Java haciendo uso de Sockets con las siguientes condiciones:</p> <ul> <li>El cliente enviar\u00e1 4 mensajes distintos:<ul> <li>Un saludo cuando se conecte.</li> <li>Dir\u00e1 Marco</li> <li>Dir\u00e1 Ping</li> <li>Un mensaje de despedida.</li> </ul> </li> <li>El servidor responder\u00e1 a cada una de ellas de la siguiente forma:<ul> <li>Saludar\u00e1 cuando el cliente le salude.</li> <li>Responder\u00e1 Polo cuando el cliente le diga Marco.</li> <li>Responder\u00e1 Pong cuando el cliente le diga Ping.</li> <li>Se despedir\u00e1 cuando el cliente lo haga.</li> </ul> </li> </ul>"},{"location":"bloque_v/tema_30/page-1/","title":"1 URI","text":""},{"location":"bloque_v/tema_30/page-1/#uri","title":"URI","text":"<p>Una URI (Uniform Resource Identifier, identificador de recurso uniforme) es una cadena de caracteres con una determinada sintaxis que sirve para identificar un recurso. El recurso identificado puede ser un fichero en un servidor, la direcci\u00f3n de una determinada m\u00e1quina en Internet, una direcci\u00f3n de email, un n\u00famero de tel\u00e9fono, etc.</p> <p>Una URI es una cadena que sigue el siguiente formato <code>[scheme:]scheme-specific-part[#fragment]</code>, es decir, que est\u00e1 formada por el nombre de esquema utilizado (scheme), que es opcional, una parte espec\u00edfica, cuya sintaxis depende del esquema del que se trate, y, opcionalmente, un fragmento (fragment) que se hace preceder por el car\u00e1cter <code>#</code>.</p> <p> Figura 1 - URI</p> <p>Los nombres de esquemas (scheme) m\u00e1s habituales son:</p> <ul> <li><code>file</code>: Para identificar un fichero disponible en un disco local.</li> <li><code>ftp</code>: Para identificar un recurso disponible en un servidor FTP.</li> <li><code>http</code>: Para identificar un recurso disponible en un servidor Web accesible a trav\u00e9s del protocolo HTTP.</li> <li><code>mailto</code>: Para identificar una direcci\u00f3n de email.</li> </ul> <p>Aunque no existe una sintaxis gen\u00e9rica que se aplique a la parte espec\u00edfica de todos los esquemas, la mayor\u00eda de los esquemas son jer\u00e1rquicos, por lo que siguen un formato gen\u00e9rico <code>//authority/path?query</code>, con el siguiente significado:</p> <ul> <li>Authority (autoridad): Autoridad responsable de resolver el resto de la URI.</li> <li>Path: Ruta para localizar el recurso dentro de la autoridad. Si el camino es jerarquico, las partes son separadas mediante el car\u00e1cter <code>/</code> y los operadores <code>.</code> (actual) y <code>..</code> (padre) son usados para navegar por la jerarqu\u00eda.</li> <li>Query: Opcional. Datos aportados para consultar el recurso, que se conocen como par\u00e1metros (parameters).</li> </ul> <p>Veamos algunos ejemplos:</p> <ul> <li><code>http://www.informaticasaladillo.es/archivos/ejercicio1.txt</code> : el esquema es <code>http</code>, la autoridad es <code>http://www.informaticasaladillo.es</code>, la ruta es <code>/archivos/ejercicio1.txt</code> y no dispone de consulta.</li> <li><code>urn:isbn:156592870</code> : tiene el esquema <code>urn</code> pero no sigue el formato gen\u00e9rico mencionado.</li> <li><code>ftp://mp3:mp3@ci43198-a.ashvil1.nc.home.com:33/VanHalen-Jump.mp3</code> : el esquema es <code>ftp</code>, la autoridad es <code>mp3:mp3@ci43198-a.ashvil1.nc.home.com:33</code>, que incluye el nombre de usuario <code>mp3</code>, la contrase\u00f1a <code>mp3</code>, el host <code>ci43198-a.ashvil1.nc.home.com</code> y el puerto <code>33</code>, y el camino es <code>/VanHalen-Jump.mp3</code>.</li> </ul> <p>Debemos tener en cuenta que hay algunos caracteres que no podremos usar dentro de las URI porque ya tienen un significado especial, por lo que deberemos sustituirlos por su representaci\u00f3n usando el c\u00e1racter <code>%</code> seguido del valor hexadecimal del car\u00e1cter en cuesti\u00f3n:</p> Car\u00e1cter original Car\u00e1cter codificado Car\u00e1cter original Car\u00e1cter codificado <code>/</code> <code>%2F</code> <code>?</code> <code>%3F</code> <code>:</code> <code>%3A</code> <code>@</code> <code>%40</code> <code>=</code> <code>%3D</code> <code>&amp;</code> <code>%26</code> <code>\"</code> <code>%22</code> <code>\\</code> <code>%5C</code> <code>'</code> <code>%60</code> <code>~</code> <code>%7E</code> ``(espacio en blanco) <code>%20</code> <code>#</code> <code>%23</code> <p>Por otra parte, aunque desde hace tiempo ya es posible incluir en las URL caracteres de otros idiomas que no sean el ingl\u00e9s, a\u00fan no es completamente seguro utilizar estos caracteres en las URL. Si se utilizan letras como <code>\u00f1</code>, <code>\u00e1</code>, <code>\u00e9</code> o <code>\u00e7</code>, es posible que algunos navegadores no las interpreten de forma correcta.</p> <p>La soluci\u00f3n consiste en codificar todos los caracteres que no existen en ingl\u00e9s. La siguiente tabla muestra la codificaci\u00f3n de los caracteres m\u00e1s utilizados:</p> Car\u00e1cter original Car\u00e1cter codificado Car\u00e1cter original Car\u00e1cter codificado <code>\u00f1</code> <code>%F1</code> <code>\u00d1</code> <code>%D1</code> <code>\u00e1</code> <code>%E1</code> <code>\u00c1</code> <code>%C1</code> <code>\u00e9</code> <code>%E9</code> <code>\u00c9</code> <code>%C9</code> <code>\u00ed</code> <code>%ED</code> <code>\u00cd</code> <code>%CD</code> <code>\u00f3</code> <code>%F3</code> <code>\u00d3</code> <code>%D3</code> <code>\u00fa</code> <code>%FA</code> <code>\u00da</code> <code>%DA</code> <code>\u00e7</code> <code>%E7</code> <code>\u00c7</code> <code>%C7</code> <p>El est\u00e1ndar RFC 2396 especifica qu\u00e9 caracteres est\u00e1n permitidos en las distintas partes de una URI</p> <p>M\u00e1s adelante veremos que Java proporciona las clases de utilidad URLEncoder y URLDecoder para asistirnos, respectivamente, en la tarea de codificar o descodificar una cadena correspondiente a una Uri.</p> <p>La clase Java <code>URI</code> representa una URI, proporcionando distintos constructores sobrecargados para crear un objeto <code>URI</code> proporcionando sus partes: <code>URI(string)</code>, <code>URI(scheme, schemeSpecificPart, fragment)</code>, <code>URI(scheme, host, path, fragment)</code>.</p> <p>La clase <code>URI</code> proporciona una serie de m\u00e9todos informativos para obtener las distintas partes de la URI, como por ejemplo <code>getSchemed()</code>, <code>getAuthority()</code>, <code>getPath()</code>, <code>getPort()</code>, <code>getQuery()</code>, etc.</p> <p>Si queremos obtener la representaci\u00f3n en cadena de un objeto <code>URI</code> podemos usar su m\u00e9todo <code>toString()</code>.</p>"},{"location":"bloque_v/tema_30/page-10/","title":"10 Retrofit","text":""},{"location":"bloque_v/tema_30/page-10/#retrofit","title":"Retrofit","text":"<p>Retrofit es una librer\u00eda desarrollada por la empresa Square para crear clientes REST, proporcion\u00e1ndonos un poderoso framework para interactuar con este tipo de web APIs, haciendo uso interno de la librer\u00eda OkHttp para la gesti\u00f3n de peticiones HTTP. Gracias a ella, se hace m\u00e1s sencillo el proceso de descarga de datos en formato JSON o XML, que posteriormente ser\u00e1n procesados para obtener los objetos POJO (Plain Old Java Object) contenidos en la respuesta. Lo m\u00e1s habitual es que el proceso de procesamiento de la respuesta se lleva a cabo a trav\u00e9s de alguna de las librer\u00edas para el procesamiento del formato JSON, como Gson, Jackson o Moshi.</p> <p>La principal ventaja de Retrofit es que permite al desarrollador especificar de forma declarativa los tipos de peticiones (endpoints) a trav\u00e9s de una interfaz que contiene un m\u00e9todo por tipo de petici\u00f3n, de manera que la declaraci\u00f3n del m\u00e9todo incluir\u00e1 una serie de anotaciones espec\u00edficas de Retrofit, que permiten a la librer\u00eda determinar la petici\u00f3n real que debe llevarse a cabo. Por ejemplo:</p> <pre><code>// Interfaz de comunicaci\u00f3n con la API (en este caso GitHub).\npublic interface GitHubService {\n    // Petici\u00f3n GET a dicho path, que incluye el usuario recibido.\n    // Retorna una lista de objeto Repo.\n    @GET(\"/users/{user}/repos\")\n    Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);\n}\n</code></pre> <p>Para poder utilizar Retrofit ser\u00e1 necesario incluir en el archivo <code>build.gradle</code> las siguientes dependencias (Gson s\u00f3lo la incluiremos si va a ser usada o en lel fichero <code>pom.xml</code>):</p> GradleMaven <pre><code>dependencies {\n    // ...\n    implementation 'com.squareup.retrofit2:retrofit:2.X.X'\n    implementation 'com.google.code.gson:gson:2.X.X'\n    implementation 'com.squareup.retrofit2:converter-gson:2.X.X'\n}\n</code></pre> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt;\n        &lt;artifactId&gt;retrofit&lt;/artifactId&gt;\n        &lt;version&gt;2.X.X&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;\n        &lt;artifactId&gt;gson&lt;/artifactId&gt;\n        &lt;version&gt;2.X.X&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt;\n        &lt;artifactId&gt;converter-gson&lt;/artifactId&gt;\n        &lt;version&gt;2.X.X&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>El c\u00f3digo de nuestro proyecto deber\u00e1 incorporar los siguientes elementos:</p> <ul> <li>Una clase POJO (modelo) por cada objeto de datos incluido en cualquiera de las respuestas (en el ejemplo anterior, al menos la clase <code>Repo</code>). Para poder obtener directamente las clases a partir de la cadena JSON correspondiente podemos usar las web http://www.jsonschema2pojo.org/. Si queremos que el lenguaje de destino sea Kotlin, podemos usar la web https://www.json2kotlin.com/ o el plugin de IntelliJ https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass-/.</li> <li>Una interfaz que incluya la declaraci\u00f3n de los m\u00e9todos correspondientes a los distintos tipos de peticiones (endpoints), con las anotaciones Retrofit adecuadas.</li> <li>Un objeto de la clase <code>Retrofit</code> para la obtenci\u00f3n de un cliente REST de acceso a la API. Para obtener el objeto <code>Retrofit</code> usaremos un objeto constructor de la clase <code>Retrofit.Builder</code>, en el que configuraremos distintos aspectos de acceso a la API, como la url base para las peticiones (a trav\u00e9s del m\u00e9todo <code>baseUrl()</code>, se recomienda que la url indicada siempre termine en <code>/</code>), o el conversor a utilizar para la respuesta (a trav\u00e9s del m\u00e9todo <code>addConverterFactory()</code>), para finalmente llamar a su m\u00e9todo <code>build()</code>, que nos retornar\u00e1 el objeto <code>Retrofit</code> ya configurado.</li> <li>Un objeto creado a trav\u00e9s del objeto <code>Retrofit</code>, que implementa la interfaz definida anteriormente, y que act\u00faa como cliente REST, permiti\u00e9ndonos llevar a cabo las peticiones a la API a trav\u00e9s de los m\u00e9todos de la interfaz.</li> </ul> <p>En el siguiente ejemplo vemos c\u00f3mo crear el objeto <code>Retrofit</code> a trav\u00e9s del configuraci\u00f3n y la posterior obtenci\u00f3n del cliente REST con el que realizar las peticiones:</p> <pre><code>// Creamos el objeto Retrofit, indicando que la url base y que se\n// use como conversor de la respuesta la librer\u00eda Gson.\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"https://api.github.com/\")\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n// Se crea el cliente REST de acceso a la API a partir del\n// objeto Retrofit. \nservice = retrofit.create(GitHubService.class);\n</code></pre> <p>Una vez obtenido el cliente REST, podemos realizar las peticiones a trav\u00e9s de sus m\u00e9todos, que corresponden a los de la interfaz. Por ejemplo:</p> <pre><code>// Petici\u00f3n de los repos del usuario pedrojoya.\n// La respuesta ser\u00e1 procesada para obtener\n// una lista de objetos Repo.\nCall&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"pedrojoya\");\n</code></pre>"},{"location":"bloque_v/tema_30/page-10/#anotaciones-para-la-declaracion-de-tipos-de-peticiones","title":"Anotaciones para la declaraci\u00f3n de tipos de peticiones","text":"<p>A continuaci\u00f3n se muestran ejemplos de declaraci\u00f3n de peticiones en las que se usan distintas anotaciones. Se usan comentarios para explicar su funcionamiento:</p> <pre><code>// Petici\u00f3n GET indicando expl\u00edcitamente la URL.\n@GET\nCall&lt;User&gt; getUserByUrl(@Url String url);\n\n// Petici\u00f3n GET simple.\n@GET(\"users/list\")\nCall&lt;List&lt;User&gt;&gt; listUsers();\n\n// Petici\u00f3n GET con par\u00e1metros en la URL.\n@GET(\"users/list?sort=desc\")\nCall&lt;List&lt;User&gt;&gt; listUsersDescOrder();\n\n// Petici\u00f3n GET. La URL incluye el valor del par\u00e1metro groupId.\n// Se a\u00f1ade un par\u00e1metro a la URL cuyo nombre ser\u00e1 sort y\n// cuyo valor ser\u00e1 el del par\u00e1metro sort del m\u00e9todo.\n@GET(\"group/{id}/users\")\nCall&lt;List&lt;User&gt;&gt; groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort);\n\n// Petici\u00f3n GET. La URL incluye el valor del par\u00e1metro groupId.\n// Se a\u00f1aden como par\u00e1metros de la URL los elementos del mapa (pares clave-valor)\n// correspondiente al valor del par\u00e1metro options del m\u00e9todo.\n@GET(\"group/{id}/users\")\nCall&lt;List&lt;User&gt;&gt; groupList(@Path(\"id\") int groupId, @QueryMap Map&lt;String, String&gt; options);\n\n// Petici\u00f3n POST. Se a\u00f1ade al cuerpo de la petici\u00f3n la representaci\u00f3n JSON \n// del objeto usuario correspondiente al valor del par\u00e1metro user del m\u00e9todo.\n@POST(\"users/new\")\nCall&lt;User&gt; createUser(@Body User user);\n\n// Petici\u00f3n POST. Se a\u00f1aden como campos de la URL con los nombres\n// first_name y last_name los valores de los par\u00e1metros first y last del m\u00e9todo\n// respectivamente.\n@FormUrlEncoded\n@POST(\"user/edit\")\nCall&lt;User&gt; updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last);\n\n// Petici\u00f3n GET. Se a\u00f1ade a la cabecera de la petici\u00f3n\n// la l\u00ednea de cabecera especificada.\n@Headers(\"Cache-Control: max-age=640000\")\n@GET(\"widget/list\")\nCall&lt;List&lt;Widget&gt;&gt; widgetList();\n\n// Petici\u00f3n GET. Se a\u00f1aden a la cabecera de la petici\u00f3n\n// las l\u00edneas de cabecera especificadas en formado JSON.\n// La URL contendr\u00e1 el valor del par\u00e1metro username del m\u00e9todo.\n@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit-Sample-App\"\n})\n@GET(\"users/{username}\")\nCall&lt;User&gt; getUser(@Path(\"username\") String username);\n\n// Petici\u00f3n GET. Se a\u00f1ade a la cabecera de la petici\u00f3n\n// una l\u00ednea de cabecera con la clave Authorization y cuyo valor\n// corresponder\u00e1 al valor del par\u00e1metro authorization del m\u00e9todo. \n@GET(\"user\")\nCall&lt;User&gt; getUser(@Header(\"Authorization\") String authorization);\n</code></pre>"},{"location":"bloque_v/tema_30/page-10/#peticiones-sincronas-y-asincronas","title":"Peticiones s\u00edncronas y as\u00edncronas","text":"<p>A la hora de realizar una petici\u00f3n podemos indicar que se realice s\u00edncronamente o as\u00edncronamente:</p> <p>Cuando realizamos una petici\u00f3n s\u00edncrona la aplicaci\u00f3n se queda a la espera de la respuesta. Emplearemos el m\u00e9todo <code>execute()</code> del objeto <code>Call</code>. Debemos tener en cuenta que en Android NO se puede llamar a este m\u00e9todo desde el hilo de la interfaz de usuario porque producir\u00eda la excepci\u00f3n <code>NetworkOnMainThreadException</code>, por lo que deberemos llamarlo desde un hilo secundario. Por ejemplo:</p> <pre><code>Call&lt;Repo&gt; call = service.loadRepo(\"studio\");\n// Llamada s\u00edncrona. No hacerla en el hilo de la IU.\nResponse&lt;Repo&gt; response = call.execute();\n// Se obtiene el objeto Repo desde response.body()\nif (response.body() != null &amp;&amp; response.isSuccessful()) {\n    Repo repo = response.body();\n    // ...\n}\n</code></pre> <p>Cuando realizamos una petici\u00f3n as\u00edncrona la aplicaci\u00f3n sigue ejecut\u00e1ndose, ya que se realiza autom\u00e1ticamente en un hilo secundario. Emplearemos el m\u00e9todo <code>enqueue()</code>, al que le pasamos un objeto listener, de la clase <code>Callback&lt;ClaseResultado&gt;</code>, que ser\u00e1 notificado cuando se haya obtenido y procesado la respuesta, a trav\u00e9s de su m\u00e9todo <code>onResponse()</code>, o de su m\u00e9todo <code>onFailure()</code> si se ha producido un error. El m\u00e9todo <code>onResponse()</code> recibir\u00e1 como par\u00e1metro un objeto <code>Response&lt;ClaseResultado&gt;</code> correspondiente a la respuesta obtenida. Para obtener el objeto resultado a partir de la respuesta, usaremos su m\u00e9todo <code>body()</code>. Debemos tener en cuenta que el metodo <code>onResponse()</code> ser\u00e1 ejecutado incluso aunque haya habido alg\u00fan problema con la respuesta, en cuyo caso el m\u00e9todo <code>body()</code> de la respuesta retornar\u00e1 <code>null</code> (deberemos controlar esta situaci\u00f3n). Por ejemplo:</p> <pre><code>Call&lt;Repo&gt; call = service.loadRepo(\"studio\");\n// Llamada as\u00edncrona (se encola, cuando est\u00e9 disponible se ejecutar\u00e1 el listener).\ncall.enqueue(new Callback&lt;Repo&gt;() {\n    @Override\n    public void onResponse(Call&lt;Repo&gt; call, Response&lt;Repo&gt; response) {\n        // Se obtiene el objeto Repo desde response.body()\n        if (response.body() != null &amp;&amp; response.isSuccessful()) {\n            Repo repo = response.body();\n            ...\n        }\n    }\n\n    @Override\n    public void onFailure(Call&lt;Repo&gt; call, Throwable t) {\n        // Se ha producido un error que ha imposibilitado realizar la petici\u00f3n,\n        // por ejemplo que no hay conexi\u00f3n a Internet.\n        ...\n    }\n});\n</code></pre>"},{"location":"bloque_v/tema_30/page-10/#interceptores-de-peticiones","title":"Interceptores de peticiones","text":"<p>En algunas APIs es necesario indicar unas determinadas cabeceras en todas las peticiones que le hagamos. Si este es el caso, en vez de tener que especificar dichas cabeceras en todas las declaraciones de tipos de peticiones, podemos crear nuestro propio objeto de conexi\u00f3n HTTP en el que definamos un interceptor de peticiones.</p> <p>Retrofit usa internamente <code>OkHttp</code> como librer\u00eda de comunicaci\u00f3n HTTP. No es necesario definir ninguna dependencia al respecto en el archivo <code>build.gradle</code> porque Retrofit ya lo hace internamente, pero nosotros podemos agregar la dependencia expl\u00edcitamente en el archivo <code>build.gradle</code> o en el <code>pom.xml</code>:</p> GRADLEMAVEN <pre><code>dependencies {\n    // ...\n    implementation 'com.squareup.okhttp3:okhttp:X.X.X'\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;\n    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;\n    &lt;version&gt;X.X.X&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Si no especificamos nada al respecto en el objeto <code>Retrofit.Builder</code>, Retrofit usar\u00e1 un objeto est\u00e1ndar de <code>OkHttp</code>. Sin embargo, nosotros podemos crear nuestro propio objeto <code>OkHttp</code>, configurarlo a nuestro gusto e indicarle a <code>Retrofit.Builder</code>, mediante el m\u00e9todo <code>client()</code>, que lo use como cliente que conexi\u00f3n HTTP a la hora de crear nuestro servicio.</p> <p>Uno de los elementos que podemos personalizar en nuestro objeto <code>OkHttp</code> es la adici\u00f3n de un determinado interceptor de peticiones, cuya misi\u00f3n en este caso ser\u00e1 interceptar cualquier petici\u00f3n o respuesta que se realice a trav\u00e9s del cliente <code>OkHttp</code>, para reconfigurarla. En el siguiente ejemplo se a\u00f1ade un interceptor al cliente <code>OkHttp</code> para a\u00f1adir a todas las peticiones que se realicen a trav\u00e9s de \u00e9l una cabecera indicando el <code>User-Agent</code> y un par\u00e1metro en la query correspondiente a la api key:</p> <pre><code>// Se crea el builder para el cliente OkHttp.\nOkHttpClient.Builder builder = new OkHttpClient.Builder();\n// Se le a\u00f1ade un interceptador al builder.\nbuilder.addInterceptor(new Interceptor() {\n    @Override\n    public Response intercept(Interceptor.Chain chain) throws IOException {\n        // Se obtiene la petici\u00f3n original.\n        Request request = chain.request();\n        // Se obtiene una nueva URL basada en la original de la petici\u00f3n\n        // agregando el par\u00e1metro de consulta correspondiente a la api key.\n        HttpUrl newUrl = request.url().newBuilder().addQueryParameter(\n                PARAM_API_KEY, apiKey).build();\n        // Se crea una nueva petici\u00f3n bas\u00e1ndose en la original.\n        // Se cambia la url por la nueva modificada y se agrega una cabecera.\n        Request newRequest;\n        newRequest = request.newBuilder()\n                .url(newUrl)\n                .addHeader(\"User-Agent\", \n                        \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\")\n                .build();\n        // Se reemplaza la nueva petici\u00f3n por la antigua y se contin\u00faa.\n        return chain.proceed(newRequest);\n    }\n});\n// Se construye el cliente OkHttpClient a partir del builder.\nOkHttpClient client = builder.build();\n</code></pre> <p>Otro interceptor que suele agregarse habitualmente es uno que nos permite mostrar un log de todas las peticiones realizadas a trav\u00e9s de <code>Retrofit</code>, as\u00ed como el contenido de las respuestas. Para ello deberemos agregar la dependencia correspondiente al archivo <code>build.gradle</code> o <code>pom.xml</code>:</p> GRADLEMAVEN <pre><code>dependencies {\n    // ...\n    implementation 'com.squareup.okhttp3:logging-interceptor:X.X.X'\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;\n    &lt;artifactId&gt;logging-interceptor&lt;/artifactId&gt;\n    &lt;version&gt;X.X.X&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Al igual que en el caso de interceptor explicado con anterioridad, tendremos que crear un objeto interceptor <code>HttpLoggingInterceptor</code>, configurar el nivel de log mediante su m\u00e9todo <code>setLevel(HttpLoggingInterceptor.Level.BODY)</code> y a\u00f1adirlo al cliente OkHttp. Existen niveles que muestran menos informaci\u00f3n, como por ejemplo <code>HttpLoggingInterceptor.Level.BASIC</code>.</p> <p>As\u00ed, el proceso de construcci\u00f3n completo ser\u00eda:</p> <p>Construcci\u00f3n de un objeto Retrofit y cliente REST con logging</p> <pre><code>// Se crea el interceptor\nHttpLoggingInterceptor logInterceptor = new HttpLoggingInterceptor();\nlogInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n// Se crea el cliente OkHttp\nOkHttpClient client = new OkHttpClient.Builder()\n    .addInterceptor(logInterceptor)\n    .build();\n// Se crea el objeto Retrofit\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"https://api.github.com/\")\n        .addConverterFactory(GsonConverterFactory.create())\n        .client(client)\n        .build();\n// Se crea el cliente REST de acceso a la API a partir del\n// objeto Retrofit. \nGitHubService apiService = retrofit.create(GitHubService.class);\n</code></pre>"},{"location":"bloque_v/tema_30/page-10/#procesador-de-respuestas","title":"Procesador de respuestas","text":"<p>Otro de los elementos que deberemos indicar a la hora de construir el objeto <code>Retrofit</code> es qu\u00e9 procesador (converter) debe utilizarse para procesar la respuesta, para lo que empleamos el m\u00e9todo <code>addConverterFactory()</code>.</p> <p>Aunque es posible crear nuestra propia clase procesadora que implemente la interfaz <code>Converter.Factory</code>, lo m\u00e1s habitual ser\u00e1 usar alguno de los procesadores soportados oficialmente por Retrofit, correspondientes a conocidas librer\u00edas de procesamiento JSON o XML, en cuyo caso deberemos a\u00f1adir la dependencia correspondiente a nuestro proyecto.</p> <p>Conversores de JSON:</p> <ul> <li>Gson: <code>implementation \"com.squareup.retrofit2:converter-gson:X.X.X\"</code></li> <li>Jackson: <code>implementation 'com.squareup.retrofit2:converter-jackson:X.X.X'</code></li> <li>Moshi: <code>implementation 'com.squareup.retrofit2:converter-moshi:X.X.X'</code></li> </ul> <p>Conversores de XML:</p> <ul> <li>Simple XML: <code>implementation 'com.squareup.retrofit2:converter-simplexml:X.X.X'</code></li> </ul> <p>Conversores primitivos:</p> <ul> <li>Scalars (tipos primitivos, clases de tipos primitivos y String): <code>implementation 'com.squareup.retrofit2:converter-scalars:X.X.X'</code>.</li> </ul> <p>Por ejemplo, si queremos que Retrofit use Gson para procesar las respuestas, deberemos a\u00f1adir las siguientes dependencia en el archivo <code>build.gradle</code>:</p> <pre><code>dependencies {\n    // ...\n    implementation 'com.squareup.retrofit2:retrofit:X.X.X'\n    implementation 'com.google.code.gson:gson:Y.Y.Y'\n    implementation 'com.squareup.retrofit2:converter-gson:X.X.X'\n}\n</code></pre> <p>y a la hora de crear el objeto <code>Retrofit</code> tendremos que indicar que se use dicho procesador:</p> <p>Configuraci\u00f3n de Retrofit para uso de Gson</p> <pre><code>// Creamos el objeto Retrofit, indicando que se\n// use como conversor de la respuesta la librer\u00eda Gson.\nRetrofit retrofit = new Retrofit.Builder()\n        // ...\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n</code></pre>"},{"location":"bloque_v/tema_30/page-10/#proyecto-retrofit","title":"Proyecto Retrofit","text":"<p>En este proyecto vamos a realizar una aplicaci\u00f3n que realiza distintos tipos de peticiones HTTP a un servicio REST de ejemplo, usando la librer\u00eda Retrofit. La respuesta es pareada y mostradas por consola.</p> <p>Definimos de la interfaz <code>ApiService</code>, en la que informamos a Retrofit de c\u00f3mo queremos atacar la Web API REST. Nuestro main construye el objeto <code>ApiService</code>. Para ello antes construye un objeto <code>Retrofit</code> con la configuraci\u00f3n adecuada, que incluye un objeto <code>OkHttpClient</code> personalizado para que muestre un log en consola con las peticiones y las respuestas obtenidas. En el main tambi\u00e9n realizamos las distintas peticiones.</p> MainApiServicePostResponse <pre><code>import es.iessaladillo.pedrojoya.retrofit.data.api.ApiService;\nimport es.iessaladillo.pedrojoya.retrofit.data.api.response.PostResponse;\nimport okhttp3.OkHttpClient;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport org.jetbrains.annotations.NotNull;\nimport retrofit2.Call;\nimport retrofit2.Callback;\nimport retrofit2.Response;\nimport retrofit2.Retrofit;\nimport retrofit2.converter.gson.GsonConverterFactory;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n    private final ApiService apiService = createApiService();\n    private final Scanner scanner = new Scanner(System.in);\n\n    Main() {\n        int selectedOption = showMenu();\n        processOption(selectedOption);\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n\n    private int showMenu() {\n        System.out.println(\"\\nMENU\");\n        System.out.println(\"1. Show all posts synchronously\");\n        System.out.println(\"2. Show all posts with callback\");\n        System.out.println(\"3. Show all posts\");\n        System.out.println(\"4. Show post\");\n        System.out.println(\"5. Show user's posts\");\n        System.out.println(\"6. Show posts by user\");\n        System.out.println(\"7. Create post\");\n        System.out.println(\"8. Update post\");\n        System.out.println(\"9. Update post partially\");\n        System.out.println(\"10. Delete post\");\n        System.out.println(\"11. Show only headers\");\n        System.out.println(\"12. Show access options\");\n        System.out.print(\"Select an option: \");\n        try {\n            return scanner.nextInt();\n        } catch (Exception e) {\n            scanner.nextLine();\n            return 0;\n        }\n    }\n\n    private void processOption(int selectedOption) {\n        switch (selectedOption) {\n            case 1:\n                showPostsSync();\n                break;\n            case 2:\n                showPostsWithCallback();\n                break;\n            case 3:\n                showPosts();\n                break;\n            case 4:\n                showPost(1);\n                break;\n            case 5:\n                showUserPosts(1);\n                break;\n            case 6:\n                showPostsByUser(1);\n                break;\n            case 7:\n                createPost(new PostResponse(1, 0, \"Baldomero\", \"Ll\u00e9gate Ligero\"));\n                break;\n            case 8:\n                updatePost(1, new PostResponse(1, 1, \"Baldomero\", \"Ll\u00e9gate Ligero\"));\n                break;\n            case 9:\n                patchPost(1, new PostResponse(3, 1, \"Baldomero\", \"Ll\u00e9gate Ligero\"));\n                break;\n            case 10:\n                deletePost(1);\n                break;\n            case 11:\n                showPostsHeaders();\n                break;\n            case 12:\n                showPostsAccessOptions();\n                break;\n        }\n    }\n\n    private void showPostsSync() {\n        try {\n            Response&lt;List&lt;PostResponse&gt;&gt; response = apiService.getPostsCall().execute();\n            if (response.isSuccessful() &amp;&amp; response.body() != null) {\n                showModel(response.body());\n            }\n        } catch (IOException e) {\n            showError(e);\n        }\n    }\n\n    private void showPostsWithCallback() {\n        apiService.getPostsCall().enqueue(new Callback&lt;List&lt;PostResponse&gt;&gt;() {\n            @Override\n            public void onResponse(Call&lt;List&lt;PostResponse&gt;&gt; call, Response&lt;List&lt;PostResponse&gt;&gt; response) {\n                if (response.isSuccessful() &amp;&amp; response.body() != null) {\n                    showModel(response.body());\n                }\n            }\n\n            @Override\n            public void onFailure(Call&lt;List&lt;PostResponse&gt;&gt; call, Throwable t) {\n                System.out.println(t.toString());\n            }\n        });\n    }\n\n    private void showPosts() {\n        apiService.getPosts().whenComplete(this::showErrorOrModel);\n    }\n\n    private void showPostsAccessOptions() {\n        apiService.getPostsAccessOptions()\n                .thenApply(response -&gt;\n                        String.join(\";\", response.headers().values(\"access-control-allow-methods\")))\n                .whenComplete(this::showErrorOrModel);\n    }\n\n    private void showPostsHeaders() {\n        apiService.getPostsHeaders()\n                .thenApply(response -&gt; response.headers().toMultimap().entrySet().stream()\n                        .map(entry -&gt; entry.getKey() + \": \" + String.join(\";\", entry.getValue()))\n                        .collect(Collectors.joining(\"\\n\"))\n                )\n                .whenComplete(this::showErrorOrModel);\n    }\n\n    private void showPost(int postId) {\n        apiService.getPost(1).whenComplete(this::showErrorOrModel);\n    }\n\n    private void createPost(PostResponse postResponse) {\n        apiService.createPost(postResponse).whenComplete(this::showErrorOrModel);\n    }\n\n    private void updatePost(int postId, PostResponse postResponse) {\n        apiService.updatePost(postId, postResponse).whenComplete(this::showErrorOrModel);\n    }\n\n    private void patchPost(int postId, PostResponse postResponse) {\n        apiService.patchPost(postId, postResponse).whenComplete(this::showErrorOrModel);\n    }\n\n    private void deletePost(int postId) {\n        apiService.deletePost(postId).whenComplete(this::showErrorOrModel).join();\n    }\n\n    private void showUserPosts(int userId) {\n        apiService.getUserPosts(userId).whenComplete(this::showErrorOrModel).join();\n    }\n\n    private void showPostsByUser(int userId) {\n        apiService.getPostsByUser(userId).whenComplete(this::showErrorOrModel).join();\n    }\n\n    // -------------------------\n\n    @NotNull\n    private ApiService createApiService() {\n        HttpLoggingInterceptor logInterceptor = new HttpLoggingInterceptor();\n        logInterceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);\n        OkHttpClient okHttpClient = new OkHttpClient.Builder().addInterceptor(logInterceptor).build();\n        Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://jsonplaceholder.typicode.com/\")\n                .client(okHttpClient)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build();\n        return retrofit.create(ApiService.class);\n    }\n\n    @NotNull\n    private ApiService createSwapiService() {\n        HttpLoggingInterceptor logInterceptor = new HttpLoggingInterceptor();\n        logInterceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);\n        OkHttpClient okHttpClient = new OkHttpClient.Builder().addInterceptor(logInterceptor).build();\n        Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://swapi.co/api/\")\n                .client(okHttpClient)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build();\n        return retrofit.create(ApiService.class);\n    }\n\n    private &lt;T&gt; void showErrorOrModel(T model, Throwable throwable) {\n        if (throwable != null) {\n            showError(throwable);\n        } else {\n            showModel(model);\n        }\n    }\n\n    private void showError(Throwable e) {\n        System.out.println(e.toString());\n    }\n\n    private &lt;T&gt; void showModel(T model) {\n        System.out.println(model);\n    }\n\n}\n</code></pre> <pre><code>import es.iessaladillo.pedrojoya.retrofit.data.api.response.PostResponse;\nimport retrofit2.Call;\nimport retrofit2.Response;\nimport retrofit2.http.*;\n\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\npublic interface ApiService {\n\n    @GET(\"posts\")\n    Call&lt;List&lt;PostResponse&gt;&gt; getPostsCall();\n\n    @GET(\"posts\")\n    CompletableFuture&lt;List&lt;PostResponse&gt;&gt; getPosts();\n\n    @OPTIONS(\"posts\")\n    CompletableFuture&lt;Response&lt;PostResponse&gt;&gt; getPostsAccessOptions();\n\n    @HEAD(\"posts\")\n    CompletableFuture&lt;Response&lt;Void&gt;&gt; getPostsHeaders();\n\n    @GET(\"posts/{postId}\")\n    public CompletableFuture&lt;PostResponse&gt; getPost(@Path(\"postId\") int postId);\n\n    @POST(\"posts\")\n    CompletableFuture&lt;PostResponse&gt; createPost(@Body PostResponse postResponse);\n\n    @PUT(\"posts/{postId}\")\n    CompletableFuture&lt;PostResponse&gt; updatePost(@Path(\"postId\") int postId, \n                                            @Body PostResponse postResponse);\n\n    @PATCH(\"posts/{postId}\")\n    public CompletableFuture&lt;PostResponse&gt; patchPost(@Path(\"postId\") int postId, \n                                                    @Body PostResponse postResponse);\n\n    @DELETE(\"posts/{postId}\")\n    CompletableFuture&lt;Void&gt; deletePost(@Path(\"postId\") int postId);\n\n    @GET(\"users/{userId}/posts\")\n    CompletableFuture&lt;List&lt;PostResponse&gt;&gt; getUserPosts(@Path(\"userId\") int userId);\n\n    @GET(\"posts\")\n    CompletableFuture&lt;List&lt;PostResponse&gt;&gt; getPostsByUser(@Query(\"userId\") int userId);\n\n}\n</code></pre> <pre><code>import com.google.gson.annotations.Expose;\nimport com.google.gson.annotations.SerializedName;\n\npublic class PostResponse {\n\n    @SerializedName(\"userId\")\n    @Expose\n    private Integer userId;\n    @SerializedName(\"id\")\n    @Expose\n    private Integer id;\n    @SerializedName(\"title\")\n    @Expose\n    private String title;\n    @SerializedName(\"body\")\n    @Expose\n    private String body;\n\n    public PostResponse(Integer userId, Integer id, String title, String body) {\n        this.userId = userId;\n        this.id = id;\n        this.title = title;\n        this.body = body;\n    }\n\n    @Override\n    public String toString() {\n        return \"{\" +\n                \"userId=\" + userId +\n                \", id=\" + id +\n                \", title='\" + title + '\\'' +\n                '}';\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_30/page-11/","title":"Ejercicios","text":"<p>Crea una base de datos tal y como te explican en el siguiente enlace: https://my-json-server.typicode.com/</p> <p>Se desea almacenar informaci\u00f3n sobre libros, queriendo almacenar lo siguientes datos:</p> <ul> <li>ISBN</li> <li>Nombre</li> <li>Autor</li> <li>A\u00f1o de publicaci\u00f3n</li> <li>Rating</li> </ul> <p>Realiza un proyecto de Java que te permita realizar peticiones a dicho servidor y mostrarlo por pantalla. Te debe permitir realizar los operaciones CRUD b\u00e1sicas.</p> <p>Realiza una versi\u00f3n para cada caso:</p> <ul> <li>Usando la librer\u00eda <code>okHttp</code></li> <li>Usando <code>HttpClient</code> de Java 11</li> <li>Usando la librer\u00eda <code>Retrofit</code>.</li> </ul> <p>Las peticiones de deben realizar de forma as\u00edncrona.</p>"},{"location":"bloque_v/tema_30/page-2/","title":"2 URL","text":""},{"location":"bloque_v/tema_30/page-2/#url","title":"URL","text":"<p>Una URL (Uniform Resource Locator) es un tipo de URI que sirve para identificar un recurso en Internet. Sigue el formato jer\u00e1rquico especificado anteriormente, pero a\u00f1ade un par de elementos adicionales:</p> <ul> <li>Port (puerto): Al especificar la autoridad se le puede a\u00f1adir opcionalmente el car\u00e1cter <code>:</code> seguido del n\u00famero de puerto que debe emplearse para conectar con la autoridad.</li> <li>Anchor (ancla): Se puede a\u00f1adir al final de la URL el car\u00e1cter <code>#</code> seguido de un nombre que hayamos asignado a una determinada posici\u00f3n de nuestra p\u00e1gina web, para indicar que el navegador se posicione autom\u00e1ticamente en dicha posici\u00f3n.</li> </ul> <p>Por ejemplo, en la URL <code>http://www.alistapart.com:81/comments/webstandards2008?page=5#42</code>, el esquema/protocolo es <code>http</code>, la autoridad es <code>www.alistapart.com</code>, el puerto es <code>81</code>, la ruta es <code>/comments/webstandards2008</code>, la consulta es <code>?page=5</code> y el ancla es <code>#5</code>.</p> <p> Figura 2 - URL</p> <p>En Java, una URL est\u00e1 representada por la clase <code>URL</code>, cuyo constructor est\u00e1 sobrecargado para que podamos crear nuestro objeto URL a partir de una cadena completa o de las distintas partes de la URL. Si no es posible formar una URL con sintaxis v\u00e1lida a partir de los datos aportados al constructor, \u00e9ste lanza la excepci\u00f3n <code>MalformedURLException</code>, aunque debemos tener en cuenta que no se comprueba que el recurso correspondiente exista realmente en la red. A continuaci\u00f3n se muestran varias formas de crear un objeto URL:</p> <pre><code>URL url = new URL(\"http://docs.oracle.com/javase/7\");\n// Especificando las distintas partes de la URL.\nURL url = new URL(\"http\", \"docs.oracle.com\", \"/javase/7\");\nURL url = new URL(\"http\", \"docs.oracle.com\", 80, \"/javase/7\");\n// A partir de una URL base.\nURL base = new URL(\"http://docs.oracle.com\");\nURL url = new URL(base, \"/javase/7\");\n</code></pre> <p>Debemos tener en cuenta que este constructor puede lanzar la excepci\u00f3n <code>MalformedURLException</code> si la cadena recibida es <code>null</code>, o no contiene protocolo, o el protocolo que contiene no es conocido. Otro aspecto a tener en cuenta es que el constructor no comprueba que el recurso correspondiente exista realmente en la red.</p> <p>La clase URL nos proporciona una serie de m\u00e9todos informativos para obtener las partes de una URL, como <code>getAuthority()</code>, <code>getPort(),</code> <code>getHost()</code>, <code>getPath()</code>, <code>getQuery()</code> y <code>getFile()</code> (ruta + consulta).</p> <p>Una vez creado nuestro objeto <code>URL</code>, podemos establecer la conexi\u00f3n con el recurso que representa haciendo uso de alguno del m\u00e9todo <code>openConnection()</code>, que retorna un objeto de la clase <code>URLConnection</code> que representa la conexi\u00f3n establecida, permiti\u00e9ndonos acceder no solo al flujo de entrada sino tambi\u00e9n a las cabeceras de la conexi\u00f3n. M\u00e1s adelante hablaremos detalladamente de esta clase.</p>"},{"location":"bloque_v/tema_30/page-3/","title":"3 URLEncoder y URLDecoder","text":""},{"location":"bloque_v/tema_30/page-3/#urlencoder-y-urldecoder","title":"URLEncoder y URLDecoder","text":"<p>Debemos tener en cuenta que los distintos sistemas operativos tienen distintas reglas a la hora de crear los nombres de los archivos, permitiendo en algunos casos caracteres que no son v\u00e1lidos en otros. Esto puede suponer un problema a la hora de trabajar con las URL, ya que, como hemos visto anteriormente, algunos caracteres no est\u00e1n permitidos.</p> <p>Java proporciona la clase <code>URLEncoder</code> con su m\u00e9todo est\u00e1tico <code>encode(stringToEncode, encoding)</code>, y la clase <code>URLDecoder</code> con su m\u00e9todo est\u00e1tico <code>decode(stringToDecode, encoding)</code>, que realizan para nosotros la codificaci\u00f3n y decodificaci\u00f3n, respectivamente, retornando la cadena resultante del proceso. Ambos m\u00e9todos reciben la cadena a procesar y el formato de codificaci\u00f3n de caracteres en el que deben ser procesados, normalmente <code>\"UTF-8\"</code>.</p> <p>Ambos m\u00e9todos lanzan la excepci\u00f3n <code>UnsupportedEncodingException</code> si no es posible, respectivamente, la codificaci\u00f3n o descodificaci\u00f3n.</p> <pre><code>String encoded = URLEncoder.encode(originalUrlString, StandardCharsets.UTF_8.toString());\nString decoded = URLDecoder.decode(encodedUrlString, StandardCharsets.UTF_8.toString());\n</code></pre> <p>Otra soluci\u00f3n consiste en crear un objeto <code>URI</code> usando su constructor <code>URI(string)</code>, que realiza internamente el proceso de codificaci\u00f3n. Si se trata de una url podemos obtener el objeto <code>URL</code> a partir del objeto <code>URI</code> mediante el m\u00e9todo <code>toURL()</code>:</p> <pre><code>URL url = new URI(txtWebUrl.getText().toString()).toURL();\n</code></pre> <p>El constructor de la clase <code>URI</code> puede lanzar la excepci\u00f3n <code>URISyntaxException</code> si la cadena recibida no tiene el formato de una URI v\u00e1lida. Por su parte el m\u00e9todo <code>toURL()</code> puede lanzar la excepci\u00f3n <code>MalformedURLException</code>, ya que internamente llama al constructor de la clase <code>URL</code>.</p>"},{"location":"bloque_v/tema_30/page-4/","title":"4 UrlConnection","text":""},{"location":"bloque_v/tema_30/page-4/#urlconnection","title":"UrlConnection","text":"<p><code>URLConnection</code> es una clase abstracta que act\u00faa como superclase de todas las clases que representan enlaces de comunicaci\u00f3n entre la aplicaci\u00f3n y una URL, como la clase <code>HttpURLConnection</code>. Un objeto <code>URLConnection</code> permite tanto la lectura como la escritura en el recurso representado por la URL.</p> <p>En general, el proceso de creaci\u00f3n de una conexi\u00f3n con una URL sigue los siguientes pasos:</p> <p>Algoritmo de conexi\u00f3n a una URL</p> <ol> <li>Se crea el objeto de conexi\u00f3n llamando al m\u00e9todo <code>openConnection()</code> de un objeto <code>URL</code>, que retorna un objeto <code>URLConnection</code>.</li> <li>Se configuran las caracter\u00edsticas de la conexi\u00f3n, para lo que se llaman a determinados m\u00e9todos del objeto <code>URLConnection</code>.</li> <li>Se establece la conexi\u00f3n llamando al m\u00e9todo <code>connect()</code> del objeto <code>URLConnection</code>.</li> <li>El recurso representado por la URL pasa a estar disponible, por lo que podemos acceder a sus campos de cabecera o a su contenido.</li> </ol> <p>Para configurar las caracter\u00edsticas de conexi\u00f3n podemos usar el m\u00e9todo gen\u00e9rico <code>setRequestProperty(key, value)</code>, o alguno de m\u00e9todos espec\u00edficos para los campos de encabezado m\u00e1s habituales, como por ejemplo <code>setUseCaches(boolean)</code> o <code>setIfModifiedSince(long)</code>.</p> <p>Para acceder a los campos de encabezado podemos usar el m\u00e9todo gen\u00e9rico <code>getHeaderField(key)</code> o los m\u00e9todos espec\u00edficos para los campos de encabezado m\u00e1s habituales, como <code>getContentEncoding()</code>, <code>getContentType()</code>, etc.</p> <p>Para acceder al contenido podemos usar el m\u00e9todo gen\u00e9rico <code>getContent()</code>, que retorna un <code>Object</code>, o usar el input stream proporcionado por el m\u00e9todo <code>getInputStream()</code> para leer de \u00e9l el contenido.</p> <p>Si lo queremos es enviar datos al recurso representado por la URL, entonces deberemos configurar la conexi\u00f3n para que sea posible, usando el m\u00e9todo <code>setDoOutput(true)</code>, y posteriormente usar el m\u00e9todo <code>getOutputStream()</code> para obtener el output stream de salida hacia el recurso, y as\u00ed escribir en \u00e9l.</p>"},{"location":"bloque_v/tema_30/page-5/","title":"5 Protocolo HTTP","text":""},{"location":"bloque_v/tema_30/page-5/#protocolo-http","title":"Protocolo HTTP","text":"<p>El protocolo HTTP (HyperText Transfer Protocol, protocolo de transferencia de hipertexto) es el protocolo de comunicaci\u00f3n principal en la Web, que define las reglas, tipos de peticiones y estructura de datos que deben utilizar los programas para comunicarse entre s\u00ed a trav\u00e9s de la web.</p> <p>Se trata de un protocolo sin estado que utiliza internamente el protocolo TCP para el transporte de los datos. Define una estructura de metadatos (datos sobre los datos), llamada cabecera, que deben ser utilizadas tanto para realizar las peticiones como para devolver las respuestas.</p> <p>El funcionamiento del protocolo es el siguiente:</p> <p>Funcionamiento del protocolo HTTP</p> <ol> <li>El cliente inicia un proceso de petici\u00f3n de un recurso a trav\u00e9s del protocolo HTTP (por ejemplo haciendo click en un enlace de una p\u00e1gina web o escribiendo la direcci\u00f3n del recurso en la barra de direcciones del navegador).</li> <li>Se establece una conexi\u00f3n TCP con el servidor web en el puerto especificado (si no se especifica ser\u00e1 usado el puerto 80 del servidor).</li> <li>Una vez establecida la conexi\u00f3n TCP, el cliente env\u00eda al servidor un mensaje HTTP con la petici\u00f3n del recurso, que incluye la cabecera necesaria.</li> <li>El servidor env\u00eda un mensaje de respuesta a la petici\u00f3n recibida, que incluye la cabecera necesaria.</li> <li>Se cierra la conexi\u00f3n TCP.</li> </ol> <p> </p> Figura 3 - Protocolo HTTP <p>Los mensajes del protocolo HTTP est\u00e1n formados por l\u00edneas de texto plano (ASCII) con las \u00f3rdenes y par\u00e1metros necesarios escritos seg\u00fan la sintaxis definida por el protocolo. Existen dos tipos de mensajes: los mensajes de petici\u00f3n, que son lo que env\u00eda el cliente al servidor, y los mensajes de respuesta, que son los que env\u00eda el servidor al cliente.</p>"},{"location":"bloque_v/tema_30/page-5/#peticiones","title":"Peticiones","text":"<p>Los mensajes de petici\u00f3n (request) est\u00e1n formados por las siguientes partes:</p> <p> </p> Figura 4 - Petici\u00f3n HTTP <ul> <li>L\u00ednea inicial, que incluye:<ul> <li>M\u00e9todo utilizado para la petici\u00f3n: GET, POST, ... (enseguida los explicamos)</li> <li>Servidor de destino (extra\u00eddo de la URL).</li> <li>Versi\u00f3n del protocolo (opcional).</li> </ul> </li> <li>L\u00ednea/s de cabecera: Determinan c\u00f3mo debe ser procesada la petici\u00f3n por parte del servidor. Cada cabecera est\u00e1 formada por un par <code>encabezado: valor</code> y se escribe en una l\u00ednea aparte. Si no hay cabeceras se env\u00eda un 0. Detr\u00e1s de la \u00faltima cabecera se env\u00eda una l\u00ednea en blanco.</li> <li>Cuerpo del mensaje (opcional): Contiene par\u00e1metros o ficheros a enviar al servidor.</li> </ul> <pre><code>GET http://es.kioskea.net HTTP/1.0\nAccept : text/html\nIf-Modified-Since : Saturday, 15-January-2000 14:37:11 GMT\nUser-Agent : Mozilla/4.0 (compatible; MSIE 5.0; Windows 95)\n</code></pre> <p>El m\u00e9todo de petici\u00f3n especifica el tipo de operaci\u00f3n que el cliente quiere que lleve a cabo el servidor. Existen distintos m\u00e9todos de petici\u00f3n, algunos de los cuales detallaremos m\u00e1s adelante:</p> <ul> <li><code>GET</code>: Para obtener cualquier tipo de informaci\u00f3n del servidor.</li> <li><code>POST</code>: Para solicitar al servidor que acepte informaci\u00f3n que se env\u00eda adjunta en la petici\u00f3n.</li> <li><code>HEAD</code>: Para obtener solamente las cabeceras de la respuesta. Similar al m\u00e9todo <code>GET</code> pero NO se obtiene el cuerpo de la respuesta.</li> <li><code>PUT</code>: Para insertar (subir) un recurso al servidor. No est\u00e1 habilitado normalmente, salvo para peticiones a servidores RESTful.</li> <li><code>DELETE</code>: Para eliminar un recurso del servidor. No est\u00e1 habilitado normalmente, salvo en servidores RESTful.</li> <li><code>TRACE</code>: Para obtener la ruta que ha seguido la petici\u00f3n a trav\u00e9s de proxies y cortafuegos. Se usa para depurar errores en redes complejas.</li> <li><code>OPTIONS</code>: Para solicitar al servidor informaci\u00f3n sobre qu\u00e9 m\u00e9todos HTTP est\u00e1n disponibles para un determinado recurso.</li> </ul> <p>El m\u00e9todo <code>GET</code> se emplea para obtener cualquier tipo de informaci\u00f3n del servidor. Es el m\u00e9todo invocado autom\u00e1ticamente cuando se introduce una URL en un navegador o se pulsa un enlace. Permite enviar par\u00e1metros al servidor escribi\u00e9ndolos en la propia URL. Esta zona, conocida como cadena de consulta (query string), se concatena al final de la URL y est\u00e1 formada por el car\u00e1cter <code>?</code> seguido de una lista de pares <code>par\u00e1metro=valor</code> separados por el car\u00e1cter <code>&amp;</code>, sustituyendo los espacios en blanco por el car\u00e1cter <code>+</code>.</p> <p>Por ejemplo, en <code>http://www.informaticasaladillo.es/mostrar.php?nombre=Baldomero&amp;apellidos=Llegate+Ligero</code>, se est\u00e1n enviando dos par\u00e1metros: el par\u00e1metro <code>nombre</code> con el valor <code>Baldomero</code> y el par\u00e1metro <code>apellidos</code> con el valor <code>Ramos Fuerte</code>. Estos par\u00e1metros se incluyen en la l\u00ednea inicial del mensaje de petici\u00f3n.</p> <p>Los mensajes de petici\u00f3n enviados con el m\u00e9todo <code>GET</code> no disponen de la zona conocida como cuerpo del mensaje y no pueden ser utilizados para enviar gran cantidad de datos al servidor (por ejemplo para subir un archivo).</p> <p>Env\u00edo de datos en una petici\u00f3n GET</p> <pre><code>GET /mostrar.php?nombre=Baldomero&amp;apellidos=Llegate+Ligero HTTP/1.1 \nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:2.0.1) Gecko/20130101 Firefox/4.0.1\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Encoding: gzip, deflate\nKeep-alive: 115\nConnection: keep-alive\nReferer: http://www.iessaladillo.es/form_post.html\n</code></pre> <p>El m\u00e9todo <code>POST</code> es utilizado para enviar al servidor informaci\u00f3n que queremos que acepte. El cuerpo del mensaje incluye los par\u00e1metros y valores que se desean enviados, no siendo visibles en la URL (como ocurre en el caso del m\u00e9todo <code>GET</code>).</p> <p>Dado que estamos enviando informaci\u00f3n al servidor para que \u00e9ste realice alguna tarea en concreto, una operaci\u00f3n realizada con <code>POST</code> NO deber\u00eda en principio ser reenviada, ya que conllevar\u00eda que se llevara a cabo la operaci\u00f3n una segunda vez, algo que en la mayor\u00eda de las ocasiones no es lo deseado, por ejemplo en el caso de que la operaci\u00f3n corresponda a ordenar una transferencia bancaria. Por este motivo, los navegadores solicitan confirmaci\u00f3n al usuario antes de reenviar un mensaje <code>POST</code> por haber refrescado la p\u00e1gina.</p> <p>El protocolo HTTP no establece un l\u00edmite en la cantidad de datos que se pueden enviar mediante el m\u00e9todo <code>POST</code>, por lo que lo podemos usar para, por ejemplo, enviar un archivo al servidor.</p> <pre><code>POST /mostrar.php HTTP/1.1\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:2.0.1) Gecko/20130101 Firefox/4.0.1\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Encoding: gzip, deflate\nKeep-alive: 115\nConnection: keep-alive\nReferer: http://www.iessaladillo.es/form_post.html\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 39\n\nnombre=Baldomero&amp;apellidos=Llegate+Ligero\n</code></pre>"},{"location":"bloque_v/tema_30/page-5/#respuestas","title":"Respuestas","text":"<p>Por su parte, los mensajes de respuesta enviados por el servidor est\u00e1n formados por las siguientes partes:</p> <p> </p> Figura 5 - Respuesta HTTP <ul> <li>L\u00ednea inicial de respuesta (l\u00ednea e estado). Incluye:<ul> <li>La versi\u00f3n de HTTP utilizada.</li> <li>El c\u00f3digo de estado o c\u00f3digo de error, que informa al cliente de c\u00f3mo se ha procesado la petici\u00f3n. Por ejemplo, el c\u00f3digo 200 indica que la petici\u00f3n se ha procesado correctamente y se ha enviado el recurso correspondiente al cliente.</li> <li>Texto explicativo del c\u00f3digo de estado.</li> </ul> </li> <li>L\u00ednea/s de cabecera: Describen los datos y la forma en la que son enviados al cliente. Cada cabecera est\u00e1 formada por un par <code>encabezado: valor</code> y se escribe en una l\u00ednea aparte. Si no hay cabeceras se env\u00eda un 0. Detr\u00e1s de la \u00faltima cabecera se env\u00eda una l\u00ednea en blanco.</li> <li>Cuerpo del mensaje (opcional): Viene determinado por el tipo de recurso solicitado.</li> </ul> <p>Respuesta HTTP</p> <pre><code>HTTP/1.1 200 OK\nDate: Sun, 3 Nov 2013 11:53:00 GMT\nServer: Apache/2.2.16 (Debian)\nLast-Modified: Sun, 3 Nov 2013 11:51:48 GMT\nAccept-Ranges: bytes\nVary: Accept-Encoding\nContent-Encoding: gzip\nContent-Length: 86\nKeep-Alive: timeout=15, max=100\nConnection: Keep-Alive\nContent-Type: text/html\n\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Saludo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\nNo te digo trigo...\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>El c\u00f3digo de estado o error es el c\u00f3digo que env\u00eda el servidor en las respuestas HTTP para informar al cliente de c\u00f3mo ha sido procesada la petici\u00f3n. Corresponden a n\u00fameros de tres cifras, clasificados en los siguientes grupos:</p> <ul> <li>Informativos (100 - 199): Indican que el servidor ha recibido la petici\u00f3n pero no ha finalizado de procesarla.</li> <li>\u00c9xito (200-299): Indican que la petici\u00f3n ha sido procesada satisfactoriamente.<ul> <li>El m\u00e1s habitual es el c\u00f3digo <code>200 OK</code></li> </ul> </li> <li>Redirecci\u00f3n (300-399): Indican que la petici\u00f3n ha sido procesada y redirigida a otra localizaci\u00f3n. Por ejemplo:<ul> <li><code>302 Found</code> indica que el recurso solicitado ha cambiado de localizaci\u00f3n, que se especifica en el encabezamiento Location de la respuesta.</li> <li><code>304 Not Modified</code> indica que el recurso solicitado no ha sido modificado y por tanto el navegador deber\u00eda obtenerlo de su cach\u00e9 local.</li> </ul> </li> <li>Error del cliente (400-499): Indican que hay alg\u00fan error en la petici\u00f3n del cliente o no se le concede permiso para acceder al recurso. Por ejemplo:<ul> <li><code>400 Bad request</code> indica que hay un error en la sintaxis en la petici\u00f3n.</li> <li><code>401 Unauthorized</code> indica que no pueden acceder al recurso los usuarios an\u00f3nimos.</li> <li><code>403 Forbidden</code> indica que est\u00e1 prohibido el acceso al recurso solicitado.</li> <li><code>404 Not found</code> indica que el recurso solicitado no se encuentra en el servidor.</li> <li><code>405 Method Not Allowed</code> indica que el m\u00e9todo establecido en la petici\u00f3n no est\u00e1 soportado para el recurso solicitado.</li> <li><code>406 Not Acceptable</code> indica que el servidor no es capaz de devolver los datos en ninguno de los formatos aceptados por el cliente, indicados mediante el encabezamiento \"Accept\" de la petici\u00f3n.</li> </ul> </li> <li>Error en el servidor (500 - 599): Indican que el servidor no puede atender la petici\u00f3n porque tiene alg\u00fan problema. Por ejemplo:<ul> <li><code>500 Internal Server Error</code> indica que se ha producido un error interno en el servidor, por ejemplo de configuraci\u00f3n.</li> <li><code>503 Service Unavailable</code> indica que el servidor no responde en este momento, por ejemplo por sobrecarga de peticiones.</li> </ul> </li> </ul>"},{"location":"bloque_v/tema_30/page-6/","title":"6 Arquitectura REST","text":""},{"location":"bloque_v/tema_30/page-6/#arquitectura-rest","title":"Arquitectura REST","text":"<p>Una API es una forma de describir la forma en que los programas o los sitios webs intercambian datos. El formato de intercambio de datos normalmente es JSON o XML.</p> <p>Las APIs se usan para ofrecer datos a aplicaciones cliente, ya sean web, de escritorio o m\u00f3viles, incluso desarrolladas por la misma empresa propietaria de la API.</p> <p>REST cambi\u00f3 por completo la ingenier\u00eda de software a partir del 2000. Este nuevo enfoque de desarrollo de proyectos y servicios web fue definido por Roy Fielding, el padre de la especificaci\u00f3n HTTP y uno los referentes internacionales en todo lo relacionado con la Arquitectura de Redes, en su disertaci\u00f3n Architectural Styles and the Design of Network-based Software Architectures\u2019.</p> <p>En el campo de las APIs, REST (Representational State Transfer- Transferencia de Estado Representacional) es, a d\u00eda de hoy, el alfa y omega del desarrollo de servicios de aplicaciones.</p> <p>REST</p> <p>Interfaz uniforme entre sistemas que automatiza el uso de HTTP para las operaciones sobre los datos</p> <p>En la actualidad no existe proyecto o aplicaci\u00f3n que no disponga de una API REST para la creaci\u00f3n de servicios profesionales a partir de ese software. Twitter, YouTube, los sistemas de identificaci\u00f3n con Facebook\u2026 hay cientos de empresas que generan negocio gracias a REST y las APIs REST. Sin ellas, todo el crecimiento en horizontal ser\u00eda pr\u00e1cticamente imposible. Esto es as\u00ed porque REST es el est\u00e1ndar m\u00e1s l\u00f3gico, eficiente y habitual en la creaci\u00f3n de APIs para servicios de Internet.</p> <p>Buscando una definici\u00f3n sencilla, REST es cualquier interfaz entre sistemas que use HTTP para obtener datos o generar operaciones sobre esos datos en todos los formatos posibles, como XML y JSON. Es una alternativa en auge a otros protocolos est\u00e1ndar de intercambio de datos como SOAP (Simple Object Access Protocol), que disponen de una gran capacidad pero tambi\u00e9n mucha complejidad. A veces es preferible una soluci\u00f3n m\u00e1s sencilla de manipulaci\u00f3n de datos como REST.</p> <p> Figura 6 - REST API</p> <p>Como ya sabemos, el protocolo HTTP es un protocolo cliente/servidor sin estado, de manera que cada petici\u00f3n HTTP contiene toda la informaci\u00f3n necesaria para ejecutarla, lo que permite que ni cliente ni servidor necesiten recordar ning\u00fan estado previo para satisfacerla. Aunque esto es as\u00ed, algunas aplicaciones HTTP incorporan memoria cach\u00e9. Para ello se configura lo que se conoce como protocolo cliente-cach\u00e9-servidor sin estado, haciendo que exista la posibilidad de definir algunas respuestas a peticiones HTTP concretas como cacheables, con el objetivo de que el cliente pueda ejecutar en un futuro la misma respuesta para peticiones id\u00e9nticas. De todas formas, que exista la posibilidad no significa que sea lo m\u00e1s recomendable.</p>"},{"location":"bloque_v/tema_30/page-6/#uris","title":"URIs","text":"<p>Los recursos en REST siempre se manipulan a partir de la URI. Es la URI y ning\u00fan otro elemento el identificador \u00fanico de cada recurso de ese sistema REST. La URI nos facilita acceder a la informaci\u00f3n para su modificaci\u00f3n o borrado, o, por ejemplo, para compartir su ubicaci\u00f3n exacta con terceros.</p> <p>La API REST debe ser jer\u00e1rquica, usando nombres en plural para los recursos, y un identificador para el recurso concreto. Por ejemplo, para la lista de recurso \"post\", usaremos <code>http://jsonplaceholder.typicode.com/posts/</code>, y para el recurso \"post\" individual con el id <code>1</code> usaremos <code>http://jsonplaceholder.typicode.com/posts/1</code>.</p> <p>La arquitectura REST define una jerarqu\u00eda de recursos. Por ejemplo la URI <code>https://jsonplaceholder.typicode.com/users/1/todos</code> representa las tareas pendientes (<code>todo</code>) del usuario (<code>user</code>) cuyo identificador es <code>1</code>.</p>"},{"location":"bloque_v/tema_30/page-6/#operaciones","title":"Operaciones","text":"<p>Para la transferencia de datos en un sistema REST, este aplica acciones concretas (POST, GET, PUT y DELETE) sobre los recursos, siempre y cuando est\u00e9n identificados con una URI. Esto facilita la existencia de una interfaz uniforme que sistematiza el proceso con la informaci\u00f3n.</p> <p>Las operaciones m\u00e1s importantes relacionadas con los datos en cualquier sistema REST y la especificaci\u00f3n HTTP son cuatro: GET (leer y consultar), POST (crear), PUT (editar) y DELETE (eliminar). Algunos servidores proporcionan tambi\u00e9n la operaci\u00f3n de PATCH (actualizaci\u00f3n parcial de un recurso).</p> <p>Para obtener una lista de recursos se usar\u00e1 el m\u00e9todo GET y una URI que represente la lista de recursos:</p> <pre><code>GET /posts/ HTTP/1.1\nHost: jsonplaceholder.typicode.com\n</code></pre> <p>La respuesta usar\u00e1 el c\u00f3digo de estado HTTP para representar el resultado:</p> <p>Respuesta de lista de recursos</p> <pre><code>HTTP/1.1 200 OK\nDate: Tue, 21 Jan 2020 11:47:49 GMT\nContent-Type: application/json; charset=utf-8\n\n[ { \"userId\": 1, \"id\": 1, \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\", \"body\": \"quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto\" }, { \"userId\": 1, \"id\": 2, \"title\": \"qui est esse\", \"body\": \"est rerum tempore vitae\\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\\nqui aperiam non debitis possimus qui neque nisi nulla\" }, { \"userId\": 1, \"id\": 3, \"title\": \"ea molestias quasi exercitationem repellat qui ipsa sit aut\", \"body\": \"et iusto sed quo iure\\nvoluptatem occaecati omnis eligendi aut ad\\nvoluptatem doloribus vel accusantium quis pariatur\\nmolestiae porro eius odio et labore et velit aut\" } ]\n</code></pre> <p>Para obtener un recurso concreto se usar\u00e1 el m\u00e9todo GET y una URI que represente un recurso individual:</p> <pre><code>GET /posts/1 HTTP/1.1\nHost: jsonplaceholder.typicode.com\n</code></pre> <p>La respuesta usar\u00e1 el c\u00f3digo de estado HTTP 200 para indicar que se ha encontrado:</p> <p>Respuesta de recurso individual correcta</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json; charset=utf-8\n\n{ \"userId\": 1, \"id\": 1, \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\", \"body\": \"quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto\" }\n</code></pre> <p>o el c\u00f3digo de estado 400 para indicar que no se ha encontrado:</p> <pre><code>HTTP/1.1 404 NOT FOUND\nContent-Type: application/json; charset=utf-8\n\n{}\n</code></pre> <p>Para la creaci\u00f3n de recursos se usar\u00e1 una URI que represente una lista de recursos (el recurso todav\u00eda no existe y por tanto no tiene id), el m\u00e9todo HTTP debe ser POST, y se mandar\u00e1 en el cuerpo de la petici\u00f3n los datos del recurso a crear:</p> <pre><code>POST /posts HTTP/1.1\nHost: jsonplaceholder.typicode.com\nContent-type: application/json; charset=UTF-8\n\n{ \"title\": \"foo\", \"body\": \"bar\", \"userId\": 1 }\n</code></pre> <p>Como respuesta a la creaci\u00f3n de un recurso obtendremos alguno de los siguientes c\u00f3digos de respuesta: 403 (Acceso prohibido), 400 (petici\u00f3n incorrecta, p.ej. falta un campo o su valor no es v\u00e1lido), 500 (Error del lado del servidor al intentar crear el recurso, p.ej. se ha ca\u00eddo la BD, 201 (Recurso creado correctamente). Adem\u00e1s, la convenci\u00f3n en REST es devolver en la respuesta la URL del recurso reci\u00e9n creado como valor de la cabecera HTTP Location.</p> <pre><code>HTTP/1.1 201 Created\nContent-Type: application/json; charset=utf-8\nLocation: http://jsonplaceholder.typicode.com/posts/101\n\n{ \"title\": \"foo\", \"body\": \"bar\", \"userId\": 1, \"id\": 101 }\n</code></pre> <p>Respecto a la actualizaci\u00f3n de recursos, se usar\u00e1 una URI que apunte a un recurso individual. Usaremos el m\u00e9todo PUT si vamos a enviar todos los datos recurso, o el m\u00e9todo PATCH para cambiar solo ciertos datos (no soportado por todos los servicios):</p> <pre><code>PUT /posts/1 HTTP/1.1\nHost: jsonplaceholder.typicode.com\nContent-type: application/json; charset=UTF-8\n\n{ \"title\": \"Baldomero\", \"body\": \"Llegate Ligero\", \"userId\": 1 \n</code></pre> <p>y la respuesta incluir\u00e1 alguno de los c\u00f3digos respuestas que ya hemos visto:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json; charset=utf-8\n\n{ \"title\": \"Baldomero\", \"body\": \"Llegate Ligero\", \"userId\": 1, \"id\": 1 }\n</code></pre> <p>Si queremos eliminar un recurso, deberemos usar una URI que apunte a un recurso individual, e indicar el m\u00e9todo DELETE:</p> <pre><code>DELETE /posts/1 HTTP/1.1\nHost: jsonplaceholder.typicode.com\nContent-type: application/json; charset=UTF-8\n</code></pre> <p>y la respuesta ser\u00e1:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json; charset=utf-8\n\n{}\n</code></pre>"},{"location":"bloque_v/tema_30/page-6/#hateoas","title":"HATEOAS","text":"<p>Para cualquier API REST es obligatorio disponer del principio HATEOAS (Hypermedia As The Engine Of Application State - Hipermedia Como Motor del Estado de la Aplicaci\u00f3n) para ser una verdadera API REST. Este principio es el que define que cada vez que se hace una petici\u00f3n al servidor y \u00e9ste devuelve una respuesta, parte de la informaci\u00f3n que contendr\u00e1 corresponder\u00e1 a los hiperv\u00ednculos de navegaci\u00f3n asociada a otros recursos del cliente.</p> <p>Por ejemplo, en la siguiente API con datos sobre las pel\u00edculas de Star Wars, cuando solicitamos el recurso correspondiente al personaje cuyo id es 1</p> <pre><code>GET /api/people/1 HTTP/1.1\nreferer: https://swapi.co/api/people/1\n</code></pre> <p>en la respuesta se incluyen las URI con las que podemos acceder en la misma API a cada una de las pel\u00edculas en las que aparece dicho personaje:</p> <p>Respuesta de personaje con id 1</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"name\": \"Luke Skywalker\",\n    \"height\": \"172\",\n    \"mass\": \"77\",\n    \"hair_color\": \"blond\",\n    \"skin_color\": \"fair\",\n    \"eye_color\": \"blue\",\n    \"birth_year\": \"19BBY\",\n    \"gender\": \"male\",\n    \"homeworld\": \"https://swapi.co/api/planets/1/\",\n    \"films\": [\n        \"https://swapi.co/api/films/2/\",\n        \"https://swapi.co/api/films/6/\",\n        \"https://swapi.co/api/films/3/\",\n        \"https://swapi.co/api/films/1/\",\n        \"https://swapi.co/api/films/7/\"\n    ],\n    \"species\": [\n        \"https://swapi.co/api/species/1/\"\n    ],\n    \"vehicles\": [\n        \"https://swapi.co/api/vehicles/14/\",\n        \"https://swapi.co/api/vehicles/30/\"\n    ],\n    \"starships\": [\n        \"https://swapi.co/api/starships/12/\",\n        \"https://swapi.co/api/starships/22/\"\n    ],\n    \"created\": \"2014-12-09T13:50:51.644000Z\",\n    \"edited\": \"2014-12-20T21:17:56.891000Z\",\n    \"url\": \"https://swapi.co/api/people/1/\"\n}\n</code></pre>"},{"location":"bloque_v/tema_30/page-6/#ventajas","title":"Ventajas","text":"<p>El servidor debe marcar de forma impl\u00edcita o expl\u00edcita las respuestas para indicar si el cliente puede o no cachearlas. As\u00ed, en futuras peticiones, el cliente sabr\u00e1 si puede reutilizar o no los datos que ya hab\u00eda obtenido. Al ahorrar peticiones, mejoraremos la escabilidad de la aplicaci\u00f3n y el rendimiento en cliente (evitamos principalmente la latencia de red).</p> <p>REST ofrece una serie de ventajas para el desarrollo:</p> <ul> <li>Separaci\u00f3n entre el cliente y el servidor: el protocolo REST separa totalmente la interfaz de usuario del servidor y el almacenamiento de datos. De esta manera el cliente acceder a los recursos a trav\u00e9s de su identificador, pero no tiene conocimiento real de c\u00f3mo estar almacenados realmente dichos recursos en el servidor. Esto tiene algunas ventajas cuando se hacen desarrollos. Por ejemplo, mejora la portabilidad de la interfaz a otro tipo de plataformas, aumenta la escalabilidad de los proyectos y permite que los distintos componentes de los desarrollos se puedan evolucionar de forma independiente.</li> <li>Visibilidad, fiabilidad y escalabilidad. La separaci\u00f3n entre cliente y servidor tiene una ventaja evidente y es que cualquier equipo de desarrollo puede escalar el producto sin excesivos problemas. Se puede migrar a otros servidores o realizar todo tipo de cambios en la base de datos, siempre y cuando los datos de cada una de las peticiones se env\u00eden de forma correcta. Esta separaci\u00f3n facilita tener en servidores distintos el front-end y el back-end , permitiendo que \u00e9stos sean desarrollados por separado, convirti\u00e9ndolos en productos m\u00e1s flexibles a la hora de trabajar. Mientras la interfaz no cambie, podremos cambiar el cliente o el servidor sin problemas.</li> <li>La API REST siempre es independiente del tipo de plataformas o lenguajes: la API REST siempre se adapta al tipo de sintaxis o plataformas con las que se est\u00e9n trabajando, lo que ofrece una gran libertad a la hora de cambiar o probar nuevos entornos dentro del desarrollo. Con una API REST se pueden tener servidores PHP, Java, Python o Node.js. Lo \u00fanico que es indispensable es que las respuestas a las peticiones se hagan siempre en el lenguaje de intercambio de informaci\u00f3n usado, normalmente XML o JSON.</li> <li>Permite el uso de un sistema de capas o servidores intermedios, para aumentar la escalabilidad (sistemas de balanceo de carga, cach\u00e9s) o para implementar pol\u00edticas de seguridad. Por su parte, el cliente puede estar conectado mediante la interfaz al servidor principal o a un intermediario, ya que esto ser\u00e1 transparente para \u00e9l.</li> </ul> <p>Info</p> <p>https://bbvaopen4u.com/es/actualidad/api-rest-que-es-y-cuales-son-sus-ventajas-en-el-desarrollo-de-proyectos</p>"},{"location":"bloque_v/tema_30/page-7/","title":"7 HttpURLConnection","text":""},{"location":"bloque_v/tema_30/page-7/#httpurlconnection","title":"HttpURLConnection","text":"<p>La clase <code>HttpUrlConnection</code> extiende de <code>URLConnection</code> y proporciona a la conexi\u00f3n las funcionalidades espec\u00edficas del protocolo HTTP.</p> <p>Cada instancia de la clase <code>HttpURLConnection</code> debe ser usada para un \u00fanica conexi\u00f3n, es decir, que si posteriormente deseamos realizar otra conexi\u00f3n deberemos crear un nuevo objeto <code>HttpURLConnection</code> y no reusar el anterior. A\u00fan as\u00ed, con objeto de optimizar recursos, el sistema hace que la conexi\u00f3n de red interna sea compartida de forma transparente para el programador con otras instancias de <code>HttpURLConnection</code>.</p> <p>Si queremos obtener un objeto que represente una conexi\u00f3n con un recurso web apuntado por una determinada URL, deberemos llamar al m\u00e9todo <code>openConnection()</code> del objeto <code>URL</code>, que retorna un objeto <code>URLConnection</code>.</p> <p>Dado que nuestra conexi\u00f3n usa el protocolo HTTP, realizaremos un cast expl\u00edcito a <code>HttpURLConnection</code> del objeto <code>URLConnection</code> retornado por el m\u00e9todo <code>openConnection()</code>.</p> <pre><code>HttpURLConnection httpUrlConnection = (HttpURLConnection) url.openConnection()\n</code></pre> <p>El m\u00e9todo <code>openConnection()</code> puede lanzar la excepci\u00f3n <code>IOException</code> si se produce un error de entrada o salida mientras se est\u00e1 abriendo la conexi\u00f3n.</p> <p>Debemos tener en cuenta que el m\u00e9todo anterior simplemente crea un objeto que representa la conexi\u00f3n, pero no realiza la conexi\u00f3n en s\u00ed. Para que se lleve a cabo la conexi\u00f3n deberemos llamar al m\u00e9todo <code>connect()</code>, como vimos anteriormente.</p> <p>Una vez que tengamos el objeto <code>HttpURLConnection</code> podemos configurar la conexi\u00f3n a trav\u00e9s de una serie de m\u00e9todos. Todos estos m\u00e9todos lanzan la excepci\u00f3n <code>ProtocolException</code> si ya hubi\u00e9ramos establecido la conexi\u00f3n. Por este motivo siempre debemos establecer estos m\u00e9todos antes de llamar al m\u00e9todo <code>connect()</code>:</p> <ul> <li><code>setRequestMethod(methodString)</code>: Establece el m\u00e9todo del protocolo HTTP que se quiere usar. Puede recibir los valores <code>GET</code> (valor por defecto), <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, y otro menos usados. Este m\u00e9todo puede lanzar la excepci\u00f3n <code>ProtocolException</code> si el m\u00e9todo indicado no es v\u00e1lido.</li> <li><code>setConnectionTimeout(timeoutMilis)</code>: Establece el tiempo m\u00e1ximo que se esperar\u00e1 para establecer la conexi\u00f3n cuando esta se inicie, transcurrido el cual se lanzar\u00e1 una excepci\u00f3n.</li> <li><code>setReadTimeout(timeoutMilis)</code>: Establece el tiempo m\u00e1ximo que se esperar\u00e1 para realizar una operaci\u00f3n de lectura de la conexi\u00f3n, transcurrido el cual se lanzar\u00e1 una excepci\u00f3n.</li> <li><code>setRequestProperty(headerName, headerValue)</code>: Establece un determinado encabezado en la petici\u00f3n HTTP.</li> <li><code>setDoInput(boolean)</code>: Una conexi\u00f3n HTTP a una URL puede ser usada tanto para obtener informaci\u00f3n como para enviar informaci\u00f3n. Mediante el m\u00e9todo <code>doInput(true)</code> indicamos que querremos leer la informaci\u00f3n recibida desde el servidor. Normalmente no llamaremos a este m\u00e9todo porque es el comportamiento por defecto.</li> <li><code>setDoOutput(boolean)</code>: Si queremos enviar datos al servidor ser\u00e1 necesario que lo indiquemos expl\u00edcitamente llamando al m\u00e9todo <code>doOutput(true)</code>, ya que por defecto esta posibilidad est\u00e1 deshabitada.</li> </ul> <pre><code>// Por defecto el m\u00e9todo ser\u00e1 GET y estar\u00e1 activada la posibilidad de leer la\n// respuesta, por lo que en este caso no ser\u00e1 necesario llamar a\n// setRequestMethod(\"GET\") ni a setDoInput(true).\nhttpUrlConnection.add   RequestProperty(\"User-Agent\",\n                    \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\");\nhttpUrlConnection.setConnectTimeout(5000);\nhttpUrlConnection.setReadTimeout(5000);\n</code></pre> <p>Una vez configurada la petici\u00f3n, iniciaremos la conexi\u00f3n llamando al m\u00e9todo <code>connect()</code>, que la establecer\u00e1 siempre y cuando no hubiera sido establecida anteriormente. Este m\u00e9todo lanzar\u00e1 la excepci\u00f3n <code>SocketTimeoutException</code> si transcurre el timeout indicado mediante <code>setConnectionTimeout()</code> sin que haya sido posible establecer la conexi\u00f3n. Tambi\u00e9n podr\u00e1 lanzar la excepci\u00f3n <code>IOException</code> si se produce un error de entrada/salida durante la conexi\u00f3n. Se trata de una llamada s\u00edncrona, que finalizar\u00e1 de ejecutarse cuando se obtenga la respuesta por parte del servidor.</p> <p>Debemos tener en cuenta que los m\u00e9todos del objeto <code>HttpUrlConnection</code> cuyo resultado dependa de que se hubiera establecido la conexi\u00f3n, realizar\u00e1n la conexi\u00f3n impl\u00edcitamente sin que sea necesario llamar expl\u00edcitamente al m\u00e9todo <code>connect()</code>. Es el caso de los m\u00e9todos <code>getResponseCode()</code>, <code>getResponseMessage()</code>, <code>getInputStream()</code>, <code>getOutputStream()</code>, <code>getContentLength()</code>, etc.</p> <p>Una vez obtenida la respuesta del servidor podemos proceder a leer la informaci\u00f3n enviada por el mismo. De la respuesta obtenida el elemento m\u00e1s importante es el c\u00f3digo de respuesta, tambi\u00e9n llamado HTTP status code, que corresponde a un valor entero est\u00e1ndar indicativo que c\u00f3mo ha ido la petici\u00f3n. Para obtener dicho valor podemos llamar al m\u00e9todo <code>getResponseCode()</code>. Dicho m\u00e9todo lanzar\u00e1 la excepci\u00f3n <code>IOException</code> si se produjo un error en la conexi\u00f3n con el servidor. La clase <code>HttpURLConnection</code> define una serie de constantes con los c\u00f3digos de respuesta m\u00e1s significativos. El m\u00e1s deseado de ellos es <code>HttpURLConnection.HTTP_OK</code>, cuyo valor es <code>200</code>, y que es indicativo de que todo ha ido bien (los c\u00f3digos de respuesta en el rango <code>200-299</code> son positivos). Por tanto, una vez realizada la conexi\u00f3n realizaremos la comprobaci\u00f3n del c\u00f3digo de respuesta de la siguiente manera:</p> <pre><code>// Es llamado impl\u00edcitamente por el m\u00e9todo getResponseCode().\n// httpUrlConnection.connect();\nif (httpUrlConnection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n    // Todo ha ido bien, podemos proceder a leer la respuesta\n    // ...\n}\n</code></pre> <p>Si queremos obtener la descripci\u00f3n textual del c\u00f3digo de respuesta enviada por el servidor podemos usar el m\u00e9todo <code>getResponseMessage()</code>.</p> <p>Para que podamos leer el cuerpo de la respuesta, la clase <code>HttpURLConnection</code> posee el m\u00e9todo <code>getInputStream()</code>, que retorna un objeto <code>InputStream</code>, que corresponde a un flujo de datos de entrada que podremos proceder a leer de forma similar a si proviniera, por ejemplo, de un fichero. Este m\u00e9todo puede lanzar la excepci\u00f3n <code>IOException</code> si se produce un error de entrada/salida durante la creaci\u00f3n del flujo, o si el c\u00f3digo de respuesta corresponde a un valor indicativo de que se ha producido un error al procesar la petici\u00f3n. En este \u00faltimo caso se puede usar el m\u00e9todo <code>getErrorStream()</code> para obtener un flujo con la informaci\u00f3n de error.</p> <p>Debemos tener en cuenta que el flujo retornado por el m\u00e9todo anterior no usa ning\u00fan tipo de buffer, por lo que normalmente al usarlo lo envolveremos en un <code>BufferedInputStream</code> creado a partir de \u00e9l que s\u00ed act\u00fae como buffer. Otra posibilidad es usar un <code>BufferedReader</code> para leer del flujo original.</p> <p>A continuaci\u00f3n se muestra un m\u00e9todo de utilidad que recibe un flujo de entrada y retorna una cadena de caracteres con todo el contenido le\u00eddo desde dicho flujo:</p> <pre><code>public static String readInputStream(InputStream inputStream) throws IOException {\n    // Utiliza la estructura try-with-resources de Java 8 para ue el bufferedReader\n    // se cierre autom\u00e1ticamente, lo que producir\u00e1 que se cierre el inputStream.\n    try (BufferedReader bufferedReader = \n        new BufferedReader(new InputStreamReader(inputStream))) {\n        // Usa los streams para leer todas las l\u00edneas.\n        return bufferedReader.lines().collect(Collectors.joining(\"\\n\"));\n    }\n}\n</code></pre> <p>En Java 9 es a\u00fan m\u00e1s sencillo, ya que podemos usar directamente:</p> <pre><code>String content = new String(inputStream.readAllBytes());\n</code></pre> <p>Una vez ha sido le\u00eddo el cuerpo de la respuesta, debemos proceder a realizar la desconexi\u00f3n, para lo que haremos uso del m\u00e9todo <code>disconnect()</code> del objeto <code>HttpURLConnection</code>. Debemos tener en cuenta que dicha operaci\u00f3n debe llevarse a cabo incluso si se ha producido alg\u00fan error despu\u00e9s de realizar la conexi\u00f3n, por lo que suele incluirse dentro de la rama <code>finally</code> de un <code>try-catch-finally</code>. Al realizar la desconexi\u00f3n se liberan los recursos de la misma para que puedan ser reusados. Por ejemplo:</p> <pre><code>// ...\ntry {\ncontent = HttpUtils.readContent(httpUrlConnection.getInputStream());  \n} finally {\n    if (httpUrlConnection != null) {\n        httpUrlConnection.disconnect();\n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_30/page-7/#peticion-get","title":"Petici\u00f3n GET","text":"<p>A modo de resumen de lo anterior, a continuaci\u00f3n vemos el c\u00f3digo de un m\u00e9todo que retorna en forma de cadena de caracteres el contenido de la respuesta correspondiente a una petici\u00f3n GET a una URL:</p> <pre><code>private String doGetRequest(URL url) throws IOException {\n    String content = \"\";\n    HttpURLConnection httpUrlConnection;\n    try {\n        httpUrlConnection = (HttpURLConnection) url.openConnection()\n        httpUrlConnection.setConnectTimeout(5000);\n        httpUrlConnection.setReadTimeout(5000);\n        if (httpUrlConnection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            content = HttpUtils.readContent(httpUrlConnection.getInputStream()); \n        }\n        return content;\n    } finally {\n        if (httpUrlConnection != null) {\n            httpUrlConnection.disconnect();\n        } \n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_30/page-7/#peticion-post","title":"Petici\u00f3n POST","text":"<p>Si nuestra petici\u00f3n va a enviar datos al servidor, deberemos indic\u00e1rselo expl\u00edcitamente al objeto <code>HttpUrlConnection</code> mediante el m\u00e9todo <code>setDoOutput(true)</code>, que debe ser llamado antes de que se establezca la conexi\u00f3n.</p> <p>Adem\u00e1s, deberemos llamar al m\u00e9todo <code>setFixedLengthStreamingMode(int)</code> cuando sepamos de antemano el tama\u00f1o del cuerpo de la petici\u00f3n (tama\u00f1o de los datos que se quieren enviar), o al m\u00e9todo <code>setChunkedStreamingMode(int)</code> si no conocemos dicho tama\u00f1o, que recibe el tama\u00f1o de los partes en el que se quieren enviar los datos, o <code>0</code> si queremos que se use un tama\u00f1o por defecto. Si no llamamos a ninguno de ambos m\u00e9todos, el objeto <code>HttpURLConnection</code> se ver\u00e1 forzado a almacenar en memoria el cuerpo de petici\u00f3n completo antes de poder transmitirlo.</p> <p>Tambi\u00e9n deberemos obtener el flujo de salida de la conexi\u00f3n, para que podamos escribir en \u00e9l los datos. Para ello llamaremos al m\u00e9todo <code>getOutputStream()</code> del objeto <code>HttpUrlConnection</code>, que realizar\u00e1 la conexi\u00f3n impl\u00edcitamente si no se hab\u00eda establecido a\u00fan. Este m\u00e9todo puede lanzar la excepci\u00f3n <code>IOException</code> si se produce un error de entrada/salida durante la creaci\u00f3n del flujo.</p> <p>El objeto <code>OutputStream</code> retornado por el m\u00e9todo anterior no usa ning\u00fan buffer, por lo que se recomienda envolverlo en alg\u00fan <code>BufferedStream</code> o simplemente usar para escribir en \u00e9l alg\u00fan <code>BufferedWriter</code>.</p> <p>Debemos tener en cuenta que la cabecera <code>Content-Type</code> es la que indica el formato en el que se van a enviar los datos al servidor. Evidentemente los datos se deben enviar en el formato el que el servidor espere recibirlos. Uno de los formatos m\u00e1s habituales es <code>application/x-www-form-urlencoded</code>, que indica que los datos van a enviarse en el cuerpo de la petici\u00f3n en forma de <code>variable1=valor1&amp;variable2=valor2</code>, de forma similar a como si fueran incluido en la propia URL. Si se van a enviar los datos en formato JSON usaremos el valor <code>application/json</code> para dicha cabecera.</p> <p>A modo de resumen, en el siguiente c\u00f3digo vemos un m\u00e9todo que env\u00eda datos a una URL mediante el m\u00e9todo POST del protocolo HTTP y obtiene la respuesta en forma de cadena de texto:</p> <pre><code>private String doPostUrlEncodedRequest(URL url, Map&lt;String, String&gt; parameters) \n        throws IOException {\n    String content = \"\";\n    try {\n        HttpURLConnection httpUrlConnection = (HttpURLConnection) url.openConnection();\n        httpUrlConnection.setRequestMethod(\"POST\");\n        httpUrlConnection.setConnectTimeout(5000);\n        httpUrlConnection.setReadTimeout(5000);\n        httpUrlConnection.setDoOutput(true);\n        if (parameters != null) {\n            try (PrintWriter writer = new PrintWriter (\n                                            httpUrlConnection.getOutputStream())) {\n                boolean addAmpersand = false;\n                for (Map.Entry&lt;String, String&gt; p : parameters.entrySet()) {\n                    if (addAmpersand) {\n                        writer.write(\"&amp;\");\n                    }\n                    else {\n                        addAmpersand = true;\n                    }\n                    writer.write(p.getKey() + \"=\" + p.getValue());\n                }\n                writer.flush();\n            }\n        }\n        if (httpUrlConnection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            content = readContent(httpUrlConnection.getInputStream()); \n        }\n        return content;\n    } finally {\n        if (httpUrlConnection != null) {\n            httpUrlConnection.disconnect();\n        } \n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_30/page-7/#descarga-de-una-imagen","title":"Descarga de una imagen","text":"<p>En el siguiente c\u00f3digo vemos un ejemplo de c\u00f3mo obtener mediante el protocolo HTTP una imagen alojada en la web:</p> <p>Descarga de una imagen con HttpURLConnection</p> <pre><code>public Bitmap downloadImage(URL url) throws IOException {\n    Bitmap bitmap = null;\n    try {\n        HttpURLConnection httpUrlConnection = (HttpURLConnection) url.openConnection();\n        byte[] result;\n        try(InputStream inputStream = conexion.getInputStream(); \n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            byte[] b = new byte[1024];\n            while (inputStream.read(b) != -1) {\n                outputStream.write(b);\n            }\n            result = outputStream.toByteArray();\n        }\n        bitmap = BitmapFactory.decodeByteArray(result, 0, result.length);\n        return bitmap;\n    } finally {\n        if (httpUrlConnection != null) {\n            httpUrlConnection.disconnect();\n        } \n    }\n}\n</code></pre>"},{"location":"bloque_v/tema_30/page-7/#proyecto-httpurlconnection","title":"Proyecto HttpURLConnection","text":"<p>En este proyecto vamos a realizar una aplicaci\u00f3n que realiza distintos tipos de peticiones HTTP a un servicio REST de ejemplo, a trav\u00e9s de la clase <code>HttpURLConnection</code>.</p> <p>Cada petici\u00f3n y su correspondiente respuesta son mostradas por consola. Para ello creamos una funci\u00f3n general que reciba como argumentos los datos necesarios para configurar la petici\u00f3n (estamos usando Java 9).</p> MainHttpUtils <pre><code>import java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static final int TIMEOUT_MILLIS = 5000;\n\n    private final Scanner scanner = new Scanner(System.in);\n\n    Main() {\n        int selectedOption = showMenu();\n        processOption(selectedOption);\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n\n    private int showMenu() {\n        System.out.println(\"\\nMENU\");\n        System.out.println(\"1. Show all posts\");\n        System.out.println(\"2. Show post\");\n        System.out.println(\"3. Show user's posts\");\n        System.out.println(\"4. Create post\");\n        System.out.println(\"5. Update post\");\n        System.out.println(\"6. Update post partially\");\n        System.out.println(\"7. Delete post\");\n        System.out.println(\"8. Show only headers\");\n        System.out.println(\"9. Show access options\");\n        System.out.print(\"Select an option: \");\n        try {\n            return scanner.nextInt();\n        } catch (Exception e) {\n            scanner.nextLine();\n            return 0;\n        }\n    }\n\n    private void processOption(int selectedOption) {\n        switch (selectedOption) {\n            case 1:\n                showPosts();\n                break;\n            case 2:\n                showPost(1);\n                break;\n            case 3:\n                showUserPosts(1);\n                break;\n            case 4:\n                createPost(\"{\\\"title\\\": \\\"Baldomero\\\", \\\"body\\\": \\\"Llegate Ligero\\\", \\\"userId\\\": 1}\");\n                break;\n            case 5:\n                updatePost(1, \"{\\\"id\\\": 1, \\\"title\\\": \\\"Baldomero\\\", \\\"body\\\": \\\"Llegate Ligero\\\", \\\"userId\\\": 1}\");\n                break;\n            case 6:\n                patchPost(1, \"{\\\"title\\\": \\\"Baldomero\\\"}\");\n                break;\n            case 7:\n                deletePost(1);\n                break;\n            case 8:\n                showPostsHeaders();\n                break;\n            case 9:\n                showPostsAccessOptions();\n                break;\n        }\n    }\n\n    private void showPosts() {\n        HttpUtils.doHttpRequestAsync(\"https://jsonplaceholder.typicode.com/posts\", \"GET\", \n                null, null, TIMEOUT_MILLIS).join();\n    }\n\n    private void showPost(int postId) {\n        HttpUtils.doHttpRequestAsync(\"https://jsonplaceholder.typicode.com/posts/\" + postId, \"GET\",\n                null, null, TIMEOUT_MILLIS).join();\n    }\n\n    private void createPost(String jsonPost) {\n        HttpUtils.doHttpRequestAsync(\"https://jsonplaceholder.typicode.com/posts\", \"POST\",\n                Map.of(\"Content-type\", \"application/json; charset=UTF-8\"),\n                jsonPost.getBytes(), TIMEOUT_MILLIS).join();\n    }\n\n    private void updatePost(int postId, String jsonPost) {\n        HttpUtils.doHttpRequestAsync(\"https://jsonplaceholder.typicode.com/posts/\" + postId, \"PUT\",\n                Map.of(\"Content-type\", \"application/json; charset=UTF-8\"),\n                jsonPost.getBytes(), TIMEOUT_MILLIS).join();\n    }\n\n    private void patchPost(int postId, String jsonPost) {\n        HttpUtils.doHttpRequestAsync(\"https://jsonplaceholder.typicode.com/posts/\" + postId, \"PATCH\",\n                Map.of(\"Content-type\", \"application/json; charset=UTF-8\"),\n                jsonPost.getBytes(), TIMEOUT_MILLIS).join();\n    }\n\n    private void deletePost(int postId) {\n        HttpUtils.doHttpRequestAsync(\"https://jsonplaceholder.typicode.com/posts/\" + postId, \"DELETE\", \n                null, null, TIMEOUT_MILLIS).join();\n    }\n\n    private void showUserPosts(int userId) {\n        HttpUtils.doHttpRequestAsync(\"https://jsonplaceholder.typicode.com/users/\" + userId + \"/posts\", \"GET\",\n                null, null, TIMEOUT_MILLIS).join();\n    }\n\n    private void showPostsHeaders() {\n        HttpUtils.doHttpRequestAsync(\"https://jsonplaceholder.typicode.com/posts\", \"HEAD\", \n                null, null, TIMEOUT_MILLIS)\n                .exceptionally(this::showError)\n                .join();\n    }\n\n    private void showPostsAccessOptions() {\n        HttpUtils.doHttpRequestAsync(\"https://jsonplaceholder.typicode.com/posts\", \"OPTIONS\", \n                null, null, TIMEOUT_MILLIS).join();\n    }\n\n    private Void showError(Throwable e) {\n        System.out.println(e.toString());\n        return null;\n    }\n\n\n}\n</code></pre> <pre><code>import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Executor;\n\npublic class HttpUtils {\n\n    private HttpUtils() {\n    }\n\n    public static CompletableFuture&lt;Void&gt; doHttpRequestAsync(String urlString, String requestMethod, Map&lt;String, String&gt; requestHeaders,\n                                                            byte[] requestBody, int timeout) {\n        return CompletableFuture.runAsync(\n                () -&gt; doHttpRequest(urlString, requestMethod, requestHeaders, requestBody, timeout));\n    }\n\n    public static CompletableFuture&lt;Void&gt; doHttpRequestAsync(String urlString, String requestMethod, Map&lt;String, String&gt; requestHeaders,\n                                                            byte[] requestBody, int timeout, Executor executor) {\n        return CompletableFuture.runAsync(\n                () -&gt; doHttpRequest(urlString, requestMethod, requestHeaders, requestBody, timeout),\n                executor);\n    }\n\n    private static void doHttpRequest(String urlString, String requestMethod, Map&lt;String, String&gt; requestHeaders,\n                                    byte[] requestBody, int timeout) {\n        HttpURLConnection httpUrlConnection = null;\n        try {\n            URL url = new URL(urlString);\n            // 1. Create connection with the URL.\n            httpUrlConnection = (HttpURLConnection) url.openConnection();\n            // 2. Setup request\n            // 2.1. Request method.\n            // PATCH method is not allowed as requesMethod, so is hacked as POST method.\n            if (\"PATCH\".equals(requestMethod)) {\n                httpUrlConnection.setRequestProperty(\"X-HTTP-Method-Override\", \"PATCH\");\n                httpUrlConnection.setRequestMethod(\"POST\");\n            } else {\n                httpUrlConnection.setRequestMethod(requestMethod);\n            }\n            // 2.2. Request timeouts.\n            httpUrlConnection.setConnectTimeout(timeout);\n            httpUrlConnection.setReadTimeout(timeout);\n            // 2.3. Request headers\n            if (requestHeaders != null) {\n                for (Map.Entry&lt;String, String&gt; header : requestHeaders.entrySet()) {\n                    httpUrlConnection.addRequestProperty(header.getKey(), header.getValue());\n                }\n            }\n            // 2.4. Request body.\n            if (requestBody != null) {\n                httpUrlConnection.setDoOutput(true);\n                try (OutputStream out = httpUrlConnection.getOutputStream()) {\n                    out.write(requestBody);\n                    out.flush();\n                }\n            }\n            // 3. Connect (optional, internally called by getResponseCode())\n            httpUrlConnection.connect();\n            // 4. Process response\n            // 4.1. Response code\n            System.out.print(httpUrlConnection.getResponseCode());\n            // 4.2. Response message\n            System.out.println(\" \" + httpUrlConnection.getResponseMessage());\n            // 4.2. Response headers.\n            if (httpUrlConnection.getHeaderFields() != null) {\n                for (Map.Entry&lt;String, List&lt;String&gt;&gt; responseHeader : httpUrlConnection.getHeaderFields().entrySet()) {\n                    if (responseHeader.getKey() != null) {\n                        System.out.print(responseHeader.getKey() + \": \");\n                    }\n                    System.out.println(String.join(\", \", responseHeader.getValue()));\n                }\n            }\n            if (httpUrlConnection.getResponseCode() &gt;= 200 &amp;&amp; httpUrlConnection.getResponseCode() &lt; 300) {\n                // 4.3 Response body\n                System.out.println(\"\\n\" + readInputStream(httpUrlConnection.getInputStream()));\n            }\n        } catch (IOException e) {\n            // 5. Show error.\n            System.out.println(e.getMessage());\n        } finally {\n            // 6. Disconnect\n            if (httpUrlConnection != null) {\n                httpUrlConnection.disconnect();\n            }\n        }\n    }\n\n    private static String readInputStream(InputStream inputStream) throws IOException {\n        return new String(inputStream.readAllBytes());\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_30/page-7/#problemas-de-httpurlconnection","title":"Problemas de HttpURLConnection","text":"<p>Hasta la versi\u00f3n 11 de Java, la \u00fanica forma de trabajar con el protocolo HTTP era a trav\u00e9s de la clase <code>HttpURLConnection</code>, disponible desde Java 1.1. Sin embargo, esta clase tiene una serie de problemas:</p> <ul> <li>La API de <code>URLConnection</code>, de la que hereda <code>HttpURLConnection</code>, fue dise\u00f1ada para m\u00faltiples protocolos que ya no est\u00e1n en funcionamiento.</li> <li>No es compatible con el protocolo HTTP/2, su versi\u00f3n m\u00e1s reciente.</li> <li>S\u00f3lo trabaja en modo s\u00edncrono, de manera que el hilo llamador queda bloqueado hasta que se recibe la respuesta.</li> <li>No es precisamente sencilla de usar ni mantener, y no es modular (no separa en clases los conceptos de cliente, petici\u00f3n y respuesta).</li> </ul> <p>De hecho, si vemos el Proyecto HttpURLConnection comprobamos que aunque las peticiones se est\u00e1n realizado en un hilo secundario, no est\u00e1 configurando un cliente HTTP que despu\u00e9s podamos reusar m\u00faltiples veces, sino que en cada petici\u00f3n debe configurarse. Por otra parte, la petici\u00f3n no se pasa en forma de objeto, sino que pasamos el verbo HTTP a usar, el cuerpo y las cabeceras de la petici\u00f3n de forma individual. Finalmente, el m\u00e9todo construido no retorna una respuesta, sino que directamente la procesa, mostr\u00e1ndola por pantalla. No existe un objeto que represente la respuesta, con su c\u00f3digo de respuesta y su cuerpo, de manera que podamos procesarla posteriormente.</p> <p>Por todo lo anterior, muchos proyectos optaron por usar librer\u00edas externas para crear clientes HTTP, que solucionan los problemas que acabamos de HttpURLConnection que acabamos de describir. Las m\u00e1s famosas de estas librer\u00edas son Apache HTTP Client y OkHttp, que fueron creadas mucho antes de la aparici\u00f3n Java 8, y se convirtieron en el est\u00e1ndar de facto.</p> <p>Sin embargo, Java 11 introdujo una nueva API para la creaci\u00f3n de clientes HTTP compatibles con HTTP/2. Adem\u00e1s, y a diferencia de la clase <code>HttpURLConnection</code>, el nuevo cliente HTTP nos proporciona mecanismos para realizar y gestionar peticiones as\u00edncronas, separando claramente los objetos que representan el cliente HTTP, la petici\u00f3n HTTP y la respuesta HTTP.</p> <p>En siguientes apartados estudiaremos la librer\u00eda OkHttp, que es ampliamente usada en programaci\u00f3n para dispositivos Android, y el cliente HTTP introducido en la versi\u00f3n 11 de Java.</p>"},{"location":"bloque_v/tema_30/page-8/","title":"8 OkHttp","text":""},{"location":"bloque_v/tema_30/page-8/#okhttp","title":"OkHttp","text":"<p>OkHttp es una librer\u00eda desarrollada por la empresa Square para crear clientes HTTP y HTTP/2 eficientes, lo que permite realizar las peticiones se realizan m\u00e1s r\u00e1pidamente y ahorrar ancho de banda. Proporciona a los desarrolladores una API que incorpora clases para modelar las peticiones (request) y las respuestas (response).</p> <p>Librer\u00eda OkHttp</p> <p>https://square.github.io/okhttp/</p> <p>Para poder usar esta librer\u00eda ser\u00e1 necesario a\u00f1adir la dependencia correspondiente en el archivo <code>build.gradle</code> del m\u00f3dulo en cuesti\u00f3n si usas gradle o en el <code>pom.xml</code> si usas maven:</p> GradleMaven <pre><code>dependencies {\n    // ...\n    implementation 'com.squareup.okhttp3:okhttp:X.X.X'\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;\n    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;\n    &lt;version&gt;X.X.X&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>La clase <code>OkHttpClient</code> representa el cliente HTTP que ser\u00e1 usado para realizar las peticiones y obtener las respuestas, por lo que crearemos un objeto de dicha clase sobre el que trabajaremos:</p> <pre><code>final OkHttpClient okHttpClient = new OkHttpClient();\n</code></pre> <p>Si queremos personalizar el cliente HTTP a la hora de construirlo usaremos el patr\u00f3n de dise\u00f1o builder a trav\u00e9s de la clase <code>OkHttpClient.Builder</code>:</p> <pre><code>final OkHttpClient okHttpClient = new OkHttpClient.Builder()\n    .addInterceptor(new HttpLoggingInterceptor())\n    .cache(new Cache(cacheDir, cacheSize))\n    .connectTimeout(500, TimeUnit.MILLISECONDS)\n    .readTimeout(500, TimeUnit.MILLISECONDS)\n    .build();\n</code></pre> <p>Lo normal es que se cree un \u00fanico objeto cliente OkHttpClient (patr\u00f3n singleton), que ser\u00e1 usado para realizar todas las peticiones.</p> <p>Para representar una petici\u00f3n, la librer\u00eda nos ofrece la clase <code>Request</code>, que construiremos a trav\u00e9s de un objeto constructor de la clase <code>Request.Builder</code>, que proporciona, entre otros, los siguientes m\u00e9todos de configuraci\u00f3n de la petici\u00f3n:</p> <ul> <li><code>url(url)</code>: URL destinataria de la petici\u00f3n.</li> <li><code>header(sNombre, sValor)</code>: A\u00f1ade un elemento de cabecera, sustituyendo su valor si ya exist\u00eda en la petici\u00f3n un elemento de cabecera con el mismo nombre.</li> <li><code>addHeader(sNombre, sValor)</code>: A\u00f1ade un elemento de cabecera, incluso si ya exist\u00eda otro elemento con el mismo nombre.</li> <li>M\u00e9todos para indicar el verbo HTTP que se desea usar: <code>get()</code>, <code>head()</code>, <code>post(requestBody)</code>, <code>put(requestBody)</code>, <code>patch(requestBody)</code>, <code>delete()</code>, <code>method(verb, requestBody)</code>. Alguno de estos m\u00e9todos establecen el cuerpo de la petici\u00f3n, representado por un objeto <code>RequestBody</code>.</li> <li><code>build()</code>: Construye, configura y retorna el objeto <code>Request</code>.</li> </ul> <p>Veamos un ejemplo sencillo:</p> <pre><code>Request request = new Request.Builder()\n      .url(\"http://publicobject.com/helloworld.txt\")\n        .build();\n</code></pre> <p>Si nuestra petici\u00f3n va a contener un cuerpo de petici\u00f3n, ser\u00e1 necesario que creemos un objeto <code>RequestBody</code> a trav\u00e9s de su m\u00e9todo est\u00e1tico <code>create()</code>. Este m\u00e9todo recibe el tipo MIME del cuerpo y el elemento a enviar, ya sea en forma de cadena de caracteres, fichero, etc. (el m\u00e9todo est\u00e1 sobrecargado para tal fin). Por ejemplo:</p> <pre><code>RequestBody requestBody = \n    RequestBody.create(jsonPost, MediaType.get(\"application/json; charset=utf-8\"));\nRequest request = new Request.Builder()\n        .url(new URL(\"https://jsonplaceholder.typicode.com/posts\"))\n        .post(requestBody)\n        .build();\n</code></pre> <p>Si el cuerpo de la petici\u00f3n debe ser enviado en forma de pares <code>variable=valor</code> codificados en la URL, para construir el <code>RequestBody</code> haremos uso de la clase <code>FormBody.Builder</code>, y usaremos sus m\u00e9todos <code>add(variable, valor)</code> o <code>addEncoded(variable, valor)</code> para a\u00f1adir cada uno de los pares, para finalmente llamar al m\u00e9todo <code>build()</code> para obtener el objeto <code>RequestBody</code>. Por ejemplo:</p> <pre><code>SimpleDateFormat formatter = new SimpleDateFormat(\"dd/MM/yyyy HH:mm:ss\",\n                Locale.getDefault());\nURL url = new URL(\"http://www.informaticasaladillo.es/echo.php\");\nRequestBody formBody = new FormBody.Builder()\n        .addEncoded(\"nombre\", \"Baldomero\")\n        .addEncoded(\"fecha\", formatter.format(new Date()))\n        .build();\nRequest request = new Request.Builder()\n        .url(url)\n        .post(formBody)\n        .build();\n</code></pre> <p>Por su parte, la clase <code>Call</code> modela la realizaci\u00f3n de una petici\u00f3n. Para obtener un objeto <code>Call</code> usaremos el m\u00e9todo <code>newCall(request)</code> del objeto <code>OkHttpClient</code>, que recibe el objeto <code>Request</code> correspondiente a la petici\u00f3n que se quiere llevar a cabo.</p> <pre><code>Call call = okHttpClient.newCall(request)\n</code></pre> <p>La clase <code>Call</code> nos proporciona dos m\u00e9todos distintos para ejecutar la petici\u00f3n, dependiendo de si lo queremos hacer de forma s\u00edncrona o as\u00edncrona.</p> <p>El m\u00e9todo <code>execute()</code> de un objeto <code>Call</code> realiza la petici\u00f3n de manera s\u00edncrona en el hilo desde el que se llame, quedando el llamador bloqueado hasta que se reciba la respuesta en forma de objeto de la clase <code>Response</code>. Debemos tener en cuenta que si se produce un error en la conexi\u00f3n, se lanzar\u00e1 una excepci\u00f3n, por lo que deberemos incluir la llamada a este m\u00e9todo dentro de un bloque <code>try catch</code>.</p> <p>Es importante recalcar que en entornos como Android, en los que no se permite por defecto operaciones de red desde el hilo principal, la llamada al m\u00e9todo <code>execute()</code> deber\u00e1 realizarse desde un hilo secundario.</p> <p>Llamada s\u00edncrona con execute()</p> <pre><code>Request request = new Request.Builder()\n    .url(new URL(\"https://jsonplaceholder.typicode.com/posts\"))\n    .get()\n    .build();\nCall call = okHttpClient.newCall(request);\n// Blocking call\ntry (Response response = call.execute()) {\n    // Process error\n    // ...\n} catch (IOException e) {\n    // Process exception\n    // ...\n}\n</code></pre> <p>Si usamos el m\u00e9todo <code>enqueue(listenerCallback)</code> del objeto <code>Call</code>, la petici\u00f3n se realiza de manera as\u00edncrona en un hilo secundario gestionado por la librer\u00eda. El m\u00e9todo recibe un objeto listener que implemente la interfaz <code>Callback</code>, cuyo m\u00e9todo <code>onResponse(call, response)</code> ser\u00e1 llamado cuando se obtenga la respuesta (objeto de la clase <code>Response</code>), que le ser\u00e1 pasada como par\u00e1metro. Si se produce un error en la petici\u00f3n, se llamada al m\u00e9todo <code>onFailure(call)</code> del objeto listener.</p> <p>Los m\u00e9todos <code>onResponse()</code> y <code>onFailure()</code> son llamados en el hilo secundario, lo que es especialmente importante si estamos en un entorno Android, en el que no es posible actualizar la interfaz de usuario desde un hilo distinto al hilo principal.</p> <pre><code>Request request = new Request.Builder()\n    .url(new URL(\"https://jsonplaceholder.typicode.com/posts\"))\n    .get()\n    .build();\nCall call = client.newCall(request);\n// Returns immediately (no value returned).\ncall.enqueue(new Callback() {\n    @Override public void onFailure(Call call, IOException e) {\n        // Process error\n        // ...\n    }\n\n    @Override public void onResponse(Call call, Response response) throws IOException {\n        // Process response\n        // ...\n    }\n});\n</code></pre> <p>Para modelar la respuesta, la librer\u00eda OkHttp proporciona la clase <code>Response</code>, que posee los m\u00e9todos necesarios para extraer la informaci\u00f3n obtenida:</p> <ul> <li><code>code()</code>: Retorna el status code HTTP contenido en la respuesta.</li> <li><code>message()</code>: Retorna el mensaje de estado HTTP contenido en la respuesta.</li> <li><code>protocol()</code>: Retorna la versi\u00f3n del protocolo HTTP usada.</li> <li><code>request()</code>: Retorna el objeto <code>Request</code> que dio lugar a esta respuesta.</li> <li><code>isSuccessful()</code>: Retorna si la respuesta ha sido satisfactoria, es decir, si el status code est\u00e1 en el rango [200-300).</li> <li><code>headers()</code>: Retorna un objeto <code>Headers</code> correspondiente a las cabeceras de la respuesta. Implementa la interfaz <code>Iterable&lt;Pair&lt;String, String&gt;&gt;</code>, por lo que podemos recorrer los pares clave-valor correspondientes a las cabeceras.</li> <li><code>body()</code>: Retorna el cuerpo de la respuesta en forma de objeto <code>ResponseBody</code>, que posee el m\u00e9todo <code>string()</code> para obtener el cuerpo de la respuesta en forma de cadena de caracteres, o el m\u00e9todo <code>bytes()</code> para obtener los bytes.</li> </ul> <p>Veamos un ejemplo completo de petici\u00f3n s\u00edncrona:</p> <p>Ejemplo completo de petici\u00f3n s\u00edncrona</p> <pre><code>Request request = new Request.Builder()\n    .url(new URL(\"https://jsonplaceholder.typicode.com/posts\"))\n    .get()\n    .build();\nCall call = okHttpClient.newCall(request);\ntry (Response response = call.execute()) {\n    System.out.print(response.code());\n    System.out.println(\" \" + response.message());\n    response.headers().forEach(\n        header -&gt; System.out.println(header.component1() + \": \" + header.component2()));\n    if (response.isSuccessful()) {\n        try (ResponseBody responseBody = response.body()) {\n            System.out.println(\"\\n\" + responseBody.string());\n        }\n    }\n} catch (IOException e) {\n    System.out.println(e.toString());\n}\n</code></pre> <p>Veamos ahora un ejemplo completo de petici\u00f3n as\u00edncrona:</p> <p>Ejemplo completo de petici\u00f3n as\u00edncrona</p> <pre><code>Request request = new Request.Builder()\n    .url(url)\n    .get()\n    .build();\nCall call = okHttpClient.newCall(request);\ncall.enqueue(new Callback() {\n    @Override\n    public void onFailure(@NotNull Call call, @NotNull IOException e) {\n        System.out.println(e.toString());\n    }\n\n    @Override\n    public void onResponse(@NotNull Call call, @NotNull Response response) {\n        if (response.isSuccessful()) {\n            try (ResponseBody responseBody = response.body()) {\n                System.out.println(\"\\n\" + responseBody.string());\n            }\n        }    \n    }\n});\n</code></pre> <p>OkHttp no trabaja directamente con <code>CompletableFuture</code>, pero podemos convertir el <code>Callback</code> en un <code>CompletableFuture</code> de una manera muy sencilla:</p> <pre><code>private CompletableFuture&lt;Response&gt; executeAsync(Call call) {\n    CompletableFuture&lt;Response&gt; cf = new CompletableFuture&lt;&gt;();\n    call.enqueue(new Callback() {\n        @Override\n        public void onFailure(@NotNull Call call, @NotNull IOException e) {\n            cf.completeExceptionally(e);\n        }\n\n        @Override\n        public void onResponse(@NotNull Call call, @NotNull Response response) {\n            cf.complete(response);\n        }\n    });\n    return cf;\n}\n</code></pre> <p>Internamente, nuestro cliente OkHttp usa para ejecutar las peticiones as\u00edncronas un <code>ThreadPoolExecutor</code> cacheado, sin n\u00famero m\u00ednimo de hilos, ni m\u00e1ximo, y donde los hilos se mantienen inactivos durante 60 segundos antes de ser eliminados. Aunque no es necesario, si queremos expl\u00edcitamente finalizar dicho ejecutor deberemos hacer:</p> <p>Finalizar el ejecutor usado por OkHttp</p> <pre><code>// Cierra y elimina todas las conexiones inactivas en el pool.\nokHttpClient.connectionPool().evictAll();\n// Termina el ejecutor.\nokHttpClient.dispatcher().executorService().shutdownNow();\n</code></pre>"},{"location":"bloque_v/tema_30/page-8/#proyecto-okhttp","title":"Proyecto OkHttp","text":"<p>En este proyecto vamos a realizar una aplicaci\u00f3n que realiza distintos tipos de peticiones HTTP a un servicio REST de ejemplo, usando la librer\u00eda OkHttp. Cada petici\u00f3n y su correspondiente respuesta son mostradas por consola.</p> <p>Para encapsular las distintas peticiones a la Web API REST, creamos una clase <code>ApiService</code> con los m\u00e9todos para realizar las distintas peticiones. el constructor de esta clase recibe un objeto <code>OkHttpClient</code> a trav\u00e9s del que realizar las peticiones.</p> <p>Nuestro main construye el objeto <code>OkHttpClient</code> y el objeto <code>ApiService</code>, con el que interact\u00faa para realizar las peticiones.</p> MainApiService <pre><code>import okhttp3.*;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.io.IOException;\nimport java.util.Scanner;\nimport java.util.concurrent.TimeUnit;\n\n@SuppressWarnings(\"SameParameterValue\")\npublic class Main {\n\n    public static void main(String[] args) {\n        new Main();\n    }\n\n    // 1. Create Http client.\n    private final OkHttpClient okHttpClient = new OkHttpClient().newBuilder()\n            // 1.1. Request timeouts.\n            .connectTimeout(5000, TimeUnit.MILLISECONDS)\n            .readTimeout(5000, TimeUnit.MILLISECONDS)\n            .build();\n    private final ApiService apiService = new ApiService(okHttpClient);\n    private final Scanner scanner = new Scanner(System.in);\n\n    Main() {\n        int selectedOption = showMenu();\n        processOption(selectedOption);\n        okHttpClient.connectionPool().evictAll();\n        okHttpClient.dispatcher().executorService().shutdownNow();\n    }\n\n    private int showMenu() {\n        System.out.println(\"\\nMENU\");\n        System.out.println(\"1. Show all posts synchronously\");\n        System.out.println(\"2. Show all posts with callback\");\n        System.out.println(\"3. Show all posts\");\n        System.out.println(\"4. Show post\");\n        System.out.println(\"5. Show user's posts\");\n        System.out.println(\"6. Create post\");\n        System.out.println(\"7. Update post\");\n        System.out.println(\"8. Update post partially\");\n        System.out.println(\"9. Delete post\");\n        System.out.println(\"10. Show only headers\");\n        System.out.println(\"11. Show access options\");\n        System.out.print(\"Select an option: \");\n        try {\n            return scanner.nextInt();\n        } catch (Exception e) {\n            scanner.nextLine();\n            return 0;\n        }\n    }\n\n    private static void showResponse(Response response) {\n        // 4.1. Response code.\n        System.out.print(response.code());\n        // 4.2. Response message.\n        System.out.println(\" \" + response.message());\n        // 4.2. Response headers.\n        response.headers().forEach(header -&gt; System.out.println(header.component1() + \": \" + header.component2()));\n        if (response.isSuccessful()) {\n            // 4.3 Response body\n            try {\n                ResponseBody responseBody = response.body();\n                if (responseBody != null) {\n                    System.out.println(\"\\n\" + responseBody.string());\n                }\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    private void processOption(int selectedOption) {\n        switch (selectedOption) {\n            case 1:\n                showPostsSync();\n                break;\n            case 2:\n                showPostsWithCallback();\n                break;\n            case 3:\n                showPosts();\n                break;\n            case 4:\n                showPost(1);\n                break;\n            case 5:\n                showUserPosts(1);\n                break;\n            case 6:\n                createPost(\"{\\\"title\\\": \\\"Baldomero\\\", \\\"body\\\": \\\"Llegate Ligero\\\", \\\"userId\\\": 1}\");\n                break;\n            case 7:\n                updatePost(1, \"{\\\"id\\\": 1, \\\"title\\\": \\\"Baldomero\\\", \\\"body\\\": \\\"Llegate Ligero\\\", \\\"userId\\\": 1}\");\n                break;\n            case 8:\n                patchPost(1, \"{\\\"title\\\": \\\"Baldomero\\\"}\");\n                break;\n            case 9:\n                deletePost(1);\n                break;\n            case 10:\n                showPostsHeaders();\n                break;\n            case 11:\n                showPostsAccessOptions();\n                break;\n        }\n    }\n\n    private void showPostsSync() {\n        try {\n            Response response = apiService.getPostsSync();\n            showResponse(response);\n        } catch (IOException e) {\n            showError(e);\n        }\n    }\n\n    private void showPostsWithCallback() {\n        apiService.getPostsWithCallback(new Callback() {\n            @Override\n            public void onFailure(@NotNull Call call, @NotNull IOException e) {\n                showError(e);\n            }\n\n            @Override\n            public void onResponse(@NotNull Call call, @NotNull Response response) {\n                showResponse(response);\n            }\n        });\n    }\n\n    private void showPosts() {\n        apiService.getPosts().whenComplete(this::showResponseOrError).join();\n    }\n\n    private void showPostsAccessOptions() {\n        apiService.getPostsAccessOptions().whenComplete(this::showResponseOrError).join();\n    }\n\n    private void showPostsHeaders() {\n        apiService.getPostsHeaders().whenComplete(this::showResponseOrError).join();\n    }\n\n    private void showPost(int postId) {\n        apiService.getPost(postId).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void createPost(String jsonPost) {\n        apiService.createPost(jsonPost).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void updatePost(int postId, String jsonPost) {\n        apiService.updatePost(postId, jsonPost).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void patchPost(int postId, String jsonPost) {\n        apiService.patchPost(postId, jsonPost).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void deletePost(int postId) {\n        apiService.deletePost(postId).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void showUserPosts(int userId) {\n        apiService.getUserPosts(userId).whenComplete(this::showResponseOrError).join();\n    }\n\n    // ---------------------------------------------------------\n\n    private void showResponseOrError(Response response, Throwable throwable) {\n        if (throwable != null) {\n            showError(throwable);\n        } else {\n            showResponse(response);\n        }\n    }\n\n    private void showError(Throwable e) {\n        System.out.println(e.toString());\n    }\n\n}\n</code></pre> <pre><code>import okhttp3.*;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.io.IOException;\nimport java.util.concurrent.CompletableFuture;\n\npublic class ApiService {\n\n    private final String BASE_URL = \"https://jsonplaceholder.typicode.com/\";\n    private final OkHttpClient okHttpClient;\n\n    public ApiService(OkHttpClient okHttpClient) {\n        this.okHttpClient = okHttpClient;\n    }\n\n    public Response getPostsSync() throws IOException {\n        // 2. Create http request.\n        Request request = new Request.Builder()\n                // 2.1. URL\n                .url(BASE_URL + \"posts\")\n                // 2.2. Request method.\n                .get()\n                .build();\n        // 3. Create a new Call with that request.\n        Call call = okHttpClient.newCall(request);\n        // 4. Execute call and obtain a response (blocking)\n        return call.execute();\n    }\n\n    public void getPostsWithCallback(Callback callback) {\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"posts\")\n                .get()\n                .build();\n        Call call = okHttpClient.newCall(request);\n        call.enqueue(callback);\n    }\n\n    public CompletableFuture&lt;Response&gt; getPosts() {\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"posts\")\n                .get()\n                .build();\n        Call call = okHttpClient.newCall(request);\n        return executeAsync(call);\n    }\n\n    public CompletableFuture&lt;Response&gt; getPostsAccessOptions() {\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"posts\")\n                .method(\"OPTIONS\", null)\n                .build();\n        Call call = okHttpClient.newCall(request);\n        return executeAsync(call);\n    }\n\n    public CompletableFuture&lt;Response&gt; getPostsHeaders() {\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"posts\")\n                .head()\n                .build();\n        Call call = okHttpClient.newCall(request);\n        return executeAsync(call);\n    }\n\n    public CompletableFuture&lt;Response&gt; getPost(int postId) {\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"posts/\" + postId)\n                .get()\n                .build();\n        Call call = okHttpClient.newCall(request);\n        return executeAsync(call);\n    }\n\n    public CompletableFuture&lt;Response&gt; createPost(String jsonPost) {\n        RequestBody requestBody = RequestBody.create(jsonPost, MediaType.get(\"application/json; charset=utf-8\"));\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"posts\")\n                .post(requestBody)\n                .build();\n        Call call = okHttpClient.newCall(request);\n        return executeAsync(call);\n    }\n\n    public CompletableFuture&lt;Response&gt; updatePost(int postId, String jsonPost) {\n        RequestBody requestBody = RequestBody.create(jsonPost, MediaType.get(\"application/json; charset=utf-8\"));\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"posts/\" + postId)\n                .put(requestBody)\n                .build();\n        Call call = okHttpClient.newCall(request);\n        return executeAsync(call);\n    }\n\n    public CompletableFuture&lt;Response&gt; patchPost(int postId, String jsonPost) {\n        RequestBody requestBody = RequestBody.create(jsonPost, MediaType.get(\"application/json; charset=utf-8\"));\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"posts/\" + postId)\n                .post(requestBody)\n                .addHeader(\"X-HTTP-Method-Override\", \"PATCH\")\n                .build();\n        Call call = okHttpClient.newCall(request);\n        return executeAsync(call);\n    }\n\n    public CompletableFuture&lt;Response&gt; deletePost(int postId) {\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"posts/\" + postId)\n                .delete()\n                .build();\n        Call call = okHttpClient.newCall(request);\n        return executeAsync(call);\n    }\n\n    public CompletableFuture&lt;Response&gt; getUserPosts(int userId) {\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"users/\" + userId + \"/posts\")\n                .get()\n                .build();\n        Call call = okHttpClient.newCall(request);\n        return executeAsync(call);\n    }\n\n    // ---------------------------------------------------------\n\n    private CompletableFuture&lt;Response&gt; executeAsync(Call call) {\n        CompletableFuture&lt;Response&gt; cf = new CompletableFuture&lt;&gt;();\n        call.enqueue(new Callback() {\n            @Override\n            public void onFailure(@NotNull Call call, @NotNull IOException e) {\n                cf.completeExceptionally(e);\n            }\n\n            @Override\n            public void onResponse(@NotNull Call call, @NotNull Response response) {\n                cf.complete(response);\n            }\n        });\n        return cf;\n    }\n\n}\n</code></pre>"},{"location":"bloque_v/tema_30/page-9/","title":"9 HttpClient","text":""},{"location":"bloque_v/tema_30/page-9/#httpclient","title":"HttpClient","text":"<p>Java 11 introdujo una nueva API para la creaci\u00f3n de clientes HTTP compatibles con HTTP/2. Adem\u00e1s, y a diferencia de la clase <code>HttpURLConnection</code>, el nuevo cliente HTTP nos proporciona mecanismos para realizar y gestionar peticiones as\u00edncronas.</p> <p>La nueva API contiene tres clases principales:</p> <ul> <li><code>HttpClient</code>: Se comporta como un contenedor para la configuraci\u00f3n com\u00fan de m\u00faltiples peticiones HTTP.</li> <li><code>HttpRequest</code>: Representa la petici\u00f3n que se env\u00eda a trav\u00e9s de un objeto <code>HttpClient</code>.</li> <li><code>HttpResponse</code>: Representa la respuesta de una petici\u00f3n <code>HttpRequest</code> realizada.</li> </ul> <p>Para poder enviar una petici\u00f3n antes debemos construir un objeto <code>HttpClient</code>. Dicha construcci\u00f3n sigue el patr\u00f3n de dise\u00f1o builder. As\u00ed, deberemos obtener un objeto de la interface <code>HttpClient.Builder</code>, a trav\u00e9s del m\u00e9todo est\u00e1tico <code>HttpClient.newBuilder()</code>, configurarlo usando los m\u00e9todos de <code>HttpClient.Builder</code> y finalmente llamar a su m\u00e9todo <code>build()</code> para obtener el objeto <code>HttpClient</code>.</p> <pre><code>HttpClient httpClient = HttpClient.newBuilder()\n        .connectTimeout(Duration.ofSeconds(30))\n        .executor(Executors.newFixedThreadPool(2))\n        .version(HttpClient.Version.HTTP_2)\n        .authenticator(new Authenticator() {\n            @Override\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(\"user\", \"password\".toCharArray());\n            }\n        })\n        .build();\n</code></pre> <p>Si queremos usar todos los valores por defecto, entonces bastar\u00e1 con hacer:</p> <pre><code>HttpClient httpClient = HttpClient.newBuilder().build();\n</code></pre> <p>En ese caso, es m\u00e1s c\u00f3modo usar el m\u00e9todo est\u00e1tico <code>HttpClient.newHttpClient()</code>, que es equivalente.</p> <pre><code>HttpClient httpClient = HttpClient.newHttpClient();\n</code></pre> <p>Una vez creado, el objeto <code>HttpClient</code> es inmutable, por lo que es thread-safe y podemos enviarle varias peticiones HTTP.</p> <p>Por defecto, el cliente HTTP al realizar una petici\u00f3n tratar\u00e1 de abrir una conexi\u00f3n HTTP/2. Si el servidor responde con HTTP/1.1, el cliente autom\u00e1ticamente pasa a usar dicha versi\u00f3n. Si ya sabemos que el servidor s\u00f3lo permite HTTP/1.1, podemos indicar que queremos usar dicha versi\u00f3n durante la construcci\u00f3n del cliente, a trav\u00e9s del m\u00e9todo <code>version(Version.HTTP_1_1)</code> del objeto <code>HttpClient.Builder</code>.</p> <p>Con el m\u00e9todo <code>connectTimeout(duration)</code> del objeto <code>HttpClient.Builder</code> podemos establecer cu\u00e1nto tiempo debe esperar el cliente la respuesta del servidor al establecer una conexi\u00f3n. Si no es posible establecerla se lanzar\u00e1 la excepci\u00f3n <code>HttpConnectTimeoutException</code>.</p> <p>El m\u00e9todo <code>executor(executor)</code> del objeto <code>HttpClient.Builder</code> permite establecer qu\u00e9 ejecutor debe usarse para las peticiones as\u00edncronas y tareas dependientes. Si no lo especificamos se crear\u00e1 un nuevo <code>ThreadPoolExecutor</code>.</p> <p>Mediante el m\u00e9todo <code>authenticator(authenticator)</code> podemos establecer el autentificador que se desea usar con las peticiones.</p> <p>Para crear una petici\u00f3n tambi\u00e9n seguiremos el patr\u00f3n de dise\u00f1o builder. As\u00ed, llamaremos al m\u00e9todo est\u00e1tico <code>HttpRequest.newBuilder()</code>, que retorna un objeto de la interfaz <code>HttpRequest.Builder</code>. Despu\u00e9s llamaremos a sus m\u00e9todos para configurar la petici\u00f3n. Finalmente, llamaremos al m\u00e9todo <code>build()</code> para construir la petici\u00f3n, retornando un objeto de la clase <code>HttpRequest</code>.</p> <pre><code>HttpRequest httpRequest = HttpRequest.newBuilder()\n        .GET()\n        .uri(URI.create(\"https://httpbin.org/get\"))\n        .setHeader(\"User-Agent\", \"Java 11 HttpClient Bot\")\n        .build();\n</code></pre> <p>Para especificar la URI a la que queremos realizar la petici\u00f3n tenemos dos opciones: pas\u00e1rsela al m\u00e9todo <code>HttpRequest.newBuilder(uri)</code>, o, como hemos hecho en el ejemplo anterior, establecerla mediante el m\u00e9todo <code>uri(uri)</code> del objeto <code>HttpRequest.Builder</code>.</p> <p>El m\u00e9todo <code>setHeader(keyString, valueString)</code> nos permite establecer una cabecera para la petici\u00f3n, sobrescribi\u00e9ndola si ya existiera.</p> <p>Para indicar el m\u00e9todo (verbo) HTTP que queremos usar en nuestra petici\u00f3n, usaremos alguno de los m\u00e9todos disponibles en <code>HttpRequest.Builder</code>, como <code>GET()</code>, <code>POST(bodyPublisher)</code>, <code>PUT(bodyPublisher)</code>y <code>DELETE()</code>, o usar el m\u00e9todo gen\u00e9rico <code>method(methodString, bodyPublisher)</code>.</p> <p>Como vemos, en los m\u00e9todos <code>POST(bodyPublisher)</code> y <code>PUT(bodyPublisher)</code> debemos indicar cu\u00e1l va a ser el cuerpo de la petici\u00f3n, representado por la interfaz <code>HttpRequest.BodyPublisher</code>. La clase de utilidad <code>BodyPublishers</code> proporciona una serie de m\u00e9todos est\u00e1ticos factor\u00eda para crear objetos <code>HttpRequest.BodyPublisher</code> a partir de valores de las fuentes de contenido m\u00e1s usuales:</p> <ul> <li><code>HttpRequest.BodyPublishers.ofString(bodyString)</code>: Retorna un cuerpo de petici\u00f3n creado a partir de una cadena de caracteres.</li> <li><code>HttpRequest.BodyPublishers.ofInputStream(streamSupplier)</code>: Retorna un cuerpo de petici\u00f3n creado a partir del contenido del un <code>InputStream</code>.</li> <li><code>HttpRequest.BodyPublishers.ofByteArray(byteArray)</code>: Retorna un cuerpo de petici\u00f3n creado a partir del contenido del un <code>byte[]</code>.</li> <li><code>HttpRequest.BodyPublishers.ofFile(path)</code>: Retorna un cuerpo de petici\u00f3n creado a partir del contenido del un fichero.</li> <li><code>HttpRequest.BodyPublishers.noBody()</code>: Retorna un cuerpo de petici\u00f3n vac\u00edo.</li> </ul> <p>Por ejemplo:</p> <pre><code>String json = new StringBuilder()\n                .append(\"{\")\n                .append(\"\\\"name\\\":\\\"mkyong\\\",\")\n                .append(\"\\\"notes\\\":\\\"hello\\\"\")\n                .append(\"}\").toString();\nHttpRequest httpRequest = HttpRequest.newBuilder()\n        .uri(new URI(\"https://postman-echo.com/post\"))\n        .setHeader(\"User-Agent\", \"Java 11 HttpClient Bot\")\n        .POST(HttpRequest.BodyPublishers.ofString(json))\n        .header(\"Content-Type\", \"application/json\")\n        .build();\n</code></pre> <p>La API no nos proporciona un m\u00e9todo est\u00e1tico factor\u00eda para cuando el cuerpo debe corresponder a los datos de un formulario, pero podemos crearlo nosotros:</p> <pre><code>public static HttpRequest.BodyPublisher ofFormData(Map&lt;Object, Object&gt; data) {\n    var stringBuilder = new StringBuilder();\n    for (Map.Entry&lt;Object, Object&gt; entry : data.entrySet()) {\n        if (builder.length() &gt; 0) {\n            builder.append(\"&amp;\");\n        }\n        builder.append(URLEncoder.encode(entry.getKey().toString(),\n                                        StandardCharsets.UTF_8));\n        builder.append(\"=\");\n        builder.append(URLEncoder.encode(entry.getValue().toString(), \n                                        StandardCharsets.UTF_8));\n    }\n    return HttpRequest.BodyPublishers.ofString(builder.toString());\n}\n</code></pre> <p>Y podemos usar dicho m\u00e9todo de la siguiente manera:</p> <pre><code>Map&lt;Object, Object&gt; data = Map.of(\n    \"username\", \"abc\",\n    \"password\", \"123\",\n    \"custom\", \"secret\",\n    \"ts\", System.currentTimeMilis());\nHttpRequest httpRequest = HttpRequest.newBuilder()\n    .POST(ofFormData(data))\n    .uri(URI.create(\"https://httpbin.org/post\"))\n    .setHeader(\"User-Agent\", \"Java 11 HttpClient Bot\")\n    .header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    .build();\n</code></pre> <p><code>HttpResponse</code> es una interfaz cuyas implementaciones son retornadas por un objeto <code>HttpClient</code> cuando se env\u00eda una petici\u00f3n <code>HttpRequest</code>.</p> <p>Los m\u00e9todos m\u00e1s importantes de esta interfaz son:</p> <ul> <li><code>statusCode()</code>: Retorna un entero con el c\u00f3digo de estado de la respuesta.</li> <li><code>body()</code>: Retorna el cuerpo de la respuesta pareado a un determinado tipo.</li> <li><code>headers()</code>: Retorna un objeto <code>HttpHeaders</code> con las cabeceras de la respuesta. Dicho objeto posee un m\u00e9todo <code>map()</code> que retorna un <code>Map&lt;String, List&lt;String&gt;&gt;</code> con las cabeceras.</li> <li><code>request()</code>: Retorna el objeto <code>HttpRequest</code> correspondiente a la petici\u00f3n por la que se ha obtenido esta repuesta.</li> <li><code>uri()</code>: Retorna la URI desde la que se ha obtenido la respuesta.</li> </ul> <p>Podemos enviar una petici\u00f3n <code>HttpRequest</code> a trav\u00e9s de un cliente <code>HttpClient</code> de dos maneras distintas: as\u00edncronamente y as\u00edncronamente.</p> <p>Para realizar una petici\u00f3n as\u00edncrona deberemos usar el m\u00e9todo <code>send(httpRequest, bodyHandler)</code> del objeto <code>HttpClient</code>, al que suministraremos adem\u00e1s del objeto <code>HttpRequest</code>, un objeto que implemente la interfaz <code>HttpResponse.BodyHandler&lt;T&gt;</code> cuyo cometido ser\u00e1 manejar el cuerpo de la respuesta hacia un destino de tipo <code>T</code>.</p> <p>La clase de utilidad <code>HttpResponse.BodyHandlers</code> proporciona m\u00e9todos est\u00e1ticos factor\u00eda para construir manejadores del cuerpo de la respuesta hacia los destinos m\u00e1s habituales:</p> <ul> <li><code>HttpResponse.BodyHandlers.ofString(bodyString)</code>: Retorna un manejador del cuerpo de la respuesta hacia una cadena de caracteres.</li> <li><code>HttpResponse.BodyHandlers.ofInputStream(streamSupplier)</code>: Retorna un manejador del cuerpo de la respuesta hacia un <code>InputStream</code>.</li> <li><code>HttpResponse.BodyHandlers.ofByteArray(byteArray)</code>: Retorna un manejador del cuerpo de la respuesta hacia un <code>byte[]</code>.</li> <li><code>HttpResponse.BodyHandlers.ofFile(path)</code>: Retorna un manejador del cuerpo de la respuesta hacia un fichero.</li> <li><code>HttpResponse.BodyHandlers.ofLines()</code>: Retorna un manejador del cuerpo de la respuesta hacia un <code>Stream&lt;String&gt;</code>.</li> <li><code>HttpResponse.BodyHandlers.discarding()</code>: Retorna un manejador del cuerpo de la respuesta que descarta su contenido.</li> </ul> <p>Por ejemplo:</p> <pre><code>HttpClient httpClient = HttpClient.newHttpClient();\nHttpRequest httpRequest = HttpRequest.newBuilder()\n    .GET()\n    .uri(URI.create(\"https://httpbin.org/get\"))\n    .build();\nHttpResponse&lt;String&gt; httpResponse = \n    httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());\nif (httpResponse.statusCode() == 200) {\n    String responseBody = httpResponse.body();\n    System.out.print(responseBody);\n}\n</code></pre> <p>Si queremos enviar la petici\u00f3n de manera as\u00edncrona, de forma que el hilo que env\u00eda la petici\u00f3n no quede bloqueado, podemos usar el m\u00e9todo <code>sendAsync(httpRequest, bodyHandler)</code>, que retorna inmediatamente un objeto <code>CompletableFuture</code>, que es marcado como completado cuando la respuesta <code>HttpResponse</code> est\u00e9 disponible.</p> <p>La petici\u00f3n se ejecutar\u00e1 en el ejecutor que hayamos configurado en el objeto <code>HttpClient</code>, o en el ejecutor por defecto si es que no lo hemos configurado.</p> <pre><code>HttpClient httpClient = HttpClient.newHttpClient();\nHttpRequest httpRequest = HttpRequest.newBuilder()\n    .GET()\n    .uri(URI.create(\"https://httpbin.org/get\"))\n    .build();\nCompletableFuture&lt;HttpResponse&lt;String&gt;&gt; cfHttpResponse = \n    httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString());\ncfHttpResponse\n        .thenApply(response -&gt; {\n            System.out.println(response.statusCode());\n            return response;\n        })\n        .thenApply(HttpResponse::body)\n        .thenAccept(System.out::println)\n</code></pre>"},{"location":"bloque_v/tema_30/page-9/#proyecto-httpclient","title":"Proyecto HttpClient","text":"<p>En este proyecto vamos a realizar una aplicaci\u00f3n que realiza distintos tipos de peticiones HTTP a un servicio REST de ejemplo, usando el cliente Http disponible desde la versi\u00f3n 11 de Java. Cada petici\u00f3n y su correspondiente respuesta son mostradas por consola.</p> <p>Para encapsular las distintas peticiones a la Web API REST, creamos una clase <code>ApiService</code> con los m\u00e9todos para realizar las distintas peticiones. el constructor de esta clase recibe un objeto <code>HttpClient</code> a trav\u00e9s del que realizar las peticiones.</p> <p>Nuestro main construye el objeto <code>HttpClient</code> y el objeto <code>ApiService</code>, con el que interact\u00faa para realizar las peticiones.</p> MainApiService <pre><code>import java.io.IOException;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.Scanner;\n\n@SuppressWarnings(\"SameParameterValue\")\npublic class Main {\n\n    private final HttpClient httpClient = HttpClient.newBuilder()\n            .connectTimeout(Duration.ofSeconds(5))\n            .build();\n    private final ApiService apiService = new ApiService(httpClient);\n    private final Scanner scanner = new Scanner(System.in);\n\n    Main() {\n        int selectedOption = showMenu();\n        processOption(selectedOption);\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n\n    private int showMenu() {\n        System.out.println(\"\\nMENU\");\n        System.out.println(\"1. Show all posts synchronously\");\n        System.out.println(\"2. Show all posts\");\n        System.out.println(\"3. Show post\");\n        System.out.println(\"4. Show user's posts\");\n        System.out.println(\"5. Create post\");\n        System.out.println(\"6. Update post\");\n        System.out.println(\"7. Update post partially\");\n        System.out.println(\"8. Delete post\");\n        System.out.println(\"9. Show only headers\");\n        System.out.println(\"10. Show access options\");\n        System.out.print(\"Select an option: \");\n        try {\n            return scanner.nextInt();\n        } catch (Exception e) {\n            scanner.nextLine();\n            return 0;\n        }\n    }\n\n    private void processOption(int selectedOption) {\n        switch (selectedOption) {\n            case 1:\n                showPostsSync();\n                break;\n            case 2:\n                showPosts();\n                break;\n            case 3:\n                showPost(1);\n                break;\n            case 4:\n                showUserPosts(1);\n                break;\n            case 5:\n                createPost(\"{\\\"title\\\": \\\"Baldomero\\\", \\\"body\\\": \\\"Llegate Ligero\\\", \\\"userId\\\": 1}\");\n                break;\n            case 6:\n                updatePost(1, \"{\\\"id\\\": 1, \\\"title\\\": \\\"Baldomero\\\", \\\"body\\\": \\\"Llegate Ligero\\\", \\\"userId\\\": 1}\");\n                break;\n            case 7:\n                patchPost(1, \"{\\\"title\\\": \\\"Baldomero\\\"}\");\n                break;\n            case 8:\n                deletePost(1);\n                break;\n            case 9:\n                showPostsHeaders();\n                break;\n            case 10:\n                showPostsAccessOptions();\n                break;\n        }\n    }\n\n    private void showPostsSync() {\n        try {\n            HttpResponse&lt;String&gt; httpResponse = apiService.getPostsSync();\n            showResponse(httpResponse);\n        } catch (InterruptedException | IOException e) {\n            showError(e);\n        }\n    }\n\n    private void showPosts() {\n        apiService.getPosts().whenComplete(this::showResponseOrError).join();\n    }\n\n    private void showPostsHeaders() {\n        apiService.getPostsHeaders().whenComplete(this::showResponseOrError).join();\n    }\n\n    private void showPostsAccessOptions() {\n        apiService.getPostsAccessOptions().whenComplete(this::showResponseOrError).join();\n    }\n\n    private void showPost(int postId) {\n        apiService.getPost(postId).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void createPost(String jsonPost) {\n        apiService.createPost(jsonPost).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void updatePost(int postId, String jsonPost) {\n        apiService.updatePost(postId, jsonPost).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void patchPost(int postId, String jsonPost) {\n        apiService.patchPost(postId, jsonPost).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void deletePost(int postId) {\n        apiService.deletePost(postId).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void showUserPosts(int userId) {\n        apiService.getUserPosts(userId).whenComplete(this::showResponseOrError).join();\n    }\n\n    private void showResponseOrError(HttpResponse&lt;String&gt; httpResponse, Throwable throwable) {\n        if (throwable != null) {\n            showError(throwable);\n        } else {\n            showResponse(httpResponse);\n        }\n    }\n\n    private void showError(Throwable e) {\n        System.out.println(e.toString());\n    }\n\n    private void showResponse(HttpResponse&lt;String&gt; response) {\n        System.out.println(response.statusCode());\n        response.headers().map().forEach((key, value) -&gt; System.out.println(key + \": \" + String.join(\";\", value)));\n        if (response.statusCode() &gt;= 200 &amp;&amp; response.statusCode() &lt; 300) {\n            String responseBody = response.body();\n            if (responseBody != null) {\n                System.out.println(\"\\n\" + responseBody);\n            }\n        }\n    }\n\n}\n</code></pre> <pre><code>import java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\n\npublic class ApiService {\n\n    private final String BASE_URL = \"https://jsonplaceholder.typicode.com/\";\n    private final HttpClient httpClient;\n\n    public ApiService(HttpClient httpClient) {\n        this.httpClient = httpClient;\n    }\n\n    public HttpResponse&lt;String&gt; getPostsSync() throws IOException, InterruptedException {\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .GET()\n                .uri(URI.create(BASE_URL + \"posts\"))\n                .build();\n        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();\n        return httpClient.send(httpRequest, bodyHandler);\n    }\n\n    public CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; getPosts() {\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .GET()\n                .uri(URI.create(BASE_URL + \"posts\"))\n                .build();\n        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();\n        return httpClient.sendAsync(httpRequest, bodyHandler);\n    }\n\n    public CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; getPostsHeaders() {\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .method(\"HEAD\", HttpRequest.BodyPublishers.noBody())\n                .uri(URI.create(BASE_URL + \"posts\"))\n                .build();\n        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();\n        return httpClient.sendAsync(httpRequest, bodyHandler);\n    }\n\n    public CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; getPostsAccessOptions() {\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .method(\"OPTIONS\", HttpRequest.BodyPublishers.noBody())\n                .uri(URI.create(BASE_URL + \"posts\"))\n                .build();\n        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();\n        return httpClient.sendAsync(httpRequest, bodyHandler);\n    }\n\n    public CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; getPost(int postId) {\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .GET()\n                .uri(URI.create(BASE_URL + \"posts/\" + postId))\n                .build();\n        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();\n        return httpClient.sendAsync(httpRequest, bodyHandler);\n    }\n\n    public CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; createPost(String jsonPost) {\n        HttpRequest.BodyPublisher bodyPublisher = HttpRequest.BodyPublishers.ofString(jsonPost);\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .POST(bodyPublisher)\n                .uri(URI.create(BASE_URL + \"posts\"))\n                .header(\"Content-Type\", \"application/json; charset=utf-8\")\n                .build();\n        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();\n        return httpClient.sendAsync(httpRequest, bodyHandler);\n    }\n\n    public CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; updatePost(int postId, String jsonPost) {\n        HttpRequest.BodyPublisher bodyPublisher = HttpRequest.BodyPublishers.ofString(jsonPost);\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .PUT(bodyPublisher)\n                .uri(URI.create(BASE_URL + \"posts/\" + postId))\n                .header(\"Content-Type\", \"application/json; charset=utf-8\")\n                .build();\n        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();\n        return httpClient.sendAsync(httpRequest, bodyHandler);\n    }\n\n    public CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; patchPost(int postId, String jsonPost) {\n        HttpRequest.BodyPublisher bodyPublisher = HttpRequest.BodyPublishers.ofString(jsonPost);\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .method(\"PATCH\", bodyPublisher)\n                .uri(URI.create(BASE_URL + \"posts/\" + postId))\n                .header(\"Content-Type\", \"application/json; charset=utf-8\")\n                .build();\n        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();\n        return httpClient.sendAsync(httpRequest, bodyHandler);\n    }\n\n    public CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; deletePost(int postId) {\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .DELETE()\n                .uri(URI.create(BASE_URL + \"posts/\" + postId))\n                .build();\n        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();\n        return httpClient.sendAsync(httpRequest, bodyHandler);\n    }\n\n    public CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; getUserPosts(int userId) {\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .GET()\n                .uri(URI.create(BASE_URL + \"users/\" + userId + \"/posts\"))\n                .build();\n        HttpResponse.BodyHandler&lt;String&gt; bodyHandler = HttpResponse.BodyHandlers.ofString();\n        return httpClient.sendAsync(httpRequest, bodyHandler);\n    }\n\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-1/","title":"1 Introducci\u00f3n a las interfaces gr\u00e1ficas","text":""},{"location":"bloque_vi/tema_31/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La interfaz de usuario es la parte de un programa que permite al usuario interactuar con el programa. Esta es una de las partes m\u00e1s importantes de un programa, por lo que debe estar bien definida y ser sencilla de usar para que el usuario pueda utilizarla obteniendo el m\u00e1ximo rendimiento.</p> <p>Existen diferentes tipos de interfaces como las l\u00edneas de comandos (usadas hasta hora) y las interfaces gr\u00e1ficas de usuario.</p> <p>La l\u00ednea de comandos es una interfaz que permite interactuar al usuario a trav\u00e9s de la l\u00ednea de comandos del sistema operativo. Este tipo de interfaz se recomienda ser usada para aquellos usuarios que tengan conocimientos de la l\u00ednea de comandas, ya que un usuario b\u00e1sico, posiblemente no sepa interactuar con \u00e9l.</p> <p>Por otro lado, las interfaces gr\u00e1ficas (Graphic User Interfaces) de usuarios son las m\u00e1s usadas en la mayor\u00eda de los programas, debido a que permite interactuar de una forma sencilla al usuario sin necesidad de conocimientos inform\u00e1ticos no b\u00e1sicos.</p>"},{"location":"bloque_vi/tema_31/page-1/#normas-de-diseno","title":"Normas de dise\u00f1o","text":"<p>Al desarrollar una interfaz gr\u00e1fica es coherente seguir ciertas reglas de dise\u00f1o que permita que la interacci\u00f3n programa-usuario sea lo m\u00e1s c\u00f3moda posible. Adem\u00e1s, tambi\u00e9n se pretende conseguir que el n\u00famero de errores cometidos por el usuario a la hora de interactuar sea el m\u00ednimo indispensable. Veamos algunas reglas b\u00e1sicas:</p> <ul> <li>Consistencia: Se debe mantener un dise\u00f1o coherente en toda la aplicaci\u00f3n. Para ello, se recomienda usar patrones de dise\u00f1os y estilos visuales.</li> <li>Simplicidad: Es recomendable que la interfaz sea lo m\u00e1s simple posible. De esta manera, el usuario puede utilizarla de forma intuitiva sin necesidad de un conocimiento previo de la misma.</li> <li>Feedback claro: Proporciona una retroalimentaci\u00f3n perceptible, es decir, utiliza mensajes de confirmaciones o errores directos y concisos, animaciones, cambios visuales, etc.</li> <li>Jerarqu\u00eda visual: Organiza los elementos de la interfaz de manera que refleje su importancia y relaci\u00f3n entre s\u00ed. Utiliza tama\u00f1o, color, contraste y espaciado para destacar los elementos m\u00e1s importantes y guiar la atenci\u00f3n del usuario.</li> <li>Facilidad de navegaci\u00f3n: Dise\u00f1a una estructura de navegaci\u00f3n clara y coherente que permita a los usuarios moverse f\u00e1cilmente por la aplicaci\u00f3n. Utiliza men\u00fas, botones de navegaci\u00f3n y elementos de control intuitivos.</li> <li>Reconocimiento en lugar de memorizaci\u00f3n: Prioriza el uso de elementos reconocibles en lugar de elementos que requieran que el usuario memorice acciones o comandos. Utiliza iconos claros y universales, y proporciona descripciones o etiquetas cuando sea necesario.</li> <li>Flexibilidad y personalizaci\u00f3n: Permite cierto grado de personalizaci\u00f3n para adaptarse a las preferencias individuales del usuario. Por ejemplo, opciones para cambiar el tama\u00f1o de la fuente, temas de color o disposici\u00f3n de la interfaz.</li> <li>Pruebas de usabilidad: Realiza pruebas de usabilidad con usuarios reales para identificar y corregir problemas en el dise\u00f1o de la interfaz. Observa c\u00f3mo interact\u00faan los usuarios con la interfaz y recopila comentarios para realizar mejoras.</li> <li>Accesibilidad: Dise\u00f1a la interfaz teniendo en cuenta la accesibilidad para usuarios con discapacidades. Utiliza est\u00e1ndares de accesibilidad web, como etiquetas alt en im\u00e1genes, contraste adecuado entre texto y fondo, y teclado accesible.</li> </ul>"},{"location":"bloque_vi/tema_31/page-1/#diseno","title":"Dise\u00f1o","text":"<p>Cuando se desea dise\u00f1ar una GUI es altamente recomendable tener claro que tipo de aplicaci\u00f3n se quiere realizar. Una vez que se sepa con exactitud el tipo de aplicaci\u00f3n a realizar se recomienda dise\u00f1ar la aplicaci\u00f3n antes de programarla. De esta forma, cuando se comience a programar se conocer\u00e1 de antemano los estilos, los componentes y las funcionalidades a usar. A este dise\u00f1o previo se le conoce como mock up.</p> <p>Una interfaz de experiencia de usuario (UX) es la parte de un sistema o aplicaci\u00f3n que permite a los usuarios interactuar con \u00e9l y realizar acciones para lograr sus objetivos. Aunque a menudo se confunde con el dise\u00f1o de la interfaz gr\u00e1fica de usuario (GUI), la UX abarca mucho m\u00e1s que solo la apariencia visual. La UX se centra en c\u00f3mo se siente y se comporta una interfaz para los usuarios, y c\u00f3mo se adapta a sus necesidades y expectativas.</p> <p>Por ello, es recomendable realizar un mock up UX de la aplicaci\u00f3n y posteriormente un mock up sobre la apariencia UI.</p> <p>Info</p> <p>Existen diferentes tipos de programas y webs que permiten realizar un dise\u00f1o UX/UI:</p> <ul> <li>Figma</li> <li>Canva</li> <li>Framer</li> <li>Pixso</li> </ul>"},{"location":"bloque_vi/tema_31/page-1/#programacion","title":"Programaci\u00f3n","text":"<p>Una vez tenido el dise\u00f1o, se puede proceder a la programaci\u00f3n de la interfaz gr\u00e1fica del usuario. Para ello, en Java existen diferentes tecnolog\u00edas como:</p> <ul> <li>Abstract Window Toolkit</li> <li>Swing</li> <li>JavaFX</li> </ul>"},{"location":"bloque_vi/tema_31/page-2/","title":"2 Introducci\u00f3n a AWT","text":""},{"location":"bloque_vi/tema_31/page-2/#awt","title":"AWT","text":"<p>Abstract Window Toolkit (AWT) es una librer\u00eda de Java para el desarrollo de interfaces gr\u00e1ficas. Fue introducida en la versi\u00f3n 1.0 de Java y se desarroll\u00f3 en tan solos dos meses, siendo la parte m\u00e1s d\u00e9bil de Java como lenguaje.</p> <p>El entorno que ofrece es demasiado simple y no se tiene en cuenta las ideas de entornos gr\u00e1ficos novedosos.</p> <p>Javasoft (desarrollador de Java antes de la adquisici\u00f3n por parte de Oracle), tras ver esta precariedad decidi\u00f3 desarrollar la Java Foundation Classes (JFC) que es una colecci\u00f3n de clases que proporcionan una sensaci\u00f3n visual m\u00e1s agradable y sean m\u00e1s f\u00e1ciles de utilizar por el programador. Dentro de este conjunto de clases encontramos:</p> <ul> <li>AWT que engloba todos los componentes del AWT que exist\u00edan en la versi\u00f3n 1.1.2.</li> <li>Java2D.</li> <li>Accesibilidad</li> <li>Swing que es la parte m\u00e1s importante y la que m\u00e1s desarrollada se encuentra.</li> </ul> <p>Las clases pertenecientes a las clases JFC son independientes de la plataformas, al igual que Java. Por lo que, si se crea una interfaz gr\u00e1fica en Windows, posiblemente al ejecutarse en otra plataforma como Linux el dise\u00f1o puede verse ligeramente modificado.</p>"},{"location":"bloque_vi/tema_31/page-2/#estructura-basica-de-awt","title":"Estructura b\u00e1sica de AWT","text":"<p>La estructura b\u00e1sica de AWT se basa en componentes y contenedores.</p> <p>Los componentes son los controles b\u00e1sicos de la interfaz, como por ejemplo, los botones, listas, cuadros de textos, etc.</p> <p>Los contenedores son componentes que contienen a otros componentes, los cuales son posicionados de forma relativa con respecto al contenedor. No se usan posiciones fijas de los componentes respecto a los contenedores, sino que est\u00e1n situadas a trav\u00e9s de una disposici\u00f3n controlada (layouts).</p> <p>Todos los contenedores y componente se encuentran dentro de un marco (frame). Un frame es un contenedor que representa una ventana que no est\u00e1 contenida en otra ventana.</p> <p> Figura 1 - Estructura AWT</p>"},{"location":"bloque_vi/tema_31/page-2/#frames","title":"Frames","text":"<p>Como hemos visto anteriormente, un Frame es una ventana top-level y se considera el primer contenedor de nuestra aplicaci\u00f3n UI. La clase <code>Frame</code> del paquete <code>java.AWT</code> representa una ventana y hereda de la clase abstracta <code>Container</code>, por lo que un <code>Frame</code> no deja de ser un contenedor. En dicha clase, podemos encontrar varios constructores que nos permite crear una ventana, entre ellos destacan:</p> <ul> <li><code>Frame()</code>: Crea una ventana con la configuraci\u00f3n por defecto.</li> <li><code>Frame(String title)</code>: Crea una ventana con el t\u00edtulo indicado.</li> </ul> <p>El Frame muestra el t\u00edtulo de la ventana que se le puede asignar tambi\u00e9n con el m\u00e9todo <code>setTitle(String title)</code>.</p> <p> Figura 2 - Frame</p> <p>Tambi\u00e9n podemos definir el tama\u00f1o de la ventana haciendo uso del m\u00e9todo <code>setSize(int width, int height)</code> indicando la anchura y la altura de la ventana.</p> <p>Una ventana, en ciertos puntos, no queremos que sea una readjustable, es decir, que el usuario no lo pueda redimensionar, para ello se usa el m\u00e9todo <code>setResizable(boolean b)</code> que permitir\u00e1 o no redimensionar el frame dependiendo del valor pasado como par\u00e1metro.</p> <p>Para visualizar la ventana, se utiliza el m\u00e9todo <code>setVisible(boolean b)</code> con el par\u00e1metro booleano a <code>true</code>. Para ocultarla se debe usar el par\u00e1metro <code>b</code>.</p> <p>Para a\u00f1adir un componente a nuestro frame se usa el m\u00e9todo <code>add(Component component)</code> de la clase <code>Frame</code>.</p>"},{"location":"bloque_vi/tema_31/page-2/#proyecto-myfirstframe","title":"Proyecto MyFirstFrame","text":"<p>En este proyecto se va a desarrollar un programa que habr\u00e1 una ventana vac\u00eda.</p> <pre><code>public class Main {\n    public void show() {\n        Frame myFirstFrame = new Frame(\"My first frame\");\n        myFirstFrame.setSize(200, 300);\n        myFirstFrame.setResizable(false);\n        myFirstFrame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new Main().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-3/","title":"3 Componentes","text":""},{"location":"bloque_vi/tema_31/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>La clase <code>Component</code> es una clase abstracta que representa a los componentes, es decir, a cada uno de los elementos de nuestro dise\u00f1o UI. Todos los componentes tienen caracter\u00edsticas comunes, como por ejemplo, la posici\u00f3n, un tama\u00f1o, que puede ser pintado y que puede provocar eventos.</p> <p>De entre los componentes, podemos destacar:</p> <ul> <li>Button</li> <li>Canvas</li> <li>Checkbox</li> <li>Choice</li> <li>Container</li> <li>Label</li> <li>List</li> <li>Scrollbar</li> <li>TextComponent</li> </ul> <p>Veremos en detalle, a cada uno de ellos.</p>"},{"location":"bloque_vi/tema_31/page-3/#metodos-comunes","title":"M\u00e9todos comunes","text":"<p>Todos los componentes citados anteriormente tienen m\u00e9todos comunes que realizan las mismas operaciones:</p> M\u00e9todo Descripci\u00f3n <code>void setBound(int x,int y, int width, int height)</code> Posiciona el componente horizontalmente (x) y verticalmente (y), y adem\u00e1s define el tama\u00f1o de ancho y alto <code>Rectangle getBounds()</code> Obtiene los l\u00edmites del componente (posici\u00f3n y tama\u00f1os) <code>void setLocation(int x, int y)</code> Posiciona el elemento horizontalmente (x) y verticalmente (y) <code>Point getLocation()</code> Obtiene la posici\u00f3n del componente <code>void setSize(int width, int height)</code> Establece el tama\u00f1o del componente <code>Dimension getSize()</code> Obtiene el tama\u00f1o del componente <code>void setVisible(boolean enabled)</code> Muestra el componente si <code>enabled</code> est\u00e1 a <code>true</code> y lo oculta si est\u00e1 a <code>false</code> <code>boolean isEnabled()</code> Comprueba si el componente es visible o no"},{"location":"bloque_vi/tema_31/page-3/#etiquetas","title":"Etiquetas","text":"<p>Las etiquetas (label) proporcionan una forma de color texto est\u00e1tico para mostrar informaci\u00f3n que no var\u00eda al usuario. La clase <code>Label</code> se encarga de este tipo de componentes.</p> <p> Figura 3 - Label</p> <pre><code>public class Labels {\n\n    public void show(){\n        Frame frame = new Frame(\"Labels\");\n\n        Label label = new Label(\"My first label\");\n        frame.add(label);\n\n        frame.setSize(200, 200);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new Labels().show();\n    }\n\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-3/#botones","title":"Botones","text":"<p>Los botones son componentes que permiten pulsaci\u00f3n sobre ellos por parte del usuario. La clase <code>Button</code> es la que se encarga de estos tipos de componentes:</p> <p> Figura 4 - Button</p> <pre><code>public class Buttons {\n\n    public void show(){\n        Frame frame = new Frame(\"Labels\");\n\n        Button button = new Button(\"My first button\");\n        frame.add(button);\n\n        frame.setSize(200, 200);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new Buttons().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-3/#selector","title":"Selector","text":"<p>El selector es componente que contiene una lista de elementos de la cual el usuario podr\u00e1 seleccionar uno. La clase <code>Choice</code> es la encargada de trabajar con este tipo de componente. Adem\u00e1s tiene un m\u00e9todo <code>addItem</code> que se utiliza para a\u00f1adir elementos a la lista.</p> <p> Figura 5 - Choice</p> <pre><code>public class Choices {\n    public void show() {\n        Frame frame = new Frame();\n        Choice choice = new Choice();\n\n        choice.addItem(\"Element 1\");\n        choice.addItem(\"Element 2\");\n        choice.addItem(\"Element 3\");\n        choice.addItem(\"Element 4\");\n\n        choice.setSize(300,100);\n        frame.add(choice);\n\n        frame.setSize(500,500);\n\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new Choices().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-3/#checkbox","title":"Checkbox","text":"<p>Los checkbox son elementos que permite marcar y desmarcar. Suelen ser usados para informaci\u00f3n de tipo true o false. La clase <code>Checkbox</code> es la encarga de estos componentes.</p> <p>Se le puede indicar un estado con el m\u00e9todo <code>setState(boolean b)</code>, para que aparezca marcado o desmarcado.</p> <p> Figura 6 - Checkbox</p> <pre><code>public class Checkboxes {\n\n    public void show() {\n        Frame frame = new Frame();\n        Checkbox component = new Checkbox(\"Choose me\");\n\n        frame.add(component);\n\n        frame.setSize(500,500);\n\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new Checkboxes().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-3/#radiobuttons","title":"RadioButtons","text":"<p>Los RadioButtons son similares a los checkboxes con la diferencia de que suele haber m\u00e1s de uno y adem\u00e1s solo puede ser seleccionado m\u00e1s de uno. La clase <code>Checkbox</code> tambi\u00e9n se encarga de ellos.</p> <p>Se puede usar como segundo par\u00e1metro de la clase <code>Checkbox</code> el grupo al cual pertenece, o por el contrario, usar el m\u00e9todo `setCheckbox</p> <p>La clase <code>CheckboxGroup</code> agrupa varios checkboxes para permitir que solo se seleccione uno:</p> <p> Figura 7 - Radio</p> <pre><code>public class RadioButtons {\n    public void show() {\n        Frame frame = new Frame();\n        Checkbox component1 = new Checkbox(\"Opci\u00f3n 1\");\n        Checkbox component2 = new Checkbox(\"Opci\u00f3n 2\");\n        Checkbox component3 = new Checkbox(\"Opci\u00f3n 3\");\n\n        component1.setSize(40, 20);\n        component2.setSize(40, 20);\n        component3.setSize(40, 20);\n\n        CheckboxGroup group = new CheckboxGroup();\n\n        component1.setCheckboxGroup(group);\n        component2.setCheckboxGroup(group);\n        component3.setCheckboxGroup(group);\n\n        frame.add(component1);\n        frame.add(component2);\n        frame.add(component3);\n\n        frame.setSize(500,500);\n\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new RadioButtons().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-3/#seleccion-multiple","title":"Selecci\u00f3n M\u00faltiple","text":"<p>Las lista de selecci\u00f3n m\u00faltiples son listas que permiten seleccionar m\u00e1s de una opci\u00f3n. La clase <code>List</code> del paquete <code>AWT</code> son las encargadas de este tipo de componente. El constructor de la clase <code>List</code> recibe dos par\u00e1metros, uno con el n\u00famero de elementos a mostrar (si se muestran menos de los que hay, se har\u00e1 scroll) y otro booleano que permite seleccionar m\u00e1s de un elementos a la vez.</p> <p>Adem\u00e1s, tambi\u00e9n dispone del m\u00e9todo <code>addItem(element)</code> para a\u00f1adir elementos a la lista.</p> <p> Figura 8 - List</p> <pre><code>public class Lists {\n    public void show() {\n        Frame frame = new Frame();\n        List list  = new List(2, true);\n\n        list.add(\"Opci\u00f3n 1\");\n        list.add(\"Opci\u00f3n 2\");\n        list.add(\"Opci\u00f3n 3\");\n\n        frame.add(list);\n\n        frame.setSize(500,500);\n\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new Lists().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-3/#campos-de-texto","title":"Campos de texto","text":"<p>Los campos de textos son componentes que permite al usuario escribir en \u00e9l. La clase <code>TextField</code> es la encarga de estos componentes y permite crearlos:</p> <ul> <li>Vac\u00edos. <code>TextField()</code></li> <li>Vac\u00edos con una longitud determinada. <code>TextField(int length)</code></li> <li>Relleno con texto predefinido. <code>TextField(String text)</code></li> <li>Relleno con texto predefinido y longitud determinada. <code>TextField(String text, int length)</code></li> </ul> <p> Figura 9 - TextField</p> <pre><code>public class TextFields {\n    public void show() {\n        Frame frame = new Frame();\n        TextField field1 = new TextField();\n        TextField field2 = new TextField(20);\n        TextField field3 = new TextField(\"Hola\");\n        TextField field4 = new TextField(\"Hola\", 20);\n\n        frame.add(field1);\n        frame.add(field2);\n        frame.add(field3);\n        frame.add(field4);\n\n        frame.setSize(500,500);\n\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new TextFields().show();\n    }\n}\n</code></pre> <p>Para obtener el texto escrito, se puede usar el m\u00e9todo <code>getText()</code>.</p> <p>Este tipo de componente tiene el m\u00e9todo <code>setEditable(boolean b)</code> para indicar si un elemento se puede editar o no.</p>"},{"location":"bloque_vi/tema_31/page-3/#areas-de-texto","title":"\u00c1reas de texto","text":"<p>Las \u00e1reas de texto permiten incorporar texto multil\u00ednea. La clase <code>TextArea</code> se encarga de dicho componente.</p> <p>Este componente puede crearse vac\u00edo (<code>TextArea()</code>), o con el n\u00famero de filas y columnas permitidas (<code>TextArea(int rows, int columns)</code>), con el texto (<code>TextArea(String text)</code>), o con todo (<code>TextArea(String text, int rows, int columns)</code>).</p> <p> Figura 10 - TextArea</p> <pre><code>public class TextAreas {\n    public void show() {\n        Frame frame = new Frame();\n        TextArea textArea = new TextArea(200, 200);\n\n        frame.add(textArea);\n\n        frame.setSize(500,500);\n\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new TextAreas().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-4/","title":"4 Layouts","text":""},{"location":"bloque_vi/tema_31/page-4/#paneles","title":"Paneles","text":"<p>La clase <code>Panel</code> es la clase m\u00e1s simple de los contenedores de componentes gr\u00e1ficos. Su uso permite que las aplicaciones puedan usar multiples layouts. Permite que cada contenedor pueda tener su propio esquema de fuentes, colores, zona de di\u00e1logo, etc.</p> <pre><code>public class Panels {\n    public void show() {\n        Panel panel = new Panel();\n        Button button = new Button(\"Panel button\");\n\n        Label label = new Label(\"Label text\");\n\n        panel.add(button);\n        panel.add(label);\n\n        Frame frame = new Frame(\"Mi panel\");\n        frame.add(panel);\n        frame.setSize(1000, 1000);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new Panels().show();\n    }\n}\n</code></pre> <p>El m\u00e9todo <code>setLayout(layout)</code> nos permite indicar de que forma se disponen los elementos.</p>"},{"location":"bloque_vi/tema_31/page-4/#layouts-manager","title":"Layouts manager","text":"<p>Los layouts managers o manejadores de composici\u00f3n permiten controlar la disposici\u00f3n de los diversos componentes dentro de un contenedor, es decir, especifican que distribuci\u00f3n tendr\u00e1n los componentes a la hora de colocarlos sobre un contenedor. Java dispone de varios como: <code>BorderLayout</code>, <code>GridLayout</code>, <code>FlowLayout</code>, <code>CardLayout</code>, <code>GridBagLayout</code>, etc.</p> <p>\u00bfPor qu\u00e9 Java proporciona estos esquemas predefinidos de disposici\u00f3n de componentes? La raz\u00f3n es simple: imaginemos que deseamos agrupar objetos de distinto tama\u00f1o en celdas de una rejilla virtual: si confiados en nuestro conocimiento de un sistema gr\u00e1fico determinado, y codificamos a mano  tal  disposici\u00f3n,  deberemos  prever  el  redimensionamiento  de  la  ventana,  su  repintado cuando sea cubierto por otra ventana, etc., adem\u00e1s de todas las cuestiones relacionadas con un posible cambio de plataforma (uno nunca sabe a donde van a ir a parar nuestras ventanas).</p> <p>Sigamos  imaginando,  ahora,  que  un  h\u00e1bil  equipo  de  desarrollo  ha  previsto  las  disposiciones gr\u00e1ficas m\u00e1s usadas y ha creado un gestor para cada una de tales configuraciones, que se ocupar\u00e1, de forma transparente para nosotros, de todas esas cuitas de formatos. Bien, pues estos gestores son  instancias  de  las  distintas  clases  derivadas  de  Layout  Manager  y  que  se  utilizan  en  los contenedores de nuestras aplicaciones.</p> <p>Los Layouts liberan al programador de tener que preocuparse de d\u00f3nde ubicar cada uno de los componentes  cuando  una  ventana  es  redimensionada  o  cuando  una  ventana  es  refrescada  o cuando  una  ventana  es  llevada  a  una  plataforma  que  maneja  un  sistema  de  coordenadas diferente.</p>"},{"location":"bloque_vi/tema_31/page-4/#flowlayout","title":"FlowLayout","text":"<p>Es el layout m\u00e1s simple y el que se utiliza por defecto en los paneles. Los componentes a\u00f1adidos se encadenan en forma de lista horizontal, de izquierda a derecha.</p> <p> Figura 11 - FlowLayout</p> <p>Existen varias formas de crear un <code>FlowLayout</code>:</p> <ul> <li><code>FlowLayout(int align, int hgap, int vgap)</code>: Crea un <code>FlowLayout</code> especificando el alineamiento de los elementos, y el espaciado horizontal (hgap) y vertical (vgap). El valor del align puede ser:         - <code>0</code> para la izquierda (se puede usar la constante <code>LEFT</code>).         - <code>1</code> para centrado (se puede usar la constante <code>CENTRE</code>).         - <code>2</code> para la derecha (se puede usar la constante <code>RIGHT</code>)         - <code>3</code> para posicionarse al principio del elemento. Esto depende de la orientaci\u00f3n del componente si estamos ante una disposici\u00f3n de izquierda a derecha se posicionaran a la izquierda, si no a la derecha. Se puede usar la constante <code>LEADING</code>.         - <code>4</code> para posicionarse al final del elemento. Esto depende de la orientaci\u00f3n del componente si estamos ante una disposici\u00f3n de izquierda a derecha se posicionar\u00e1 a la derecha, si no a la izquierda. Se puede usar la constante <code>TRAILING</code>.</li> <li><code>FlowLayout(int align)</code>: Crea un <code>FlowLayout</code> con el alineamiento especificado, y con un espacio por defecto de 5, tanto vertical como horizontal.</li> <li><code>FlowLayout()</code>: Crea una <code>FlowLayout</code> centrado y con espaciado vertical y horizontal de 5, por defecto.</li> </ul> <p>Existen tambi\u00e9n los getters y setters de dichas propiedades. Adem\u00e1s del m\u00e9todo <code>setAlignOnBaseline(boolean b)</code> que permite alinear los elementos seg\u00fan su baseline.</p> <pre><code>public class FlowLayouts {\n    public void show() {\n\n        Frame frame = new Frame();\n        Panel panel = new Panel();\n        LayoutManager flowLayout = new FlowLayout(FlowLayout.CENTER, 10, 10);\n\n        Component button = new Button(\"Button\");\n        Component other = new Button(\"Other\");\n        Component third = new Button(\"third\");\n\n        panel.setLayout(flowLayout);\n        panel.add(button);\n        panel.add(other);\n        panel.add(third);\n\n        frame.setSize(1000, 1000);\n        frame.add(panel);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new FlowLayouts().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-4/#borderlayout","title":"BorderLayout","text":"<p>La composici\u00f3n <code>BorderLayout</code> proporciona un esquema m\u00e1s complejo de colocaci\u00f3n de los componente en un panel. La composici\u00f3n utiliza cinco zonas para colocar los componentes sobre ellas: norte, sur, este, oeste y centro.</p> <p> Figura 12 - BorderLayout</p> <p>Para poder a\u00f1adir cada componente, en alguna de dichas direcciones se debe usar la sobrecarga del m\u00e9todo <code>add(String name, Component component)</code>, siendo el valor de name el nombre de la posici\u00f3n del elemento.</p> <p>Se puede usar indicar el espacio vertical y horizontal haciendo uso del constructor que los recoge: <code>BorderLayout(int vgap, int hgap)</code>; o con los setters necesarios: <code>setVgap()</code> para vertical y <code>setHgap()</code> para horizontal.</p> <pre><code>public class BorderLayouts {\n\n    public void show(){\n        Frame frame = new Frame();\n        Panel panel = new Panel();\n        LayoutManager borderLayout = new BorderLayout();\n\n        Button button1 = new Button(\"North\");\n        Button button2 = new Button(\"South\");\n        Button button3 = new Button(\"West\");\n        Button button4 = new Button(\"East\");\n        Button button5 = new Button(\"Center\");\n\n        panel.setLayout(borderLayout);\n\n        panel.add(\"North\", button1);\n        panel.add(\"South\", button2);\n        panel.add(\"West\", button3);\n        panel.add(\"East\", button4);\n        panel.add(\"Center\", button5);\n\n        frame.add(panel);\n        frame.setSize(1000, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new BorderLayouts().show();\n    }\n\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-4/#gridlayout","title":"GridLayout","text":"<p>La composici\u00f3n <code>GridLayout</code> proporciona una gran flexibilidad para situar componentes. El layout crea con un n\u00famero de filas y columnas y los componentes van dentro de las celdas de la tabla as\u00ed definida.</p> <p>Todos los componentes comprendido en el layout tienen el mismo tama\u00f1o. Si el n\u00famero de filas es menor que el n\u00famero de componentes a a\u00f1adir, omite el valor dado para el n\u00famero de columna y a\u00f1ade las columnas necesarias para abarcar el n\u00famero de componentes.</p> <p> Figura 13 - GridLayout</p> <p>El constructor tiene varias sobrecargas:</p> <ul> <li><code>GridLayout(int rows, int cols, hgap, vgap)</code>: crea un <code>GridLayout</code> definiendo el n\u00famero de filas y columnas, as\u00ed como el espaciado vertical y horizontal. El n\u00famero de filas o el de columnas no puede ser 0 (se lanza un <code>IllegalArgumentException</code>), aunque uno de ellos s\u00ed.</li> <li><code>GridLayout(int rows, int cols)</code>: Crea un <code>GridLayout</code> con el n\u00famero de filas y columnas. Por defecto, el espaciado, tanto horizontal como vertical, queda en 0.</li> <li><code>GridLayout()</code>: Crea un <code>GridLayout</code> con una fila y ninguna columna.</li> </ul> <pre><code>public class GridLayouts {\n    public void show() {\n        Frame frame = new Frame();\n        Panel panel = new Panel();\n        LayoutManager borderLayout = new GridLayout(3, 2);\n\n        Button button1 = new Button(\"1\");\n        Button button2 = new Button(\"2\");\n        Button button3 = new Button(\"3\");\n        Button button4 = new Button(\"4\");\n        Button button5 = new Button(\"5\");\n        Button button6 = new Button(\"6\");\n\n        panel.setLayout(borderLayout);\n\n        panel.add(button1);\n        panel.add(button2);\n        panel.add(button3);\n        panel.add(button4);\n        panel.add(button5);\n        panel.add(button6);\n\n        frame.add(panel);\n        frame.setSize(1000, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new GridLayouts().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-4/#cardlayout","title":"CardLayout","text":"<p>Este tipo de composici\u00f3n es usado cuando se necesita una zona de la ventaja que permita colocar distintos componentes en cada momento.  Este layout suele ir asociado con un <code>Choice</code>, de tal modo que cada selecci\u00f3n determina el panel que se presentar\u00e1.</p> <pre><code>public class CardLayouts {\n\n    private final static String PANEL_BUTTON = \"Panel con botones\";\n    private final static String PANEL_TEXT = \"Panel con campo de texto\";\n    public void show() {\n        Frame frame = new Frame();\n        Panel parent = new Panel();\n        Panel card = new Panel();\n        Panel panel = new Panel();\n\n        LayoutManager borderLayout = new BorderLayout();\n        LayoutManager cardLayout = new CardLayout();\n\n        Choice choice = new Choice();\n\n        choice.addItem(PANEL_BUTTON);\n        choice.addItem(PANEL_TEXT);\n\n        panel.add(choice);\n\n        parent.setLayout(borderLayout);\n        parent.add(\"North\", panel);\n\n        card.setLayout(cardLayout);\n\n        Panel child1 = new Panel();\n        child1.add(new Button(\"Button 1\"));\n        child1.add(new Button(\"Button 2\"));\n        child1.add(new Button(\"Button 3\"));\n\n        Panel child2 = new Panel();\n        child2.add(new TextField(\"Texto\", 20));\n\n        card.add(PANEL_BUTTON, child1);\n        card.add(PANEL_TEXT, child2);\n\n        parent.add(\"Center\", card);\n\n\n        new CardLayout().show(card,  PANEL_TEXT);\n        new CardLayout().show(card, PANEL_BUTTON);\n\n\n        frame.add(parent);\n        frame.setSize(1000, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new CardLayouts().show();\n    }\n}\n</code></pre> <p>De esta manera, puede pasar de esto:</p> <p> Figura 14 - CardLayout1</p> <p>A esto:</p> <p> Figura 15 - CardLayout2</p>"},{"location":"bloque_vi/tema_31/page-4/#layout-personalizado","title":"Layout personalizado","text":"<p>Para poder crear un layout personalizada es necesario implementar la interfaz <code>LayoutManager</code> y sobrescribir sus m\u00e9todos:</p> <ul> <li><code>void addLayoutComponent(String name, Component component)</code>. A\u00f1ade el componente a la posici\u00f3n nombrada.</li> <li><code>void removeLayoutComponent(Component component)</code>. Elimina el componente del layout.</li> <li><code>Dimension preferredLayoutSize(Container parent)</code>. Calcula el tama\u00f1o preferido para el especificado container.</li> <li><code>Dimension miniumLayoutSize(Container parent)</code>. Calcula el tama\u00f1o m\u00ednimo para el especificado container.</li> <li><code>void layoutContainer(Container parent)</code>. Establece el especificado container.</li> </ul> <p>En el siguiente ejemplo, se desarrolla un layout que permite colocar los componentes en posiciones absolutas del panel que contenga a este layout:</p> <p> Figura 16 - CustomLayout</p> CustomLayoutMain <pre><code>public class CustomLayout implements LayoutManager {\n    @Override\n    public void addLayoutComponent(String name, Component comp) {\n\n    }\n\n    @Override\n    public void removeLayoutComponent(Component comp) {\n\n    }\n\n    @Override\n    public Dimension preferredLayoutSize(Container parent) {\n        Insets insets = parent.getInsets();\n        int num = parent.getComponentCount();\n        int width = 0;\n        int height = 0;\n\n        for (int i = 0; i &lt; num; i++) {\n            Component component = parent.getComponent(i);\n            Dimension d = component.getPreferredSize();\n            Point p = component.getLocation();\n\n            if((p.x + d.width) &gt; width){\n                width = p.x + d.width;\n            }\n\n            if((p.y + d.height) &gt; height){\n                height = p.y + d.height;\n            }\n        }\n        return new Dimension(insets.left + insets.right + width, insets.top + insets.bottom + height);\n    }\n\n    @Override\n    public Dimension minimumLayoutSize(Container parent) {\n        return preferredLayoutSize(parent);\n    }\n\n    @Override\n    public void layoutContainer(Container parent) {\n        int num = parent.getComponentCount();\n\n        for (int i = 0; i &lt; num; i++) {\n            Component component = parent.getComponent(i);\n            Dimension d = component.getPreferredSize();\n            component.setSize(d.width, d.height);\n        }\n    }\n}\n</code></pre> <pre><code>public class CustomLayouts {\n    public void show() {\n        Frame frame = new Frame();\n        Panel panel = new Panel();\n        Button button1 = new Button(\"Aceptar\");\n        Button button2 = new Button(\"Abrir\");\n        Button button3 = new Button(\"Cerrar\");\n        Label label = new Label(\"Texto\");\n        TextField textField = new TextField(\"\", 20);\n\n        panel.setLayout(new CustomLayout());\n\n        panel.add(button1);\n        panel.add(button2);\n        panel.add(button3);\n        panel.add(label);\n        panel.add(textField);\n\n        button1.setLocation(0, 10);\n        button2.setLocation(70, 10);\n        button3.setLocation(30, 40);\n        label.setLocation(75,70);\n        textField.setLocation(120, 70);\n\n        frame.setSize(500, 500);\n        frame.add(panel);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new CustomLayouts().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-4/#canvas","title":"Canvas","text":"<p>Un lienzo es una parte de nuestra UI donde se le permite a los usuarios realizar pintadas. La clase <code>Canvas</code> representa un lienzo y sus caracter\u00edsticas principales son:</p> <ul> <li>Permite dibujar directamente en el componente utilizando los m\u00e9todos de la clase <code>Graphic</code>.</li> <li>Puede manejar eventos del rat\u00f3n y teclado para interactividad.</li> <li>Se puede a\u00f1adir contenedor de AWT como <code>Frame</code> o <code>Panel</code>, etc.</li> </ul> <p> Figura 17 - Canvas</p> <pre><code>public class CanvasExample {\n    public void show() {\n        Canvas canvas = new Canvas();\n\n        Panel panel = new Panel();\n\n        panel.add(canvas);\n\n        Frame frame = new Frame();\n        frame.add(panel);\n        frame.setSize(500, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new CanvasExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-4/#proyecto-layout","title":"Proyecto Layout","text":"<p>En el siguiente proyecto, se va a desarrollar una aplicaci\u00f3n Ui como la siguiente:</p> <p> Figura 18 - Proyecto Layout</p> <pre><code>public class LayoutProject {\n\n    private static class MyCanvas extends Canvas{\n        @Override\n        public void paint(Graphics g) {\n            int w = getSize().width;\n            int h = getSize().height;\n\n            g.drawRect(0, 0, w-1, h-1);\n            g.drawString(\"Canvas\", (w-g.getFontMetrics().stringWidth(\"Canvas\"))/2, 10);\n        }\n    }\n    public void show() {\n        Panel panel = createPanel();\n        Frame frame = new Frame();\n\n        frame.setSize(1000, 1000);\n        frame.add(panel);\n        frame.setVisible(true);\n    }\n\n    private Panel createPanel() {\n        Panel panel = new Panel(); // Parent\n        Panel start = new Panel(); // Left\n        Panel end = new Panel(); // Right\n        Panel buttons = new Panel(); // Buttons panel\n        Panel canvasPanel = new Panel();\n\n        start.setLayout(new BorderLayout());\n        end.setLayout(new BorderLayout());\n        canvasPanel.setLayout(new BorderLayout());\n        canvasPanel.setBounds(1, 1, 200, 20);\n\n        printStart(start);\n        printCenter(buttons);\n        printCanva(canvasPanel);\n        printEnd(end);\n\n        start.add(\"East\", buttons);\n        start.add(\"South\", canvasPanel);\n\n        panel.add(start);\n        panel.add(end);\n        return panel;\n    }\n\n    private void printEnd(Panel panel) {\n        Label label = new Label(\"Editor\");\n        TextArea textField = new TextArea(\"Aqu\u00ed se puede escribir\", 8, 30);\n\n        panel.add(\"North\", label);\n        panel.add(\"South\", textField);\n    }\n\n    private void printCenter(Panel panel) {\n        Button deleteButton = new Button(\"Borrar\");\n        Button printButton = new Button(\"Imprimir\");\n\n        Choice figures = new Choice();\n        figures.addItem(\"Cuadrado\");\n        figures.addItem(\"Circulo\");\n        figures.addItem(\"Tri\u00e1ngulo\");\n\n        Checkbox checkbox = new Checkbox(\"Relleno\");\n\n        panel.add(deleteButton);\n        panel.add(printButton);\n        panel.add(figures);\n        panel.add(checkbox);\n    }\n\n    private void printCanva(Panel panel) {\n        Label pencilLabel = new Label(\"L\u00e1piz\");\n        TextField textField = new TextField(\"1\", 8);\n        Scrollbar pencilScrollbar = new Scrollbar(Scrollbar.HORIZONTAL, 1, 1, 1,  10);\n        pencilScrollbar.setBounds(1, 1, 100, 5);\n\n        panel.add(\"North\", pencilLabel);\n        panel.add(\"East\", textField);\n        panel.add(\"Center\", pencilScrollbar);\n    }\n\n    private void printStart(Panel panel) {\n        List colors = new List(6, false);\n\n        colors.add(\"Rojo\");\n        colors.add(\"Naranja\");\n        colors.add(\"Amarillo\");\n        colors.add(\"Verde\");\n        colors.add(\"Azul\");\n        colors.add(\"Morado\");\n        colors.add(\"Negro\");\n        colors.add(\"Blanco\");\n\n        panel.add(\"West\", colors);\n\n        Canvas canvas = new MyCanvas();\n        canvas.setBounds(0,0, 100, 100);\n        panel.add(\"Center\", canvas);\n    }\n\n    public static void main(String[] args) {\n        new LayoutProject().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-5/","title":"5 Eventos","text":""},{"location":"bloque_vi/tema_31/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Los eventos son acciones que son provocadas por la interacci\u00f3n de los usuarios con los componentes. Por ejemplo, al hacer clic en un bot\u00f3n, al cambiar el estado de un checkbox, al escribir en un campo de texto, etc.</p> <p>En AWT, los eventos son objetos que representan dicha interacci\u00f3n. El manejo de estos eventos se realizan mediante listeners, es decir, escuchadores que responden a dichos eventos.</p> <p>Podemos distinguir diferentes grupos de eventos:</p> <ul> <li>Eventos del mouse: Son generados por el rat\u00f3n, como hacer clic, moverlo o arrastrar.</li> <li>Eventos del teclado: Se generan cuando se interact\u00faa con el teclado, al escribir o pulsar una tecla.</li> <li>Eventos del componente: Generados cuando el componente cambia de estado, como ser redimensionados, mostrados u ocultados.</li> <li>Eventos del foco: Generados cuando un componente gana o pierde el foco.</li> <li>Eventos de acci\u00f3n: Generados por componentes interactivos como botones.</li> <li>Eventos de selecci\u00f3n: Generados por componentes de selecci\u00f3n, como checkbox o listas.</li> <li>Eventos de texto: Generados por componentes de campos de textos.</li> <li>Eventos de ventana: Generados por la ventana principal.</li> </ul>"},{"location":"bloque_vi/tema_31/page-5/#eventos-del-mouse","title":"Eventos del mouse","text":"<p>Son manejados por las interfaces <code>MouseListener</code> y <code>MouseMotionListener</code>. La interfaz <code>MouseListener</code> se encarga de los eventos del rat\u00f3n:</p> <ul> <li><code>mouseClicked(event)</code>: Se ejecuta cuando se hace clic en el rat\u00f3n.</li> <li><code>mousePressed(event)</code>: Se ejecuta cunado se presiona sobre el rat\u00f3n.</li> <li><code>mouseReleased(event)</code>: Se ejecuta cuando el bot\u00f3n del rat\u00f3n se suelta.</li> <li><code>mouseEntered(event)</code>: Se ejecuta cuando el rat\u00f3n entra en un componente.</li> <li><code>mouseExited(event)</code>: Se ejecuta cuando el rat\u00f3n sale de un componente.</li> </ul> <p>Mientras que, la interfaz <code>MouseMotionListener</code> se encarga de los movimientos del rat\u00f3n:</p> <ul> <li><code>mouseDragged</code>: Se ejecuta cuando se arrastra el rat\u00f3n con un bot\u00f3n presionado.</li> <li><code>mouseMoved</code>: Se ejecuta cuando se arrastra el rat\u00f3n, pero sin presionar ning\u00fan bot\u00f3n.</li> </ul> <p>Todos los m\u00e9todos reciben como par\u00e1metro un objeto de la clase <code>MouseEvent</code>. Esta clase registra las operaciones realizadas por el rat\u00f3n:</p> <ul> <li><code>int getButton()</code>. Retorna un valor n\u00famero indicado el bot\u00f3n del teclado que ha devuelto. Si ha devuelto 0, no ha presionado ning\u00fan bot\u00f3n. Si devuelve un n\u00famero entre 1 y 5, devuelve el bot\u00f3n presionado por el rat\u00f3n desde la izquierda (comienza en 1) hasta la derecha(termina en 5).</li> <li><code>Point getPoint()</code>. Retorna la posicional horizontal (x, tambi\u00e9n se puede obtener con <code>getX()</code>) y la posici\u00f3n vertical (y, <code>getY()</code>).</li> <li><code>int getClickCount()</code>. Retorna el n\u00famero de veces que se ha hecho clic en un bot\u00f3n.</li> </ul> <p>Los componentes que admiten este evento, tienen el m\u00e9todo <code>addMouseListener</code> que recibe un objeto de <code>MouseListener</code> y <code>addMouseMotionListener</code> que recibe un objeto de <code>MouseMotionListener</code>.</p> <p>Existe otra tipo de evento del rat\u00f3n, que controla cuando la rueda del rat\u00f3n es movida. La interfaz <code>MouseWheelListener</code> es una interfaz funcional que contiene el m\u00e9todo <code>mouseWheelMoved(mouseWheelEvent)</code> que se ejecuta cuando la rueda del rat\u00f3n se mueve. Adem\u00e1s, recibe un objeto de la clase <code>MouseWheelEvent</code>que se encarga de almacenar informaci\u00f3n sobre el evento. Para a\u00f1adir un evento de este tipo se llama al m\u00e9todo <code>addMouseWheelListener</code> del componente.</p> <pre><code>public class MouseEvents {\n    public void show() {\n        Panel panel = new Panel();\n        Frame frame = new Frame();\n\n        Label label = new Label(\"Sin movimiento\");\n\n        Canvas canvas = new Canvas();\n\n        panel.add(label);\n        panel.add(canvas);\n\n        canvas.setBounds(0,0, 100,100);\n        canvas.setBackground(Color.BLACK);\n\n        canvas.addMouseWheelListener(new MouseWheelListener() {\n            @Override\n            public void mouseWheelMoved(MouseWheelEvent e) {\n\n            }\n        });\n\n        canvas.addMouseListener(new MouseListener() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                int button = e.getButton();\n                if(button == 1){\n                    label.setText(\"Izquierdo presionado\");\n                } else if(button == 2){\n                    label.setText(\"Medio presionado\");\n                } else if(button == 3){\n                    label.setText(\"Derecho presionado\");\n                }\n            }\n\n            @Override\n            public void mousePressed(MouseEvent e) {\n                label.setText(e.getPoint().toString());\n            }\n\n            @Override\n            public void mouseReleased(MouseEvent e) {\n                System.out.println(e.getClickCount());\n            }\n\n            @Override\n            public void mouseEntered(MouseEvent e) {\n\n            }\n\n            @Override\n            public void mouseExited(MouseEvent e) {\n\n            }\n        });\n\n\n\n        frame.add(panel);\n        frame.setSize(500, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new MouseEvents().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-5/#eventos-del-teclado","title":"Eventos del teclado","text":"<p>La interfaz <code>KeyListener</code> es la encarga de manejar los eventos del teclado. Entre sus m\u00e9todos encontramos:</p> <ul> <li><code>keyTyped(event)</code>. Se produce cuando se escribe una tecla.</li> <li><code>keyPressed(event)</code>. Se produce cuando se presiona una tecla.</li> <li><code>keyReleased(event)</code>. Se produce cuando se presiona una tecla.</li> </ul> <p>Dichos m\u00e9todos reciben un objeto de tipo <code>KeyEvent</code>, que es la clase encargada de recibir informaci\u00f3n sobre el evento. Entre sus m\u00e9todos, podemos destacar:</p> <ul> <li><code>int getKeyCode()</code>: retorna el n\u00famero asociado a la tecla relacionada con el evento.</li> <li><code>char getKeyChar()</code>: retorna el car\u00e1cter.</li> <li><code>static String getKeyText()</code>: retorna la funci\u00f3n de la tecla, como por ejemplo, la tecla ENTER.</li> <li><code>boolean isActionKey()</code>: retorna <code>true</code> si la tecla es una tecla de acci\u00f3n.</li> </ul> <p>Parra ejecutar un evento de este tipo, se llama al m\u00e9todo <code>addKeyListener()</code></p> <pre><code>public class KeyEvents {\n    public void show() {\n        Panel panel = new Panel();\n        Frame frame = new Frame();\n\n        Label label = new Label(\"Sin movimiento\");\n\n        Canvas canvas = new Canvas();\n\n        panel.add(label);\n        panel.add(canvas);\n\n        canvas.setBounds(0,0, 100,100);\n        canvas.setBackground(Color.BLACK);\n        canvas.setFocusable(true);\n        canvas.addMouseWheelListener(new MouseWheelListener() {\n            @Override\n            public void mouseWheelMoved(MouseWheelEvent e) {\n\n            }\n        });\n\n        canvas.addKeyListener(new KeyListener() {\n            @Override\n            public void keyTyped(KeyEvent e) {\n                System.out.println(\"KEY TYPED\");\n                System.out.printf(\"CHAR -&gt; %c\\n\", e.getKeyChar());\n                System.out.printf(\"INTEGER -&gt; %d\\n\", e.getKeyCode());\n                System.out.printf(\"TEXT -&gt; %s\\n\", KeyEvent.getKeyText(e.getKeyCode()));\n            }\n\n            @Override\n            public void keyPressed(KeyEvent e) {\n                System.out.println(\"KEY PRESSED\");\n                System.out.printf(\"CHAR -&gt; %c\\n\", e.getKeyChar());\n                System.out.printf(\"INTEGER -&gt; %d\\n\", e.getKeyCode());\n                System.out.printf(\"TEXT -&gt; %s\\n\", KeyEvent.getKeyText(e.getKeyCode()));\n            }\n\n            @Override\n            public void keyReleased(KeyEvent e) {\n                System.out.println(\"KEY RELEASED\");\n                System.out.printf(\"CHAR -&gt; %c\\n\", e.getKeyChar());\n                System.out.printf(\"INTEGER -&gt; %d\\n\", e.getKeyCode());\n                System.out.printf(\"TEXT -&gt; %s\\n\", KeyEvent.getKeyText(e.getKeyCode()));\n            }\n        });\n\n\n\n        frame.add(panel);\n        frame.setSize(500, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new KeyEvents().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-5/#eventos-de-componentes","title":"Eventos de componentes","text":"<p>La interfaz <code>ComponentListener</code> es la encargada de manejar los eventos del componente. Los m\u00e9todos que se ejecutar\u00edan ser\u00edan:</p> <ul> <li><code>componentResized(event)</code>: Se llama cuando el componente cambia de tama\u00f1o.</li> <li><code>componentMoved(event)</code>: Se llama cuando el componente cambia de posici\u00f3n.</li> <li><code>componentShown(event)</code>: Se llama cuando el componente se hace visible.</li> <li><code>componentHidden(event)</code>: Se llama cuando el componente se oculta.</li> </ul> <p>Para a\u00f1adir este tipo de eventos, se puede usar el m\u00e9todo <code>addComponentListener</code> de los componentes.</p> <pre><code>public class ComponentEvents {\n    public void show() {\n        Panel panel = new Panel();\n        Frame frame = new Frame();\n\n        Label label = new Label(\"Sin movimiento\");\n\n        panel.add(label);\n        frame.addComponentListener(new ComponentListener() {\n            @Override\n            public void componentResized(ComponentEvent e) {\n                System.out.println(\"Component resized\");\n            }\n\n            @Override\n            public void componentMoved(ComponentEvent e) {\n                System.out.println(\"Component moved\");\n            }\n\n            @Override\n            public void componentShown(ComponentEvent e) {\n                System.out.println(\"Component shown\");\n            }\n\n            @Override\n            public void componentHidden(ComponentEvent e) {\n                System.out.println(\"Component hidden\");\n            }\n        });\n\n\n        frame.add(panel);\n        frame.setSize(500, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new ComponentEvents().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-5/#eventos-del-foco","title":"Eventos del foco","text":"<p>Para controla el foco, disponemos de la interfaz <code>FocusListener</code> con m\u00e9todos para comprobar, si el foco ha sido adquirido <code>focusGained(focusEvent)</code>, o lo ha perdido <code>focusGained(focusEvent)</code>. La clase <code>FocusEvent</code> guarda la informaci\u00f3n sobre la obtenci\u00f3n o p\u00e9rdida del foco.</p> <p>Con el m\u00e9todo <code>addFocusListener()</code> se puede a\u00f1adir un objeto de tipo <code>FocusListener</code> para manejar el evento del foco. Adem\u00e1s los componentes suelen tener un m\u00e9todo <code>setFocusable(boolean b)</code> para indicar desde el c\u00f3digo la p\u00e9rdida o la obtenci\u00f3n del foco.</p> <pre><code>public class FocusEvents {\n\n    public void show() {\n        Panel panel = new Panel();\n        Frame frame = new Frame();\n\n        TextField field = new TextField(40);\n\n        panel.add(field);\n\n        field.addFocusListener(new FocusListener() {\n            @Override\n            public void focusGained(FocusEvent e) {\n                System.out.println(\"Foco obtenido\");\n            }\n\n            @Override\n            public void focusLost(FocusEvent e) {\n                System.out.println(\"Foco perdido\");\n            }\n        });\n\n\n\n        frame.add(panel);\n        frame.setSize(500, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new FocusEvents().show();\n    }\n\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-5/#eventos-de-accion","title":"Eventos de acci\u00f3n","text":"<p>La interfaz <code>ActionListener</code> es la encargada de manejar los eventos por acciones provocados por los componentes. Es un interfaz funcional y su \u00fanico m\u00e9todo <code>actionPerformed(actionEvent)</code> es el que se ejecuta cuando el evento se produce.</p> <p>La clase <code>ActionEvent</code> almacena informaci\u00f3n relevante para la acci\u00f3n realizada, como obtener el comando de la acci\u00f3n ejecutada (<code>getActionCommand()</code>), obtener el momento de la ejecuci\u00f3n de la acci\u00f3n (<code>getWhen()</code>), etc.</p> <p>Para registrar un objeto de este tipo para manejar el evento, se puede llamar al m\u00e9todo <code>addActionListener()</code> de los componentes.</p> <pre><code>public class ActionEvents {\n    public void show() {\n        Panel panel = new Panel();\n        Frame frame = new Frame();\n\n        Button button = new Button(\"Press me\");\n\n        panel.add(button);\n\n        button.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.out.println(\"Button clicked in \" + e.getWhen() + \" with action \" + e.getActionCommand());\n            }\n        });\n\n\n\n        frame.add(panel);\n        frame.setSize(500, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new ActionEvents().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-5/#eventos-de-seleccion","title":"Eventos de selecci\u00f3n","text":"<p>La interfaz <code>ItemListener</code> es la encargada de manejar los eventos de los componentes de selecci\u00f3n (<code>Choice</code>, <code>Checkbox</code>, <code>List</code>). Es una interfaz funcional, cuyo m\u00e9todo <code>itemStateChange(itemEvent)</code> se invoca cuando se cambia el estado del componente.</p> <p>El objeto <code>ItemEvent</code> almacena informaci\u00f3n sobre el evento, como:</p> <ul> <li><code>Object getItem()</code>. Obtiene el elemento seleccionado.</li> <li><code>int getStateChange()</code>. Obtiene el estado cambiado, puede ser <code>SELECTED</code> o <code>DESELECTED</code>.</li> <li><code>getSource()</code>. Obtiene la fuente del evento.</li> </ul> <p>Para a\u00f1adir dicho evento, se puede usar el m\u00e9todo <code>addItemListener()</code>.</p> <pre><code>public class ItemEvents {\n    public void show() {\n        Panel panel = new Panel();\n        Frame frame = new Frame();\n\n        Label label = new Label(\"Choose an option\");\n        Choice choice = new Choice();\n\n        choice.addItem(\"Opci\u00f3n 1\");\n        choice.addItem(\"Opci\u00f3n 2\");\n        choice.addItem(\"Opci\u00f3n 3\");\n\n        panel.add(label);\n        panel.add(choice);\n\n       choice.addItemListener(new ItemListener() {\n           @Override\n           public void itemStateChanged(ItemEvent e) {\n               System.out.println(e.getItem());\n           }\n       });\n\n\n\n        frame.add(panel);\n        frame.setSize(500, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new ItemEvents().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-5/#eventos-de-texto","title":"Eventos de texto","text":"<p>La interfaz <code>TextListener</code> es la encarga de manejar los cambios producidos por los textos de los componentes de textos (<code>TextField</code> y <code>TextArea</code>). Es una interfaz funcional, cuyo m\u00e9todo <code>textValueChange(event)</code> es ejecutado cuando se produce el evento.</p> <p>La clase <code>TextEvent</code> almacena la informaci\u00f3n relevante sobre el evento producido. Con el m\u00e9todo <code>addTextListener</code> se a\u00f1ade el controlador de dicho evento.</p> <pre><code>public class TextEvents {\n    public void show() {\n        Panel panel = new Panel();\n        Frame frame = new Frame();\n\n        Label label = new Label(\"Type something: \");\n        TextArea textArea = new TextArea(300, 300);\n\n        panel.add(label);\n        panel.add(textArea);\n\n        textArea.addTextListener(new TextListener() {\n            @Override\n            public void textValueChanged(TextEvent e) {\n                System.out.println(textArea.getText());\n            }\n        });\n\n\n\n        frame.add(panel);\n        frame.setSize(500, 500);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new TextEvents().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-5/#eventos-de-ventana","title":"Eventos de ventana","text":"<p>La interfaz <code>WindowListener</code> es la encargada de manejar los eventos relacionados con la ventana de nuestra aplicaci\u00f3n. Sus m\u00e9todos son:</p> <ul> <li><code>void windowOpened(event)</code>. Se invoca cuando la ventana ha sido abierta.</li> <li><code>void windowClosing(event)</code>. Se invoca cuando el usuario intenta cerrar la ventana, desde el sistema ventanas nativo. Este m\u00e9todo suele usarse, para realizar limpiezas antes de cerrar la aplicaci\u00f3n.</li> <li><code>void windowClosed(event)</code>. Se invoca despu\u00e9s de cerrar la ventana.</li> <li><code>void windowIconified(event)</code>. Se invoca cuando la ventana se minimiza (iconifica).</li> <li><code>void windowDeiconified(event)</code>. Se invoca cuando la ventana se maximiza (desiconifica) desde un estado minimizado.</li> <li><code>void windowActivated(event)</code>. Se invoca cuando una ventana se convierte en la ventana activa</li> <li><code>void windowDeactivated(event)</code>. Se invoca cuando una ventana deja de ser la ventana activa</li> </ul> <p>La interfaz <code>WindowFocusListener</code> se encarga de manejar el foco de la ventana, con sus m\u00e9todos <code>windowGainedFocus(event)</code> y <code>windowLostFocus(event)</code>.</p> <p>La interfaz <code>WindowStateListener</code> se encarga de manejar el cambio del estado de la ventana, con su m\u00e9todo <code>windowStateChanged(event)</code>. La clase <code>WindowEvent</code> almacena el cambio de estado, y con su m\u00e9todo <code>getOldState()</code> se puede obtener el antiguo estado, y con <code>getNewState()</code> el nuevo. Los diferentes estados a tener son:</p> <ul> <li><code>Frame.NORMAL</code>: La ventana est\u00e1 en su estado normal.</li> <li><code>Frame.ICONIFIED</code>: La ventana est\u00e1 minimizada.</li> <li><code>Frame.MAXIMIZED_HORIZ</code>: La ventana est\u00e1 maximizada horizontalmente.</li> <li><code>Frame.MAXIMIZED_VERT</code>: La ventana est\u00e1 maximizada verticalmente.</li> <li><code>Frame.MAXIMIZED_BOTH</code>: La ventana est\u00e1 maximizada completamente.</li> </ul> <p>Con el m\u00e9todo <code>dispose()</code> de los componentes, se puede liberar los recursos de dicho componente, as\u00ed como eliminar el componente.</p> <pre><code>public class WindowEvents {\n    public void show() {\n        Panel panel = new Panel();\n        Frame frame = new Frame();\n\n        frame.add(panel);\n        frame.setSize(500, 500);\n        frame.setVisible(true);\n        frame.setLocation(100, 100);\n\n        frame.addWindowListener(new WindowListener() {\n            @Override\n            public void windowOpened(WindowEvent e) {\n                System.out.println(\"Ventana abierta\");\n            }\n\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.out.println(\"Cerrando ventana\");\n                frame.dispose();\n            }\n\n            @Override\n            public void windowClosed(WindowEvent e) {\n                System.out.println(\"Ventana cerrada\");\n            }\n\n            @Override\n            public void windowIconified(WindowEvent e) {\n                System.out.println(\"Ventana minimizada\");\n            }\n\n            @Override\n            public void windowDeiconified(WindowEvent e) {\n                System.out.println(\"Ventana maximizada\");\n            }\n\n            @Override\n            public void windowActivated(WindowEvent e) {\n                System.out.println(\"Ventana activada\");\n            }\n\n            @Override\n            public void windowDeactivated(WindowEvent e) {\n                System.out.println(\"Ventana desactivada\");\n            }\n        });\n\n        frame.addWindowFocusListener(new WindowFocusListener() {\n            @Override\n            public void windowGainedFocus(WindowEvent e) {\n                System.out.println(\"Ventana tiene foco\");\n            }\n\n            @Override\n            public void windowLostFocus(WindowEvent e) {\n                System.out.println(\"Ventana perdi\u00f3 el foco\");\n            }\n        });\n\n        frame.addWindowStateListener(new WindowStateListener() {\n            @Override\n            public void windowStateChanged(WindowEvent e) {\n                int state = e.getNewState();\n\n                switch (state) {\n                    case Frame.NORMAL -&gt; System.out.println(\"NORMAL\");\n                    case Frame.ICONIFIED -&gt; System.out.println(\"ICONIFIED\");\n                    case Frame.MAXIMIZED_HORIZ -&gt; System.out.println(\"MAXIMIZED HORIZONTALLY\");\n                    case Frame.MAXIMIZED_VERT -&gt; System.out.println(\"MAXIMIZED VERTICALLY\");\n                    case Frame.MAXIMIZED_BOTH -&gt; System.out.println(\"MAXIMIZED\");\n                }\n            }\n        });\n    }\n\n\n    public static void main(String[] args) {\n        new WindowEvents().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-6/","title":"6 Estilos","text":""},{"location":"bloque_vi/tema_31/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Los componentes disponen de diferentes m\u00e9todos para a\u00f1adirles estilos. En este punto vamos a tratar dichos m\u00e9todos y sus posibles opciones.</p>"},{"location":"bloque_vi/tema_31/page-6/#colores","title":"Colores","text":"<p>La clase <code>Color</code> es una clase que contiene las constantes de los colores comunes, como <code>RED</code>, <code>BLUE</code>, <code>WHITE</code>, <code>BLACK</code>, etc. Podemos, tambi\u00e9n crear colores a trav\u00e9s de su controlador, pasandole hasta 4 argumentos siguiendo el sistema de colores <code>rgba</code>:</p> <ul> <li><code>r</code>.  La cantidad del color rojo que se a\u00f1ade al color que se desea formar.</li> <li><code>g</code>.  La cantidad del color verde que se a\u00f1ade al color que se desea formar.</li> <li><code>b</code>.  La cantidad del color azul que se a\u00f1ade al color que se desea formar.</li> <li><code>a</code>.  La opacidad del color. Es un par\u00e1metro no obligatorio.</li> </ul> <p>Para aplicar colores a los componentes, tenemos dos m\u00e9todos:</p> <ul> <li><code>setBackground(color)</code>: a\u00f1ade color de fondo al componente.</li> <li><code>setForeground(color)</code>: a\u00f1ade color de letra al componente.</li> </ul>"},{"location":"bloque_vi/tema_31/page-6/#fuentes","title":"Fuentes","text":"<p>La clase <code>Font</code> es una clase que se encarga de aplicarle la fuente a los componentes. En su constructor podemos encontrar diferentes elementos:</p> <ul> <li><code>name</code>: Nombre de la fuente.</li> <li><code>style</code>: estilo de la fuente (la clase <code>Font</code> tiene constantes para este tipo, como <code>BOLD</code>).</li> <li><code>size</code>: tama\u00f1o de la fuente.</li> </ul> <p>Para a\u00f1adir una fuente a un componente, se utiliza su m\u00e9todo <code>setFont(font)</code>.</p>"},{"location":"bloque_vi/tema_31/page-6/#proyecto-styles","title":"Proyecto Styles","text":"<p>En este proyecto, se va a dibujar un bot\u00f3n y se va a aplicar un estilo.</p> <pre><code>public class Styles {\n    public void show() {\n\n        Panel panel = new Panel();\n        Frame frame = new Frame();\n\n        Button button = new Button(\"Button styled\");\n\n        panel.add(button);\n        button.setBackground(Color.BLUE);\n        button.setForeground(Color.CYAN);\n        button.setFont(new Font(\"Arial\", Font.BOLD, 24));\n\n        frame.add(panel);\n        frame.setSize(500, 500);\n        frame.setVisible(true);\n        frame.setLocation(100, 100);\n    }\n\n    public static void main(String[] args) {\n        new Styles().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_31/page-7/","title":"Ejercicio","text":"<p>Realiza una aplicaci\u00f3n Java que tenga un parecido a lo siguiente:</p> <p> Figura 19 - Ejercicio</p>"},{"location":"bloque_vi/tema_32/page-1/","title":"1 Swing","text":""},{"location":"bloque_vi/tema_32/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Java Swing es un conjunto de bibliotecas de interfaz gr\u00e1fica de usuario que forman parte de la plataforma Java Foundation Classes (JFC). Introducido por primera vez en la versi\u00f3n 1.2 de Java, Swing proporciona una rica colecci\u00f3n de componentes gr\u00e1ficos que permiten a los desarrolladores crear interfaces de usuario sofisticadas y altamente personalizables para aplicaciones Java.</p> <p>Al usar Swing, podemos encontrar una serie de ventajas:</p> <ul> <li>Personalizaci\u00f3n: Uno de los puntos fuertes de Swing es su capacidad para ser altamente personalizable. A diferencia de AWT, la biblioteca de GUI anterior en Java, Swing es una biblioteca de componentes ligeros, lo que significa que no depende directamente del sistema operativo subyacente para representar sus componentes. Esto permite que los componentes de Swing sean m\u00e1s flexibles y portables. Por ejemplo, es posible cambiar la apariencia de los componentes (look-and-feel) para que se asemejen a diferentes sistemas operativos o para crear un look-and-feel completamente personalizado.</li> <li>Independencia de la plataforma: Debido a que Swing es una biblioteca pura de Java, es completamente independiente de la plataforma. Las aplicaciones de Swing se comportan de la misma manera en cualquier sistema operativo que soporte Java, como Windows, macOS y Linux, lo que facilita la creaci\u00f3n de aplicaciones multiplataforma.</li> <li>Modelo de eventos: Swing utiliza un modelo de eventos robusto que permite gestionar interacciones del usuario de manera eficiente. Los eventos en Swing se basan en la interfaz <code>ActionListener</code> y otras interfaces relacionadas que permiten a los desarrolladores definir c\u00f3mo las aplicaciones deben responder a acciones del usuario como clics de bot\u00f3n, movimientos de rat\u00f3n y teclas presionadas.</li> </ul> <p>Un aspecto a considerar es que, debido a su flexibilidad y riqueza de caracter\u00edsticas, las aplicaciones de Swing pueden ser m\u00e1s pesadas en t\u00e9rminos de uso de memoria y CPU en comparaci\u00f3n con aplicaciones desarrolladas con bibliotecas de GUI m\u00e1s ligeras o espec\u00edficas de la plataforma. Sin embargo, con un manejo adecuado y t\u00e9cnicas de optimizaci\u00f3n, es posible crear aplicaciones Swing con buen desempe\u00f1o.</p> <p>Con la introducci\u00f3n de JavaFX, una biblioteca m\u00e1s moderna y rica para la construcci\u00f3n de interfaces de usuario, Swing ha pasado a un segundo plano en el desarrollo de nuevas aplicaciones Java GUI. JavaFX ofrece una mejor integraci\u00f3n multimedia, gr\u00e1ficos acelerados por hardware y una sintaxis m\u00e1s moderna mediante FXML para definir interfaces de usuario.</p> <p>Sin embargo, Swing sigue siendo ampliamente utilizado, especialmente en aplicaciones empresariales existentes que requieren mantenimiento y en entornos donde la migraci\u00f3n a JavaFX no es pr\u00e1ctica. Adem\u00e1s, muchos desarrolladores todav\u00eda aprecian la robustez y la madurez de Swing.</p> <p>Swing sigue el patr\u00f3n Modelo-Vista-Controlador, aunque no lo implemente estrictamente, ciertos componentes es\u00b4tan dise\u00f1ados con una separaci\u00f3n entre el modelo y la vista.</p>"},{"location":"bloque_vi/tema_32/page-1/#patron-mvc","title":"Patr\u00f3n MVC","text":"<p>El patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador (MVC) es una arquitectura ampliamente utilizada en el desarrollo de aplicaciones que separa la l\u00f3gica de la aplicaci\u00f3n en tres componentes interrelacionados: el Modelo, la Vista y el Controlador. Este patr\u00f3n ayuda a organizar el c\u00f3digo de una manera que promueve la reutilizaci\u00f3n, la escalabilidad y el mantenimiento.</p> <p>El Modelo es la parte de la aplicaci\u00f3n que maneja la l\u00f3gica de negocio y los datos subyacentes. Es responsable de gestionar la informaci\u00f3n y las reglas de negocio de la aplicaci\u00f3n. En el contexto de una base de datos, el Modelo tambi\u00e9n es responsable de interactuar con ella, incluyendo operaciones de consulta y actualizaci\u00f3n. Los principales aspectos del Modelo incluyen:</p> <ul> <li>Gesti\u00f3n de Datos: Almacena los datos de la aplicaci\u00f3n y garantiza su consistencia.</li> <li>Reglas de Negocio: Implementa la l\u00f3gica de negocio que define c\u00f3mo se manejan y procesan los datos.</li> <li>Notificaci\u00f3n de Cambios: Proporciona mecanismos para notificar a la Vista y al Controlador sobre los cambios en los datos, a menudo mediante el uso de patrones de dise\u00f1o como Observer o eventos.</li> </ul> <p>La Vista es la representaci\u00f3n visual de los datos del Modelo. Es responsable de mostrar la informaci\u00f3n al usuario y capturar la entrada del usuario, pero no contiene l\u00f3gica de negocio. La Vista es lo que el usuario ve e interact\u00faa directamente. Los principales aspectos de la Vista incluyen:</p> <ul> <li>Renderizaci\u00f3n de Datos: Muestra los datos del Modelo de una manera adecuada para el usuario.</li> <li>Captura de Eventos de Usuario: Recoge las interacciones del usuario, como clics de bot\u00f3n y entradas de teclado.</li> <li>Actualizaci\u00f3n Din\u00e1mica: Cambia din\u00e1micamente en respuesta a las actualizaciones del Modelo para reflejar el estado actual de los datos.</li> </ul> <p>El Controlador act\u00faa como intermediario entre la Vista y el Modelo. Recibe la entrada del usuario a trav\u00e9s de la Vista, procesa esa entrada (a menudo invocando m\u00e9todos del Modelo), y luego devuelve los resultados a la Vista. Los principales aspectos del Controlador incluyen:</p> <ul> <li>Gesti\u00f3n de la Entrada del Usuario: Interpreta las acciones del usuario y las traduce en operaciones en el Modelo.</li> <li>Actualizaci\u00f3n del Modelo: Modifica el estado del Modelo en respuesta a las acciones del usuario.</li> <li>Actualizaci\u00f3n de la Vista: Ordena a la Vista que se actualice cuando los datos en el Modelo cambian.</li> </ul> <p> Figura 1 - Patr\u00f3n de dise\u00f1o MVC</p> <p>La interacci\u00f3n entre los componentes es sencilla. En primer lugar, el usuario interact\u00faa con la vista realizando una acci\u00f3n (por ejemplo, presionando un bot\u00f3n). Posteriormente, la vista informa al controlador, y \u00e9ste a su vez se lo comunica al modelo. El modelo realiza la acci\u00f3n pertinente en la base de datos (o en la l\u00f3gica del negocio), devolvi\u00e9ndola as\u00ed al controlador el resultado de la operaci\u00f3n, y \u00e9ste a su vez se lo retorna a la vista para actualizar el resultado al usuario.</p> <p>El uso de este patr\u00f3n de dise\u00f1o tiene ciertas ventajas:</p> <ul> <li>Separaci\u00f3n de Preocupaciones: Divide la aplicaci\u00f3n en componentes independientes, lo que facilita el mantenimiento y la escalabilidad.</li> <li>Reutilizaci\u00f3n de C\u00f3digo: Los componentes del Modelo pueden reutilizarse en diferentes partes de la aplicaci\u00f3n o incluso en diferentes aplicaciones.</li> <li>Facilidad de Pruebas: Permite probar cada componente de manera aislada, mejorando la capacidad de realizar pruebas unitarias y de integraci\u00f3n.</li> <li>Desarrollo Colaborativo: Permite que diferentes desarrolladores trabajen en la Vista, el Modelo y el Controlador simult\u00e1neamente sin interferir en el trabajo de los dem\u00e1s.</li> </ul>"},{"location":"bloque_vi/tema_32/page-1/#proyecto-mvc","title":"Proyecto MVC","text":"<p>En este proyecto, se va a desarrollar una aplicaci\u00f3n, haciendo uso del patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador. En primer lugar, se crea el modelo con la l\u00f3gica de negocio.</p> <pre><code>public class UserModel {\n\n    private final List&lt;String&gt; users = List.of(\"Ana\", \"Sof\u00eda\", \"Marcus\", \"Andres\");\n\n    public List&lt;String&gt; getUsers(){\n        return users;\n    }\n\n    public String getUserById(String name){\n        return users.stream().filter(x -&gt; x.equals(name)).findFirst().orElse(\"No existe\");\n    }\n}\n</code></pre> <p>Una vez creado el modelo, se crea la vista con la que se va a trabajar. En esta vista se va a crear un bot\u00f3n y un label con el nombre de usuario:</p> <pre><code>public class UserView {\n\n    private final Frame frame;\n    private final Button button;\n    private final Label label;\n\n    public UserView(){\n        frame = new Frame(\"MVC\");\n        frame.setSize(300, 200);\n        frame.setLayout(new FlowLayout());\n\n        label = new Label(\"\");\n        button = new Button(\"Click me!\");\n\n        frame.add(label);\n        frame.add(button);\n    }\n\n    public void show(){\n        frame.setVisible(true);\n    }\n\n    public void setUsername(String name){\n        label.setText(name);\n    }\n\n    public void onClickButton(ActionListener listener){\n        button.addActionListener(listener);\n    }\n\n}\n</code></pre> <p>Por \u00faltimo, creamos el controlador, inyect\u00e1ndole tanto la vista como el modelo:</p> <pre><code>public class UserController {\n\n    private final UserModel model;\n    private final UserView view;\n\n    public UserController(UserModel model, UserView view) {\n        this.model = model;\n        this.view = view;\n\n        view.onClickButton(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                updateUsername();\n            }\n        });\n    }\n    private void updateUsername() {\n        String username = model.getUserById(\"Ana\");\n        view.setUsername(username);\n    }\n}\n</code></pre> <p>Otra forma de hacerlo, es inyectar el controlador en la vista, y desde ah\u00ed realizar las interacciones.</p> <p>En nuestro <code>Main</code>, creamos instancias de nuestros componentes:</p> <pre><code>public class Main {\n    public void show() {\n        UserModel model = new UserModel();\n        UserView view = new UserView();\n        UserController controller = new UserController(model, view);\n        view.show();\n    }\n\n    public static void main(String[] args) {\n        new Main().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-2/","title":"2 Componentes","text":""},{"location":"bloque_vi/tema_32/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>El funcionamiento de los componentes del paquete Swing, son los mismos que los componentes en AWT. Esto es debido a porque todas las clases e interfaces de dicho paquete son heredados del paquete AWT.</p> <p>Sin embargo, los componentes Swing a\u00f1ade nuevas funcionalidades, haci\u00e9ndolo m\u00e1s rico y \u00fatil que la biblioteca AWT.</p> <p>La mayor\u00eda de los nombre de AWT y Swing coinciden en parte, teniendo un prefijo <code>J</code> en los componentes Swing. Por ejemplo, el componente <code>Panel</code> de AWT tiene un similar en Swing llamado <code>JPanel</code>.</p>"},{"location":"bloque_vi/tema_32/page-2/#jcomponent","title":"JComponent","text":"<p>La clase <code>JComponent</code> es una clase del paquete Swing m\u00e1s fundamental, debido a que todos los componentes heredan de esta clase. La clase <code>JComponent</code> a su vez hereda de la clase <code>Container</code> del paquete AWT, que hereda de <code>Component</code>.</p> <p>Proporciona el m\u00e9todo <code>paintComponent(Graphics g)</code>, que se utiliza para renderizar el componente. Este m\u00e9todo ha de ser sobrescrito para renderizar componentes personalizados. Esta versi\u00f3n del componente permite trabajar con los bordes haciendo uso del m\u00e9todo <code>setBorder(Border border)</code>. Esto es \u00fatil para agregar decoraciones o delimitaciones visuales a los componentes.</p> <p>Otros m\u00e9todos de inter\u00e9s:</p> <ul> <li><code>setTooltipText(String text)</code>: permite crear tooltips en el componente. Los tooltips son \u00fatiles para proporcionar informaci\u00f3n adicional sobre un componente cuando el usuario pasa el cursor sobre \u00e9l.</li> <li><code>setPreferredSize(Dimension d)</code>, <code>setMinimumSize(Dimension d)</code> y <code>setMaximumSize(Dimension d)</code> para controlar las dimensiones preferidas, m\u00ednimas y m\u00e1ximas del componente.</li> <li>Soporta la integraci\u00f3n con tecnolog\u00edas de asistencia mediante m\u00e9todos de accesibilidad, mejorando la experiencia para usuarios con discapacidades.</li> </ul> <p><code>JComponent</code> proporciona el doble buffering, una t\u00e9cnica que reduce el parpadeo durante la actualizaci\u00f3n de gr\u00e1ficos, proporcionando una representaci\u00f3n m\u00e1s suave.</p>"},{"location":"bloque_vi/tema_32/page-2/#graphics","title":"Graphics","text":"<p>La clase <code>Graphics</code> en Java es parte del paquete <code>java.awt</code> y es fundamental para la creaci\u00f3n de gr\u00e1ficos en aplicaciones Java. Proporciona los m\u00e9todos necesarios para dibujar formas, texto e im\u00e1genes en componentes gr\u00e1ficos. Aunque <code>Graphics</code> es una clase abstracta, sus m\u00e9todos son implementados por la clase <code>Graphics2D</code>, que proporciona capacidades de dibujo m\u00e1s avanzadas.</p> <p>Veamos algunos de sus m\u00e9todos:</p> M\u00e9todo Funci\u00f3n <code>drawLine(int x1, int y1, int x2, int y2)</code> Dibuja una l\u00ednea entre los puntos <code>(x1, y1)</code> y <code>(x2, y2)</code> <code>drawReact(int x, int y, int width, int height)</code> Dibuja un rect\u00e1ngulo, en la posici\u00f3n y dimensiones indicadas <code>fillRect(int x, int y, int width, int height)</code> Dibuja un rect\u00e1ngulo relleno <code>drawOval(int x, int y, int width, int height)</code> Dibuja un \u00f3valo, en la posici\u00f3n y dimensiones indicadas <code>fillOval(int x, int y, int width, int height)</code> Dibuja un \u00f3valo relleno <code>drawString(String str, int x, int y)</code> Dibuja el texto especificado en la posici\u00f3n <code>(x, y)</code> <code>drawImage(Image img, int x, int y, ImageObserver observer)</code> Dibuja una imagen <code>setColor(Color color)</code> Establece el color del dibujo <code>setFont(Font font)</code> Establece la fuente para el texto <code>translate(int x, int y)</code> Mueve el origen del componente a las coordenadas <code>(x, y)</code>"},{"location":"bloque_vi/tema_32/page-2/#bordes","title":"Bordes","text":"<p>Los bordes vienen definidos en la interfaz <code>Border</code> del paquete Swing. Esta interfaz define una serie de m\u00e9todos que deben ser implementados por las clases que definen distintos tipos de bordes que pueden ser aplicados a componentes Swing.</p> <p>Los bordes se utilizan ampliamente en Swing para proporcionar delimitaciones visuales alrededor de componentes como <code>JPanel</code>, <code>JButton</code>, <code>JTextField</code>, entre otros. Swing proporciona varias implementaciones predeterminadas de la interfaz Border en el subpaquete <code>javax.swing.border</code>:</p> <ul> <li><code>EmptyBorder</code>: Un borde vac\u00edo que deja espacio en blanco alrededor de un componente.</li> <li><code>LineBorder</code>: Un borde simple que dibuja una l\u00ednea alrededor del componente.</li> <li><code>EtchedBorder</code>: Un borde con un efecto grabado.</li> <li><code>BevelBorder</code>: Un borde biselado que puede dar la apariencia de relieve o hundido.</li> <li><code>TitledBorder</code>: Un borde con un t\u00edtulo.</li> <li><code>CompoundBorder</code>: Un borde compuesto que permite combinar dos bordes en uno.</li> </ul>"},{"location":"bloque_vi/tema_32/page-2/#jframe","title":"JFrame","text":"<p><code>JFrame</code> es una clase fundamental en el paquete Swing de Java, utilizada para crear ventanas con una interfaz gr\u00e1fica de usuario. Un <code>JFrame</code> es una ventana de nivel superior que puede contener otros componentes Swing, como botones, etiquetas, paneles y m\u00e1s. Proporciona una ventana con una barra de t\u00edtulo, bordes y botones est\u00e1ndar para minimizar, maximizar y cerrar la ventana.</p> <p>Dispone del m\u00e9todo <code>setDefaultCloseOperation(int operation)</code> que permite definir que operaci\u00f3n hacer cuando se hace clic en el bot\u00f3n de cerrar ventana. Entre las diferentes opciones tenemos:</p> <ul> <li><code>0</code>. No hace nada al cerrar. Se puede indicar f\u00e1cilmente haciendo uso de la variable est\u00e1tica <code>DO_NOTHING_ON_CLOSE</code> de la clase <code>JFrame</code>.</li> <li><code>1</code>. Oculta la ventana. Es la opci\u00f3n por defecto, y est\u00e1 representada por la variable est\u00e1tica <code>HIDE_ON_CLOSE</code>.</li> <li><code>2</code>. Libera al cerrar. Est\u00e1 representada por <code>DISPOSE_ON_CLOSE</code>.</li> <li><code>3</code>. Cierra la ventana. Est\u00e1 representada por <code>EXIT_ON_CLOSE</code>.</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>public class JFrameExample {\n    public void show() {\n        JFrame frame = new JFrame(\"JFrame Example\");\n        frame.setSize(200, 200);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new JFrameExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-2/#contentpane","title":"ContentPane","text":"<p><code>ContentPane</code> es el contenedor por defecto para los componentes de alto nivel como <code>JFrame</code>, en el cual se agregan los componentes que se desean mostrar en la ventana.</p> <p>A trav\u00e9s del m\u00e9todo <code>getContentPane()</code> se puede acceder a dicho contenedor. A diferencia del <code>Frame</code> de AWT, en Swing para agregar componentes a un <code>JFrame</code> es necesario realizarlo a trav\u00e9s de dicho contenedor. Por lo que, a trav\u00e9s del m\u00e9todo <code>getContentPane()</code> se puede acceder a \u00e9l, y con el m\u00e9todo <code>add(component)</code> de dicho contenedor, se a\u00f1aden los componentes.</p> <p><code>ContentPane</code> utiliza un layout para posicionar los componentes. Por defecto, se utiliza <code>BorderLayout</code>, pero puede ser cambiado usando el m\u00e9todo <code>setLayout(layout)</code>.</p> <p>Adem\u00e1s, este tipo de contenedor dispone del m\u00e9todo <code>remove(component)</code> que elimina el componente del contenedor.</p> <p>Se puede cambiar el contenedor de un <code>JFrame</code> a trav\u00e9s del m\u00e9todo <code>setContentPane(pane)</code> a\u00f1adiendo el contenedor que se desee.</p>"},{"location":"bloque_vi/tema_32/page-2/#componentes-de-botones","title":"Componentes de botones","text":"<ul> <li> <p><code>JButton</code>: Representa un bot\u00f3n que se puede presionar para realizar una acci\u00f3n.</p> <pre><code>JButton button = new JButton(\"Click Me\");\n</code></pre> </li> <li> <p><code>JCheckBox</code>: Representa una casilla de verificaci\u00f3n que se puede seleccionar o deseleccionar.</p> <pre><code>JCheckBox checkBox = new JCheckBox(\"Accept Terms\");\n</code></pre> </li> <li> <p><code>JRadioButton</code>: Representa un bot\u00f3n de opci\u00f3n que se puede seleccionar como parte de un grupo de botones de opci\u00f3n. La clase <code>ButtonGroup</code> agrupa los botones de un opci\u00f3n en un grupo, para que solo puedan ser elegido uno.</p> <pre><code>JRadioButton radioButton1 = new JRadioButton(\"Option 1\");\nJRadioButton radioButton2 = new JRadioButton(\"Option 2\");\nButtonGroup group = new ButtonGroup();\ngroup.add(radioButton1);\ngroup.add(radioButton2);\n</code></pre> </li> </ul>"},{"location":"bloque_vi/tema_32/page-2/#componentes-de-etiquetas-y-areas-de-texto","title":"Componentes de Etiquetas y \u00c1reas de Texto","text":"<ul> <li> <p><code>JLabel</code>: Representa una etiqueta que puede mostrar texto o iconos.</p> <pre><code>JLabel label = new JLabel(\"Hello, World!\");\n</code></pre> </li> <li> <p><code>JTextField</code>: Representa un campo de texto de una sola l\u00ednea donde el usuario puede ingresar datos.</p> <pre><code>JTextField textField = new JTextField(20);\n</code></pre> </li> <li> <p><code>JTextArea</code>: Representa un \u00e1rea de texto de m\u00faltiples l\u00edneas.</p> <pre><code>JTextArea textArea = new JTextArea(5, 20);\n</code></pre> </li> </ul>"},{"location":"bloque_vi/tema_32/page-2/#componentes-de-listas","title":"Componentes de Listas","text":"<ul> <li><code>JList</code>: Representa una lista de elementos.</li> </ul> <pre><code>String[] data = {\"Item 1\", \"Item 2\", \"Item 3\"};\nJList&lt;String&gt; list = new JList&lt;&gt;(data);\n</code></pre>"},{"location":"bloque_vi/tema_32/page-2/#listado-componentes","title":"Listado componentes","text":"<p>En Swing, existen una gran variedad de componentes.</p> Componente Descripci\u00f3n JButton Bot\u00f3n. JCheckBox Bot\u00f3n de comprobaci\u00f3n. JCheckBoxMenuItem Bot\u00f3n de comprobaci\u00f3n para usar en men\u00fas JColorChooser Selector de colores. JComboBox Entrada de texto con lista de valores. JComponent Ra\u00edz de la jerarquia de componentes Swing. JEditorPane Editor de texto. Normalmente HTML o RTF. JFileChooser Selector de ficheros. JLabel Etiqueta. JList Lista. JMenu Men\u00fa dentro de un JMenuBar o dentro de otro men\u00fa. JMenuBar Barra de Men\u00fas. JMenuItem Elemento seleccionable en un men\u00fa. JOptionPane Ventanas de dialogo. JPasswordField Entrada de passwords. JPopupMenu Ventana con un men\u00fa. JProgressBar Barra de progreso. JRadioButton Bot\u00f3n excluyente. JRadioButtonMenuItem Bot\u00f3n excluyente para usar en men\u00fas JScrollBar Barra de desplazamiento. JSeparator L\u00edneas de separaci\u00f3n. JSlider Deslizador. JTable Tabla. JTextArea Edici\u00f3n de m\u00faltiples l\u00edneas de texto plano. JTextComponent Ra\u00edz de los editores de texto. JTextField Edici\u00f3n de una l\u00ednea de texto plano. JTextPane Subclase de JEditorPane para hacer procesadores de texto. JToggleButton Padre de JCheckBox y JRadioButton. JToolBar Barra de herramientas o acciones. JToolTip Ventana informativa. JTree \u00c1rboles."},{"location":"bloque_vi/tema_32/page-2/#componentes-de-tablas","title":"Componentes de tablas","text":"<p><code>JTable</code> es un componente de la biblioteca Swing que permite mostrar datos en forma de una tabla. Es altamente personalizable y puede mostrar datos en forma de filas y columnas. Es especialmente \u00fatil cuando necesitas mostrar grandes cantidades de datos en una interfaz de usuario de manera organizada y estructurada.</p> <p>El constructor recibe una matriz con los datos y un array con el nombre de las columnas.</p> <p>Algunos de sus m\u00e9todos m\u00e1s importantes son:</p> <ul> <li><code>void setModel(TableModel dataModel)</code>: Establece el modelo de datos para la tabla. El modelo debe implementar la interfaz <code>TableModel</code>, como <code>DefaultTableModel</code> o <code>AbstractTableModel</code>.</li> <li><code>void setSelectionMode(int selectionMode)</code>: Establece el modo de selecci\u00f3n de celdas. Los valores posibles son <code>ListSelectionModel.SINGLE_SELECTION</code>, <code>ListSelectionModel.SINGLE_INTERVAL_SELECTION</code> y <code>ListSelectionModel.MULTIPLE_INTERVAL_SELECTION.</code></li> <li><code>void setShowGrid(boolean showGrid)</code>:Establece si se debe mostrar o no la cuadr\u00edcula que separa las celdas.</li> <li><code>void setAutoResizeMode(int mode)</code>: Establece el modo de ajuste autom\u00e1tico del ancho de las columnas. Los valores posibles son <code>JTable.AUTO_RESIZE_OFF</code>, <code>JTable.AUTO_RESIZE_NEXT_COLUMN</code>, <code>JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS</code> y <code>JTable.AUTO_RESIZE_LAST_COLUMN</code>.</li> <li><code>void setRowHeight(int row, int rowHeight)</code>: Establece la altura de una fila espec\u00edfica.</li> <li><code>void setValueAt(Object value, int row, int column)</code>: Establece el valor de una celda en la posici\u00f3n especificada.</li> <li><code>void addRow(Object[] rowData)</code>: Agrega una nueva fila con los datos especificados al final del modelo de datos de la tabla.</li> <li><code>void removeRow(int row)</code>: Elimina la fila en la posici\u00f3n especificada del modelo de datos de la tabla.</li> <li><code>int getSelectedRow()</code>:Devuelve el \u00edndice de la fila seleccionada. Si no hay ninguna fila seleccionada, devuelve -1.</li> <li><code>Object getValueAt(int row, int column)</code>:Devuelve el valor de la celda en la posici\u00f3n especificada</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>public class JTableExample {\n    public void show() {\n        JFrame frame = new JFrame(\"Ejemplo de JTable\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        Object[][] data = {\n                {\"John\", 25, \"Developer\"},\n                {\"Alice\", 30, \"Designer\"},\n                {\"Bob\", 35, \"Manager\"}\n        };\n\n        String[] columnNames = {\"Nombre\", \"Edad\", \"Cargo\"};\n\n        JTable table = new JTable(data, columnNames);\n        frame.getContentPane().add(table);\n\n\n        frame.setSize(400, 300);\n        frame.setLocationRelativeTo(null); // Centrar la ventana en la pantalla\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new JTableExample().show();\n    }\n}\n</code></pre> <p>Para lograr que una celda ocupe dos filas en una JTable, necesitamos personalizar el renderizado de esa celda espec\u00edfica. Podemos hacerlo creando una clase personalizada que extienda JTable y sobrescriba el m\u00e9todo prepareRenderer() para manejar el renderizado de la celda.</p>"},{"location":"bloque_vi/tema_32/page-2/#proyecto-components","title":"Proyecto Components","text":"<pre><code>public class ComponentsExample {\n    public void show() {\n        // Crear el JFrame\n        JFrame frame = new JFrame(\"Ejemplo de Componentes Swing\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // Crear un JPanel para contener los componentes\n        JPanel panel = new JPanel();\n        panel.setLayout(new GridLayout(4, 2)); // 4 filas, 2 columnas\n\n        // Crear etiquetas\n        JLabel nameLabel = new JLabel(\"Nombre:\");\n        JLabel ageLabel = new JLabel(\"Edad:\");\n\n        // Crear campos de texto\n        JTextField nameField = new JTextField(20);\n        JTextField ageField = new JTextField(5);\n\n        // Crear un \u00e1rea de texto\n        JTextArea descriptionArea = new JTextArea(5, 20);\n        descriptionArea.setLineWrap(true);\n        JScrollPane scrollPane = new JScrollPane(descriptionArea);\n\n        // Crear botones\n        JButton submitButton = new JButton(\"Enviar\");\n        JButton clearButton = new JButton(\"Limpiar\");\n\n        // A\u00f1adir componentes al panel\n        panel.add(nameLabel);\n        panel.add(nameField);\n        panel.add(ageLabel);\n        panel.add(ageField);\n        panel.add(new JLabel(\"Descripci\u00f3n:\"));\n        panel.add(scrollPane);\n        panel.add(submitButton);\n        panel.add(clearButton);\n\n        // A\u00f1adir el panel al JFrame\n        frame.add(panel);\n\n        // Ajustar el tama\u00f1o del JFrame y hacerlo visible\n        frame.pack();\n        frame.setLocationRelativeTo(null); // Centrar la ventana en la pantalla\n        frame.setVisible(true);\n\n    }\n\n    public static void main(String[] args) {\n        new ComponentsExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-2/#menus","title":"Men\u00fas","text":"<p>En Java Swing, la clase <code>JMenu</code> representa un componente que se utiliza para crear men\u00fas desplegables en una interfaz de usuario. Un JMenu puede contener elementos de men\u00fa, como opciones, submen\u00fas u otros componentes Swing.</p> <ul> <li>Elementos de Men\u00fa: Puedes a\u00f1adir elementos de men\u00fa, como JMenuItem, a un JMenu para crear las opciones que se mostrar\u00e1n cuando el usuario haga clic en \u00e9l.</li> <li>Submen\u00fas: Tambi\u00e9n puedes a\u00f1adir otros JMenu como elementos de un JMenu, lo que te permite crear submen\u00fas y organizar las opciones en una jerarqu\u00eda.</li> <li>Atajos de Teclado: Los elementos de men\u00fa pueden tener atajos de teclado asociados, permitiendo al usuario activar la opci\u00f3n del men\u00fa utilizando combinaciones de teclas.</li> <li>Iconos: Puedes a\u00f1adir iconos a los elementos de men\u00fa para proporcionar una representaci\u00f3n visual de las opciones.</li> <li>Eventos de Acci\u00f3n: Puedes registrar ActionListeners en los elementos de men\u00fa para manejar eventos de acci\u00f3n cuando el usuario selecciona una opci\u00f3n del men\u00fa.</li> </ul> <p>Um <code>JMenuBar</code> es una clase que representa un menu bar de nuestra aplicaci\u00f3n. A esta clase se le pueden a\u00f1adir los diferentes men\u00fas de <code>JMenu</code>. La clase <code>JMenuItem</code> representan los items de un men\u00fa de <code>JMenu</code>. Veamos un ejemplo:</p> <pre><code>public class MenuExample {\n\n    public void show(){\n        // Crear un JFrame\n        JFrame frame = new JFrame(\"Ejemplo de Men\u00fa\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // Crear la barra de men\u00fa\n        JMenuBar menuBar = new JMenuBar();\n\n        // Crear el men\u00fa \"Archivo\" y sus elementos de men\u00fa\n        JMenu fileMenu = new JMenu(\"Archivo\");\n        JMenuItem newItem = new JMenuItem(\"Nuevo\");\n        JMenuItem openItem = new JMenuItem(\"Abrir\");\n        JMenuItem saveItem = new JMenuItem(\"Guardar\");\n        JMenuItem exitItem = new JMenuItem(\"Salir\");\n\n        // Agregar elementos de men\u00fa al men\u00fa \"Archivo\"\n        fileMenu.add(newItem);\n        fileMenu.add(openItem);\n        fileMenu.add(saveItem);\n        fileMenu.addSeparator(); // Separador\n        fileMenu.add(exitItem);\n\n        // Crear el men\u00fa \"Ayuda\" y sus elementos de men\u00fa\n        JMenu helpMenu = new JMenu(\"Ayuda\");\n        JMenuItem aboutItem = new JMenuItem(\"Acerca de\");\n\n        // Agregar elementos de men\u00fa al men\u00fa \"Ayuda\"\n        helpMenu.add(aboutItem);\n\n        // Agregar men\u00fas a la barra de men\u00fa\n        menuBar.add(fileMenu);\n        menuBar.add(helpMenu);\n\n        // Configurar el ActionListener para el elemento de men\u00fa \"Salir\"\n        exitItem.addActionListener(e -&gt; System.exit(0));\n\n        // Agregar la barra de men\u00fa al JFrame\n        frame.setJMenuBar(menuBar);\n\n        // Ajustar el tama\u00f1o del JFrame y hacerlo visible\n        frame.setSize(300, 200);\n        frame.setLocationRelativeTo(null); // Centrar la ventana en la pantalla\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new MenuExample().show();\n    }\n}\n</code></pre> <p>Se le puede a\u00f1adir un men\u00fa a un componente haciendo uso de la clase <code>JPopMen\u00fa</code>, que simula un men\u00fa que suele ser mostrador a clicar sobre el componente con el bot\u00f3n derecho del rat\u00f3n. Veamos un ejemplo:</p> <pre><code>public class PopMenuExample {\n    public void show() {\n\n        // Crear un JFrame\n        JFrame frame = new JFrame(\"Ejemplo de Men\u00fa en Componente\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // Crear un bot\u00f3n\n        JButton button = new JButton(\"Haz clic aqu\u00ed\");\n\n        // Crear un JPopupMenu con elementos de men\u00fa\n        JPopupMenu popupMenu = new JPopupMenu();\n        JMenuItem menuItem1 = new JMenuItem(\"Opci\u00f3n 1\");\n        JMenuItem menuItem2 = new JMenuItem(\"Opci\u00f3n 2\");\n        popupMenu.add(menuItem1);\n        popupMenu.add(menuItem2);\n\n        // Asociar el JPopupMenu al bot\u00f3n\n        button.setComponentPopupMenu(popupMenu);\n\n        // A\u00f1adir el bot\u00f3n al JFrame\n        frame.add(button);\n\n        // Ajustar el tama\u00f1o del JFrame y hacerlo visible\n        frame.setSize(300, 200);\n        frame.setLocationRelativeTo(null); // Centrar la ventana en la pantalla\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new PopMenuExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-3/","title":"3 Componentes","text":""},{"location":"bloque_vi/tema_32/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Al igual que en AWT, los componentes de Swing siguen las reglas de dise\u00f1o Java Bean, pudiendo configurar las propiedades deseadas. En Swing existen diferentes tipos de componentes, similares a los que hemos visto en AWT.</p>"},{"location":"bloque_vi/tema_32/page-3/#etiquetas","title":"Etiquetas","text":"<p>La clase <code>JLabel</code> representa una etiqueta.</p> <pre><code>JLabel label = new JLabel(\"Hello World!\")\n</code></pre>"},{"location":"bloque_vi/tema_32/page-3/#jtextfield","title":"JTextField","text":"<p>La clase <code>JTextField</code> representa un campo de texto de una \u00fanica l\u00ednea, donde el usuario puede ingresar datos.</p> <pre><code>JTextField = new JTextField(20)\n</code></pre>"},{"location":"bloque_vi/tema_32/page-3/#jtextarea","title":"JTextArea","text":"<p>La clase <code>JTextArea</code> representa un \u00e1rea de texto de m\u00faltiples l\u00edneas.</p> <pre><code>JTextArea textArea = new JTextArea(5, 20);\n</code></pre>"},{"location":"bloque_vi/tema_32/page-3/#jbutton","title":"JButton","text":"<p>La clase <code>JButton</code> representa</p>"},{"location":"bloque_vi/tema_32/page-4/","title":"4 Contenedores","text":""},{"location":"bloque_vi/tema_32/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos visto, existen diferentes componentes en Swing. Los contenedores son unos componentes especiales encargados de agrupar otros componentes. El <code>JFrame</code> tiene por defecto un <code>ContentPane</code> como contenedor que puede ser modificado por cualquier otro componente.</p> <p>Entre los contenedores m\u00e1s comunes de Swing, encontramos:</p> <ul> <li><code>JFrame</code>: Es el contenedor de nivel superior m\u00e1s utilizado en una aplicaci\u00f3n Swing. Representa una ventana con un borde, un t\u00edtulo, botones de cierre y maximizaci\u00f3n, etc.</li> <li><code>JPanel</code>: Es un contenedor gen\u00e9rico que se utiliza para organizar y agrupar otros componentes. Puede actuar como un contenedor para otros paneles o para componentes individuales.</li> <li><code>JDialog</code>: Similar a un JFrame, pero se utiliza para crear cuadros de di\u00e1logo modales o no modales.</li> <li><code>JApplet</code>: Es un contenedor espec\u00edfico para las applets de Java, aunque su uso ha disminuido significativamente en favor de las aplicaciones Java independientes.</li> <li><code>JScrollPane</code>: Es un contenedor especializado que proporciona barras de desplazamiento para ver contenido que no cabe completamente dentro del \u00e1rea visible.</li> <li><code>JTabbedPane</code>: Organiza los componentes secundarios en pesta\u00f1as, permitiendo al usuario cambiar entre diferentes conjuntos de componentes.</li> <li><code>JSplitPane</code>: Divide el \u00e1rea disponible en dos (horizontal o verticalmente) y permite al usuario ajustar el tama\u00f1o relativo de las dos \u00e1reas.</li> <li><code>JToolBar</code>: Es un contenedor que normalmente se encuentra en la parte superior de una ventana y contiene botones u otros componentes para realizar acciones comunes.</li> <li><code>JDesktopPane</code> y <code>JInternalFrame</code>: Estos contenedores se utilizan para crear interfaces de m\u00faltiples ventanas, donde las ventanas internas (<code>JInternalFrame</code>) se pueden mover y redimensionar dentro del \u00e1rea de trabajo (<code>JDesktopPane</code>).</li> </ul>"},{"location":"bloque_vi/tema_32/page-4/#jpanel","title":"JPanel","text":"<p><code>JPanel</code> es una clase en Java Swing que act\u00faa como un contenedor gen\u00e9rico para organizar y agrupar otros componentes Swing. Funciona como un lienzo en el que puedes colocar y organizar varios componentes, como botones, etiquetas, campos de texto, etc. Los paneles se utilizan com\u00fanmente para dividir la interfaz de usuario en secciones l\u00f3gicas y para aplicar dise\u00f1os espec\u00edficos a grupos de componentes.</p> <pre><code>public class JPanelExample {\n    public void show() {\n        // Crear un JFrame\n        JFrame frame = new JFrame(\"Ejemplo de JPanel\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // Crear un JPanel\n        JPanel panel = new JPanel();\n        panel.setBackground(Color.WHITE);\n\n        // A\u00f1adir componentes al panel\n        JLabel label = new JLabel(\"Hola, mundo!\");\n        JButton button = new JButton(\"Haz clic aqu\u00ed\");\n        panel.add(label);\n        panel.add(button);\n\n        // A\u00f1adir el panel al JFrame\n        frame.getContentPane().add(panel);\n\n        // Ajustar el tama\u00f1o del JFrame y hacerlo visible\n        frame.setSize(300, 200);\n        frame.setLocationRelativeTo(null); // Centrar la ventana en la pantalla\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new JPanelExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-4/#jdialog","title":"JDialog","text":"<p><code>JDialog</code> es una clase en Java Swing que representa un cuadro de di\u00e1logo en una aplicaci\u00f3n. Se utiliza para mostrar mensajes, solicitar informaci\u00f3n al usuario o realizar acciones que requieren su atenci\u00f3n. Un <code>JDialog</code> puede ser modal o no modal, lo que significa que puede bloquear o no bloquear la interacci\u00f3n con otras ventanas de la aplicaci\u00f3n mientras est\u00e1 abierto.</p> <p>Un <code>JDialog</code> modal bloquea la interacci\u00f3n con otras ventanas de la aplicaci\u00f3n hasta que se cierra. Esto es \u00fatil para alertas importantes o solicitudes de informaci\u00f3n cr\u00edtica que requieren la atenci\u00f3n inmediata del usuario.</p> <pre><code>public class JDialogExample {\n\n    public void show(){\n        // Crear un JFrame\n        JFrame frame = new JFrame(\"Ejemplo de JDialog\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // Crear un JButton para mostrar el cuadro de di\u00e1logo\n        JButton button = new JButton(\"Mostrar Di\u00e1logo\");\n        button.addActionListener(e -&gt; {\n            // Crear un JDialog modal\n            JDialog dialog = new JDialog(frame, \"Cuadro de Di\u00e1logo\", true);\n\n            // A\u00f1adir un JLabel al cuadro de di\u00e1logo\n            JLabel label = new JLabel(\"\u00a1Hola desde el cuadro de di\u00e1logo!\");\n            dialog.add(label);\n\n            // Establecer el tama\u00f1o del cuadro de di\u00e1logo\n            dialog.setSize(200, 100);\n\n            // Hacer visible el cuadro de di\u00e1logo\n            dialog.setVisible(true);\n        });\n\n        // A\u00f1adir el JButton al JFrame\n        frame.getContentPane().add(button);\n\n        // Ajustar el tama\u00f1o del JFrame y hacerlo visible\n        frame.setSize(300, 200);\n        frame.setLocationRelativeTo(null); // Centrar la ventana en la pantalla\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new JDialogExample().show();\n    }\n\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-4/#jscrollpane","title":"JScrollPane","text":"<p><code>JScrollPane</code> es un contenedor especializado en Java Swing que proporciona barras de desplazamiento para permitir al usuario desplazarse por el contenido que no cabe completamente dentro del \u00e1rea visible del contenedor. Se utiliza com\u00fanmente para mostrar componentes que contienen grandes cantidades de datos, como listas largas, tablas extensas o \u00e1reas de texto grandes. <code>JScrollPane</code> agrega barras de desplazamiento vertical y horizontal autom\u00e1ticamente cuando el contenido del componente supera el tama\u00f1o del \u00e1rea visible.</p> <p>Permite al usuario desplazarse suavemente por el contenido utilizando las barras de desplazamiento o, en el caso de dispositivos con pantalla t\u00e1ctil, mediante gestos de desplazamiento. Se puede personalizar el comportamiento y la apariencia de las barras de desplazamiento utilizando m\u00e9todos como <code>setVerticalScrollBarPolicy(int policy)</code> y <code>setHorizontalScrollBarPolicy(int policy)</code>.</p> <pre><code>public class JScrollPaneExample {\n    public void show() {\n        // Crear un JFrame\n        JFrame frame = new JFrame(\"Ejemplo de JScrollPane\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // Crear un JTextArea con un texto largo\n        JTextArea textArea = new JTextArea(10, 20);\n        for (int i = 0; i &lt; 100; i++) {\n            textArea.append(\"L\u00ednea \" + (i + 1) + \"\\n\");\n        }\n\n        // Crear un JScrollPane con el JTextArea como contenido\n        JScrollPane scrollPane = new JScrollPane(textArea);\n\n        // A\u00f1adir el JScrollPane al JFrame\n        frame.getContentPane().add(scrollPane);\n\n        // Ajustar el tama\u00f1o del JFrame y hacerlo visible\n        frame.setSize(300, 200);\n        frame.setLocationRelativeTo(null); // Centrar la ventana en la pantalla\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new JScrollPaneExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-4/#jtabbedpane","title":"JTabbedPane","text":"<p><code>JTabbedPane</code> es un componente en Java Swing que permite a los desarrolladores organizar la interfaz de usuario en pesta\u00f1as, cada una de las cuales puede contener su propio conjunto de componentes. Este componente es muy \u00fatil para presentar diferentes vistas o secciones de una aplicaci\u00f3n de manera organizada y accesible. Cada pesta\u00f1a puede contener cualquier componente Swing, como paneles, botones, etiquetas, campos de texto, etc.</p> <p>Las pesta\u00f1as pueden colocarse en diferentes posiciones (<code>TOP</code>, <code>BOTTOM</code>, <code>LEFT</code>, <code>RIGHT</code>) utilizando el m\u00e9todo <code>setTabPlacement(int tabPlacement)</code>.  Puedes a\u00f1adir iconos y t\u00edtulos a las pesta\u00f1as para una identificaci\u00f3n visual m\u00e1s f\u00e1cil utilizando los m\u00e9todos <code>addTab(String title, Icon icon, Component component)</code> y variantes.</p> <p>Puedes a\u00f1adir <code>ChangeListener</code> para manejar eventos de cambio de pesta\u00f1a, lo que te permite ejecutar c\u00f3digo cuando el usuario cambia de una pesta\u00f1a a otra.</p> <pre><code>public class JTabbedPaneExample {\n    public void show() {\n        // Crear un JFrame\n        JFrame frame = new JFrame(\"Ejemplo de JTabbedPane\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(400, 300);\n        frame.setLocationRelativeTo(null); // Centrar la ventana en la pantalla\n\n        // Crear un JTabbedPane\n        JTabbedPane tabbedPane = new JTabbedPane();\n\n        // Crear paneles para las pesta\u00f1as\n        JPanel panel1 = new JPanel();\n        panel1.add(new JLabel(\"Contenido de la Pesta\u00f1a 1\"));\n\n        JPanel panel2 = new JPanel();\n        panel2.add(new JLabel(\"Contenido de la Pesta\u00f1a 2\"));\n\n        JPanel panel3 = new JPanel();\n        panel3.add(new JLabel(\"Contenido de la Pesta\u00f1a 3\"));\n\n        // A\u00f1adir las pesta\u00f1as al JTabbedPane\n        tabbedPane.addTab(\"Pesta\u00f1a 1\", panel1);\n        tabbedPane.addTab(\"Pesta\u00f1a 2\", panel2);\n        tabbedPane.addTab(\"Pesta\u00f1a 3\", panel3);\n\n        // A\u00f1adir el JTabbedPane al JFrame\n        frame.getContentPane().add(tabbedPane, BorderLayout.CENTER);\n\n        // Hacer visible el JFrame\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new JTabbedPaneExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-4/#jsplitpane","title":"JSplitPane","text":"<p><code>JSplitPane</code> es un componente de Java Swing que divide el \u00e1rea de visualizaci\u00f3n en dos componentes ajustables. Estos componentes pueden ser organizados horizontal o verticalmente y el usuario puede cambiar el tama\u00f1o de cada \u00e1rea arrastrando el divisor. <code>JSplitPane</code> es \u00fatil cuando se necesita presentar dos componentes que el usuario puede querer ver simult\u00e1neamente pero ajustar el tama\u00f1o relativo de cada uno seg\u00fan sus necesidades.</p> <p>Se puedes configurar el <code>JSplitPane</code> para que divida los componentes horizontalmente (<code>JSplitPane.HORIZONTAL_SPLIT</code>) o verticalmente (<code>JSplitPane.VERTICAL_SPLIT</code>). El divisor entre los dos componentes es ajustable por el usuario, permitiendo cambiar el tama\u00f1o de las \u00e1reas de visualizaci\u00f3n.</p> <p>Se puede establecer la posici\u00f3n inicial del divisor utilizando el m\u00e9todo <code>setDividerLocation(int location)</code>. Tambi\u00e9n se puede bloquear el divisor para evitar que el usuario cambie el tama\u00f1o de las \u00e1reas de visualizaci\u00f3n utilizando el m\u00e9todo <code>setEnabled(boolean enabled)</code>.</p> <p>Adem\u00e1s se puede a\u00f1adir <code>PropertyChangeListener</code> para manejar eventos cuando cambia la posici\u00f3n del divisor.</p> <pre><code>public class JSplitPaneExample {\n\n    public void show(){\n        // Crear un JFrame\n        JFrame frame = new JFrame(\"Ejemplo de JSplitPane\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(500, 300);\n        frame.setLocationRelativeTo(null); // Centrar la ventana en la pantalla\n\n        // Crear dos paneles para dividir\n        JPanel leftPanel = new JPanel();\n        leftPanel.setBackground(Color.CYAN);\n        leftPanel.add(new JLabel(\"Panel Izquierdo\"));\n\n        JPanel rightPanel = new JPanel();\n        rightPanel.setBackground(Color.LIGHT_GRAY);\n        rightPanel.add(new JLabel(\"Panel Derecho\"));\n\n        // Crear un JSplitPane con divisi\u00f3n horizontal\n        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, leftPanel, rightPanel);\n        splitPane.setDividerLocation(150); // Posici\u00f3n inicial del divisor\n\n        // A\u00f1adir el JSplitPane al JFrame\n        frame.getContentPane().add(splitPane);\n\n        // Hacer visible el JFrame\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new JSplitPaneExample().show();\n    }\n\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-4/#jtoolbar","title":"JToolbar","text":"<p><code>JToolBar</code> es un componente en Java Swing que se utiliza para crear barras de herramientas en la interfaz de usuario. Estas barras de herramientas suelen contener botones, iconos y otros componentes interactivos que permiten al usuario realizar acciones comunes o acceder r\u00e1pidamente a funciones espec\u00edficas de la aplicaci\u00f3n. <code>JToolBar</code> puede ser flotante o anclado a los bordes de un contenedor, como un <code>JFrame</code>. Puede ser orientado horizontalmente (<code>JToolBar.HORIZONTAL</code>) o verticalmente (<code>JToolBar.VERTICAL</code>). Adem\u00e1s puede a\u00f1adir separadores (<code>JToolBar.Separator</code>) para organizar los componentes en grupos l\u00f3gicos.</p> <pre><code>public class JToolbar {\n    public void show() {\n        JFrame frame = new JFrame(\"Ejemplo de JToolBar\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(400, 300);\n        frame.setLocationRelativeTo(null); // Centrar la ventana en la pantalla\n\n        // Crear un JToolBar\n        JToolBar toolBar = new JToolBar();\n        toolBar.setFloatable(true); // Permitir que la barra de herramientas sea flotante\n\n        // Crear botones para la barra de herramientas\n        JButton newButton = new JButton(new ImageIcon(\"icons/new.png\")); // Aseg\u00farate de tener un icono llamado \"new.png\"\n        newButton.setToolTipText(\"Nuevo\");\n        toolBar.add(newButton);\n\n        JButton openButton = new JButton(new ImageIcon(\"icons/open.png\")); // Aseg\u00farate de tener un icono llamado \"open.png\"\n        openButton.setToolTipText(\"Abrir\");\n        toolBar.add(openButton);\n\n        JButton saveButton = new JButton(new ImageIcon(\"icons/save.png\")); // Aseg\u00farate de tener un icono llamado \"save.png\"\n        saveButton.setToolTipText(\"Guardar\");\n        toolBar.add(saveButton);\n\n        // A\u00f1adir un separador\n        toolBar.addSeparator();\n\n        // A\u00f1adir otro bot\u00f3n\n        JButton exitButton = new JButton(new ImageIcon(\"icons/exit.png\")); // Aseg\u00farate de tener un icono llamado \"exit.png\"\n        exitButton.setToolTipText(\"Salir\");\n        toolBar.add(exitButton);\n\n        // A\u00f1adir ActionListener para el bot\u00f3n de salir\n        exitButton.addActionListener(e -&gt; System.exit(0));\n\n        // A\u00f1adir el JToolBar al JFrame\n        frame.getContentPane().add(toolBar, \"North\"); // A\u00f1adir la barra de herramientas en la parte superior\n\n        // Hacer visible el JFrame\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new JToolbar().show();\n    }\n}\n</code></pre> <p>Se puede hacer flotante haciendo uso del m\u00e9todo <code>setFlotable(boolean)</code>.</p>"},{"location":"bloque_vi/tema_32/page-4/#jdesktoppane-y-jinternalframe","title":"JDesktopPane y JInternalFrame","text":"<p><code>JDesktopPane</code> y <code>JInternalFrame</code> son componentes de Java Swing que se utilizan para crear aplicaciones que tienen m\u00faltiples documentos o ventanas internas, similares a un entorno de escritorio. Estos componentes son \u00fatiles para implementar el patr\u00f3n MDI (Multiple Document Interface), donde una sola ventana principal contiene varias sub-ventanas internas que pueden ser gestionadas de forma independiente.</p> <p><code>JDesktopPane</code> es un contenedor que act\u00faa como el escritorio virtual sobre el cual se pueden colocar m\u00faltiples <code>JInternalFrame</code>. Es similar a la ventana de un sistema operativo donde se pueden abrir y organizar varias ventanas internas. Con la propiedad <code>Z-Order</code>  se puede gestionar la superposici\u00f3n de las ventanas internas, controlando cu\u00e1l est\u00e1 en primer plano.</p> <p><code>JInternalFrame</code> es un componente similar a JFrame, pero dise\u00f1ado para ser utilizado dentro de un <code>JDesktopPane</code>. Tiene la apariencia y el comportamiento de una ventana interna, incluyendo bordes, barra de t\u00edtulo y botones de control (cerrar, minimizar, maximizar).</p>"},{"location":"bloque_vi/tema_32/page-5/","title":"5 Layouts","text":""},{"location":"bloque_vi/tema_32/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya vimos en el tema anterior \u00f1os layouts son gestores de dise\u00f1o que determinan c\u00f3mo se organizan los componentes dentro de un contenedor. Java Swing proporciona varios tipos de layouts que permiten a los desarrolladores organizar los componentes de una forma flexible y adaptable a diferentes tama\u00f1os y resoluciones de pantalla. Entender y utilizar los diferentes tipos de layouts es crucial para crear interfaces de usuario efectivas y visualmente atractivas.</p>"},{"location":"bloque_vi/tema_32/page-5/#flowlayout","title":"FlowLayout","text":"<p><code>FlowLayout</code> organiza los componentes en una l\u00ednea, uno al lado del otro, hasta que no hay m\u00e1s espacio, luego pasa a la siguiente l\u00ednea. Es el layout predeterminado para los paneles (<code>JPanel</code>).</p> <p>Se puede indicar la alineaci\u00f3n (<code>LEFT</code>, <code>RIGHT</code>, <code>CENTER</code>) y el espacio vertical y horizontal de los elementos. Este layout no proviene del paquete Swing, si no del paquete AWT.</p> <pre><code>public class FlowLayoutExample {\n    public void show() {\n        JFrame frame = new JFrame(\"FlowLayout Example\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(300, 200);\n\n        JPanel panel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 20));\n        panel.add(new JButton(\"Button 1\"));\n        panel.add(new JButton(\"Button 2\"));\n        panel.add(new JButton(\"Button 3\"));\n\n        frame.add(panel);\n        frame.setVisible(true);\n\n    }\n\n    public static void main(String[] args) {\n        new FlowLayoutExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-5/#borderlayout","title":"BorderLayout","text":"<p><code>BorderLayout</code> divide el contenedor en cinco \u00e1reas: norte (<code>NORTH</code>), sur (<code>SOUTH</code>), este (<code>EAST</code>), oeste (<code>WEST</code>) y centro (<code>CENTER</code>). Es el layout predeterminado para los frames (<code>JFrame</code>). El \u00e1rea central se expande para llenar el espacio restante.</p> <pre><code>public class BorderLayoutExample {\n    public void show() {\n        JFrame frame = new JFrame(\"BorderLayout Example\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(300, 200);\n\n        frame.setLayout(new BorderLayout());\n        frame.add(new JButton(\"NORTH\"), BorderLayout.NORTH);\n        frame.add(new JButton(\"SOUTH\"), BorderLayout.SOUTH);\n        frame.add(new JButton(\"EAST\"), BorderLayout.EAST);\n        frame.add(new JButton(\"WEST\"), BorderLayout.WEST);\n        frame.add(new JButton(\"CENTER\"), BorderLayout.CENTER);\n\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new BorderLayoutExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-5/#gridlayout","title":"GridLayout","text":"<p><code>GridLayout</code> organiza los componentes en una cuadr\u00edcula con un n\u00famero fijo de filas y columnas. Todos los componentes tienen el mismo tama\u00f1o.</p> <pre><code>public class GridLayoutExample {\n    public void show() {\n        JFrame frame = new JFrame(\"GridLayout Example\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(300, 200);\n\n        frame.setLayout(new GridLayout(2, 3, 5, 5)); // 2 filas, 3 columnas, espacio de 5 p\u00edxeles entre componentes\n        frame.add(new JButton(\"Button 1\"));\n        frame.add(new JButton(\"Button 2\"));\n        frame.add(new JButton(\"Button 3\"));\n        frame.add(new JButton(\"Button 4\"));\n        frame.add(new JButton(\"Button 5\"));\n        frame.add(new JButton(\"Button 6\"));\n\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new GridLayoutExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-5/#boxlayout","title":"BoxLayout","text":"<p><code>BoxLayout</code> coloca los componentes en una sola fila (<code>X_AXIS</code>) o en una sola columna (<code>Y_AXIS</code>).</p> <p>Con el m\u00e9todo est\u00e1tico <code>Box.createRigidArea(dimension)</code> crea un espacio fijo. Es usado para separar los componentes, tanto vertical como horizontal, dependiendo de la orientaci\u00f3n del layout. Si por el contrario, se quiere una separaci\u00f3n extensible (que se extienda hasta el final) se puede usar el m\u00e9todo est\u00e1tico <code>Box.createVerticalGlue()</code> para el espaciado vertical, o <code>createHorizontalGlue()</code> para el horizontal.</p> <pre><code>public class BoxLayoutExample {\n\n    public void show(){\n        JFrame frame = new JFrame(\"BoxLayout Example\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(300, 200);\n\n        JPanel panel = new JPanel();\n        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\n        panel.add(new JButton(\"Button 1\"));\n        panel.add(Box.createRigidArea(new Dimension(0, 5))); // Espacio vertical fijo\n        panel.add(new JButton(\"Button 2\"));\n        panel.add(Box.createVerticalGlue()); // Espacio vertical expansible\n        panel.add(new JButton(\"Button 3\"));\n\n        frame.add(panel);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new BoxLayoutExample().show();\n    }\n\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-5/#cardlayout","title":"CardLayout","text":"<p><code>CardLayout</code> permite apilar varios componentes uno encima del otro y mostrar solo uno a la vez, similar a un conjunto de tarjetas (de ah\u00ed su nombre). Puedes navegar entre diferentes \"tarjetas\" (componentes) utilizando m\u00e9todos como <code>next()</code>, <code>previous()</code>, <code>first()</code>, <code>last()</code>, y <code>show()</code>.</p> <pre><code>public class CardLayoutExample {\n\n    public void show(){\n        JFrame frame = new JFrame(\"CardLayout Example\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(300, 200);\n\n        CardLayout cardLayout = new CardLayout();\n        JPanel cardPanel = new JPanel(cardLayout);\n\n        JPanel card1 = new JPanel();\n        card1.add(new JLabel(\"Card 1\"));\n        cardPanel.add(card1, \"Card 1\");\n\n        JPanel card2 = new JPanel();\n        card2.add(new JLabel(\"Card 2\"));\n        cardPanel.add(card2, \"Card 2\");\n\n        JPanel card3 = new JPanel();\n        card3.add(new JLabel(\"Card 3\"));\n        cardPanel.add(card3, \"Card 3\");\n\n        JPanel controlPanel = new JPanel();\n        JButton nextButton = new JButton(\"Next\");\n        controlPanel.add(nextButton);\n\n        nextButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cardLayout.next(cardPanel);\n            }\n        });\n\n        frame.setLayout(new BorderLayout());\n        frame.add(cardPanel, BorderLayout.CENTER);\n        frame.add(controlPanel, BorderLayout.SOUTH);\n\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new CardLayoutExample().show();\n    }\n\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-5/#gridbaglayout","title":"GridBagLayout","text":"<p><code>GridBagLayout</code> es el layout m\u00e1s complejo y flexible, permitiendo organizar componentes en una cuadr\u00edcula de celdas, donde cada componente puede ocupar m\u00faltiples celdas y tener diferentes tama\u00f1os.</p> <p>La clase <code>GridBagConstraints</code> nos permite indica la posici\u00f3n de la cuadricula en la que queremos a\u00f1adir los componentes, as\u00ed como cuantas celdas se desea ocupar:</p> <pre><code>public class GridBagLayoutExample {\n    public void show() {\n        JFrame frame = new JFrame(\"GridBagLayout Example\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(300, 200);\n\n        frame.setLayout(new GridBagLayout());\n        GridBagConstraints gbc = new GridBagConstraints();\n\n        JButton button1 = new JButton(\"Button 1\");\n        gbc.gridx = 0;\n        gbc.gridy = 0;\n        frame.add(button1, gbc);\n\n        JButton button2 = new JButton(\"Button 2\");\n        gbc.gridx = 1;\n        gbc.gridy = 0;\n        frame.add(button2, gbc);\n\n        JButton button3 = new JButton(\"Button 3\");\n        gbc.gridx = 0;\n        gbc.gridy = 1;\n        gbc.gridwidth = 2;\n        frame.add(button3, gbc);\n\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new GridBagLayoutExample().show();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-6/","title":"6 Multihilo","text":""},{"location":"bloque_vi/tema_32/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Crear una aplicaci\u00f3n Swing que soporte m\u00faltiples hilos (multithreading) implica manejar correctamente las actualizaciones de la interfaz de usuario para evitar problemas de concurrencia y asegurar una experiencia de usuario fluida. Swing no es seguro para el uso de hilos, lo que significa que todas las actualizaciones de la interfaz de usuario deben realizarse en el Event Dispatch Thread (EDT).</p> <p>EL EDT es el hilo donde se deben ejecutar todas las actualizaciones de la interfaz de usuario. Manipular componentes de Swing desde cualquier otro hilo puede causar problemas impredecibles.</p> <p>El <code>SwingWorker</code> es una clase conveniente para realizar tareas en segundo plano sin bloquear el EDT. Permite ejecutar tareas en un hilo separado y actualizar la interfaz de usuario de forma segura.</p> <p><code>SwingUtilities.invokeLater()</code> es un m\u00e9todo \u00fatil para ejecutar c\u00f3digo en el EDT.</p>"},{"location":"bloque_vi/tema_32/page-6/#proyecto-multithreading","title":"Proyecto Multithreading","text":"<pre><code>public class MultithreadingExample {\n\n    private JFrame frame;\n    private JButton startButton;\n    private JLabel statusLabel;\n    private JProgressBar progressBar;\n\n    public MultithreadingExample() {\n        // Crear el marco\n        frame = new JFrame(\"Multithreading in Swing\");\n        frame.setSize(400, 200);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setLocationRelativeTo(null);\n        frame.setLayout(new FlowLayout());\n\n        // Crear componentes\n        startButton = new JButton(\"Start Task\");\n        statusLabel = new JLabel(\"Status: Waiting\");\n        progressBar = new JProgressBar(0, 100);\n\n        // Agregar acci\u00f3n al bot\u00f3n\n        startButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                startBackgroundTask();\n            }\n        });\n\n        // Agregar componentes al marco\n        frame.add(startButton);\n        frame.add(statusLabel);\n        frame.add(progressBar);\n    }\n\n    private void startBackgroundTask() {\n        SwingWorker&lt;Void, Integer&gt; worker = new SwingWorker&lt;&gt;() {\n            @Override\n            protected Void doInBackground() throws Exception {\n                for (int i = 0; i &lt;= 100; i++) {\n                    Thread.sleep(50); // Simula una tarea pesada\n                    publish(i); // Env\u00eda el progreso\n                }\n                return null;\n            }\n\n            @Override\n            protected void process(java.util.List&lt;Integer&gt; chunks) {\n                int progress = chunks.get(chunks.size() - 1);\n                progressBar.setValue(progress);\n                statusLabel.setText(\"Status: \" + progress + \"% completed\");\n            }\n\n            @Override\n            protected void done() {\n                statusLabel.setText(\"Status: Task Completed!\");\n                startButton.setEnabled(true);\n            }\n        };\n\n        startButton.setEnabled(false);\n        worker.execute();\n    }\n\n    public void show() {\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -&gt; {\n            MultithreadingExample example = new MultithreadingExample();\n            example.show();\n        });\n    }\n\n}\n</code></pre>"},{"location":"bloque_vi/tema_32/page-7/","title":"Ejercicios","text":"Calculadora <p>Crea una calculadora que te permita realizar las operaciones b\u00e1sicas: suma, resta, multiplicar, dividir, obtener el resto de una divisi\u00f3n y potencia.</p> Agenda de contactos <p>Crea una aplicaci\u00f3n que permita realizar operaciones CRUD sobre los contactos. La aplicaci\u00f3n ser\u00e1 SinglePage. Se mostrar\u00e1 un formulario y abajo una tabla con los datos a\u00f1adidos y con la opci\u00f3n de eliminar y actualizar.</p> MultiPage <p>Crea una base de datos con MySQL con los contactos de la agenda. Luego realiza una aplicaci\u00f3n con Swing con las siguientes p\u00e1ginas:</p> <ul> <li>La primera mostrar\u00e1 en una cuadricula los datos de los usuarios. (Incluida las im\u00e1genes)</li> <li>Al hacer clic en el contacto, en una segunda p\u00e1gina se mostrar\u00e1 los datos del contacto m\u00e1s detalladamente.</li> <li>Una tercera ventana con un formulario que te permita a\u00f1adir o actualizar un contacto.</li> </ul> <p>A\u00f1ade en la segunda p\u00e1gina, un bot\u00f3n que te permite navegar hacia atr\u00e1s.</p> <p>Crea un men\u00fa que te permita realiza las siguientes operaciones:</p> <ul> <li>Contactos: Mostrar\u00e1 operaciones sobre los contactos (se mostrar\u00e1 en la primera p\u00e1gina). Como por ejemplo a\u00f1adir contacto (navegar\u00e1 a la tercera p\u00e1gina)</li> </ul>"},{"location":"bloque_vi/tema_33/page-1/","title":"1 Introducci\u00f3n a Java FX","text":""},{"location":"bloque_vi/tema_33/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Hoy en d\u00eda las interfaces de los programas son cada vez m\u00e1s sofisticadas y atractivas para el usuario. Son intuitivas y cada vez m\u00e1s f\u00e1ciles de usar, como las pantallas t\u00e1ctiles, etc.</p> <p>Sin embargo, no siempre ha sido as\u00ed. No hace muchos a\u00f1os, antes de que surgieran y se popularizaran las interfaces gr\u00e1ficas para que el usuario interactuara con el sistema operativo con sistemas como Windows, etc., se trabajaba en modo consola, o modo car\u00e1cter, es decir, se le daban las ordenes al ordenador con comandos por teclado, de hecho, por entonces no exist\u00eda el rat\u00f3n. Es lo que se conoce como interfaces de l\u00ednea de comandos (CLI).</p> <p>As\u00ed que, con el tiempo, con la idea de simplificar el uso de los ordenadores para extender el uso a un cada vez mayor espectro de gente, de usuarios de todo tipo, y no s\u00f3lo para los expertos, se ha convertido en una pr\u00e1ctica habitual utilizar interfaces gr\u00e1ficas de usuario (IGU \u00f3 GUI en ingl\u00e9s), para que el usuario interact\u00fae y establezca un contacto m\u00e1s f\u00e1cil e intuitivo con el ordenador.</p> <p>En ocasiones ver\u00e1s otras definiciones de interfaz, como la que define una interfaz como un dispositivo que permite comunicar dos sistemas que no hablan el mismo lenguaje. Tambi\u00e9n se emplea el t\u00e9rmino interfaz para definir el juego de conexiones y dispositivos que hacen posible la comunicaci\u00f3n entre dos sistemas.</p> <p>Ahora, cuando hablamos de interfaz nos referimos a la cara visible de los programas tal y como se presenta a los usuarios para que interact\u00faen con la m\u00e1quina. La interfaz gr\u00e1fica implica la presencia de un monitor de ordenador, en el que veremos la interfaz constituida por una serie de men\u00fas e iconos que representan las opciones que el usuario puede tomar dentro del sistema.</p> <p>JavaFX es por tanto el kit de herramientas GUI de \u00faltima generaci\u00f3n para la plataforma Java. Estaba completamente integrado con versiones como la 8 de de Java SE Runtime Environment (JRE) y el Java Development Kit (JDK), pero en marzo de 2018 Oracle anunci\u00f3 que sacar\u00eda JavaFX del JDK debido a que est\u00e1 evolucionando m\u00e1s r\u00e1pidamente el lenguaje en s\u00ed, que JavaFX, que va m\u00e1s lento en su evoluci\u00f3n.</p> <p>En una aplicaci\u00f3n de internet enriquecida (RIA), la presentaci\u00f3n gr\u00e1fica se gestiona en el lado del cliente y la manipulaci\u00f3n de datos se lleva a cabo en el lado del servidor.</p>"},{"location":"bloque_vi/tema_33/page-1/#arquitectura-java-fx","title":"Arquitectura Java FX","text":"<p>Al principio, el primer sistema de Java para mostrar interfaces de usuario basadas en ventanas en Java. De ah\u00ed surgi\u00f3 Swing, que triunf\u00f3 r\u00e1pidamente y a partir de Java SE 7 Update 6, Oracle JavaFX es la tecnolog\u00eda indicada para desarrollar aplicaciones. Desde entonces, JavaFX form\u00f3 parte del JDK para facilitar el desarrollo de aplicaciones de interfaz de usuario y proporciona un rico conjunto de API para desarrollo de gr\u00e1ficos y contenidos multimedia. Oracle anunci\u00f3 que JavaFX sustituir\u00eda a Swing. Aunque Swing todav\u00eda era compatible con Java 8 y ser\u00e1 compatible con un futuro cercano, Swing estar\u00e1 obsoleto en poco tiempo.</p> <p> Figura 1 - Arquitectura JavaFx</p> <p>En el esquema podemos ver la arquitectura de JavaFX. Los elementos principales son:</p> <ul> <li>Prism. Debajo de las API p\u00fablicas de JavaFX se encuentra el motor que ejecuta el c\u00f3digo JavaFX, es un motor gr\u00e1fico de alto rendimiento para gr\u00e1ficos 2D y 3D.</li> <li>Glass windowing toolkit, es el nuevo sistema de ventanas, que constituye una capa que conecta JavaFX al sistema operativo nativo. Proporciona servicios nativos del sistema operativo, como la administraci\u00f3n de ventanas, eventos, temporizadores, etc.</li> <li>Media engine, proporciona herramientas para crear aplicaciones multimedia que permiten la reproducci\u00f3n de medios en la ventana del escritorio o dentro de una p\u00e1gina web en plataformas compatibles.</li> <li>Web engine, es un motor de navegador web que admite HTML5, CSS, JavaScript, DOM y SVG.</li> </ul> <p>Las aplicaciones usan la API p\u00fablica de JavaFX para construir el grafo de escena (Scene Graph), que es la representaci\u00f3n jer\u00e1rquica de la interfaz. Por debajo hay una serie de componentes, que hemos visto en el esquema anterior, no accesibles sobre los que se apoya JavaFX.</p> <p> Figura 2 - Estructura de una App</p> <p>Normalmente, una aplicaci\u00f3n JavaFX consta de un escenario (Stage) y una escena (Scene):</p> <ul> <li>Stage es un contenedor de alto nivel, la ventana principal de la aplicaci\u00f3n, representa la ventana del sistema operativo. En el caso de aplicaciones embebidas en un navegador web, ser\u00eda el \u00e1rea rectangular principal. En el caso de aplicaciones de escritorio, el stage ser\u00e1 la ventana, con su barra de t\u00edtulo, y botones de maximizar, minimizar o cerrar.</li> <li>Scene es el contenedor donde se aloja el grafo de escena.</li> </ul> <p>Frecuentemente, se suele poner como ejemplo para entender estos conceptos, el hecho de ver el stage como un escenario o teatro en el que se desarrollan escenas. As\u00ed, el stage es un espacio, y una escena define qu\u00e9 sucede en ese espacio. Un stage es el contenedor de nivel superior, que como m\u00ednimo consta de una escena, que a su vez contiene otros elementos.</p>"},{"location":"bloque_vi/tema_33/page-1/#grafo-de-escena","title":"Grafo de escena","text":"<p>El grafo de escena constituye una estructura jer\u00e1rquica que contiene la descripci\u00f3n de los elementos que forman la interfaz gr\u00e1fica. Est\u00e1 formado por nodos dispuestos en un orden jer\u00e1rquico. Este \u00e1rbol jer\u00e1rquico de nodos representa todos los elementos visuales del interfaz de usuario de la aplicaci\u00f3n JavaFX.</p> <p> Figura 3 - Node</p> <p>Este \u00e1rbol jer\u00e1rquico de nodos representa todos los elementos visuales del interfaz de usuario de la aplicaci\u00f3n JavaFX.</p> <p>Cada elemento de un grafo de escena es un nodo. Salvo el nodo ra\u00edz (root node) que es el primer nodo del \u00e1rbol y no tiene padres, tenemos dos tipos de nodos:</p> <ul> <li>Nodo contenedor, de tipo Parent, que contienen otros nodos hijos.</li> <li>Nodo hoja, que no contienen otros nodos y pueden ser formas gr\u00e1ficas o texto, o bien controles de interfaz de usuario. Las formas geom\u00e9tricas y el texto heredan de la clase Shape o bien de la clase Shape3D. Los controles de interfaz de usuario as\u00ed como los paneles de layouts heredan de la clase Parent.</li> </ul> <p>Podemos manipular la escena modificando propiedades de un nodo. De esta forma, podemos animar nodos, aplicar efectos, hacer transformaciones o cambiar su opacidad, etc.</p> <p>Los nodos son elementos individuales que forman una escena, como por ejemplo botones, cuadros de texto, layouts, etc. Si seguimos con el s\u00edmil de un teatro, los nodos ser\u00edan los actores y el atrezo.</p> <p>Cualquier nodo de un grafo de escena hereda de la clase base <code>Node</code>, y existen otras clases que heredan directa o indirectamente de <code>Node</code>, como <code>Parent</code>, <code>Group</code>, <code>Region</code> o <code>Control</code>.</p>"},{"location":"bloque_vi/tema_33/page-1/#instalacion-del-sdk","title":"Instalaci\u00f3n del SDK","text":"<p>Para instalar el SDK de JavaFX, podemos hacerlo de forma manual, descargando el fichero desde aqu\u00ed. Luego, se deber\u00e1 a\u00f1adir la librer\u00eda JavaFx como librer\u00eda de nuestro proyecto.</p> <p>Tambi\u00e9n se puede realizar a trav\u00e9s de maven o gradle:</p> MavenGradle <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n     xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;javafx-app&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;\n        &lt;javafx.version&gt;19&lt;/javafx.version&gt; &lt;!-- Aseg\u00farate de usar la versi\u00f3n correcta de JavaFX --&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.openjfx&lt;/groupId&gt;\n            &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;\n            &lt;version&gt;${javafx.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.openjfx&lt;/groupId&gt;\n            &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;\n            &lt;version&gt;${javafx.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.8.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;11&lt;/source&gt;\n                    &lt;target&gt;11&lt;/target&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.openjfx&lt;/groupId&gt;\n                &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;0.0.8&lt;/version&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;compile&lt;/goal&gt;\n                            &lt;goal&gt;process-classes&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n                &lt;configuration&gt;\n                    &lt;mainClass&gt;com.example.App&lt;/mainClass&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <pre><code>plugins {\n    id 'application'\n    id 'org.openjfx.javafxplugin' version '0.0.13'\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.openjfx:javafx-controls:19'\n    implementation 'org.openjfx:javafx-fxml:19'\n}\n\napplication {\n    mainClass = 'App'\n}\n\njavafx {\n    version = \"19\"\n    modules = [ 'javafx.controls', 'javafx.fxml' ]\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-10/","title":"Di\u00e1logos","text":""},{"location":"bloque_vi/tema_33/page-10/#introduccion","title":"Introducci\u00f3n","text":"<p>En JavaFX, <code>Dialog</code> es una clase base para crear di\u00e1logos. Un di\u00e1logo es una vista que se superpone a la vista principal e impide la interacci\u00f3n del usuario con la vista principal hasta que no responda al di\u00e1logo.</p> <p>Un di\u00e1logo est\u00e1 formado por un <code>DialogPane</code>, el nodo ra\u00edz del di\u00e1logo y ofrece funcionalidades necesarias para mostrarlo en un <code>stage</code>. El di\u00e1logo es responsable</p> <p> Figura 15 - Di\u00e1logo</p> <p>La clase <code>Dialog&lt;R&gt;</code> tiene un tipo gen\u00e9rico que representa el tipo del resultado devuelto por el di\u00e1logo a trav\u00e9s de la propiedad <code>result</code>. Por defecto, el tipo de resultado devuelto es <code>ButtonType</code></p> <p>Despu\u00e9s de instanciar el di\u00e1logo hay que configurarlo. Las propiedades relacionadas con el contenido son: <code>contentText</code>, <code>headerText</code> y <code>graphic</code>, que corresponde a las propiedades equivalentes del <code>DialogPane</code>. Dado lo habitual que es mostrar una cadena de texto, tanto como una cabecera en el contenido de un di\u00e1logo, estas propiedades son muy \u00fatiles para que se les pueda asignar directamente una cadena, sin necesidad de crear un <code>Label</code>.</p> <p>Tambi\u00e9n se puede establecer un nodo en el \u00e1rea del contenido de la cabecera, teniendo en cuenta que si tambi\u00e9n se especifica una cadena, \u00e9sta ser\u00e1 omitida.</p> <p>Una vez que el di\u00e1logo ha sido configurado, hay que mostrarlo. La mayor\u00eda de las veces los di\u00e1logos son mostrados de forma modal y bloquean el c\u00f3digo. Cuando se muestra de forma modal, evita cualquier interacci\u00f3n del usuario mientras el di\u00e1logo est\u00e9 visible.Esto quiere decir que se mostrar\u00e1 el di\u00e1logo a la espera de que el usuario continue la ejecuci\u00f3n.</p> <p>Un di\u00e1logo no bloqueante implicar\u00eda escribir c\u00f3digo necesario para asegurarse de obtener la respuesta antes de que esta sea usada. Para especificar si se quiere el comportamiento que bloquee el c\u00f3digo o no, se utilizara respectivamente los m\u00e9todos <code>showAndWait()</code> or <code>show()</code>.</p> <p>Veamos un ejemplo:</p> <pre><code>Dialog&lt;String&gt; dialog = new Dialog&lt;&gt;();\ndialog.setTitle(\"Login Dialog\");\ndialog.setContentText(\"Would you like to log in?\");\nButtonType loginButtonType = new ButtonType(\"Login\", ButtonData.OK_DONE);\ndialog.getDialogPane().getButtonTypes().add(loginButtonType);\ndialog.showAndWait();\n</code></pre>"},{"location":"bloque_vi/tema_33/page-10/#alert","title":"Alert","text":"<p>La clase <code>Alert</code> es una subclase de <code>Dialog</code> y proporciona soporte para un n\u00famero de di\u00e1logos predise\u00f1ados para solicitar informaci\u00f3n en una interface gr\u00e1fica.</p> <p>Tambi\u00e9n est\u00e1n disponibles las clases <code>TextInputDialog</code> and <code>ChoiceDialog</code> para hacer una pregunta tipo texto o de selecci\u00f3n, respectivamente.</p> <p>Cando se crea una nueva instancia de la clase <code>Alert</code>, hay que pasar como par\u00e1metro un valor de entre los disponibles en <code>Alert.AlertType</code> (CONFIRMATION, ERROR, INFORMATION, NONE ou WARNING). A partir de este valor se configura  apropiadamente a la ventana incluido el t\u00edtulo, la cabecera, gr\u00e1fico, as\u00ed como los botones por defecto.</p> <p>Al igual que un di\u00e1logo, una alerta est\u00e1 composta por:</p> <ul> <li>A cabecera, que se usa para mostrar una peque\u00f1a notificaci\u00f3n con un icono.</li> <li>La regi\u00f3n del contenido normalmente suele ser un texto utilizando el m\u00e9todo <code>setContentText(String)</code>. Tambi\u00e9n es posible mostrar un Nodo en esta regi\u00f3n a trav\u00e9s del m\u00e9todo <code>alert.getDialogPane().setContent(Node)</code>.</li> <li>Una regi\u00f3n al pie de la ventana donde se muestra los botones, pudiendo personalizarlos.</li> </ul> <pre><code>Alert alert = new Alert(AlertType.CONFIRMATION, \"Are you sure you want to format your system?\");\nOptional&lt;ButtonType&gt; result = alert.showAndWait();\nif (result.isPresent() &amp;&amp; result.get() == ButtonType.OK) {\n    formatSystem();\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-11/","title":"Ejercicios","text":"Aplicaci\u00f3n 1 <p>Crea una aplicaci\u00f3n similar a la siguiente:</p> <p> Figura 16 - Aplicaci\u00f3n 1 </p> <p>Teniendo en cuenta:</p> <ul> <li>No se puede usar ni FXML ni SceneBuilder.</li> <li>Cada vez que se hace click al bot\u00f3n <code>Agregar Persona</code>, dicho datos deben ser a\u00f1adidos a la tabla.</li> <li>Si la tabla no tiene contenido, debe mostrar <code>Tabla Sin Contenido</code>, por el contrario mostrar\u00e1 su contenido.</li> <li>Al seleccionar una persona de la tabla, \u00e9sta rellenar\u00e1 los datos del formulario y podr\u00e1 ser modificados al hacer clic en el bot\u00f3n <code>Modificar</code>. Si se se hace clic a una persona y se hace clic en el bot\u00f3n <code>Agregar Persona</code>, \u00e9sta no ser\u00e1 a\u00f1adida.</li> <li>Al seleccionar una persona de la tabla, y al hacer clic en el bot\u00f3n eliminar se eliminar\u00e1 de la tabla.</li> <li>Aplica estilos libres haciendo uso de los m\u00e9todos necesarios. No se puede usar ficheros externos.</li> </ul> Aplicaci\u00f3n 2 <p>Crea una aplicaci\u00f3n similar a la siguiente, teniendo en cuenta</p> <p>A\u00f1adir foto</p> <ul> <li>Se puede utilizar JavaFX, pero no SceneBuilder.</li> <li>Se debe utilizar una base de datos. No importa si se utiliza con JDBC o con JPA o Hibernate.</li> <li>Aplicar estilos libres.</li> <li>Se pueden aplicar ficheros CSS para los estilos. </li> <li>Se debe realizaci\u00f3n una paginaci\u00f3n coherente.</li> </ul> Aplicaci\u00f3n 3 <p>Realiza la mista aplicaci\u00f3n anterior, haciendo uso de bases de datos para guardar la informaci\u00f3n, obteniendo la informaci\u00f3n previamente de la API. Se puede utilizar SceneBuilder</p>"},{"location":"bloque_vi/tema_33/page-2/","title":"2 Nodes","text":""},{"location":"bloque_vi/tema_33/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>En JavaFX, un <code>Node</code> es la clase base para todos los objetos que pueden aparecer en la escena (escenario). La jerarqu\u00eda de nodos es fundamental para construir la interfaz gr\u00e1fica de usuario (GUI). Los nodos pueden ser visuales, como controles (botones, etiquetas, campos de texto), o contenedores que organizan otros nodos en una estructura (por ejemplo, <code>HBox</code>, <code>VBox</code>, <code>GridPane</code>).</p> <p>Existen dos tipos de nodos:</p> <ul> <li>Nodos gr\u00e1ficos (leaf nodes): Son los elementos visuales que aparecen en la interfaz. Entre sus clases podemos encontrar: <code>Label</code>, <code>Button</code>, <code>TextField</code>, <code>ImageView</code>, etc.</li> <li>Nodo contenedores (branch nodes): Organizan otros nodos en la escena y pueden contener m\u00faltiples nodos hijos. Podemos encontrar entre ellos, <code>HBox</code>, <code>VBox</code>, etc.</li> </ul> <p>JavaFX utiliza una estructura de \u00e1rbol para organizar los nodos. La ra\u00edz del \u00e1rbol es un nodo especial, <code>Scene</code>, y todos los dem\u00e1s nodos son descendientes de la ra\u00edz.</p> <p>Todos los nodos tienen propiedades comunes como <code>layoutX</code>, <code>layoutY</code>, <code>opacity</code>, <code>visible</code>, <code>style</code>, etc. Adem\u00e1s, pueden manejar eventos de usuario como clics, teclas presionadas, movimientos del rat\u00f3n, etc.</p> <p>Tambi\u00e9n, los nodos pueden ser transformados (escalados, rotados, trasladados) usando las clases de transformaci\u00f3n de JavaFX, y se pueden aplicar efectos visuales como sombras y reflejos a los nodos.</p>"},{"location":"bloque_vi/tema_33/page-2/#controles-de-usuarios","title":"Controles de usuarios","text":"<p>Los controles de usuarios, tambi\u00e9n conocidos como nodos gr\u00e1ficos, son aquellos elementos que pueden interactuar con el usuario. Entre sus clases encontramos:</p> <ul> <li><code>Button</code>. Un bot\u00f3n simple que puede ser clicado para realizar una acci\u00f3n.</li> <li><code>ToggleButton</code>: Un bot\u00f3n que puede estar en un estado activado o desactivado.</li> <li><code>CheckBox</code>: Una casilla que puede estar seleccionada o deseleccionada.</li> <li><code>RadioButton</code>: Botones de opci\u00f3n que se agrupan para permitir una selecci\u00f3n exclusiva.</li> <li><code>TextField</code>: Un campo de texto de una sola l\u00ednea.</li> <li><code>PasswordField</code>: Un campo de texto de una sola l\u00ednea para ingresar contrase\u00f1as, ocultando el texto ingresado.</li> <li><code>TextArea</code>: Un campo de texto de varias l\u00edneas.</li> <li><code>ComboBox</code>: Un men\u00fa desplegable que permite seleccionar una opci\u00f3n de una lista.</li> <li><code>ChoiceBox</code>: Similar a <code>ComboBox</code>, pero con una apariencia y comportamiento ligeramente diferente.</li> <li><code>ListView</code>: Un control que muestra una lista de elementos.</li> <li><code>Label</code>: Un control para mostrar texto est\u00e1tico.</li> <li><code>ImageView</code>: Un control para mostrar im\u00e1genes.</li> <li><code>ProgressBar</code>: Una barra de progreso para mostrar el progreso de una tarea.</li> <li><code>ProgressIndicator</code>: Similar a ProgressBar, pero con una apariencia circular.</li> <li><code>TableView</code>: Para mostrar informaci\u00f3n en forma de tabla.</li> <li><code>TreeView</code>: Para mostrar informaci\u00f3n de forma jer\u00e1rquica (\u00e1rbol)</li> </ul> <p>En la siguiente tabla, vemos los m\u00e9todos que tienen en com\u00fan la mayor\u00eda de los nodos:</p> M\u00e9todo Descripci\u00f3n <code>setText(String text)</code> A\u00f1ade el texto al componente. <code>getText()</code> Obtiene el texto del componente <code>setDisable(boolean value)</code> Permite deshabilitar o habilitar el componente <code>isDisable()</code> Devuelve <code>true</code> si el componente est\u00e1 deshabilitado, por el contrario devuelve <code>false</code> <code>setVisible(boolean value)</code> Muestra u oculta el componente <code>isVisible()</code> Devuelve <code>true</code> si el componente es visible, <code>false</code> si no lo es <code>setStyle(String style)</code> Aplica el estilo al componente <code>setPrefWidth()</code> Configura el ancho preferido del componente <code>setPrefHeight()</code> Configura el alto preferido del componente <code>setMaxWidth()</code> Configura el ancho m\u00e1ximo del componente <code>setMaxHeight()</code> Configura el alto m\u00e1ximo del componente <code>setMinWidth()</code> Configura el ancho m\u00ednimo del componente <code>setMinHeight()</code> Configura el alto m\u00ednimo del componente <p>Cada nodo tiene su propio sistema de coordenadas, que a diferencia del sistema de coordenadas cartesianas, el eje Y est\u00e1 invertido, por lo que el origen de la coordenada est\u00e1 situada en la esquina superior izquierda del nodo.</p> <p> Figura 4 - Coordenadas nodo</p> <p>Este sistema de coordenadas tambi\u00e9n es utilizado para distribuir y posicionar los descendientes en relaci\u00f3n con el nodo padre, es decir, cada nodo hijo tendr\u00e1 su propio sistema de coordenadas y tendr\u00e1 una posici\u00f3n relativa dentro del sistema de coordenadas del nodo padre.</p> <p> Figura 5 - Relaci\u00f3n coordenadas entre nodo padre y nodo hijo</p>"},{"location":"bloque_vi/tema_33/page-2/#aplicacion-javafx","title":"Aplicaci\u00f3n JavaFX","text":"<p>Existen dos formas de crear una aplicaci\u00f3n con JavaFx:</p> <ul> <li>Usando un archivo FXML que define los elementos que componen la interfaz (Puede usarse la herramienta <code>SceneBuilder</code> para crear el archivo FXML)</li> <li>Programar la interfaz usando el c\u00f3digo de la API JavaFX.</li> </ul> <p>De momento, usaremos la \u00faltima opci\u00f3n.</p> <p>Para representar una aplicaci\u00f3n en JavaFx, hacemos uso de la clase <code>Application</code> que es la clase base para todas las aplicaciones JavaFX. Proporciona el punto de entrada principal y el ciclo de vida de una aplicaci\u00f3n JavaFX. Para crear una aplicaci\u00f3n JavaFX, debes extender la clase <code>Application</code> y sobrescribir el m\u00e9todo <code>start()</code>.</p> <p>Una aplicaci\u00f3n JavaFX pasa por varios estados a lo largo de su vida. Los m\u00e9todos principales que controlan este ciclo de vida son:</p> <ul> <li><code>init()</code>: Se llama antes de que la aplicaci\u00f3n JavaFX se inicie y antes del m\u00e9todo <code>start()</code>. No es obligatorio sobrescribirlo al extender de la clase <code>Application</code>. Se suele usar para inicializar cualquier recurso que no sea gr\u00e1fico. Se ejecuta en el hilo de lanzamiento de la aplicaci\u00f3n y no en el hilo de la aplicaci\u00f3n JavaFX. Se debe llamar a <code>super.init()</code> para que se JavaFX inicializa lo necesario</li> <li><code>start(Stage primaryStage)</code>: Este m\u00e9todo se ejecuta cuando la aplicaci\u00f3n ya es iniciada y se desea pintar la aplicaci\u00f3n JavaFX. Es obligatorio su sobrescritura, ya que en ella se configura y se muestra la interfaz de usuario principal de la aplicaci\u00f3n. Se proporciona un objeto de la clase <code>Stage</code> que representa la ventana principal de la aplicaci\u00f3n.</li> <li><code>stop()</code>. Se llama cuando la aplicaci\u00f3n se detiene. Se utiliza para liberar recursos y se ejecuta en el hilo de aplicaci\u00f3n de JavaFX. No es obligatorio sobrescribir este m\u00e9todo, pero al hacer se debe llamar a <code>super.stop()</code> para que se JavaFX libere sus recursos.</li> </ul> <p>Adem\u00e1s de los m\u00e9todos principales, se debe puede utilizar el m\u00e9todo <code>launch(String ...args)</code>. Este m\u00e9todo es un m\u00e9todo est\u00e1tico que se utiliza para inicializar la aplicaci\u00f3n JavaFX, y llama internamente a los m\u00e9todos descritos anteriormente, en el orden adecuado. Dicho m\u00e9todo debe ser usado en el <code>main</code> de la aplicaci\u00f3n.</p>"},{"location":"bloque_vi/tema_33/page-3/","title":"3 Layouts","text":""},{"location":"bloque_vi/tema_33/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Los layouts son contenedores usados para gestionar la disposici\u00f3n de los controles de grafo. Cuando una ventana es redimensionada, el panel autom\u00e1ticamente tambi\u00e9n es recolocado y redimensiona los componentes que contiene.</p> <p>La principal ventaja de usar layouts es que el tama\u00f1o y el alineamiento de los nodos est\u00e1 gestionado por el panel, por lo que si el panel se redimensiona, los nodos hijos tambi\u00e9n lo har\u00e1n.</p> <p>En JavaFX todos los controles tienen un tama\u00f1o preferido (preferredSize) que se calcula en funci\u00f3n de su contenido. Adem\u00e1s, los controles tambi\u00e9n proporcionan un tama\u00f1o m\u00ednimo y m\u00e1ximo que se basan en el uso t\u00edpico del control. Por ejemplo, un bot\u00f3n tiene como tama\u00f1o m\u00e1ximo su tama\u00f1o preferido. Este comportamiento puede ser manipulado con los m\u00e9todos vistos en el apartado anterior.</p> <p>Cuando se posiciona un control dentro de un layout, el control pasar\u00e1 a ser hijo del layout que se encargar\u00e1 de visualizarlo adecuadamente.</p> <p>JavaFX tiene, entre otros, los siguientes paneles de layout:</p> <ul> <li><code>StackPane</code>: Coloca los nodos en una pila de atr\u00e1s hacia adelante. El \u00faltimo nodo es el que est\u00e1 en la parte superior.</li> <li><code>HBox</code> y <code>VBox</code>. Los elementos son posicionados de forma horizontal o vertical, respectivamente.</li> <li><code>FlowPane</code>. Posiciona los elementos en una fila o columna. La orientaci\u00f3n por defecto es horizontal.</li> <li><code>AnchorPane</code>. Permite anclar los bordes de los hijos a una distancia predefinida del borde del contenedor.</li> <li><code>TilePane</code>. Distribuye los elementos de tal forma que tengan el mismo tama\u00f1o. Por defecto, son colocados horizontalmente, pero puede configurarse de forma vertical o en forma de matriz.</li> <li><code>BorderPane</code>. Coloca los elementos en las posiciones, superior, inferior, derecha, izquierda o centro. Los elementos posicionados en la parte superior o inferior ocupan todo el ancho, pero el alto necesario. Mientras que, los posicionados en la parte izquierda o derecha, ocupan el ancho necesario y todo el alto. Los elementos posicionados en el centro ocupar\u00e1 todo el resto de espacio disponible.</li> <li><code>GridPane</code>. Posiciona los elementos en una matriz de filas y columnas. Los nodos pueden extenderse por m\u00faltiples filas y columnas.</li> </ul>"},{"location":"bloque_vi/tema_33/page-3/#stackpane","title":"StackPane","text":"<p><code>StackPane</code> es una de las clases de contenedor m\u00e1s b\u00e1sicas en JavaFX y es parte del paquete <code>javafx.scene.layout</code>. Se utiliza para colocar nodos unos sobre otros en una pila (stack), donde cada nodo se coloca en el centro de su padre. Es \u00fatil cuando quieres superponer varios nodos o cuando deseas que un solo nodo ocupe todo el espacio disponible en su contenedor.</p> <p> Figura 6 - StackPane</p> <p>Todos los nodos hijos de un <code>StackPane</code> se colocan uno encima del otro. El primer nodo a\u00f1adido se coloca en el fondo y el \u00faltimo en la parte superior. De forma predeterminada, los nodos se centran en el medio del <code>StackPane</code>. <code>StackPane</code> puede ajustar el tama\u00f1o de sus nodos hijos para que se ajusten al tama\u00f1o del panel.</p> <p>Con el m\u00e9todo <code>getChildren()</code> obtenemos una lista con los nodos hijos del panel, y haciendo uso del m\u00e9todo <code>addAll()</code> o <code>add()</code> de las listas, podemos a\u00f1adir elementos al panel:</p> <pre><code>StackPane stack = new StackPane()\n\nstack.getChildren().addAll(new Button('Button'))\n</code></pre> <p>A trav\u00e9s del m\u00e9todo est\u00e1tico <code>setAlignment(Node child, Pos value)</code> puedes cambiar la alineaci\u00f3n de los nodos hijos. Con el m\u00e9todo <code>setAlignment(Pos value)</code> cambiamos la alineaci\u00f3n de todos sus hijos.</p> <pre><code>StackPane.setAlignment(button, POS.TOP_LEFT)\n</code></pre> <p>Tambi\u00e9n podemos a\u00f1adirle un margen al hijo, haciendo uso del m\u00e9todo <code>setMargin(Node children, Insets value)</code></p> <p>Veamos un ejemplo:</p> <pre><code>public class StackPaneExample extends Application {\n\n    @Override\n    public void start(Stage stage) throws Exception {\n        StackPane stack = new StackPane();\n\n        Button button1 = new Button(\"Button 1\");\n        button1.setPrefSize(150, 100);\n\n        Button button2 = new Button(\"Button 2\");\n        button2.setPrefSize(100, 50);\n\n        stack.getChildren().addAll(button1, button2);\n        stack.setAlignment(Pos.BOTTOM_RIGHT);\n\n        Scene scene = new Scene(stack, 300, 200);\n\n        stage.setTitle(\"StackPane example\");\n        stage.setScene(scene);\n        stage.show();\n\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre> <p>Como se puede observar los botones est\u00e1n uno encima del otro, ambos alineados a bajo a la derecha.</p>"},{"location":"bloque_vi/tema_33/page-3/#hbox-y-vbox","title":"HBox y VBox","text":"<p><code>HBox</code> y <code>VBox</code> son dos de los contenedores de dise\u00f1o m\u00e1s utilizados en JavaFX para organizar nodos en una disposici\u00f3n horizontal o vertical, respectivamente. Ambos son parte del paquete <code>javafx.scene.layout</code> y facilitan la creaci\u00f3n de interfaces de usuario al proporcionar una manera sencilla de alinear y distribuir nodos.</p> <p><code>HBox</code> organiza sus nodos hijos en una fila horizontal. Los nodos hijos se colocan uno al lado del otro en una fila. En su constructor, <code>HBox(int gap)</code> se puede indicar el espacio entre los elementos.</p> <p> Figura 7 - HBox</p> <p><code>VBox</code> organiza sus nodos hijos en una columna vertical. Los nodos hijos se colocan uno debajo de otro en una columna. Tambi\u00e9n, a trav\u00e9s de su constructor, <code>VBox(int gap)</code> se le puede indicar el espacio entre los elementos.</p> <p> Figura 8 - VBox</p> <p>A trav\u00e9s de el m\u00e9todo <code>setAlignment(Post ps)</code> y el m\u00e9todo est\u00e1tico <code>setMargin(Node child, Insets inset)</code>, se puede indicar el alineamiento y el margen de los hijos, respectivamente. La alineaci\u00f3n por defecto es a la izquierda. Veamos un ejemplo:</p> HBoxVBox <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        Button button1 = new Button(\"Button 1\");\n        Button button2 = new Button(\"Button 2\");\n        Button button3 = new Button(\"Button 3\");\n        Button button4 = new Button(\"Button 4\");\n        Button button5 = new Button(\"Button 5\");\n\n        HBox hbox = new HBox(10);\n        hbox.getChildren().addAll(button1, button2, button3, button4, button5);\n        hbox.setAlignment(Pos.CENTER);\n\n        Scene scene = new Scene(hbox, 300, 200);\n        stage.setTitle(\"HBox Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) {\n        Button button1 = new Button(\"Button 1\");\n        Button button2 = new Button(\"Button 2\");\n        Button button3 = new Button(\"Button 3\");\n        Button button4 = new Button(\"Button 4\");\n        Button button5 = new Button(\"Button 5\");\n\n        VBox vbox = new VBox(10);\n        vbox.getChildren().addAll(button1, button2, button3, button4, button5);\n        vbox.setAlignment(Pos.CENTER);\n\n        Scene scene = new Scene(vbox, 300, 200);\n        stage.setTitle(\"VBox Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-3/#flowpane","title":"FlowPane","text":"<p><code>FlowPane</code> es otro contenedor de dise\u00f1o en JavaFX que organiza sus nodos hijos en una disposici\u00f3n de flujo. Los nodos se colocan en filas horizontales (o columnas verticales) y se ajustan autom\u00e1ticamente a medida que se agregan m\u00e1s nodos, envolvi\u00e9ndose a la siguiente fila (o columna) cuando se alcanza el l\u00edmite del contenedor. Este comportamiento es similar al de un flujo de texto en un p\u00e1rrafo.</p> <p> Figura 9 - FlowPane</p> <p>A trav\u00e9s del m\u00e9todo <code>setOrientation(Orientation o)</code> se puede especificar la orientaci\u00f3n del panel, que por defecto es horizontal. Con el constructor <code>FlowPane(int hGap, int vGap)</code> se pueden establecer el espaciado horizontal y vertical, respectivamente. Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage)  {\n        Button button1 = new Button(\"Button 1\");\n        Button button2 = new Button(\"Button 2\");\n        Button button3 = new Button(\"Button 3\");\n        Button button4 = new Button(\"Button 4\");\n        Button button5 = new Button(\"Button 5\");\n\n        FlowPane flowPane = new FlowPane(10, 10);\n        flowPane.setOrientation(Orientation.VERTICAL);\n        flowPane.setAlignment(Pos.CENTER);\n        flowPane.getChildren().addAll(button1, button2, button3, button4, button5);\n\n        Scene scene = new Scene(flowPane, 300, 200);\n\n        stage.setTitle(\"FlowPane Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-3/#anchorpane","title":"AnchorPane","text":"<p><code>AnchorPane</code> es un contenedor de dise\u00f1o en JavaFX que permite anclar nodos a los bordes del contenedor. Este tipo de pane es \u00fatil cuando deseas que ciertos elementos se mantengan en una posici\u00f3n fija en relaci\u00f3n con los bordes del contenedor, incluso cuando el tama\u00f1o del contenedor cambia.</p> <p> Figura 10 - AnchorPane</p> <p>Entre sus m\u00e9todos comunes encontramos:</p> <ul> <li><code>setTopAnchor(Node child, Double value)</code>: Establece la distancia desde el nodo hijo hasta el borde superior del <code>AnchorPane</code>.</li> <li><code>setRightAnchor(Node child, Double value)</code>: Establece la distancia desde el nodo hijo hasta el borde derecho del <code>AnchorPane</code>.</li> <li><code>setBottomAnchor(Node child, Double value)</code>: Establece la distancia desde el nodo hijo hasta el borde inferior del <code>AnchorPane</code>.</li> <li><code>setLeftAnchor(Node child, Double value)</code>: Establece la distancia desde el nodo hijo hasta el borde izquierdo del <code>AnchorPane</code>.</li> </ul> <p>Veamos un ejemplo b\u00e1sico:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage)  {\n        Button button1 = new Button(\"Top Left\");\n        Button button2 = new Button(\"Bottom Right\");\n        Button button3 = new Button(\"Center\");\n\n        AnchorPane anchorPane = new AnchorPane();\n\n        anchorPane.getChildren().addAll(button1, button2, button3);\n\n        AnchorPane.setTopAnchor(button1, 10.0);\n        AnchorPane.setLeftAnchor(button1, 10.0);\n\n        AnchorPane.setBottomAnchor(button2, 10.0);\n        AnchorPane.setRightAnchor(button2, 10.0);\n\n        AnchorPane.setTopAnchor(button3, 50.0);\n        AnchorPane.setLeftAnchor(button3, 50.0);\n\n        // Crear una escena con AnchorPane como root node\n        Scene scene = new Scene(anchorPane, 300, 200);\n\n        // Configurar el escenario\n        stage.setTitle(\"AnchorPane Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre> <p>Uno de los usos que se le da a este panel es  anclar un nodo a m\u00faltiples bordes para que se estire cuando el tama\u00f1o del contenedor cambie. Ve\u00e1moslo en un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        Button button = new Button(\"Stretch\");\n\n        AnchorPane anchorPane = new AnchorPane();\n\n        anchorPane.getChildren().add(button);\n\n        AnchorPane.setTopAnchor(button, 10.0);\n        AnchorPane.setBottomAnchor(button, 10.0);\n        AnchorPane.setLeftAnchor(button, 10.0);\n        AnchorPane.setRightAnchor(button, 10.0);\n\n        Scene scene = new Scene(anchorPane, 300, 200);\n\n        stage.setTitle(\"Advanced AnchorPane Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-3/#tilepane","title":"TilePane","text":"<p><code>TilePane</code> es un contenedor de dise\u00f1o en JavaFX que organiza sus nodos hijos en una cuadr\u00edcula de celdas de tama\u00f1o uniforme. Es \u00fatil cuando deseas disponer componentes en filas y columnas de manera uniforme, sin preocuparte demasiado por el tama\u00f1o de cada celda, ya que todas tendr\u00e1n el mismo tama\u00f1o. Con <code>setOrientation(Orientation o)</code> se puede establecer la orientaci\u00f3n del panel.</p> <p> Figura 11 - TilePane</p> <p>Se puede indicar el tama\u00f1o preferido por las celdas utilizando los m\u00e9todos <code>setPrefTileWidth(double value)</code> y <code>setPrefTileHeight(double value)</code>. Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        Button button1 = new Button(\"Button 1\");\n        Button button2 = new Button(\"Button 2\");\n        Button button3 = new Button(\"Button 3\");\n        Button button4 = new Button(\"Button 4\");\n        Button button5 = new Button(\"Button 5\");\n        Button button6 = new Button(\"Button 6\");\n\n        TilePane tilePane = new TilePane(10, 10);\n        tilePane.setOrientation(Orientation.HORIZONTAL);\n        tilePane.setPrefTileWidth(100);\n        tilePane.setPrefTileHeight(50);\n        tilePane.getChildren().addAll(button1, button2, button3, button4, button5, button6);\n\n        Scene scene = new Scene(tilePane, 400, 200);\n\n        stage.setTitle(\"Complete TilePane Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-3/#borderpane","title":"BorderPane","text":"<p><code>BorderPane</code> es un contenedor de dise\u00f1o en JavaFX que organiza sus nodos hijos en cinco regiones distintas: superior (<code>top</code>), inferior (<code>bottom</code>), izquierda (<code>left</code>), derecha (<code>right</code>) y centro (<code>center</code>). Este contenedor es \u00fatil para crear interfaces de usuario que requieren una disposici\u00f3n estructurada y equilibrada.</p> <p>Las regiones superiores e inferiores ocupan todo el ancho posible del padre pero la altura que necesite. Mientras que, las regiones izquierda y derecha, ocupan todo el alto posible y la anchura necesaria.</p> <p> Figura 12 - BorderPane</p> <p>Haciendo uso de los m\u00e9todos <code>setXXX(Node n)</code>, siendo <code>XXX</code> la posici\u00f3n, se puede posicionar los elementos en la parte deseada.</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage)  {\n        Button topButton = new Button(\"Top\");\n        Button bottomButton = new Button(\"Bottom\");\n        Button leftButton = new Button(\"Left\");\n        Button rightButton = new Button(\"Right\");\n        Button centerButton = new Button(\"Center\");\n\n        BorderPane borderPane = new BorderPane();\n\n        borderPane.setTop(topButton);\n        borderPane.setBottom(bottomButton);\n        borderPane.setLeft(leftButton);\n        borderPane.setRight(rightButton);\n        borderPane.setCenter(centerButton);\n\n        Scene scene = new Scene(borderPane, 300, 200);\n\n        stage.setTitle(\"BorderPane Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-3/#gridpane","title":"GridPane","text":"<p><code>GridPane</code> es un contenedor de dise\u00f1o en JavaFX que organiza sus nodos hijos en una cuadr\u00edcula flexible de filas y columnas. Es especialmente \u00fatil para crear interfaces de usuario con una disposici\u00f3n tabular, donde puedes controlar la alineaci\u00f3n, el espaciado y el tama\u00f1o de las celdas.</p> <p> Figura 13 - GridPane</p> <p>Para a\u00f1adir un elemento al contenedor se utiliza el m\u00e9todo <code>add(Node n, int columnIndex, int rowIndex)</code>, el cu\u00e1l recibe el elemento a a\u00f1adir y la celda en la cu\u00e1l se desea a\u00f1adir. Veamos un ejemplo b\u00e1sico:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        Button button1 = new Button(\"Button 1\");\n        Button button2 = new Button(\"Button 2\");\n        Button button3 = new Button(\"Button 3\");\n        Button button4 = new Button(\"Button 4\");\n\n        GridPane gridPane = new GridPane();\n\n        gridPane.add(button1, 0, 0); // Columna 0, Fila 0\n        gridPane.add(button2, 1, 0); // Columna 1, Fila 0\n        gridPane.add(button3, 0, 1); // Columna 0, Fila 1\n        gridPane.add(button4, 1, 1); // Columna 1, Fila 1\n\n        Scene scene = new Scene(gridPane, 300, 200);\n\n        stage.setTitle(\"GridPane Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre> <p>Existe un constructor para indicar el espaciado horizontal y vertical, <code>GridPane(double hgap, double vgap)</code>, as\u00ed como los m\u00e9todos setters <code>setHgap(double d)</code> y <code>setVgap(double d)</code>.</p> <p>El m\u00e9todo para a\u00f1adir elementos est\u00e1 sobrescrito para recibir m\u00e1s par\u00e1metros, <code>add(Node n, int columnIndex, int rowIndex, int columnSpan, int rowSpan)</code> donde columnSpan y rowSpan son el n\u00famero de columnas y filas a unificar.</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        Button button1 = new Button(\"Button 1\");\n        Button button2 = new Button(\"Button 2\");\n        Button button3 = new Button(\"Button 3\");\n\n        GridPane gridPane = new GridPane(10, 10);\n\n        gridPane.add(button1, 0, 0);\n        gridPane.add(button2, 1, 0);\n        gridPane.add(button3, 0, 1, 1, 2);\n\n        Scene scene = new Scene(gridPane, 300, 200);\n\n        stage.setTitle(\"GridPane with unified cells example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre> <p>Con la clase <code>RowConstraints</code> podemos modificar el tama\u00f1o de la filas. Los m\u00e9todos de esta clase son:</p> <ul> <li><code>setPrefHeight()</code>: Establece la altura preferida de la fila.</li> <li><code>setMinHeight()</code>: Establece la altura m\u00ednima.</li> <li><code>setMaxHeight()</code>: Establece la altura m\u00e1xima.</li> <li><code>setPercentHeight()</code>: Establece la altura de la fila como un porcentaje de la altura total del <code>GridPane</code>.</li> <li><code>setVgrow(Priority priority)</code>: Establece la prioridad de crecimiento vertical de la fila.</li> <li><code>setFillHeight(boolean b)</code>: Especifica si las celdas de una fila deben llenar todo el espacio vertical disponible. Cuando este m\u00e9todo se establece en true, las celdas de la fila llenar\u00e1n todo el espacio disponible en la fila, ajustando la altura de los nodos hijos para que coincidan con la altura de la fila. Si se establece en false, las celdas mantendr\u00e1n su altura preferida y no llenar\u00e1n el espacio vertical adicional.</li> </ul> <p>Tambi\u00e9n existe la clase <code>ColumnConstraints</code> donde se estable el tama\u00f1o de las columnas. Los m\u00e9todos son iguales que los anteriores, pero en lugar de usar la altura (height) se usa la anchura (width).</p> <p>Para a\u00f1adir estas constraints es necesario obtener la constraint correspondiente al <code>GridPane</code>, a trav\u00e9s de los m\u00e9todos <code>getRowsConstraints()</code> y <code>getColumnsConstraints()</code>, y una vez obtenidas, se a\u00f1ade a trav\u00e9s de los m\u00e9todos <code>add()</code> o <code>addAll()</code>. Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        Button button1 = new Button(\"Button 1\");\n        Button button2 = new Button(\"Button 2\");\n        Button button3 = new Button(\"Button 3\");\n        Button button4 = new Button(\"Button 4\");\n\n        GridPane gridPane = new GridPane();\n        gridPane.setHgap(10);\n        gridPane.setVgap(10);\n        gridPane.setPadding(new Insets(10));\n\n        ColumnConstraints col1 = new ColumnConstraints();\n        col1.setPercentWidth(50);\n        ColumnConstraints col2 = new ColumnConstraints();\n        col2.setPercentWidth(50);\n\n        gridPane.getColumnConstraints().addAll(col1, col2);\n\n        RowConstraints row1 = new RowConstraints();\n        row1.setPrefHeight(100);\n        row1.setVgrow(Priority.ALWAYS);\n        row1.setFillHeight(true);  \n\n        RowConstraints row2 = new RowConstraints();\n        row2.setPrefHeight(100);\n        row2.setVgrow(Priority.NEVER);\n        row2.setFillHeight(false);  \n\n        gridPane.getRowConstraints().addAll(row1, row2);\n\n        gridPane.add(button1, 0, 0); // Columna 0, Fila 0\n        gridPane.add(button2, 1, 0); // Columna 1, Fila 0\n        gridPane.add(button3, 0, 1); // Columna 0, Fila 1\n        gridPane.add(button4, 1, 1); // Columna 1, Fila 1\n\n        Scene scene = new Scene(gridPane, 300, 200);\n\n        stage.setTitle(\"GridPane Constraints Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-3/#scrollpane","title":"ScrollPane","text":"<p><code>ScrollPane</code> en JavaFX es un contenedor que proporciona funcionalidad de desplazamiento para su contenido. Es \u00fatil cuando el contenido dentro del \u00e1rea visible del contenedor es m\u00e1s grande que el tama\u00f1o del contenedor mismo, permitiendo al usuario desplazarse para ver el contenido completo.</p> <p>A trav\u00e9s de los m\u00e9todos <code>setHbarPolicy(ScrollBarPolicy policy)</code> y <code>setVbarPolicy(ScrollBarPolicy policy)</code> establece la pol\u00edtica de barras de desplazamiento horizontal y vertical respectivamente. Las opciones disponibles son:</p> <ul> <li><code>ScrollBarPolicy.ALWAYS</code>: siempre se muestran</li> <li><code>ScrollBarPolicy.AS_NEEDED</code>: solo se muestra cuando el contenido lo require. Este es el valor por defecto.</li> <li><code>ScrollBarPolicy.NEVER</code>: no se muestra nunca.</li> </ul> <p>Los m\u00e9todos <code>setFitToWidth(boolean value)</code> y <code>setFitToHeight(boolean value)</code> establecen si el <code>ScrollPane</code> debe ajustarse autom\u00e1ticamente al ancho y/o alto de su contenido.</p> <p>A trav\u00e9s del m\u00e9todo <code>setContent(Node n)</code> se indica el contenido a mostrar. Normalmente, se suele utilizar alguno de los layouts vistos anteriormente dentro de este tipo de layout. Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n\n        Label content = new Label(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. \" +\n                \"Nullam et metus ut nisi semper fermentum eget nec elit. \" +\n                \"Sed pharetra volutpat lectus non molestie. \" +\n                \"Duis consequat nisi sit amet sem mattis, ac tempor purus gravida. \" +\n                \"Nunc dignissim feugiat urna, sed convallis arcu ultricies vel. \" +\n                \"Proin ut neque nulla. Sed sit amet varius metus, ac placerat libero.\");\n\n        ScrollPane scrollPane = new ScrollPane();\n        scrollPane.setContent(content);\n\n        scrollPane.setPrefSize(300, 200);\n\n        StackPane root = new StackPane();\n        root.getChildren().add(scrollPane);\n        Scene scene = new Scene(root, 400, 300);\n\n        stage.setTitle(\"ScrollPane Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/","title":"4 Componentes","text":""},{"location":"bloque_vi/tema_33/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos visto, los componentes en JavaFX est\u00e1n definidos como nodos por la clase <code>Node</code>. La mayor\u00eda de los controles tienen un compartimiento similar. Sin embargo, existen algunos controles m\u00e1s avanzados que requieren una especial atenci\u00f3n.</p>"},{"location":"bloque_vi/tema_33/page-4/#campos-de-texto","title":"Campos de texto","text":"<p>En JavaFX, <code>TextField</code>, <code>TextArea</code> y <code>PasswordField</code> son componentes de entrada de texto que permiten a los usuarios ingresar informaci\u00f3n de manera interactiva. Cada uno tiene caracter\u00edsticas espec\u00edficas que los hacen adecuados para diferentes tipos de entrada de datos.</p> <p><code>TextField</code> es un control de entrada de una sola l\u00ednea que permite al usuario ingresar y editar texto de longitud limitada, mientras que <code>TextArea</code> permite m\u00faltiples l\u00edneas que permite al usuario ingresar y editar texto de longitud potencialmente ilimitada. <code>PasswordFiled</code> es similar a <code>TextField</code> pero ocultando el texto escrito y suele ser \u00fatiles para contrase\u00f1as.</p> <p>Las clases tienen los siguientes m\u00e9todos en com\u00fan:</p> <ul> <li><code>setText(String text)</code>: Establece el texto dentro del campo.</li> <li><code>getText()</code>: Obtiene el texto del campo.</li> <li><code>setPromptText(String text)</code>: Establece un texto de sugerencia que aparece cuando el campo est\u00e1 vac\u00edo.</li> <li><code>clear()</code>: Elimina el contenido del campo de texto.</li> <li><code>setPrefColumnCount()</code>: Estable el n\u00famero preferido de columnas del campo.</li> </ul> <p>Para la clase <code>TextArea</code>, adem\u00e1s, existe el m\u00e9todo <code>setPrefRowCount()</code> que establece el n\u00famero preferido de filas del campo. Tambi\u00e9n se dispone del m\u00e9todo <code>setWrapText(boolean value)</code> que establece si el texto debe ajustarse autom\u00e1ticamente al tama\u00f1o del \u00e1rea de texto. Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        TextField textField = new TextField();\n        textField.setPromptText(\"Ingrese su nombre\");\n\n        TextArea textArea = new TextArea();\n        textArea.setPromptText(\"Ingrese una descripci\u00f3n\");\n\n        PasswordField passwordField = new PasswordField();\n        passwordField.setPromptText(\"Ingrese su contrase\u00f1a\");\n\n        VBox vbox = new VBox(10);\n        vbox.getChildren().addAll(textField, textArea, passwordField);\n\n        // Crear escena y configurar el escenario\n        Scene scene = new Scene(vbox, 300, 200);\n        stage.setTitle(\"Ejemplo de Controles de Entrada\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#botones","title":"Botones","text":"<p><code>Button</code> representa un bot\u00f3n est\u00e1ndar que el usuario puede clicar para activar una acci\u00f3n. Con el m\u00e9todo <code>setText(String text)</code> establece el texto que se muestra en el bot\u00f3n y <code>setDisable(boolean value)</code> habilita o deshabilita el bot\u00f3n. EL m\u00e9todo <code>fire()</code> activa el evento <code>ActionEvent</code> asociado al bot\u00f3n program\u00e1ticamente, es decir, es como hacer clic desde c\u00f3digo. Adem\u00e1s, con los m\u00e9todos <code>setDefaultButton(boolean value)</code> marca el bot\u00f3n como el bot\u00f3n predeterminado que responde a la tecla Enter en el foco de la ventana, y <code>setCancelButton(boolean value)</code> marca el bot\u00f3n como el bot\u00f3n de cancelaci\u00f3n que responde a la tecla Esc en el foco de la ventana.</p> <p><code>ToggleButton</code> es un bot\u00f3n que mantiene su estado (activado o desactivado) despu\u00e9s de ser clicado. Tiene m\u00e9todos similares a la clase <code>Button</code>, pero adem\u00e1s tiene los siguientes m\u00e9todos:</p> <ul> <li><code>isSelected()</code>: Retorna si el ToggleButton est\u00e1 seleccionado o no.</li> <li><code>setSelected(boolean selected)</code>: Establece el estado seleccionado del <code>ToggleButton</code>.</li> <li><code>toggle()</code>: Cambia el estado seleccionado del <code>ToggleButton</code> de forma program\u00e1tica.</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        Button button = new Button(\"Click Me\");\n\n        ToggleButton toggleButton = new ToggleButton(\"Toggle Me\");\n\n\n        VBox vbox = new VBox(10);\n        vbox.getChildren().addAll(button, toggleButton);\n\n        Scene scene = new Scene(vbox, 300, 200);\n\n        stage.setTitle(\"Button and ToggleButton Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#botones-de-seleccion","title":"Botones de selecci\u00f3n","text":"<p>Los botones de selecci\u00f3n son botones que al ser clicado cambia su estado, es decir, pasan de estar seleccionados a no seleccionados y viceversa. Existen dos tipos de botones de selecci\u00f3n <code>CheckBox</code> y los <code>RadioButton</code>. Los <code>Checkbox</code> permite seleccionar varias opciones mientras que los <code>RadioButton</code> pertenecientes a un mismo grupo, solo pueden ser seleccionados uno de ellos.</p> <p>Los checkboxes suelen ser utilizados para las opciones que son independientes, por ejemplo, para una lista de tareas a realizar, no es necesario que las opciones tengan relaci\u00f3n entre s\u00ed. Mientras los radios, suelen ser utilizados para aquellas opciones en la cuales solo tiene cabida que sea seleccionada una de ellas, como el sexo de una persona.</p> <p>Ambas clases tienen los siguientes m\u00e9todos comunes:</p> <ul> <li><code>setText(String text)</code>: establece el texto asociado.</li> <li><code>setSelected(boolean b)</code> establece si el bot\u00f3n est\u00e1 o no seleccionado.</li> <li><code>isSelected()</code>: devuelve si el bot\u00f3n est\u00e1 seleccionado.</li> </ul> <p>Los checkboxes, adem\u00e1s, pueden tener un tercer estado llamado indeterminado. Suele ser \u00fatil cuando necesitamos un estado intermedio entre seleccionado y no seleccionado. Por ejemplo, supongamos que tenemos checkboxes para indicar si una tarea ha sido finalizado. Si ha sido finalizada, el estado del checkbox pasa a estar seleccionado, si a\u00fan no ha sido finalizada pasa a ser no seleccionado, pero si no ha sido seleccionada pero ya se ha comenzado con ella se puede indicar como indeterminado. Para ello se usa el m\u00e9todo, <code>setIndeterminate(boolean b)</code> para indicar si su estado es indeterminado o no. Con el m\u00e9todo <code>indeterminateProperty()</code> obtiene si el estado es indeterminado.</p> <p>Los botones de selecci\u00f3n <code>RadioButton</code> deben ser implementados en un mismo grupo, por lo que es necesario crear un objeto de la clase <code>ToggleGroup</code>. A trav\u00e9s de los m\u00e9todos <code>setToggleGroup(ToggleGroup t)</code> se establece al grupo al que pertenece. Adem\u00e1s, se dispone de un m\u00e9todo getter <code>getToggleGroup()</code> que obtiene el grupo.</p> <p>Los m\u00e9todos <code>getToggles()</code> y <code>getSelectedToggle()</code>, sirve para obtener todos los elementos del grupo y el elemento seleccionado, respectivamente.</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        CheckBox checkBox1 = new CheckBox(\"Opci\u00f3n 1\");\n        CheckBox checkBox2 = new CheckBox(\"Opci\u00f3n 2\");\n\n        ToggleGroup toggleGroup = new ToggleGroup();\n        RadioButton radioButton1 = new RadioButton(\"Opci\u00f3n A\");\n        radioButton1.setToggleGroup(toggleGroup);\n        RadioButton radioButton2 = new RadioButton(\"Opci\u00f3n B\");\n        radioButton2.setToggleGroup(toggleGroup);\n\n        VBox vbox = new VBox(10);\n        vbox.getChildren().addAll(checkBox1, checkBox2, radioButton1, radioButton2);\n\n        Scene scene = new Scene(vbox, 300, 200);\n\n        stage.setTitle(\"CheckBox and RadioButton Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#controles-de-lista","title":"Controles de lista","text":""},{"location":"bloque_vi/tema_33/page-4/#combobox","title":"ComboBox","text":"<p>El <code>ComboBox</code> en JavaFX es un control que permite al usuario seleccionar una opci\u00f3n de una lista desplegable o ingresar su propia opci\u00f3n. Una de sus caracter\u00edsticas principales es su capacidad de ser editable, lo que permite al usuario ingresar texto directamente. Se puede tener una lista de opciones predefinidas pero le permite al usuario poder editar m\u00e1s opciones. Solo permite tener un \u00fanico valor seleccionado a la vez.</p> <p>El constructor <code>ComboBox(ObservableList&lt;T&gt; items)</code> puede recibir una lista observable de JavaFx como par\u00e1metro. Adem\u00e1s, se puede a\u00f1adir elementos con el m\u00e9todo <code>setItems(ObservableList&lt;T&gt; items)</code>. Tambi\u00e9n tiene un getter para obtener los elementos de la lista: <code>getItems()</code>.</p> <p>Para indicar el valor seleccionado, se puede usar el m\u00e9todo <code>setValue(T value)</code> y se puede obtener el valor a trav\u00e9s del m\u00e9todo <code>getValue()</code>. Adem\u00e1s, con el m\u00e9todo <code>setEditable(boolean b)</code> permite o no la edici\u00f3n por parte del usuario. Con el m\u00e9todo <code>isEditable()</code> se comprueba si el usuario puede o no realizar la edici\u00f3n.</p> <p>Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        ComboBox&lt;String&gt; comboBox = new ComboBox&lt;&gt;(FXCollections.observableArrayList(\"Option 1\", \"Option 2\", \"Option 3\"));\n        comboBox.setValue(\"Option 1\");\n        comboBox.setEditable(true);\n\n        StackPane root = new StackPane();\n        root.getChildren().add(comboBox);\n\n        Scene scene = new Scene(root, 300, 200);\n\n        stage.setTitle(\"ComboBox Event Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#choicebox","title":"ChoiceBox","text":"<p><code>ChoiceBox</code> es un control en JavaFX que permite al usuario seleccionar una opci\u00f3n de una lista desplegable de opciones predefinidas. Es similar a un combo box pero m\u00e1s sencillo, sin la capacidad de edici\u00f3n. Solo permite una \u00fanica opci\u00f3n seleccionada a la vez y las opciones deben ser predefinidas, ya que no permite la edici\u00f3n por parte del usuario.</p> <p>El constructor <code>ChoiceBox(ObservableList&lt;T&gt; items)</code> puede recibir una lista observable de JavaFx como par\u00e1metro. Adem\u00e1s, se puede a\u00f1adir elementos con el m\u00e9todo <code>setItems(ObservableList&lt;T&gt; items)</code>. Tambi\u00e9n tiene un getter para obtener los elementos de la lista: <code>getItems()</code>.</p> <p>Para indicar el valor seleccionado, se puede usar el m\u00e9todo <code>setValue(T value)</code> y se puede obtener el valor a trav\u00e9s del m\u00e9todo <code>getValue()</code>.</p> <p>Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        ChoiceBox&lt;String&gt; choiceBox = new ChoiceBox&lt;&gt;(FXCollections.observableArrayList(\"Option 1\", \"Option 2\", \"Option 3\"));\n\n        choiceBox.setValue(\"Option 1\");\n\n        StackPane root = new StackPane();\n        root.getChildren().add(choiceBox);\n\n        Scene scene = new Scene(root, 300, 200);\n\n        stage.setTitle(\"ChoiceBox Event Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#listview","title":"ListView","text":"<p>El <code>ListView</code> en JavaFX es un control que permite mostrar una lista desplazable de elementos. Es \u00fatil para mostrar grandes conjuntos de datos de manera organizada, permitiendo al usuario seleccionar uno o varios elementos.</p> <p>A trav\u00e9s del constructor <code>ListView(ObservableList&lt;T&gt;)</code> o del m\u00e9todo <code>setItems(ObservableList&lt;T&gt;)</code> se puede a\u00f1adir elementos a la lista. Con el m\u00e9todo <code>getItems()</code> se obtienen los elementos de la lista. Adem\u00e1s, se puede indicar la orientaci\u00f3n (vertical u horizontal) de la lista a trav\u00e9s del m\u00e9todo <code>setOrientation(Orientation o)</code> (por defecto es vertical).</p> <p>El modelo de selecci\u00f3n es un mecanismo que permite gestionar la selecci\u00f3n de elementos en controles de interfaz de usuario que contienen una colecci\u00f3n de elementos.  El modelo de selecci\u00f3n es responsable de controlar y manejar qu\u00e9 elementos est\u00e1n seleccionados en un control dado, proporcionando m\u00e9todos para acceder y manipular esta selecci\u00f3n.</p> <p>Existen dos clases principales para la selecci\u00f3n:</p> <ul> <li><code>SingleSelectionModel</code>: Utilizado para controles donde solo un elemento puede ser seleccionado a la vez.</li> <li><code>MultipleSelectionModel</code>: Utilizado para controles donde m\u00faltiples elementos pueden ser seleccionados simult\u00e1neamente.</li> </ul> <p>Ambas clases son abstractas, por lo que para indicar el modo de selecci\u00f3n, es necesario obtener el modelo con el m\u00e9todo <code>getSelectionModel()</code> que devuelve un <code>MultipleSelectionModel</code>, cuyo modo puede ser simple o m\u00faltiple. A trav\u00e9s del m\u00e9todo <code>setSelectionModel(SelectionModel mode)</code> se puede modificar su comportamiento a m\u00faltiple, a trav\u00e9s de <code>SelectionModel.MULTIPLE</code> o a simple (por defecto) <code>SelectionModel.SINGLE</code>. Otros m\u00e9todos de inter\u00e9s de la clase <code>MultipleSelectionModel</code> son:</p> <ul> <li><code>getSelectedItem()</code>: Retorna el valor seleccionado.</li> <li><code>getSelectedItems()</code>: Devuelve una lista observable de los elementos actualmente seleccionados (relevante para modelos de selecci\u00f3n m\u00faltiple).</li> <li><code>select(T item)</code>: Selecciona el elemento especificado.</li> <li><code>select(int index)</code>: Selecciona el elemento en el \u00edndice especificado.</li> <li><code>clearSelection()</code>: Deselecciona todos los elementos.</li> <li><code>isSelected(int index)</code>: Devuelve <code>true</code> si el elemento en el \u00edndice especificado est\u00e1 seleccionado.</li> </ul> <p>Con el m\u00e9todo <code>setCellFactory(Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; valu)</code> se utiliza para proporcionar una manera personalizada de representar cada celda en la lista, es decir, permite definir c\u00f3mo se deben mostrar los elementos en el <code>ListView</code>, lo que es \u00fatil cuando necesitas una representaci\u00f3n m\u00e1s compleja que el simple texto. Un <code>CellFactory</code> es responsable de crear las celdas que se utilizar\u00e1n para representar los elementos del ListView. Al definir un CellFactory personalizado, puedes controlar exactamente c\u00f3mo se debe mostrar cada elemento de la lista.</p> <p>Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        ObservableList&lt;String&gt; items = FXCollections.observableArrayList(\n                \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\");\n\n        ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);\n        listView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n\n        listView.setCellFactory(new Callback&lt;&gt;() {\n            @Override\n            public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {\n                return new ListCell&lt;&gt;() {\n                    @Override\n                    protected void updateItem(String item, boolean empty) {\n                        super.updateItem(item, empty);\n                        if (empty || item == null) {\n                            setText(null);\n                        } else {\n                            setText(\"Customized: \" + item);\n                        }\n                    }\n                };\n            }\n        });\n\n        StackPane root = new StackPane();\n        root.getChildren().add(listView);\n\n        Scene scene = new Scene(root, 300, 200);\n\n        stage.setTitle(\"ListView Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#imageview","title":"ImageView","text":"<p><code>ImageView</code> es una clase en JavaFX que se utiliza para mostrar im\u00e1genes. Es una parte fundamental del paquete <code>javafx.scene.image</code> y ofrece una amplia gama de funcionalidades para manipular y mostrar im\u00e1genes en la interfaz gr\u00e1fica de una aplicaci\u00f3n JavaFX. Entre sus caracter\u00edsticas principales encontramos:</p> <ul> <li>Cargar im\u00e1genes desde archivos, URL o recursos</li> <li>Escalar, recortar y ajustar im\u00e1genes</li> <li>Rotar im\u00e1genes</li> <li>Aplicar efectos a las im\u00e1genes</li> </ul> <p>Para utilizar un <code>ImageView</code>, generalmente primero creas una instancia de la clase <code>Image</code>, que contiene la imagen que deseas mostrar, y luego pasas esa instancia al constructor del <code>ImageView(Image i)</code>.</p> <p>A trav\u00e9s del m\u00e9todo <code>setImage(Image i)</code> se puede especificar la imagen a mostrar. Con el m\u00e9todo <code>getImage()</code> se obtiene la imagen. Con los m\u00e9todos <code>setFitWidth(double value)</code> y <code>setFitHeight(double value)</code> se establece el ancho y alto al que se debe ajustar la imagen. Si se desea preservar la relaci\u00f3n aspecto de la imagen, se puede utilizar el m\u00e9todo <code>setPreserveRatio(boolean b)</code> con el par\u00e1metro a <code>true</code>.</p> <p>Con el m\u00e9todo <code>setSmooth(boolean value)</code> se establece si se debe aplicar un filtrado suave al escalar la imagen. Y, con el m\u00e9todo <code>setRotate(double angle)</code> se rota la imagen en el \u00e1ngulo especificado.</p> <p>Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        Image image = new Image(\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/b6/Image_created_with_a_mobile_phone.png/220px-Image_created_with_a_mobile_phone.png\");\n\n        ImageView imageView = new ImageView(image);\n\n        imageView.setFitWidth(300);\n        imageView.setFitHeight(300);\n        imageView.setPreserveRatio(true);\n        imageView.setSmooth(true);\n        imageView.setRotate(30);\n\n        StackPane root = new StackPane();\n        root.getChildren().add(imageView);\n\n        Scene scene = new Scene(root, 400, 400);\n\n        stage.setTitle(\"ImageView Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#slider","title":"Slider","text":"<p>El <code>Slider</code> es un control de interfaz de usuario en JavaFX que permite al usuario seleccionar un valor num\u00e9rico de un rango continuo arrastrando un indicador a lo largo de una barra. Es \u00fatil en situaciones donde se necesita un control preciso y visualmente intuitivo para seleccionar valores dentro de un rango definido.</p> <p>Para configurar un Slider se puede utilizar los getters y setters de las siguientes propiedades:</p> <ul> <li><code>min</code>: El valor m\u00ednimo del rango del Slider.</li> <li><code>max</code>: El valor m\u00e1ximo del rango del Slider.</li> <li><code>value</code>: El valor actual del Slider.</li> <li><code>showTickMarks</code>: Muestra u oculta las marcas de las unidades en el Slider.</li> <li><code>showTickLabels</code>: Muestra u oculta las etiquetas de los valores en el Slider.</li> <li><code>majorTickUnit</code>: Define la distancia entre las marcas principales en el Slider.</li> <li><code>minorTickCount</code>: Define la cantidad de marcas menores entre dos marcas principales.</li> <li><code>blockIncrement</code>: Define el incremento de los valores cuando se usa el teclado para mover el Slider.</li> <li><code>orientation</code>: Define la orientaci\u00f3n del Slider (horizontal o vertical).</li> </ul> <pre><code>\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#progresos","title":"Progresos","text":"<p>En JavaFX, <code>ProgressBar</code> y <code>ProgressIndicator</code> son componentes utilizados para mostrar el progreso de una operaci\u00f3n en curso en una aplicaci\u00f3n. Ambos sirven para indicar visualmente al usuario cu\u00e1nto tiempo o qu\u00e9 parte de una tarea se ha completado.</p> <p><code>ProgressBar</code> es un componente visual que muestra el progreso de una tarea en forma de una barra horizontal. Mientras que, <code>ProgressIndicator</code> es un componente visual que muestra el progreso de una tarea en forma de un indicador circular o lineal.</p> <p>SA trav\u00e9s del m\u00e9todo <code>setProgress(double value)</code> se establece el valor de progreso del indicador. El valor debe estar entre 0.0 y 1.0, donde 0.0 indica que no se ha iniciado la tarea y 1.0 indica que la tarea est\u00e1 completa. Si se indica -1 (ProgressBar.INDETERMINATE_PROGRESS o ProgressIndicator.INDETERMINATE_PROGRESS), estable que el indicador del progreso se indeterminado, es decir, el indicador muestra animaci\u00f3n continua mientras se desconoce la duraci\u00f3n de la tarea.</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        ProgressBar progressBar = new ProgressBar();\n        progressBar.setProgress(0.6); // Establecer progreso al 60%\n\n        ProgressIndicator progressIndicator = new ProgressIndicator();\n        progressIndicator.setProgress(0.25); // Establecer progreso al 25%\n\n        ProgressIndicator progressIndeterminate = new ProgressIndicator();\n        progressIndeterminate.setProgress(ProgressIndicator.INDETERMINATE_PROGRESS);\n\n        VBox vbox = new VBox(20);\n        vbox.getChildren().addAll(progressBar, progressIndicator, progressIndeterminate);\n\n        Scene scene = new Scene(vbox, 300, 150);\n\n        stage.setTitle(\"ProgressBar and ProgressIndicator Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#tableview","title":"TableView","text":"<p><code>TableView</code> es una clase en JavaFX que se utiliza para mostrar datos tabulares. Es similar a una tabla en una hoja de c\u00e1lculo o una base de datos, y permite a los desarrolladores crear tablas de forma sencilla en sus aplicaciones. TableView es parte del paquete <code>javafx.scene.control</code>. Entre sus caracter\u00edsticas, encontramos:</p> <ul> <li>Mostrar datos en filas y columnas</li> <li>Soporte para m\u00faltiples tipos de datos</li> <li>Ordenaci\u00f3n y filtrado de datos</li> <li>Selecci\u00f3n de filas y celdas</li> <li>Personalizaci\u00f3n de celdas mediante CellFactory</li> </ul> <p>Para utilizar un <code>TableView</code>, debes definir las columnas y los datos que se mostrar\u00e1n. Cada columna se representa mediante una instancia de <code>TableColumn</code>, y los datos se organizan en filas utilizando una lista observable (<code>ObservableList</code>).</p> <p>Las columnas tiene un compartimiento similar a <code>ListView</code>. Veamos un ejemplo:</p> PersonApp <pre><code>public class Person {\n    private final StringProperty firstName;\n    private final StringProperty lastName;\n\n    public Person(String firstName, String lastName) {\n        this.firstName = new SimpleStringProperty(firstName);\n        this.lastName = new SimpleStringProperty(lastName);\n    }\n\n    public String getFirstName() {\n        return firstName.get();\n    }\n\n    public void setFirstName(String firstName) {\n        this.firstName.set(firstName);\n    }\n\n    public StringProperty firstNameProperty() {\n        return firstName;\n    }\n\n    public String getLastName() {\n        return lastName.get();\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName.set(lastName);\n    }\n\n    public StringProperty lastNameProperty() {\n        return lastName;\n    }\n}\n</code></pre> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        TableView&lt;Person&gt; tableView = new TableView&lt;&gt;();\n\n        TableColumn&lt;Person, String&gt; firstNameColumn = new TableColumn&lt;&gt;(\"First Name\");\n        firstNameColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(\"firstName\"));\n\n        TableColumn&lt;Person, String&gt; lastNameColumn = new TableColumn&lt;&gt;(\"Last Name\");\n        lastNameColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(\"lastName\"));\n\n        tableView.getColumns().add(firstNameColumn);\n        tableView.getColumns().add(lastNameColumn);\n\n        firstNameColumn.setCellFactory(new Callback&lt;&gt;() {\n            @Override\n            public TableCell&lt;Person, String&gt; call(TableColumn&lt;Person, String&gt; param) {\n                return new TableCell&lt;&gt;() {\n                    @Override\n                    protected void updateItem(String item, boolean empty) {\n                        super.updateItem(item, empty);\n                        if (item == null || empty) {\n                            setText(null);\n                        } else {\n                            setText(\"Name: \" + item);\n                        }\n                    }\n                };\n            }\n        });\n\n\n        ObservableList&lt;Person&gt; data = FXCollections.observableArrayList(\n                new Person(\"John\", \"Doe\"),\n                new Person(\"Jane\", \"Doe\"),\n                new Person(\"Mike\", \"Smith\")\n        );\n\n        tableView.setItems(data);\n\n        tableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n\n\n        StackPane root = new StackPane();\n        root.getChildren().add(tableView);\n\n        Scene scene = new Scene(root, 400, 300);\n\n        stage.setTitle(\"Row Selection TableView Example\");\n        stage.setScene(scene);\n        stage.show();\n\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre> <p>Como puedes observar, en el ejemplo anterior, las propiedad de la clase <code>Person</code> son de tipo <code>StringProperty</code>. Este tipo de propiedades son espec\u00edficas de JavaFX y tiene una serie de ventajas:</p> <ul> <li>Observabilidad: Las propiedades de JavaFX (StringProperty, IntegerProperty, etc.) son observables. Esto significa que puedes agregar listeners para reaccionar autom\u00e1ticamente a los cambios en los valores de estas propiedades.</li> <li>Enlace de Datos (Data Binding): Las propiedades permiten el enlace de datos, lo que facilita la sincronizaci\u00f3n de datos entre el modelo y la vista. Esto es \u00fatil para mantener la interfaz de usuario actualizada autom\u00e1ticamente cuando cambian los datos subyacentes.</li> <li>Compatibilidad con Controles JavaFX: Muchos controles JavaFX, como <code>TableView</code>, est\u00e1n dise\u00f1ados para trabajar directamente con propiedades observables.</li> </ul>"},{"location":"bloque_vi/tema_33/page-4/#treeview","title":"TreeView","text":"<p><code>TreeView</code> es una clase en JavaFX que se utiliza para mostrar datos jer\u00e1rquicos en forma de \u00e1rbol. Cada elemento en un <code>TreeView</code> es un <code>TreeItem</code>, que puede contener subelementos, permitiendo la creaci\u00f3n de estructuras de datos anidadas. Es \u00fatil para mostrar informaci\u00f3n que tiene una estructura de \u00e1rbol, como sistemas de archivos, estructuras organizativas, etc. Sus caracter\u00edsticas son:</p> <ul> <li>Mostrar datos jer\u00e1rquicos</li> <li>Expandir y contraer nodos</li> <li>Personalizaci\u00f3n de celdas</li> <li>Soporte para m\u00faltiples tipos de datos</li> </ul> <p>Veamos sus m\u00e9todos principales:</p> <ul> <li><code>setRoot(TreeItem&lt;T&gt; root)</code>: Establece el nodo ra\u00edz del TreeView.</li> <li><code>getRoot()</code>: Obtiene el nodo ra\u00edz del TreeView.</li> <li><code>getSelectionModel()</code>: Obtiene el modelo de selecci\u00f3n del TreeView.</li> <li><code>setCellFactory(Callback&lt;&gt; c)</code>: Permite personalizar la apariencia de las celdas en un <code>TreeView</code> utilizando una <code>TreeCellFactory</code>.</li> <li><code>setExpanded(boolean b)</code>: Expande o no el \u00e1rbol.</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(\"Root\");\n        rootItem.setExpanded(true);\n\n        TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(\"Item 1\");\n        TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(\"Item 2\");\n        TreeItem&lt;String&gt; item3 = new TreeItem&lt;&gt;(\"Item 3\");\n\n        rootItem.getChildren().addAll(item1, item2, item3);\n\n        // Crear nodos hijos para item1\n        TreeItem&lt;String&gt; item1Child1 = new TreeItem&lt;&gt;(\"Item 1.1\");\n        TreeItem&lt;String&gt; item1Child2 = new TreeItem&lt;&gt;(\"Item 1.2\");\n        item1.getChildren().addAll(item1Child1, item1Child2);\n\n        // Crear un TreeView y a\u00f1adir el nodo ra\u00edz\n        TreeView&lt;String&gt; treeView = new TreeView&lt;&gt;(rootItem);\n\n        // A\u00f1adir el TreeView a un layout\n        StackPane root = new StackPane();\n        root.getChildren().add(treeView);\n\n        // Crear una escena y a\u00f1adir el layout\n        Scene scene = new Scene(root, 300, 250);\n\n        // Configurar el escenario\n        stage.setTitle(\"TreeView Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#datepicker-y-colorpicker","title":"DatePicker y ColorPicker","text":"<p><code>DatePicker</code> es un control de JavaFX que permite al usuario seleccionar una fecha desde un calendario emergente. Es \u00fatil para aplicaciones donde se necesita ingresar o seleccionar fechas.</p> <ul> <li>Permite seleccionar fechas.</li> <li>Puede ser inicializado con una fecha espec\u00edfica.</li> <li>Se puede personalizar el formato de la fecha.</li> <li>Permite a\u00f1adir listeners para manejar cambios en la fecha seleccionada.</li> </ul> <p><code>ColorPicker</code> es un control de JavaFX que permite al usuario seleccionar un color desde un di\u00e1logo emergente. Es \u00fatil para aplicaciones donde se necesita seleccionar colores.</p> <ul> <li>Permite seleccionar colores.</li> <li>Puede ser inicializado con un color espec\u00edfico.</li> <li>Permite a\u00f1adir listeners para manejar cambios en el color seleccionado.</li> </ul>"},{"location":"bloque_vi/tema_33/page-4/#tabpane","title":"TabPane","text":"<p><code>TabPane</code> es un contenedor en JavaFX que permite organizar el contenido de una aplicaci\u00f3n en pesta\u00f1as. Cada pesta\u00f1a puede contener diferentes nodos o layouts, proporcionando una manera conveniente de mostrar y alternar entre diferentes vistas o funcionalidades en una sola ventana.</p> <p>Con la clase <code>Tab</code> se puede crear una pesta\u00f1a. A trav\u00e9s de su m\u00e9todo <code>setContent(Node n)</code> se indica el contenido de la pesta\u00f1a.</p> <p>Por defecto, las pesta\u00f1as tienen la opci\u00f3n de ser cerrada, eso se puede impedir, haciendo uso del m\u00e9todo <code>setTabClosingPolicy(TabClosingPolicy t)</code>. Veamos un ejemplo:</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        Tab tab1 = new Tab(\"Tab 1\");\n        Tab tab2 = new Tab(\"Tab 2\");\n        Tab tab3 = new Tab(\"Tab 3\");\n\n        StackPane tab1Content = new StackPane();\n        tab1Content.getChildren().add(new Label(\"Content of Tab 1\"));\n\n        StackPane tab2Content = new StackPane();\n        tab2Content.getChildren().add(new Label(\"Content of Tab 2\"));\n\n        StackPane tab3Content = new StackPane();\n        tab3Content.getChildren().add(new Label(\"Content of Tab 3\"));\n\n        tab1.setContent(tab1Content);\n        tab2.setContent(tab2Content);\n        tab3.setContent(tab3Content);\n\n        TabPane tabPane = new TabPane();\n        tabPane.getTabs().addAll(tab1, tab2, tab3);\n        tabPane.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE);\n\n        Scene scene = new Scene(tabPane, 400, 300);\n\n        stage.setTitle(\"TabPane Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#menubar","title":"MenuBar","text":"<p><code>MenuBar</code> en JavaFX es un componente que permite crear y gestionar men\u00fas dentro de una aplicaci\u00f3n. Es \u00fatil para agrupar opciones y funcionalidades en una estructura organizada de men\u00fas y submen\u00fas, proporcionando una forma est\u00e1ndar y accesible para que los usuarios interact\u00faen con la aplicaci\u00f3n.</p> <p>La clase <code>Menu</code> representa una opci\u00f3n del men\u00fa principal, y la clase <code>MenuItem</code> representa un hijo de dicha clase <code>Menu</code>.</p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        Menu fileMenu = new Menu(\"File\");\n        MenuItem newMenuItem = new MenuItem(\"New\");\n        MenuItem openMenuItem = new MenuItem(\"Open\");\n        MenuItem saveMenuItem = new MenuItem(\"Save\");\n        MenuItem exitMenuItem = new MenuItem(\"Exit\");\n\n        fileMenu.getItems().addAll(newMenuItem, openMenuItem, saveMenuItem, exitMenuItem);\n\n        Menu editMenu = new Menu(\"Edit\");\n        MenuItem cutMenuItem = new MenuItem(\"Cut\");\n        MenuItem copyMenuItem = new MenuItem(\"Copy\");\n        MenuItem pasteMenuItem = new MenuItem(\"Paste\");\n\n        editMenu.getItems().addAll(cutMenuItem, copyMenuItem, pasteMenuItem);\n\n        MenuBar menuBar = new MenuBar();\n        menuBar.getMenus().addAll(fileMenu, editMenu);\n\n        BorderPane borderPane = new BorderPane();\n        borderPane.setTop(menuBar);\n\n        Scene scene = new Scene(borderPane, 400, 300);\n\n        stage.setTitle(\"MenuBar Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-4/#contextmenu","title":"ContextMenu","text":"<p>Un pop-up menu (men\u00fa emergente) en JavaFX se puede implementar utilizando la clase <code>ContextMenu</code>. Este tipo de men\u00fa proporciona opciones contextuales que aparecen en respuesta a una acci\u00f3n espec\u00edfica del usuario, como hacer clic con el bot\u00f3n derecho del rat\u00f3n sobre un elemento. Tiene un funcionamiento similar a <code>MenuBar</code></p> <pre><code>public class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) throws IOException {\n        TextArea textArea = new TextArea();\n        textArea.setPrefSize(300, 200);\n\n        ContextMenu contextMenu = new ContextMenu();\n        MenuItem cutMenuItem = new MenuItem(\"Cut\");\n        MenuItem copyMenuItem = new MenuItem(\"Copy\");\n        MenuItem pasteMenuItem = new MenuItem(\"Paste\");\n\n        contextMenu.getItems().addAll(cutMenuItem, copyMenuItem, pasteMenuItem);\n\n        textArea.setContextMenu(contextMenu);\n\n        StackPane root = new StackPane();\n        root.getChildren().add(textArea);\n\n        Scene scene = new Scene(root, 400, 300);\n\n        stage.setTitle(\"ContextMenu Example\");\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-5/","title":"5 Eventos","text":""},{"location":"bloque_vi/tema_33/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Las aplicaciones gr\u00e1ficas son dirigidas por eventos, es decir, ejecutar\u00e1n diferente c\u00f3digo en funci\u00f3n de los eventos que produzcan. Estos eventos pueden ser generados por los usuarios, una aplicaci\u00f3n o un sistema.</p> <p>Un evento es un cambio de estado en un dispositivo, una acci\u00f3n de un usuario, o una tarea en segundo plano. Los eventos pueden ser lanzados como resultado de hacer scroll o editar nodos complejos, como <code>TableView</code> o <code>TreeView</code>.</p> <p>En las aplicaciones JavaFX existe un hilo que escucha los eventos que se producen. Cuando un evento es lanzado, el hilo de la interfaz gr\u00e1fica comprueba si hay un manejador de eventos registrado para ese evento, y as\u00ed ejecutarlo.</p>"},{"location":"bloque_vi/tema_33/page-5/#event","title":"Event","text":"<p>La clase que representa los eventos en JavaFX es <code>Event</code> del paquete <code>javafx.event</code>. Esta clase tiene muchas subclases que representan los distintos eventos que pueden suceder en un aplicaci\u00f3n, como <code>MouseEvent</code>, <code>KeyEvent</code>, <code>WindowEvent</code>, etc.</p> <p>Cada evento tiene las siguientes propiedades:</p> <ul> <li>Source: objeto donde se ha registrado el manejador del evento.</li> <li>Target: objeto donde se ha producido el evento. Por ejemplo, un bot\u00f3n.</li> <li>Type: tipo de evento producido. Por ejemplo, presionar un bot\u00f3n, una tecla, etc.</li> </ul> <p>El objeto donde se gener\u00f3 el evento delega la tarea de manejo de eventos al controlador de eventos cuando ocurre el evento, el objeto de origen crea un objeto de evento y lo env\u00eda al controlador de eventos registrado.</p> <p>Cuando se produce un evento se determina la ruta del evento mediante un Event Dispatch chain que no es m\u00e1s que un camino donde <code>Stage</code> vincula el nodo de origen del evento. Una vez construido el evento, viaja desde el nodo ra\u00edz hasta el nodo fuente del evento (fase captura). Si alg\u00fan nodo tiene un filtro registrado para el evento, se ejecutar\u00e1. Durante la fase de burbuja (bubbling phase) el evento viaja en sentido inverso, desde el nodo a la ra\u00edz. Si alg\u00fan nodo tiene un controlador registrado para el evento, se ejecutar\u00e1</p> <p>Algunos nodos, como el bot\u00f3n, consumen el evento, por lo que no se propaga a trav\u00e9s de cadena de nodos.</p>"},{"location":"bloque_vi/tema_33/page-5/#eventhandler","title":"EventHandler","text":"<p>JavaFX tiene una \u00fanica interfaz para todos los manejadores de eventos, <code>EventHandler&lt;T extends Event&gt;</code>, parametrizada con un tipo que sea hijo de la clase <code>Event</code>:</p> <pre><code>classDiagram\n    class EventHandler~T extends Event~\n    &lt;&lt;interface&gt;&gt; EventHandler\n\n    EventHandler: handler(event T)\n</code></pre> Figura 14 - EventHandler <p>Para responder a un evento, es necesario implementar la interfaz <code>EventHandler</code>. Para ello, habr\u00e1 que indicar el tipo de evento a manejar.</p> <p>Para agregar estos manejadores de eventos puede usarse el m\u00e9todo <code>addEventHandler(EventType&lt;T&gt; type, EventHandler&lt;? extends T&gt;)</code>, donde se indica el tipo de evento, y el manejador de eventos.</p>"},{"location":"bloque_vi/tema_33/page-5/#tipos-de-eventos","title":"Tipos de eventos","text":"<p>En JavaFX existen diferentes tipos de eventos:</p> <ul> <li><code>ActionEvent</code>: Ocurren cuando un usuario realiza una acci\u00f3n espec\u00edfica. Los eventos comunes es <code>ACTION</code>.</li> <li><code>MouseEvent</code>: Incluyen acciones del rat\u00f3n, como hacer clic, mover el rat\u00f3n, presionar o soltar botones del rat\u00f3n. Sus eventos son: <code>MOUSE_CLICKED</code> para cuando se hace click en el rat\u00f3n, <code>MOUSE_ENTERED</code> para cuando el rat\u00f3n entra en un Nodo, y <code>MOUSE_EXITED</code>, para cuando sale.</li> <li><code>KeyEvent</code>: Se activan cuando el usuario interact\u00faa con el teclado, como presionar o soltar una tecla. Sus acciones son: <code>KEY_PRESSED</code> para cuando se presiona una tecla, <code>KEY_RELEASED</code> para cunado se deja de presionar una tecla, <code>KEY_TYPED</code> para cuando una tecla ya ha sido escrita (se produce despu\u00e9s de <code>KEY_PRESSED</code>).</li> <li><code>ChangeEvent</code>: Ocurren cuando hay cambios en el estado de un control.</li> <li><code>FocusEvent</code>: Se disparan cuando un nodo obtiene o pierde el foco.</li> <li><code>DragEvent</code>: Se utilizan cuando el usuario arrastra elementos dentro de la aplicaci\u00f3n y los suelta. Sus acciones son: <code>DRAG_DETECTED</code> que representa un evento cuando se inicia un gesto de arrastre y <code>DRAG_DROPPED</code> que representa un evento cuando se suelta un objeto durante un gesto de arrastre.</li> <li><code>ScrollEvent</code>: Ocurren cuando se realiza un desplazamiento (scroll) con el rat\u00f3n o la rueda del rat\u00f3n. <code>SCROLL</code> es la acci\u00f3n que representa un evento de desplazamiento, que ocurre cuando el usuario usa la rueda del rat\u00f3n o realiza un desplazamiento t\u00e1ctil.</li> <li><code>WindowEvent</code>: Se activan cuando ocurren cambios en el estado de la ventana de la aplicaci\u00f3n, como abrir, cerrar, maximizar, minimizar, etc. Sus eventos son: <code>WINDOW_SHOWN</code> que representa un evento cuando la ventana se muestra y <code>WINDOW_HIDDEN</code> cuando se oculta.</li> </ul> <p>Algunas clases en JavaFX definen propiedades para el manejo de eventos, que proporcionan una forma de registrar manejadores de eventos. Los setters de estas propiedades permitir\u00e1n registrar manejadores de eventos, su sintaxis es : <code>setOnEventXXX(EventHandler&lt;T extends Event&gt;)</code> donde <code>XXX</code> es el tipo de evento. Por ejemplo para <code>MouseEvent</code> tenemos <code>setOnEventMouseClicked</code></p> <pre><code>button.setOnMouseClicked(event -&gt; System.out.println(\"Hi!\"))\n</code></pre>"},{"location":"bloque_vi/tema_33/page-6/","title":"6 Manejo de cambios","text":""},{"location":"bloque_vi/tema_33/page-6/#propiedades","title":"Propiedades","text":"<p>Una propiedad en JavaFX es un tipo especial de variable de un objeto JavaFX. Las propiedades JavaFX son usadas para almacenar informaci\u00f3n de un objeto. Adem\u00e1s, las propiedades tienen la capacidad de notificar cambios de sus valores y tambi\u00e9n permiten hacer asociaciones con propiedades de otros los objetos. Las propiedades deben ser clases que implementen la interfaz <code>ObservableValue</code>.</p> <p><code>ObservableValue</code> es una interfaz que representa un valor observable, es decir, un valor cuyo cambio puede ser observado por otros objetos. Esta interfaz se encuentra en el paquete <code>javafx.beans.value</code> y es fundamental para implementar el patr\u00f3n de dise\u00f1o <code>Observer/Observable</code> en el contexto de las propiedades observables.</p> <p>JavaFX proporciona varias implementaciones de <code>ObservableValue</code> para diferentes tipos de propiedades, como <code>BooleanProperty</code>, <code>IntegerProperty</code>, <code>DoubleProperty</code>, <code>StringProperty</code>, etc. Es ampliamente utilizado en JavaFX para sincronizar autom\u00e1ticamente los cambios de estado de los datos con la interfaz de usuario, asegurando que los componentes gr\u00e1ficos reflejen siempre el estado actual de los datos.</p> <p>A continuaci\u00f3n se presentan algunos m\u00e9todos comunes que se encuentran en la interfaz ObservableValue:</p> <ul> <li><code>addListener(ChangeListener&lt;? super T&gt; listener)</code>: Permite registrar un <code>ChangeListener</code> que ser\u00e1 notificado cuando el valor observado cambie.</li> <li><code>removeListener(ChangeListener&lt;? super T&gt; listener)</code>: Permite eliminar un <code>ChangeListener</code> registrado previamente.</li> <li><code>getValue()</code>: Retorna el valor actual del <code>ObservableValue</code>.</li> <li><code>setValue(T value)</code>: Cambia el valor de la propiedad al valor dado.</li> </ul> <p>Algunos componentes, como <code>CheckBox</code> o <code>RadioButton</code> utilizan estas propiedades internamente. Tambi\u00e9n propiedades como <code>Label</code> o <code>TextField</code> las contiene. Para acceder a ellas, como valores observables, se puede acceder a trav\u00e9s de los m\u00e9todos <code>xxxProperty()</code> donde <code>xxx</code> es el tipo de dato. Por ejemplo, para acceder al texto observable de un <code>Label</code>, se acceder\u00eda a trav\u00e9s de <code>textProperty()</code>.</p> <p>Tambi\u00e9n es posible asociar propiedades entre s\u00ed, de tal forma que cuando se produzca un cambio en alguna propiedad, autom\u00e1ticamente se cambie la propiedad asociada, es decir, cuando dos variables est\u00e1n asociadas, un cambio de una se ve reflejada en la otra. Para asociar una propiedad a otra es necesario utilizar el m\u00e9todo <code>bind(ObjectValue&lt;? extends T&gt; property)</code> de las propiedades. Veamos un ejemplo:</p> <pre><code>Slider slider = new Slider(0, 1, 0);\n\nProgressBar bar = new ProgressBar(0);\nbar.setMaxWidth(Double.MAX_VALUE);\nbar.progressProperty().bind(slider.valueProperty);\n</code></pre> <p>En el ejemplo anterior, se est\u00e1 asociando el valor del slider a la barra de progreso, por lo que cuando cambie el valor del slider, tambi\u00e9n cambiar\u00e1 el valor de la barra de progreso. En este caso, estamos ante una asociaci\u00f3n unidireccional, es decir, los cambios de una propiedad se ve reflejada en la otra, pero no al rev\u00e9s. Para que una asociaci\u00f3n sea bidireccional es necesario utilizar el m\u00e9todo <code>bindDirectional(Property&lt;T&gt; property)</code>. Por el contrario, se puede desasociar dos propiedades, haciendo uso del m\u00e9todo <code>unbind()</code> para asociaciones unidireccionales y <code>unbindBidirectional(Property&lt;T&gt; other)</code> para bidireccionales.</p> <p>Para hacer cualquier objeto en JavaFX como un valor observable, puedes utilizar las clases provistas en el paquete <code>javafx.beans.property</code>, como <code>SimpleObjectProperty</code> o <code>ReadOnlyObjectWrapper</code>. Estas clases permiten envolver un objeto y proporcionar m\u00e9todos para acceder y modificar ese objeto de manera observable, es decir, permiten detectar cambios en su valor y notificar a los listeners registrados. <code>SimpleObjectProperty</code> es mutable, es decir, permite lectura y escritura, mientras que <code>ReadOnlyObjectWrapper</code> es inmutable, es decir, solo permite lectura.</p>"},{"location":"bloque_vi/tema_33/page-6/#changelistener","title":"ChangeListener","text":"<p><code>ChangeListener</code> es una interfaz funcional y gen\u00e9rica que se utiliza para escuchar cambios en un <code>ObservableValue</code>. Esta interfaz permite detectar y manejar eventos cuando el valor de una propiedad observable cambia. En el caso espec\u00edfico de un CheckBox, podemos utilizar un <code>ChangeListener</code> para ser notificados cuando el estado seleccionado del <code>CheckBox</code> cambia.</p> <p>El m\u00e9todo de dicha interfaz es <code>change(ObservableValue&lt;? extends T&gt; observable, T oldValue, T newValue)</code>, que recibe el objeto observable cuyo valor ha cambiado, el viejo valor y el nuevo valor.</p> <p>Cuando se registra un <code>ChangeListener</code> a un <code>ObservableValue</code>, el m\u00e9todo <code>changed</code> se ejecutar\u00e1 cada vez que el valor del <code>ObservableValue</code> cambie. Dentro del m\u00e9todo <code>changed</code>, puedes implementar la l\u00f3gica para manejar y responder al cambio de valor. Por ejemplo, actualizaci\u00f3n de la interfaz de usuario, procesamiento de datos, o cualquier acci\u00f3n basada en el cambio detectado.</p> <pre><code>IntegerProperty counter = new SimpleIntegerProperty(0);\n\ncounter.addListener(new ChangeListener&lt;Number&gt;() {\n    @Override\n    public void changed(ObservableValue&lt;? extends Number&gt; observable, Number oldValue, Number newValue) {\n        System.out.println(\"Contador ha cambiado de \" + oldValue + \" a \" + newValue);\n    }\n});\n\ncounter.set(1); \ncounter.set(5); \n</code></pre>"},{"location":"bloque_vi/tema_33/page-6/#colecciones-javafx","title":"Colecciones JavaFX","text":"<p>En JavaFX, existe el paquete <code>javafx.collections</code> que re\u00fane una serie de interfaces y clases para las colecciones de JavaFX, entre ellas encontramos:</p> <ul> <li><code>ObservableList</code>: Interfaz que representa una lista que permite a los listeners detectar los cambios que producen.</li> <li><code>ListChangeListener</code>: Interfaz que recibe las notificaciones de cambios de un <code>ObservableList</code></li> <li><code>FXCollections</code>: Clase de utilidad con m\u00e9todos est\u00e1ticos que son copias de los m\u00e9todos de la clase <code>java.util.Collections</code>.</li> <li><code>ListChangeListener.Change</code>: Clase que representa un cambio realizado por un <code>ObservableList</code>.</li> </ul> <p>Existe clases e interfaces parecidas para mapas y conjunto observables. Sus nombres son parecidos a lo de las listas observables, pero el lugar de usar <code>List</code> se usar\u00eda <code>Map</code> o <code>Set</code>, respectivamente. Por ejemplo, existe la interfaz <code>ObservableMap</code> para mapas y <code>ObservableSet</code> para conjuntos.</p> <p>En el siguiente ejemplo, se observa los cambios desarrollados en una lista:</p> <pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n\nObservableList&lt;String&gt; observableList = FXCollections.observableList(list);\n\nobservableList.addListener(new ListChangeListener(){\n    @Override\n    public void onChanged(ListChangeListener.Change change){\n        System.out.println(\"Detected change!\");\n    }\n});\n</code></pre> <p>Hasta ahora, hemos visto algunos componentes donde era necesario indicar los elementos de dicho componente como una lista observable.</p> <p>Cuando se modifica la lista (se a\u00f1aden, eliminan o modifican elementos), se generan eventos de cambio que notifican a los listeners sobre los detalles espec\u00edficos de la modificaci\u00f3n.</p> <p><code>ObservableList</code> est\u00e1 dise\u00f1ada para ser utilizada en conjunto con componentes gr\u00e1ficos de JavaFX, como <code>ListView</code>, <code>TableView</code>, <code>ComboBox</code>, etc., para mantener la sincronizaci\u00f3n autom\u00e1tica entre los datos y la interfaz de usuario.</p> <p>A continuaci\u00f3n se presentan algunos m\u00e9todos comunes que se encuentran en la interfaz <code>ObservableList</code>:</p> <ul> <li><code>addListener(InvalidationListener listener)</code>: Permite registrar un <code>InvalidationListener</code> que ser\u00e1 notificado cuando la lista se invalide. Esto significa que la lista ha cambiado estructuralmente de alguna manera y puede requerir que se vuelva a consultar.</li> <li><code>addListener(ListChangeListener&lt;? super E&gt; listener)</code>: Permite registrar un <code>ListChangeListener</code> que ser\u00e1 notificado cuando se realicen cambios estructurales en la lista, como a\u00f1adir, eliminar o reordenar elementos.</li> <li><code>removeListener(InvalidationListener listener)</code>: Permite eliminar un <code>InvalidationListener</code> registrado previamente.</li> <li><code>removeListener(ListChangeListener&lt;? super E&gt; listener)</code>: Permite eliminar un <code>ListChangeListener</code> registrado previamente.</li> <li><code>addAll(E... elements)</code>: A\u00f1ade todos los elementos especificados al final de la lista.</li> <li><code>removeAll(E... elements)</code>: Elimina todos los elementos especificados de la lista, si est\u00e1n presentes.</li> <li><code>clear()</code>: Elimina todos los elementos de la lista.</li> </ul>"},{"location":"bloque_vi/tema_33/page-7/","title":"7 FXML","text":""},{"location":"bloque_vi/tema_33/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>Hasta ahora hemos creado aplicaciones simples en JavaFX donde todo el c\u00f3digo est\u00e1 en un archivo. Son peque\u00f1os ejemplos, pero cuando las aplicaciones empiezan a crecer es \u00fatil tener el c\u00f3digo estructurado en diferentes archivos para que sea m\u00e1s f\u00e1cil de entender y manejar.</p> <p>Dado que JavaFX fue dise\u00f1ado con el patr\u00f3n MVC en mente, es muy f\u00e1cil crear uno aplicaci\u00f3n que sigue este patr\u00f3n (Modelo Vista Controlador), asegurando que el c\u00f3digo proporciona la interfaz (FXML) est\u00e1 separada del c\u00f3digo que manipula los datos de la aplicaci\u00f3n. El controlador ser\u00e1 un intermediario entre la interfaz y los datos, es decir, es la clase encargada de gestionar los eventos que suceden en la aplicaci\u00f3n.</p> <p>En JavaFX, la estructura jer\u00e1rquica de los componentes de la interfaz se puede definir utilizando el lenguaje XML. El formato XML espec\u00edfico de JavaFX se llama FXML.</p> <p>En el archivo FXML de una aplicaci\u00f3n JavaFX, todos los componentes gr\u00e1ficos y como sus propiedades y estar\u00e1 vinculado a una clase Controlador, que ser\u00e1 responsable de Manejar la l\u00f3gica de control del programa.</p> <p>El formato FXML es un formato basado en XML para realizar dise\u00f1os de interfaces gr\u00e1ficas de forma similar a como se crean las interfaces gr\u00e1ficas en HTML. Adem\u00e1s, FXML permite separar el dise\u00f1o de la interfaz del resto del c\u00f3digo, lo que es una gran ventaja a la hora de programar, ya que sigue el patr\u00f3n de dise\u00f1o Modelo-Vista-Controlador.</p> <p>FXML no tiene un esquema, pero tiene una estructura predefinida. La forma de construir el FXML depende de la API de los objetos construidos, por lo que se puede consultar la documentaci\u00f3n en dicha API para entender que elementos y atributos se pueden a\u00f1adir. En general, la mayor\u00eda de las clases JavaFX pueden ser usadas como elementos y la mayor\u00eda de sus propiedades pueden ser usadas como atributos (incluyendo las heredadas).</p> <p>Veamos la siguiente vista, haciendo uso de programaci\u00f3n pura y haciendo uso de XML.</p> <p> Figura 14 - Ejemplo FXML</p> C\u00f3digoFXML <pre><code>BorderPane border = new BorderPane();\nLabel topPaneText = new Label(\"Page title\");\nLabel centerPaneText = new Label(\"Some data here\");\n\nborder.setTop(topPaneText);\nborder.setCenter(centerPaneText);\n</code></pre> <pre><code>&lt;BorderPane&gt;\n    &lt;top&gt;\n        &lt;Label text=\"Page title\" /&gt;\n    &lt;/top&gt;\n    &lt;center&gt;\n        &lt;Label text=\"Some data here\" /&gt;\n    &lt;/center&gt;\n&lt;/BorderPane&gt;\n</code></pre>"},{"location":"bloque_vi/tema_33/page-7/#objectos-fxml","title":"Objectos FXML","text":"<p>Para crear objetos en FXML debe de usarse el elemento FXML apropiado. El nombre del elemento FXML usado correspondiente al nombre de la clase Java. Hay que tener en cuenta que para poder usar el elemento, primero hay que importarlo al igual que en el c\u00f3digo Java. Para importar un paquete es necesario usar la siguiente sintaxis <code>&lt;?import package?&gt;</code> siendo package el nombre del paquete a importar. Veamos un ejemplo, donde se use <code>VBox</code> y <code>Label</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;?import javafx.scene.layout.VBox?&gt;\n&lt;?import javafx.scene.control.Label?&gt;\n\n&lt;VBox spacing=\"20\"&gt;\n    &lt;children&gt;\n        &lt;Label text=\"Line 1\"/&gt;\n        &lt;Label text=\"Line 2\"/&gt;\n    &lt;/children&gt;\n&lt;/VBox&gt;\n</code></pre> <p>Las propiedades se pueden modificar por c\u00f3digo o por atributos XML. En el ejemplo anterior se a\u00f1ade espacio haciendo uso del atributo <code>spacing = 20</code>, pero tambi\u00e9n se puede usar en c\u00f3digo <code>setSpacing(20)</code>. La etiqueta <code>children</code> representa al m\u00e9todo <code>getChildren()</code> de la clase <code>VBox</code>. Los elementos a\u00f1adidos en su interior ser\u00e1n convertidos en componentes JavaFX y a\u00f1adidos a la colecci\u00f3n de descendientes del objeto <code>VBox</code> obtenidos en el <code>getChildren()</code>. Solo se pueden establecer los atributos de aquellos campos de los elementos que tienen getters y setters, de lo contrario ser\u00e1 omitido.</p> <p>En JavaFX es posible a\u00f1adir asignar ids a los elementos. Estos ids pueden ser usados para referenciar elementos en otra parte del fichero FXML, desde CSS, o desde la clase controladora.</p> <p>Para asignar los ids hay que utilizar el atributo id del espacio de nombre de FXML:</p> <pre><code>&lt;VBox xmlns:fx=\"http://javafx.com/fmxl/1\"&gt;\n    &lt;Label fx:id=\"label1\" text=\"Line 1\" /&gt;\n&lt;/VBox&gt;\n</code></pre> <p>FXML tiene un espacio de nombre que puede establecer en el elemento ra\u00edz. Este espacio de nombre es necesario para algunos atributos como el atributo id.</p> <p>Cuando se desea manipular un campo del elemento a trav\u00e9s de los m\u00e9todos est\u00e1ticos, en FXML, tambi\u00e9n se usa de forma est\u00e1tica. Por ejemplo, la clase <code>GridPane</code> tiene m\u00e9todos est\u00e1ticos para posicionar sus hijos en la cuadricula, <code>public static void setColumnIndex(Node node, int index)</code> y <code>public static void setRowIndex(Node node, int index)</code>, al igual que sus getters <code>public static int getColumnIndex(Node node)</code> y <code>public static int getRowIndex(Node node)</code>, en el FXML su uso ser\u00eda <code>GridPane.rowIndex=\"0\"</code>. Veamos un ejemplo:</p> <pre><code>&lt;GridPane&gt;\n    &lt;children&gt;\n        &lt;Label text=\"Username:\" GridPane.columnIndex=\"0\" GridPane.rowIndex=\"0\"/&gt;\n        &lt;!-- elementos adicionales --&gt;\n    &lt;/children&gt;\n&lt;/GridPane&gt;\n</code></pre> <p>Algunas propiedades de los elementos son m\u00e1s complejas (como objetos, en lugar de primitivos) y se escriben como etiquetas hijas de las etiquetas que representa el elemento, en lugar de atributos. Para que una etiqueta sea representada como una etiqueta hija del elemento, es necesario que en la clase que representa el elemento este la anotaci\u00f3n <code>DefaultProperty(property)</code>. Por ejemplo, en la clase <code>VBox</code> o <code>GridPane</code> debe haber una anotaci\u00f3n como <code>DefaultProperty(\"children\")</code>. Si una propiedad no es indicada dentro de dicha anotaci\u00f3n debe ser usada como atributo.</p>"},{"location":"bloque_vi/tema_33/page-7/#clase-contenedora","title":"Clase contenedora","text":"<p>Los documentos FXML tienen asociada una clase contenedora. Una clase contenedora permite acceder a los componentes declarados en un fichero FXML y hacer que el objeto controlador act\u00fae de intermediario.</p> <p>Para establecer un controlador en un fichero FXML, se debe especificar el fichero con el atributo <code>fx:controller=\"package\"</code> en la ra\u00edz del elemento. Cuando se carga el fichero FXML crea una instancia de la clase controladora. Para que esto sea funcional, el constructor de la clase contenedora no debe recibir ning\u00fan par\u00e1metro:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;?import javafx.scene.layout.VBox?&gt;\n&lt;?import javafx.scene.control.Button?&gt;\n\n&lt;VBox xmlns:fx=\"http://javafx.com/fxml\" fx:controller=\"com.example.javafx.MyFxmlController\"&gt;\n    &lt;Button text=\"Click me!\" /&gt;\n&lt;/VBox&gt;\n</code></pre> <p>Se puede asociar cada elemento del fichero FXML con los campos de clase contenedora. Para que ello sea posible, hay que a\u00f1adir el atributo <code>fx:id</code> al elemento FXML con el mismo nombre que el campo de la clase controladora. Adem\u00e1s, en la clase controladora, se debe a\u00f1adir la anotaci\u00f3n <code>@FXML</code>:</p> <pre><code>public class MyFxmlController{\n\n    @FXML\n    public Label label1;\n}\n</code></pre> <p>Tambi\u00e9n es posible referencias m\u00e9todos de la clase contenedora:</p> ControllerFXML <pre><code>public class MyFxmlController{\n\n    // ...\n\n    @FXML\n    public void buttonClicked(Event e){\n        System.out.println(\"Button Clicked\")\n    }\n}\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;?import javafx.scene.layout.VBox?&gt;\n&lt;?import javafx.scene.control.Button?&gt;\n\n&lt;VBox xmlns:fx=\"http://javafx.com/fxml\" fx:controller=\"com.example.javafx.MyFxmlController\"&gt;\n    &lt;Button text=\"Click me!\" onAction=\"#buttonClicked\"/&gt;\n&lt;/VBox&gt;\n</code></pre> <p>En este caso, ser\u00eda similar a hacer:</p> <pre><code>public class HelloApplication extends Application {\n\n    public void buttonClicked(Event e){\n        System.out.println(\"Button Clicked\")\n    }\n\n    @Override\n    public void start(Stage stage){\n        VBox vbox = new VBox();\n\n        Button button = new Button(\"Click me!\");\n        button.setOnAction(this::buttonClicked);\n\n        vbox.getChildren().addAll(button);\n    }\n}\n</code></pre> <p>Si es necesario a\u00f1adir algo en la interfaz, antes que est\u00e1 sea cargada, se puede a\u00f1adir el m\u00e9todo <code>initialize()</code> al controlador con las instrucciones a ejecutar cada vez que se encargue la interfaz gr\u00e1fica durante la ejecuci\u00f3n de la aplicaci\u00f3n.</p>"},{"location":"bloque_vi/tema_33/page-7/#scenebuilder","title":"SceneBuilder","text":"<p>La aplicaci\u00f3n SceneBuilder permite dise\u00f1ar de forma visual la interfaz gr\u00e1fica de una aplicaci\u00f3n JavaFX. Para usar Scene Builder hay que descargarlo desde su web</p> <p>SceneBuilder permite dise\u00f1ar de forma visual las interfaces, almacenando la configuraci\u00f3n de la misma en ficheros con extensi\u00f3n <code>fxml</code>.</p>"},{"location":"bloque_vi/tema_33/page-7/#cargar-fxml","title":"Cargar FXML","text":"<p>Para poder obtener el componente de un fichero FXML es necesario <code>FXMLLoader</code>. Veamos un ejemplo:</p> <pre><code>Class&lt;HelloApplication&gt; helloApplicationClass = HelloApplication.class;\nURL url = helloApplicationClass.getResource(\"hello-view.xml\");\nFXMLLoader fxmlLoader = new FXMLLoader(url);\nParent component = fxmlLoader.load();\n\n\nScene scene = new Scene(component, 320, 240);\n\nstage.setTitle(\"Hello!\");\nstage.setScene(scene);\nstage.show();\n</code></pre> <p>Como se puede observar en el ejemplo anterior, para poder cargar el componente, hay que seguir varios pasos:</p> <ul> <li>Obtener el objeto de tipo <code>Class&lt;T&gt;</code> de la clase actual, siendo el tipo <code>T</code> el tipo de la clase actual. En el ejemplo, se obtiene <code>Class&lt;HelloApplication&gt;</code> ya que la clase donde se est\u00e1 ejecutando el c\u00f3digo es <code>HelloApplication</code></li> <li>Obtener la url como un objeto <code>URL</code> a trav\u00e9s del m\u00e9todo <code>getResource(String res)</code> del objeto de tipo <code>Class&lt;HelloApplicationClass&gt;</code>.</li> <li>Dicha url se pasa como par\u00e1metro del constructor de la clase <code>FXMLLoader</code>.</li> <li>Con el m\u00e9todo <code>load()</code> de la clase <code>FXMLLoader</code> se obtiene el componente padre de nuestra aplicaci\u00f3n.</li> <li>Con dicho componente se crea la escena y el stage.</li> </ul> <p>Todo esto se puede simplificar mucho m\u00e1s:</p> <pre><code>FXMLLoader fxmlLoader = new FXMLLoader(HelloApplication.class.getResource(\"hello-view.fxml\"));\nScene scene = new Scene(fxmlLoader.load(), 320, 240);\nstage.setTitle(\"Hello!\");\nstage.setScene(scene);\nstage.show();\n</code></pre>"},{"location":"bloque_vi/tema_33/page-8/","title":"8 Estilos","text":""},{"location":"bloque_vi/tema_33/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Al igual que en Java Swing y en Java AWT se puede aplicar estilos a los componentes a trav\u00e9s de las propiedades de estilo. Sin embargo, est\u00e1 no es la forma recomendada de hacerle en JavaFX, ya que se dispone de una forma m\u00e1s familiar de hacerlo y de una forma m\u00e1s sencilla.</p> <p>JavaFX es compatible con CSS por lo que le podemos aplicar estilos CSS de la siguientes forma:</p> <ul> <li>A trav\u00e9s de un fichero con extensi\u00f3n <code>css</code>.</li> <li>A trav\u00e9s de una etiqueta <code>style</code> dentro del fichero FXML.</li> <li>A trav\u00e9s del m\u00e9todo <code>setStyle</code> de los componentes.</li> </ul>"},{"location":"bloque_vi/tema_33/page-8/#propiedades-css","title":"Propiedades CSS","text":"<p>Los estilos CSS se aplican a los nodos en el scene JavaFX de una manera similar a la forma en que se aplican los estilos CSS a los elementos en HTML DOM. Los estilos se aplican primero al padre y luego a sus hijos. El c\u00f3digo est\u00e1 escrito de manera que solo se visiten aquellas ramas del gr\u00e1fico de escena que podr\u00edan necesitar que se vuelva a aplicar CSS. A un nodo se le aplica estilo despu\u00e9s de agregarlo al scene. Los estilos se vuelven a aplicar cuando hay un cambio en el estado de pseudoclase, clase de estilo, identificaci\u00f3n, estilo en l\u00ednea o padre del nodo.</p> <p>Los estilos CSS se aplican de forma as\u00edncrona, es decir, los estilos CSS se cargan y los valores se convierten y se asignan alg\u00fan tiempo despu\u00e9s de que se haya creado y agregado un elemento al scene, pero antes de que el scene se dise\u00f1e y pinte por primera vez. Adem\u00e1s, si los estilos que se aplican a un objeto han cambiado (por ejemplo, porque su pseudoclase ha cambiado), los valores de los estilos reci\u00e9n aplicados no se aplicar\u00e1n inmediatamente. En cambio, se aplicar\u00e1n en alg\u00fan momento despu\u00e9s de que el estado del objeto haya cambiado, pero antes de que se pinte el scene a continuaci\u00f3n. Es posible que un estilo se aplique a una variable en un objeto JavaFX al que un programa JavaFX le haya asignado un valor. Dado que los estilos CSS se aplican de forma as\u00edncrona, es posible que un programa asigne valores y los utilice durante alg\u00fan tiempo antes de que CSS los sobrescriba en un momento arbitrario posterior.</p> <p>Cada nodo en el scene tiene una variable <code>styleClass</code>, una lista de cadenas. Esto es an\u00e1logo al atributo <code>class=\"...\"</code> que puede aparecer en elementos HTML. Proporcionar una cadena para la variable <code>styleClass</code> de un nodo hace que las propiedades de estilo de esa clase de estilo se apliquen a este nodo. Los estilos para las clases de estilo se pueden especificar utilizando la sintaxis del selector <code>\".styleClass\"</code> en una hoja de estilos. Tenga en cuenta que un nodo puede tener m\u00e1s de una clase de estilo.</p> <p>Cada nodo en el gr\u00e1fico de escena tiene una variable de identificaci\u00f3n , una cadena. Esto es an\u00e1logo al atributo <code>id=\"...\"</code> que puede aparecer en elementos HTML. Proporcionar una cadena para la variable de identificaci\u00f3n de un nodo hace que las propiedades de estilo de este nodo se busquen usando esa identificaci\u00f3n. Los estilos para identificadores espec\u00edficos se pueden especificar utilizando la sintaxis del selector <code>\"#nodeId\"</code> en una hoja de estilos.</p> <p>Cada nodo respeta un conjunto de propiedades que dependen de la clase JavaFX del nodo (a diferencia de su clase de estilo). El valor de propiedad que realmente se aplica depende de la precedencia del origen de la regla, como se describe anteriormente, as\u00ed como de la especificidad del selector de la regla como se describe en CSS 2. En \u00faltima instancia, una cadena de valor de propiedad se convierte en un valor JavaFX del tipo apropiado y luego se asigna a una variable de instancia del objeto JavaFX.</p> <p>Los estilos CSS pueden provenir de hojas de estilo o estilos en l\u00ednea. Las hojas de estilo se cargan desde las URL especificadas en la variable de hojas de estilo del objeto Scene. Si el scene contiene un control, se carga una hoja de estilo de agente de usuario predeterminada. Los estilos en l\u00ednea se especifican a trav\u00e9s de la API <code>setStyle</code> del Nodo. Los estilos en l\u00ednea son an\u00e1logos al atributo <code>style=\"...\"</code> de un elemento HTML. Los estilos cargados desde las hojas de estilos de una escena tienen prioridad sobre las reglas de la hoja de estilos del agente de usuario. Los estilos en l\u00ednea tienen prioridad sobre los estilos que se originan en otros lugares. El orden de precedencia de las reglas de estilo se puede modificar usando <code>\"!important\"</code> en una declaraci\u00f3n de estilo.</p> <p>A partir de JavaFX 2.1, la clase <code>Parent</code> tiene una propiedad de hojas de estilo, que permite configurar hojas de estilo en un contenedor. Esto permite que una rama del scene tenga un conjunto distinto de estilos. Cualquier instancia de Parent puede tener hojas de estilo. Un ni\u00f1o tomar\u00e1 sus estilos de sus propios estilos en l\u00ednea, las hojas de estilo de todos sus antepasados \u200b\u200by cualquier hoja de estilo de la escena.</p> <p>La URL de una hoja de estilo puede ser una URL absoluta o una URL relativa. Si se proporciona una URL relativa, se resuelve con la URL base del <code>ClassLoader</code> de la clase de aplicaci\u00f3n concreta. Si, por ejemplo, hay una clase principal <code>com.example.cool.ui.Main</code> que extiende la Aplicaci\u00f3n, la URL relativa <code>\"com/example/cool/resources/styles.css\"</code> se resolver\u00eda correctamente. La URL relativa <code>\"../resources/styles.css\"</code> no lo ser\u00eda, ya que la ruta <code>\"..\"</code> relativa a la ra\u00edz no es una ruta v\u00e1lida. A menudo es m\u00e1s f\u00e1cil utilizar el <code>ClassLoader</code> de alguna clase para encontrar el recurso. Por ejemplo, si el archivo <code>\"styles.css\"</code> reside en el mismo paquete que Main, el siguiente c\u00f3digo le dar\u00e1 la URL correcta: <code>com.example.cool.ui.Main.class.getResource(\"styles.css\").toExternalForm()</code></p> <p>Tenga en cuenta que, a partir de JavaFX 2.1, una URL que consta \u00fanicamente de una ruta absoluta (sin esquema ni autoridad) se resuelve en relaci\u00f3n con la URL base del <code>ClassLoader</code> de la clase que extiende la Aplicaci\u00f3n. En otras palabras, <code>\"/com/example/cool/resources/styles.css\"</code> se trata como <code>\"com/example/cool/resources/styles.css\"</code>. Esto es consistente con FXML.</p> <p>La implementaci\u00f3n permite a los dise\u00f1adores dise\u00f1ar una aplicaci\u00f3n mediante el uso de hojas de estilo para anular los valores de propiedad establecidos en el c\u00f3digo. Esto tiene implicaciones para la cascada; En particular, \u00bfcu\u00e1ndo un estilo de una hoja de estilos anula un valor establecido en el c\u00f3digo? La implementaci\u00f3n de JavaFX CSS aplica el siguiente orden de precedencia:</p> <ul> <li>un estilo de una hoja de estilo del usuario tiene menor prioridad que un valor establecido a partir del c\u00f3digo</li> <li>un valor establecido a partir del c\u00f3digo tiene menor prioridad que una hoja de estilo de scene o principal.</li> <li>Los estilos en l\u00ednea tienen la m\u00e1xima prioridad.</li> <li>Las hojas de estilo de una instancia principal se consideran m\u00e1s espec\u00edficas que los estilos de las hojas de estilo de escena.</li> </ul> <p>Se han establecido convenciones de nomenclatura para derivar nombres de clases de estilo CSS a partir de nombres de clases JavaFX y para derivar nombres de propiedades CSS a partir de nombres de variables JavaFX. Tenga en cuenta que esto es s\u00f3lo una convenci\u00f3n de nomenclatura; no hay conversi\u00f3n autom\u00e1tica de nombres. La mayor\u00eda de los nombres JavaFX usan \"camel case\", es decir, nombres de casos mixtos formados a partir de palabras compuestas, donde la letra inicial de cada subpalabra est\u00e1 en may\u00fascula. La mayor\u00eda de los nombres CSS en el mundo HTML est\u00e1n todos en min\u00fasculas, con palabras compuestas separadas por guiones. Por lo tanto, la convenci\u00f3n es tomar los nombres de las clases JavaFX y formar su correspondiente nombre de clase de estilo CSS separando las palabras compuestas con guiones y convirtiendo las letras a min\u00fasculas. Por ejemplo, la clase JavaFX <code>ToggleButton</code> tendr\u00eda una clase de estilo de \"bot\u00f3n de alternancia\". La convenci\u00f3n para asignar nombres de variables JavaFX a nombres de propiedades CSS es similar, con la adici\u00f3n del prefijo \"-fx-\". Por ejemplo, la variable <code>blendMode</code> tendr\u00eda un nombre de propiedad CSS correspondiente de \"-fx-blend-mode\".</p> <p>Si bien el analizador CSS JavaFX analizar\u00e1 la sintaxis CSS v\u00e1lida, no es un analizador CSS totalmente compatible. No se debe esperar que el analizador maneje una sintaxis no especificada en este documento.</p> <ul> <li>Las declaraciones de palabras clave <code>@</code> se ignoran.</li> <li>Las pseudoclases <code>\":first-child\"</code> y <code>\":lang\"</code> no son compatibles.</li> <li>Los pseudoelementos <code>\":first-line\"</code>, <code>\":first-letter\"</code>, <code>\":after\"</code> y <code>\":before\"</code> no son compatibles.</li> <li>Las pseudoclases din\u00e1micas <code>\":active\"</code> y <code>\":focus\"</code> no son compatibles. Sin embargo, los nodos admiten las pseudoclases <code>\":pressed\"</code> y <code>\":focused\"</code>, que son similares.</li> <li>Las pseudoclases <code>\":link\"</code> y <code>\":visited\"</code> no son compatibles en general. Sin embargo, a los objetos Hiperv\u00ednculo se les puede aplicar estilo y admiten la pseudoclase <code>\":visited\"</code>.</li> <li>JavaFX CSS no admite series de nombres de familias de fuentes separadas por comas en la propiedad <code>-fx-font-family</code>.</li> <li>No se admite el par\u00e1metro de altura de l\u00ednea opcional al especificar fuentes.</li> <li>No existe ning\u00fan equivalente para la propiedad <code>font-variant</code>.</li> <li>JavaFX CSS utiliza el modelo de color <code>HSB</code> en lugar del modelo de color <code>HSL</code>.</li> <li>Es posible utilizar el nombre de clase JavaFX como selector de tipo; sin embargo, no se recomienda dicho uso. Por ejemplo, es posible especificar estilos para un <code>ToggleButton</code> usando la sintaxis \"ToggleButton {...}\". No se recomienda este uso porque el nombre utilizado para hacer coincidir el selector de tipo es el nombre de clase concreto real utilizado en el programa JavaFX. Este nombre de clase puede cambiar en el caso de subclases. Si la aplicaci\u00f3n subclasificara la clase <code>ToggleButton</code>, estos estilos ya no se aplicar\u00edan.</li> </ul> <p>En este momento, las interfaces de programaci\u00f3n necesarias para que una clase declare soporte para propiedades CSS, convierta y cargue estos valores de hojas de estilos CSS en variables de objeto y declare y notifique cambios en las pseudoclases de un objeto, se consideran interfaces internas y no son accesibles directamente a las aplicaciones.</p> <p>Si una propiedad de un nodo se inicializa llamando al m\u00e9todo <code>set</code> de la propiedad, la implementaci\u00f3n de CSS ver\u00e1 esto como un valor establecido por el usuario y el valor no ser\u00e1 sobrescrito por un estilo de una hoja de estilo de agente de usuario.</p> <p>CSS tambi\u00e9n permite que ciertas propiedades se hereden de forma predeterminada, o se hereden si el valor de la propiedad es heredar. Si un valor se hereda, se hereda del valor calculado del elemento principal en el \u00e1rbol del documento. En JavaFX, la herencia es similar, excepto que en lugar de elementos en el \u00e1rbol del documento, la herencia ocurre desde los nodos principales en el gr\u00e1fico de escena.</p> <p>Info</p> <p>A trav\u00e9s de la siguiente web puedes conocer una lista con el nombre de las propiedades. </p> <p>https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html#introscenegraph</p> <p>Haciendo uso del m\u00e9todo <code>setStyle</code> o de la etiqueta <code>style</code> de FXML se puede a\u00f1adir estilos:</p> C\u00f3digoFXML <pre><code>Button button = new Button(\"Button\");\n\nbutton.setStyle(\"-fx-background-color: red; -fx-text-fill: blue\");\n</code></pre> <pre><code>&lt;Button text=\"Button\"&gt;\n    &lt;style&gt;\n        -fx-background-color: red;\n        -fx-text-fill: blue;\n    &lt;/style&gt;\n&lt;/Button&gt;\n</code></pre>"},{"location":"bloque_vi/tema_33/page-8/#clases-css","title":"Clases CSS","text":"<p>Para a\u00f1adir una clase CSS a un elemento de JavaFx se puede utilizar el m\u00e9todo <code>add</code> de la lista <code>styleClass</code>:</p> <pre><code>button.getStyleClass().add('my-class');\n</code></pre> <p>O tambi\u00e9n desde FXML:</p> <pre><code>&lt;Button styleClass=\"my-class1, my-class2\" /&gt;\n</code></pre>"},{"location":"bloque_vi/tema_33/page-8/#hojas-de-estilos","title":"Hojas de estilos","text":"<p>Las hojas de estilos CSS puede ser a\u00f1adidas a la aplicaci\u00f3n CSS de varias formas:</p> <ul> <li> <p>En el objeto <code>Scene</code> a trav\u00e9s de su propiedad <code>stylesheets</code>:</p> <pre><code>scene.getStylesheets().add(\"style1/button-styles.css\");\n</code></pre> </li> <li> <p>En el objeto padre del componente a trav\u00e9s de la propiedad <code>styleSheets</code>:</p> C\u00f3digoFXML <pre><code>vBox.getStylesheets().add(\"style1/button-styles.css\");\n</code></pre> <pre><code>&lt;VBox stylesheets=\"@style1/button-styles.css\"&gt;\n    &lt;!--  --&gt;\n&lt;/VBox&gt;\n</code></pre> </li> </ul>"},{"location":"bloque_vi/tema_33/page-9/","title":"9 M\u00e1s JavaFX","text":""},{"location":"bloque_vi/tema_33/page-9/#formas","title":"Formas","text":"<p>En JavaFX, puedes crear y manipular formas gr\u00e1ficas utilizando las clases proporcionadas en el paquete j<code>avafx.scene.shape</code>. Estas formas incluyen rect\u00e1ngulos, c\u00edrculos, l\u00edneas, elipses, pol\u00edgonos y m\u00e1s.</p> <p>Puede ser manipuladas como un componente normal. Tienen m\u00e9todos como <code>setFill(Color color)</code> para modificar el estilo de las formas. Tambi\u00e9n se puede modificar a trav\u00e9s de CSS. Veamos un ejemplo, de un c\u00edrculo:</p> <pre><code>public class CircleExample extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        Circle circle = new Circle(150, 100, 50);\n        circle.setFill(Color.LIGHTGREEN);\n        circle.setStroke(Color.DARKGREEN);\n        circle.setStrokeWidth(2);\n\n        Pane pane = new Pane();\n        pane.getChildren().add(circle);\n\n        Scene scene = new Scene(pane, 300, 200);\n        primaryStage.setTitle(\"Circle Example\");\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n</code></pre>"},{"location":"bloque_vi/tema_33/page-9/#graficos","title":"Gr\u00e1ficos","text":"<p>En JavaFX, los gr\u00e1ficos (charts) son una manera efectiva de visualizar datos. JavaFX proporciona varias clases para crear diferentes tipos de gr\u00e1ficos, como gr\u00e1ficos de l\u00edneas, gr\u00e1ficos de barras, gr\u00e1ficos de sectores, etc. Todos estos gr\u00e1ficos est\u00e1n en el paquete <code>javafx.scene.chart</code>. A continuaci\u00f3n, se explica c\u00f3mo utilizar estos gr\u00e1ficos con ejemplos.</p> <ol> <li> <p><code>LineChart</code> (Gr\u00e1fico de l\u00edneas)</p> <pre><code>public class LineChartExample extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        NumberAxis xAxis = new NumberAxis();\n        NumberAxis yAxis = new NumberAxis();\n        xAxis.setLabel(\"X Axis\");\n        yAxis.setLabel(\"Y Axis\");\n\n        LineChart&lt;Number, Number&gt; lineChart = new LineChart&lt;&gt;(xAxis, yAxis);\n        lineChart.setTitle(\"Line Chart Example\");\n\n        XYChart.Series&lt;Number, Number&gt; series = new XYChart.Series&lt;&gt;();\n        series.setName(\"My Data\");\n        series.getData().add(new XYChart.Data&lt;&gt;(1, 23));\n        series.getData().add(new XYChart.Data&lt;&gt;(2, 14));\n        series.getData().add(new XYChart.Data&lt;&gt;(3, 15));\n        series.getData().add(new XYChart.Data&lt;&gt;(4, 24));\n        series.getData().add(new XYChart.Data&lt;&gt;(5, 34));\n        series.getData().add(new XYChart.Data&lt;&gt;(6, 36));\n        series.getData().add(new XYChart.Data&lt;&gt;(7, 22));\n        series.getData().add(new XYChart.Data&lt;&gt;(8, 45));\n        series.getData().add(new XYChart.Data&lt;&gt;(9, 43));\n        series.getData().add(new XYChart.Data&lt;&gt;(10, 17));\n        series.getData().add(new XYChart.Data&lt;&gt;(11, 29));\n        series.getData().add(new XYChart.Data&lt;&gt;(12, 25));\n\n        lineChart.getData().add(series);\n\n        Scene scene = new Scene(lineChart, 800, 600);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"Line Chart Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n}\n</code></pre> </li> <li> <p><code>BarChart</code> (Gr\u00e1fico de barras)</p> <pre><code>public class BarChartExample extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        CategoryAxis xAxis = new CategoryAxis();\n        NumberAxis yAxis = new NumberAxis();\n        xAxis.setLabel(\"Category\");\n        yAxis.setLabel(\"Value\");\n\n        BarChart&lt;String, Number&gt; barChart = new BarChart&lt;&gt;(xAxis, yAxis);\n        barChart.setTitle(\"Bar Chart Example\");\n\n        XYChart.Series&lt;String, Number&gt; series = new XYChart.Series&lt;&gt;();\n        series.setName(\"My Data\");\n        series.getData().add(new XYChart.Data&lt;&gt;(\"A\", 20));\n        series.getData().add(new XYChart.Data&lt;&gt;(\"B\", 15));\n        series.getData().add(new XYChart.Data&lt;&gt;(\"C\", 25));\n        series.getData().add(new XYChart.Data&lt;&gt;(\"D\", 10));\n\n        barChart.getData().add(series);\n\n        Scene scene = new Scene(barChart, 800, 600);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"Bar Chart Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n}\n</code></pre> </li> <li> <p><code>PieChart</code> (Gr\u00e1fico de sectores)</p> <pre><code>public class PieChartExample extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        PieChart pieChart = new PieChart();\n        pieChart.setTitle(\"Pie Chart Example\");\n\n        PieChart.Data slice1 = new PieChart.Data(\"Category A\", 30);\n        PieChart.Data slice2 = new PieChart.Data(\"Category B\", 25);\n        PieChart.Data slice3 = new PieChart.Data(\"Category C\", 45);\n\n        pieChart.getData().addAll(slice1, slice2, slice3);\n\n        Scene scene = new Scene(pieChart, 800, 600);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"Pie Chart Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n}\n</code></pre> </li> <li> <p><code>ScatterChart</code> (Gr\u00e1fico de dispersi\u00f3n)</p> <pre><code>public class ScatterChartExample extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        NumberAxis xAxis = new NumberAxis();\n        NumberAxis yAxis = new NumberAxis();\n        xAxis.setLabel(\"X Axis\");\n        yAxis.setLabel(\"Y Axis\");\n\n        ScatterChart&lt;Number, Number&gt; scatterChart = new ScatterChart&lt;&gt;(xAxis, yAxis);\n        scatterChart.setTitle(\"Scatter Chart Example\");\n\n        XYChart.Series&lt;Number, Number&gt; series = new XYChart.Series&lt;&gt;();\n        series.setName(\"My Data\");\n        series.getData().add(new XYChart.Data&lt;&gt;(1, 23));\n        series.getData().add(new XYChart.Data&lt;&gt;(2, 14));\n        series.getData().add(new XYChart.Data&lt;&gt;(3, 15));\n        series.getData().add(new XYChart.Data&lt;&gt;(4, 24));\n        series.getData().add(new XYChart.Data&lt;&gt;(5, 34));\n        series.getData().add(new XYChart.Data&lt;&gt;(6, 36));\n        series.getData().add(new XYChart.Data&lt;&gt;(7, 22));\n        series.getData().add(new XYChart.Data&lt;&gt;(8, 45));\n        series.getData().add(new XYChart.Data&lt;&gt;(9, 43));\n        series.getData().add(new XYChart.Data&lt;&gt;(10, 17));\n        series.getData().add(new XYChart.Data&lt;&gt;(11, 29));\n        series.getData().add(new XYChart.Data&lt;&gt;(12, 25));\n\n        scatterChart.getData().add(series);\n\n        Scene scene = new Scene(scatterChart, 800, 600);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"Scatter Chart Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n}\n</code></pre> </li> <li> <p><code>AreaChart</code> (Gr\u00e1fico de \u00e1rea)</p> <pre><code>public class AreaChartExample extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        NumberAxis xAxis = new NumberAxis();\n        NumberAxis yAxis = new NumberAxis();\n        xAxis.setLabel(\"X Axis\");\n        yAxis.setLabel(\"Y Axis\");\n\n        AreaChart&lt;Number, Number&gt; areaChart = new AreaChart&lt;&gt;(xAxis, yAxis);\n        areaChart.setTitle(\"Area Chart Example\");\n\n        XYChart.Series&lt;Number, Number&gt; series = new XYChart.Series&lt;&gt;();\n        series.setName(\"My Data\");\n        series.getData().add(new XYChart.Data&lt;&gt;(1, 23));\n        series.getData().add(new XYChart.Data&lt;&gt;(2, 14));\n        series.getData().add(new XYChart.Data&lt;&gt;(3, 15));\n        series.getData().add(new XYChart.Data&lt;&gt;(4, 24));\n        series.getData().add(new XYChart.Data&lt;&gt;(5, 34));\n        series.getData().add(new XYChart.Data&lt;&gt;(6, 36));\n        series.getData().add(new XYChart.Data&lt;&gt;(7, 22));\n        series.getData().add(new XYChart.Data&lt;&gt;(8, 45));\n        series.getData().add(new XYChart.Data&lt;&gt;(9, 43));\n        series.getData().add(new XYChart.Data&lt;&gt;(10, 17));\n        series.getData().add(new XYChart.Data&lt;&gt;(11, 29));\n        series.getData().add(new XYChart.Data&lt;&gt;(12, 25));\n\n        areaChart.getData().add(series);\n\n        Scene scene = new Scene(areaChart, 800, 600);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"Area Chart Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n}\n</code></pre> </li> <li> <p><code>BubbleChart</code> (Gr\u00e1fico de burbujas)</p> <pre><code>public class BubbleChartExample extends Application {\n    @Override\n    public void start(Stage primaryStage) {\n        NumberAxis xAxis = new NumberAxis();\n        NumberAxis yAxis = new NumberAxis();\n        xAxis.setLabel(\"X Axis\");\n        yAxis.setLabel(\"Y Axis\");\n\n        BubbleChart&lt;Number, Number&gt; bubbleChart = new BubbleChart&lt;&gt;(xAxis, yAxis);\n        bubbleChart.setTitle(\"Bubble Chart Example\");\n\n        XYChart.Series&lt;Number, Number&gt; series = new XYChart.Series&lt;&gt;();\n        series.setName(\"My Data\");\n        series.getData().add(new XYChart.Data&lt;&gt;(5, 5, 1));\n        series.getData().add(new XYChart.Data&lt;&gt;(10, 10, 4));\n        series.getData().add(new XYChart.Data&lt;&gt;(15, 15, 9));\n        series.getData().add(new XYChart.Data&lt;&gt;(20, 20, 16));\n        series.getData().add(new XYChart.Data&lt;&gt;(25, 25, 25));\n\n        bubbleChart.getData().add(series);\n\n        Scene scene = new Scene(bubbleChart, 800, 600);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(\"Bubble Chart Example\");\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n}\n</code></pre> </li> </ol>"}]}