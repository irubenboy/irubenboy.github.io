{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenidx al mundo de Java","text":""},{"location":"bloque_ii/tema_10/page-1/","title":"10.1 Introducci\u00f3n a los Gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-1/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Se trata de la implementaci\u00f3n en Java de una de las opciones de C++ m\u00e1s a\u00f1oradas por los programadores que proceden de ese lenguaje; las plantillas (templates). Son similares a las plantillas de C++. Sirven para evitar conversiones de clases.</p> <p>Uno de los motivos de la creaci\u00f3n de los gen\u00e9ricos fueron las colecciones. Sin los gen\u00e9ricos todas las colecciones ser\u00edan de tipo Object, lo que tendr\u00eda una serie de desventajas:</p> <ul> <li>Nada impide crear listas heterog\u00e9neas de objetos. Eso causa problemas evidentes de casting, adem\u00e1s de imposible incoherencias.</li> <li>Si se desea acceder a propiedades espec\u00edficas de otro tipo de clases, ser\u00e1 necesario realizar una cantidad grande de conversiones en el c\u00f3digo, lo que har\u00e1 que sea m\u00e1s pesado de comprender.</li> <li>Los m\u00e9todos de las clases e interfaces de las colecciones no se adaptan al tipo de datos que contienen dificultando su uso.</li> </ul> <p>Por ello aparecieron los tipos gen\u00e9ricos en la versi\u00f3n 1.5 de Java consiguiendo solucionar los problemas anteriores en las colecciones.</p>"},{"location":"bloque_ii/tema_10/page-1/#2-idea-general-de-los-genericos","title":"2. Idea general de los gen\u00e9ricos","text":"<p>Los gen\u00e9ricos permiten crear clases y m\u00e9todos en los que los tipos de datos (las clases) sobre los que act\u00faan son un par\u00e1metro m\u00e1s. Gracias a ello se pueden crear clases y m\u00e9todos que se adaptan a distintos tipos de datos de forma autom\u00e1tica.</p> <p>Anteriormente a la aparici\u00f3n de los gen\u00e9ricos el que las clases y m\u00e9todos se adaptaran autom\u00e1ticamente pasaba por especificar par\u00e1metros de tipo Object, ya que las referencias de tipo Object valen para cualquier otro tipo de objeto.</p> <p>El problema es que la coherencia no est\u00e1 asegurada con los tipos Object, la sintaxis del lenguaje puede provocar excepciones de tipo ClassCastException ante conversiones err\u00f3neas de Object a otro tipo de datos.</p> <p>La idea es:</p> <ol> <li>El programar declara un gen\u00e9rico en un m\u00e9todo de clase, por ejemplo T</li> <li>Cuando se utilice dicha clase o m\u00e9todo se indicar\u00e1 un tipo concreto, entonces se cambia el gen\u00e9rico para que se refiera a ese tipo concreto.</li> </ol>"},{"location":"bloque_ii/tema_10/page-2/","title":"10.2 Uso de gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-2/#1-genericos-en-metodos","title":"1. Gen\u00e9ricos en m\u00e9todos","text":"<p>Se pueden indicar gen\u00e9ricos en los m\u00e9todos. Para indicar que el m\u00e9todo se puede utilizar con cualquier tipo de objeto y que el m\u00e9todo se adaptar\u00e1 a dicho tipo. La sintaxis es: <code>modificadores &lt;Gen\u00e9rico&gt; tipoRetorno nombreM\u00e9todo(...)</code></p> <p>Ejemplo:</p> <pre><code>public class ArrayUtils{\npublic static &lt;T&gt; T getRandom(T a[]){\nint i = new Random().nexInt(a.length-1);\nreturn a[i];\n}\n}\n</code></pre> <p>En el ejemplo anterior, se desea obtener un elemento aleatorio de un array. En el ejemplo la letra T entre los signos &lt; y &gt; indica que se va a utilizar un tipo gen\u00e9rico, el hecho de que le siga otra T significa que el tipo que devuelve el m\u00e9todo tomarAleatorio ser\u00e1 el mismo que el del par\u00e1metro a, y se corresponder\u00e1 al tipo gen\u00e9rico T. Despu\u00e9s cuando se invoque a este m\u00e9todo, la letra gen\u00e9rica T ser\u00e1 traducida por el tipo con el que se invoque al m\u00e9todo. Por ejemplo desde este c\u00f3digo:</p> <pre><code>String a[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString element = ArraysUtils.getRandom(a);\nSystem.out.println(element);\n</code></pre> <p>En ese c\u00f3digo, como se invoca usando un array de Strings, por lo tanto la letra gen\u00e9rica T ser\u00e1 traducida por String. Es decir es como si el c\u00f3digo anterior se tradujera como:</p> <pre><code>public class UtilesArrays {\npublic static String tomarAleatorio(String a[]){\nint i=(int)(Math.random()*a.length);\nreturn a[i];\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#2-genericos-en-las-clases","title":"2. Gen\u00e9ricos en las clases","text":"<p>El m\u00e9todo habitual de utilizar gen\u00e9ricos, debido a su mayor potencia, es declarar el gen\u00e9rico en una clase. De esta forma indicados que el c\u00f3digo de la clase utiliza tipos gen\u00e9ricos que ser\u00e1n traducidos por el tipo de datos que se desee.</p> <p>Por ejemplo una clase pensada para extraer elementos aleatorios de un array del tipo que sea se podr\u00eda declarar as\u00ed:</p> <pre><code>public class RandomElement&lt;T&gt;{\nprivate T element;\npublic RandomElement(T array[]){\nelement = array[new Random(array.length)];\n}\npublic T getElement(){\nreturn element;\n}\n}\n</code></pre> <p>Los tipos se indican tras el nombre de la clase. De esta forma cuando se creen objetos de clase RandomElement habr\u00e1 que indicar la clase por la que se traducir\u00e1 el gen\u00e9rico T. Por ejemplo:</p> <pre><code>public static void main(String[] args){\nString a[] = {\"uno\", \"dos\", \"tres\", \"cuatro\"};\nRandomElement&lt;String&gt; e = new RandomElement&lt;String&gt;(a);\nSystem.out.println(a.getElement());\n}\n</code></pre> <p>Obs\u00e9rvese que tanto al declarar el objeto e hay que concretar el valor del gen\u00e9rico de ah\u00ed que la declaraci\u00f3n sea <code>RandomElement&lt;String&gt; e</code> de ese modo ya queda claro la traducci\u00f3n de <code>T</code>. A partir de ese momento ya todos los m\u00e9todos de clase y propiedades que utilizaran el gen\u00e9rico <code>T</code>, ahora utilizar\u00e1n el tipo <code>String</code>. En definitiva los gen\u00e9ricos de clase marcan las posiciones para la clase concreta que habr\u00e1 que especificar en la creaci\u00f3n del objeto. Lo bueno es que pueden convivir distintas concreciones de gen\u00e9ricos, podr\u00eda ser:</p> <pre><code>RandomElement&lt;String&gt; e1 = new RandomElement&lt;String&gt;(a1);\nRandomElement&lt;Integer&gt; e2 = new RandomElement&lt;Integer&gt;(a2);\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#3-interfaces-con-genericos","title":"3. Interfaces con gen\u00e9ricos","text":"<p>Al igual que las clases, las interfaces pueden utilizar gen\u00e9ricos en las mismas condiciones que en \u00e9stas:</p> <pre><code>public interface Comparable&lt;T&gt;{\nT lower();\nT upper();\n}\n</code></pre> <p>Una clase que implemente la interfaz puede hacerlo as\u00ed:</p> <pre><code>public class Clase1 implements Compar&lt;String&gt;{\n</code></pre> <p>De modo que traduce el gen\u00e9rico de la interfaz por un tipo concreto o bien:</p> <pre><code>public class Clase1 &lt;T&gt; implements Compar&lt;T&gt;{\n</code></pre> <p>De modo que no traduce el gen\u00e9rico y espera a que durante la creaci\u00f3n de objetos de esa clase se indique el tipo concreto para el gen\u00e9rico.</p>"},{"location":"bloque_ii/tema_10/page-2/#4-uso-de-varios-genericos","title":"4. Uso de varios gen\u00e9ricos","text":"<p>Tanto en m\u00e9todos, como en clases o interfaces, es posible utilizar dos tipos gen\u00e9ricos e incluso m\u00e1s. Para ello se separan por comas dentro del operador diamante. Ejemplo:</p> <pre><code>public class CompareObjects&lt;T, U&gt;{\nprotected T object1;\nprotected U object2;\npublic CompareObjects(T object1, U object2){\nthis.object1 = object1;\nthis.object2 = object2;\n}\npublic boolean sameFirstLetter(){\nString letter1 = object1.getClass().getName().substring(1,1);\nString letter2 = object2.getClass().getName().substring(1,1);\nreturn letter1.equalsIgnoreCase(letter2);\n}\n}\n</code></pre> <p>Esta clase (que en realidad no es muy \u00fatil), construye un objeto a partir de otros dos. El primero de tipo gen\u00e9rico <code>T</code>, y el segundo de tipo <code>U</code>. El m\u00e9todo <code>sameFirstLetter</code> devuelve verdadero si el nombre de clase de <code>T</code> empieza por la misma letra que <code>U</code>.</p> <p>Para utilizar esta clase:</p> <pre><code>public static void main(String[] args){\nString s1 = \"Hola\";\nStringBuffer s2 = new StringBuffer(\"Adi\u00f3s\");\nCompareObjects&lt;String, StringBuffer&gt; comp = new CompareObjects&lt;String, StringBuffer&gt;(s1,s2);\nSystem.out.println(comp.sameFirstLetter());\n}\n</code></pre> <p>Devolver\u00e1 verdadero porque tanto <code>String</code> como <code>StringBuffer</code> empiezan por <code>S</code>. En el ejemplo <code>T</code> se convertir\u00e1 en String y <code>U</code> en <code>StringBuffer</code>.</p>"},{"location":"bloque_ii/tema_10/page-3/","title":"10.3 Gen\u00e9ricos avanzados","text":""},{"location":"bloque_ii/tema_10/page-3/#limitacion-de-los-tipos-posibles-en-un-generico","title":"Limitaci\u00f3n de los tipos posibles en un gen\u00e9rico","text":"<p>A veces no interesa que las clases acepten a cualquier tipo de objeto, sino a objetos de un determinado tipo y sus descendientes. Eso es posible indicarlo mediante la palabra <code>extends</code> dentro de la declaraci\u00f3n del gen\u00e9rico. Ejemplo:</p> <pre><code>public class HandlerVehicles &lt;V extends Vehicles&gt;{\nprotected V vehicle;\npublic HandlerVehicles(V vehicle){\nthis.vehicle = vehicle;\n}\npublic void start(){\nvehicle.start();\n}\n}\n</code></pre> <p>En el ejemplo, a la clase se le puede indicar cualquier clase descendiente de <code>Vehicle</code>, pero ninguna otra. Por ejemplo:</p> <pre><code>HandlerVehicle&lt;Car&gt; v1 = new HandlerVehicle&lt;Car&gt;();\nHandlerVehicle&lt;Autocar&gt; v2 = new HandlerVehicle&lt;Autocar&gt;\n</code></pre> <p>Sin embargo, no se podr\u00eda declarar:</p> <pre><code>HandlerVehicle&lt;String&gt; v3 = HandlerVehicle&lt;String&gt;(e);\n</code></pre> <p>No es posible porque la clase String no es heredera de ning\u00fan veh\u00edculo. La raz\u00f3n de utilizar esta cl\u00e1usula tan restrictiva est\u00e1 en el hecho de poder realizar acciones que sabemos que s\u00f3lo son posibles en cierto tipo de objetos. La clase <code>HandlerVehicle</code> necesita arrancar el veh\u00edculo, por ello tenemos que asegurar que el gen\u00e9rico no puede ser ninguna clase incompatible.</p> <p>Por otro lado extends no tiene por qu\u00e9 referirse a clases, tambi\u00e9n puede referirse a interfaces. Ejemplo:</p> <pre><code>public class Clase1 &lt;V extends Comparable&gt;{\n</code></pre> <p>Significa que la Clase1 usa un gen\u00e9rico al que se le puede asignar cualquier clase que implemente la interfaz Comparable.</p>"},{"location":"bloque_ii/tema_10/page-3/#tipos-comodin","title":"Tipos comod\u00edn","text":"<p>Aunque parece que todo est\u00e1 resuelto de esta forma. Hay problemas cuando mezclamos objetos de la misma clase pero distinta traducci\u00f3n de gen\u00e9rico. Es el caso de este ejemplo:</p> <pre><code>public class RandomElement&lt;T&gt;{\nprivate T element;\nprivate int index;\npublic RandomElement(T array[]){\nindex = new Random().nextInt(array.length);\nelement = array[index];\n}\npublic T getElement(){\nreturn element;\n}\npublic int getIndex(){\nreturn index;\n}\npublic boolean sameIndex(RandomElement&lt;T&gt; random){\nreturn random.index = index;\n}\n}\n</code></pre> <p>En este caso la clase RandomElement se le ha a\u00f1adido una propiedad que almacena el \u00edndice aleatorio que obtiene el constructor. Eso permite que construyamos un m\u00e9todo llamado <code>sameIndex</code> que recibe un objeto de clase RandomElement y nos dice si el \u00edndice aleatorio calculado fue el mismo. Para usar este m\u00e9todo:</p> <pre><code>String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString[] s2 = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"};\nRandomElement&lt;String&gt; r1 = new RandomElement&lt;String&gt;(s1);\nRandomElement&lt;String&gt; r2 = new RandomElement&lt;String&gt;(s2);\nSystem.out.println(r1.sameIndex(r2));\n</code></pre> <p>El c\u00f3digo funciona, s\u00f3lo devolver\u00e1 verdadero si tanto el objeto <code>r1</code> como en <code>r2</code>, el \u00edndice tiene el mismo valor. Sin embargo, este otro c\u00f3digo fallara:</p> <p>```java hl_lines= 6 String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}; Integer[] s2 = {1,2,3,4,5,6}; RandomElement r1 = new RandomElement(s1); RandomElement r2 = new RandomElement(s2); <p>System.out.println(r1.sameIndex(r2)); <pre><code>El error ocurre en tiempo de compilaci\u00f3n. La raz\u00f3n, que en la l\u00ednea remarcada, el objeto `r1` es ya de tipo `RandomElement&lt;String&gt;` por lo que el m\u00e9todo `sameIndex` s\u00f3lo puede aceptar objetos de tipo `RandomElement&lt;String&gt;`, ya que el gen\u00e9rico T se tradujo como STring. El problema est\u00e1 en que dicho m\u00e9todo tiene que poder aceptar cualquier tipo de objeto de tipo `RandomElement`.\n\nPara ello se usa el signo `&lt;?&gt;` de ese modo indicamos la posibilidad de aceptar cualquier tipo de clase con gen\u00e9rico. Es decir el m\u00e9todo se reescribir\u00eda as\u00ed:\n\n```java\npublic boolean sameIndex(RandomElement&lt;?&gt; random){\n    return random.getIndex() == index;\n}\n</code></pre></p> <p>De esa forma se indica que random es un objeto de tipo <code>RandomElement</code> tenga el tipo que tenga el gen\u00e9rico.</p> <p>Incluso se puede delimitar el gen\u00e9ricos:</p> <pre><code>public boolean sameIndex(RandomElement&lt;? extends Number&gt; random){\nreturn random.getIndex() == index;\n}\n</code></pre> <p>Ahora el m\u00e9todo acepta cualquier tipo de <code>RandomElement</code> pero siempre y cuando el tipo gen\u00e9rico forme parte de la herencia <code>Number</code></p>"},{"location":"bloque_iii/tema_11/page-1/","title":"1 Introducci\u00f3n a las colecciones","text":""},{"location":"bloque_iii/tema_11/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Una colecci\u00f3n representa un grupo de objetos. Estos objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almac\u00e9n donde poder guardarlos.</p> <p>Las colecciones son estructuras de datos con la peculiaridad de que son estructuras din\u00e1micas. Eso quiere decir que pueden aumentar o disminuir su tama\u00f1o dependiendo de los elementos que almacenan, lo que suponen una mejora respecto a las estructuras de datos est\u00e1ticas cuyo tama\u00f1o se define en su creaci\u00f3n y no se puede alterar en tiempo de ejecuci\u00f3n, como por ejemplo, los arrays.</p> <p>El API de Java nos proporciona en el paquete <code>java.util</code> el framework de las colecciones, que nos permite utilizar diferentes estructuras de datos para almacenar y recuperar objetos de cualquier clase. Java tiene desde la versi\u00f3n 2 todo un juego de clases e interfaces para guardar colecciones de objetos donde todas las entidades conceptuales est\u00e1n representadas por interfaces y las clases se usan para proveer implementaciones de esas interfaces. Estas clases e interfaces est\u00e1n estructuradas en una jerarqu\u00eda.</p> <p>Pero \u00bfqu\u00e9 podemos almacenar dentro de una colecci\u00f3n? Podemos almacenar cualquier objeto que herede de la clase <code>Object</code>. Pero esto presenta ciertos inconvenientes:</p> <ul> <li>Podr\u00edamos tener una colecci\u00f3n con objetos completamente distintos, lo que puede dar lugar a problemas ya que en todo momento deber\u00edamos saber qu\u00e9 tipo de objeto y qu\u00e9 posici\u00f3n de la colecci\u00f3n se encuentra el elementos con el que queremos trabajar, de otro modo podr\u00edamos tener incongruencias en el c\u00f3digo e incluso hacer saltar una excepci\u00f3n.</li> <li>Otro inconveniente es que tendr\u00edamos que hacer continuos castings para poder trabajar con los elementos de la colecci\u00f3n, lo cual resulta tedioso y poco productivo.</li> </ul> <p>Veamos un ejemplo para obtener la suma de los valores almacenados en una lista:</p> <pre><code>int total = 0;\nArrayList numbers = new ArrayList(); // Creaci\u00f3n de la lista\nnumbers.add(1); // Se a\u00f1ade el elemento 1 a la lista utilizando el m\u00e9todo add\nnumbers.add(2);\nnumbers.add(3);\nfor(int i = 0; i &lt; numbers.size(); i++){\n// No vemos obligados a hacer cast, dado que numbers.get(i) retorna un Object:\ntotal += (int) numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>Como vemos en el ejemplo anterior, nos vemos obligados a hacer expl\u00edcitamente un cast cuando obtenemos un elemento de la lista, dado que la lista internamente trabaja con elementos de la clase <code>Object</code>. No hay ning\u00fan contrato que permita a la clase <code>ArrayList</code> saber qu\u00e9 tipo de datos queremos que trabaje.</p> <p>Adem\u00e1s, es posible a\u00f1adir elementos de distinto tipo a la lista, con el agravante de que m\u00e1s adelante cuando se intenta acceder al elemento y se hace cast sobre \u00e9l se producir\u00e1 un error en tiempo de ejecuci\u00f3n. As\u00ed, si modificamos el ejemplo anterior de la siguiente manera:</p> <pre><code>int total = 0;\nArrayList numbers = new ArrayList(); numbers.add(1);\nnumbers.add(2);\nnumbers.add(\"Antonio\");\nfor(int i = 0; i &lt; numbers.size(); i++){\n// Esta l\u00ednea lanza una excepci\u00f3n cuando\n// se trata de convertir a entero el elemento \"Antonio\",\ntotal += (int) numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>As\u00ed pues, para resolver este problema, a partir de la versi\u00f3n 5 de Java empezaron a utilizar los gen\u00e9ricos. Los gen\u00e9ricos nos permiten establecer un tipo con el que vamos a trabajar en esa colecci\u00f3n, de esa manera podemos evitar los problemas mencionados anteriormente.</p> <p>As\u00ed el ejemplo anterior podr\u00edamos modificarlo de la siguiente manera:</p> <pre><code>int total = 0;\nArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); numbers.add(1);\nnumbers.add(2);\n//Esta l\u00ednea da un error de compilaci\u00f3n, dado que el compilador\n// detecta que estamos intentado a\u00f1adir una cadena a la lista de enteros:\nnumbers.add(\"Antonio\");\nfor(int i = 0; i &lt; numbers.size(); i++){\n// Ya no es necesario hacer un cast expl\u00edcito, dado que el compilador\n// lo har\u00e1 internamente por nosotros, al haberle informado de que quer\u00edamos\n// trabajar con una lista de enteros\ntotal += numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>Como vemos en el ejemplo anterior, gracias a la informaci\u00f3n que le suministramos al compilador sobre el tipo de lista con el que queremos trabajar, en este caso <code>Integer</code>, el compilador es capaz de detectar en tiempo de compilaci\u00f3n que no deber\u00eda ser posible a\u00f1adir una cadena a la lista, y adem\u00e1s nos evita tener que hacer expl\u00edcitamente el cast a entero cuando obtenemos los elementos de la lista, porque ya lo puede hacer \u00e9l internamente por nosotros.</p> <p>Lo que se use en un gen\u00e9rico debe ser un objeto, por lo tanto, los gen\u00e9ricos no funcionan con datos primitivos. Para resolver esta situaci\u00f3n, la API de Java incorpora las clases envoltorio (wrapper class) que no son m\u00e1s que dotar a los datos primitivos con un envoltorio que permita tratarlos como objetos. Las clases envoltorios proporcionan m\u00e9todos de utilidad para la manipulaci\u00f3n de datos primitivos (conversiones de / hacia datos primitivos, conversiones a String, etc).</p>"},{"location":"bloque_iii/tema_11/page-2/","title":"2 ArrayList","text":""},{"location":"bloque_iii/tema_11/page-2/#interfaz-collection","title":"Interfaz Collection","text":"<p>Es la interfaz ra\u00edz de la jerarqu\u00eda de las colecciones. Java no proporciona ninguna implementaci\u00f3n directa de esta interfaz, sino que proporciona implementaciones de sub-interfaces m\u00e1s espec\u00edficas como Set y List. Esta interfaz se utiliza normalmente para pasar colecciones y manipularlas cuando se desea la m\u00e1xima generalidad.</p> <p>Veamos algunos de los m\u00e9todos que podemos observar en la API</p> <ul> <li><code>boolean add(E e)</code>: a\u00f1ade el elemento e a la colecci\u00f3n.</li> <li><code>boolean addAll(Collection &lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de la colecci\u00f3n c.</li> <li><code>void clear()</code>: elimina todos los elementos de la colecci\u00f3n.</li> <li><code>boolean contains(Object o)</code>: comprueba si el elemento o est\u00e1 en la colecci\u00f3n.</li> <li>boolean containsAll(Collection&lt;?&gt; c) : comprueba si todos los elementos de c est\u00e1n en la colecci\u00f3n.</li> <li><code>boolean isEmpty()</code>: comprueba si la colecci\u00f3n est\u00e1 vac\u00eda.</li> <li><code>boolean remove(Object o)</code>: elimina de la colecci\u00f3n el elemento o.</li> <li><code>boolean removeAll(Collection&lt;?&gt; c)</code>: elimina de la colecci\u00f3n todos los elementos de c.</li> <li><code>boolean retainAll(Collection&lt;?&gt; c)</code>: elimina de la colecci\u00f3n todos los elementos exceptos los que est\u00e1n en c, es decir, obtiene la intersecci\u00f3n.</li> <li><code>int size()</code>: devuelve el tama\u00f1o de la colecci\u00f3n.</li> </ul>"},{"location":"bloque_iii/tema_11/page-2/#interfaz-list","title":"Interfaz List","text":"<p>Esta interfaz es una sub-interfaz o interfaz hija de Collection, por lo tanto, tiene todos los m\u00e9todos de Collection y adem\u00e1s a\u00f1ade los suyos propios.</p> <p>Este tipo de colecci\u00f3n se refiere a listas en las que los elementos de la colecci\u00f3n tienen un orden, es decir, existe una secuencia de elementos. Cada elemento tiene un \u00edndice o posici\u00f3n. El primer elemento ocupa la posici\u00f3n 0. La interfaz List s\u00ed admite elementos duplicados.</p> <p>Veamos algunos de los m\u00e9todos que podemos observar en la API:</p> <ul> <li><code>void add(int index, E element)</code>: inserta el elemento E en la posici\u00f3n index.</li> <li><code>boolean add(E e)</code>: a\u00f1ade el elemento e al final de la lista.</li> <li><code>boolean addAll(int index, Collection &lt;? extends E&gt; c)</code>: inserta todos los elementos de c en la posici\u00f3n index.</li> <li><code>boolean addAll(Collection &lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de c al final de la lista.</li> <li><code>E get(int index)</code>: devuelve el elemento de la posici\u00f3n index.</li> <li><code>int indexOf(Object o)</code>: devuelve el \u00edndice de la primera ocurrencia del elemento o en la lista, o -1 si la lista no contiene el elemento.</li> <li><code>int lastIndexOf(Object o)</code>: devuelve el \u00edndice de la \u00faltima ocurrencia del elemento o en la lista, o -1 si la lista no contiene el elemento.</li> <li><code>E remove(int index)</code>: elimina el elemento que se encuentra en la posici\u00f3n index. E set(int index, E element): reemplaza el elemento que se encuentra en index por el elemento element.</li> <li><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code>: devuelve la sub-lista comprendida entre las posiciones fromIndex incluida y toIndex excluida.</li> </ul> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java para la interfaz List, como por ejemplo, ArrayList.</p>"},{"location":"bloque_iii/tema_11/page-2/#la-clase-arraylist","title":"La clase ArrayList","text":"<p>Se basa en un array redimensionable que aumenta su tama\u00f1o seg\u00fan crece la colecci\u00f3n de elementos. Lo bueno es que el tiempo de acceso a un elemento en particular es \u00ednfimo. Lo malo es que si queremos eliminar un elemento del principio o del medio, la clase debe mover todos los que le siguen a la posici\u00f3n anterior, para tapar el agujero que deja el elemento removido. Esto hace que sacar elementos del medio o del principio sea costoso.</p> <p>ArrayList mantiene el orden de inserci\u00f3n, es decir, si recorremos la colecci\u00f3n se nos mostrar\u00e1 en el mismo orden en que insertamos los objetos.</p> <p>Veamos un ejemplo de declaraci\u00f3n e inicializaci\u00f3n:</p> <pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n</code></pre> <p>A partir de java7, no es necesario indicar el gen\u00e9rico en la inicializaci\u00f3n:</p> <pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n</code></pre> <p>Para hacer el c\u00f3digo m\u00e1s gen\u00e9rico, se puede definir la variable de tipo interfaz, ya que dicho c\u00f3digo podr\u00eda funcionar con cualquier clase que implemente la interfaz, simplemente habr\u00eda que cambiar el new:</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n</code></pre> <p>Veamos un ejemplo de ArrayList donde utiliza m\u00e9todos tanto de Collection como de List:</p> C\u00f3digoSalida <pre><code>import java.util.ArrayList;\nimport java.util.List;\npublic class ShowArrayList{\npublic void show(){\nList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\nList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\nList&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();\nlist1.add(1);\nlist1.add(2);//Se a\u00f1aden los elementos al final de la lista\nlist1.add(6);\nlist1.add(2, 5);//Se a\u00f1ade el 5 en la posici\u00f3n 2\nfor (Integer i : list1) {//Recorremos la lista con un bucle for-each: 1 2 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist2.add(3);\nlist2.add(4);\nlist1.addAll(2, list2);//Se inserta list2 en la posici\u00f3n 2 de list1\nfor (Integer i : list1) {// 1 2 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist3.add(7);\nlist3.add(8);\nlist1.addAll(list3);//Se inserta list3 al final de list1\nfor (Integer i : list1) {// 1 2 3 4 5 6 7 8\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl elemento 3 de list1 es: %d\", list1.get(3));//4\nSystem.out.printf(\"\\nLa posici\u00f3n del 4 en list1 es: %d\", list1.indexOf(4));//3\nlist1.add(4);//Se a\u00f1ade un 4 al final de list1\nSystem.out.printf(\"\\nLa posici\u00f3n del 4 en list1 por el final es: %d\\n\", list1.lastIndexOf(4));//8\nlist1.remove(8);//Se elimina el elemento de la posici\u00f3n 8, que es el \u00faltimo 4 insertado\nfor (Integer i : list1) {// 1 2 3 4 5 6 7 8\nSystem.out.printf(\" %d \", i);\n}\nlist1.set(6, 8);//Se reemplaza el elemento que se encuentra en la posici\u00f3n 6 por un 8\nSystem.out.println();\nfor (Integer i : list1) {// 1 2 3 4 5 6 8 8\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nLa sub-lista comprendida entre las posiciones 2 y 5 es: \");\nfor (Integer i : list1.subList(2, 6)) {// 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl 4 %s se encuentra en list1\", list1.contains(4) ? \"s\u00ed\" : \"no\");//s\u00ed\nSystem.out.printf(\"\\nEl 9 %s se encuentra en list1\", list1.contains(9) ? \"s\u00ed\" : \"no\");//no\n//list1: 1 2 3 4 5 6 8 8\n//list2: 3 4\n//list3: 7 8\nSystem.out.printf(\"\\nTodos los elementos de list2 %s se encuentran en list1\", list1.containsAll(list2) ? \"s\u00ed\" : \"no\");//s\u00ed\nSystem.out.printf(\"\\nTodos los elementos de list3 %s se encuentran en list1\\n\",\nlist1.containsAll(list3) ? \"s\u00ed\" : \"no\");//no\nlist1.removeAll(list3);//Se eliminan de list1 todos los elementos de list3, es decir, el 8\nfor (Integer i : list1) {// 1 2 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist1.retainAll(list2);//Intersecci\u00f3n entre list1 y list2\nfor (Integer i : list1) {// 3 4\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl tama\u00f1o de list1 es: %d\", list1.size());//2\nSystem.out.printf(\"\\nlist1 %s est\u00e1 vac\u00eda\", list1.isEmpty() ? \"s\u00ed\" : \"no\");//no\nlist1.clear();//Elimina todos los elementos de list1\nSystem.out.printf(\"\\nlist1 %s est\u00e1 vac\u00eda\", list1.isEmpty() ? \"s\u00ed\" : \"no\");//s\u00ed\n}\npublic static void main(String[] args) {\nnew ShowArrayList().show();\n}\n}\n</code></pre> <pre><code>1 2 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6 7 8\nEl elemento 3 de list1 es: 4\nLa posici\u00f3n del 4 en list1 es: 3\nLa posici\u00f3n del 4 en list1 por el final es: 8\n1 2 3 4 5 6 7 8\n1 2 3 4 5 6 8 8\nLa sub-lista comprendida entre las posiciones 2 y 5 es: 3 4 5 6\nEl 4 s\u00ed se encuentra en list1\nEl 9 no se encuentra en list1\nTodos los elementos de list2 s\u00ed se encuentran en list1\nTodos los elementos de list3 no se encuentran en list1\n1 2 3 4 5 6\n3 4\nEl tama\u00f1o de list1 es: 2\nlist1 no est\u00e1 vac\u00eda\nlist1 s\u00ed est\u00e1 vac\u00eda\n</code></pre>"},{"location":"bloque_iii/tema_11/page-2/#iteradores","title":"Iteradores","text":"<p>En dise\u00f1o de software, el patr\u00f3n de dise\u00f1o Iterador (en ingl\u00e9s, Iterator) define una interfaz que declara los m\u00e9todos necesarios para acceder secuencialmente a un grupo de objetos de una colecci\u00f3n.</p> <p>Este patr\u00f3n debe ser utilizado cuando se requiera una forma est\u00e1ndar de recorrer una colecci\u00f3n, es decir, cuando no sea necesario que un cliente sepa el tipo de colecci\u00f3n que est\u00e1 recorriendo.</p> <p>La interfaz <code>Iterable&lt;T&gt;</code> contiene el m\u00e9todo iterator() que devuelve una instancia de alguno clase que implemente la interfaz <code>Iterator&lt;T&gt;</code>:</p> <ul> <li><code>Iterator&lt;T&gt; iterator()</code>: devuelve un iterador al comienzo de la colecci\u00f3n.</li> </ul> <p>La interfaz <code>Iterator&lt;E&gt;</code> permite el acceso secuencial a los elementos de una colecci\u00f3n y realizar recorridos sobre la colecci\u00f3n. Los m\u00e9todos de <code>Iterator&lt;E&gt;</code> son:</p> <ul> <li><code>boolean hasNext()</code>: comprueba si hay siguiente elemento.</li> <li><code>E next()</code>: devuelve el siguiente elemento y mueve el iterador.</li> <li><code>void remove()</code>: se invoca despu\u00e9s de next() para eliminar el \u00faltimo elemento le\u00eddo.</li> </ul> <p>La interfaz <code>Collection&lt;E&gt;</code> es una sub-interfaz o interfaz hija de <code>Iterable&lt;E&gt;</code>, as\u00ed que dispone del m\u00e9todo <code>iterator()</code>. Veamos un ejemplo de un <code>ArrayList&lt;E&gt;</code>utilizando iteradores:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class ShowIterator{\npublic void show(){\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile(it.hashNext()){\nSystem.out.println(it.next());\n}\n}\npublic static void main(String[] args){\nnew ShowIterator().show();\n}\n}\n</code></pre> <pre><code>Juan\nAntonio\nJaime\nVicente\n</code></pre> <p>Si no hay siguiente, <code>next()</code> lanza una excepci\u00f3n <code>NoSuchElementException</code>:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class NextException {\npublic void show() {\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nit = list.iterator();\nSystem.out.println(it.next());\nSystem.out.println(it.next());//(1)!\n}\npublic static void main(String[] args) {\nnew NextException().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n una excepci\u00f3n <code>NoSuchElementException</code></li> </ol> <p>Tal y como vemos en el ejemplo anterior, hay que comprobar si hay siguiente con un <code>hashNext()</code> para que el <code>next()</code> no lance la excepci\u00f3n.</p> <p>No se puede modificar la colecci\u00f3n dentro del bucle for-each porque se lanza en ejecuci\u00f3n la excepci\u00f3n <code>ConcurrentModificationException</code>, ya que estamos recorriendo y modificando la lista a la vez:</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\npublic class ModifyInsideForEach {\npublic void show() {\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nfor (String s : list) {//(1)!\nSystem.out.printf(\" %s \", s);\nif (s.equals(\"Antonio\")) {\nlist.remove(\"Antonio\");\n}\n}\n}\npublic static void main(String[] args) {\nnew ModifyInsideForEach().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n la excepci\u00f3n <code>ConcurrentModificationException</code></li> </ol> <p>Para solucionarlo, podemos utilizar el m\u00e9todo <code>remove()</code>de <code>Iterator&lt;E&gt;</code>. Si se modifica una colecci\u00f3n mientras se recorre, los iteradores quedan invalidados, a excepci\u00f3n del m\u00e9todo <code>remove()</code> de la interfaz <code>Iterator&lt;E&gt;</code>. El m\u00e9todo <code>remove()</code> permite eliminar elementos de la colecci\u00f3n siendo la \u00fanica forma adecuada para eliminar elementos durante la iteraci\u00f3n:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveIterator {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveIterator().show();\n}\n}\n</code></pre> <pre><code>Juan\nJaime\nVicente\n</code></pre> <p>Solo puede haber una invocaci\u00f3n a <code>remove()</code> por cada invocaci\u00f3n <code>next()</code>. Si no cumple, se lanza en ejecuci\u00f3n una excepci\u00f3n <code>IllegalStateException</code>. Por ejemplo, imaginemos que tenemos una lista de personas y queremos eliminar a Antonio y a la persona que venga detr\u00e1s. Si cuando encontramos a Antonio, hacemos dos <code>remove()</code> seguidos, entonces salta la excepci\u00f3n:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveNext1 {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\nit.remove();//(1)!\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveNext1().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n la excepci\u00f3n <code>IllegalStateException</code></li> </ol> <p>Tendr\u00edamos que hacer otro <code>next()</code> para el que venga detr\u00e1s de Antonio:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveNext2 {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\nit.next();\nit.remove();\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveNext2().show();\n}\n}\n</code></pre> <pre><code>Juan\nVicente\n</code></pre> <p>La interfaz <code>ListIterator&lt;E&gt;</code> es una subinterfaz o interfaz hija de <code>Iterator&lt;E&gt;</code>. Es un iterador para listas que permite al programador recorrer la lista hacia delante y hacia atr\u00e1s, modificar la lista durante la iteraci\u00f3n y obtener la posici\u00f3n actual del iterador en la lista.</p> <p>Hereda los m\u00e9todos de <code>Iterador&lt;E&gt;</code> y adem\u00e1s aporta otros m\u00e9todos nuevos:</p> <ul> <li><code>void add(E e)</code>: inserta el elemento en la lista antes del elemento que ser\u00eda devuelto por next(), si lo hubiera, y despu\u00e9s del elemento que ser\u00eda devuelto por previous(), si lo hubiera. Una llamada posterior a next() no se ver\u00eda afectada y una llamada posterior a previous() devolver\u00eda el nuevo elemento.</li> <li><code>boolean hasPrevious()</code>: comprueba si hay un elemento anterior.</li> <li><code>int nextIndex()</code>: devuelve el \u00edndice del elemento que ser\u00eda devuelto por una llamada a next(). El \u00edndice del primer elemento es 0.</li> <li><code>E previous()</code>: devuelve el elemento anterior de la lista y mueve la posici\u00f3n del cursor hacia atr\u00e1s.</li> <li><code>int previousIndex()</code>: devuelve el \u00edndice del elemento que ser\u00eda devuelto por una llamada a previous().</li> <li><code>void set(E e)</code>: sustituye el \u00faltimo elemento devuelto por next() o previous() por elemento e.</li> </ul> <p>En la interfaz <code>List&lt;E&gt;</code>, hay dos m\u00e9todos para crear este iterador:</p> <ul> <li><code>ListIterator&lt;E&gt; listIterator()</code>: se coloca antes del primer elemento para que al hacer el primer next() se devuelva el primer elemento.</li> <li><code>ListIterator&lt;E&gt; listIterator(int index)</code>: se coloca antes del elemento que se encuentra en la posici\u00f3n index para que al hacer un next() se devuelva dicho elemento. Para recorrer la lista al rev\u00e9s, hay que crearlo con el tama\u00f1o de la lista para que el primer previous() devuelva el \u00faltimo.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\npublic class ShowListIterator {\npublic void show() {\nListIterator&lt;Integer&gt; it;\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(1);\nlist.add(2);\nlist.add(4);\nlist.add(6);\n//Recorrido de la lista hacia atr\u00e1s:\nit = list.listIterator(list.size());\nwhile (it.hasPrevious()) {\nSystem.out.printf(\" %d \", it.previous());// 6 4 2 1\n}\nit = list.listIterator(1);//Se coloca antes del elemento que se encuentra en la posici\u00f3n 1\nSystem.out.printf(\"\\n %d \", it.next());//2\nSystem.out.printf(\"\\n %d \", it.nextIndex());//2\nSystem.out.printf(\"\\n %d \", it.previousIndex());//1\nit.add(3);\nSystem.out.printf(\"\\n %d \", it.next());//4 Una llamada posterior a next() no se ve afectada\nit.add(5);\nSystem.out.printf(\"\\n %d \", it.previous());//5 Una llamada posterior a previous() devuelve el nuevo elemento\nSystem.out.printf(\"\\n %d \\n\", it.next());//5\nit.set(7);//sustituye el \u00faltimo elemento devuelto por next() por 7\nfor (Integer i : list) {\nSystem.out.printf(\" %d \", i);//1 2 3 4 7 6\n}\n}\npublic static void main(String[] args) {\nnew ShowListIterator().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/","title":"Editing","text":""},{"location":"proyects/cinema/proyecto_v1/","title":"Proyecto V1","text":"<p>Se quiere realizar una aplicaci\u00f3n para realizar la compra de entradas de cine. En este primera parte, se llevar\u00e1 a cabo el inicio de sesi\u00f3n.</p> <p>Se debe tener en cuenta que existen 4 tipos de usuarios diferentes, cliente, administrador, encargado y empleado. De todos los usuarios se desea almacenar las credenciales, que constar\u00e1 de correo, contrase\u00f1a y estado. Pero adem\u00e1s de los clientes se desea almacenar la direcci\u00f3n (compuesta de Nombre de la v\u00eda, n\u00famero, municipio, localidad y c\u00f3digo postal), su nombre completo y una breve biograf\u00eda de 160 caracteres. De los empleados se desea almacenar el a\u00f1o en el que empezaron ser empleados y de los encargados el a\u00f1o en el que se hicieron encargados. De los administradores no se desea conocer nada diferente. </p> <p>Al ejecutar la aplicaci\u00f3n le pedir\u00e1 las credenciales necesarias a un usuario para poder acceder a la aplicaci\u00f3n. Si las credenciales son err\u00f3neas, se las volver\u00e1 a solicitar hasta 3 veces, luego mostrar\u00e1 un mensaje de error y terminar\u00e1 la aplicaci\u00f3n. En caso de las credenciales sean correctas, mostrar\u00e1 un mensaje de bienvenida con el tipo de usuario que ha entrado en la aplicaci\u00f3n.</p> <p>Debes tener en cuenta:</p> <ul> <li>El estado de una credencial puede ser, activo, inactivo, dado de baja, email por confirmar.</li> <li>Al realizarse la petici\u00f3n de iniciar sesi\u00f3n, se deber\u00e1 comprobar si el usuario acreditado es de correo prueba@test.com y de contrase\u00f1a 1234. Este tipo de usuario es administrador</li> <li>La aplicaci\u00f3n se har\u00e1 por completo en INGL\u00c9S, incluyendo los mensajes al usuario.</li> <li>Se deber\u00e1 realizar la entrega a trav\u00e9s de GitHub.</li> <li>Se realizar\u00e1n tantos commits, como se considere, pero siempre m\u00e1s de uno.</li> <li>Se valorar\u00e1 la organizaci\u00f3n de paquetes.</li> <li>Se podr\u00e1 usar la librer\u00eda creada en el proyecto anterior llamada Help, pero ninguna librer\u00eda m\u00e1s. En caso de usarla, se deber\u00e1 hacer la importaci\u00f3n de forma correcta.</li> </ul>"},{"location":"proyects/cinema/proyecto_v2/","title":"Proyecto V2","text":"<p>Los primeros cambios a realizar sobre la aplicaci\u00f3n son los siguientes:</p> <p>Sobre las credenciales de usuarios debes validas:</p> <ul> <li>El email sea correcto, en caso de no serlo, se lanzar\u00e1 una excepci\u00f3n llama <code>EmailMalFormedEXception</code>.</li> <li>La constrase\u00f1a contenga de 8 a 16 caracteres, y como m\u00ednimo una letra min\u00fascula, una may\u00fascula, un d\u00edgito y un car\u00e1cter especial.</li> <li>Si la credencial no es v\u00e1lida, o no es ning\u00fana de las indicadas en la versi\u00f3n anterior, deber\u00e1 obtener por defecto el estado inactivo.</li> </ul> <p>Sobre los clientes se debe tener en cuenta que la bibliograf\u00eda no supere los 160 caracteres, y en caso de superarlo obtener solo los 160 primeros caracteres de la bibliograf\u00eda. Tambi\u00e9n hay que tener en cuenta que los campos num\u00e9ricos de la direcci\u00f3n, no pueden ser negativos, y en caso de serlos, se lanzar\u00e1 un excepci\u00f3n de tipo <code>IllegalArgumentException</code>.</p> <p>Sobre los encargados y los empleados, hay que tener en cuenta, que el a\u00f1o en el que comenzar\u00f3n sus puestos deben ser n\u00fameros positivos y a\u00f1os l\u00f3gicos y v\u00e1lidos, (no ser\u00eda l\u00f3gico que el empleado empezase a trabajar en la empresa en el a\u00f1o 2 a.C)</p> <p>Debe crear una aplicaci\u00f3n llamada SignUpCliente.java, SignUpEmpleado.java, SignUpEmcargado.java, donde se solicite los datos de registro, y en caso de que alguno sea err\u00f3neo debe volver a solicitarselo. Se debe tener en cuenta que el estado de un usuario debe ser EMAIL POR CONFIRMAR, durante su registro, y que no se debe soliciar al usuario.</p> <p>Una vez que el tipo de usuario haya sido creado\u00a1, se mostrar\u00e1 por pantalla con la siguiente estructura:</p> CLIENTEEMPLEADOENCARGADO <pre><code>Cliente Sa\u00fal Benitez\n - Email: saul@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - Direcci\u00f3n: Calle Inventida, n\u00ba 7 - 11300 - La L\u00ednea de la concepci\u00f3n (C\u00e1diz)\n- Bibliograf\u00eda: Soy cin\u00e9filo, en busca de las mejores ofertas para ir al cine.\n   Me gusta mucho las pel\u00edculas de Marvel y DC, aun que a veces tambi\u00e9n me pongo\n   sensibl\u00f3n y me pongo una comedia rom\u00e1ntica.\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> <pre><code>Cliente Rosa Soria\n - Email: rosa@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - A\u00f1o de contrataci\u00f3n: 2015\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> <pre><code>Cliente Marta Dominguez\n - Email: marta@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - A\u00f1o de contrataci\u00f3n: 2012\n- A\u00f1o de subida: 2018\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> Pregunta para pensar <p>\u00bfPor que no fue un error en la primera versi\u00f3n crear una clase exactamente Admin que heredase de la clase base User? Justifica tu respuesta</p>"}]}