{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"bloque_ii/tema_10/page-1/","title":"10.1 Introducci\u00f3n a los Gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-1/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Se trata de la implementaci\u00f3n en Java de una de las opciones de C++ m\u00e1s a\u00f1oradas por los programadores que proceden de ese lenguaje; las plantillas (templates). Son similares a las plantillas de C++. Sirven para evitar conversiones de clases.</p> <p>Uno de los motivos de la creaci\u00f3n de los gen\u00e9ricos fueron las colecciones. Sin los gen\u00e9ricos todas las colecciones ser\u00edan de tipo Object, lo que tendr\u00eda una serie de desventajas:</p> <ul> <li>Nada impide crear listas heterog\u00e9neas de objetos. Eso causa problemas evidentes de casting, adem\u00e1s de imposible incoherencias.</li> <li>Si se desea acceder a propiedades espec\u00edficas de otro tipo de clases, ser\u00e1 necesario realizar una cantidad grande de conversiones en el c\u00f3digo, lo que har\u00e1 que sea m\u00e1s pesado de comprender.</li> <li>Los m\u00e9todos de las clases e interfaces de las colecciones no se adaptan al tipo de datos que contienen dificultando su uso.</li> </ul> <p>Por ello aparecieron los tipos gen\u00e9ricos en la versi\u00f3n 1.5 de Java consiguiendo solucionar los problemas anteriores en las colecciones.</p>"},{"location":"bloque_ii/tema_10/page-1/#2-idea-general-de-los-genericos","title":"2. Idea general de los gen\u00e9ricos","text":"<p>Los gen\u00e9ricos permiten crear clases y m\u00e9todos en los que los tipos de datos (las clases) sobre los que act\u00faan son un par\u00e1metro m\u00e1s. Gracias a ello se pueden crear clases y m\u00e9todos que se adaptan a distintos tipos de datos de forma autom\u00e1tica.</p> <p>Anteriormente a la aparici\u00f3n de los gen\u00e9ricos el que las clases y m\u00e9todos se adaptaran autom\u00e1ticamente pasaba por especificar par\u00e1metros de tipo Object, ya que las referencias de tipo Object valen para cualquier otro tipo de objeto.</p> <p>El problema es que la coherencia no est\u00e1 asegurada con los tipos Object, la sintaxis del lenguaje puede provocar excepciones de tipo ClassCastException ante conversiones err\u00f3neas de Object a otro tipo de datos.</p> <p>La idea es:</p> <ol> <li>El programar declara un gen\u00e9rico en un m\u00e9todo de clase, por ejemplo T</li> <li>Cuando se utilice dicha clase o m\u00e9todo se indicar\u00e1 un tipo concreto, entonces se cambia el gen\u00e9rico para que se refiera a ese tipo concreto.</li> </ol>"},{"location":"bloque_ii/tema_10/page-2/","title":"10.2 Uso de gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-2/#1-genericos-en-metodos","title":"1. Gen\u00e9ricos en m\u00e9todos","text":"<p>Se pueden indicar gen\u00e9ricos en los m\u00e9todos. Para indicar que el m\u00e9todo se puede utilizar con cualquier tipo de objeto y que el m\u00e9todo se adaptar\u00e1 a dicho tipo. La sintaxis es: <code>modificadores &lt;Gen\u00e9rico&gt; tipoRetorno nombreM\u00e9todo(...)</code></p> <p>Ejemplo:</p> <pre><code>public class ArrayUtils{\npublic static &lt;T&gt; T getRandom(T a[]){\nint i = new Random().nexInt(a.length-1);\nreturn a[i];\n}\n}\n</code></pre> <p>En el ejemplo anterior, se desea obtener un elemento aleatorio de un array. En el ejemplo la letra T entre los signos &lt; y &gt; indica que se va a utilizar un tipo gen\u00e9rico, el hecho de que le siga otra T significa que el tipo que devuelve el m\u00e9todo tomarAleatorio ser\u00e1 el mismo que el del par\u00e1metro a, y se corresponder\u00e1 al tipo gen\u00e9rico T. Despu\u00e9s cuando se invoque a este m\u00e9todo, la letra gen\u00e9rica T ser\u00e1 traducida por el tipo con el que se invoque al m\u00e9todo. Por ejemplo desde este c\u00f3digo:</p> <pre><code>String a[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString element = ArraysUtils.getRandom(a);\nSystem.out.println(element);\n</code></pre> <p>En ese c\u00f3digo, como se invoca usando un array de Strings, por lo tanto la letra gen\u00e9rica T ser\u00e1 traducida por String. Es decir es como si el c\u00f3digo anterior se tradujera como:</p> <pre><code>public class UtilesArrays {\npublic static String tomarAleatorio(String a[]){\nint i=(int)(Math.random()*a.length);\nreturn a[i];\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#2-genericos-en-las-clases","title":"2. Gen\u00e9ricos en las clases","text":"<p>El m\u00e9todo habitual de utilizar gen\u00e9ricos, debido a su mayor potencia, es declarar el gen\u00e9rico en una clase. De esta forma indicados que el c\u00f3digo de la clase utiliza tipos gen\u00e9ricos que ser\u00e1n traducidos por el tipo de datos que se desee.</p> <p>Por ejemplo una clase pensada para extraer elementos aleatorios de un array del tipo que sea se podr\u00eda declarar as\u00ed:</p> <pre><code>public class RandomElement&lt;T&gt;{\nprivate T element;\npublic RandomElement(T array[]){\nelement = array[new Random(array.length)];\n}\npublic T getElement(){\nreturn element;\n}\n}\n</code></pre> <p>Los tipos se indican tras el nombre de la clase. De esta forma cuando se creen objetos de clase RandomElement habr\u00e1 que indicar la clase por la que se traducir\u00e1 el gen\u00e9rico T. Por ejemplo:</p> <pre><code>public static void main(String[] args){\nString a[] = {\"uno\", \"dos\", \"tres\", \"cuatro\"};\nRandomElement&lt;String&gt; e = new RandomElement&lt;String&gt;(a);\nSystem.out.println(a.getElement());\n}\n</code></pre> <p>Obs\u00e9rvese que tanto al declarar el objeto e hay que concretar el valor del gen\u00e9rico de ah\u00ed que la declaraci\u00f3n sea <code>RandomElement&lt;String&gt; e</code> de ese modo ya queda claro la traducci\u00f3n de <code>T</code>. A partir de ese momento ya todos los m\u00e9todos de clase y propiedades que utilizaran el gen\u00e9rico <code>T</code>, ahora utilizar\u00e1n el tipo <code>String</code>. En definitiva los gen\u00e9ricos de clase marcan las posiciones para la clase concreta que habr\u00e1 que especificar en la creaci\u00f3n del objeto. Lo bueno es que pueden convivir distintas concreciones de gen\u00e9ricos, podr\u00eda ser:</p> <pre><code>RandomElement&lt;String&gt; e1 = new RandomElement&lt;String&gt;(a1);\nRandomElement&lt;Integer&gt; e2 = new RandomElement&lt;Integer&gt;(a2);\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#3-interfaces-con-genericos","title":"3. Interfaces con gen\u00e9ricos","text":"<p>Al igual que las clases, las interfaces pueden utilizar gen\u00e9ricos en las mismas condiciones que en \u00e9stas:</p> <pre><code>public interface Comparable&lt;T&gt;{\nT lower();\nT upper();\n}\n</code></pre> <p>Una clase que implemente la interfaz puede hacerlo as\u00ed:</p> <pre><code>public class Clase1 implements Compar&lt;String&gt;{\n</code></pre> <p>De modo que traduce el gen\u00e9rico de la interfaz por un tipo concreto o bien:</p> <pre><code>public class Clase1 &lt;T&gt; implements Compar&lt;T&gt;{\n</code></pre> <p>De modo que no traduce el gen\u00e9rico y espera a que durante la creaci\u00f3n de objetos de esa clase se indique el tipo concreto para el gen\u00e9rico.</p>"},{"location":"bloque_ii/tema_10/page-2/#4-uso-de-varios-genericos","title":"4. Uso de varios gen\u00e9ricos","text":"<p>Tanto en m\u00e9todos, como en clases o interfaces, es posible utilizar dos tipos gen\u00e9ricos e incluso m\u00e1s. Para ello se separan por comas dentro del operador diamante. Ejemplo:</p> <pre><code>public class CompareObjects&lt;T, U&gt;{\nprotected T object1;\nprotected U object2;\npublic CompareObjects(T object1, U object2){\nthis.object1 = object1;\nthis.object2 = object2;\n}\npublic boolean sameFirstLetter(){\nString letter1 = object1.getClass().getName().substring(1,1);\nString letter2 = object2.getClass().getName().substring(1,1);\nreturn letter1.equalsIgnoreCase(letter2);\n}\n}\n</code></pre> <p>Esta clase (que en realidad no es muy \u00fatil), construye un objeto a partir de otros dos. El primero de tipo gen\u00e9rico <code>T</code>, y el segundo de tipo <code>U</code>. El m\u00e9todo <code>sameFirstLetter</code> devuelve verdadero si el nombre de clase de <code>T</code> empieza por la misma letra que <code>U</code>.</p> <p>Para utilizar esta clase:</p> <pre><code>public static void main(String[] args){\nString s1 = \"Hola\";\nStringBuffer s2 = new StringBuffer(\"Adi\u00f3s\");\nCompareObjects&lt;String, StringBuffer&gt; comp = new CompareObjects&lt;String, StringBuffer&gt;(s1,s2);\nSystem.out.println(comp.sameFirstLetter());\n}\n</code></pre> <p>Devolver\u00e1 verdadero porque tanto <code>String</code> como <code>StringBuffer</code> empiezan por <code>S</code>. En el ejemplo <code>T</code> se convertir\u00e1 en String y <code>U</code> en <code>StringBuffer</code>.</p>"},{"location":"bloque_ii/tema_10/page-3/","title":"10.3 Gen\u00e9ricos avanzados","text":""},{"location":"bloque_ii/tema_10/page-3/#limitacion-de-los-tipos-posibles-en-un-generico","title":"Limitaci\u00f3n de los tipos posibles en un gen\u00e9rico","text":"<p>A veces no interesa que las clases acepten a cualquier tipo de objeto, sino a objetos de un determinado tipo y sus descendientes. Eso es posible indicarlo mediante la palabra <code>extends</code> dentro de la declaraci\u00f3n del gen\u00e9rico. Ejemplo:</p> <pre><code>public class HandlerVehicles &lt;V extends Vehicles&gt;{\nprotected V vehicle;\npublic HandlerVehicles(V vehicle){\nthis.vehicle = vehicle;\n}\npublic void start(){\nvehicle.start();\n}\n}\n</code></pre> <p>En el ejemplo, a la clase se le puede indicar cualquier clase descendiente de <code>Vehicle</code>, pero ninguna otra. Por ejemplo:</p> <pre><code>HandlerVehicle&lt;Car&gt; v1 = new HandlerVehicle&lt;Car&gt;();\nHandlerVehicle&lt;Autocar&gt; v2 = new HandlerVehicle&lt;Autocar&gt;\n</code></pre> <p>Sin embargo, no se podr\u00eda declarar:</p> <pre><code>HandlerVehicle&lt;String&gt; v3 = HandlerVehicle&lt;String&gt;(e);\n</code></pre> <p>No es posible porque la clase String no es heredera de ning\u00fan veh\u00edculo. La raz\u00f3n de utilizar esta cl\u00e1usula tan restrictiva est\u00e1 en el hecho de poder realizar acciones que sabemos que s\u00f3lo son posibles en cierto tipo de objetos. La clase <code>HandlerVehicle</code> necesita arrancar el veh\u00edculo, por ello tenemos que asegurar que el gen\u00e9rico no puede ser ninguna clase incompatible.</p> <p>Por otro lado extends no tiene por qu\u00e9 referirse a clases, tambi\u00e9n puede referirse a interfaces. Ejemplo:</p> <pre><code>public class Clase1 &lt;V extends Comparable&gt;{\n</code></pre> <p>Significa que la Clase1 usa un gen\u00e9rico al que se le puede asignar cualquier clase que implemente la interfaz Comparable.</p>"},{"location":"bloque_ii/tema_10/page-3/#tipos-comodin","title":"Tipos comod\u00edn","text":"<p>Aunque parece que todo est\u00e1 resuelto de esta forma. Hay problemas cuando mezclamos objetos de la misma clase pero distinta traducci\u00f3n de gen\u00e9rico. Es el caso de este ejemplo:</p> <pre><code>public class RandomElement&lt;T&gt;{\nprivate T element;\nprivate int index;\npublic RandomElement(T array[]){\nindex = new Random().nextInt(array.length);\nelement = array[index];\n}\npublic T getElement(){\nreturn element;\n}\npublic int getIndex(){\nreturn index;\n}\npublic boolean sameIndex(RandomElement&lt;T&gt; random){\nreturn random.index = index;\n}\n}\n</code></pre> <p>En este caso la clase RandomElement se le ha a\u00f1adido una propiedad que almacena el \u00edndice aleatorio que obtiene el constructor. Eso permite que construyamos un m\u00e9todo llamado <code>sameIndex</code> que recibe un objeto de clase RandomElement y nos dice si el \u00edndice aleatorio calculado fue el mismo. Para usar este m\u00e9todo:</p> <pre><code>String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString[] s2 = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"};\nRandomElement&lt;String&gt; r1 = new RandomElement&lt;String&gt;(s1);\nRandomElement&lt;String&gt; r2 = new RandomElement&lt;String&gt;(s2);\nSystem.out.println(r1.sameIndex(r2));\n</code></pre> <p>El c\u00f3digo funciona, s\u00f3lo devolver\u00e1 verdadero si tanto el objeto <code>r1</code> como en <code>r2</code>, el \u00edndice tiene el mismo valor. Sin embargo, este otro c\u00f3digo fallara:</p> <p>```java hl_lines= 6 String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}; Integer[] s2 = {1,2,3,4,5,6}; RandomElement r1 = new RandomElement(s1); RandomElement r2 = new RandomElement(s2); <p>System.out.println(r1.sameIndex(r2)); <pre><code>El error ocurre en tiempo de compilaci\u00f3n. La raz\u00f3n, que en la l\u00ednea remarcada, el objeto `r1` es ya de tipo `RandomElement&lt;String&gt;` por lo que el m\u00e9todo `sameIndex` s\u00f3lo puede aceptar objetos de tipo `RandomElement&lt;String&gt;`, ya que el gen\u00e9rico T se tradujo como STring. El problema est\u00e1 en que dicho m\u00e9todo tiene que poder aceptar cualquier tipo de objeto de tipo `RandomElement`.\n\nPara ello se usa el signo `&lt;?&gt;` de ese modo indicamos la posibilidad de aceptar cualquier tipo de clase con gen\u00e9rico. Es decir el m\u00e9todo se reescribir\u00eda as\u00ed:\n\n```java\npublic boolean sameIndex(RandomElement&lt;?&gt; random){\n    return random.getIndex() == index;\n}\n</code></pre></p> <p>De esa forma se indica que random es un objeto de tipo <code>RandomElement</code> tenga el tipo que tenga el gen\u00e9rico.</p> <p>Incluso se puede delimitar el gen\u00e9ricos:</p> <pre><code>public boolean sameIndex(RandomElement&lt;? extends Number&gt; random){\nreturn random.getIndex() == index;\n}\n</code></pre> <p>Ahora el m\u00e9todo acepta cualquier tipo de <code>RandomElement</code> pero siempre y cuando el tipo gen\u00e9rico forme parte de la herencia <code>Number</code></p>"},{"location":"proyects/proyecto_v1/","title":"Proyecto V1","text":"<p>Se quiere realizar una aplicaci\u00f3n para realizar la compra de entradas de cine. En este primera parte, se llevar\u00e1 a cabo el inicio de sesi\u00f3n.</p> <p>Se debe tener en cuenta que existen 4 tipos de usuarios diferentes, cliente, administrador, encargado y empleado. De todos los usuarios se desea almacenar las credenciales, que constar\u00e1 de correo, contrase\u00f1a y estado. Pero adem\u00e1s de los clientes se desea almacenar la direcci\u00f3n (compuesta de Nombre de la v\u00eda, n\u00famero, municipio, localidad y c\u00f3digo postal), su nombre completo y una breve biograf\u00eda de 160 caracteres. De los empleados se desea almacenar el a\u00f1o en el que empezaron ser empleados y de los encargados el a\u00f1o en el que se hicieron encargados. De los administradores no se desea conocer nada diferente. </p> <p>Al ejecutar la aplicaci\u00f3n le pedir\u00e1 las credenciales necesarias a un usuario para poder acceder a la aplicaci\u00f3n. Si las credenciales son err\u00f3neas, se las volver\u00e1 a solicitar hasta 3 veces, luego mostrar\u00e1 un mensaje de error y terminar\u00e1 la aplicaci\u00f3n. En caso de las credenciales sean correctas, mostrar\u00e1 un mensaje de bienvenida con el tipo de usuario que ha entrado en la aplicaci\u00f3n.</p> <p>Debes tener en cuenta:</p> <ul> <li>El estado de una credencial puede ser, activo, inactivo, dado de baja, email por confirmar.</li> <li>Al realizarse la petici\u00f3n de iniciar sesi\u00f3n, se deber\u00e1 comprobar si el usuario acreditado es de correo prueba@test.com y de contrase\u00f1a 1234. Este tipo de usuario es administrador</li> <li>La aplicaci\u00f3n se har\u00e1 por completo en INGL\u00c9S, incluyendo los mensajes al usuario.</li> <li>Se deber\u00e1 realizar la entrega a trav\u00e9s de GitHub.</li> <li>Se realizar\u00e1n tantos commits, como se considere, pero siempre m\u00e1s de uno.</li> <li>Se valorar\u00e1 la organizaci\u00f3n de paquetes.</li> <li>Se podr\u00e1 usar la librer\u00eda creada en el proyecto anterior llamada Help, pero ninguna librer\u00eda m\u00e1s. En caso de usarla, se deber\u00e1 hacer la importaci\u00f3n de forma correcta.</li> </ul>"},{"location":"proyects/proyecto_v2/","title":"Proyecto V2","text":"<p>Los primeros cambios a realizar sobre la aplicaci\u00f3n son los siguientes:</p> <p>Sobre las credenciales de usuarios debes validas:</p> <ul> <li>El email sea correcto, en caso de no serlo, se lanzar\u00e1 una excepci\u00f3n llama <code>EmailMalFormedEXception</code>.</li> <li>La constrase\u00f1a contenga de 8 a 16 caracteres, y como m\u00ednimo una letra min\u00fascula, una may\u00fascula, un d\u00edgito y un car\u00e1cter especial.</li> <li>Si la credencial no es v\u00e1lida, o no es ning\u00fana de las indicadas en la versi\u00f3n anterior, deber\u00e1 obtener por defecto el estado inactivo.</li> </ul> <p>Sobre los clientes se debe tener en cuenta que la bibliograf\u00eda no supere los 160 caracteres, y en caso de superarlo obtener solo los 160 primeros caracteres de la bibliograf\u00eda. Tambi\u00e9n hay que tener en cuenta que los campos num\u00e9ricos de la direcci\u00f3n, no pueden ser negativos, y en caso de serlos, se lanzar\u00e1 un excepci\u00f3n de tipo <code>IllegalArgumentException</code>.</p> <p>Sobre los encargados y los empleados, hay que tener en cuenta, que el a\u00f1o en el que comenzar\u00f3n sus puestos deben ser n\u00fameros positivos y a\u00f1os l\u00f3gicos y v\u00e1lidos, (no ser\u00eda l\u00f3gico que el empleado empezase a trabajar en la empresa en el a\u00f1o 2 a.C)</p> <p>Debe crear una aplicaci\u00f3n llamada SignUpCliente.java, SignUpEmpleado.java, SignUpEmcargado.java, donde se solicite los datos de registro, y en caso de que alguno sea err\u00f3neo debe volver a solicitarselo. Se debe tener en cuenta que el estado de un usuario debe ser EMAIL POR CONFIRMAR, durante su registro, y que no se debe soliciar al usuario.</p> <p>Una vez que el tipo de usuario haya sido creado\u00a1, se mostrar\u00e1 por pantalla con la siguiente estructura:</p> CLIENTEEMPLEADOENCARGADO <pre><code>Cliente Sa\u00fal Benitez\n - Email: saul@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - Direcci\u00f3n: Calle Inventida, n\u00ba 7 - 11300 - La L\u00ednea de la concepci\u00f3n (C\u00e1diz)\n- Bibliograf\u00eda: Soy cin\u00e9filo, en busca de las mejores ofertas para ir al cine.\n   Me gusta mucho las pel\u00edculas de Marvel y DC, aun que a veces tambi\u00e9n me pongo\n   sensibl\u00f3n y me pongo una comedia rom\u00e1ntica.\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> <pre><code>Cliente Rosa Soria\n - Email: rosa@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - A\u00f1o de contrataci\u00f3n: 2015\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> <pre><code>Cliente Marta Dominguez\n - Email: marta@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - A\u00f1o de contrataci\u00f3n: 2012\n- A\u00f1o de subida: 2018\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> Pregunta para pensar <p>\u00bfPor que no fue un error en la primera versi\u00f3n crear una clase exactamente Admin que heredase de la clase base User? Justifica tu respuesta</p>"}]}