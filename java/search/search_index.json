{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenidx al mundo de Java","text":""},{"location":"bloque_i/tema_1/page-1/","title":"1 Introducci\u00f3n","text":""},{"location":"bloque_i/tema_1/page-1/#conceptos-basicos","title":"Conceptos b\u00e1sicos","text":""},{"location":"bloque_i/tema_1/page-1/#computadora","title":"Computadora","text":"<p>Una computadora. o como se le conoce com\u00fan mente, un ordenador, es una m\u00e1quina electr\u00f3nica, anal\u00f3gica o digital, dotada de una memoria de gran capacidad y de m\u00e9todos de tratamiento de la informaci\u00f3n, capaz de resolver problemas matem\u00e1ticos y l\u00f3gicos mediante la utilizaci\u00f3n autom\u00e1tica de programas inform\u00e1ticos.</p>"},{"location":"bloque_i/tema_1/page-1/#informatica","title":"Inform\u00e1tica","text":"<p>Conjunto de conocimientos cient\u00edficos y t\u00e9cnicas que hacen posible el tratamiento autom\u00e1tico de la informaci\u00f3n por medio de ordenadores.</p>"},{"location":"bloque_i/tema_1/page-1/#hardware","title":"Hardware","text":"<p>Componentes f\u00edsicos que conforman parte de un ordenador (o de otro dispositivo electr\u00f3nico): procesador, RAM, impresora, teclado, rat\u00f3n,...</p>"},{"location":"bloque_i/tema_1/page-1/#software","title":"Software","text":"<p>Es el conjunto de programas de c\u00f3mputo, procedimientos, reglas, documentaci\u00f3n y datos asociados, que forman parte de las operaciones de un sistema de computaci\u00f3n.</p>"},{"location":"bloque_i/tema_1/page-1/#sistema-operativo","title":"Sistema Operativo","text":"<p>Se trata del software encargado de gestionar el ordenador. Es la aplicaci\u00f3n que oculta la f\u00edsica real del ordenador para mostrarnos una interfaz que permita al usuario un mejor y m\u00e1s f\u00e1cil manejo de la computadora. Por ejemplo: Windows, Linux, MacOS, etc.</p>"},{"location":"bloque_i/tema_1/page-1/#algoritmo","title":"Algoritmo","text":"<p>Conjunto ordenado y finito de operaciones que permite hallar la soluci\u00f3n de un problema.</p>"},{"location":"bloque_i/tema_1/page-1/#programa-informatico","title":"Programa inform\u00e1tico","text":"<p>Es una secuencia de instrucciones escritas para realizar una tarea espec\u00edfica en una computadora.</p>"},{"location":"bloque_i/tema_1/page-1/#aplicacion-informatica","title":"Aplicaci\u00f3n Inform\u00e1tica","text":"<p>Software formado por uno o m\u00e1s programas, la documentaci\u00f3n de los mismos y los archivos necesarios para su funcionamiento, de modo que el conjunto completo forma una herramienta de trabajo en un ordenador.</p>"},{"location":"bloque_i/tema_1/page-1/#codificacion-de-la-informacion","title":"Codificaci\u00f3n de la informaci\u00f3n","text":"<p>Un ordenador maneja informaci\u00f3n de todo tipo. Nuestra perspectiva humana nos permite r\u00e1pidamente diferenciar lo que no son n\u00fameros, de lo que es texto, imagen, ... Sin embargo al tratarse de una m\u00e1quina digital, el ordenador s\u00f3lo es capaz de representar n\u00fameros en forma binaria. Por ello todos los ordenadores necesitan codificar la informaci\u00f3n del mundo real al equivalente binario entendible por el ordenador.</p>"},{"location":"bloque_i/tema_1/page-1/#sistemas-numericos","title":"Sistemas Num\u00e9ricos","text":"<p>Existen dos tipos de sistemas num\u00e9ricos:</p> <ol> <li>Sistemas no posicionales. En ellos se utilizan s\u00edmbolos cuyo valor num\u00e9rico es siempre el mismo independientemente de donde se sit\u00faen.Es lo que ocurre con la numeraci\u00f3n romana. En esta numeraci\u00f3n el s\u00edmbolo <code>I</code> significa siempre <code>uno</code> independientemente de su posici\u00f3n.</li> <li>Sistemas posicionales. En ellos los s\u00edmbolos num\u00e9ricos cambian de valor en funci\u00f3n de la posici\u00f3n que ocupe. Es el caso de nuestra numeraci\u00f3n, el s\u00edmbolo 2, en la cifra 12 vale 2; mientra que en la cifra 21 vale viente.</li> </ol> <p>La historia ha demostrado que los sistemas posicionales son mucho mejores para los c\u00e1lculos matem\u00e1ticos ya que las operaciones matem\u00e1ticas son m\u00e1s sencillas. Todos los sistemas posicionales tienen una base, que es el n\u00famero total de s\u00edmbolos que utiliza el sistema.</p>"},{"location":"bloque_i/tema_1/page-1/#sistemas-posicionales","title":"Sistemas posicionales","text":"<ul> <li>Sistema decimal: la base es 10, ya que utiliza 10 s\u00edmbolos, desde el 0 hasta el 9.</li> <li>Sistema binario: la base es 2, utiliza 0 y 1.</li> <li>Sistema octal: la base es 8, desde el 0 hasta el 7. -Sistema hexadecimal: la base es 16, donde el 0 al 9 y desde la A a la F</li> </ul> <p>Para convertir un n\u00famero octal en binario, se representa cada d\u00edgito en octal por tres d\u00edgitos binarios seg\u00fan la siguiente tabla de conversi\u00f3n:</p> Octal Binario 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 <p>Por lo tanto, el n\u00famero 467 en octal ser\u00eda 100110111 en binario.</p> <p>Los mismo podemos hacer con el binario y el hexadecimal pero con 4 d\u00edgitos.</p> Octal Binario 0 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111 8 1000 9 1001 A 1010 B 1011 C 1100 D 1101 E 1110 F 1111 <p>El n\u00famero B3F en hexadecimal es 1011001111111 en binario</p>"},{"location":"bloque_i/tema_1/page-1/#representacion-de-texto-en-el-sistema-binario","title":"Representaci\u00f3n de texto en el sistema binario","text":"<p>Puesto que una computadora no s\u00f3lo maneja n\u00fameros, habr\u00e1 d\u00edgitos binarios que contengan informaci\u00f3n que no es traducible a decimal. Todo depende de c\u00f3mo se interprete esa traducci\u00f3n. Por ejemplo en el caso del texto, lo que se hace es codificar cada car\u00e1cter en una serie de n\u00fameros binarios. El c\u00f3digo ASCII es un est\u00e1ndar que ha sido durante mucho tiempo el m\u00e1s utilizado. Inicialmente era un c\u00f3digo que utilizaba 7 bits para representar texto, lo que significaba que era capaz de codificar 127 caracteres. Por ejemplo el n\u00famero 65 (1000001 en binario) se utiliza para la A may\u00fascula. Poco despu\u00e9s apareci\u00f3 un problema: este c\u00f3digo es suficiente para los caracteres del ingl\u00e9s, pero no para otras lenguas. Entonces se a\u00f1adi\u00f3 el octavo bit para representar otros 128 caracteres que son distintos seg\u00fan idiomas(Europa Occidental usa unos c\u00f3digos que no utiliza Europa Oriental). Eso provoca que un c\u00f3digo como el 190 signifique cosas diferentes si cambiamos de pa\u00eds. Por ello cuando un ordenador necesita mostrar texto, tiene que saber qu\u00e9 juego de c\u00f3digos debe de utilizar (lo cual supone un tremendo problema). Una ampliaci\u00f3n de este m\u00e9todo de codificaci\u00f3n de caracteres es el est\u00e1ndar Unicode que puede utilizar hasta 4 bytes (32 bits) con lo que es capaz de codificar cualquier car\u00e1cter en cualquier lengua del planeta utilizando el mismo conjunto de c\u00f3digos. Poco a poco es el c\u00f3digo que se va extendiendo, siendo actualmente utilizado en un n\u00famero considerable de tecnolog\u00edas recientes, como XML, Java y sistemas operativos modernos.</p> <p>La descripci\u00f3n completa del est\u00e1ndar est\u00e1 disponible en la p\u00e1gina web de Unicode https://unicode.org/. En <code>Quick Links -&gt; Code Charts</code> encontraremos las tablas de caracteres. Los caracteres b\u00e1sicos del espa\u00f1ol los encontraremos en <code>Latin -&gt; Basic Latin (ASCII)</code> y los caracteres especiales del espa\u00f1ol por ejemplo, las vocales acentuadas y la \u00f1, en <code>Latin1 -&gt; Supplement</code>.</p>"},{"location":"bloque_i/tema_1/page-1/#representacion-binaria-de-datos-no-numericos-ni-de-texto","title":"Representaci\u00f3n binaria de datos no num\u00e9ricos ni de texto","text":"<p>En el caso de datos m\u00e1s complejos (im\u00e1genes, v\u00eddeo, audio) se necesita una codificaci\u00f3n m\u00e1s compleja. En el caso, por ejemplo de las im\u00e1genes, una forma b\u00e1sica de codificarlas en binario es la que graba cada p\u00edxel (cada punto distinguible en la imagen) mediante tres bytes: el primero graba el nivel de rojo, el segundo el nivel de azul y el tercero el nivel de verde. Y as\u00ed por cada p\u00edxel. Esto se conoce como modelo de color RGB donde es posible representar un color mediante la mezcla por adici\u00f3n de los tres colores de luz primarios. Por ejemplo un punto en una imagen de color rojo puro: <code>11111111 00000000 00000000</code>. Naturalmente en una imagen no solo se graban los p\u00edxeles sino el tama\u00f1o de la imagen, el modelo de color,... de ah\u00ed que representar estos datos sea tan complejo para el ordenador (y tan complejo entenderlo para nosotros).</p>"},{"location":"bloque_i/tema_1/page-1/#multiplos-para-medir-digitos-binarios","title":"M\u00faltiplos para medir d\u00edgitos binarios","text":"<p>Puesto que toda la informaci\u00f3n de un ordenador se representa de forma binaria, se hizo indispensable el utilizar unidades de medida para poder indicar la capacidad de los dispositivos:</p> <ul> <li>Bit (de binary digit). Representa un d\u00edgito binario. Por ejemplo, se dice que el n\u00famero binario 1001 tiene cuatro bits.</li> <li>Byte. Es el conjunto de 8 bits.</li> <li>Kilobyte. Son 1024 bytes.</li> <li>Megabyte. Son 1024 Kilobytes.</li> <li>Gigabyte. Son 1024 Megabytes.</li> <li>Terabyte. Son 1024 Gigabytes.</li> <li>Petabyte. Son 1024 Terabytes.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#arquitectura-de-von-newmann","title":"Arquitectura de Von Newmann","text":"<p>La mayor\u00eda de los sistemas inform\u00e1ticos actuales se basan en la arquitectura propuesta por Von Newmann. Esta arquitectura se caracteriza porque el programa que ejecuta el sistema inform\u00e1tico est\u00e1 almacenado internamente en el propio sistema.</p> <p> Figura 1 - Arquitectura de Von Newmann</p> <p>Los buses transportan la informaci\u00f3n entre los diferentes elementos.</p> <p> Figura 2 - Buses</p> <ul> <li>Buses de datos: Como su nombre indica transporta datos. Estos datos pueden ser la informaci\u00f3n que se est\u00e1 procesando o las instrucciones del programa que se ejecuta. El ancho en bits del bus de datos define el tama\u00f1o de la palabra del sistema inform\u00e1tico, por ejemplo, 32 bits \u00f3 64 bits.</li> <li>Bus de direcciones: El bus de direcciones se utiliza para indicar el origen y/o el destino de los datos. En el bus de direcciones se indica la posici\u00f3n de memoria a la que se est\u00e1 accediendo en cada momento. Puede tratarse de una direcci\u00f3n de la memoria principal o puede tratarse de una direcci\u00f3n de memoria de un perif\u00e9rico. El ancho en bits del bus de direcciones determina el tama\u00f1o del espacio de memoria direccionable. Un ancho de 16 bits puede almacenar 2 elevado a 16 (65.536) valores diferentes.</li> <li>Bus de control: El bus de control proporciona se\u00f1ales para coordinar las diferentes tareas que se realizan en el sistema inform\u00e1tico. Por ejemplo, R/W indica si es una operaci\u00f3n de lectura o escritura.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#historia-del-software","title":"Historia del Software","text":"<p>Los primeros ordenadores cumpl\u00edan una \u00fanica programaci\u00f3n que estaba definida en los componentes el\u00e9ctricos que formaban el ordenador. La idea de que el ordenador hiciera varias tareas (ordenador programable o multiprop\u00f3sito) hizo que se idearan las tarjetas perforadas. En ellas se utilizaba c\u00f3digo binario, de modo que se hac\u00edan agujeros en ellas para indicar el c\u00f3digo 1 o el cero. Estos \u201cprimeros programas\u201d l\u00f3gicamente serv\u00edan para hacer tareas muy concretas.</p> <p>La llegada de ordenadores electr\u00f3nicos m\u00e1s potentes hizo que los ordenadores se convirtieran en verdaderas m\u00e1quinas digitales que segu\u00edan utilizando el 1 y el 0 del c\u00f3digo binario pero que eran capaces de leer miles de unos y ceros. Empezaron a aparecer los primeros lenguajes de programaci\u00f3n que escrib\u00edan c\u00f3digo m\u00e1s entendible por los humanos que posteriormente era convertido al c\u00f3digo entendible por la m\u00e1quina.</p> <p>Inicialmente la creaci\u00f3n de aplicaciones requer\u00eda escribir pocas l\u00edneas de c\u00f3digo en el ordenador, por lo que no hab\u00eda una t\u00e9cnica especificar a la hora de crear programas. Cada programador se defend\u00eda como pod\u00eda generando el c\u00f3digo a medida que se le ocurr\u00eda. Poco a poco las funciones que se requer\u00edan a los programas fueron aumentando produciendo miles de l\u00edneas de c\u00f3digo que al estar desorganizada hac\u00edan casi imposible su mantenimiento. S\u00f3lo el programador que hab\u00eda escrito el c\u00f3digo era capaz de entenderlo y eso no era en absoluto pr\u00e1ctico.</p> <p>La llamada crisis del software ocurri\u00f3 cuando se percibi\u00f3 que se gastaba m\u00e1s tiempo en hacer las modificaciones a los programas que en volver a crear el software. La raz\u00f3n era que ya se hab\u00edan codificado millones de l\u00edneas de c\u00f3digo antes de que se definiera un buen m\u00e9todo para crear los programas. La soluci\u00f3n a esta crisis ha sido la definici\u00f3n de la Ingenier\u00eda del software como un oficio que requer\u00eda un m\u00e9todo de trabajo similar al del resto de ingenier\u00edas. La b\u00fasqueda de una metodolog\u00eda de trabajo que elimine esta crisis parece que a\u00fan no est\u00e1 resuelta, de hecho los m\u00e9todos de trabajo siguen redefini\u00e9ndose una y otra vez.</p>"},{"location":"bloque_i/tema_1/page-1/#ciclo-de-vida-de-una-aplicacion","title":"Ciclo de vida de una aplicaci\u00f3n","text":"<p> Figura 3 - Ciclo de vida</p> <p>Una de las cosas que se han definido tras el nacimiento de la ingenier\u00eda del software ha sido el ciclo de vida de una aplicaci\u00f3n. El ciclo de vida define los pasos que sigue el proceso de creaci\u00f3n de una aplicaci\u00f3n desde que se propone hasta que finaliza su construcci\u00f3n. Los pasos son:</p> <ol> <li>An\u00e1lisis. En esta fase se determinan los requisitos que tiene que cumplir la aplicaci\u00f3n. Se anota todo aquello que afecta al futuro funcionamiento de la aplicaci\u00f3n. Este paso le realiza un analista.</li> <li>Dise\u00f1o. Se especifican los esquemas de dise\u00f1o de la aplicaci\u00f3n. Estos esquemas forman los planos del programador, los realiza el analista y representan todos los aspectos que requiere la creaci\u00f3n de la aplicaci\u00f3n.</li> <li>Codificaci\u00f3n. En esta fase se pasa el dise\u00f1o a c\u00f3digo escrito en alg\u00fan lenguaje de programaci\u00f3n. Esta es la primera labor que realiza el programador.</li> <li>Pruebas. Se trata de comprobar que el funcionamiento de la aplicaci\u00f3n es la adecuada. Se realiza en varias fases:<ol> <li>Prueba del c\u00f3digo. Las realizan programadores. Normalmente programadores distintos a los que crearon el c\u00f3digo, de ese modo la prueba es m\u00e1s independiente y generar\u00e1 resultados m\u00e1s \u00f3ptimos.</li> <li>Versi\u00f3n alfa. Es una primera versi\u00f3n terminada que se revisa a fin de encontrar errores. Estas pruebas conviene que sean hechas por personal no inform\u00e1tico. El producto s\u00f3lo tiene cierta apariencia de acabado.</li> <li>Versi\u00f3n beta. Versi\u00f3n casi definitiva del software en la que no se estiman fallos, pero que se distribuye a los clientes para que encuentren posibles problemas. A veces est\u00e1 versi\u00f3n acaba siendo la definitiva.</li> </ol> </li> <li>Mantenimiento. Tiene lugar una vez que la aplicaci\u00f3n ha sido ya distribuida. En esta fase se asegura que el sistema siga funcionando aunque cambien los requisitos o el sistema para el que fue dise\u00f1ado el software. Antes esos cambios se hacen los arreglos pertinentes, por lo que habr\u00e1 que retroceder a fases anteriores del ciclo de vida.</li> </ol>"},{"location":"bloque_i/tema_1/page-1/#errores","title":"Errores","text":"<p>Cuando un programa obtiene una salida que no es la esperada, se dice que posee errores. Los errores son uno de los caballos de batalla de los programadores ya que a veces son muy dif\u00edciles de encontrar (de ah\u00ed que hoy en d\u00eda en muchas aplicaciones se distribuyan parches para subsanar errores no encontrados en la creaci\u00f3n de la aplicaci\u00f3n). Tipos de errores:</p> <ul> <li>Error del usuario. Errores que se producen cuando el usuario realiza algo inesperado y el programa no reacciona apropiadamente (se entiende por usuario la persona que utiliza la aplicaci\u00f3n inform\u00e1tica).</li> <li>Errores de documentaci\u00f3n. Ocurren cuando la documentaci\u00f3n del programa no es correcta y provoca fallos en el manejo.</li> <li>Error de interfaz. Se entiende por interfaz el medio con que el usuario se comunica con la m\u00e1quina, como ventanas, men\u00fas, etc. El error de interfaz ocurre si la interfaz de usuario de la aplicaci\u00f3n es enrevesada para el usuario impidiendo su manejo normal. Tambi\u00e9n se llaman as\u00ed los errores de protocolo entre dispositivos.</li> <li>Error de entrada / salida o de comunicaciones. Ocurre cuando falla la comunicaci\u00f3n entre el programa y un dispositivo (se desea imprimir y no hay papel, falla el teclado,...)</li> <li>Error fatal. Ocurre cuando el hardware produce una situaci\u00f3n inesperada que el software no puede controlar (el ordenador se cuelga, errores en la grabaci\u00f3n de datos,...)</li> <li>Error de sintaxis. Ocurre cuando una instrucci\u00f3n del c\u00f3digo no est\u00e1 bien escrita, es decir, tiene un error de sintaxis. Por lo tanto, no puede ser traducida a c\u00f3digo binario.</li> <li>Error de ejecuci\u00f3n. Se produce cuando el ordenador no puede ejecutar alguna instrucci\u00f3n de forma correcta. Por ejemplo, la instrucci\u00f3n c = 5 / 0; es correcta sint\u00e1cticamente y ser\u00e1 traducida a c\u00f3digo binario. Sin embargo, cuando la computadora intente realizar la divisi\u00f3n 5 / 0 se producir\u00e1 un error de ejecuci\u00f3n, ya que, matem\u00e1ticamente, no se puede dividir entre cero.</li> <li>Error de l\u00f3gica. En cuanto a los errores de l\u00f3gica son los m\u00e1s dif\u00edciles de detectar. Cuando un programa no tiene errores de sintaxis ni de ejecuci\u00f3n, pero a\u00fan as\u00ed, no funciona bien, esto es debido a la existencia de alg\u00fan error l\u00f3gico. De manera que, un error de l\u00f3gica se produce cuando los resultados obtenidos no son los esperados.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-de-programacion","title":"Lenguajes de programaci\u00f3n","text":""},{"location":"bloque_i/tema_1/page-1/#historia","title":"Historia","text":""},{"location":"bloque_i/tema_1/page-1/#inicio-en-la-programacion","title":"Inicio en la programaci\u00f3n","text":"<p>Charles Babbage defini\u00f3 a mediados del siglo XIX lo que \u00e9l llam\u00f3 la m\u00e1quina anal\u00edtica. Se considera a esta m\u00e1quina el dise\u00f1o del primer ordenador. La realidad es que no se pudo construir hasta el siglo siguiente. El caso es que su colaboradora Ada Lovelace escribi\u00f3 en tarjetas perforadas una serie de instrucciones que la m\u00e1quina iba a ser capaz de ejecutar. Se dice que eso signific\u00f3 el inicio de la ciencia de la programaci\u00f3n de ordenadores. En la segunda guerra mundial debido a las necesidades militares, la ciencia de la computaci\u00f3n prospera y con ella aparece el famoso ENIAC (Electronic Numerical Integrator And Calculator), que se programaba cambiando su circuiter\u00eda. Esa es la primera forma de programar (que a\u00fan se usa en numerosas m\u00e1quinas) que s\u00f3lo vale para m\u00e1quinas de \u00fanico prop\u00f3sito. Si se cambia el prop\u00f3sito, hay que modificar la m\u00e1quina.</p>"},{"location":"bloque_i/tema_1/page-1/#codigo-maquina-primera-generacion-de-lenguajes-1gl","title":"C\u00f3digo m\u00e1quina. Primera generaci\u00f3n de lenguajes (1GL)","text":"<p>No mucho m\u00e1s tarde apareci\u00f3 la idea de que las m\u00e1quinas fueran capaces de realizar m\u00e1s de una aplicaci\u00f3n. Para lo cual se ide\u00f3 el hecho de que hubiera una memoria donde se almacenaran esas instrucciones. Esa memoria se pod\u00eda rellenar con datos procedentes del exterior. Inicialmente se utilizaron tarjetas perforadas para introducir las instrucciones. Durante mucho tiempo esa fue la forma de programar, que teniendo en cuenta que las m\u00e1quinas entend\u00edan s\u00f3lo c\u00f3digo binario, consist\u00eda en introducir la programaci\u00f3n de la m\u00e1quina mediante unos y ceros, el llamado c\u00f3digo m\u00e1quina. Todav\u00eda los ordenadores es el \u00fanico c\u00f3digo que entienden, por lo que cualquier forma de programar debe de ser convertida a c\u00f3digo m\u00e1quina. S\u00f3lo se ha utilizado por los programadores en los inicios de la inform\u00e1tica. Su incomodidad de trabajo hace que sea impensable para ser utilizado hoy en d\u00eda. Pero cualquier programa de ordenador debe, finalmente, ser convertido a este c\u00f3digo para que un ordenador puede ejecutar las instrucciones de dicho programa. Un detalle a tener en cuenta es que el c\u00f3digo m\u00e1quina es distinto para cada tipo de procesador. Lo que hace que los programas en c\u00f3digo m\u00e1quina no sean portables entre distintas m\u00e1quinas.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguaje-ensamblador-segunda-generacion-de-lenguajes-2gl","title":"Lenguaje ensamblador. Segunda generaci\u00f3n de lenguajes (2GL)","text":"<p>En los a\u00f1os 40 se intent\u00f3 concebir un lenguaje m\u00e1s simb\u00f3lico que permitiera no tener que programar utilizando c\u00f3digo m\u00e1quina. Poco m\u00e1s tarde se ide\u00f3 el lenguaje ensamblador, que es la traducci\u00f3n del c\u00f3digo m\u00e1quina a una forma m\u00e1s textual. Cada tipo de instrucci\u00f3n se asocia a una palabra mnemotecnia (como SUM para sumar por ejemplo), de forma que cada palabra tiene traducci\u00f3n directa en el c\u00f3digo m\u00e1quina. Tras escribir el programa en c\u00f3digo ensamblador, un programa (llamado tambi\u00e9n ensamblador) se encargar\u00e1 de traducir el c\u00f3digo ensamblador a c\u00f3digo m\u00e1quina. Esta traducci\u00f3n es r\u00e1pida puesto que cada l\u00ednea en ensamblador tiene equivalente directo en c\u00f3digo m\u00e1quina (en los lenguajes modernos no ocurre esto). La idea es la siguiente: si en el c\u00f3digo m\u00e1quina el n\u00famero binario 0000 significa sumar, una instrucci\u00f3n m\u00e1quina que sumara el n\u00famero 8 (00001000 en binario) al n\u00famero 16 (00010000 en binario) ser\u00eda <code>00000000100000010000</code>. El ordenador entender\u00eda que los primeros cuatro bits representan la instrucci\u00f3n y los 8 siguientes el primer n\u00famero y los ocho siguientes el segundo n\u00famero (suponiendo que los n\u00fameros ocupan 8 bits). L\u00f3gicamente trabajar de esta forma es muy complicado. Por eso se podr\u00eda utilizar la siguiente traducci\u00f3n en ensamblador: <code>SUM 8 16</code> , que ya se entiende mucho mejor. Puesto que el ensamblador es una representaci\u00f3n textual pero exacta del c\u00f3digo m\u00e1quina, cada programa s\u00f3lo funcionar\u00e1 para la m\u00e1quina en la que fue concebido el programa, es decir, no es portable. La ventaja de este lenguaje es que se puede controlar absolutamente el funcionamiento de la m\u00e1quina, lo que permite crear programas muy eficientes. Lo malo es precisamente que hay que conocer muy bien el funcionamiento de la computadora para crear programas con esta t\u00e9cnica. Adem\u00e1s las l\u00edneas requeridas para realizar una tarea se disparan ya que las instrucciones de la m\u00e1quina son excesivamente simples.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-de-alto-nivel-lenguajes-de-tercera-generacion-3gl","title":"Lenguajes de alto nivel. Lenguajes de tercera generaci\u00f3n (3GL)","text":"<p>Aunque el ensamblador signific\u00f3 una notable mejora sobre el c\u00f3digo m\u00e1quina, segu\u00eda siendo excesivamente cr\u00edptico. De hecho para hacer un programa sencillo, se necesitaban miles y miles l\u00edneas de c\u00f3digo. Para evitar los problemas del ensamblador apareci\u00f3 la tercera generaci\u00f3n de lenguajes de programaci\u00f3n, la de los lenguajes de alto nivel. En este caso el c\u00f3digo vale para cualquier m\u00e1quina pero deber\u00e1 ser traducido mediante software especial que adaptar\u00e1 el c\u00f3digo de alto nivel al c\u00f3digo m\u00e1quina correspondiente. Esta traducci\u00f3n es necesaria ya que el c\u00f3digo en un lenguaje de alto nivel no se parece en absoluto al c\u00f3digo m\u00e1quina. Tras varios intentos de representar lenguajes, en 1957 aparece el que se considera el primer lenguaje de alto nivel, el FORTRAN (FORmula TRANslation), lenguaje orientado a resolver f\u00f3rmulas matem\u00e1ticas. Poco a poco fueron evolucionando los lenguajes formando lenguajes cada vez mejores. As\u00ed en 1958 se crea LISP como lenguaje declarativo para expresiones matem\u00e1ticas, en 1960 se cre\u00f3 el COBOL como lenguaje de gesti\u00f3n y en 1963 se cre\u00f3 PL/I el primer lenguaje que admit\u00eda la multitarea y la programaci\u00f3n modular. BASIC se cre\u00f3 en el a\u00f1o 1964 como lenguaje de programaci\u00f3n sencillo de aprender y ha sido uno de los lenguajes m\u00e1s populares. En 1968 se crea LOGO para ense\u00f1ar a programar a los ni\u00f1os. Pascal se cre\u00f3 con la misma idea acad\u00e9mica pero siendo ejemplo de lenguaje estructurado para programadores avanzados. El creador del Pascal (Niklaus Wirdth) cre\u00f3 Modula en 1977 siendo un lenguaje estructurado para la programaci\u00f3n de sistemas (intentando sustituir al C). C es un lenguaje de programaci\u00f3n originalmente desarrollado por Dennis Ritchie entre 1969 y 1972 como evoluci\u00f3n del anterior lenguaje B a su vez basado en BCPL. Al igual que B, es un lenguaje orientado a la implementaci\u00f3n de Sistemas operativos, concretamente Unix. C es apreciado por la eficiencia del c\u00f3digo que produce y es el lenguaje de programaci\u00f3n m\u00e1s popular para crear software de sistemas, aunque tambi\u00e9n se utiliza para crear aplicaciones. Es un lenguaje de medio nivel ya que dispone de las estructuras t\u00edpicas de los lenguajes de alto nivel pero a su vez dispone de construcciones del lenguaje que permiten un control a muy bajo nivel pudiendo acceder directamente a memoria o dispositivos perif\u00e9ricos.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-de-cuarta-generacion-4gl","title":"Lenguajes de cuarta generaci\u00f3n (4GL)","text":"<p>En los a\u00f1os 70 se empez\u00f3 a utilizar \u00e9ste t\u00e9rmino para hablar de lenguajes en los que apenas hay c\u00f3digo y en su lugar aparecen indicaciones sobre qu\u00e9 es lo que el programa debe de obtener. Se consideraba que el lenguaje SQL (muy utilizado en las bases de datos) y sus derivados eran de cuarta generaci\u00f3n. Los lenguajes de consulta de datos, creaci\u00f3n de formularios, informes,... son lenguajes de cuarta generaci\u00f3n. Aparecieron con los sistemas de base de datos. Actualmente se consideran lenguajes de \u00e9ste tipo a aquellos lenguajes que se programan sin escribir casi c\u00f3digo (lenguajes visuales), mientras que tambi\u00e9n se propone que este nombre se reserve a los lenguajes orientados a objetos.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguaje-orientado-a-objetos","title":"Lenguaje orientado a objetos","text":"<p>En los 80 llegan los lenguajes preparados para la programaci\u00f3n orientada a objetos todos procedentes de Simula (1964) considerado el primer lenguaje con facilidades de uso de objetos. De estos destac\u00f3 inmediatamente C++. A partir de C++ aparecieron numerosos lenguajes que convirtieron los lenguajes cl\u00e1sicos en lenguajes orientados a objetos y adem\u00e1s con mejoras en el entorno de programaci\u00f3n, son los llamados lenguajes visuales: Visual Basic, Delphi (versi\u00f3n orientada a objetos de Pascal), Visual C++,...En 1995 aparece Java como lenguaje totalmente orientado a objetos y en el a\u00f1o 2000 aparece C# un lenguaje que toma la forma de trabajar de C++ y del propio Java.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-para-la-web","title":"Lenguajes para la web","text":"<p>La popularidad de Internet ha producido lenguajes h\u00edbridos que se mezclan con el c\u00f3digo HTML con el que se crean las p\u00e1ginas web. HTML no es un lenguaje en s\u00ed sino un formato de texto pensado para crear p\u00e1ginas web. Estos lenguajes se usan para poder realizar p\u00e1ginas web m\u00e1s potentes. Son lenguajes interpretados como JavaScript o VB Script, o lenguajes especiales para uso en servidores como ASP, JSP o PHP. Todos ellos permiten crear p\u00e1ginas web usando c\u00f3digo mezcla de p\u00e1ginas web y lenguajes de programaci\u00f3n sencillos.</p>"},{"location":"bloque_i/tema_1/page-1/#tipos-de-lenguajes","title":"Tipos de lenguajes","text":"<p>Seg\u00fan el estilo de programaci\u00f3n se puede hacer esta divisi\u00f3n:</p> <ul> <li>Lenguajes imperativos. Son lenguajes que se centran en c\u00f3mo resolver el problema. Las instrucciones se ejecutan secuencialmente y van modificando la memoria del ordenador para producir las salidas requeridas. La mayor\u00eda de lenguajes (C, Pascal, Basic, Cobol, ...) son de este tipo. Dentro de estos lenguajes est\u00e1n tambi\u00e9n los lenguajes orientados a objetos (C++, Java, C#,...).</li> <li>Lenguajes declarativos. Son lenguajes que se centran en el qu\u00e9 queremos resolver en lugar de en c\u00f3mo resolverlo. El m\u00e1s conocido de ellos es el SQL, lenguaje de consulta de Bases de datos.</li> <li>Lenguajes funcionales. Definen funciones que nos responden a trav\u00e9s de una serie de argumentos. Son lenguajes que usan expresiones matem\u00e1ticas. El m\u00e1s conocido de ellos es el LISP.</li> <li>Lenguajes l\u00f3gicos. Lenguajes utilizados para resolver expresiones l\u00f3gicas. Utilizan la l\u00f3gica para producir resultados. El m\u00e1s conocido es el PROLOG.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#interpretes-y-compiladores","title":"Interpretes y compiladores","text":"<p>A la hora de convertir un programa en c\u00f3digo m\u00e1quina, se pueden utilizar dos tipos de software: int\u00e9rpretes y compiladores.</p>"},{"location":"bloque_i/tema_1/page-1/#interpretes","title":"Int\u00e9rpretes","text":"<p>Se convierte cada l\u00ednea a c\u00f3digo m\u00e1quina y se ejecuta ese c\u00f3digo m\u00e1quina antes de convertir la siguiente l\u00ednea. De esa forma si las dos primeras l\u00edneas son correctas y la tercera tiene un fallo de sintaxis, ver\u00edamos el resultado de las dos primeras l\u00edneas y al llegar a la tercera se nos notificar\u00eda el fallo y finalizar\u00eda la ejecuci\u00f3n. El int\u00e9rprete hace una simulaci\u00f3n de modo que parece que la m\u00e1quina entiende directamente las instrucciones del lenguaje, pareciendo que ejecuta cada instrucci\u00f3n (como si fuese c\u00f3digo m\u00e1quina directo). El BASIC era un lenguaje interpretado, se traduc\u00eda l\u00ednea a l\u00ednea. Hoy en d\u00eda la mayor\u00eda de los lenguajes integrados en p\u00e1ginas web son interpretados, la raz\u00f3n es que como la descarga de Internet es lenta, es mejor que las instrucciones se vayan traduciendo seg\u00fan van llegando en lugar de cargar todas en el ordenador. Por eso lenguajes como JavaScript son interpretados.</p> <p>Un programa que se convierte a c\u00f3digo m\u00e1quina mediante un int\u00e9rprete sigue estos pasos:</p> <ol> <li>Lee la primera instrucci\u00f3n</li> <li>Comprueba si es correcta</li> <li>Convierte esa instrucci\u00f3n al c\u00f3digo m\u00e1quina equivalente</li> <li>Lee la siguiente instrucci\u00f3n</li> <li>Vuelve al paso 2 hasta terminar con todas las instrucciones</li> </ol> <p>Ventajas de los int\u00e9rpretes</p> <ul> <li>Se tarda menos en crear el primer c\u00f3digo m\u00e1quina. El programa se ejecuta antes.</li> <li>No hace falta cargar todas las l\u00edneas para empezar a ver resultados (lo que hace que sea una t\u00e9cnica id\u00f3nea para programas que se cargan desde Internet)</li> </ul> <p>Desventajas de los int\u00e9rpretes:</p> <ul> <li>El c\u00f3digo m\u00e1quina producido es peor ya que no se optimiza al valorar una sola l\u00ednea cada vez. El c\u00f3digo optimizado permite estudiar varias l\u00edneas a la vez para producir el mejor c\u00f3digo m\u00e1quina posible, por ello no es posible mediante el uso de int\u00e9rpretes.</li> <li>Todos los errores son errores en tiempo de ejecuci\u00f3n, no se pueden detectar antes de lanzar el programa. Esto hace que la depuraci\u00f3n de los errores sea m\u00e1s compleja.</li> <li>El c\u00f3digo m\u00e1quina resultante gasta m\u00e1s espacio.</li> <li>Hay errores dif\u00edcilmente detectables, ya que para que los errores se produzcan, las l\u00edneas de errores hay que ejecutarlas. Si la l\u00ednea es condicional, hasta que no probemos todas las posibilidades del programa, no sabremos todos los errores de sintaxis cometidos.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#compiladores","title":"Compiladores","text":"<p>Se trata de software que traduce las instrucciones de un lenguaje de programaci\u00f3n de alto nivel a c\u00f3digo m\u00e1quina. La diferencia con los int\u00e9rpretes reside en que se analizan todas las l\u00edneas antes de empezar la traducci\u00f3n. Durante muchos a\u00f1os, los lenguajes potentes han sido compilados. El uso masivo de Internet ha propiciado que esta t\u00e9cnica a veces no sea adecuada y haya lenguajes modernos interpretados o semi-interpretados, mitad se compila hacia un c\u00f3digo intermedio y luego se interpreta l\u00ednea a l\u00ednea (esta t\u00e9cnica la siguen Java y los lenguajes de la plataforma .NET de Microsoft).</p> <p>Ventajas de los compiladores:</p> <ul> <li>Se detectan errores antes de ejecutar el programa (errores de compilaci\u00f3n).</li> <li>El c\u00f3digo m\u00e1quina generado es m\u00e1s r\u00e1pido (ya que se optimiza).</li> <li>Es m\u00e1s f\u00e1cil hacer procesos de depuraci\u00f3n de c\u00f3digo.</li> </ul> <p>Desventajas de los compiladores:</p> <ul> <li>El proceso de compilaci\u00f3n del c\u00f3digo es lento.</li> <li>No es \u00fatil para ejecutar programas desde Internet ya que hay que descargar todo el programa antes de traducirle, lo que ralentiza mucho su uso.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#tipos-de-paradigmas-de-programacion","title":"Tipos de paradigmas de programaci\u00f3n","text":"<p>Un paradigma de programaci\u00f3n es un modelo b\u00e1sico de dise\u00f1o y desarrollo de programas que permite generar programas con un conjunto de normas espec\u00edficas.</p> <p>En general, la mayor\u00eda de paradigmas son variantes de los dos tipos principales de programaci\u00f3n, imperativa y declarativa. En la programaci\u00f3n imperativa se describe paso a paso un conjunto de instrucciones que deben ejecutarse para variar el estado del programa y hallar la soluci\u00f3n, es decir, un algoritmo en el que se describen los pasos necesarios para solucionar el problema.</p> <p>En la programaci\u00f3n declarativa las sentencias que se utilizan lo que hacen es describir el problema que se quiere solucionar; se programa diciendo lo que se quiere resolver pero no las instrucciones necesarias para solucionarlo. Esto \u00faltimo se realizar\u00e1 mediante mecanismos internos de deducci\u00f3n de informaci\u00f3n a partir de la descripci\u00f3n realizada.</p> <p>A continuaci\u00f3n se describen algunas de las distintas variantes de paradigmas de programaci\u00f3n:</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-imperativa","title":"Programaci\u00f3n imperativa","text":"<p>Es uno de los paradigmas de programaci\u00f3n de computadoras m\u00e1s utilizados. Bajo este paradigma, la programaci\u00f3n se describe en t\u00e9rminos del estado del programa y de sentencias que cambian dicho estado. Java es un lenguaje imperativo, lo que implica que un programa Java est\u00e1 compuesto por una secuencia de instrucciones, que son ejecutadas en el mismo orden en el que se escriben, de manera que al ejecutarla se produce cambios en el estado del programa.</p> <p>Dentro de esta categor\u00eda se engloban la programaci\u00f3n estructurada y la programaci\u00f3n orientada a objetos, las cuales han permitido mejorar la mantenibilidad y la calidad de los programas imperativos.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-estructurada","title":"Programaci\u00f3n estructurada","text":"<p>Est\u00e1 orientada a mejorar la claridad, calidad y tiempo de desarrollo de un programa de computadora recurriendo \u00fanicamente a subrutinas y tres estructuras b\u00e1sicas: secuencia, selecci\u00f3n (if y switch) e iteraci\u00f3n(bucles for y while).</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-orientada-a-objetos","title":"Programaci\u00f3n orientada a objetos","text":"<p>La programaci\u00f3n orientada a objetos encapsula elementos denominados objetos.</p> <p>Bajo este paradigma, la programaci\u00f3n se describe como una serie de objetos independientes que se comunican entre s\u00ed. Java es un lenguaje orientado a objetos.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-orientada-a-eventos","title":"Programaci\u00f3n orientada a eventos","text":"<p>La programaci\u00f3n dirigida por eventos es un paradigma de programaci\u00f3n en el que tanto la estructura como la ejecuci\u00f3n de los programas van determinados por los sucesos que ocurran en el sistema, definidos por el usuario o lo que sea que est\u00e9 accionando el programa.</p> <p>Mientras que en la programaci\u00f3n estructurada es el programador el que define cu\u00e1l va a ser el flujo del programa, en la programaci\u00f3n dirigida por eventos ser\u00e1 el propio usuario, o lo que sea que est\u00e9 accionando el programa, el que dirija el flujo del programa. Aunque en la programaci\u00f3n estructurada puede haber intervenci\u00f3n de un agente externo al programa, estas intervenciones ocurrir\u00e1n cuando el programador lo haya determinado, y no en cualquier momento como puede ser en el caso de la programaci\u00f3n dirigida por eventos.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-declarativa","title":"Programaci\u00f3n declarativa","text":"<p>Est\u00e1 basada en describir el problema declarando propiedades y reglas que deben cumplirse, en lugar de instrucciones. La soluci\u00f3n es obtenida mediante mecanismos internos de control, sin especificar exactamente c\u00f3mo encontrarla (tan solo se le indica a la computadora qu\u00e9 es lo que se desea obtener o qu\u00e9 es lo que se est\u00e1 buscando). Los lenguajes declarativos tienen la ventaja de ser razonados matem\u00e1ticamente, lo que permite el uso de mecanismos matem\u00e1ticos para optimizar el rendimiento de los programas.</p> <p>Dentro de esta categor\u00eda se engloban la programaci\u00f3n funcional y la programaci\u00f3n l\u00f3gica.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-funcional","title":"Programaci\u00f3n funcional","text":"<p>Es un paradigma de programaci\u00f3n en el que el resultado de un programa deriva de la aplicaci\u00f3n de distintas funciones a la entrada, sin cambiar el estado interno del programa. En la programaci\u00f3n funcional los bloques principales de construcci\u00f3n de nuestros programas son las funciones, y no los objetos.</p> <p>Al aplicar programaci\u00f3n funcional se produce normalmente un c\u00f3digo m\u00e1s corto y m\u00e1s sencillo de entender que aplicando programaci\u00f3n imperativa.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-logica","title":"Programaci\u00f3n l\u00f3gica","text":"<p>Es un paradigma de programaci\u00f3n basado en la definici\u00f3n de relaciones l\u00f3gicas.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-multiparadigma","title":"Programaci\u00f3n multiparadigma","text":"<p>Es el uso de dos o m\u00e1s paradigmas dentro de un programa. Por ejemplo, Java es imperativo y orientado a objetos</p>"},{"location":"bloque_i/tema_1/page-10/","title":"10 N\u00fameros aleatorios","text":""},{"location":"bloque_i/tema_1/page-10/#la-clase-random","title":"La clase Random","text":"<p>En java disponemos de la clase Random para generar n\u00fameros aleatorios. La clase dispone de dos constructores, uno sin par\u00e1metros y otro con un par\u00e1metro llamado semilla (seed). Aunque no  podemos  predecir  que  n\u00fameros  se  generar\u00e1n  con  una  semilla  particular,  podemos  sin embargo, duplicar una serie de n\u00fameros aleatorios usando la misma semilla. Es decir, cada vez que  creamos  un  objeto  de  la  clase  Random  con  la  misma  semilla  obtendremos  la  misma secuencia de n\u00fameros aleatorios. Podemos cambiar la semilla de los n\u00fameros aleatorios en cualquier momento utilizando el m\u00e9todo setSeed.</p>"},{"location":"bloque_i/tema_1/page-10/#metodos","title":"M\u00e9todos","text":"<p>Algunos m\u00e9todos de la clase Random para generar n\u00fameros aleatorios:</p> <ul> <li>nextInt(): genera un n\u00famero aleatorio entero de tipo int</li> <li>nextInt(int n): genera un n\u00famero aleatorio entero de tipo int entre 0(incluido) y n(excluido)</li> <li>nextLong(): genera un n\u00famero aleatorio entero de tipo long</li> <li>nextFloat(): genera un n\u00famero aleatorio de tipo float entre 0.0(incluido) y 1.0(excluido)</li> <li>nextDouble():  genera  un  n\u00famero  aleatorio  de  tipo  double  entre  0.0(incluido)  y 1.0(excluido)</li> <li>nextBoolean(): genera un booleano aleatorio</li> </ul>"},{"location":"bloque_i/tema_1/page-10/#numeros-aleatorios-en-un-rango","title":"N\u00fameros aleatorios en un rango","text":"<p>Para generar n\u00fameros aleatorios enteros comprendidos entre un rango de dos n\u00fameros enteros min y max, hay que utilizar la siguiente f\u00f3rmula:</p> <p><code>nextInt(max - min + 1) + min</code></p> <p>Por  ejemplo,  si  queremos  generar  un  n\u00famero  aleatorio  entre  5  y  10:  nextInt(10-5+1)+5  \u2192 nextInt(6)+5</p>"},{"location":"bloque_i/tema_1/page-10/#ejemplo-de-uso","title":"Ejemplo de uso","text":"<p>En el siguiente ejemplo, se puede observar en la ejecuci\u00f3n que utilizando el Random con semilla siempre se generan los mismos n\u00fameros</p> <pre><code>public class RandomClass {\npublic static void main(String[] args) {\nRandom random = new Random(); // Sin semilla\nRandom randomSeed = new Random(3816); // Con semilla. Siempre se generan los mimos n\u00fameros\nSystem.out.println(random.nextBoolean());\nSystem.out.println(random.nextInt());\nSystem.out.println(random.nextLong());\nSystem.out.println(random.nextFloat());\nSystem.out.println(random.nextDouble());\nSystem.out.println(random.nextInt(6) + 5); // Genera un n\u00famero aleatorio entre 5 y 10\nSystem.out.println(randomSeed.nextBoolean());\nSystem.out.println(randomSeed.nextInt());\nSystem.out.println(randomSeed.nextLong());\nSystem.out.println(randomSeed.nextFloat());\nSystem.out.println(randomSeed.nextDouble());\nSystem.out.println(randomSeed.nextInt(6) + 5); // Genera un n\u00famero aleatorio entre 5 y 10\n}\n}\n</code></pre> Ejercicio <p>Sacar aleatoriamente lo siguiente:</p> <ul> <li>La cara de una moneda</li> <li>El lanzamiento de un dado</li> <li>Un n\u00famero entre 34 y 68 ambos incluidos</li> <li>Un n\u00famero decimal</li> <li>Un d\u00eda de la semana y mostrar si es fin de semana o no</li> <li>Un mes del a\u00f1o y mostrar si es verano o no (entenderemos como veranos los meses de julio y agosto)</li> </ul>"},{"location":"bloque_i/tema_1/page-11/","title":"11 Lectura por teclado","text":""},{"location":"bloque_i/tema_1/page-11/#la-clase-system","title":"La clase System","text":"<p>Las aplicaciones pueden necesitar acceder a los recursos del sistema, como por ejemplo, a los dispositivos de entrada/salida est\u00e1ndar para recoger datos desde el teclado o mostrar datos por pantalla. En Java, la entrada por teclado y la salida de informaci\u00f3n por pantalla se hace mediante la clase System del paquete java.lang de la biblioteca de clases de Java. Dicha clase contiene el atributo in para el teclado y el atributo out para la pantalla.</p> <p>Dichos atributos son est\u00e1ticos por lo que se accede a ellos con el nombre de la clase System:</p> <ul> <li><code>System.in</code> Entrada est\u00e1ndar: teclado.</li> <li><code>System.out</code> Salida est\u00e1ndar: pantalla.</li> </ul>"},{"location":"bloque_i/tema_1/page-11/#la-clase-scanner","title":"La clase Scanner","text":"<p>El  kit  de  desarrollo  de  Java,  a  partir  de  su  versi\u00f3n  1.5,  incorpora  la  clase  Scanner  del  paquete java.util la cual posee m\u00e9todos para leer valores de entrada que pueden venir de varias fuentes, como por ejemplo, de datos introducidos por teclado o datos almacenados en un archivo. Para leer datos desde el teclado, tenemos que pasarle el  <code>System.in</code>  al constructor del Scanner:</p> <pre><code>Scanner keyboard = new Scanner (System.in);\n</code></pre> <p>Veamos algunos m\u00e9todos de esta clase:</p> <ul> <li>nextByte, nextShort, nextInt y nextLong: para leer datos de tipo entero.</li> <li>nextFloat y nextDouble: para leer n\u00fameros decimales.</li> <li>next: lee una palabra, es decir, hasta que encuentre un espacio.</li> <li>nextLine: lee una l\u00ednea completa, es decir, hasta que encuentre un salto de l\u00ednea (\\n).</li> </ul> <p>Por ejemplo, para leer un dato de tipo int ser\u00eda:</p> <pre><code>int i = keyboard.nextInt ();\n</code></pre> <p>O bien esta otra instrucci\u00f3n para leer una l\u00ednea completa:</p> <pre><code>String string = keyboard.nextLine();\n</code></pre> <p>He aqu\u00ed un ejemplo de entrada de teclado con la clase Scanner:</p> <pre><code>import java.util.Scanner;\npublic class ScannerClass {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString string;\nint i;\nfloat f;\nboolean b;\nstring = keyboard.nextLine();\nSystem.out.println(string);\ni = keyboard.nextInt();\nSystem.out.println(i);\nb = keyboard.nextBoolean();\nSystem.out.println(b);\nf = keyboard.nextFloat();//(1)!\nSystem.out.println(f);\n}\n}\n</code></pre> <ol> <li>El s\u00edmbolo separador de decimales ser\u00e1 la coma si nuestro idioma por defecto del sistema operativo est\u00e1 configurado en espa\u00f1ol.</li> </ol> <p>El  s\u00edmbolo  separador  de  decimales  ser\u00e1  la  coma  si  nuestro  idioma  por  defecto  del  sistema operativo  est\u00e1  configurado  en  espa\u00f1ol.  Si  deseamos  que  el  separador  decimal  sea  el  punto  en lugar  de  la  coma,  entonces  tendremos  que  a\u00f1adir <code>useLocale(Locale.US)</code>   cuando  creemos  el Scanner:</p> <pre><code>import java.util.Locale;\nimport java.util.Scanner;\npublic class ScannerClassLocale {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in).useLocale(Locale.US);\nfloat f;\n// Debido al useLocale(Locale.US), el s\u00edmbolo separador de decimales ser\u00e1 el punto\nf = keyboard.nextFloat();\nSystem.out.println(f);\n}\n}\n</code></pre> <p>Veamos un ejemplo de lectura de palabras con next():</p> <pre><code>import java.util.Scanner;\npublic class Next {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString string1, string2, string3;\nSystem.out.println(\"Introduzca 3 palabras separadas por espacio: \");\nstring1 = keyboard.next();\nstring2 = keyboard.next();\nstring3 = keyboard.next();\nSystem.out.println(\"Primera palabra: \" + string1);\nSystem.out.println(\"Segunda palabra: \" + string2);\nSystem.out.println(\"Tercera palabra: \" + string3);\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_1/page-11/#buffer-de-datos","title":"Buffer de datos","text":"<p>Un buffer de datos es un espacio de memoria donde se almacenan datos de manera temporal mientras  son  transferidos  o  procesados.  Los  sistemas  de  entrada  de  teclado  poseen  un  buffer que almacena las teclas presionadas.</p> <p>Cuando  introducimos  un  dato  por  teclado,  para  indicar  que  hemos  finalizado  la  introducci\u00f3n pulsamos la tecla Enter. Cuando se ejecuta cualquier next con la clase Scanner(excepto nextLine), se coge el dato correspondiente del buffer pero el Enter se queda guardado como un <code>\\n</code> (salto de l\u00ednea) en el buffer. Si a continuaci\u00f3n se ejecuta un nextLine, lee hasta el salto de l\u00ednea del buffer, es  decir,  lee  cadena  vac\u00eda  y  ya  no  le  da  opci\u00f3n  al  usuario  de  introducir  la  cadena.  Una  posible soluci\u00f3n  ser\u00eda  limpiar  el  buffer  con  un  nextLine  y  luego  realizar  otro  nextLine  para  pedirle  la cadena al usuario.</p> <pre><code>import java.util.Scanner;\npublic class NextLine {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString string;\nint number;\nboolean b;\n// El nextLine() toma el salto de l\u00ednea dejado por cualquier otro next\nSystem.out.println(\"Introduzca un n\u00famero entero: \");\nnumber = keyboard.nextInt();\nSystem.out.println(number);\nSystem.out.println(\"Introduzca una cadena: \");\nstring = keyboard.nextLine();\nSystem.out.println(string);\nSystem.out.println(\"Introduzca un booleano: \");\nb = keyboard.nextBoolean();\nSystem.out.println(b);\nSystem.out.println(\"Introduzca una cadena: \");\nstring = keyboard.nextLine();\nSystem.out.println(string);\nSystem.out.println(\"Introduzca una cadena con next: \");\nstring = keyboard.next();\nSystem.out.println(string);\nSystem.out.println(\"Introduzca una cadena: \");\nstring = keyboard.nextLine();\nSystem.out.println(string);\n// Soluci\u00f3n: poner un nextLine que coja el salto de l\u00ednea. A esto se le conoce\n// como limpiar el buffer\nSystem.out.println(\"Vamos a solucionar el problema.\\nIntroduzca un n\u00famero entero: \");\nnumber = keyboard.nextInt();\nSystem.out.println(number);\nSystem.out.println(\"Introduce una cadena: \");\nkeyboard.nextLine(); // Limpieza del buffer\nstring = keyboard.nextLine();\nSystem.out.println(string);\n}\n}\n</code></pre> <p>Otra soluci\u00f3n ser\u00eda indicarle al objeto scanner que como delimitador use el \\n ya que por defecto es el car\u00e1cter espacio. De esta forma, cuando utilicemos next(), leer\u00e1 todos los caracteres hasta el siguiente \\n. El \u00fanico inconveniente de esto es que no podremos leer palabra a palabra.</p> <pre><code>public class NextDelimiter {\npublic static void main(String[] args) {\nString delimiterWindows = \"\\\\r\\\\n\";\nString delimiterLinuxMac = \"\\\\n\";\nScanner keyboard = new Scanner(System.in).useDelimiter(delimiterWindows);\nString string;\nint number;\nSystem.out.println(\"Introduzca un n\u00famero entero: \");\nnumber = keyboard.nextInt();\nSystem.out.println(number);\nSystem.out.println(\"Introduzca una cadena: \");\nstring = keyboard.next();\nSystem.out.println(string);\n}\n}\n</code></pre> Ejercicio <p>Solic\u00edtale al usuario los siguientes datos. A continuaci\u00f3n, mu\u00e9stralos por consola:</p> <ol> <li>Nombre</li> <li>Apellidos</li> <li>Edad</li> <li>Direcci\u00f3n<ul> <li>Calle</li> <li>N\u00famero</li> <li>C\u00f3digo postal</li> <li>Provincia</li> </ul> </li> <li>Si es estudiante (boolean)</li> <li>Altura (con decimales)</li> </ol>"},{"location":"bloque_i/tema_1/page-12/","title":"12 Escritura en pantalla","text":""},{"location":"bloque_i/tema_1/page-12/#introduccion","title":"Introducci\u00f3n","text":"<p>La salida por pantalla en Java se hace con el objeto System.out. Este objeto es una instancia de la clase  PrintStream  del  paquete  java.lang.  Si  miramos  la  API  de  PrintStream  obtendremos  la variedad de m\u00e9todos para mostrar datos por pantalla, algunos de estos son:</p> <ul> <li>print y println: muestran los datos por pantalla. Est\u00e1n sobrecargados para varios tipos de datos. El println inserta un salto de l\u00ednea despu\u00e9s de mostrar el dato.</li> <li>printf: escribe una cadena de texto utilizando formato.</li> </ul> <p>En print y println, cuando queramos escribir un mensaje y el valor de una variable debemos utilizar el operador de  <code>concatenaci\u00f3n</code>  de cadenas (+), por ejemplo:</p> <pre><code>System.out.println(\"Bienvenido, \" + nombre);\n</code></pre> <p>Escribe el mensaje de \"Bienvenido, Carlos\", si el valor de la variable nombre es Carlos. En print y println, todas las variables que se muestran se consideran como cadenas de texto sin formato,por ejemplo, no ser\u00eda posible indicar que escriba un n\u00famero decimal con dos cifras decimales.</p> <p>Para ello se utiliza printf</p> Ejercicio 1 <p>Muestra en consola lo siguiente, exactamente igual, utilizando <code>System.out.print</code></p> <pre><code>La letra n\u00famero \"101\" es la:    'e'\nEl car\u00e1cter '\\' es:\n        \"especial\"\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#el-metodo-printf","title":"El m\u00e9todo printf","text":"<p><code>printf(String format, Object... args)</code></p> <p>En <code>String format</code> se coloca la cadena a la cual se le quiere dar formato. Utiliza unos c\u00f3digos de conversi\u00f3n para indicar del contenido a mostrar de qu\u00e9 tipo es. Estos c\u00f3digos se caracterizan porque llevan delante el s\u00edmbolo <code>%</code>, algunos de ellos son:</p> <ul> <li><code>%c</code>: car\u00e1cter.</li> <li><code>%s</code>: cadena de texto.</li> <li><code>%d</code>: entero.</li> <li><code>%f</code>: n\u00famero decimal.</li> </ul> <p>Tambi\u00e9n se pueden usar las secuencias de escape que van precedidas de <code>\\</code>, como por ejemplo <code>\\n</code> y <code>\\t</code>, incluso el salto de l\u00ednea <code>\\n</code> tambi\u00e9n se puede especificar como <code>%n</code> .</p> <p>En <code>Object... args</code> se colocan los valores correspondientes. El primero corresponde al primer %, el segundo al segundo, y as\u00ed sucesivamente. Dichos valores tienen que ser expresiones que devuelvan resultados con tipos compatibles a los % que correspondan.</p> <p>Ejemplos:</p> <pre><code>System.out.printf(\"El car\u00e1cter es %c\", 'a');\n</code></pre> <p>Nos mostrar\u00eda por pantalla: <code>El car\u00e1cter es a</code></p> <pre><code>int integer = 10;\nSystem.out.printf(\"%d\", integer);\n</code></pre> <p>Salida por pantalla: <code>10</code></p> <p>Si queremos mostrar el s\u00edmbolo % se utiliza otro % delante:</p> <pre><code>System.out.printf(\"El 20%% de %d es %d\\n\", 200, 200*20/100);\n</code></pre> <p>Salida por pantalla: <code>El 20% de 200 es 40</code></p>"},{"location":"bloque_i/tema_1/page-12/#decimales","title":"Decimales","text":"<p>Para <code>%f</code> podemos especificar el n\u00famero de decimales escribiendo <code>.n</code> entre % y f, siendo n el n\u00famero de decimales:</p> <pre><code>System.out.printf(\"%.2f\", 12.3698);\n</code></pre> <p>La salida por pantalla es <code>12,37</code> ya que se realiza un redondeo para mostrar los decimales indicados.</p>"},{"location":"bloque_i/tema_1/page-12/#numeros-con-signo","title":"N\u00fameros con signo","text":"<p>Para mostrar n\u00fameros con signo se utiliza el s\u00edmbolo + entre % y d si es un n\u00famero entero o entre % y f si es un n\u00famero decimal.</p> <pre><code>int integer = 10;\nSystem.out.printf(\"%+d\", integer);\n</code></pre> <p>Salida por pantalla: <code>+10</code></p> <pre><code>int integer = -10;\nSystem.out.printf(\"%-d\", integer);\n</code></pre> <p>Salida por pantalla: <code>-10</code></p> <pre><code>double decimal = 3.968;\nSystem.out.printf(\"%+.2f\", decimal);\n</code></pre> <p>Salida por pantalla: <code>+3.97</code></p> <pre><code>double decimal = -3.968;\nSystem.out.printf(\"%+f\", decimal);\n</code></pre> <p>Salida por pantalla: <code>-3.968000</code></p>"},{"location":"bloque_i/tema_1/page-12/#mostrar-mas-de-un-valor","title":"Mostrar m\u00e1s de un valor","text":"<p>Utilizaremos tantos % como valores vamos a formatear. Despu\u00e9s de la primera coma, se van poniendo los valores separados por comas, el primero corresponde al primer %, el segundo al segundo %, y as\u00ed sucesivamente.</p> <pre><code>double decimal = 1.25036;\nint integer = 10;\nSystem.out.printf(\"decimal = %.2f integer = %d\", decimal, integer);\n</code></pre> <p>Salida por pantalla: <code>decimal = 1,25 integer = 10</code></p> <p>Tambi\u00e9n podemos cambiar el orden por defecto de correspondencia entre los valores y los % con el s\u00edmbolo <code>$</code>. Ejemplo: <code>%2$d</code> significa que al n\u00famero entero (%d) se le va a asignar el segundo valor (<code>2$</code>).</p> <pre><code>System.out.printf(\"decimal1 = %2$.2f integer = %1$d decimal2 = %2$+.1f\", integer, decimal);\n</code></pre> <p>Salida por pantalla: <code>decimal1 = 1,25 integer = 10 decimal2 = +1,3</code></p> <p>Ejemplo: mostrar el n\u00fameros 123.4567 y su cuadrado ambos con dos decimales:</p> <pre><code>double decimal = 123.4567;\nSystem.out.printf(\"El cuadrado de %.2f es %.2f\", decimal, decimal * decimal)\n</code></pre> <p>Salida por pantalla: <code>El cuadrado de 123,46 es 15241,56</code></p>"},{"location":"bloque_i/tema_1/page-12/#especificar-un-ancho-de-campo","title":"Especificar un ancho de campo","text":"<p>printf permite tambi\u00e9n mostrar valores con un ancho de campo determinado. Por ejemplo, si queremos mostrar un n\u00famero entero en un ancho de 10 caracteres, escribimos 10 enter % y d:</p> EJEMPLOSALIDA <pre><code>int integer = 1234;\nSystem.out.printf(\"Ancho de 10 caracteres con un entero: %10d\", integer);\n</code></pre> <pre><code>Ancho de 10 caracteres con un entero:      1234\n</code></pre> <p>Otro ejemplo con n\u00fameros decimales: mostrar con dos decimales, con signo y en un ancho de campo de 10 caracteres:</p> EJEMPLOSALIDA <pre><code>double decimal = 1.25036;\nSystem.out.printf(\"Ancho de 10 caracteres con un decimal: %+10.2f\", decimal);\n</code></pre> <pre><code>Ancho de 10 caracteres con un decimal:      +1,25\n</code></pre> <p>En el ancho de 10 caracteres, se cuentan adem\u00e1s de las cifras del n\u00famero, la coma decimal, el signo si lo lleva. En este caso, el n\u00famero ocupa un espacio de 5 caracteres (3 cifras, la coma y el signo), por lo tanto, se a\u00f1aden 5 espacios en blanco al principio para completar el tama\u00f1o de 10.</p> <p>Para completar el ancho de caracteres con ceros en lugar de con espacios, se coloca un 0 delante del ancho de caracteres:</p> EJEMPLOSALIDA <pre><code>double decimal = 1.25036;\nSystem.out.printf(\"Ancho de caracteres rellenado con ceros: %+010.2f\", decimal);\n</code></pre> <pre><code>Ancho de caracteres rellenado con ceros: +000001,25\n</code></pre> <p>Veamos un ejemplo con cadenas: mostrar la cadena \"Manolo\" con un ancho de 10 caracteres:</p> EJEMPLOSALIDA <pre><code>System.out.printf(\"Ancho de caracteres con cadenas:%10s\", \"Manolo\");\n</code></pre> <pre><code>Ancho de caracteres con cadenas:    Manolo\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#alineacion-a-la-izquierda","title":"Alineaci\u00f3n a la izquierda","text":"<p>Con el signo <code>-</code> se indica alineaci\u00f3n a la izquierda.</p> <p>Ejemplo: mostrar un decimal con un ancho de 9 caracteres, con tres decimales y alineado a la izquierda:</p> EJEMPLOSALIDA <pre><code>double decimal = 58.965874f;\nSystem.out.printf(\"decimal=%-9.3fQue ocupe 9 caracteres, con tres decimales y alineado a la izquierda\", decimal);\n</code></pre> <pre><code>decimal=58.966   Que ocupe 9 caracteres, con tres decimales y alineado a la izquierda\n</code></pre> <p>Ejemplo con cadenas: mostrar la cadena \"Manolo\" con un ancho de 10 caracteres y alineada a la izquierda:</p> EJEMPLOSALIDA <pre><code>System.out.printf(\"%-10s:Alineaci\u00f3n a la izquierda con cadenas\", \"Manolo\");\n</code></pre> <pre><code>Manolo    :Alineaci\u00f3n a la izquierda con cadenas\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#ejemplos","title":"Ejemplos","text":"<p>He aqu\u00ed todos los ejemplos de printf vistos en este apartado:</p> <pre><code>public class Printf {\npublic static void main(String[] args) {\ndouble decimal;\nint integer;\nSystem.out.printf(\"El car\u00e1cter es %c%n\", 'a');\ninteger = 10;\nSystem.out.printf(\"%d\\n\", integer);\nSystem.out.printf(\"El 20%% de %d es %d\\n\", 200, 200 * 20 / 100);\nSystem.out.printf(\"%.2f\\n\", 12.3698);\ndecimal = 1.25036;\nSystem.out.printf(\"%.3f\\n\", decimal);\nSystem.out.printf(\"%+d\\n\", integer);\ninteger = -10;\nSystem.out.printf(\"%+d\\n\", integer);\ndecimal = 3.968;\nSystem.out.printf(\"%+.2f\\n\", decimal);\ndecimal = -3.968;\nSystem.out.printf(\"%+f\\n\", decimal);\ndecimal = 1.25036;\ninteger = 10;\nSystem.out.printf(\"decimal = %.2f integer = %d\\n\", decimal, integer);\nSystem.out.printf(\"decimal1 = %2$.2f integer = %1$d decimal2 = %2$+.1f\\n\", integer, decimal);\ndecimal = 123.4567;\nSystem.out.printf(\"El cuadrado de %.2f es %.2f\\n\", decimal, decimal * decimal);\ninteger = 1234;\nSystem.out.printf(\"Ancho de 10 caracteres con un entero:%10d\\n\", integer);\ndecimal = 1.25036;\nSystem.out.printf(\"Ancho de 10 caracteres con un decimal:%+10.2f\\n\", decimal);\ndecimal = 1.25036;\nSystem.out.printf(\"Ancho de caracteres rellenado con ceros:%+010.2f\\n\", decimal);\nSystem.out.printf(\"Ancho de caracteres con cadenas:%10s\\n\", \"Manolo\");\ndecimal = 58.965874f;\nSystem.out.printf(\"decimal=%-9.3fQue ocupe 9 caracteres, con tres decimales y alineado a la izquierda\\n\", decimal);\nSystem.out.printf(\"%-10s:Alineaci\u00f3n a la izquierda con cadenas\\n\", \"Manolo\");\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#ejemplo-de-scanner-y-printf","title":"Ejemplo de Scanner y printf","text":"<p>He aqu\u00ed un ejemplo de entrada/salida de datos utilizando Scanner y printf.</p> <pre><code>import java.util.Scanner;\npublic class InputOutput {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString name;\nint age;\nfloat salary;\n// Entrada de datos\nSystem.out.print(\"Nombre: \");\nname = keyboard.nextLine();\nSystem.out.print(\"Edad: \");\nage = keyboard.nextInt();\nSystem.out.print(\"Salario: \");\nsalary = keyboard.nextFloat();\n// Salida de datos\nSystem.out.printf(\"\\nBienvenido: %s\\n\", name);\nSystem.out.printf(\"Tienes: %d a\u00f1os\\n\", age);\nSystem.out.printf(\"Tu salario es: %.2f euros\\n\", salary);\n}\n}\n</code></pre> Ejercicio 2     <p>Utilizando las siguientes variables:</p> <pre><code>int x = 10;\nint y = -10;\nfloat n = 13.269834f;\nString cad = \"Ana\";\n</code></pre> <p>Muestra en consola el siguiente resultado, exactamente igual, utilizando <code>System.out.printf</code>, sin utilizar espacios ni tabulaciones en la cadena de formato y utilizando solamente las variables indicadas anteriormente.</p> <pre><code>10\n+10\n-10\n13,27\n  +13,2698\n  13,26983\n+00013,270\nn=13,27   x=10\n      AnaAna  Ana\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#colores","title":"Colores","text":"<p>Para poder utilizar colores en la escritura de datos por pantalla, hay que comprobar si es necesario instalar alg\u00fan plugin en el IDE.</p> <p>Las secuencias de escape ANSI permiten enviar informaci\u00f3n de control a la consola para cambiar los  atributos  del  texto  representado.  Solo  debemos  anteponer  a  la  cadena  que  queremos mostrar en color el c\u00f3digo de escape ANSI referente al color.</p> <p>Cuando aplicamos un color a la salida por consola, el resto de salida por consola seguir\u00e1 saliendo de dicho color hasta que se especifique otro color de salida o finalicemos el texto con el c\u00f3digo RESET, en cuyo caso se vuelve al color por defecto.</p> <pre><code>public class Colors {\npublic static final String RESET = \"\\u001B[0m\";\npublic static final String BLACK = \"\\u001B[30m\";\npublic static final String RED = \"\\u001B[31m\";\npublic static final String GREEN = \"\\u001B[32m\";\npublic static final String YELLOW = \"\\u001B[33m\";\npublic static final String BLUE = \"\\u001B[34m\";\npublic static final String PURPLE = \"\\u001B[35m\";\npublic static final String CYAN = \"\\u001B[36m\";\npublic static final String WHITE = \"\\u001B[37m\";\npublic static final String BLACK_BACKGROUND = \"\\u001B[40m\";\npublic static final String RED_BACKGROUND = \"\\u001B[41m\";\npublic static final String GREEN_BACKGROUND = \"\\u001B[42m\";\npublic static final String YELLOW_BACKGROUND = \"\\u001B[43m\";\npublic static final String BLUE_BACKGROUND = \"\\u001B[44m\";\npublic static final String PURPLE_BACKGROUND = \"\\u001B[45m\";\npublic static final String CYAN_BACKGROUND = \"\\u001B[46m\";\npublic static final String WHITE_BACKGROUND = \"\\u001B[47m\";\npublic static final String BOLD = \"\\u001B[1m\";// Negrita\npublic static final String UNDERLINE = \"\\u001B[4m\";// Subrayado\npublic static final String REVERSED = \"\\u001B[7m\";// Invierte los colores del texto y del fondo\n}\n</code></pre> <pre><code>import static examples.tema_01.Colors.*;\npublic class ColorUse {\npublic static void main(String[] args) {\nSystem.out.println(RED + \"Este texto es de color rojo\" + RESET);\nSystem.out.println(\"Volvemos al color por defecto\");\nSystem.out.println(GREEN + \"...y ahora es verde\");\nSystem.out.println(PURPLE_BACKGROUND + \"Fondo morado\");\nSystem.out.println(CYAN + WHITE_BACKGROUND + \"Fondo blanco con texto celeste\");\nSystem.out.println(CYAN + WHITE_BACKGROUND + BOLD + \"Fondo blanco con texto celeste en negrita\");\nSystem.out.println(CYAN + WHITE_BACKGROUND + UNDERLINE + \"Fondo blanco con texto celeste subrayado\");\nSystem.out.printf(\"%s\\n\", YELLOW + RED_BACKGROUND + (char) 9733); //Estrella\nSystem.out.println(YELLOW + GREEN_BACKGROUND + \"Fondo verde con texto amarillo\");\nSystem.out.println(REVERSED + \"Fondo amarillo con texto verde usando REVERSED\");\n}\n}\n</code></pre> Ejercicio 3 <p>Muestra en consola una l\u00ednea de texto con 3 colores y fondos diferentes usando solamente un printf.</p>"},{"location":"bloque_i/tema_1/page-13/","title":"Proyecto","text":"<p>Se desea realizar un proyecto Java en el cu\u00e1l se le solicitar\u00e1 al usuario la siguiente informaci\u00f3n sobre un tri\u00e1ngulo.</p> <ol> <li>Valor de hipotenusa</li> <li>Valor de su base</li> <li>Valor de su altura</li> <li>Nombre</li> </ol> <p>Se mostrar\u00e1 una salida con el siguiente formato, con dicha informaci\u00f3n, usando color de letras azul y un fondo morado:</p> <pre><code>Tri\u00e1ngulo  : Sombra\nHipotenusa : 20,75 cm\nBase       : 15,75 cm\nAltura     : 14.00 cm\n======================\n   \u00c1rea: 189,00 cm\u00b2\n======================\n- No es recto\n- No es equil\u00e1tero\n</code></pre> <p>Para realizar el proyecto se tendr\u00e1 en cuenta los siguientes objeciones:</p> <ol> <li>Se crear\u00e1 un proyecto nuevo cuyo nombre sea el siguiente formato <code>pr01java-NOMBRE-triangulos</code> siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se deber\u00e1 realizar las operaciones pertinentes, incluso si no se han dictado expl\u00edcitamente en el enunciado</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> </ol>"},{"location":"bloque_i/tema_1/page-2/","title":"2 Introducci\u00f3n al lenguaje Java","text":""},{"location":"bloque_i/tema_1/page-2/#historia","title":"Historia","text":"<p>Java es un lenguaje de programaci\u00f3n de prop\u00f3sito general, concurrente, orientado a objetos, que fue dise\u00f1ado espec\u00edficamente para que los desarrolladores de aplicaciones escribieran el programa una vez y lo ejecutaran en cualquier dispositivo, lo que quiere decir que el c\u00f3digo que es ejecutado en una plataforma no tiene que ser recompilado para correr en otra.</p> <p>El lenguaje de programaci\u00f3n Java fue originalmente desarrollado por James Gosling, de Sun Microsystems (constituida en 1982 y posteriormente adquirida el 27 de enero de 2010 por la compa\u00f1\u00eda Oracle). Su sintaxis deriva en gran medida de C y C++, pero tiene menos utilidades de bajo nivel que cualquiera de ellos.</p> <p>El lenguaje Java se cre\u00f3 con cinco objetivos principales:</p> <ol> <li>Deber\u00eda usar el paradigma de la programaci\u00f3n orientada a objetos.</li> <li>Deber\u00eda permitir la ejecuci\u00f3n de un mismo programa en m\u00faltiples sistemas operativos.</li> <li>Deber\u00eda incluir por defecto soporte para trabajo en red.</li> <li>Deber\u00eda dise\u00f1arse para ejecutar c\u00f3digo en sistemas remotos de forma segura.</li> <li>Deber\u00eda ser f\u00e1cil de usar y tomar lo mejor de otros lenguajes orientados a objetos, como C++.</li> </ol>"},{"location":"bloque_i/tema_1/page-2/#bytecode-jvm-jre-jdk","title":"Bytecode, JVM, JRE, JDK","text":"<p>En el mundo de la programaci\u00f3n siempre se ha hablado de lenguajes compilados y de lenguajes interpretados. El resultado del proceso de compilaci\u00f3n (en realidad de compilaci\u00f3n y enlazado) es un archivo ejecutable. Un archivo ejecutable es un programa que se puede lanzar directamente en el sistema operativo; en el caso de Windows o Linux simplemente con hacer doble clic sobre el archivo, se ejecutan sus instrucciones. La ventaja es que los programas ejecutables no necesitan compilarse de nuevo, son programas terminados. El problema es que los sistemas operativos utilizan diferentes tipos de archivos ejecutables: es decir, un archivo ejecutable en Linux no ser\u00eda compatible con Windows.</p> <p>En Java el c\u00f3digo no se traduce a c\u00f3digo ejecutable. En Java el proceso se conoce como precompilaci\u00f3n y sirve para producir un archivo (de extensi\u00f3n class) que contiene c\u00f3digo que no es directamente ejecutable (no es c\u00f3digo Java). Es un c\u00f3digo intermedio llamado bytecode. Al no ser ejecutable, el archivo class no puede ejecutarse directamente con un doble clic en el sistema. El bytecode tiene que ser interpretado (es decir, traducido l\u00ednea a l\u00ednea) por una aplicaci\u00f3n conocida como la m\u00e1quina virtual de Java (JVM).</p> <p>JRE es el Java Runtime Environment o, en espa\u00f1ol, el Entorno de Ejecuci\u00f3n de Java. Contiene a la JVM y otras herramientas que permiten la ejecuci\u00f3n de las aplicaciones Java. La gran ventaja es que el entorno de ejecuci\u00f3n de Java se fabrica para todas las plataformas; lo que significa que un archivo class se puede ejecutar en cualquier ordenador o m\u00e1quina que incorpore el JRE. S\u00f3lo hay una pega, si programamos utilizando por ejemplo la versi\u00f3n 10 de Java, el ordenador en el que queramos ejecutar el programa deber\u00e1 incorporar el JRE al menos de la versi\u00f3n 10.</p> <p>A la forma de producir c\u00f3digo final de Java se la llama JIT (Just In Time,justo en el momento) ya que el c\u00f3digo ejecutable se produce s\u00f3lo en el instante de ejecuci\u00f3n del programa. Es decir, no hay en ning\u00fan momento c\u00f3digo ejecutable.</p> <p>JRE no posee compiladores ni herramientas para desarrollar las aplicaciones Java, solo posee las herramientas para ejecutarlas. JDK es el Java Development Kit o, en espa\u00f1ol, Herramientas de Desarrollo de Java. Sirve para construir programas usando el lenguaje de programaci\u00f3n Java. Trae herramientas \u00fatiles como el compilador (javac), el debugger, herramientas de evaluaci\u00f3n de rendimiento de aplicaciones, etc. Una instalaci\u00f3n de JDK ya contiene un JRE dentro de las carpetas.</p> <p>Para programar en Java, el primer paso que tiene que realizar el alumno es instalarse el JDK de la \u00faltima versi\u00f3n de Java. La descarga la puede efectuar desde la p\u00e1gina web de Oracle https://www.oracle.com/technetwork/java/javase/downloads/index.html/ en la pesta\u00f1a Downloads. Buscar la \u00faltima versi\u00f3n y descargar el JDK del Sistema Operativo con el que el alumno va a trabajar. Pero si al instalar el JDK ya existe una instalaci\u00f3n del JRE en el ordenador de una versi\u00f3n anterior, el JDK no actualizar\u00e1 el JRE a la \u00faltima versi\u00f3n. En este caso, hay que desinstalar primero el JRE y ya despu\u00e9s instalar el JDK de la \u00faltima versi\u00f3n.</p>"},{"location":"bloque_i/tema_1/page-2/#entornos-de-desarrollo-integrado-ide-eclipse","title":"Entornos de desarrollo integrado (IDE): Eclipse","text":"<p>El c\u00f3digo en Java se puede escribir en cualquier editor de texto, y para compilar el c\u00f3digo en bytecodes, s\u00f3lo hace falta descargar la versi\u00f3n del JDK deseada. Sin embargo, la escritura y compilaci\u00f3n de programas hecha de esta forma es un poco inc\u00f3moda. Por ello numerosas empresas fabrican sus propios entornos de edici\u00f3n, algunos incluyen el compilador y otras utilizan el propio JDK de Java.</p> <p>Un IDE ( integrated development environment )  es  un  entorno  de  programaci\u00f3n  que  consiste  b\u00e1sicamente en un editor de c\u00f3digo, un compilador y un depurador.</p> <p>Algunas ventajas que ofrecen son</p> <ul> <li>Facilidades  para  escribir  c\u00f3digo:  coloreado  de  las  palabras  clave,  autocorrecci\u00f3n  al  escribir, abreviaturas,...</li> <li>Facilidades de depuraci\u00f3n, para probar el programa.</li> <li>Facilidad de configuraci\u00f3n del sistema.</li> <li>Facilidades para organizar los archivos de c\u00f3digo.</li> <li>Facilidad para exportar e importar proyectos.</li> </ul> <p>Algunos IDEs para programar en Java son Eclipse, Netbeans e IntelliJ IDEA.</p>"},{"location":"bloque_i/tema_1/page-2/#sentencias","title":"Sentencias","text":"<p>Una sentencia es la unidad m\u00ednima de ejecuci\u00f3n de un programa. Un programa se compone de conjunto de sentencias  que  acaban  resolviendo  un  problema.  Al  final  de  cada  una  de  las  sentencias  encontraremos  un punto y coma (<code>;</code>).</p> <p>Veamos algunos ejemplos de sentencias en java:</p> <ul> <li>Sentencias de declaraci\u00f3n:  <code>int x;</code></li> <li>Invocaciones o llamadas a m\u00e9todos de tipo void: <code>System.out.println(\"Bienvenidos a Programaci\u00f3n\");</code></li> <li>Sentencias de control de flujo: alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</li> </ul>"},{"location":"bloque_i/tema_1/page-2/#expresiones","title":"Expresiones","text":"<p>Una  expresi\u00f3n  es  una  combinaci\u00f3n  de  operadores  y  operandos  que  se  eval\u00faa  gener\u00e1ndose  un  \u00fanico resultado de un tipo determinado.</p> <p>La diferencia entre las sentencias y los operadores es que las expresiones devuelven un valor y las sentencias no devuelven nada.</p>"},{"location":"bloque_i/tema_1/page-2/#bloques","title":"Bloques","text":"<p>Un bloque es un conjunto de sentencias las cuales est\u00e1n delimitadas por llaves:</p> <pre><code>{\nsentencias\n}\n</code></pre>"},{"location":"bloque_i/tema_1/page-3/","title":"3 Variables y constantes","text":""},{"location":"bloque_i/tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Las variables son contenedores que sirven para almacenar los datos que utiliza un programa. Dicho m\u00e1s sencillamente, son nombres que asociamos a determinados datos. La realidad es que cada variable ocupa un espacio  en  la  memoria  RAM  del  ordenador  para  almacenar  el  dato  al  que  se  refiere.  Es  decir,  cuando utilizamos el nombre de la variable realmente estamos haciendo referencia a un dato que est\u00e1 en memoria.</p> <p>Las  variables  tienen  un  nombre  (un  identificador)  que  se  escribe  en  min\u00fascula,  y  si  consta  de  varias palabras,  se  utiliza  la  notaci\u00f3n  lowerCamelCase.  Ejemplo:  myFirstVariable.  Adem\u00e1s,  deben  cumplir  lo siguiente:</p> <ul> <li>No deben comenzar con los caracteres guion bajo ( _ ) o el signo de d\u00f3lar ( $ ), aunque ambos se admiten.</li> <li>Se admiten los n\u00fameros pero no como primer car\u00e1cter.</li> <li>Deben ser cortos pero significativos. La elecci\u00f3n de un nombre de variable debe ser mnem\u00f3nico, es decir, dise\u00f1ado para indicar al observador casual la intenci\u00f3n de su uso. Por ejemplo, si queremos usar una variable para almacenar una edad, la llamaremos edad.</li> <li>Se deben evitar los nombres de variables de un solo car\u00e1cter excepto para las variables temporales \"usar y tirar\". Los nombres comunes de las variables temporales son i, j, k, m, y n para enteros; c, d, y e para los caracteres.</li> </ul>"},{"location":"bloque_i/tema_1/page-3/#declaracion-de-variables","title":"Declaraci\u00f3n de variables","text":"<p>Antes de poder utilizar una variable, esta se debe declarar de la siguiente manera: <code>tipo nombreVariable;</code> Donde tipo es el tipo de datos que almacenar\u00e1 la variable (texto, n\u00fameros enteros,...) y nombreVariable es el identificador de la variable. Ejemplos:</p> <pre><code>int days; boolean exit;\n</code></pre> <p>Java es un lenguaje muy estricto al utilizar tipos de datos. Variables de datos distintos son incompatibles. Algunos autores hablan de lenguaje fuertemente tipado o incluso lenguaje muy tipificado. Se debe a una traducci\u00f3n muy directa del ingl\u00e9s strongly typed referida a los lenguajes que, como Java, son muy r\u00edgidos en el uso de tipos. El caso contrario ser\u00eda el lenguaje C en el que jam\u00e1s se comprueban de manera estricta los tipos de datos. Parte de le seguridad y robustez de las que hace gala Java se deben a esta caracter\u00edstica.</p> <p>Por convenci\u00f3n de c\u00f3digo, todas las declaraciones de variables se ponen al principio.</p>"},{"location":"bloque_i/tema_1/page-3/#inicializacion-de-variables","title":"Inicializaci\u00f3n de variables","text":"<p>En Java se utiliza el operador asignaci\u00f3n <code>=</code> para inicializar una variable, es decir, para darle un valor inicial.</p> <p>La inicializaci\u00f3n se puede realizar:</p> <ul> <li> <p>En la misma l\u00ednea de c\u00f3digo que la declaraci\u00f3n:</p> <pre><code>int x = 7;\n</code></pre> </li> <li> <p>En cualquier otro momento, pero siempre despu\u00e9s de haberla declarado:</p> <pre><code>int x;\n// ...\nx = 7;\n</code></pre> </li> <li> <p>Tambi\u00e9n se puede utilizar una expresi\u00f3n para asignar un valor a una variable:</p> <pre><code>int x;\n// ...\nx =7;\n//...\nx = x * 2;\n</code></pre> </li> <li> <p>Incluso se puede utilizar una expresi\u00f3n en la misma inicializaci\u00f3n:</p> <pre><code>int a = 13, b = 18;\nint c = a + b;\n</code></pre> </li> <li> <p>Se puede declarar m\u00e1s de una variable a la vez del mismo tipo en la misma l\u00ednea si las separamos con comas:</p> <pre><code>int days, year, weeks;\n</code></pre> </li> <li> <p>Incluso se pueden tambi\u00e9n inicializar:</p> <pre><code>int days = 365, years = 2019, weeks;\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_1/page-3/#ambito-de-vida-de-las-variables","title":"\u00c1mbito de vida de las variables","text":"<p>Toda variable tiene un \u00e1mbito de vida. Esto es la parte del c\u00f3digo en la que una variable se puede utilizar, que es en el bloque donde se ha declarado. De hecho las variables tienen un ciclo de vida:</p> <ol> <li>En la declaraci\u00f3n se reserva el espacio necesario para que se puedan comenzar a utilizar (digamos que se avisa de su futura existencia)</li> <li>Se la asigna su primer valor (la variable nace)</li> <li>Se la utiliza en diversas sentencias. Cuando finaliza el bloque en el que fue declarada, la variable muere. Es decir, se libera el espacio que ocupa esa variable en memoria.</li> <li>Una vez que la variable ha sido eliminada, no se puede utilizar. Dicho de otro modo, no se puede utilizar una variable m\u00e1s all\u00e1 del bloque en el que ha sido definida. Ejemplo:</li> </ol> <pre><code>{ // (1)!\nint x = 9;\n} // (2)!\nint y = x;\n</code></pre> <ol> <li>Se utiliza <code>{</code> para indicar el comienzo del bloque dde c\u00f3digo</li> <li>Se utiliza <code>}</code> para indicar el fin del bloque de c\u00f3digo</li> </ol>"},{"location":"bloque_i/tema_1/page-3/#constantes","title":"Constantes","text":"<p>Una constante es un valor que no puede ser modificado durante la ejecuci\u00f3n de un programa, \u00fanicamente puede ser le\u00eddo.</p> <p>La forma de declarar constantes es la misma que la de las variables pero hay que anteponer la palabra final que es la que indica que estamos declarando una constante:</p> <pre><code>final double PI = 3.141591;\n</code></pre> <p>Los nombres de las constantes se deben escribir en may\u00fasculas. Pueden contener tambi\u00e9n guiones bajos. Incluso pueden contener d\u00edgitos pero no como primer car\u00e1cter.</p> <p>Ejemplos:</p> <pre><code>final int MAX_PARTICIPANTS = 10;\nfinal int _MIN1 = 1;\n</code></pre> <p>Cuando  un  mismo  valor  se  utilice  en  varias  partes  del  c\u00f3digo,  entonces  hay  que  declararlo  como  una constante ya que si en alg\u00fan momento de la vida de la aplicaci\u00f3n, ese valor var\u00eda, solamente hay que cambiar el valor de la constante y no estar cambi\u00e1ndolo en todos los sitios del c\u00f3digo donde aparezca.</p> Ejercicio 1 <p>Indica cu\u00e1les de los siguientes no son identificadores.</p> <ol> <li>hola</li> <li>\"a\"</li> <li>1nombre</li> <li>mi variable</li> <li>mi_variable</li> <li>esto_es_una_variable</li> <li>nombre1</li> </ol>"},{"location":"bloque_i/tema_1/page-4/","title":"4 Tipos de datos primitivos","text":""},{"location":"bloque_i/tema_1/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Se llaman tipos primitivos a los tipos de datos originales de un lenguaje de programaci\u00f3n, esto es, aquellos que nos proporciona el lenguaje, java posee los siguientes:</p> Tipo de variable Bytes que ocupa Rango de valores boolean 1 true, false char 2 Caracteres en Unicode byte 1 -128 a 127 short 2 -32.768 a 32.767 int 4 -2.147.483.648 a 2.147.483.647 long 8 -9\u00b71018 a 9\u00b71018 float 4 -3.4\u00b71038 a 3.4\u00b71038 double 8 -3.4\u00b710308 a 3.4\u00b710308"},{"location":"bloque_i/tema_1/page-4/#enteros","title":"Enteros","text":"<p>Los tipos byte, short, int y long sirven para almacenar datos enteros. Los enteros son n\u00fameros sin decimales.</p> <p>Un literal es un elemento de programa que representa directamente un valor:</p> <pre><code>int number = 16; // 16 es un literal\n</code></pre> <p>Los literales se pueden expresar de varias maneras</p> <ul> <li>En decimal, es como se representan por defecto: <code>16</code></li> <li>En binario, anteponiendo 0b: <code>0b10000</code></li> <li>En octal, anteponiendo 0: <code>020</code></li> <li>En hexadecimal, anteponiendo 0x: <code>0x10</code></li> </ul> <p>Por defecto, un literal entero es de tipo int. Si se le coloca detr\u00e1s la letra L, entonces el literal ser\u00e1 de tipo long.</p> <pre><code>int number = 16; //(1)!\nlong number_long = 16L; //(2)!\n</code></pre> <ol> <li>16 es un literal entero</li> <li>16L es un literal de tipo long</li> </ol> <p>No se acepta en general asignar variables de distinto tipo pero existen excepciones. Por ejemplo, si se pueden asignar valores de variables enteras a variables enteras de un tipo superior (por ejemplo, asignar un valor int a una variable long). Pero al rev\u00e9s no se puede:</p> <pre><code>int i = 12;\nbyte b = i; //(1)!\n</code></pre> <ol> <li>Error de compilaci\u00f3n, posible p\u00e9rdida de precisi\u00f3n</li> </ol> <p>La soluci\u00f3n es hacer un casting. Esta operaci\u00f3n permite convertir valores de un tipo a otro tipo, siempre y cuando sea posible:</p> <pre><code>int i = 12;\nbyte b = (byte) i; //(1)!\n</code></pre> <ol> <li>El casting evita el error</li> </ol> <p>Hay que tener en cuenta en estos castings que si el valor asignado sobrepasa el rango del elemento, el valor convertido no tendr\u00e1 ning\u00fan sentido ya que no puede almacenar todos los bits necesarios para representar ese n\u00famero:</p> <pre><code>int i = 1200;\nbyte b = (byte) i; //(1)!\n</code></pre> <ol> <li>El valor de b no tiene sentido</li> </ol> <p>Si lo que asignamos a la variables es un literal, java hace una conversi\u00f3n impl\u00edcita siempre y cuando el literal est\u00e9 dentro del rango permitido para dicho tipo. Por ejemplo, el siguiente c\u00f3digo no da error porque 127 est\u00e1 dentro del rango de los bytes aunque el literal sea por defecto int:</p> <pre><code>byte b = 127;\n</code></pre> <p>Sin embargo, el siguiente c\u00f3digo si da error porque 128 sobrepasa el rango de los tipos byte:</p> <pre><code>byte b = 128; //ERROR\n</code></pre> <p>A partir de Java7, se pueden usar guiones, como separador de miles, para facilitar la lectura al programador:</p> <pre><code>int i = 1_000_000;\n</code></pre> <p>En el siguiente c\u00f3digo de ejemplo, utilizamos <code>System.out.println</code> para escribir en pantalla el valor de las variables:</p> <pre><code>public class Integers {\npublic static void main(String[] args) {\nint i;\nlong l;\nbyte b;\nshort s;\ni = 16; //(1)!\nSystem.out.println(i);\ni = 020; //(2)!\nSystem.out.println(i);\ni = 0x10; //(3)!\nSystem.out.println(i);\ni = 0b10000; //(4)!\nSystem.out.println(i);\nl = 6985742369L; //(5)!\nSystem.out.println(l);\nb = 127; //(6)!\nSystem.out.println(b);\ns = 32767; //(7)!\nSystem.out.println(s);\ni = 1200;\nSystem.out.println(i);\nb = (byte) i;\nSystem.out.println(b); //(8)!\nSystem.out.println(1_000_000); //(9)!\n}\n}\n</code></pre> <ol> <li>16 en decimal</li> <li>20 en octal = 16 decimal</li> <li>10 hexadecimal = 16 decimal</li> <li>10000 binario = 16 decimal</li> <li>Si se le quita la L da error</li> <li>No da error porque est\u00e1 dentro del rango de los bytes aunque su valor por defecto sea int</li> <li>No da error porque est\u00e1 dentro del rango de los shorts aunque su valor por defecto sea int</li> <li>El valor b no tiene sentido</li> <li>Salida por consola: 1000000</li> </ol>"},{"location":"bloque_i/tema_1/page-4/#numeros-decimales","title":"N\u00fameros decimales","text":"<p>Los decimales se almacenan en los tipos float y double. Los decimales no son almacenados de forma exacta por eso siempre hay un posible error y se habla de precisi\u00f3n. Es mucho m\u00e1s preciso el tipo double que el tipo float.</p> <p>Para asignar valores literales a una variable decimal, hay que tener en cuenta que el separador decimal es el punto y no la coma. Es decir para asignar el valor 2,75 a la variable x se har\u00eda: <code>x=2.75;</code></p> <p>A un valor literal (como 1.5 por ejemplo), se le puede indicar con una f al final del n\u00famero que es float (1.5f por ejemplo) o una d para indicar que es double. Si no se indica nada, un n\u00famero literal siempre se entiende que es double, por lo que al usar tipos float hay que convertir los literales:</p> <pre><code>double d = 3.49; //(1)!\nfloat f = 3.49f; //(2)!\n</code></pre> <ol> <li>El literal 3.49 por defecto es double</li> <li>El literal 3.49 se tiene que convertir a float</li> </ol> <p>L\u00f3gicamente no podemos asignar valores decimales a tipos de datos enteros:</p> <pre><code>int x = 9.5; //Error\nint x = (int) 9.5;//(1)!\n</code></pre> <ol> <li>Podemos mediante un casting, pero perderemos los decimales. En este caso, x valdr\u00e1 9.</li> </ol> <p>El caso contrario, sin embargo, si se puede haceR:</p> <pre><code>int x = 9;\ndouble y = z;\n</code></pre> <p>La raz\u00f3n es que los tipos decimales son m\u00e1s grandes que los enteros, por lo que no hay problema de p\u00e9rdida de valores.</p>"},{"location":"bloque_i/tema_1/page-4/#booleanos","title":"Booleanos","text":"<p>Los valores booleanos o l\u00f3gicos se almacenan en el tipo boolean. Sirven para indicar si algo es verdadero (true) o falso (false).</p> <p>Por otro lado, a diferencia del lenguaje C, no se puede en Java asignar n\u00fameros a una variable booleana (en C, el valor false se asocia al n\u00famero 0, y cualquier valor distinto de cero se asocia a true). Tampoco tiene sentido asignar valores de otros tipos de datos a variables booleanas mediante casting:</p> <pre><code>boolean b = (boolean) 9; // no tiene sentido\n</code></pre>"},{"location":"bloque_i/tema_1/page-4/#5-caracteres","title":"5 Caracteres","text":"<p>Los valores de tipo car\u00e1cter sirven para almacenar s\u00edmbolos de escritura. En Java se puede almacenar cualquier c\u00f3digo Unicode en el tipo char.</p> <p>Los literales car\u00e1cter van entre comillas simples, como por ejemplo: <code>'a'</code>.</p> <p>En programaci\u00f3n, secuencias de escape es el conjunto de caracteres que en el c\u00f3digo es interpretado con alg\u00fan fin. En Java, la barra invertida <code>\\</code> se denomina car\u00e1cter de escape, el cual indica que el car\u00e1cter puesto a continuaci\u00f3n ser\u00e1 convertido en car\u00e1cter especial o, si ya es especial, dejar\u00e1 de ser especial. Por ejemplo, si el car\u00e1cter <code>n</code> no es especial pero con la <code>\\</code> delante se convierte en especial ya que <code>\\n</code> se interpreta como un salto de l\u00ednea. La <code>\\</code> es un car\u00e1cter especial pero con otra <code>\\</code> delante deja de ser especial y simplemente es una barra invertida.</p> Car\u00e1cter Significado \\t Tabulador \\n Salto de l\u00ednea \" Dobles comillas ' Comillas simples \\ Barra invertida \\udddd Representa el car\u00e1cter Unicode cuyo c\u00f3digo es representado por dddd en hexadecimal <p>Como se vio en el tema 1. Introducci\u00f3n, la descripci\u00f3n completa del est\u00e1ndar Unicode est\u00e1 disponible en la p\u00e1gina web https://unicode.org/. En dicha p\u00e1gina, encontramos las tablas de caracteres en hexadecimal en el enlace Code Charts. Para saber saber el c\u00f3digo de los caracteres en decimal, podemos acceder al siguiente enlace: https://unicode-table-com/es. Los caracteres imprimibles son del 32 al 126 y del 161 al 255.</p> <p>Para insertar el c\u00f3digo caracteres no disponibles en el teclado, se hace de manera diferente seg\u00fan el Sistema Operativo:</p> <ul> <li>Linux: Ctrl+Shift y luego se pulsa u(para indicar que es Unicode) y el c\u00f3digo Unicode en hexadecimal en el teclado num\u00e9rico desactivado.</li> <li>Windows: ++Alt++ y el c\u00f3digo Unicode en hexadecimal.</li> </ul> <p>Tambi\u00e9n se le puede asignar a una variable de tipo char un car\u00e1cter Unicode, ya sea usando el c\u00f3digo decimal o hexadecimal del car\u00e1cter.</p> <pre><code>public class Characters {\npublic static void main(String[] args) {\nchar character;\ncharacter = 'C'; //(1)!\nSystem.out.println(character);\ncharacter = 67; // (2)!\nSystem.out.println(character);\ncharacter = '\\u0043'; // (3)!\nSystem.out.println(character);\ncharacter = '\\n'; // (4)!\nSystem.out.println(character);\ncharacter = '\\''; // (5)!\nSystem.out.println(character);\ncharacter = '\\\"'; // (6)!\nSystem.out.println(character);\ncharacter = '\"'; // (7)!\nSystem.out.println(character);\ncharacter = '\\\\'; // (8)!\nSystem.out.println(character);\ncharacter = 9752; // (9)!\nSystem.out.println(character);\ncharacter = '\\u2618'; // (10)!\nSystem.out.println(character);\ncharacter = '\u2618'; // (11)!\nSystem.out.println(character);\n}\n}\n</code></pre> <ol> <li>Los literales car\u00e1cter van entre comillas simples</li> <li>El c\u00f3digo Unicode de la C es el 67</li> <li>El c\u00f3digo Unicode de la C en hexadecimal es el 0043</li> <li>Car\u00e1cter especial salto de l\u00ednea</li> <li>Car\u00e1cter especial Comillas Simples</li> <li>Car\u00e1cter especial Comillas Dobles</li> <li>Car\u00e1cter especial comillas dobles se puede utilizar sin el car\u00e1cter de escape en un literal de car\u00e1cter</li> <li>Car\u00e1cter especial barra inclinada</li> <li>C\u00f3digo decimal del car\u00e1cter tr\u00e9bol</li> <li>C\u00f3digo hexadecimal del car\u00e1cter tr\u00e9bol</li> <li>Car\u00e1cter tr\u00e9bol</li> </ol> <p>Si necesitamos almacenar m\u00e1s de un car\u00e1cter, entonces debemos usar otro tipo de datos que nos permite manejar cadenas de caracteres: String.</p> Ejercicio 1 <p>Muestra en consola los siguientes caracteres</p> <ol> <li>\u2764</li> <li>\u2602</li> <li>\u260e</li> <li>\u265e</li> </ol> <p>En Java, las cadenas no se modelan como un dato de tipo primitivo, sino a trav\u00e9s de la clase String. El texto es uno de los tipos de datos m\u00e1s importantes y por ello java lo trata de manera especial. Para Java, las cadenas de texto son objectos especiales. Los textos deben manejarse creando objetos de tipo String.</p> <p>Los literales cadena se escriben entre comillas dobles: <code>\"Esto es un literal cadena</code>\".</p> <p>Ejemplo:</p> <pre><code>String s = \"Estamos aprendiendo a programar\";\n</code></pre> <p>En Java existe tambi\u00e9n la cadena vac\u00eda o nula(\"\"), es decir, una cadena sin ning\u00fan car\u00e1cter. Ejemplo: <code>String s = \"\";</code> A la variable s se le est\u00e1 asignando la cadena vac\u00eda o nula.</p> Ejercicio 2 <p>Sea MAX una constante que vale 1000, a,b e i variables enteras, x una variable decimal, c una variable car\u00e1cter y s una variable cadena. Indicar las sentencias v\u00e1lidas y su valor, razonando la respuesta. Suponer que a = 3 y b = 4.</p> <ol> <li>i = (900 - MAX) / a</li> <li>i = b / 0</li> <li>i = a % (MAX - 900)</li> <li>i = (MAX - 900) % a</li> <li>i = 3.34 * a</li> <li>x = a / b</li> <li>x = a % (a / b)</li> <li>i = a / b</li> <li>i = ++a</li> <li>i = a++</li> <li>c = '''</li> <li>c = '\"'</li> <li>s = 'c'</li> <li>s = \"'\"</li> <li>s = \"\"\"</li> <li>c = '\\u0041'</li> <li>c = 65</li> </ol>"},{"location":"bloque_i/tema_1/page-5/","title":"5 Operadores","text":""},{"location":"bloque_i/tema_1/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Un operador lleva a cabo operaciones sobre uno (operador unario), dos (operador binario) o tres (operador ternario) datos u operandos de tipo primitivo devolviendo un valor determinado tambi\u00e9n de un tipo primitivo. El tipo de valor devuelto tras la evaluaci\u00f3n depende del operador y del  tipo  de  los  operandos.  Por  ejemplo,  los  operadores  aritm\u00e9ticos  trabajan  con  operandos num\u00e9ricos,  llevan  a  cabo  operaciones  aritm\u00e9ticas  b\u00e1sicas  y  devuelven  el  valor  num\u00e9rico correspondiente. Los operadores se pueden clasificar en distintos grupos seg\u00fan se muestra en los siguientes apartados</p>"},{"location":"bloque_i/tema_1/page-5/#operador-asignacion","title":"Operador asignaci\u00f3n","text":"<p>El operador asignaci\u00f3n <code>=</code> es un operador binario que asigna el valor del t\u00e9rmino de la derecha al operando de la izquierda. El operando de la izquierda es una variable. El t\u00e9rmino de la derecha es una expresi\u00f3n de un tipo de dato compatible.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo = Operador asignaci\u00f3n n = 4 n vale 4 <p>No debe confundirse el operador asignaci\u00f3n (=) con el operador relacional de igualdad (==) que se ver\u00e1 m\u00e1s adelante. Adem\u00e1s Java dispone de otros operadores que combinan la asignaci\u00f3n con otras operaciones (operadores aritm\u00e9ticos combinados).</p>"},{"location":"bloque_i/tema_1/page-5/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>El lenguaje de programaci\u00f3n Java tiene varios operadores aritm\u00e9ticos para los datos num\u00e9ricos enteros y decimales.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo - Operador unario de cambio de signo -4 -4 + Suma 2.5 + 7.1 9.6 - Resta 235.6 - 103.5 132.1 * Multiplicaci\u00f3n 1.2 * 1.1 1.32 / Divisi\u00f3n 0.050 / 0.027 / 2 0.253 % M\u00f3dulo 20 % 714.5 % 2 60.5 <p>El resultado exacto depende de los tipos de operandos involucrados. Es conveniente tener en cuenta las siguientes peculiaridades:</p> <ul> <li> <p>El resultado de una expresi\u00f3n se convierte al tipo m\u00e1s general seg\u00fan el siguiente orden de generalidad:     byte \u2192 short \u2192 int \u2192 long \u2192 float \u2192 double     Teniendo esto en cuenta, tenemos que:</p> <ul> <li>El resultado es de tipo long si, al menos, uno de los operandos es de tipo long y ninguno es decimal. </li> <li>El resultado es de tipo int si ninguno de los operandos es de tipo long ni decimal.</li> <li>El resultado es de tipo double si, al menos, uno de los operandos es de tipo double.</li> <li>El resultado es de tipo float si, al menos, uno de los operandos es de tipo float y ninguno es double.</li> </ul> </li> <li> <p>Con  los  n\u00fameros  enteros,  si  se  divide  entre  cero,  se  genera  la  excepci\u00f3n ArithmeticException. Pero si se realiza la divisi\u00f3n entre cero con decimales, el resultado es infinito (<code>Infinity</code>).</p> </li> <li>El resultado de una expresi\u00f3n inv\u00e1lida, por ejemplo, dividir infinito por infinito, no genera una excepci\u00f3n ni un error de ejecuci\u00f3n: es un valor Not a Number (<code>NaN</code>).</li> </ul> <pre><code>public class ArithmeticOperators {\npublic static void main(String[] args) {\nint int1 = 100, int2 = 0;\ndouble dec1 = 20.36, dec2 = 0;\nSystem.out.println(int1 / int2); //(1)!\nSystem.out.println(dec1 / dec2); //(2)!\nSystem.out.println(dec1 % dec2); //(3)!\n}\n}\n</code></pre> <ol> <li>Genera ArithmeticException</li> <li>Infinity</li> <li>NaN</li> </ol> <p>Hay que tener en cuenta que el resultado de estos operadores var\u00eda notablemente si usamos enteros o si usamos n\u00fameros decimales. Por ejemplo:</p> <pre><code>double result1, d1 = 14, d2 = 5;\nint result2, i1 = 14, i2 = 5;\nresult1 = d1 / d2; // result1 = 2.8\nresult2 = i1 / i2; // result2 = 2\n</code></pre> <p>Es m\u00e1s incluso:</p> <pre><code>double result;\nint i1 = 7, i2 = 2;\nresult = i1 / i2; // resultado = 3.0\nresult = (double) i1 / i2; // resultado 3.5\n</code></pre> <p>El operador del m\u00f3dulo (<code>%</code>) sirve para calcular el resto de una divisi\u00f3n tanto entera como decimal.</p> <pre><code>int remainder, i1 = 14, i2 = 5;\nremainder = i1 % i2; // remainder = 4\n</code></pre> <p>En los decimales, el resto se calcula asumiendo que la divisi\u00f3n produce un resultado entero:</p> <pre><code>double remainder, d1 = 7.5, d2 = 2;\nremainder = d1 % d2; // remainder = 1.5\n</code></pre>"},{"location":"bloque_i/tema_1/page-5/#operadores-aritmeticos-incrementales","title":"Operadores aritm\u00e9ticos incrementales","text":"<p>Los  operadores  aritm\u00e9ticos  incrementales  son  operadores  unarios  (un  \u00fanico  operando).  El operando puede ser num\u00e9rico o de tipo char y el resultado es del mismo tipo que el operando.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo ++ Incremento 4++ 5 -- Decremento 4-- 3 <p>En el caso de los caracteres, el incremento/decremento se realiza a su c\u00f3digo Unicode. Es decir, si  una  variable  char  tiene  el  valor  'C',  su  c\u00f3digo  Unicode  es  67.  Si  se  incrementa,  su  c\u00f3digo Unicode pasa a valer 68 que corresponde al valor 'D'.</p> <p>Estos operadores pueden emplearse de dos formas dependiendo de su posici\u00f3n con respecto al operando:</p> <ul> <li>si  el  operador  est\u00e1  detr\u00e1s  del  operando,  primero  se  utiliza  la  variable  y  luego  se incrementa/decrementa su valor:<ul> <li>Post-incremento: a++</li> <li>Post-decremento: a- -</li> </ul> </li> <li>si el operador est\u00e1 delante del operando, primero se incrementa/decrementa el valor de la variable y luego se utiliza.<ul> <li>Pre-incremento: ++a</li> <li>Pre-decremento: - -a</li> </ul> </li> </ul> <pre><code>public class IncrementalArithmeticOperators {\npublic static void main(String[] args) {\nint integer1, integer2;\nchar character1, character2;\ncharacter1 = 'C'; //(1)!\ncharacter1++;\nSystem.out.println(character1); //(2)!\n//(3)!\ncharacter2 = (char) (character1 + 6);\nSystem.out.println(character2); //(4)!\ninteger1 = character2 + 2;\nSystem.out.println(integer1); //(5)!\ncharacter2++;\nSystem.out.println(character2); //(6)!\ninteger1 = character2;\nSystem.out.println(integer1); //(7)!\ninteger1 = 5;\ninteger2 = integer1++;\nSystem.out.println(integer1); //(8)!\nSystem.out.println(integer2); //(9)!\ninteger1 = 5;\ninteger2 = ++integer1;\nSystem.out.println(integer1); //(10)!\nSystem.out.println(integer2); //(11)!\n}\n}\n</code></pre> <ol> <li>Unicode 67</li> <li>Al incrementarse vale 'D', Unicode 68</li> <li>Tambi\u00e9n se pueden utilizar los caracteres con los operadores aritm\u00e9ticos, pero entonces hace falta usar casting</li> <li>character2 vale 'J', Unicode 74</li> <li>integer1 vale 76</li> <li>character2 vale 'K', Unicode 75</li> <li>integer1 vale 75</li> <li>integer1 vale 6</li> <li>integer2 vale 5</li> <li>integer1 vale 6</li> <li>integer2 vale 6</li> </ol>"},{"location":"bloque_i/tema_1/page-5/#operadores-aritmeticos-combinados","title":"Operadores aritm\u00e9ticos combinados","text":"<p>Combinan  un  operador  aritm\u00e9tico  con  el  operador  asignaci\u00f3n.  Como  en  el  caso  de  los operadores  aritm\u00e9ticos,  pueden  tener  operandos  num\u00e9ricos  enteros  o  decimales  y  el  tipo espec\u00edfico del resultado num\u00e9rico depender\u00e1 del tipo de \u00e9stos.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo += Suma combinada a+=b a=a+b -= Resta combinada a-=b a=a-b *= Multiplicaci\u00f3n combinada a*=b a=a*b /= Divisi\u00f3n combinada a/=b a=a/b %= Resto combinado a%=b a=a%b <p>Tambi\u00e9n se pueden utilizar con caracteres:</p> <pre><code>char character='a';\ncharacter+=2; //character vale 'c'\n</code></pre>"},{"location":"bloque_i/tema_1/page-5/#operadores-relacionales","title":"Operadores relacionales","text":"<p>Realizan  comparaciones  entre  datos  compatibles  de  tipos  primitivos  (num\u00e9ricos,  car\u00e1cter  y booleanos)  teniendo  siempre  un  resultado  booleano.  Los  operandos  booleanos  s\u00f3lo  pueden emplear los operadores de igualdad y desigualdad.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo == Igual que 7 == 3 false != Distinto que 'a' != 'k' true &lt; Menor que 'G' &lt; 'B' false &gt; Mayor que 'b' &gt; 'a' true &lt;= Menor o igual que 7.5 &lt;= 7.38 false &gt;= Mayor o igual que 38 &gt;= 7 true"},{"location":"bloque_i/tema_1/page-5/#operadores-logicos-o-booleanos","title":"Operadores l\u00f3gicos o booleanos","text":"<p>Las puertas l\u00f3gicas son circuitos electr\u00f3nicos capaces de realizar operaciones l\u00f3gicas b\u00e1sicas:</p> <ul> <li> <p>Puerta NOT: la salida es la inversa de la entrada. Se corresponde con la siguiente tabla de verdad:</p> A (entrada) S (salida) 0 1 1 0 </li> <li> <p>Puerta AND:  la  se\u00f1al  de  salida  se  activa  solo  cuando  se  activan  todas  las  se\u00f1ales  de entrada. Equivale al producto l\u00f3gico S = A \u00b7 B y se corresponde con la siguiente tabla de verdad:</p> A (entrada1) B (entrada 2) S (salida) 0 0 0 0 1 0 1 0 0 1 1 1 </li> <li> <p>Puerta OR: la salida se activa cuando cualquiera de las entradas est\u00e1 activada. Equivale a la suma l\u00f3gica S = A + B y se corresponde con la siguiente tabla de verdad:</p> A (entrada1) B (entrada 2) S (salida) 0 0 0 0 1 1 1 0 1 1 1 1 </li> </ul> <p>Los operadores l\u00f3gicos o booleanos realizan operaciones sobre datos booleanos y tienen como resultado un valor booleano:</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo ! Negaci\u00f3n - NOT (unario) !false!(5 == 5) truefalse || Suma l\u00f3gica - OR (binario) true || false(5 == 5) || (5 &lt; 4) truetrue &amp;&amp; Producto l\u00f3gico - AND (binario) false &amp;&amp; true(5 == 5) &amp;&amp; (5 &lt; 4) falsefalse <p>El producto l\u00f3gico se realiza con cortocircuito, es decir, si el primer operando es false entonces el segundo operando no se eval\u00faa ya que el resultado va a ser de todas maneras false. En este caso es conveniente situar la condici\u00f3n m\u00e1s propensa a ser falsa en el t\u00e9rmino de la izquierda.</p> <p>La suma l\u00f3gica tambi\u00e9n  se  realiza  con  cortocircuito,  es  decir,  si  el  primer  operando  es  true entonces el segundo operando no se eval\u00faa ya que el resultado va a ser de todas maneras true. En este caso es conveniente colocar la condici\u00f3n m\u00e1s propensa a ser verdadera en el t\u00e9rmino de la izquierda.</p> <p>Estas t\u00e9cnicas reducen el tiempo de ejecuci\u00f3n del programa y ayudan al programador a evitar ciertos  errores.  Por  ejemplo,  <code>5/b==2</code> , si b es  una  variable  de  tipo  entero y  su  valor es 0,  se genera la excepci\u00f3n ArithmeticException. Para evitar este problema, el programador puede hacer lo siguiente: <code>b!=0 &amp;&amp; 5/b==2</code>.Si b contiene el valor 0, <code>b!=0</code> dar\u00e1 false, entonces <code>5/b==2</code> no se eval\u00faa, evitando as\u00ed la generaci\u00f3n de la excepci\u00f3n.</p> <p>Ejemplos de uso de operadores l\u00f3gicos o booleanos:</p> <pre><code>boolean adult, younger;\nint age = 21;\nadult = age &gt;= 18; //adult ser\u00e1 true\nyounger = !adult; //younger ser\u00e1 false\n</code></pre> <pre><code>boolean drivingLicense=true;\nint age=20;\nboolean canDrive= (age&gt;=18) &amp;&amp; drivingLicense;\n/*Si la edad es de al menos 18 a\u00f1os y tiene carnet de conducir,\n  entonces puede conducir*/\n</code></pre> <pre><code>boolean snow =true, rain=false, hail=false;\nboolean badWeather= snow || rain || hail;\n//Si nieva o llueve o graniza, hace mal tiempo\n</code></pre>"},{"location":"bloque_i/tema_1/page-5/#operador-condicional","title":"Operador condicional","text":"<p>Este operador ternario permite devolver valores en funci\u00f3n de una expresi\u00f3n l\u00f3gica. Su sintaxis es la siguiente:</p> <p><code>expresionLogica ? expresion_1 : expresion_2</code></p> <p>Si el resultado de evaluar la expresi\u00f3n l\u00f3gica es verdadero, devuelve el valor de la primera expresi\u00f3n, y en caso contrario, devuelve el valor de la segunda expresi\u00f3n.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo ?: Operador condicional a = 4;b = a == 4 ? a+5 : 6-a;b = a &gt; 4 ? a*7 : a+8; b vale 9 b vale 12 <p>Ejemplo:</p> <pre><code>pay = (age &gt; 18) ? 6000 : 3000;\n</code></pre> <p>En este caso, si la variable edad es mayor de 18, la paga ser\u00e1 de 6000, sino ser\u00e1 de 3000.</p>"},{"location":"bloque_i/tema_1/page-5/#operador-de-concatenacion-de-cadenas","title":"Operador de concatenaci\u00f3n de cadenas","text":"<p>El operador concatenaci\u00f3n <code>+</code> es un operador binario que devuelve una cadena resultado de concatenar dos cadenas que act\u00faan como operando. Si solo uno de los operandos es de tipo cadena, el otro se convierte impl\u00edcitamente en tipo cadena.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo + Operador concatenaci\u00f3n \"Hola\" + \"Juan\"\"Hola\" + 5 \"HolaJuan\"\"Hola5\""},{"location":"bloque_i/tema_1/page-5/#operador-a-nivel-de-bits","title":"Operador a nivel de bits","text":"<p>Manipulan los bits de los n\u00fameros.</p> Operador Descripci\u00f3n &amp; AND | OR ~ NOT ^ XOR &gt;&gt; Desplazamiento a la derecha &lt;&lt; Desplazamiento a la izquierda &gt;&gt;&gt;&gt; Desplazamiento a la derecha con relleno de ceros &lt;&lt;&lt;&lt; Desplazamiento a la izquierda con relleno de ceros Ejercicio <p>De las siguientes asignaciones, \u00bfcu\u00e1les son v\u00e1lidas? \u00bfCu\u00e1l es el efecto de su ejecuci\u00f3n? \u00bfDe qu\u00e9 tipo deben ser las variables?</p> <ol> <li>z = 2 &lt; 1</li> <li>a = a + 1</li> <li>sqrt(3) = 32717</li> <li>'x' = 'y'</li> <li>x = 'y'</li> <li>a = b</li> <li>precio = precio - precio * (30/100)</li> </ol>"},{"location":"bloque_i/tema_1/page-6/","title":"6 Sentencias y Expresiones","text":""},{"location":"bloque_i/tema_1/page-6/#sentencias","title":"Sentencias","text":"<p>Una sentencia es la unidad m\u00ednima de ejecuci\u00f3n de un programa. Un programa se compone de un  conjunto  de  sentencias  que  acaban  resolviendo  un  problema.  Al  final  de  cada  una  de  las sentencias encontraremos un punto y coma (<code>;</code>).</p> <p>Veamos algunos ejemplos de sentencias en java:</p> <ul> <li>Sentencias de declaraci\u00f3n:  int x;</li> <li>Invocaciones o llamadas a m\u00e9todos de tipo void: <code>System.out.println(\"Bienvenidos a Programaci\u00f3n\");</code></li> <li>Sentencias de control de flujo: alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</li> </ul>"},{"location":"bloque_i/tema_1/page-6/#expresiones","title":"Expresiones","text":"<p>Una expresi\u00f3n es una combinaci\u00f3n de operadores y operandos que se eval\u00faa gener\u00e1ndose un \u00fanico resultado de un tipo determinado.</p> <p>La diferencia entre las sentencias y las expresiones es que las expresiones devuelven un valor y las sentencias no devuelven nada.</p>"},{"location":"bloque_i/tema_1/page-6/#prioridad-entre-operadores","title":"Prioridad entre operadores","text":"<p>A veces hay expresiones con operadores que resultan confusas. Por ejemplo:</p> <p><code>resultado=8+4/2;</code></p> <p>Es  dif\u00edcil  saber  el  resultado.  \u00bfCu\u00e1l  es?  \u00bfseis  o  diez?  La  respuesta  es  10  y  la  raz\u00f3n  es  que  el operador de divisi\u00f3n siempre precede en el orden de ejecuci\u00f3n al de la suma. Es decir, siempre se ejecuta antes la divisi\u00f3n que la suma. Siempre se pueden usar par\u00e9ntesis para forzar el orden deseado:</p> <p><code>resultado=(8+4)/2;</code></p> <p>Ahora no hay duda, el resultado es seis.</p> <p>\u00bfC\u00f3mo podemos saber en qu\u00e9 orden se van a ejecutar los operadores en una expresi\u00f3n en Java? Pues se ejecutan en funci\u00f3n de una prioridad, es decir, primero se ejecuta el que tenga m\u00e1s prioridad. La siguiente tabla muestra todos los operadores Java ordenados de mayor a menor prioridad. La primera l\u00ednea de la tabla contiene los operadores de mayor prioridad y la \u00faltima los de menor prioridad. Los operadores que aparecen en la misma l\u00ednea tienen la misma prioridad.</p> <p>Cuando una expresi\u00f3n tenga dos operadores con la misma prioridad, la expresi\u00f3n se eval\u00faa seg\u00fan su asociatividad.</p> Nivel Operador Descripci\u00f3n Asociatividad 1 [].() acceso elementos arrayacceso miembros objetospar\u00e9ntesis de izquierda a derecha 2 ++-- unario post-incrementounario post-incremento no asociativos 3 ++--+-!~ unario pre-incrementounario pre-decrementounario m\u00e1sunario menosunario l\u00f3gico NOTunario NOT a nivel de bits de derecha a izquierda 4 ()new castcreaci\u00f3n objetos de derecha a izquierda 5 */% multiplicaci\u00f3ndivisi\u00f3nm\u00f3dulo de izquierda a derecha 6 +-+ sumarestaconcatenaci\u00f3n cadenas de izquierda a derecha 7 &lt;&lt;&gt;&gt;&gt;&gt;&gt; desplazamiento a nivel de bits de izquierda a derecha 8 &lt;&lt;=&gt;&gt;=instanceof relacionales no asociativos 9 ==!= igualdistinto de izquierda a derecha 10 &amp; AND nivel de bits de izquierda a derecha 11 ^ XOR nivel de bits de izquierda a derecha 12 | OR nivel de bits de izquierda a derecha 13 &amp;&amp; AND de izquierda a derecha 14 || OR de izquierda a derecha 15 ?: ternario condicional de derecha a izquierda 16 =+=-=*=/=%=&amp;=^|=&lt;&lt;&lt;=&gt;&gt;=&gt;&gt;= asignaciones de derecha a izquierda <p>Por ejemplo:<code>resultado = 9 / 3 * 3;</code> En este caso, la multiplicaci\u00f3n y la divisi\u00f3n tienen la misma prioridad y su asociatividad es de izquierda a derecha por lo que se realiza primero la operaci\u00f3n que est\u00e9 m\u00e1s a la izquierda, que en este caso es la divisi\u00f3n. El resultado por lo tanto es nueve.  Si  se  desea  que  se  haga  primero  la  multiplicaci\u00f3n,  habr\u00eda  que  utilizar  un  par\u00e9ntesis: <code>resultado = 9 / (3 * 3);</code> En este caso, el resultado ser\u00eda 1.</p> <p>Otro  ejemplo: <code>x  =  y  =  z  =  17;</code> Como  la  asociatividad  de  la  asignaci\u00f3n  es  de  derecha a izquierda, primero se asigna el valor 17 a <code>z</code>, luego a <code>y</code> y por \u00faltimo a <code>x</code>.Esto se puede realizar porque el operador de asignaci\u00f3n devuelve el valor asignado.</p> <p>Algunos operadores son no asociativos, por ejemplo, la expresi\u00f3n  <code>x &lt;= y &lt;= z</code> es inv\u00e1lida ya que  el  valor  devuelto  por  estos  operadores  es  de  un  tipo  diferente  (booleano)  al  de  los operandos que necesita (num\u00e9rico o car\u00e1cter).</p>"},{"location":"bloque_i/tema_1/page-6/#evaluacion-de-cortocircuito","title":"Evaluaci\u00f3n de cortocircuito","text":"<p>La evaluaci\u00f3n de cortocircuito denota la sem\u00e1ntica de algunos operadores booleanos en algunos lenguajes  de  programaci\u00f3n  en  los  cuales  si  con  la  evaluaci\u00f3n  de  la  primera  expresi\u00f3n  ya  se conoce el resultado, ya no se eval\u00faan el resto de expresiones. En Java, se utiliza la evaluaci\u00f3n de cortocircuito.</p> <p>Por ejemplo, veamos la siguiente expresi\u00f3n que utiliza operadores <code>AND</code>:</p> <pre><code>12 &lt; 9 &amp;&amp; 5 &gt; 1 &amp;&amp; 8 &lt;= 13\n</code></pre> <p>Se  eval\u00faa  la  primera  expresi\u00f3n <code>12  &lt;  9</code>   dando  false.  Como  el  resultado  va  a  ser  false independientemente del resultado de la segunda y tercera expresi\u00f3n, entonces no se eval\u00faan ni la segunda <code>5 &gt; 1</code> ni la tercera expresi\u00f3n <code>8&lt;= 13</code>, sino que solamente se eval\u00faa la primera, dando como resultado false. Lo mismo ocurre con el operador <code>OR</code>:</p> <pre><code>8 &lt;= 13 || 12 &lt; 9 || 5 &gt; 1\n</code></pre> <p>Se  eval\u00faa  la  primera  expresi\u00f3n <code>8  &lt;=  13</code>   dando true.  Como  el  resultado  va  a  ser  true independientemente del resultado de la segunda y tercera expresi\u00f3n, entonces no se eval\u00faan ni la segunda <code>12 &lt; 9</code> ni la tercera expresi\u00f3n <code>5 &gt; 1</code>, sino que solamente se eval\u00faa la primera, dando como resultado true.</p> Ejercicio 1 <p>Suponiendo realizadas las siguientes sentencias de asignaci\u00f3n: lado1 = 3; precio = 325,6; lado2 = 4; comprar = false; hipotenusa = 5; ch = '7'. Determinar cu\u00e1les de las expresiones siguientes dan un resultado booleano y cu\u00e1les no. Para aquellas que produzcan un resultado booleano determinar si el resultado es verdadero o falso. Para las que no lo sean, explicar la raz\u00f3n. Indicar tambi\u00e9n si existe alguna expresi\u00f3n err\u00f3nea, y crea una aplicaci\u00f3n Java para comprobar los resultados.</p> <ol> <li>5 * precio - 1.50</li> <li>(precio &lt; 300 + 0.1 * precio) ||comprar</li> <li>sqrt(lado1) + sqrt(lado2) = sqrt(hipotenusa)</li> <li>(!comprar) &amp;&amp; (precio + 125.3)</li> <li>(ch &lt;= 'A') &amp;&amp; comprar</li> <li>ch = '7' || !comprar</li> </ol> Ejercicio 2 <p>Calcula el resultado de las siguientes expresiones de forma manual, y luego creando un programa JAVA:</p> <ol> <li>3 * 5 - 4 / 2</li> <li>3 - (3*5)2 / 4</li> <li>32 - 5 * 2</li> <li>7 - 4 * 2 - 5 * 2</li> <li>5 + 4 &lt; 7 + 8</li> <li>4 &lt; 5 * 4 / 2 - 7</li> <li>3 + 6 * 14</li> <li>8 + 7 * 3 + 4 * 6</li> <li>-4 * 7 + 23 / 4 - 5</li> <li>12 + 3 * 7 + 5 * 4</li> <li>!(4 &gt; 6)</li> <li>73 / 2 + 6</li> </ol> Ejercicio 3 <p>Dados los siguientes valores para las variables booleanas a,b y c (a = true, b = false y c = true), evaluar las expresiones que aparecen a continuaci\u00f3n y crear un programa JAVA para comprobar las soluciones:</p> <ol> <li>a &amp;&amp; b || a &amp;&amp; c</li> <li>(a || b) &amp;&amp; (!a || c)</li> <li>a || b &amp;&amp; c</li> <li>!(a || b) &amp;&amp; c</li> </ol> Ejercicio 4 <p>Dado los siguientes valores de las variables x, y, j y k, a\u00f1adir los par\u00e9ntesis que sean necesarios para que las expresiones que las siguen eval\u00faen a verdadero: x = 10; y = 19; j = true; k = false.</p> <ol> <li>x == y || j</li> <li>x &gt;= y || x &lt;=y &amp;&amp; j</li> <li>!j || j</li> <li>!k &amp;&amp; k</li> </ol> Ejercicio 5 <p>Sea n un dato de tipo Entero que suponemos positivo. Empareja las expresiones con la descripci\u00f3n que les corresponda:</p> <p>a) El mayor n\u00famero par no superior a n. b) El primer n\u00famero par mayor o igual que n c) El primer impar mayor o igual que n</p> <p>1) (n / 2)*2 2) n + (n+1) % 2 3) ((n+1)/2)*2</p>"},{"location":"bloque_i/tema_1/page-7/","title":"7 Introducci\u00f3n a las funciones","text":""},{"location":"bloque_i/tema_1/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ol> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ol>"},{"location":"bloque_i/tema_1/page-7/#construccion","title":"Construcci\u00f3n","text":"<p>Una funci\u00f3n se construye de la siguiente manera:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro\nnombre_par\u00e1metro, ... ) {\ninstrucciones\nreturn expresi\u00f3n;\n}\n</code></pre> <ul> <li>modificador_acceso: es la visibilidad que posee la funci\u00f3n (Lo veremos m\u00e1s adelante. De momento, lo utilizaremos como public).</li> <li>tipo_resultado: es el tipo del resultado que devuelve la funci\u00f3n.</li> <li>nombre_funci\u00f3n:  es  el  nombre  que  identifica  a  la  funci\u00f3n.  Utiliza  la  notaci\u00f3n lowerCamelCase. Ejemplo: imprimirResultadoDecimal.</li> <li>tipo_par\u00e1metro nombre_par\u00e1metro,...:  puede  ocurrir  que  la  funci\u00f3n  necesite  ciertos valores para efectuar la misi\u00f3n para la que ha sido creada. Por ejemplo, la funci\u00f3n suma necesitar\u00eda  los  valores  que  tiene  que  sumar.  En  este  caso,  se  deben  indicar  cada  uno  de dichos  valores  con  sus  tipos  correspondientes. A  estos  valores  se  les  conoce como par\u00e1metros  de  la  funci\u00f3n.  Si  la  funci\u00f3n  no  necesita  par\u00e1metros,  entonces  solamente se ponen los par\u00e9ntesis:  <code>nombre_funcion( )</code></li> </ul> <p>A todo esto se le conoce como la firma (signature) de la funci\u00f3n:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro\nnombre_par\u00e1metro, ... )\n</code></pre> <ul> <li>instrucciones: instrucciones que conforman el algoritmo de la funci\u00f3n, para que realice la misi\u00f3n para la que ha sido creada.</li> <li>return expresi\u00f3n;: el return es el que nos devuelve el resultado, por lo tanto la expresi\u00f3n que  acompa\u00f1a  al  return  tiene  que  devolver  un  valor  correspondiente  al  tipo_resultado indicado en la firma de la funci\u00f3n.</li> </ul> <p>Ejemplo de funci\u00f3n con dos par\u00e1metros:</p> <pre><code>public static int add(int sum1,int sum2) {\nreturn sum1+sum2;\n}\n</code></pre> <p>Puede  ser  tambi\u00e9n  que  haya  m\u00e1s  de  un  return.  En  ese  caso,  el  flujo  de  ejecuci\u00f3n  abandona  la funci\u00f3n en cuanto ejecute el primer return. Ejemplo:</p> <pre><code>public static boolean isPar(int n){\nif(n%2==0){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n</code></pre> <p>En  el  caso  de  que  estemos  definiendo  un  procedimiento,  no  tendremos  return  ya  que  no devuelve ning\u00fan resultado y el tipo_resultado es void. Como por ejemplo <code>System.out.println</code>, que escribe en pantalla lo que recibe por par\u00e1metro pero no devuelve nada.</p>"},{"location":"bloque_i/tema_1/page-7/#llamada-a-la-funcion","title":"Llamada a la funci\u00f3n","text":"<p>Una  funci\u00f3n  permite  que  reutilicemos  un  algoritmo  ya  que  se  puede  utilizar  cuando  nos  haga falta.  Para  ello,  solamente  tendremos  que  llamar  a  la  funci\u00f3n  por  su  nombre  y  pasarle  los par\u00e1metros en el mismo orden que se han definido y pertenecientes al mismo tipo de dato. En la llamada, dichos par\u00e1metros se llaman argumentos.</p> <pre><code>public class Functions {\npublic static void main(String[] args) {\nboolean par;\nint result;\npar = isPar(5);//(1)!\nSystem.out.println(par);//(2)!\npar = isPar(4);//(3)!\nSystem.out.println(par);//(4)!\nresult = add(5, 2);//(5)!\nSystem.out.println(result);//(6)!\n}\npublic static boolean isPar(int n) {\nif (n % 2 == 0) {\nreturn true;\n} else {\nreturn false;\n}\n}\npublic static int add(int sum1, int sum2) {\nreturn sum1 + sum2;\n}\n}\n</code></pre> <ol> <li>Se llama a la funci\u00f3n isPar con un valor de 5 en el argumento</li> <li>Mostrar\u00e1 false</li> <li>Se llama a la funci\u00f3n isPar con un valor de 4 en el argumento</li> <li>Mostrar\u00e1 true</li> <li>Se llama a la funci\u00f3n add con los valores 5 y 2 en los argumentos</li> <li>Mostrar\u00e1 7</li> </ol>"},{"location":"bloque_i/tema_1/page-8/","title":"8 Tipos enumerados simples","text":""},{"location":"bloque_i/tema_1/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Los tipos enumerados sirven para restringir el contenido de una variable a una serie de valores predefinidos. Esto suele ayudar a reducir los errores en nuestro c\u00f3digo.</p> <p>En  las  versiones  anteriores  a  la  versi\u00f3n  5  de  Java  no  exist\u00edan  los  tipos  de  datos  enumerados  con  lo  que deb\u00edamos usar constantes de la siguiente forma:</p> <pre><code>final String RED_COLOR = \"rojo\";\nfinal String GREEN_COLOR = \"verde\";\nfinal String BLUE_COLOR = \"azul\";\n</code></pre> <p>A partir de la versi\u00f3n 5 de Java se incorporaron al lenguaje los tipos de datos enumerados con el objetivo de mejorar varios aspectos sobre el uso de las constantes. B\u00e1sicamente, un enumerado en Java es un conjunto fijo  y  relacionado  de  constantes  y deben  usarse  siempre  que  se  necesite  representar  un  conjunto  de constantes con esas caracter\u00edsticas.</p>"},{"location":"bloque_i/tema_1/page-8/#definicion","title":"Definici\u00f3n","text":"<p>Los  enumerados  se  definen  con  la  palabra  enum, el nombre del enumerado  y  luego  el  conjunto  de  las constantes, que por las convenciones del lenguaje se escriben en may\u00fascula. Ejemplo:</p> <pre><code>public enum DayOfWeek {\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n</code></pre> <p>En Java, los tipos enumerados se pueden definir dentro de una clase o como una clase independiente. Si varias clases  van  a  utilizar  el  enum,  entonces  se  define  como  una  clase  independiente.  Si  por  el  contrario,  es solamente una clase la que lo utiliza, entonces se define dentro de dicha clase.</p> <ul> <li> <p>Dentro de una clase:</p> <pre><code>public class SimpleEnum {\npublic enum DayOfWeek {\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\npublic static void main(String[] args) {\nDayOfWeek d;\nd = DayOfWeek.MONDAY;\nSystem.out.println(d == DayOfWeek.MONDAY ? true:false);\nd = DayOfWeek.SUNDAY;\nSystem.out.println(d == DayOfWeek.MONDAY ? true:false);\n}\n}\n</code></pre> </li> <li> <p>Como  una  clase  independiente: hay  que  colocarse  en  el  paquete donde se quiera crear el enum. Luego se pulsa el bot\u00f3n derecho del rat\u00f3n y New \u2192 Enum.</p> <pre><code>public enum DayOfWeeks {\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n</code></pre> <pre><code>public class EnumSimple {\npublic static void main(String[] args) {\nDayOfWeeks d;\nd = DayOfWeeks.MONDAY;\nSystem.out.println(d == DayOfWeeks.MONDAY ? true:false);\nd = DayOfWeeks.SUNDAY;\nSystem.out.println(d == DayOfWeeks.MONDAY ? true:false);\n}\n}\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_1/page-9/","title":"9 Iniciaci\u00f3n a la Programaci\u00f3n Orientada a Objetos","text":""},{"location":"bloque_i/tema_1/page-9/#introduccion","title":"Introducci\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es una t\u00e9cnica de programar aplicaciones basada en una serie de objetos independientes que se comunican entre s\u00ed.</p> <p>A Java se le considera un lenguaje orientado a objetos ya que siempre que se crea un programa en Java, por simple que sea, se necesita declarar una clase, y el concepto de clase pertenece a la programaci\u00f3n orientada a objetos.</p> <p>Un  objeto  es  un  elemento  del  programa  que  integra  sus  propios  datos  y  su  propio funcionamiento. Es decir, un objeto est\u00e1 formado por datos (atributos o propiedades) y por las funciones que es capaz de realizar el objeto (m\u00e9todos). Esta forma de programar se asemeja m\u00e1s al pensamiento humano. La cuesti\u00f3n es detectar adecuadamente los objetos necesarios para una aplicaci\u00f3n. De hecho hay que detectar las distintas clases de objetos.</p> <p>Una clase es lo que define a un tipo de objeto. Al definir una clase lo que se hace es indicar como funciona un determinado tipo de objeto. Luego, a partir de la clase, podremos crear objetos de esa  clase, es  decir,  la  clase  es  como  un  molde  a  partir  del  cual  se  crean  los  objetos  que pertenecen  a  ella.  Realmente  la  programaci\u00f3n  orientada  a  objetos  es  una  programaci\u00f3n orientada a clases. Es decir, lo que necesitamos programar es como funcionan las clases de objetos.</p> <p>Por ejemplo, una clase podr\u00eda ser la clase Coche. Cuando se defina esta clase, indicaremos los atributos o propiedades (como el color, modelo, marca, velocidad m\u00e1xima,...) y los m\u00e9todos (arrancar, parar, repostar, acelerar, frenar...). Todos los coches, es decir, todos los objetos de la clase Coche, tendr\u00e1n esas propiedades y esos m\u00e9todos. Para explicar la diferencia entre clase y objeto:</p> <ul> <li>la clase Coche representa a todos los coches.</li> <li>un coche concreto es un objeto, es decir, un ejemplar de una clase es un objeto. Tambi\u00e9n se le llama a los objetos instancias de la clase. Este t\u00e9rmino procede del ingl\u00e9s, instance, que realmente significa ejemplar.</li> </ul> <p>Por ejemplo, si quisi\u00e9ramos crear el juego del parch\u00eds en Java, una clase ser\u00eda la casilla, otra las fichas,  otra  el  dado,  etc.  En  el  caso  de  la  casilla,  se  definir\u00eda  la  clase  para  indicar  su funcionamiento y sus propiedades, y luego se crear\u00edan tantos objetos casilla como casillas tenga el juego. Lo mismo ocurrir\u00eda con las fichas, la clase ficha definir\u00eda las propiedades de la ficha (color  y  posici\u00f3n  por  ejemplo)  y  su  funcionamiento  mediante  sus  m\u00e9todos  (por  ejemplo  un m\u00e9todo ser\u00eda mover, otro llegar a la meta, etc), luego se crear\u00edan tantos objetos ficha como fichas tenga el juego.</p>"},{"location":"bloque_i/tema_1/page-9/#creacion-de-objetos","title":"Creaci\u00f3n de objetos","text":"<p>Una vez definida la clase, ya se pueden crear objetos de la misma. Para crear un objeto, hay que declarar una variable cuyo tipo ser\u00e1 la propia clase.</p> <p>Si por ejemplo defini\u00e9ramos una clase llamada Vehicle para modelar veh\u00edculos, para crear un objeto tendr\u00edamos que declarar una variable de tipo Vehicle:</p> <pre><code>Vehicle car; // car es una variable de tipo Vehicle\n</code></pre> <p>Una vez definida la variable, se le crea el objeto llamando a un m\u00e9todo que se llama constructor. Un constructor es un m\u00e9todo que se invoca cuando se crea un objeto y que sirve para inicializar los atributos del objeto y para realizar las acciones pertinentes que requiera el mismo para ser creado. El constructor tiene el mismo nombre que la clase y para invocarlo se utiliza el operador new.</p> <pre><code>car = new Vehicle(); // Vehicle() es un m\u00e9todo constructor\n</code></pre> <p>Tambi\u00e9n se puede hacer todo en la misma l\u00ednea:</p> <pre><code>Vehicle car = new Vehicle();\n</code></pre>"},{"location":"bloque_i/tema_1/page-9/#acceso-a-los-atributos-y-metodos-del-objeto","title":"Acceso a los atributos y m\u00e9todos del objeto","text":"<p>Una  vez  creado  el  objeto,  se  puede  acceder  a  sus  atributos  de  la  siguiente  manera: <code>objeto.atributo</code>.</p> <pre><code>car.wheelCount = 4; //(1)!\n</code></pre> <ol> <li>Se le asigna 4 al atributo de ruedas de la variable car.</li> </ol> <p>Los m\u00e9todos se utilizan de la misma forma que los atributos, a excepci\u00f3n de que los m\u00e9todos poseen  siempre  par\u00e9ntesis  ya  que  son  funciones  que  pertenecen  a  un  objeto: <code>objeto.m\u00e9todo(argumentos)</code>.</p> <pre><code>car.accelerate(30); //(1)!\n</code></pre> <ol> <li>El coche incrementa su velocidad en 30. Es decir, si iba a 90km/h, despu\u00e9s de ejecutar el m\u00e9todo, el coche va a 120km/h.</li> </ol>"},{"location":"bloque_i/tema_1/page-9/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<p>Java admite sobrecargar los m\u00e9todos, es decir, crear distintas variantes del mismo m\u00e9todo con el mismo nombre pero que se diferencien en el orden, tipo o n\u00famero de los par\u00e1metros. Por ejemplo, tenemos el m\u00e9todo para <code>sumar  add(int x,double y)</code>:</p> <ul> <li>S\u00ed  podr\u00edamos  definir  el  m\u00e9todo <code>add(double  x,int  y)</code> porque  var\u00eda  el  orden  de  los par\u00e1metros.</li> </ul> <p>Otro ejemplo donde tenemos el m\u00e9todo <code>add(int x,int y)</code>:</p> <ul> <li>No  podr\u00edamos  definir  otro  m\u00e9todo <code>add(int  a,int  b)</code>porque  no  var\u00eda  el  tipo  ni  el n\u00famero de par\u00e1metros.</li> <li>S\u00ed podr\u00edamos definir <code>add(int a)  y  add(int  a,int  b,int  c)</code> porque  el  n\u00famero  de par\u00e1metros var\u00eda. Tambi\u00e9n podr\u00edamos definir `add(int x,double y)p porque aunque no var\u00ede el n\u00famero de par\u00e1metros, s\u00ed var\u00eda uno de los tipos.</li> </ul>"},{"location":"bloque_i/tema_1/page-9/#metodos-estaticos-y-dinamicos","title":"M\u00e9todos est\u00e1ticos y din\u00e1micos","text":"<p>A los m\u00e9todos asociados a los objetos se les conoce como m\u00e9todos din\u00e1micos. Pero puede ocurrir que tengamos m\u00e9todos que no est\u00e9n asociados a ning\u00fan objeto, por ejemplo, m\u00e9todos de utilidad general. Dichos m\u00e9todos se les conoce como m\u00e9todos est\u00e1ticos y se definen con la palabra static. Al no estar asociados a ning\u00fan objeto, se utilizan con el nombre de la clase: <code>Clase.metodoEst\u00e1tico(argumentos)</code>. Ejemplos de llamadas a m\u00e9todos din\u00e1micos y est\u00e1ticos:</p> <ul> <li>Llamada a m\u00e9todo din\u00e1mico: <code>car.accelerate(30);</code></li> <li>Llamada a m\u00e9todo est\u00e1tico: <code>Math.pow(2,3);</code></li> </ul>"},{"location":"bloque_i/tema_1/page-9/#api-de-java","title":"Api de Java","text":"<p>La API de Java es una interfaz de programaci\u00f3n de aplicaciones (API, por sus siglas del ingl\u00e9s: Application Programming Interface) provista por los creadores del lenguaje de programaci\u00f3n Java, que da a los programadores los medios para desarrollar aplicaciones Java.</p> <p>Al instalar Java (el paquete JDK) en nuestro ordenador, adem\u00e1s del compilador y la m\u00e1quina virtual de Java se instalan bastantes m\u00e1s elementos. Entre ellos, una cantidad muy importante de clases que ofrece la multinacional desarrolladora de Java y que est\u00e1n a disposici\u00f3n de todos los programadores listas para ser usadas.  Estas clases junto a otros elementos forman lo que se denomina API de Java.</p> <p>Los paquetes donde se encuentran dichas clases los podemos encontrar en https://docs.oracle.com/  \u2192 Java \u2192 Java SE Documentation \u2192 JDK  de  la  versi\u00f3n  deseada  \u2192  Specifications \u2192 API Documentation \u2192 Module: java.base.</p> <p>Otra manera de acceder r\u00e1pido es poniendo en un buscador de Internet <code>Api  Java  Version Clase</code>, como por ejemplo: Api Java 12 Math.</p>"},{"location":"bloque_i/tema_1/page-9/#la-clase-math","title":"La clase Math","text":"<p>La  clase  Math  contiene  los  m\u00e9todos  para  realizar  operaciones  matem\u00e1ticas  b\u00e1sicas,  como potencias, logaritmos, ra\u00edces cuadradas y funciones trigonom\u00e9tricas.</p> <p>Si observamos esta clase en la API, todos los m\u00e9todos tienen al principio la palabra static, ya que son m\u00e9todos est\u00e1ticos porque son funciones de utilidad que no se utilizan asociadas a un objeto. Despu\u00e9s de la palabra static nos encontramos con el tipo del resultado que devuelve el m\u00e9todo. Y  a  continuaci\u00f3n,  nos  encontramos  con  el  nombre  del  m\u00e9todo  y  sus  par\u00e1metros.  Ejemplo:</p> <p><code>static double abs(double a)</code>Esto se conoce como la firma del m\u00e9todo (signature en ingl\u00e9s).</p> <pre><code>public class MathClass {\npublic static void main(String[] args) {\nSystem.out.println(Math.abs(-3.2));\nSystem.out.println(Math.pow(2,3));\nSystem.out.println(Math.sqrt(16));\nSystem.out.println(Math.min(20,5));\n}\n}\n</code></pre> Ejercicio 1 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Math. Realiza un programa Java donde uses cada uno de esos m\u00e9todos realizando comentarios explicando cada uno de ellos. (Hacer ejemplo con n\u00fameros positivos y negativos)</p> <ol> <li><code>static float abs(float a)</code></li> <li><code>static int addExact(int x, int y)</code></li> <li><code>static double ceil(double a)</code></li> <li><code>static int decrementExact(int a)</code></li> <li><code>static double floor(double a)</code></li> <li><code>static int incrementExact(int a)</code></li> <li><code>static double max(double a, double b)</code></li> <li><code>static int multiplyExact(int x, int y)</code></li> <li><code>static int negateExact(int a)</code></li> </ol> <p>Obs\u00e9rvese en la API la sobrecarga de los m\u00e9todos abs y min.</p>"},{"location":"bloque_i/tema_1/page-9/#la-clase-string","title":"La clase String","text":"<p>El texto es uno de los tipos de datos m\u00e1s importantes y por ello Java lo trata de manera especial. Para Java, las cadenas de texto son objetos especiales. Los textos deben manejarse creando objetos de tipo String. Las cadenas se pueden inicializar de dos maneras:</p> <ul> <li>Usando el operador asignaci\u00f3n: <code>String s=\"hola\";</code></li> <li>Usando el constructor: <code>String s=new String(\"hola\");</code></li> </ul> <p>Los literales cadena se escriben entre comillas dobles: <code>\"Esto es un literal cadena\"</code>.</p> <p>En java existe tambi\u00e9n la cadena vac\u00eda o nula, es decir, una cadena sin ning\u00fan car\u00e1cter. Ejemplo: <code>String s=\"\";</code> A la variable s se le est\u00e1 asignando la cadena vac\u00eda o nula.</p> <p>Como vimos en el tema 1.5 Operadores, el operador concatenaci\u00f3n <code>+</code>  es un operador binario que devuelve una cadena resultado de concatenar las dos cadenas que act\u00faan como operandos. Si s\u00f3lo uno de los operandos es de tipo cadena, el otro operando se convierte impl\u00edcitamente en tipo cadena.</p> <p>Obs\u00e9rvese en la API el m\u00e9todo valueOf: es est\u00e1tico y est\u00e1 sobrecargado. Sirve para obtener la representaci\u00f3n String de un valor u objeto.</p> <pre><code>public class StringClass {\npublic static void main(String[] args) {\nint i = 100;\nString string1, string2, string3, string4;\nstring1 = \"Esto es un literal cadena\"; //(1)!\nSystem.out.println(string1);\nSystem.out.println(string1 + \" al cual le hemos concatenado este literal cadena\"); //(2)!\nstring2 = \"hola\";\nstring3 = \" que tal\";\nstring4 = string2 + string3;\nSystem.out.println(string4);\nSystem.out.println(i + 100); //(3)!\nSystem.out.println(String.valueOf(i) + 100); //(4)!\n}\n}\n</code></pre> <ol> <li>Se le da el valor inicial con el operador asignaci\u00f3n =</li> <li>Se concatena otra cadena con el operador +</li> <li>suma de enteros</li> <li>Concatenaci\u00f3n de cadenas</li> </ol> <p>Otros m\u00e9todos de las cadenas muy \u00fatiles son:</p> <ul> <li>charAt: devuelve el car\u00e1cter de la cadena del especificado \u00edndice. Dicho \u00edndice empieza en cero, es decir, con el cero se obtiene el primer car\u00e1cter de la cadena.</li> <li>length: devuelve la longitud de la cadena.</li> <li>equals: compara si dos cadenas son iguales.</li> </ul> <pre><code>public class StringClass2 {\npublic static void main(String[] args) {\nString string = \"hola\";\nSystem.out.println(string.charAt(0)); //h\nSystem.out.println(string.charAt(1)); //o\nSystem.out.println(string.charAt(2)); //l\nSystem.out.println(string.charAt(3)); //a\nSystem.out.println(string.length()); //4\nSystem.out.println(string.equals(\"hola\")); //true\nSystem.out.println(string.equals(\"hola\")); //false\n}\n}\n</code></pre> Ejercicio 2 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase String. Realiza un programa Java con ejemplos de cada uno de ellos comentando su uso.</p> <ol> <li><code>char charAt(int index)</code></li> <li><code>int length()</code></li> <li><code>boolean equals(Object anObject)</code><ul> <li>Compara dos cadenas</li> <li>Compara tres cadenas</li> </ul> </li> <li><code>int codePointAt(int index)</code></li> <li><code>int compareTo(String anotherString)</code></li> <li><code>int compareToIgnoreCase(String str)</code></li> <li><code>String concat(String str)</code></li> <li><code>boolean endsWith(String suffix)</code></li> <li><code>boolean equalsIgnoreCase(String anotherString)</code></li> <li><code>int indexOf(int ch)</code></li> <li><code>int indexOf(int ch, int fromIndex)</code></li> <li><code>boolean isEmpty()</code></li> <li><code>int lastIndexOf(int ch)</code></li> <li><code>int lastIndexOf(int ch, int fromIndex)</code></li> <li><code>String replace(char oldChar, char newChar)</code></li> <li><code>String toUpperCase()</code></li> <li><code>String trim()</code></li> </ol>"},{"location":"bloque_i/tema_1/page-9/#wrappers","title":"Wrappers","text":"<p>En ocasiones es muy conveniente poder tratar los datos primitivos (int, boolean, etc.) como objetos. Pero los datos primitivos no son objetos. Para resolver esta situaci\u00f3n, la API de Java incorpora las clases envoltorio (wrapper class), que no son m\u00e1s que dotar a los datos primitivos con  un  envoltorio  que  permita  tratarlos  como  objetos.  Las  clases  envoltorio  proporcionan m\u00e9todos de utilidad para la manipulaci\u00f3n de datos primitivos (conversiones de / hacia datos primitivos, conversiones a String, etc).</p> <p>La siguiente tabla muestra los tipos primitivos y sus wrappers asociados:</p> Tipo primitivo Wrapper asociado byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean <p>Todos estos wrappers los encontraremos en la API de Java. Por ejemplo, si observamos en la API la clase Integer, podemos ver la siguiente firma de m\u00e9todo: <code>static int parseInt(String s)</code> que convierte la cadena pasada por par\u00e1metro a entero.</p> <pre><code>public class IntegerClass {\npublic static void main(String[] args) {\nInteger integer1, integer2;\nint i;\ninteger1 = 5;\nSystem.out.println(integer1);\ni = Integer.parseInt(\"7\"); //(1)!\nSystem.out.println(i);\ninteger2 = Integer.valueOf(i); //(2)!\nSystem.out.println(integer2);\ni = integer1.intValue(); //(3)!\nSystem.out.println(i);\n}\n</code></pre> <ol> <li>Convierte la cadena a int. M\u00e9todo est\u00e1tico por lo que se utiliza con Integer</li> <li>Convierte el int a Integer. Tambi\u00e9n es est\u00e1tico</li> <li>Convierte el integer a int. M\u00e9todo din\u00e1mico por lo que se utiliza con el objeto</li> </ol>"},{"location":"bloque_i/tema_1/page-9/#encadenamiento-de-llamadas-a-metodos","title":"Encadenamiento de llamadas a m\u00e9todos","text":"<p>Se emplea cuando invocamos a un m\u00e9todo de un objeto que nos devuelve como resultado otro objeto al que podemos volver a invocar otro m\u00e9todo y as\u00ed encadenar varias operaciones.</p> <pre><code>public class CallsToMethods {\npublic void showCallsToMethods(){\nBoolean b;\nString string;\nstring = \"EntornoDeDesarrollo\";\nSystem.out.println(string.substring(10).toUpperCase()); // DESARROLLO\nb = Boolean.TRUE;\nSystem.out.println(b.toString().charAt(2)); //u\n}\npublic static void main(String[] args) {\nnew CallsToMethods().showCallsToMethods();\n}\n}\n</code></pre> <p>En este ejemplo, el m\u00e9todo <code>substring(10)</code>  est\u00e1 devolviendo una subcadena de la cadena string a partir del car\u00e1cter 10 empezando en 0, es decir, \"Desarrollo\", al que se le invoca luego el m\u00e9todo <code>toUpperCase</code> devolviendo como resultado la cadena \"DESARROLLO\".</p> <p>Y el m\u00e9todo <code>toString()</code> de la variable b de tipo Boolean est\u00e1 devolviendo la cadena \"true\" a la que se le encadena el m\u00e9todo <code>charAt(2)</code>  devolviendo el car\u00e1cter 'u'.</p> Ejercicio 3 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Character. Realiza un programa Java donde realices ejemplos us\u00e1ndolos y comentando su uso.</p> <ol> <li><code>char charValue()</code></li> <li><code>static int compare(char x, char y)</code></li> <li><code>boolean equals(Object obj)</code></li> <li><code>static boolean isDigit(char ch)</code></li> <li><code>static boolean isLetter(char ch)</code></li> <li><code>static boolean isLowerCase(char ch)</code></li> <li><code>static boolean isSpaceChar(char ch)</code></li> <li><code>static boolean isUpperCase(char ch)</code></li> <li><code>static char toLowerCase(char ch)</code></li> <li><code>static char toUpperCase(char ch)</code></li> <li><code>static Character valueOf(char c)</code></li> </ol> Ejercicio 4 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Integer. Realiza un programa Java donde realices ejemplos us\u00e1ndolos y comentando su uso.</p> <ol> <li><code>byte byteValue()</code></li> <li><code>static int compare(int x, int y)</code></li> <li><code>int compareTo(Integer anotherInteger)</code></li> <li><code>double doubleValue()</code></li> <li><code>boolean equals(Object obj)</code></li> <li><code>int intValue()</code></li> <li><code>static int max(int a, int b)</code></li> <li><code>static int min(int a, int b)</code></li> <li><code>static int parseInt(String s)</code></li> <li><code>static int sum(int a, int b)</code></li> <li><code>static Integer valueOf(int i)</code></li> <li><code>static Integer valueOf(String s)</code></li> </ol> Ejercicio 5 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Double. Realiza un programa Java donde realices ejemplos us\u00e1ndolos y comentando su uso.</p> <ol> <li><code>static int compare(double d1, double d2)</code></li> <li><code>int compareTo(Double anotherDouble)</code></li> <li><code>double doubleValue()</code></li> <li><code>boolean equals(Object obj)</code></li> <li><code>float floatValue()</code></li> <li><code>int intValue()</code></li> <li><code>boolean isInfinite()</code></li> <li><code>static boolean isInfinite(double v)</code></li> <li><code>boolean isNaN()</code></li> <li><code>static boolean isNaN(double v)</code></li> <li><code>static double max(double a, double b)</code></li> <li><code>static double min(double a, double b)</code></li> <li><code>static double parseDouble(String s)</code></li> <li><code>static double sum(double a, double b)</code></li> <li><code>static Double valueOf(double i)</code></li> <li><code>static Double valueOf(String s)</code></li> </ol> Ejercicio 6 <p>Declara un booleano, un entero, un car\u00e1cter y un decimal, inicial\u00edzalas. Luego, transforma todas las variables a variable cadena. Luego, obtener una cadena resultante de concatenar todas las cadenas obtenidas anteriormente. Muestra esta cadena resultante por pantalla.</p>"},{"location":"bloque_i/tema_2/page-1/","title":"1 Condicionales","text":""},{"location":"bloque_i/tema_2/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Los  programas  se  construyen  para  procesar  datos,  manipul\u00e1ndolos  de  formas diferentes  dependiendo  de  los  valores  que  tengan.  Los  lenguajes  de  programaci\u00f3n deben proveer estructuras que les permitan a los  programadores controlar el flujo de ejecuci\u00f3n  de  un  programa  dependiendo  de  los  datos  que  procesan.  Para  ello,  se incluyen las sentencias de control de flujo, que alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</p> <p>La programaci\u00f3n estructurada es un paradigma de programaci\u00f3n orientado a mejorar la claridad, calidad y tiempo  de  desarrollo  de  un  programa  de  computadora  recurriendo  \u00fanicamente  a subrutinas y tres estructuras b\u00e1sicas: secuencia, sentencias condicionales y bucles.</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo  principal,  el  cual  permite  resolver  una  tarea  espec\u00edfica.  Por  ejemplo,  los m\u00e9todos en Java.</p>"},{"location":"bloque_i/tema_2/page-1/#secuencia","title":"Secuencia","text":"<p>La  ejecuci\u00f3n  secuencial  es  el  m\u00e1s  b\u00e1sico  de  los  mecanismos  de  control  de  flujo  y consiste en la ejecuci\u00f3n de instrucciones en el orden en que se encuentran en el c\u00f3digo fuente del programa.</p> <p>Hasta  ahora  las  instrucciones  que  hemos  visto,  son  instrucciones  que  se  ejecutan secuencialmente; es decir, podemos saber lo que hace el programa leyendo las l\u00edneas de izquierda a derecha y de arriba abajo.</p>"},{"location":"bloque_i/tema_2/page-1/#sentencias-condicionales","title":"Sentencias condicionales","text":"<p>La sentencia condicional consiste en ejecutar instrucciones diferentes dependiendo del resultado de evaluar una expresi\u00f3n l\u00f3gica. Una expresi\u00f3n l\u00f3gica es cualquier tipo de expresi\u00f3n que devuelva un resultado booleano (true o false). Las expresiones l\u00f3gicas se construyen  por  medio  de  variables  booleanas  o  bien  a  trav\u00e9s  de  los  operadores relacionales (==, &gt;, &lt;,...) y/o l\u00f3gicos (&amp;&amp;,||, !).</p>"},{"location":"bloque_i/tema_2/page-1/#condicional-simple","title":"Condicional simple","text":"<p>Se ejecutan una serie de instrucciones en el caso de que la expresi\u00f3n l\u00f3gica sea verdadera:</p> EstructuraEjemplo <pre><code>if(expresi\u00f3nL\u00f3gica){\n// instrucciones\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class If {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint age;\nString name;\nSystem.out.print(\"Introduce tu nombre: \");\nname = keyboard.nextLine();\nSystem.out.print(\"Introduce tu edad: \");\nage = keyboard.nextInt();\nif(age &gt;= 18){\nSystem.out.printf(\"Bienvenido/a %s\\n\", name);\nSystem.out.println(\"Eres mayor de edad\");\n}\n}\n}\n</code></pre> Ejercicio 1 <p>Dada una cantidad, si es mayor que 1000, que muestre el 15% de dicha cantidad. Si no, que no haga nada.</p>"},{"location":"bloque_i/tema_2/page-1/#condicional-doble","title":"Condicional doble","text":"<p>Es igual que la anterior, s\u00f3lo que se a\u00f1ade un apartado else que contiene instrucciones que se ejecutar\u00e1n si la expresi\u00f3n evaluada por el if es falsa.</p> EstructuraEjemplo <pre><code>if(expresi\u00f3nL\u00f3gica){\n// instrucciones si la expresi\u00f3n l\u00f3gica es verdadera\n} else {\n// expresiones si la expresi\u00f3n l\u00f3gica es falsa\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class IfElse {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint age;\nString name;\nSystem.out.print(\"Introduce tu nombre: \");\nname = keyboard.nextLine();\nSystem.out.print(\"Introduce tu edad: \");\nage = keyboard.nextInt();\nSystem.out.printf(\"Bienvenido/a %s\\n\", name);\nif(age &gt;= 18){\nSystem.out.println(\"Eres mayor de edad\");\n} else {\nSystem.out.println(\"Eres menor de edad\");\n}\n}\n}\n</code></pre> Ejercicio 2 <p>Dada una edad, que te muestre por pantalla si es mayor de edad o no.</p> Ejercicio 3 <p>Dado un n\u00famero, indicar si es par o impar.</p> Ejercicio 4 <p>Pedir dos n\u00fameros por teclado e indicar si el primer n\u00famero es m\u00faltiplo del segundo.</p>"},{"location":"bloque_i/tema_2/page-1/#condicional-multiple","title":"Condicional M\u00faltiple","text":""},{"location":"bloque_i/tema_2/page-1/#anidacion","title":"Anidaci\u00f3n","text":"<p>Dentro  de  una  sentencia  if  se  puede  colocar  otra  sentencia  if.  A  esto  se  le  llama anidaci\u00f3n  y  permite  crear  programas  donde  se  valoren  expresiones  complejas.  La nueva sentencia puede ir tanto en la parte if como en la parte else.</p> <p>Las anidaciones se utilizan much\u00edsimo al programar. Solo hay que tener en cuenta que siempre se debe cerrar primero el \u00faltimo if que se abri\u00f3. Es muy importante tambi\u00e9n tabular el c\u00f3digo correctamente para que las anidaciones sean legibles.</p> <p>Ejemplo:</p> <pre><code>if(x == 1){\n// instrucciones\n} else {\nif(x == 2){\n// instrucciones\n} else {\nif(x == 3){\n// instrucciones\n}\n}\n}\n</code></pre> <p>Una forma m\u00e1s legible de escribir ese mismo c\u00f3digo dando lugar a la llamada estructura if-else-if ser\u00eda:</p> <pre><code>if(x == 1){\n// instrucciones\n} else if(x == 2){\n// instrucciones\n} else if(x == 3){\n// instrucciones\n}\n</code></pre> <p>Cuando  se  cumpla  alguna  de  las  condiciones,  se  ejecutan  sus  instrucciones correspondientes y despu\u00e9s ya se sale de la estructura if-else-if ya que las condiciones son autoexcluyentes, es decir, solamente se va a cumplir una. Por eso, no estar\u00eda bien hacer lo siguiente:</p> <pre><code>if(x == 1){ // Forma incorrecta de programar\n// instrucciones\n}\nif(x == 2){\n// instrucciones\n}\nif(x == 3){\n// instrucciones\n}\n</code></pre> <p>El motivo de que no sea adecuado es porque se pierde tiempo en comprobar todas las condiciones. Por ejemplo, si x vale 1, se ejecutan sus instrucciones correspondientes y luego se comprobar\u00eda si x vale 2, si x vale 3, etc. cuando no se va a cumplir ninguna m\u00e1s ya que si x vale 1 no puede valer ni 2 ni 3.</p> <pre><code>import java.util.Scanner;\npublic class IfElseIf {\npublic static void main(String[] args) {         Scanner keyboard = new Scanner(System.in);\nint age;\nSystem.out.print(\"Introduce tu edad: \");\nage = keyboard.nextInt();\nif (age &gt;= 18) {\nSystem.out.println(\"Eres mayor de edad\");\n} else if (age &gt;= 16 &amp;&amp; age &lt; 18) {\nSystem.out.println(\"Eres menor de edad pero tienes ciertos privilegios\");\n} else if (age &gt;= 14 &amp;&amp; age &lt; 16) {\nSystem.out.println(\"Eres menor de edad y adem\u00e1s no tienes privilegios\");\n} else {\nSystem.out.println(\"Eres menor de edad\");\n}     }\n}\n</code></pre> Ejercicio 5 <p>Dada una nota, que te muestre lo siguiente:</p> <ul> <li>0, 1, 2: Muy deficiente</li> <li>3, 4: Insuficiente</li> <li>5: Suficiente</li> <li>6: Bien</li> <li>7, 8: Notable</li> <li>9, 10: Sobresaliente</li> </ul> Ejercicio 6 <p>Hacer un programa que lea por teclado un n\u00famero entero y nos diga si el n\u00famero es positivo, negativo o cero.</p> Ejercicio 7 <p>Realiza un programa que lea tres n\u00fameros positivos y compruebe si son iguales. Por ejemplo: Si la entrada fuese 5 5 5, la salida deber\u00eda ser \u201chay tres n\u00fameros iguales a 5\u201d. Si la entrada fuese 4 6 4, la salida deber\u00eda ser \u201chay dos n\u00fameros iguales a 4\u201d. Si la entrada fuese 0 1 2, la salida deber\u00eda ser \u201cno hay n\u00fameros iguales\u201d.</p>"},{"location":"bloque_i/tema_2/page-1/#switch","title":"Switch","text":"<p>El cuerpo de una sentencia switch se conoce como bloque switch.</p> <p>Esta  sentencia  eval\u00faa  una  expresi\u00f3n  y  cada  case  contiene  un  posible  valor  del resultado  de  dicha  expresi\u00f3n;  si  efectivamente  el  resultado  equivale  a  ese  valor,  se ejecutan las instrucciones de ese case y de los siguientes.</p> <p>La instrucci\u00f3n break se utiliza para salir del switch. De tal modo que si queremos que para un determinado valor se ejecuten las instrucciones de un apartado case y solo las de ese apartado, entonces habr\u00e1 que finalizar ese case con un break. Cuando se alcanza una sentencia break, el switch termina y el flujo de control salta a la siguiente l\u00ednea que sigue a la sentencia switch.</p> <p>Fall through condition (condici\u00f3n de ca\u00edda): esta condici\u00f3n se produce en la sentencia switch cuando no se utiliza  break en un case y causa la ejecuci\u00f3n de los siguientes case hasta que no se produce un break o se sale de la sentencia switch.</p> <p>El  bloque  default  sirve  para  ejecutar  instrucciones  para  los  casos  en  los  que  la expresi\u00f3n no se ajuste a ning\u00fan case. T\u00e9cnicamente, el break del default no es necesario porque el flujo se sale de la sentencia switch, pero se recomienda utilizarlo para que la modificaci\u00f3n del c\u00f3digo sea m\u00e1s f\u00e1cil y menos propensa a errores.</p> <p>Funciona con los tipos de datos primitivos, con los tipos enumerados, con las cadenas(a partir de Java 7) y con los wrappers.</p> EstructuraEjemplo 1Ejemplo 2 <pre><code>switch(expresi\u00f3n) {\ncase valor1 :\ninstrucciones\nbreak; // opcional\ncase valor2 :\ninstrucciones\nbreak; // opcional\n//....\n//....\ndefault : // opcional\ninstrucciones\nbreak; // opcional\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class Switch1 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint weekday;\nSystem.out.print(\"Introduce un n\u00famero del 1 al 7 correspondiente al d\u00eda de la semana: \");\nweekday = keyboard.nextInt();\nswitch (weekday) {\ncase 1:\nSystem.out.println(\"Lunes\");\nbreak;\ncase 2:\nSystem.out.println(\"Martes\");\nbreak;\ncase 3:\nSystem.out.println(\"Mi\u00e9rcoles\");\nbreak;\ncase 4:\nSystem.out.println(\"Jueves\");\nbreak;\ncase 5:\nSystem.out.println(\"Viernes\");\nbreak;\ncase 6:\nSystem.out.println(\"S\u00e1bado\");\nbreak;\ncase 7:\nSystem.out.println(\"Domingo\");\nbreak;\ndefault:\nSystem.out.println(\"D\u00eda incorrecto\");\nbreak;\n}\n}\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class Switch2 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint month, year, numDays = 0;\nSystem.out.print(\"Introduce un n\u00famero del 1 al 12 correspondiente a un mes: \");\nmonth = keyboard.nextInt();\nSystem.out.print(\"Introduce un a\u00f1o: \");\nyear = keyboard.nextInt();\nswitch (month) {\ncase 1:\ncase 3:\ncase 5:\ncase 7:\ncase 8:\ncase 10:\ncase 12:\nnumDays = 31;\nbreak;\ncase 4:\ncase 6:\ncase 9:\ncase 11:\nnumDays = 30;\nbreak;\ncase 2://Se calcula si es un a\u00f1o bisiesto\nif (((year % 4 == 0) &amp;&amp; !(year % 100 == 0)) || (year % 400 == 0)) {\nnumDays = 29;\n} else {\nnumDays = 28;\n}\nbreak;\ndefault:\nSystem.out.println(\"Mes inv\u00e1lido\");\nbreak;\n}\nif (month &gt;= 1 &amp;&amp; month &lt;= 12) {\nSystem.out.printf(\"N\u00famero de d\u00edas del mes %d del a\u00f1o %d: %d\", month, year, numDays);\n}\n}\n}\n</code></pre> <p>La  decisi\u00f3n  de  utilizar  sentencias  if-then-else  o  una  sentencia  switch  se  basa  en  la legibilidad y en la expresi\u00f3n que la sentencia est\u00e1 probando. Una sentencia if-then-else puede comprobar expresiones basadas en rangos de valores o condiciones, mientras que una sentencia switch comprueba expresiones basadas s\u00f3lo en un \u00fanico valor.</p> Ejercicio 8 <p>Realiza el ejercicio 4, haciendo uso de la estructura Switch.</p>"},{"location":"bloque_i/tema_2/page-1/#nuevo-switch","title":"Nuevo Switch","text":"<p>Desde la versi\u00f3n de Java 14, hay una nueva estructura de la sentencia switch, que la hace m\u00e1s \"elegante\" pero sobretodo legible.</p> EstructuraEjemplo 1Ejemplo 2 <pre><code>switch(expresi\u00f3n){\ncase valor1 -&gt; /* instrucci\u00f3n de una l\u00ednea*/;\ncase valor2 -&gt; {\n// instrucciones de m\u00e1s de una l\u00ednea\n}\n// ...\ndefault -&gt; /* instrucci\u00f3n de una l\u00ednea */;\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class NewSwitch1 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint weekday;\nSystem.out.print(\"Introduce un n\u00famero del 1 al 7 correspondiente al d\u00eda de la semana: \");\nweekday = keyboard.nextInt();\nswitch (weekday) {\ncase 1 -&gt; System.out.println(\"Lunes\");\ncase 2 -&gt; System.out.println(\"Martes\");\ncase 3 -&gt; System.out.println(\"Mi\u00e9rcoles\");\ncase 4 -&gt; System.out.println(\"Jueves\");\ncase 5 -&gt; System.out.println(\"Viernes\");\ncase 6 -&gt; System.out.println(\"S\u00e1bado\");\ncase 7 -&gt; System.out.println(\"Domingo\");\ndefault -&gt; System.out.println(\"D\u00eda incorrecto\");\n}\n}\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class NewSwitch2 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint month, year, numDays = 0;\nSystem.out.print(\"Introduce un n\u00famero del 1 al 12 correspondiente a un mes: \");\nmonth = keyboard.nextInt();\nSystem.out.print(\"Introduce un a\u00f1o: \");\nyear = keyboard.nextInt();\nswitch (month) {\ncase 1, 3, 5, 7, 8, 10, 12 -&gt; numDays = 31;\ncase 4, 6, 9, 11 -&gt; numDays = 30;\ncase 2 -&gt; {\n//Se calcula si es un a\u00f1o bisiesto\nif (((year % 4 == 0) &amp;&amp; !(year % 100 == 0)) || (year % 400 == 0)) {\nnumDays = 29;\n} else {\nnumDays = 28;\n}\n}\ndefault -&gt; System.out.println(\"Mes inv\u00e1lido\");\n}\nif (month &gt;= 1 &amp;&amp; month &lt;= 12) {\nSystem.out.printf(\"N\u00famero de d\u00edas del mes %d del a\u00f1o %d: %d\", month, year, numDays);\n}\n}\n}\n</code></pre> Ejercicio 9 <p>Realiza el ejercicio 4, haciendo uso de la nueva estructura Switch</p>"},{"location":"bloque_i/tema_2/page-1/#ejercicios","title":"Ejercicios","text":"Ejercicio 10 <p>Realiza un programa que calcule el precio de un billete de ida y vuelta por avi\u00f3n, conociendo la distancia a recorrer, el n\u00famero de d\u00edas de estancia y sabiendo que si la distancia es superior a 1.000 Km y el n\u00famero de d\u00edas de estancia es superior a 7, la l\u00ednea a\u00e9rea le hace un descuento del 30 %. (Precio por kil\u00f3metro = 0,35 \u20ac).</p> Ejercicio 11 <p>Los empleados de una f\u00e1brica trabajan en dos turnos: diurno y nocturno. Se desea calcular el jornal diario de acuerdo con los siguientes tarifas: la tarifa de las horas diurnas es de 3 \u20ac por hora, mientras que el de las nocturnas es de 4,80 \u20ac po hora. Cuando se trata de un d\u00eda festivo, la tarifa se incrementa en 1,20 \u20ac por hora en el turno diurno y 1,80 \u20ac por hora en el nocturno.</p> Ejercicio 12 <p>Realiza un programa que dados tres n\u00fameros, los devuelva en orden ascendente.</p> Ejercicio 13 <p>Dada una cadena solicitada al usuario, obtener y mostrar uno de sus caracteres elegidos aleatoriamente. Mostrar tambi\u00e9n en qu\u00e9 posici\u00f3n se encuentra dicho car\u00e1cter.</p> Ejercicio 14 <p>Realiza un programa que saque una carta aleatoria de una baraja con 4 palos y 13 cartas por cada palo. Los palos son Picas \u2660, Corazones \u2665, Diamantes \u2666 y Tr\u00e9boles \u2663. Las 13 cartas por cada palo ir\u00e1n del as al diez y adem\u00e1s tres figuras: jota, reina y rey. Mostrar la carta incluyendo el s\u00edmbolo del palo(\u2660,\u2665,\u2666,\u2663).</p>"},{"location":"bloque_i/tema_2/page-2/","title":"2 Bucles","text":""},{"location":"bloque_i/tema_2/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>En programaci\u00f3n, un bucle o instrucci\u00f3n de control repetitiva (o iterativa)  permite  ejecutar  una  o m\u00e1s  instrucciones  varias  veces,  es  decir,  permite  ejecutar  un  bloque  de  instrucciones repetidamente, escribi\u00e9ndolas una sola vez en el programa, reduciendo de este modo el c\u00f3digo del mismo. Cada vuelta que da el bucle se conoce como iteraci\u00f3n.</p> <p>Las variables que se utilizan en los bucles pueden tener distintas funciones:</p> <ul> <li>\u00edndice: es una variable que apunta a un recurso concreto. En los bucles, apunta al n\u00famero de iteraci\u00f3n. Se suelen utilizar por convenio los identificadores de variables i, j y k.</li> <li>contador: cuenta cu\u00e1ntas veces ocurre algo.</li> <li>acumulador: acumula operaciones parciales.</li> </ul> <p>Las instrucciones b\u00e1sicas que permiten construir este tipo de estructuras son while, do-while y for.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-while","title":"Bucle while","text":"<p>El bucle while agrupa instrucciones las cuales se ejecutan continuamente mientras una condici\u00f3n que se eval\u00faa sea verdadera. La condici\u00f3n se eval\u00faa antes de entrar dentro del while y cada vez que se termina de ejecutar las instrucciones del while.</p> <p>El programa se ejecuta siguiendo estos pasos:</p> <ol> <li>Se eval\u00faa la expresi\u00f3n l\u00f3gica.</li> <li>Si  la  expresi\u00f3n  es  verdadera  ejecuta  las  instrucciones,  sino  el  programa  abandona  la sentencia while.</li> <li>Tras ejecutar las instrucciones, volvemos al paso 1.</li> </ol> EstructuraEjemplo <pre><code>while(expresi\u00f3nL\u00f3gica){\n//instrucciones\n}\n</code></pre> <pre><code>import java.util.Random;\npublic class While1 {\npublic static void main(String[] args) {\nint number;\nRandom random = new Random();\n/*\n         * Se obtiene un n\u00famero aleatorio entre 1 y 500.\n         * Mientras dicho n\u00famero sea par, continuamos en el bucle while\n         */\nwhile ((number = random.nextInt(500)+1) % 2 == 0){\nSystem.out.println(number);\n}\n}\n}\n</code></pre> Ejercicio 1 <p>Dados dos n\u00fameros n1 y n2, tal que n1 &lt;= n2, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle while.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-do-while","title":"Bucle do-while","text":"<p>La \u00fanica diferencia respecto al while est\u00e1 en que la expresi\u00f3n l\u00f3gica se eval\u00faa despu\u00e9s de haber ejecutado  las  instrucciones.  Es  decir,  el  bucle  al  menos  se  ejecuta  una  vez.  Los  pasos  son  los siguientes:</p> <ol> <li>Ejecutar instrucciones.</li> <li>Evaluar expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera, volver al paso 1. Si es falsa, salir del do-while.</li> </ol> <p>Ejemplo que muestra n\u00fameros aleatorios entre 1 y 500 hasta que salga uno m\u00faltiplo de 7:</p> EstructuraEjemploEjemplo 2Ejemplo 3Ejemplo 4 <pre><code>do{\n// instrucciones\n} while(expresi\u00f3nL\u00f3gica)\n</code></pre> <pre><code>import java.util.Random;\npublic class DoWhile1 {\npublic static void main(String[] args) {\nboolean exit = false;\nint number;\nRandom random = new Random();\ndo{\nnumber = random.nextInt(500) + 1; //(1)!\nSystem.out.println(number);\nexit = (number % 7 == 0); //(2)!\n} while (!exit); //(3)!\n}\n}\n</code></pre> <ol> <li>Se calcula un n\u00famero aleatorio entre 1 y 500</li> <li>exit se pone a true si el n\u00famero es m\u00faltiplo de 7</li> <li>Condici\u00f3n de repetici\u00f3n: que exit sea false</li> </ol> <p>Si le a\u00f1adimos al ejemplo anterior que solamente haya 5 posibilidades para encontrar el m\u00faltiplo de 7, eso significa que necesitamos una variable que apunte al n\u00famero de iteraci\u00f3n del bucle para poder controlar que solamente se ejecute 5 veces, es decir, necesitamos un \u00edndice:</p> <pre><code>import java.util.Random;\npublic class DoWhile2 {\npublic static void main(String[] args) {\nboolean exit = false;\nint number, i = 1; //(1)!\nRandom random = new Random();\ndo{\nnumber = random.nextInt(500) + 1;\nSystem.out.println(number);\nexit = (number % 7 == 0);\ni++;\n} while (!exit &amp;&amp; i &lt;= 5); //(2)!\nif(!exit){\nSystem.out.println(\"No se encontr\u00f3 el m\u00faltiplo de 7\");\n}\n}\n}\n</code></pre> <ol> <li>i es un \u00edndice porque apunta al n\u00famero de iteraci\u00f3n del bucle</li> <li>Mientras exit sea false y adem\u00e1s i sea menor o igual que 5</li> </ol> <p>El  bucle  do-while  se  utiliza  cuando  se  sabe  que  las  instrucciones  del  bucle  se  van  a  ejecutar  al menos  una  vez.  En  el  bucle  while  puede  ser  que  no  se  ejecuten  nunca  si  la  condici\u00f3n  es  falsa desde un principio. Las peticiones de usuario se realizan con bucles do-while, ya que la petici\u00f3n del  dato  al  usuario  siempre  se  realiza,  y  si  el  usuario  no  introduce  lo  que  le  hemos  pedido, entonces utilizamos el bucle para volv\u00e9rselo a pedir.</p> <pre><code>import java.util.Scanner;\npublic class DoWhile3 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint number;\ndo{\nSystem.out.print(\"Introduzca un n\u00famero del 1 al 5: \");\nnumber = keyboard.nextInt();\nSystem.out.printf(\"Has introducido un %d\\n\", number);\n}while (number &lt; 1 || number &gt; 5);\n}\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class DoWhile4 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint number, counter = 0, sum = 0, index = 0;\n/*\n         * index: es un \u00edndice porque apunta al n\u00famero de iteraci\u00f3n del bucle\n         * counter: es un contador para contar el n\u00famero de pares\n         * sum: es un acumulador donde se acumula la suma de los n\u00fameros pares\n         */\ndo{\nSystem.out.print(\"Introduzca un n\u00famero \u00f3 0 para terminar: \");\nnumber = keyboard.nextInt();\nif(number != 0){\nindex++; // Se incrementa el n\u00famero de iteraciones del bucle\nSystem.out.printf(\"El n\u00famero introducido en la iteraci\u00f3n %d es %d\\n\", index, number);\nif(number % 2 == 0){ // si el n\u00famero es par\ncounter++; // Se incrementa el contador\nsum += number; // Se acumula la suma en el acumulador\n}\n}\n}while (number != 0);\nSystem.out.printf(\"En %d iteraciones se han introducido %d n\u00fameros pares cuya suma vale %d\", index, counter, sum);\n}\n}\n</code></pre> Ejercicio 2 <p>Dados dos n\u00fameros n1 y n2, tal que n1 &lt;= n2, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle do-while.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-for","title":"Bucle for","text":"<p>El funcionamiento es el siguiente:</p> <ol> <li>Se ejecuta la instrucci\u00f3n de inicializaci\u00f3n.</li> <li>Se comprueba la condici\u00f3n.</li> <li>Si la condici\u00f3n es cierta, entonces se ejecutan las instrucciones. Si la condici\u00f3n es falsa, se abandona el bloque for.</li> <li>Tras ejecutar las instrucciones, se ejecuta la instrucci\u00f3n de incremento y se vuelve al paso</li> </ol> EstructuraEjemploEjemplo con While <pre><code>for(inicializaci\u00f3n;condici\u00f3n;incremento){\n// instrucciones\n}\n</code></pre> <p>Escribir n\u00fameros del 1 al 100:</p> <pre><code>public class For1 {\npublic static void main(String[] args) {\nint i;\nfor (i = 1; i &lt;= 100; i ++){ //(1)!\nSystem.out.println(i);\n}\n}\n}\n</code></pre> <ol> <li>i es un \u00edndice porque apunta al n\u00famero de iteraci\u00f3n del bucle</li> </ol> <p>Los bucles for tambi\u00e9n se pueden hacer con while o do-while pero los for tienen una sintaxis m\u00e1s abreviada. Veamos el ejemplo For1 hecho con un while:</p> <pre><code>public class While2 {\npublic static void main(String[] args) {\nint i = 1;\nwhile (i &lt;= 100){\nSystem.out.println(i);\ni++;\n}\n}\n}\n</code></pre> <p>Todos los bucles se pueden hacer con for, while y do-while, entonces, \u00bfcu\u00e1l se debe usar? Es importante que le programador utilice la estructura m\u00e1s adecuada en cada caso:</p> <ul> <li> <p>Un bucle for se utiliza cuando se conozca el n\u00famero de veces que se va a ejecutar el bucle, es decir, cuando se conozcan el n\u00famero de iteraciones de antemano.</p> </li> <li> <p>Si no se sabe de antemano el n\u00famero de iteraciones, entonces hay que utilizar while o do-while</p> <ul> <li>Un bucle do-while se utiliza cuando las instrucciones del bucle se van a ejecutar al menos una vez.</li> <li>Un bucle while se utiliza, entonces, cuando las instrucciones del bucle pueden no ejecutarse nunca si la condici\u00f3n es falsa desde un principio.</li> </ul> </li> </ul> <p>Tambi\u00e9n es posible declarar la variable dentro del propio bucle for, pero su \u00e1mbito de vida se reduce exclusivamente al bucle for, es decir, no se conoce fuera del for ya que muere en cuando el bucle se finalice.</p> <pre><code>public class For2 {\npublic static void main(String[] args) {\nfor (int i = 1; i &lt;= 100; i++) { //(1)!\nSystem.out.println(i);\n}\ni = 1; //(2)!\n}\n}\n</code></pre> <ol> <li>Se declara la variable i como int dentro del for</li> <li> Error de compilaci\u00f3n: <code>i cannot be resolved to a variable</code></li> </ol> <p>El bucle for tambi\u00e9n admite m\u00e1s de una variable, en cuyo caso, en las partes de inicializaci\u00f3n e incremento, se utiliza como separador la coma <code>,</code>:</p> <pre><code>public class For3 {\npublic static void main(String[] args) {\nfor(int i = 0, j = 10; i &lt;= j; i++, j--){\nSystem.out.printf(\"i: %d j: %d\\n\", i, j);\n}\n}\n}\n</code></pre> <p>CUIDADO</p> <p>En los IDEs, se puede seleccionar variables l\u00edneas de c\u00f3digos y se puede insertar f\u00e1cilmente en un if o en un bucle.</p> <p>Por motivos de legibilidad de c\u00f3digo, es muy importante que las variables del for aparezcan en las  3  partes  del  for,  es  decir,  en  la  inicializaci\u00f3n,  en  la  condici\u00f3n  y  en  el  incremento,  ya  que  el programador  que  quiera  saber  cu\u00e1ntas  iteraciones  realiza  el  bucle,  solamente  con  fijarse  en  la l\u00ednea de c\u00f3digo donde se encuentra el for, pueda saberlo. Si las variables del for no aparecen en las 3 partes, eso nos indica que es m\u00e1s conveniente realizar un while o un do-while.</p> <p>Veamos el ejemplo que muestra n\u00fameros aleatorios entre 1 y 500 hasta que salga uno m\u00faltiplo de 7:</p> <pre><code>import java.util.Random;\npublic class For4 {\npublic static void main(String[] args) {\nboolean exit = false;\nint number = 0, i;\nRandom random = new Random();\nfor(i = 1; !exit; i++){ // Este for no es legible, se debe sustituir por un do-while\nnumber = random.nextInt(500)+1;\nSystem.out.printf(\"Iteraci\u00f3n %d, n\u00famero: %d\\n\", i, number);\nexit = (number % 7 == 0);\n}\nSystem.out.printf(\"El m\u00faltiplo de 7 con valor %d se ha encontrado en la iteraci\u00f3n %d\", number, i - 1);\n}\n}\n</code></pre> <p>Si le a\u00f1adimos al ejemplo anterior que solamente haya 5 posibilidades para encontrar el m\u00faltiplo de 7:</p> <pre><code>import java.util.Random;\npublic class For5 {\npublic static void main(String[] args) {\nboolean exit = false;\nint number = 0, i;\nRandom random = new Random();\n/*\n         * Ahora el for s\u00ed es legible porque la variable i aparece en las 3 partes:\n         * en la inicializaci\u00f3n, en la condici\u00f3n y en el incremento\n         */\nfor(i = 1; i &lt;= 5 &amp;&amp; !exit; i++){\nnumber = random.nextInt(500) + 1;\nSystem.out.printf(\"Iteraci\u00f3n: %d, n\u00famero: %d\\n\", i, number);\nexit = (number % 7 == 0);\n}\nif(exit){\nSystem.out.printf(\"El m\u00faltiplo de 7 con valor de %d se ha encontrado en la iteraci\u00f3n %d\", number, i - 1);\n} else {\nSystem.out.println(\"El m\u00faltiplo de 7 no se ha encontrado\");\n}\n}\n}\n</code></pre> <p>Tambi\u00e9n  es  muy  importante  por  motivos  de  legibilidad  del  c\u00f3digo,  que  el  \u00fanico  sitio  donde  se modifiquen  los  valores  de  las  variables  del  for  sea  en  la  zona  del  incremento  ya  que  el programador que quiera saber cu\u00e1ntas iteraciones realiza el bucle, solamente con ver la l\u00ednea de c\u00f3digo del for, pueda saberlo. Por ejemplo, este c\u00f3digo no es adecuado ya que para salirse del bucle del for, se est\u00e1 modificando la variable i.</p> <pre><code>import java.util.Random;\npublic class For6 {\npublic static void main(String[] args) {\nint number = 0, i;\nRandom random = new Random();\nfor(i = 1; i &lt; = 5; i++){\nnumber = random.nextInt(500) + 1;\nSystem.out.printf(\"Iteraci\u00f3n %d, n\u00famero: %d\\n\", i, number);\nif(number % 7 == 0){\ni = 5; // No se pueden modificar las variables del for, solamente en el incremento\n}\n}\nif(number % 7 == 0){\nSystem.out.printf(\"El m\u00faltiplo de 7 encontrado vale %d\", number);\n} else {\nSystem.out.println(\"El m\u00faltiplo de 7 no se ha encontrado\");\n}\n}\n}\n</code></pre> Ejercicio 3 <p>Dados dos n\u00fameros n1 y n2, tal que n1 &lt;= n2, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle for.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-for-each","title":"Bucle for-each","text":"<p>Una de las cosas que incorpor\u00f3 Java 5 fue el bucle for-each. Esta estructura nos permite recorrer una colecci\u00f3n o un array de elementos de una forma sencilla, evitando el uso de iteradores o de un bucle for normal.</p> <p>Tambi\u00e9n se usa el for-each para recorrer los valores de un enum. Para ello, se utiliza el m\u00e9todo values() de los enum que est\u00e1 impl\u00edcitamente declarado por el compilador:</p> EstructuraEjemplo <pre><code>for(TipoVariable variable : values){\n//instrucciones\n}\n</code></pre> <pre><code>public class ForEachEnum {\npublic enum DayOfWeek{\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\npublic static void main(String[] args) {\nfor (DayOfWeek d : DayOfWeek.values()) {\nSystem.out.println(d);\n}\n}\n}\n</code></pre> Ejercicio 4 <p>Crea un enum con los meses del a\u00f1o, y haciendo uso de un bucle for-each, muestra aquellos meses de verano.</p>"},{"location":"bloque_i/tema_2/page-2/#ejercicios","title":"Ejercicios","text":"Ejercicio 5 <p>Haz un programa para simular 20 lanzamientos de un dado.</p> Ejercicio 6 <p>Genera 15 n\u00fameros aleatorios entre el rango de dos n\u00fameros solicitados al usuario.</p> Ejercicio 7 <p>Dados dos n\u00fameros enteros positivos, calcula su producto utilizando solo sumas.</p> Ejercicio 8 <p>Solic\u00edtale al usuario un n\u00famero entre 0 y 10 ambos incluidos:</p> <ul> <li>Si el usuario introduce un n\u00famero que no est\u00e9 dentro de ese rango, vuelve a ped\u00edrselo tantas veces como sea necesario, ese decir, hasta que introduzca un n\u00famero entre 0 y 10.</li> <li>Una vez obtenido el n\u00famero dentro de ese rango, muestra la tabla de multiplicar de dicho n\u00famero.</li> </ul> Ejercicio 9 <p>Realiza un programa que solicite al usuario un n\u00famero entero positivo n y dibuje un tri\u00e1ngulo de asteriscos. El tri\u00e1ngulo debe contener un asterisco en la primera l\u00ednea, dos en la segunda, etc.; es decir, en la fila en\u00e9sima deben aparecer n asteriscos. Ejemplo para n=5.</p> <pre><code>    *\n* *\n* * *\n* * * *\n* * * * *\n</code></pre> Ejercicio 10 <p>Realiza un programa que solicite al usuario un n\u00famero entero positivo n y dibuje un rombo de asteriscos. Por ejemplo, si n = 5 deber\u00eda dibujarse:</p> <pre><code>    *\n* *\n* * *\n* * * *\n* * * * *\n* * * *\n* * *\n* *\n*\n</code></pre> Ejercicio 11 <p>Realiza un programa que dibuje el tri\u00e1ngulo hasta un valor dado. El tri\u00e1ngulo contiene los n\u00fameros naturales correlativos, uno en la primera l\u00ednea, dos en la segunda, etc,; es decir, en la fila en\u00e9sima aparecen n valores. Ejemplo para n=5</p> <pre><code>      1\n1  2\n1  2  3\n1  2  3  4\n1  2  3  4  5\n</code></pre> Ejercicio 12 <p>Realiza un programa que dibuje una pir\u00e1mide de d\u00edgitos como la de la figura, pidiendo por teclado el n\u00famero de filas de la misma. Ejemplo para n = 5:</p> <pre><code>            1\n1  2  1\n1  2  3  2  1\n1  2  3  4  3  2  1\n1  2  3  4  5  4  3  2  1\n</code></pre> Ejercicio 13 <p>Crea un programa que dibuje un table de ajedrez.</p> Ejercicio 14 <p>Solic\u00edtale al usuario una casilla de un tablero de ajedrez. Dibuja el tablero de ajedrez con el alfil colocado en dicha casilla y marca con un color diferente en el tablero las casillas a las que puede mover dicho alfil.</p> Ejercicio 15 <p>Realiza un dibujo de una estrella de 6 puntas. Solic\u00edtale al usuario:</p> <ul> <li>La altura de las puntas, como m\u00ednimo 2.</li> <li>El color de la estrella: rojo o verde.</li> </ul> <p> Figura 1 - Salida del ejercicio 15 </p> Ejercicio 16 <p>Realiza un dibujo de un c\u00edrculo rojo con fondo amarillo. Solic\u00edtale al usuario el n\u00famero de l\u00edneas. </p> <p>Ejemplo con 13 l\u00edneas</p> <p> Figura 2 - Salida del ejercicio 16 </p> <p>Ejemplo con 21 l\u00edneas:</p> <p> Figura 3 - Salida del ejercicio 16 </p>"},{"location":"bloque_i/tema_2/page-3/","title":"3 Funciones","text":""},{"location":"bloque_i/tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ol> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ol> <p>Dichas  funciones  se  pueden  utilizar  desde  muchos  sitios  diferentes,  por  lo  que  de  manera general, no se suelen poner mensajes en consola en las funciones ya que puede ser que dichos mensajes no interesen en todos los sitios donde se utilice dicha funci\u00f3n. A no ser que la funci\u00f3n se haya creado espec\u00edficamente para dar mensajes informativos en consola.</p>"},{"location":"bloque_i/tema_2/page-3/#construccion","title":"Construcci\u00f3n","text":"<p>Una funci\u00f3n se construye de la siguiente manera:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro nombre_par\u00e1metro, ...){\n// instrucciones\nreturn expresi\u00f3n;\n}\n</code></pre> <ul> <li>modificador_acceso: es la visibilidad que posee la funci\u00f3n (Lo veremos m\u00e1s adelante. De momento, lo utilizaremos como public).</li> <li>tipo_resultado: es el tipo del resultado que devuelve la funci\u00f3n.</li> <li>nombre_funci\u00f3n:  es  el  nombre  que  identifica  a  la  funci\u00f3n.  Utiliza  la  notaci\u00f3n lowerCamelCase. Ejemplo: imprimirResultadoDecimal.</li> <li>tipo_par\u00e1metro  nombre_par\u00e1metro,  ...:  puede  ocurrir  que  la  funci\u00f3n  necesite  ciertos valores para efectuar la misi\u00f3n para la que ha sido creada. Por ejemplo, la funci\u00f3n suma necesitar\u00eda los valores que tiene que sumar. En este caso, se deben indicar cada uno de dichos  valores  con  sus  tipos  correspondientes.  A  estos  valores  se  les  conoce  como par\u00e1metros de la funci\u00f3n. Si la funci\u00f3n no necesita par\u00e1metros, entonces solamente se ponen los par\u00e9ntesis: <code>nombre_funci\u00f3n( )</code>.</li> </ul> <p>A todo esto se le conoce como firma (signature) de la funci\u00f3n:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro nombre_par\u00e1metro, ...)\n</code></pre> <ul> <li>instrucciones: instrucciones que conforman el algoritmo de la funci\u00f3n, para que realice la misi\u00f3n para la que ha sido creada.</li> <li>return expresi\u00f3n: con el return se termina la ejecuci\u00f3n de la funci\u00f3n y si va acompa\u00f1ado de una expresi\u00f3n, la funci\u00f3n devuelve como resultado el valor de dicha expresi\u00f3n. Dicho valor tiene que ser del tipo_resultado indicado en la firma de la funci\u00f3n.</li> </ul> <p>Ejemplo de la funci\u00f3n con dos par\u00e1metros:</p> <pre><code>public static int add(int sum1, int sum2){\nreturn sum1 + sum2;\n}\n</code></pre> <p>Puede ser tambi\u00e9n que haya m\u00e1s de un return. En ese caso, el flujo de ejecuci\u00f3n abandona la funci\u00f3n en cuanto ejecute el primer return. Ejemplo:</p> <pre><code>public static boolean isPair(int n){\nif(n % 2 == 0){\nreturn true;\n} else {\nreturn false;\n}\n}\n</code></pre> <p>En el caso de que estemos definiendo un procedimiento, no tendremos <code>return expresi\u00f3n</code> ya que no devuelve ning\u00fan resultado y el tipo_resultado es void. Como por ejemplo <code>System.put.println</code>, que escribe en pantalla lo que recibe por par\u00e1metro pero no devuelve nada.</p>"},{"location":"bloque_i/tema_2/page-3/#llamada-a-la-funcion","title":"Llamada a la funci\u00f3n","text":"<p>Una funci\u00f3n permite que reutilicemos un algoritmo ya que se puede utilizar cuando nos haga falta.  Para  ello,  solamente  tendremos  que  llamar  a  la  funci\u00f3n  por  su  nombre  y  pasarle  los par\u00e1metros en el mismo orden que se han definido y pertenecientes al mismo tipo de dato o compatible. En la llamada, dichos par\u00e1metros se llaman argumentos, es decir, los argumentos son los valores iniciales de los par\u00e1metros.</p> <pre><code>public class Functions1 {\npublic static void main(String[] args) {\nboolean pair;\nint result;\n/*\n         * Se llama a la funci\u00f3n isPair con un valor de 5 en el argumento, es decir,\n         * el valor inicial del par\u00e1metro n es 5:\n         */\npair = isPair(5);\nSystem.out.println(pair); // false\n/*\n         * Se lla a la funci\u00f3n isPair con un valor de 4 en el argumento, es decir,\n         * ahora el valor inicial del par\u00e1metro n es 4.\n         */\npair = isPair(4);\nSystem.out.println(pair); // true\n/*\n         * Se llama a la funci\u00f3n add con los valores 5 y 2 en los argumentos, es decir,\n         * los valores iniciales de los par\u00e1metros sum1 y sum2 son 5 y 2 respectivamente.\n         */\nresult = add(5,2);\nSystem.out.println(result); // 7\n}\npublic static int add(int sum1, int sum2){\nreturn sum1 + sum2;\n}\npublic static boolean isPair(int n){\nif(n % 2 == 0){\nreturn true;\n} else {\nreturn false;\n}\n}\n}\n</code></pre> Ejercicio 1 <p>Realiza una funci\u00f3n que reciba la base y el exponente y devuelva la potencia baseexponente sin utilizar Math.pow</p>"},{"location":"bloque_i/tema_2/page-3/#ambito-de-vida-de-los-parametros","title":"\u00c1mbito de vida de los par\u00e1metros","text":"<p>A nivel de visibilidad y de \u00e1mbito de vida, los par\u00e1metros funcionan como las variables locales (Ver tema 1.3 Variables y constantes 4. \u00c1mbito de vida de las variables), por lo tanto el \u00e1mbito de vida de los par\u00e1metros es el bloque donde han sido definidos, es decir, la propia funci\u00f3n. Cada vez  que  se  llame  a  la  funci\u00f3n,  los  par\u00e1metros  nacen,  se  ejecuta  la  funci\u00f3n  y  una  vez  que  la funci\u00f3n ha terminado de ejecutarse, los par\u00e1metros mueren.</p> <pre><code>public class Functions2 {\npublic static void main(String[] args) {\nboolean pair;\nint result;\npair = isPair(5); //(1)!\n//(2)!\nSystem.out.println(pair);\npair = isPair(4); //(3)!\n//(4)!\nSystem.out.println(pair);\nresult = add(5, 2); //(5)!\n//(6)!\nSystem.out.println(result);\n}\npublic static int add(int sum1, int sum2){ //(7)!\nreturn sum1 + sum2;\n} //(8)!\npublic static boolean isPair(int n){ //(9)!\nif(n % 2 == 0){\nreturn true;\n} else {\nreturn false;\n}\n} //(10)!\n}\n</code></pre> <ol> <li>Nace el par\u00e1metro n con el valor 5</li> <li>Aqu\u00ed n ya no existe porque la funci\u00f3n isPair ya ha terminado de ejecutarse</li> <li>Vuelve a nacer n pero esta vez con un valor de 4</li> <li>Aqu\u00ed n ya no existe porque la funci\u00f3n isPair ya ha terminado de ejecutarse</li> <li>Nacen los par\u00e1metros sum1 y sum2 con los valores 5 y 2 respectivamente</li> <li>Aqu\u00ed sum1 y sum2 ya no existen porque la funci\u00f3n add ha terminado de ejecutarse</li> <li>Comienzo del \u00e1mbito de vida de los par\u00e1metros sum1 y sum2</li> <li>Fin del \u00e1mbito de vida de los par\u00e1metros sum1 y sum2</li> <li>Comienzo del \u00e1mbito de vida del par\u00e1metro n</li> <li>Fin del \u00e1mbito de vida del par\u00e1metro n</li> </ol> Ejercicio 2 <p>Realiza una funci\u00f3n que reciba 3 par\u00e1metros: dos de tipo entero y uno de tipo car\u00e1cter. La funci\u00f3n deber\u00e1 sumar, restar, multiplicar o dividir los valores de los dos primeros par\u00e1metros dependiendo de la operaci\u00f3n indicada en el tercer par\u00e1metro, y devolver el resultado</p> Ejercicio 3 <p>Sobrecarga la funci\u00f3n del ejercicio anterior para que se pueda operar con enteros y con decimales. Haz un programa que utilice las dos funciones, con enteros y con decimales</p>"},{"location":"bloque_i/tema_2/page-3/#ejemplo-de-funcion-el-factorial-de-un-numero","title":"Ejemplo de funci\u00f3n: el factorial de un n\u00famero","text":"<p>El factorial de un entero positivo n, tambi\u00e9n indicado como n!, se define como el producto de todos los n\u00fameros enteros positivos desde 1 hasta n. Por ejemplo:</p> <p>5! = 1 x 2 x 3 x 4 x 5 = 120</p> <p>La  operaci\u00f3n  de  factorial  aparece  en  muchas  \u00e1reas  de  las  matem\u00e1ticas,  particularmente  en combinatoria  y  an\u00e1lisis  matem\u00e1tico.  De  manera  fundamental,  el  factorial  de  n  representa  el n\u00famero de formas distintas de ordenar n objetos distintos (elementos sin repetici\u00f3n). Este hecho ha sido conocido desde hace varios siglos, en el siglo XII, por los hind\u00faes.</p> <p>Veamos  c\u00f3mo  se  programar\u00eda  dicha  funci\u00f3n  factorial  y  las  llamadas  con  distintos  tipos  de argumentos:</p> <pre><code>import java.util.Scanner;\npublic class Factorial {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint n, variable;\nSystem.out.println(\"Llamada a la funci\u00f3n con argumentos literales: \");\nSystem.out.printf(\"El factorial de 5 es %d\\n\", factorial(5));\nSystem.out.println(\"Llamada a la funci\u00f3n usando una variable como argumento: \");\nvariable = 5;\nSystem.out.printf(\"El factorial de %d es %d\\n\", variable, factorial(variable));\nSystem.out.println(\"Llamada a la funci\u00f3n usando una expresi\u00f3n como argumento: \");\nvariable = 3;\nSystem.out.printf(\"El factorial de %d es %d\\n\", variable + 2, factorial(variable + 2));\nSystem.out.println(\"Llamada a la funci\u00f3n con argumentos introducidos por el usuario: \");\ndo {\nSystem.out.println(\"Introduzca un n\u00famero entero positivo: \");\nn = keyboard.nextInt();\n} while (n &lt;= 0);\nSystem.out.printf(\"El factorial de %d es %d\", n, factorial(n));\n}\npublic static int factorial(int n) {\nint result = 1;\nfor (int i = 2; i &lt;= n; i++) {\nresult *= i;\n}\nreturn result;\n}\n}\n</code></pre> <p>El concepto del factorial se aplica a los n\u00fameros enteros positivos, pero como los int admiten n\u00fameros  negativos,  se  podr\u00eda  llamar  a  la  funci\u00f3n  con  un  n\u00famero  negativo  aunque  no  tenga sentido:</p> <pre><code>int result = factorial(-5); //(1)!\nSystem.out.println(\"El factorial de %d es %d\\n\", -5, result); //(2)!\n</code></pre> <ol> <li>No tiene mucho sentido porque el factorial se aplica a n\u00fameros positivos</li> <li>El factorial de -5 es 1</li> </ol> <p>Es decir, cuando programamos una funci\u00f3n, no podemos dar por hecho que el programador que la vaya a utilizar lo haga de manera adecuada con la l\u00f3gica que representa su funcionalidad. As\u00ed que  siempre  que  programemos  una  funci\u00f3n,  debemos  asegurarnos  que  va  a  funcionar correctamente para todos los valores posibles del par\u00e1metro. En nuestro caso, no podemos dar un  resultado  coherente  para  los  n\u00fameros  negativos  puesto  que  no  tiene  sentido matem\u00e1ticamente el factorial de un n\u00famero negativo, as\u00ed que lo m\u00e1s conveniente es lanzar un error cuando llamen a la funci\u00f3n con un n\u00famero negativo.</p> <pre><code>import java.util.Scanner;\npublic class Factorial {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint n, variable;\nSystem.out.println(\"Llamada a la funci\u00f3n con argumentos literales: \");\nSystem.out.printf(\"El factorial de 5 es %d\\n\", factorial(5));\nSystem.out.println(\"Llamada a la funci\u00f3n usando una variable como argumento: \");\nvariable = 5;\nSystem.out.printf(\"El factorial de %d es %d\\n\", variable, factorial(variable));\nSystem.out.println(\"Llamada a la funci\u00f3n usando una expresi\u00f3n como argumento: \");\nvariable = 3;\nSystem.out.printf(\"El factorial de %d es %d\\n\", variable + 2, factorial(variable + 2));\nSystem.out.println(\"Llamada a la funci\u00f3n con argumentos introducidos por el usuario: \");\ndo {\nSystem.out.println(\"Introduzca un n\u00famero entero positivo: \");\nn = keyboard.nextInt();\n} while (n &lt;= 0);\nSystem.out.printf(\"El factorial de %d es %d\", n, factorial(n));\nSystem.out.println(\"Llamada a la funci\u00f3n con argumentos negativos\");\nvariable = - 5;\nSystem.out.printf(\"El factorial %d es %d\\n\", variable, factorial(variable));\n}\npublic static int factorial(int n) {\nint result = 1;\nif(n &lt; 0){\nthrow new IllegalArgumentException(\"El factorial se aplica a n\u00fameros positivos\");\n}\nfor (int i = 2; i &lt;= n; i++) {\nresult *= i;\n}\nreturn result;\n}\n}\n</code></pre> <p>Salida por consola:</p> <pre><code>Exception in thread \"main\" java.lang.IllegalArgumentException: El factorial se aplica a n\u00fameros positivos\nat tema2_3_Funciones.Factorial3.factorial(Factorial3.java:19)\nat tema2_3_Funciones.Factorial3.main(Factorial3.java:9)\n</code></pre> Ejercicio 4 <p>Realiza una funci\u00f3n que encuentre el primer valor N para el que la suma <code>1 + 2 + 3 + .. + N</code> exceda a un valor M que se introduce por par\u00e1metro. Es decir, si M vale:</p> <ul> <li>1: devuelve 2</li> <li>3: devuelve 3</li> <li>7: devuelve 4</li> <li>10: devuelve 5</li> <li>15: devuelve 6</li> </ul> Ejercicio 5 <p>El m\u00e1ximo com\u00fan divisor de dos enteros es el entero m\u00e1s grande que es divisor exacto de los dos n\u00fameros. Realiza una funci\u00f3n que devuelva el m\u00e1ximo com\u00fan divisor de dos enteros. Por ejemplo, 12 es el mcd de 36 y 60.</p>"},{"location":"bloque_i/tema_2/page-3/#ejemplo-de-procedimiento","title":"Ejemplo de Procedimiento","text":"<p>No tendremos  <code>return expresi\u00f3n</code>  ya que no devuelve ning\u00fan resultado y el <code>tipo_resultado</code> es void:</p> <pre><code>import java.util.Scanner;\nimport static examples.tema_01.Colors.GREEN;\nimport static examples.tema_01.Colors.RESET;\npublic class Procedure {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString string;\nSystem.out.print(\"Introduce una cadena: \");\nstring = keyboard.nextLine();\npaintGreen(string);\n}\nprivate static void paintGreen(String string) {\nSystem.out.printf(\"La cadena que has introducido en verde: %s\", GREEN + string + RESET);\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#resultado-de-las-funciones","title":"Resultado de las funciones","text":"<p>En las llamadas a funciones, no hay que obligatoriamente utilizar el valor devuelto:</p> <pre><code>import java.util.Scanner;\nimport static examples.tema_01.Colors.GREEN;\nimport static examples.tema_01.Colors.RESET;\npublic class Result {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString string, stringGreen;\nSystem.out.print(\"Introduce una cadena: \");\nstring = keyboard.nextLine();\n/*\n         * En la llamada a la funci\u00f3n turnGreen, no estamos utilizando el valor devuelto\n         */\nturnGreen(string);\n/*\n         * En la siguiente llamada, s\u00ed lo vamos a utilizar\n         */\nstringGreen = turnGreen(string);\nSystem.out.printf(\"La cadena %s convertida a verde: %s\", string, stringGreen);\n}\nprivate static String turnGreen(String string) {\nString result = String.format(\"%s\", GREEN + string + RESET);\nSystem.out.println(result);\nreturn result;\n}\n}\n</code></pre> Ejercicio 6 <p>Se dice que un n\u00famero entero es primo si s\u00f3lo es divisible entre 1 y entre s\u00ed mismo. Por ejemplo, 2, 3, 5 y 7 son primos, pero 4, 6, 8 y 9 no lo son.</p> <ol> <li>Realiza una funci\u00f3n que determine si un n\u00famero es primo o no.</li> <li>Realiza una funci\u00f3n que muestre todos los n\u00fameros primos comprendidos entre 1 y 10.000</li> <li>Realiza una funci\u00f3n que descomponga un n\u00famero en factores primos. Ejemplo:<ul> <li>18 = 2 x 3 x 3</li> <li>11 = 11</li> <li>35 = 5 x 7</li> <li>40 = 2 x 2 x 2 x 5</li> </ul> </li> </ol> Ejercicio 7 <p>Se dice que un n\u00famero entero es un n\u00famero perfecto si la suma de sus divisores propios (incluyendo el 1 y sin incluirse \u00e9l mismo) da como resultado el mismo n\u00famero. Por ejemplo, 6 es un n\u00famero perfecto, porque sus divisores propios son 1, 2 y 3; y 6 = 1 + 2 + 3. Los siguientes n\u00fameros perfectos son 28, 496 y 8128.</p> <ol> <li>Realiza una funci\u00f3n que determine si el par\u00e1metro es perfecto o no.</li> <li>Realiza una funci\u00f3n que dado un n\u00famero perfecto, imprima los factores para confirmar que el n\u00famero es perfecto. Si no lo es, que no haga nada.</li> <li>Realiza una funci\u00f3n que muestre todos los n\u00fameros perfectos entre 1 y 10.000 con sus correspondientes factores.</li> </ol> Ejercicio 8 <p>La serie Fibonacci se define mediante: a0 = 0 a1 = 1 an = an-1 + an-2, es decir, la serie Fibonacci ser\u00eda la siguiente 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p> <ol> <li>Realiza una funci\u00f3n que devuelva el elemento en\u00e9simo de la serie Fibonacci. Es decir, si recibe:<ul> <li>0: devuelve 0</li> <li>1: devuelve 1</li> <li>4: devuelve 3</li> <li>7: devuelve 13</li> </ul> </li> <li>Realiza una funci\u00f3n que muestre los 30 primeros n\u00fameros de la serie de Fibonacci</li> <li>Realiza una funci\u00f3n que calcule el primer elemento de la serie Fibonacci que se mayor o igual que un valor introducido por par\u00e1metro. Por ejemplo, si recibe 20, devolver\u00e1 21, ya que es el primer elemento de la serie mayor o igual que 20.</li> </ol> Ejercicio 9 <p>Realiza una funci\u00f3n que reciba un n\u00famero entero positivo de n cifras y devuelva el n\u00famero con sus cifras en orden inverso. No utilizar String ni calcular previamente el n\u00famero de cifras. Ej: 24.321 debe devolver 12.345</p>"},{"location":"bloque_i/tema_2/page-3/#recursividad","title":"Recursividad","text":"<p>La recursividad es una t\u00e9cnica de escritura de funciones pensada para problemas complejos. La idea parte de que una funci\u00f3n pueda invocarse a s\u00ed misma.</p> <p>Esta t\u00e9cnica es peligrosa ya que se pueden generar f\u00e1cilmente llamadas infinitas (la funci\u00f3n se llama a s\u00ed misma, tras la llamada se vuelve a llamar a s\u00ed misma, y as\u00ed sucesivamente sin freno ni control).  Por  lo  tanto,  es  muy  importante  tener  en  cuenta  cu\u00e1ndo  la  funci\u00f3n  debe  dejar  de llamarse.</p> <p>Hay  que  ser  muy  cauteloso  cuando  se  utiliza  la  recursividad,  pero  permite  soluciones  muy originales y abre la posibilidad de solucionar problemas muy complejos.</p> <p>Veamos como ejemplo la versi\u00f3n recursiva del factorial:</p> <pre><code>import java.util.Scanner;\npublic class RecursiveFactorial {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint n;\ndo{\nSystem.out.println(\"Introduce un n\u00famero entero positivo: \");\nn = keyboard.nextInt();\n} while (n &lt;= 0);\nSystem.out.printf(\"El factorial de %d es %d\\n\", factorial(n));\n}\nprivate static int factorial(int n) {\nint result;\nif(n == 1){ // Caso base: devuelve 1\nresult = 1;\n} else { // Caso recursivo\nresult = n * factorial(n-1);\n}\n/*\n         * Mensaje intermedio para comprobar\n         * como funciona\n         */\nSystem.out.printf(\"Factorial de %d  Resultado: %d\\n\", n, result);\nreturn result;\n}\n}\n</code></pre> <p>\u00bfRecursividad o iteraci\u00f3n? Hay otra versi\u00f3n del factorial resuelto mediante un bucle for (soluci\u00f3n iterativa) en lugar de utilizar la recursividad. La cuesti\u00f3n es \u00bfcu\u00e1l es mejor? Ambas implican sentencias repetitivas hasta llegar a una determinada condici\u00f3n, por lo que ambas pueden generar programas que no finalizan si la condici\u00f3n nunca se cumple. En el caso de la iteraci\u00f3n es una condici\u00f3n la que permite determinar el final, la recursividad lo que hace es ir simplificando el problema hasta generar una llamada a la funci\u00f3n que devuelva un valor y no se vuelva a llamar. Para un ordenador es m\u00e1s costosa la recursividad ya que implicar realizar muchas llamadas a funciones, es decir, es m\u00e1s r\u00e1pida la soluci\u00f3n iterativa. Entonces, \u00bfpor qu\u00e9 elegir recursividad? La recursividad se utiliza s\u00f3lo s\u00ed:</p> <ul> <li>No encontramos la soluci\u00f3n iterativa a un problema.</li> <li>El c\u00f3digo es mucho m\u00e1s claro en su versi\u00f3n recursiva.</li> </ul> Ejercicio 10 <p>Realiza el ejercicio 1, haciendo uso de la recursividad</p> Ejercicio 11 <p>El m\u00e1ximo com\u00fan divisor de los enteros a y b es el entero m\u00e1s grande que es divisor exacto de a y de b. Escribe una funci\u00f3n recursiva llamada gcd que devuelva el m\u00e1ximo com\u00fan divisor de a y b. El m\u00e1ximo com\u00fan divisor de a y b se define recursivamente como sigue:</p> <ul> <li>si b = 0 \u2192 gcd(a, b) = a</li> <li>si b \u2260 0 \u2192 gcd(a, b) = gcd(b, a % b)</li> </ul> Ejercicio 12 <p>Realiza el ejercicio 4 haciendo uso de la recursividad</p> Ejercicio 13 <p>Realiza el ejercicio 9 haciendo uso de la recursividad</p>"},{"location":"bloque_i/tema_2/page-3/#la-pila","title":"La pila","text":"<p>Una pila(stack) es una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del ingl\u00e9s Last In, First Out, \u00faltimo en entrar,  primero  en  salir) de  supuestos  en  el  \u00e1rea  de inform\u00e1tica debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.</p> <p>Para el manejo de los datos cuenta con dos operaciones b\u00e1sicas: apilar (push), que coloca un objeto en la pila, y su operaci\u00f3n inversa, desapilar (pop), que retira el \u00faltimo elemento apilado.</p> <p>En cada momento s\u00f3lo se tiene acceso a la parte superior de la pila, es decir, al \u00faltimo objeto apilado  (denominado  TOS,  Top of Stack).  La  operaci\u00f3n  desapilar  permite  la  obtenci\u00f3n  de  este elemento, que es retirado de la pila permitiendo el acceso al anterior (apilado con anterioridad), que pasa a ser el \u00faltimo, el nuevo TOS.</p> <p>Para las llamadas entre funciones, se utiliza una estructura de tipo pila: supongamos que se est\u00e1 procesando  una  funci\u00f3n  y  en  su  interior  llama  a  otra  funci\u00f3n.  La  funci\u00f3n  se  abandona  para procesar la funci\u00f3n de la llamada, pero antes se almacena en una pila la direcci\u00f3n que apunta a la funci\u00f3n. Ahora supongamos que esa nueva funci\u00f3n llama a su vez a otra funci\u00f3n. Igualmente, se almacena su direcci\u00f3n, se abandona y se atiende la petici\u00f3n. As\u00ed en tantos casos como existan peticiones.  La  ventaja  de  la  pila  es  que  no  requiere  definir  ninguna  estructura  de  control  ni conocer las veces que el programa estar\u00e1 saltando entre funciones para despu\u00e9s retomarlas, con la \u00fanica limitaci\u00f3n de la capacidad de almacenamiento de la pila. Conforme se van cerrando las funciones, se van rescatando las funciones precedentes mediante sus direcciones almacenadas en la pila y se va concluyendo su proceso, esto hasta llegar a la primera.</p> <p>En el caso de una funci\u00f3n recursiva, esto es posible implementarlo con sencillez mediante una pila. La funci\u00f3n se llama a s\u00ed misma tantas veces como sea necesario hasta que el resultado de la funci\u00f3n cumpla la condici\u00f3n de retorno; entonces, todas las funciones abiertas van completando su proceso en cascada. No se necesita saber cuantas veces se anidar\u00e1 y, por tanto, tampoco cuando  se  cumplir\u00e1  la  condici\u00f3n,  con  la  \u00fanica  limitaci\u00f3n  de  la  capacidad  de  la  pila.  De sobrepasarse ese l\u00edmite, normalmente porque se entra en un bucle sin final, se produce el error de desbordamiento de la pila (stack overflow).</p> Ejercicio 15 <p>Realiza una funci\u00f3n recursiva que invierta los caracteres de una cadena. Por ejemplo, si la funci\u00f3n recibe \"Hola a todos\", devuelve \"sodot a aloH\".</p> Ejercicio 14 <p>Realiza  un  programa  para  resolver  el  juego  de  las  Torres de Hanoi.  El  juego  consiste  en  tres  varillas verticales. En una de las varillas se apila un n\u00famero indeterminado de discos. Los discos se apilan sobre una varilla en tama\u00f1o decreciente. No hay dos discos iguales, y todos ellos est\u00e1n apilados de mayor a menor radio en una de las varillas, quedando las otras dos varillas vacantes. El juego consiste en pasar todos los discos de la varilla ocupada a una de las otras varillas vacantes. Para realizar este objetivo, es necesario seguir estas simples reglas:</p> <ul> <li>Solo se puede mover un disco cada vez.</li> <li>Un disco de mayor tama\u00f1o no puede descansar sobre uno m\u00e1s peque\u00f1o que \u00e9l mismo.</li> <li>Solo puedes desplazar el disco que se encuentre arriba en cada varilla.</li> </ul> <p>El movimiento de n discos se puede visualizar en t\u00e9rminos de mover s\u00f3lo n-1 discos (y de ah\u00ed la recursividad) como sigue:</p> <ol> <li>Pasar n-1 discos de la varilla 1 a la 2, usando la varilla 3 como \u00e1rea de retenci\u00f3n temporal.</li> <li>Pasar el \u00faltimo disco (el m\u00e1s grande) de la varilla 1 a la 3.</li> <li>Pasar los n-1 discos de la varilla 2 a la 3, empleando la varilla 1 como \u00e1rea de retenci\u00f3n temporal.</li> </ol> <p>El  proceso  termina  cuando  la  \u00faltima  tarea  implica  pasar  n=1  disco,  esto  es,  el  caso  base.  Esto  se  logra transfiriendo  el  disco  sin  necesidad  de  un  \u00e1rea  de  retenci\u00f3n  temporal.  Escribe  una  funci\u00f3n  recursiva  con cuatro par\u00e1metros:</p> <ol> <li>El n\u00famero de discos por transferir.</li> <li>La varilla en la que est\u00e1n colocados inicialmente esos discos.</li> <li>La varilla a la que debe pasarse esa pila de discos.</li> <li>La varilla que se usar\u00e1 como \u00e1rea de retenci\u00f3n temporal.</li> </ol> <p>El programa deber\u00e1 imprimir las instrucciones precisas requeridas para pasar los discos de la varilla inicial a  la varilla de destino. Por ejemplo, para pasar una pila de tres discos de la varilla 1 a la varilla 3, el programa deber\u00e1 imprimir la siguiente serie de movimientos:</p> <pre><code>1 \u2192 3\n1 \u2192 2\n3 \u2192 2\n1 \u2192 3\n2 \u2192 1\n2 \u2192 3\n1 \u2192 3\n</code></pre>"},{"location":"bloque_i/tema_2/page-4/","title":"Proyecto","text":"<p>Se desea realizar un proyecto Java en el cu\u00e1l se le mostrar\u00e1 al usuario un men\u00fa d\u00f3nde se le solicitar\u00e1 una de las siguiente figuras, teniendo en cuenta que cada vez que acceda a una de ellas, se les solicitar\u00e1 los datos pertinentes para el calculo de su \u00e1rea. Las figuras son las siguientes:</p> <ol> <li>Tri\u00e1ngulo (solicitar base y altura)</li> <li>Cuadrado (solicitar lado)</li> <li>Rect\u00e1ngulo (solicitar base y altura)</li> <li>Rombo (solicitar diagonal mayor y menor)</li> <li>Romboide (solicitar base y altura)</li> <li>Trapecio (solicitar base mayor, base menor y altura)</li> <li>C\u00edrculo (solicitar di\u00e1metro)</li> </ol> <p>Una vez realizado el \u00e1rea se deber\u00e1 comprobar sin hacer uso del resto de la divisi\u00f3n si el \u00e1rea (solo la parte entera) es m\u00faltiplo de 3 y de 9.</p> <p>Adem\u00e1s se le dar\u00e1 una opci\u00f3n al usuario para salir del men\u00fa, ya que aunque el usuario elija una opci\u00f3n se le volver\u00e1 a mostrar el men\u00fa de opciones una vez finalizada la operaci\u00f3n.</p> <p>Para realizar el proyecto se tendr\u00e1 en cuenta los siguientes objeciones:</p> <ol> <li>Se crear\u00e1 un proyecto nuevo cuyo nombre sea el siguiente formato pr02java-NOMBRE-geometria siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>Se har\u00e1 uso de la recursividad donde sea necesario.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ol>"},{"location":"bloque_ii/tema_10/page-1/","title":"10.1 Introducci\u00f3n a los Gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-1/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Se trata de la implementaci\u00f3n en Java de una de las opciones de C++ m\u00e1s a\u00f1oradas por los programadores que proceden de ese lenguaje; las plantillas (templates). Son similares a las plantillas de C++. Sirven para evitar conversiones de clases.</p> <p>Uno de los motivos de la creaci\u00f3n de los gen\u00e9ricos fueron las colecciones. Sin los gen\u00e9ricos todas las colecciones ser\u00edan de tipo Object, lo que tendr\u00eda una serie de desventajas:</p> <ul> <li>Nada impide crear listas heterog\u00e9neas de objetos. Eso causa problemas evidentes de casting, adem\u00e1s de imposible incoherencias.</li> <li>Si se desea acceder a propiedades espec\u00edficas de otro tipo de clases, ser\u00e1 necesario realizar una cantidad grande de conversiones en el c\u00f3digo, lo que har\u00e1 que sea m\u00e1s pesado de comprender.</li> <li>Los m\u00e9todos de las clases e interfaces de las colecciones no se adaptan al tipo de datos que contienen dificultando su uso.</li> </ul> <p>Por ello aparecieron los tipos gen\u00e9ricos en la versi\u00f3n 1.5 de Java consiguiendo solucionar los problemas anteriores en las colecciones.</p>"},{"location":"bloque_ii/tema_10/page-1/#2-idea-general-de-los-genericos","title":"2. Idea general de los gen\u00e9ricos","text":"<p>Los gen\u00e9ricos permiten crear clases y m\u00e9todos en los que los tipos de datos (las clases) sobre los que act\u00faan son un par\u00e1metro m\u00e1s. Gracias a ello se pueden crear clases y m\u00e9todos que se adaptan a distintos tipos de datos de forma autom\u00e1tica.</p> <p>Anteriormente a la aparici\u00f3n de los gen\u00e9ricos el que las clases y m\u00e9todos se adaptaran autom\u00e1ticamente pasaba por especificar par\u00e1metros de tipo Object, ya que las referencias de tipo Object valen para cualquier otro tipo de objeto.</p> <p>El problema es que la coherencia no est\u00e1 asegurada con los tipos Object, la sintaxis del lenguaje puede provocar excepciones de tipo ClassCastException ante conversiones err\u00f3neas de Object a otro tipo de datos.</p> <p>La idea es:</p> <ol> <li>El programar declara un gen\u00e9rico en un m\u00e9todo de clase, por ejemplo T</li> <li>Cuando se utilice dicha clase o m\u00e9todo se indicar\u00e1 un tipo concreto, entonces se cambia el gen\u00e9rico para que se refiera a ese tipo concreto.</li> </ol>"},{"location":"bloque_ii/tema_10/page-2/","title":"10.2 Uso de gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-2/#1-genericos-en-metodos","title":"1. Gen\u00e9ricos en m\u00e9todos","text":"<p>Se pueden indicar gen\u00e9ricos en los m\u00e9todos. Para indicar que el m\u00e9todo se puede utilizar con cualquier tipo de objeto y que el m\u00e9todo se adaptar\u00e1 a dicho tipo. La sintaxis es: <code>modificadores &lt;Gen\u00e9rico&gt; tipoRetorno nombreM\u00e9todo(...)</code></p> <p>Ejemplo:</p> <pre><code>public class ArrayUtils{\npublic static &lt;T&gt; T getRandom(T a[]){\nint i = new Random().nexInt(a.length-1);\nreturn a[i];\n}\n}\n</code></pre> <p>En el ejemplo anterior, se desea obtener un elemento aleatorio de un array. En el ejemplo la letra T entre los signos &lt; y &gt; indica que se va a utilizar un tipo gen\u00e9rico, el hecho de que le siga otra T significa que el tipo que devuelve el m\u00e9todo tomarAleatorio ser\u00e1 el mismo que el del par\u00e1metro a, y se corresponder\u00e1 al tipo gen\u00e9rico T. Despu\u00e9s cuando se invoque a este m\u00e9todo, la letra gen\u00e9rica T ser\u00e1 traducida por el tipo con el que se invoque al m\u00e9todo. Por ejemplo desde este c\u00f3digo:</p> <pre><code>String a[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString element = ArraysUtils.getRandom(a);\nSystem.out.println(element);\n</code></pre> <p>En ese c\u00f3digo, como se invoca usando un array de Strings, por lo tanto la letra gen\u00e9rica T ser\u00e1 traducida por String. Es decir es como si el c\u00f3digo anterior se tradujera como:</p> <pre><code>public class UtilesArrays {\npublic static String tomarAleatorio(String a[]){\nint i=(int)(Math.random()*a.length);\nreturn a[i];\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#2-genericos-en-las-clases","title":"2. Gen\u00e9ricos en las clases","text":"<p>El m\u00e9todo habitual de utilizar gen\u00e9ricos, debido a su mayor potencia, es declarar el gen\u00e9rico en una clase. De esta forma indicados que el c\u00f3digo de la clase utiliza tipos gen\u00e9ricos que ser\u00e1n traducidos por el tipo de datos que se desee.</p> <p>Por ejemplo una clase pensada para extraer elementos aleatorios de un array del tipo que sea se podr\u00eda declarar as\u00ed:</p> <pre><code>public class RandomElement&lt;T&gt;{\nprivate T element;\npublic RandomElement(T array[]){\nelement = array[new Random(array.length)];\n}\npublic T getElement(){\nreturn element;\n}\n}\n</code></pre> <p>Los tipos se indican tras el nombre de la clase. De esta forma cuando se creen objetos de clase RandomElement habr\u00e1 que indicar la clase por la que se traducir\u00e1 el gen\u00e9rico T. Por ejemplo:</p> <pre><code>public static void main(String[] args){\nString a[] = {\"uno\", \"dos\", \"tres\", \"cuatro\"};\nRandomElement&lt;String&gt; e = new RandomElement&lt;String&gt;(a);\nSystem.out.println(a.getElement());\n}\n</code></pre> <p>Obs\u00e9rvese que tanto al declarar el objeto e hay que concretar el valor del gen\u00e9rico de ah\u00ed que la declaraci\u00f3n sea <code>RandomElement&lt;String&gt; e</code> de ese modo ya queda claro la traducci\u00f3n de <code>T</code>. A partir de ese momento ya todos los m\u00e9todos de clase y propiedades que utilizaran el gen\u00e9rico <code>T</code>, ahora utilizar\u00e1n el tipo <code>String</code>. En definitiva los gen\u00e9ricos de clase marcan las posiciones para la clase concreta que habr\u00e1 que especificar en la creaci\u00f3n del objeto. Lo bueno es que pueden convivir distintas concreciones de gen\u00e9ricos, podr\u00eda ser:</p> <pre><code>RandomElement&lt;String&gt; e1 = new RandomElement&lt;String&gt;(a1);\nRandomElement&lt;Integer&gt; e2 = new RandomElement&lt;Integer&gt;(a2);\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#3-interfaces-con-genericos","title":"3. Interfaces con gen\u00e9ricos","text":"<p>Al igual que las clases, las interfaces pueden utilizar gen\u00e9ricos en las mismas condiciones que en \u00e9stas:</p> <pre><code>public interface Comparable&lt;T&gt;{\nT lower();\nT upper();\n}\n</code></pre> <p>Una clase que implemente la interfaz puede hacerlo as\u00ed:</p> <pre><code>public class Clase1 implements Compar&lt;String&gt;{\n</code></pre> <p>De modo que traduce el gen\u00e9rico de la interfaz por un tipo concreto o bien:</p> <pre><code>public class Clase1 &lt;T&gt; implements Compar&lt;T&gt;{\n</code></pre> <p>De modo que no traduce el gen\u00e9rico y espera a que durante la creaci\u00f3n de objetos de esa clase se indique el tipo concreto para el gen\u00e9rico.</p>"},{"location":"bloque_ii/tema_10/page-2/#4-uso-de-varios-genericos","title":"4. Uso de varios gen\u00e9ricos","text":"<p>Tanto en m\u00e9todos, como en clases o interfaces, es posible utilizar dos tipos gen\u00e9ricos e incluso m\u00e1s. Para ello se separan por comas dentro del operador diamante. Ejemplo:</p> <pre><code>public class CompareObjects&lt;T, U&gt;{\nprotected T object1;\nprotected U object2;\npublic CompareObjects(T object1, U object2){\nthis.object1 = object1;\nthis.object2 = object2;\n}\npublic boolean sameFirstLetter(){\nString letter1 = object1.getClass().getName().substring(1,1);\nString letter2 = object2.getClass().getName().substring(1,1);\nreturn letter1.equalsIgnoreCase(letter2);\n}\n}\n</code></pre> <p>Esta clase (que en realidad no es muy \u00fatil), construye un objeto a partir de otros dos. El primero de tipo gen\u00e9rico <code>T</code>, y el segundo de tipo <code>U</code>. El m\u00e9todo <code>sameFirstLetter</code> devuelve verdadero si el nombre de clase de <code>T</code> empieza por la misma letra que <code>U</code>.</p> <p>Para utilizar esta clase:</p> <pre><code>public static void main(String[] args){\nString s1 = \"Hola\";\nStringBuffer s2 = new StringBuffer(\"Adi\u00f3s\");\nCompareObjects&lt;String, StringBuffer&gt; comp = new CompareObjects&lt;String, StringBuffer&gt;(s1,s2);\nSystem.out.println(comp.sameFirstLetter());\n}\n</code></pre> <p>Devolver\u00e1 verdadero porque tanto <code>String</code> como <code>StringBuffer</code> empiezan por <code>S</code>. En el ejemplo <code>T</code> se convertir\u00e1 en String y <code>U</code> en <code>StringBuffer</code>.</p>"},{"location":"bloque_ii/tema_10/page-3/","title":"10.3 Gen\u00e9ricos avanzados","text":""},{"location":"bloque_ii/tema_10/page-3/#limitacion-de-los-tipos-posibles-en-un-generico","title":"Limitaci\u00f3n de los tipos posibles en un gen\u00e9rico","text":"<p>A veces no interesa que las clases acepten a cualquier tipo de objeto, sino a objetos de un determinado tipo y sus descendientes. Eso es posible indicarlo mediante la palabra <code>extends</code> dentro de la declaraci\u00f3n del gen\u00e9rico. Ejemplo:</p> <pre><code>public class HandlerVehicles &lt;V extends Vehicles&gt;{\nprotected V vehicle;\npublic HandlerVehicles(V vehicle){\nthis.vehicle = vehicle;\n}\npublic void start(){\nvehicle.start();\n}\n}\n</code></pre> <p>En el ejemplo, a la clase se le puede indicar cualquier clase descendiente de <code>Vehicle</code>, pero ninguna otra. Por ejemplo:</p> <pre><code>HandlerVehicle&lt;Car&gt; v1 = new HandlerVehicle&lt;Car&gt;();\nHandlerVehicle&lt;Autocar&gt; v2 = new HandlerVehicle&lt;Autocar&gt;\n</code></pre> <p>Sin embargo, no se podr\u00eda declarar:</p> <pre><code>HandlerVehicle&lt;String&gt; v3 = HandlerVehicle&lt;String&gt;(e);\n</code></pre> <p>No es posible porque la clase String no es heredera de ning\u00fan veh\u00edculo. La raz\u00f3n de utilizar esta cl\u00e1usula tan restrictiva est\u00e1 en el hecho de poder realizar acciones que sabemos que s\u00f3lo son posibles en cierto tipo de objetos. La clase <code>HandlerVehicle</code> necesita arrancar el veh\u00edculo, por ello tenemos que asegurar que el gen\u00e9rico no puede ser ninguna clase incompatible.</p> <p>Por otro lado extends no tiene por qu\u00e9 referirse a clases, tambi\u00e9n puede referirse a interfaces. Ejemplo:</p> <pre><code>public class Clase1 &lt;V extends Comparable&gt;{\n</code></pre> <p>Significa que la Clase1 usa un gen\u00e9rico al que se le puede asignar cualquier clase que implemente la interfaz Comparable.</p>"},{"location":"bloque_ii/tema_10/page-3/#tipos-comodin","title":"Tipos comod\u00edn","text":"<p>Aunque parece que todo est\u00e1 resuelto de esta forma. Hay problemas cuando mezclamos objetos de la misma clase pero distinta traducci\u00f3n de gen\u00e9rico. Es el caso de este ejemplo:</p> <pre><code>public class RandomElement&lt;T&gt;{\nprivate T element;\nprivate int index;\npublic RandomElement(T array[]){\nindex = new Random().nextInt(array.length);\nelement = array[index];\n}\npublic T getElement(){\nreturn element;\n}\npublic int getIndex(){\nreturn index;\n}\npublic boolean sameIndex(RandomElement&lt;T&gt; random){\nreturn random.index = index;\n}\n}\n</code></pre> <p>En este caso la clase RandomElement se le ha a\u00f1adido una propiedad que almacena el \u00edndice aleatorio que obtiene el constructor. Eso permite que construyamos un m\u00e9todo llamado <code>sameIndex</code> que recibe un objeto de clase RandomElement y nos dice si el \u00edndice aleatorio calculado fue el mismo. Para usar este m\u00e9todo:</p> <pre><code>String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString[] s2 = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"};\nRandomElement&lt;String&gt; r1 = new RandomElement&lt;String&gt;(s1);\nRandomElement&lt;String&gt; r2 = new RandomElement&lt;String&gt;(s2);\nSystem.out.println(r1.sameIndex(r2));\n</code></pre> <p>El c\u00f3digo funciona, s\u00f3lo devolver\u00e1 verdadero si tanto el objeto <code>r1</code> como en <code>r2</code>, el \u00edndice tiene el mismo valor. Sin embargo, este otro c\u00f3digo fallara:</p> <p>```java hl_lines= 6 String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}; Integer[] s2 = {1,2,3,4,5,6}; RandomElement r1 = new RandomElement(s1); RandomElement r2 = new RandomElement(s2); <p>System.out.println(r1.sameIndex(r2)); <pre><code>El error ocurre en tiempo de compilaci\u00f3n. La raz\u00f3n, que en la l\u00ednea remarcada, el objeto `r1` es ya de tipo `RandomElement&lt;String&gt;` por lo que el m\u00e9todo `sameIndex` s\u00f3lo puede aceptar objetos de tipo `RandomElement&lt;String&gt;`, ya que el gen\u00e9rico T se tradujo como STring. El problema est\u00e1 en que dicho m\u00e9todo tiene que poder aceptar cualquier tipo de objeto de tipo `RandomElement`.\n\nPara ello se usa el signo `&lt;?&gt;` de ese modo indicamos la posibilidad de aceptar cualquier tipo de clase con gen\u00e9rico. Es decir el m\u00e9todo se reescribir\u00eda as\u00ed:\n\n```java\npublic boolean sameIndex(RandomElement&lt;?&gt; random){\n    return random.getIndex() == index;\n}\n</code></pre></p> <p>De esa forma se indica que random es un objeto de tipo <code>RandomElement</code> tenga el tipo que tenga el gen\u00e9rico.</p> <p>Incluso se puede delimitar el gen\u00e9ricos:</p> <pre><code>public boolean sameIndex(RandomElement&lt;? extends Number&gt; random){\nreturn random.getIndex() == index;\n}\n</code></pre> <p>Ahora el m\u00e9todo acepta cualquier tipo de <code>RandomElement</code> pero siempre y cuando el tipo gen\u00e9rico forme parte de la herencia <code>Number</code></p>"},{"location":"bloque_iii/tema_11/page-1/","title":"1 Introducci\u00f3n a las colecciones","text":""},{"location":"bloque_iii/tema_11/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Una colecci\u00f3n representa un grupo de objetos. Estos objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almac\u00e9n donde poder guardarlos.</p> <p>Las colecciones son estructuras de datos con la peculiaridad de que son estructuras din\u00e1micas. Eso quiere decir que pueden aumentar o disminuir su tama\u00f1o dependiendo de los elementos que almacenan, lo que suponen una mejora respecto a las estructuras de datos est\u00e1ticas cuyo tama\u00f1o se define en su creaci\u00f3n y no se puede alterar en tiempo de ejecuci\u00f3n, como por ejemplo, los arrays.</p> <p>El API de Java nos proporciona en el paquete <code>java.util</code> el framework de las colecciones, que nos permite utilizar diferentes estructuras de datos para almacenar y recuperar objetos de cualquier clase. Java tiene desde la versi\u00f3n 2 todo un juego de clases e interfaces para guardar colecciones de objetos donde todas las entidades conceptuales est\u00e1n representadas por interfaces y las clases se usan para proveer implementaciones de esas interfaces. Estas clases e interfaces est\u00e1n estructuradas en una jerarqu\u00eda.</p> <p>Pero \u00bfqu\u00e9 podemos almacenar dentro de una colecci\u00f3n? Podemos almacenar cualquier objeto que herede de la clase <code>Object</code>. Pero esto presenta ciertos inconvenientes:</p> <ul> <li>Podr\u00edamos tener una colecci\u00f3n con objetos completamente distintos, lo que puede dar lugar a problemas ya que en todo momento deber\u00edamos saber qu\u00e9 tipo de objeto y qu\u00e9 posici\u00f3n de la colecci\u00f3n se encuentra el elementos con el que queremos trabajar, de otro modo podr\u00edamos tener incongruencias en el c\u00f3digo e incluso hacer saltar una excepci\u00f3n.</li> <li>Otro inconveniente es que tendr\u00edamos que hacer continuos castings para poder trabajar con los elementos de la colecci\u00f3n, lo cual resulta tedioso y poco productivo.</li> </ul> <p>Veamos un ejemplo para obtener la suma de los valores almacenados en una lista:</p> <pre><code>int total = 0;\nArrayList numbers = new ArrayList(); // Creaci\u00f3n de la lista\nnumbers.add(1); // Se a\u00f1ade el elemento 1 a la lista utilizando el m\u00e9todo add\nnumbers.add(2);\nnumbers.add(3);\nfor(int i = 0; i &lt; numbers.size(); i++){\n// No vemos obligados a hacer cast, dado que numbers.get(i) retorna un Object:\ntotal += (int) numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>Como vemos en el ejemplo anterior, nos vemos obligados a hacer expl\u00edcitamente un cast cuando obtenemos un elemento de la lista, dado que la lista internamente trabaja con elementos de la clase <code>Object</code>. No hay ning\u00fan contrato que permita a la clase <code>ArrayList</code> saber qu\u00e9 tipo de datos queremos que trabaje.</p> <p>Adem\u00e1s, es posible a\u00f1adir elementos de distinto tipo a la lista, con el agravante de que m\u00e1s adelante cuando se intenta acceder al elemento y se hace cast sobre \u00e9l se producir\u00e1 un error en tiempo de ejecuci\u00f3n. As\u00ed, si modificamos el ejemplo anterior de la siguiente manera:</p> <pre><code>int total = 0;\nArrayList numbers = new ArrayList(); numbers.add(1);\nnumbers.add(2);\nnumbers.add(\"Antonio\");\nfor(int i = 0; i &lt; numbers.size(); i++){\n// Esta l\u00ednea lanza una excepci\u00f3n cuando\n// se trata de convertir a entero el elemento \"Antonio\",\ntotal += (int) numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>As\u00ed pues, para resolver este problema, a partir de la versi\u00f3n 5 de Java empezaron a utilizar los gen\u00e9ricos. Los gen\u00e9ricos nos permiten establecer un tipo con el que vamos a trabajar en esa colecci\u00f3n, de esa manera podemos evitar los problemas mencionados anteriormente.</p> <p>As\u00ed el ejemplo anterior podr\u00edamos modificarlo de la siguiente manera:</p> <pre><code>int total = 0;\nArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); numbers.add(1);\nnumbers.add(2);\n//Esta l\u00ednea da un error de compilaci\u00f3n, dado que el compilador\n// detecta que estamos intentado a\u00f1adir una cadena a la lista de enteros:\nnumbers.add(\"Antonio\");\nfor(int i = 0; i &lt; numbers.size(); i++){\n// Ya no es necesario hacer un cast expl\u00edcito, dado que el compilador\n// lo har\u00e1 internamente por nosotros, al haberle informado de que quer\u00edamos\n// trabajar con una lista de enteros\ntotal += numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>Como vemos en el ejemplo anterior, gracias a la informaci\u00f3n que le suministramos al compilador sobre el tipo de lista con el que queremos trabajar, en este caso <code>Integer</code>, el compilador es capaz de detectar en tiempo de compilaci\u00f3n que no deber\u00eda ser posible a\u00f1adir una cadena a la lista, y adem\u00e1s nos evita tener que hacer expl\u00edcitamente el cast a entero cuando obtenemos los elementos de la lista, porque ya lo puede hacer \u00e9l internamente por nosotros.</p> <p>Lo que se use en un gen\u00e9rico debe ser un objeto, por lo tanto, los gen\u00e9ricos no funcionan con datos primitivos. Para resolver esta situaci\u00f3n, la API de Java incorpora las clases envoltorio (wrapper class) que no son m\u00e1s que dotar a los datos primitivos con un envoltorio que permita tratarlos como objetos. Las clases envoltorios proporcionan m\u00e9todos de utilidad para la manipulaci\u00f3n de datos primitivos (conversiones de / hacia datos primitivos, conversiones a String, etc).</p>"},{"location":"bloque_iii/tema_11/page-2/","title":"2 ArrayList","text":""},{"location":"bloque_iii/tema_11/page-2/#interfaz-collection","title":"Interfaz Collection","text":"<p>Es la interfaz ra\u00edz de la jerarqu\u00eda de las colecciones. Java no proporciona ninguna implementaci\u00f3n directa de esta interfaz, sino que proporciona implementaciones de sub-interfaces m\u00e1s espec\u00edficas como Set y List. Esta interfaz se utiliza normalmente para pasar colecciones y manipularlas cuando se desea la m\u00e1xima generalidad.</p> <p>Veamos algunos de los m\u00e9todos que podemos observar en la API</p> <ul> <li><code>boolean add(E e)</code>: a\u00f1ade el elemento e a la colecci\u00f3n.</li> <li><code>boolean addAll(Collection &lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de la colecci\u00f3n c.</li> <li><code>void clear()</code>: elimina todos los elementos de la colecci\u00f3n.</li> <li><code>boolean contains(Object o)</code>: comprueba si el elemento o est\u00e1 en la colecci\u00f3n.</li> <li>boolean containsAll(Collection&lt;?&gt; c) : comprueba si todos los elementos de c est\u00e1n en la colecci\u00f3n.</li> <li><code>boolean isEmpty()</code>: comprueba si la colecci\u00f3n est\u00e1 vac\u00eda.</li> <li><code>boolean remove(Object o)</code>: elimina de la colecci\u00f3n el elemento o.</li> <li><code>boolean removeAll(Collection&lt;?&gt; c)</code>: elimina de la colecci\u00f3n todos los elementos de c.</li> <li><code>boolean retainAll(Collection&lt;?&gt; c)</code>: elimina de la colecci\u00f3n todos los elementos exceptos los que est\u00e1n en c, es decir, obtiene la intersecci\u00f3n.</li> <li><code>int size()</code>: devuelve el tama\u00f1o de la colecci\u00f3n.</li> </ul>"},{"location":"bloque_iii/tema_11/page-2/#interfaz-list","title":"Interfaz List","text":"<p>Esta interfaz es una sub-interfaz o interfaz hija de Collection, por lo tanto, tiene todos los m\u00e9todos de Collection y adem\u00e1s a\u00f1ade los suyos propios.</p> <p>Este tipo de colecci\u00f3n se refiere a listas en las que los elementos de la colecci\u00f3n tienen un orden, es decir, existe una secuencia de elementos. Cada elemento tiene un \u00edndice o posici\u00f3n. El primer elemento ocupa la posici\u00f3n 0. La interfaz List s\u00ed admite elementos duplicados.</p> <p>Veamos algunos de los m\u00e9todos que podemos observar en la API:</p> <ul> <li><code>void add(int index, E element)</code>: inserta el elemento E en la posici\u00f3n index.</li> <li><code>boolean add(E e)</code>: a\u00f1ade el elemento e al final de la lista.</li> <li><code>boolean addAll(int index, Collection &lt;? extends E&gt; c)</code>: inserta todos los elementos de c en la posici\u00f3n index.</li> <li><code>boolean addAll(Collection &lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de c al final de la lista.</li> <li><code>E get(int index)</code>: devuelve el elemento de la posici\u00f3n index.</li> <li><code>int indexOf(Object o)</code>: devuelve el \u00edndice de la primera ocurrencia del elemento o en la lista, o -1 si la lista no contiene el elemento.</li> <li><code>int lastIndexOf(Object o)</code>: devuelve el \u00edndice de la \u00faltima ocurrencia del elemento o en la lista, o -1 si la lista no contiene el elemento.</li> <li><code>E remove(int index)</code>: elimina el elemento que se encuentra en la posici\u00f3n index. E set(int index, E element): reemplaza el elemento que se encuentra en index por el elemento element.</li> <li><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code>: devuelve la sub-lista comprendida entre las posiciones fromIndex incluida y toIndex excluida.</li> </ul> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java para la interfaz List, como por ejemplo, ArrayList.</p>"},{"location":"bloque_iii/tema_11/page-2/#la-clase-arraylist","title":"La clase ArrayList","text":"<p>Se basa en un array redimensionable que aumenta su tama\u00f1o seg\u00fan crece la colecci\u00f3n de elementos. Lo bueno es que el tiempo de acceso a un elemento en particular es \u00ednfimo. Lo malo es que si queremos eliminar un elemento del principio o del medio, la clase debe mover todos los que le siguen a la posici\u00f3n anterior, para tapar el agujero que deja el elemento removido. Esto hace que sacar elementos del medio o del principio sea costoso.</p> <p>ArrayList mantiene el orden de inserci\u00f3n, es decir, si recorremos la colecci\u00f3n se nos mostrar\u00e1 en el mismo orden en que insertamos los objetos.</p> <p>Veamos un ejemplo de declaraci\u00f3n e inicializaci\u00f3n:</p> <pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n</code></pre> <p>A partir de java7, no es necesario indicar el gen\u00e9rico en la inicializaci\u00f3n:</p> <pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n</code></pre> <p>Para hacer el c\u00f3digo m\u00e1s gen\u00e9rico, se puede definir la variable de tipo interfaz, ya que dicho c\u00f3digo podr\u00eda funcionar con cualquier clase que implemente la interfaz, simplemente habr\u00eda que cambiar el new:</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n</code></pre> <p>Veamos un ejemplo de ArrayList donde utiliza m\u00e9todos tanto de Collection como de List:</p> C\u00f3digoSalida <pre><code>import java.util.ArrayList;\nimport java.util.List;\npublic class ShowArrayList{\npublic void show(){\nList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\nList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\nList&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();\nlist1.add(1);\nlist1.add(2);//Se a\u00f1aden los elementos al final de la lista\nlist1.add(6);\nlist1.add(2, 5);//Se a\u00f1ade el 5 en la posici\u00f3n 2\nfor (Integer i : list1) {//Recorremos la lista con un bucle for-each: 1 2 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist2.add(3);\nlist2.add(4);\nlist1.addAll(2, list2);//Se inserta list2 en la posici\u00f3n 2 de list1\nfor (Integer i : list1) {// 1 2 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist3.add(7);\nlist3.add(8);\nlist1.addAll(list3);//Se inserta list3 al final de list1\nfor (Integer i : list1) {// 1 2 3 4 5 6 7 8\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl elemento 3 de list1 es: %d\", list1.get(3));//4\nSystem.out.printf(\"\\nLa posici\u00f3n del 4 en list1 es: %d\", list1.indexOf(4));//3\nlist1.add(4);//Se a\u00f1ade un 4 al final de list1\nSystem.out.printf(\"\\nLa posici\u00f3n del 4 en list1 por el final es: %d\\n\", list1.lastIndexOf(4));//8\nlist1.remove(8);//Se elimina el elemento de la posici\u00f3n 8, que es el \u00faltimo 4 insertado\nfor (Integer i : list1) {// 1 2 3 4 5 6 7 8\nSystem.out.printf(\" %d \", i);\n}\nlist1.set(6, 8);//Se reemplaza el elemento que se encuentra en la posici\u00f3n 6 por un 8\nSystem.out.println();\nfor (Integer i : list1) {// 1 2 3 4 5 6 8 8\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nLa sub-lista comprendida entre las posiciones 2 y 5 es: \");\nfor (Integer i : list1.subList(2, 6)) {// 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl 4 %s se encuentra en list1\", list1.contains(4) ? \"s\u00ed\" : \"no\");//s\u00ed\nSystem.out.printf(\"\\nEl 9 %s se encuentra en list1\", list1.contains(9) ? \"s\u00ed\" : \"no\");//no\n//list1: 1 2 3 4 5 6 8 8\n//list2: 3 4\n//list3: 7 8\nSystem.out.printf(\"\\nTodos los elementos de list2 %s se encuentran en list1\", list1.containsAll(list2) ? \"s\u00ed\" : \"no\");//s\u00ed\nSystem.out.printf(\"\\nTodos los elementos de list3 %s se encuentran en list1\\n\",\nlist1.containsAll(list3) ? \"s\u00ed\" : \"no\");//no\nlist1.removeAll(list3);//Se eliminan de list1 todos los elementos de list3, es decir, el 8\nfor (Integer i : list1) {// 1 2 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist1.retainAll(list2);//Intersecci\u00f3n entre list1 y list2\nfor (Integer i : list1) {// 3 4\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl tama\u00f1o de list1 es: %d\", list1.size());//2\nSystem.out.printf(\"\\nlist1 %s est\u00e1 vac\u00eda\", list1.isEmpty() ? \"s\u00ed\" : \"no\");//no\nlist1.clear();//Elimina todos los elementos de list1\nSystem.out.printf(\"\\nlist1 %s est\u00e1 vac\u00eda\", list1.isEmpty() ? \"s\u00ed\" : \"no\");//s\u00ed\n}\npublic static void main(String[] args) {\nnew ShowArrayList().show();\n}\n}\n</code></pre> <pre><code>1 2 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6 7 8\nEl elemento 3 de list1 es: 4\nLa posici\u00f3n del 4 en list1 es: 3\nLa posici\u00f3n del 4 en list1 por el final es: 8\n1 2 3 4 5 6 7 8\n1 2 3 4 5 6 8 8\nLa sub-lista comprendida entre las posiciones 2 y 5 es: 3 4 5 6\nEl 4 s\u00ed se encuentra en list1\nEl 9 no se encuentra en list1\nTodos los elementos de list2 s\u00ed se encuentran en list1\nTodos los elementos de list3 no se encuentran en list1\n1 2 3 4 5 6\n3 4\nEl tama\u00f1o de list1 es: 2\nlist1 no est\u00e1 vac\u00eda\nlist1 s\u00ed est\u00e1 vac\u00eda\n</code></pre>"},{"location":"bloque_iii/tema_11/page-2/#iteradores","title":"Iteradores","text":"<p>En dise\u00f1o de software, el patr\u00f3n de dise\u00f1o Iterador (en ingl\u00e9s, Iterator) define una interfaz que declara los m\u00e9todos necesarios para acceder secuencialmente a un grupo de objetos de una colecci\u00f3n.</p> <p>Este patr\u00f3n debe ser utilizado cuando se requiera una forma est\u00e1ndar de recorrer una colecci\u00f3n, es decir, cuando no sea necesario que un cliente sepa el tipo de colecci\u00f3n que est\u00e1 recorriendo.</p> <p>La interfaz <code>Iterable&lt;T&gt;</code> contiene el m\u00e9todo iterator() que devuelve una instancia de alguno clase que implemente la interfaz <code>Iterator&lt;T&gt;</code>:</p> <ul> <li><code>Iterator&lt;T&gt; iterator()</code>: devuelve un iterador al comienzo de la colecci\u00f3n.</li> </ul> <p>La interfaz <code>Iterator&lt;E&gt;</code> permite el acceso secuencial a los elementos de una colecci\u00f3n y realizar recorridos sobre la colecci\u00f3n. Los m\u00e9todos de <code>Iterator&lt;E&gt;</code> son:</p> <ul> <li><code>boolean hasNext()</code>: comprueba si hay siguiente elemento.</li> <li><code>E next()</code>: devuelve el siguiente elemento y mueve el iterador.</li> <li><code>void remove()</code>: se invoca despu\u00e9s de next() para eliminar el \u00faltimo elemento le\u00eddo.</li> </ul> <p>La interfaz <code>Collection&lt;E&gt;</code> es una sub-interfaz o interfaz hija de <code>Iterable&lt;E&gt;</code>, as\u00ed que dispone del m\u00e9todo <code>iterator()</code>. Veamos un ejemplo de un <code>ArrayList&lt;E&gt;</code>utilizando iteradores:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class ShowIterator{\npublic void show(){\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile(it.hashNext()){\nSystem.out.println(it.next());\n}\n}\npublic static void main(String[] args){\nnew ShowIterator().show();\n}\n}\n</code></pre> <pre><code>Juan\nAntonio\nJaime\nVicente\n</code></pre> <p>Si no hay siguiente, <code>next()</code> lanza una excepci\u00f3n <code>NoSuchElementException</code>:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class NextException {\npublic void show() {\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nit = list.iterator();\nSystem.out.println(it.next());\nSystem.out.println(it.next());//(1)!\n}\npublic static void main(String[] args) {\nnew NextException().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n una excepci\u00f3n <code>NoSuchElementException</code></li> </ol> <p>Tal y como vemos en el ejemplo anterior, hay que comprobar si hay siguiente con un <code>hashNext()</code> para que el <code>next()</code> no lance la excepci\u00f3n.</p> <p>No se puede modificar la colecci\u00f3n dentro del bucle for-each porque se lanza en ejecuci\u00f3n la excepci\u00f3n <code>ConcurrentModificationException</code>, ya que estamos recorriendo y modificando la lista a la vez:</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\npublic class ModifyInsideForEach {\npublic void show() {\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nfor (String s : list) {//(1)!\nSystem.out.printf(\" %s \", s);\nif (s.equals(\"Antonio\")) {\nlist.remove(\"Antonio\");\n}\n}\n}\npublic static void main(String[] args) {\nnew ModifyInsideForEach().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n la excepci\u00f3n <code>ConcurrentModificationException</code></li> </ol> <p>Para solucionarlo, podemos utilizar el m\u00e9todo <code>remove()</code>de <code>Iterator&lt;E&gt;</code>. Si se modifica una colecci\u00f3n mientras se recorre, los iteradores quedan invalidados, a excepci\u00f3n del m\u00e9todo <code>remove()</code> de la interfaz <code>Iterator&lt;E&gt;</code>. El m\u00e9todo <code>remove()</code> permite eliminar elementos de la colecci\u00f3n siendo la \u00fanica forma adecuada para eliminar elementos durante la iteraci\u00f3n:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveIterator {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveIterator().show();\n}\n}\n</code></pre> <pre><code>Juan\nJaime\nVicente\n</code></pre> <p>Solo puede haber una invocaci\u00f3n a <code>remove()</code> por cada invocaci\u00f3n <code>next()</code>. Si no cumple, se lanza en ejecuci\u00f3n una excepci\u00f3n <code>IllegalStateException</code>. Por ejemplo, imaginemos que tenemos una lista de personas y queremos eliminar a Antonio y a la persona que venga detr\u00e1s. Si cuando encontramos a Antonio, hacemos dos <code>remove()</code> seguidos, entonces salta la excepci\u00f3n:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveNext1 {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\nit.remove();//(1)!\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveNext1().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n la excepci\u00f3n <code>IllegalStateException</code></li> </ol> <p>Tendr\u00edamos que hacer otro <code>next()</code> para el que venga detr\u00e1s de Antonio:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveNext2 {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\nit.next();\nit.remove();\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveNext2().show();\n}\n}\n</code></pre> <pre><code>Juan\nVicente\n</code></pre> <p>La interfaz <code>ListIterator&lt;E&gt;</code> es una subinterfaz o interfaz hija de <code>Iterator&lt;E&gt;</code>. Es un iterador para listas que permite al programador recorrer la lista hacia delante y hacia atr\u00e1s, modificar la lista durante la iteraci\u00f3n y obtener la posici\u00f3n actual del iterador en la lista.</p> <p>Hereda los m\u00e9todos de <code>Iterador&lt;E&gt;</code> y adem\u00e1s aporta otros m\u00e9todos nuevos:</p> <ul> <li><code>void add(E e)</code>: inserta el elemento en la lista antes del elemento que ser\u00eda devuelto por next(), si lo hubiera, y despu\u00e9s del elemento que ser\u00eda devuelto por previous(), si lo hubiera. Una llamada posterior a next() no se ver\u00eda afectada y una llamada posterior a previous() devolver\u00eda el nuevo elemento.</li> <li><code>boolean hasPrevious()</code>: comprueba si hay un elemento anterior.</li> <li><code>int nextIndex()</code>: devuelve el \u00edndice del elemento que ser\u00eda devuelto por una llamada a next(). El \u00edndice del primer elemento es 0.</li> <li><code>E previous()</code>: devuelve el elemento anterior de la lista y mueve la posici\u00f3n del cursor hacia atr\u00e1s.</li> <li><code>int previousIndex()</code>: devuelve el \u00edndice del elemento que ser\u00eda devuelto por una llamada a previous().</li> <li><code>void set(E e)</code>: sustituye el \u00faltimo elemento devuelto por next() o previous() por elemento e.</li> </ul> <p>En la interfaz <code>List&lt;E&gt;</code>, hay dos m\u00e9todos para crear este iterador:</p> <ul> <li><code>ListIterator&lt;E&gt; listIterator()</code>: se coloca antes del primer elemento para que al hacer el primer next() se devuelva el primer elemento.</li> <li><code>ListIterator&lt;E&gt; listIterator(int index)</code>: se coloca antes del elemento que se encuentra en la posici\u00f3n index para que al hacer un next() se devuelva dicho elemento. Para recorrer la lista al rev\u00e9s, hay que crearlo con el tama\u00f1o de la lista para que el primer previous() devuelva el \u00faltimo.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\npublic class ShowListIterator {\npublic void show() {\nListIterator&lt;Integer&gt; it;\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(1);\nlist.add(2);\nlist.add(4);\nlist.add(6);\n//Recorrido de la lista hacia atr\u00e1s:\nit = list.listIterator(list.size());\nwhile (it.hasPrevious()) {\nSystem.out.printf(\" %d \", it.previous());// 6 4 2 1\n}\nit = list.listIterator(1);//Se coloca antes del elemento que se encuentra en la posici\u00f3n 1\nSystem.out.printf(\"\\n %d \", it.next());//2\nSystem.out.printf(\"\\n %d \", it.nextIndex());//2\nSystem.out.printf(\"\\n %d \", it.previousIndex());//1\nit.add(3);\nSystem.out.printf(\"\\n %d \", it.next());//4 Una llamada posterior a next() no se ve afectada\nit.add(5);\nSystem.out.printf(\"\\n %d \", it.previous());//5 Una llamada posterior a previous() devuelve el nuevo elemento\nSystem.out.printf(\"\\n %d \\n\", it.next());//5\nit.set(7);//sustituye el \u00faltimo elemento devuelto por next() por 7\nfor (Integer i : list) {\nSystem.out.printf(\" %d \", i);//1 2 3 4 7 6\n}\n}\npublic static void main(String[] args) {\nnew ShowListIterator().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/","title":"3 Conjuntos","text":""},{"location":"bloque_iii/tema_11/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Un conjunto es una lista formada por elementos que no se repiten. Para ello, la JVM usar\u00e1 los m\u00e9todos <code>equals</code> y <code>hashCode</code> heredados la clase clase Object para comprobar si dos elementos son iguales.</p> <p>Son m\u00e9todos heredados de la clase <code>Object</code>. Normalmente, hay que sobrescribirlos para adaptarlo de forma adecuada a la clase correspondiente.</p> <p>Sin embargo, debemos tener en cuenta que al sobrescribir todos estos m\u00e9todos debemos seguir cumpliendo con el comportamiento que se espera de ellos, ya que son usados internamente por muchas clases del propio lenguaje. De lo contario, las clases que dependen de ello, como <code>HashMap</code>y <code>HashSet</code> dejar\u00edan de funcionar correctamente.</p> <p>Escribir a mano los m\u00e9todos <code>equals()</code> y <code>hashCode()</code> es bastante tedioso. Para facilitarnos esta tarea tenemos librer\u00edas como la librer\u00eda AutoValue de Google que lo genera autom\u00e1ticamente para nosotros con tan s\u00f3lo usar una determinada anotaci\u00f3n. Otra opci\u00f3n es dejar que el IDE nos genere dichos m\u00e9todos, aunque esto tiene el inconveniente de que no se generan autom\u00e1ticamente de nuevo conforme a\u00f1adimos atributos a nuestro clase, por lo que debemos tener cuidado, algo que s\u00ed hace AutoValue. En todo caso, es mejor usar el IDE que hacerlo nosotros a mano, ya que el humano es m\u00e1s propenso a los errores. En el Eclipse se encuentra en <code>Men\u00fa Source \u2192 Generate hashCode() and equals()</code>.</p>"},{"location":"bloque_iii/tema_11/page-3/#metodo-equals","title":"M\u00e9todo <code>equals</code>","text":"<p>El m\u00e9todo <code>equals()</code> comprueba si dos objetos son iguales.</p> <p>En caso de que no se sobrescriba dicho m\u00e9todo, s\u00f3lo ser\u00e1 igual a s\u00ed misma, es decir, si est\u00e1 situada en la misma posici\u00f3n de memoria.</p> <p>Debemos tener en cuenta que cuando un programador usa el m\u00e9todo <code>equals()</code> sobre un objeto pas\u00e1ndole como argumento otro objeto lo que pretende es descubrir si ambos objetos son equivalentes l\u00f3gicamente(representa el mismo \"valor\"), no si est\u00e1n almacenados en la misma posici\u00f3n de memoria (tienen la misma identidad).</p> <p>No sobrescribir el m\u00e9todo <code>equals()</code> en una determinada clase es la opci\u00f3n recomendada en los siguientes casos:</p> <ul> <li>Cuando cada instancia de la clase es intr\u00ednsecamente \u00fanica, lo cual es cierto para clases como <code>Scanner</code> que representan entidades activas en lugar de valores.</li> <li>Cuando se considera que no hay necesidad de que la clase provea una prueba de equivalencia l\u00f3gica.</li> <li>Cuando una superclase de la clase ya lo ha sobrescrito y el comportamiento de la superclase es apropiado para las subclase.</li> <li>Cuando la clase es privada o friendly, y estamos completamente seguros de que su m\u00e9todo <code>equals()</code> nunca ser\u00e1 invocado, ni expl\u00edcita ni impl\u00edcitamente.</li> </ul> <p>Si nuestra clase no se encuentra en ninguno de los casos anteriores es muy recomendable que sobrescribamos el m\u00e9todo <code>equals()</code>. Un ejemplo muy caracter\u00edstico es cuando la clase corresponda a una entidad que represente un valor.</p> <p>Como hemos comentado, cuando sobrescribamos el m\u00e9todo <code>equals()</code> debemos seguir cumpliendo el comportamiento que el sistema espera de \u00e9l, que incluye las siguientes propiedades:</p> <ul> <li>Reflexiva: Para todo objeto x distinto de null se debe cumplir que <code>x.equals(x)</code> sea true.</li> <li>Sim\u00e9trica: Para todo par de objetos x e y y distintos de null se debe cumplir que <code>x.equals(y)</code> s\u00f3lo debe retornar true si <code>y.equals(x)</code> retorna true.</li> <li>Transitiva: Para todo tr\u00edo de objetos x, y, z distintos de null se debe cumplir que si <code>x.equals(y)</code> retorne true y <code>y.equals(z)</code> retorna true entonces <code>x.equals(z)</code> debe retornar true.</li> <li>Consistente: Para todo par de objetos x e y distintos de null se debe cumplir que <code>x.equals(y)</code>siempre retorne el mismo valor si no hemos cambiado los atributos que se usan para comparar en alguno de los objetos.</li> <li>Para todo objeto x distinto de null se debe cumplir que <code>x.equals(null)</code>debe retornar false.</li> </ul> <p>As\u00ed para sobrescribir el m\u00e9todo <code>equals()</code> cumpliendo con las propiedades anteriores se recomienda seguir los siguientes pasos:</p> <ol> <li>Usar el operador <code>==</code> para comprobar si el argumento corresponde a otra referencia al mismo objeto, en cuyo caso retornar true.</li> <li>Usar el operador <code>instanceof</code> para comprobar si el objeto recibido como argumento no es de la misma clase, en cuyo caso retornar false. Tambi\u00e9n nos sirve para comprobar si dichos argumento es null, ya que en este caso instanceof retornar\u00eda false.</li> <li>Hacer cast del objeto recibido como argumento convirti\u00e9ndolo a la clase correspondiente. Dado que hemos hecho antes instanceof, el cast siempre tendr\u00e1 \u00e9xito.</li> <li>Para cada atributo significativo de la clase, comprobar que dicho atributo en el objeto argumento es equivalente al atributo en el objeto this. Si no tenemos \u00e9xito en alguno de ellos, retornar false. Si todas las comprobaciones se han hecho con \u00e9xito, retornar true. Para realizar las comprobaciones de cada atributo usar:<ul> <li>El operador <code>==</code> para valores primitivos que no sean float ni double.</li> <li>Para los valores float usar <code>Float.compare(value1, value2)</code> y para valores double usar <code>Double.compare(value1, value2)</code>.</li> <li>Para valores correspondientes a objetos llamar a <code>equals()</code> recursivamente. Si es v\u00e1lido que dichos objetos contengan null, entonces debemos usar <code>Objects.equals(object1, object2)</code> para que no se produzca la excepci\u00f3n <code>NullPointerException</code>.</li> <li>Para los valores correspondientes a arrays, compara uno a uno los elementos significativos del array. Si todos los elementos son significativos, usa alguno de las versiones del m\u00e9todo est\u00e1tico <code>Arrays.equals()</code>.</li> </ul> </li> </ol> <p>Veamos un ejemplo:</p> <pre><code>public final class PhoneNumber{\nprivate final short areaCode, prefix, lineNum;\n@Override\npublic boolean equals(Object o){\nif(o == this) return true;\nif(!(o instanceof PhoneNumber)) return false;\nPhoneNumber pn = (PhoneNumber) o;\nreturn pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n}\n//...\n}\n</code></pre> <p>\u00a1CUIDADO!</p> <p>Un aspecto muy importante es que no debemos cambiar el tipo del objeto recibido como argumento, que siempre debe ser <code>Object</code>, o no estaremos sobrescribiendo el m\u00e9todo <code>equals()</code>, sino sobrecarg\u00e1ndolo, lo que puede producir falsos positivos. El compilador no se quejar\u00e1 si no usamos la anotaci\u00f3n <code>@Override</code> (por eso siempre se recomienda usarla). Por ejemplo, nunca hagas esto:</p> <pre><code>public boolean equals(MyClass o){\n//...\n}\n</code></pre> <p>Nota</p> <p>Algunas veces, para comparar que una variable de tipo String es equivalente a una determinada constante de cadena se usa la construcci\u00f3n \"Hello\".equals(message) , ya que dicho construcci\u00f3n no puede lanzar NullPointerException si message es null, sino que tan s\u00f3lo retornar\u00e1 false, mientras que message.equals(\"Hello\") lanzar\u00eda NullPointerException en ese caso.</p>"},{"location":"bloque_iii/tema_11/page-3/#metodo-hashcode","title":"M\u00e9todo <code>hashCode</code>","text":"<p>El m\u00e9todo <code>hashCode()</code> devuelve un n\u00famero entero que identifica al objeto cuando se guarda en algunas estructuras de datos.</p> <p>Un detalla muy importante que no debemos olvidar es que **si en una clase sobrescribimos el m\u00e9todo <code>equals()</code> debemos obligatoriamente sobrescribir tambi\u00e9n el m\u00e9todo <code>hashCode()</code> o de lo contrario no se estar\u00e1 cumpliendo con el comportamiento esperado de este \u00faltimo, lo que impedir\u00e1 que los objetos de dichas clase funcionen correctamente en colecciones como <code>HashMap</code> y <code>HashSet</code>.</p> <p>El comportamiento que se espera de <code>hashCode()</code> es el siguiente:</p> <ul> <li>Debe ser consistente, es decir, que repetidas llamadas al m\u00e9todo <code>hashCode()</code> deben retornar el mismo valor, siempre y cuando no se haya modificado ninguno de los atributos usados para las comparaciones.</li> <li>Si dos objetos son equivalentes, es decir, si <code>x.equals(y)</code> retorna true, entonces <code>x.hashCode()</code> e <code>y.hashCode()</code> deben retornar el mismo valor entero. \u00c9ste ees el motivo por el que siempre que sobrescribamos <code>equals()</code> debemos sobrescribir <code>hashCode()</code>, ya que la implementaci\u00f3n por defecto de <code>hashCode()</code> de la clase <code>Object</code> devuelve una representaci\u00f3n num\u00e9rica de la direcci\u00f3n de memoria en la que se encuentra ubicado el objeto.</li> <li>Si dos objetos no son equivalentes, es decir si <code>x.equals(y)</code> retorna false, no es estrictamente necesario, aunque si recomendable, que <code>x.hashCode()</code> e <code>y.hashCode()</code> retornen valores diferentes, de manera que se mejore el rendimiento de las tablas hash. Idealmente el algoritmo de la funci\u00f3n hash debe distribuir una colecci\u00f3n de instancias de un tama\u00f1o considerable de forma uniforme entre todos los valores enteros.</li> </ul> <p>La implementaci\u00f3n caracter\u00edstica al sobrescribir el m\u00e9todo <code>hashCode()</code> en la clase <code>PhoneNumber</code> es la siguiente, usando los atributos areaCode, prefix, lineNum.</p> <pre><code>public final class PhoneNumber{\nprivate final short areaCode, prefix, lineNum;\n@Override\npublic boolean equals(Object o){\nif(o == this) return true;\nif(!(o instanceof PhoneNumber)) return false;\nPhoneNumber pn = (PhoneNumber) o;\nreturn pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n}\n@Override\npublic int hashCode(){\nint result = Short.hashCode(areaCode);\nresult = 31 * result + Short.hashCode(prefix);\nresult = 31 * result + Short.hashCode(lineNum);\nreturn result;\n}\n//...\n}\n</code></pre> <p>Adem\u00e1s de escribir nosotros a mano el c\u00f3digo del m\u00e9todo <code>hashCode()</code>, podemos usar la implementaci\u00f3n proporcionada por algunas librer\u00edas, como Guava o AutoValue, o usar la implementaci\u00f3n de los IDEs.</p> <p>Por otra parte, podemos usar <code>Objects.hashCode(object...)</code> para sobrescribir el m\u00e9todo con una sola l\u00ednea. Desafortunadamente, este m\u00e9todo es bastante menos eficiente de lo esperado, debido a que recibe un array de atributos y de que realiza boxing y unboxing de los atributos que sean de un tipo primitivo. Por ejemplo:</p> <pre><code>public final class PhoneNumber{\nprivate final short areaCode, prefix, lineNum;\n@Override\npublic boolean equals(Object o){\nif(o == this) return true;\nif(!(o instanceof PhoneNumber)) return false;\nPhoneNumber pn = (PhoneNumber) o;\nreturn pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n}\n@Override\npublic int hashCode(){\nreturn Objects.hash(lineNum, prefix, areaCode);\n}\n//...\n}\n</code></pre> <p>Si una clase es inmutable y el coste de calcular el valor hash es significativo, podr\u00eda considerar almacenar cacheado el c\u00f3digo hash en el propio objecto, en lugar de recalcularlo cada vez que se solicite. Si cree que la mayor\u00eda de los objetos de esta clase se usar\u00e1n como claves hash, entonces deber\u00eda calcular el c\u00f3digo hash cuando se cree la instancia. De lo contario, podr\u00eda elegir calcular perezosamente el c\u00f3digo hash la primera vez que se invoque el m\u00e9todo <code>hash()</code>.</p> <p>Dos consideraciones finales:en primer lugar no excluya atributos significativos del c\u00e1lculo de valor hash, as\u00ed lograr\u00e1 un mejor rendimiento, al no repetir tanto los valores. En segundo lugar, no proporcione a los clientes de la clase demasiada informaci\u00f3n acerca de c\u00f3mo se calcula el valor hash de esta manera el c\u00f3digo no podr\u00e1 depender de c\u00f3mo se calcula, permiti\u00e9ndonos modificar la implementaci\u00f3n del m\u00e9todo en el futuro sin afectar a los clientes.</p>"},{"location":"bloque_iii/tema_11/page-3/#colecciones-sin-duplicados","title":"Colecciones sin duplicados","text":"<p>La interfaz <code>Set</code>, que hereda de Collection, permite implementar listas de elementos sin duplicados, es decir, modela la abstracci\u00f3n matem\u00e1tica de los conjuntos.</p> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java:</p> <ul> <li>HashSet: esta implementaci\u00f3n almacena los elementos de una tabla hash. Es la implementaci\u00f3n con mejor rendimiento de todas pero no garantiza ning\u00fan orden a la hora de realizar iteraciones.</li> <li>LinkedHashSet: est\u00e1 implementaci\u00f3n almacena los elementos en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que HashSet.</li> <li>TreeSet: est\u00e1 implementaci\u00f3n utiliza una estructura de \u00e1rbol para ordenar los elementos. Es bastante m\u00e1s lenta que HashSet.</li> </ul>"},{"location":"bloque_iii/tema_11/page-3/#clase-hashset","title":"Clase HashSet","text":"<p>Implementa la interfaz <code>Set</code>. Es la clase m\u00e1s utilizada para implementar listas sin duplicados. Esta clase permite el elemento nulo. No garantiza ning\u00fan orden a la hora de realizar iteraciones.</p> <p>Utiliza internamente una tabla de tipos hash:</p> <p> Figura 1 - Hashtable</p> <p>Al querer guardar un objeto en esta estructura, se llama al m\u00e9todo hashCode() el cual devuelve un n\u00famero entero que la estructura usar\u00e1 para decidir en qu\u00e9 caj\u00f3n debe recuperar el objeto. El objetivo de guardar los datos de esta forma y de llamar al m\u00e9todo es lograr almacenar y recuperar la informaci\u00f3n en tiempo constante (lo cual no ocurre siempre, pero se acerca). El que no suceda esto depende, casi siempre, del valor que devuelva el m\u00e9todo <code>hashCode()</code> para cada objeto.</p> <p>Supongamos que guardamos 3 objetos en esta estructura y el m\u00e9todo <code>hashCode()</code> de los 3 devuelve 0, esto quiere decir que los 3 objetos se guardar\u00e1n en el caj\u00f3n 0. Cuando se necesite recuperar un objeto, hay que recorrer los objetos del caj\u00f3n 0 para determinar cu\u00e1l es el que se quiere recuperar. Por lo tanto, este m\u00e9todo <code>hashCode()</code> no es \u00fatil ya que lo que se pretende al guardar los elementos es que \u00e9stos queden dispersos de forma uniforme en toda la estructura quedando la menor cantidad de cajones vac\u00edos y que no haya cajones donde se guarden muchos m\u00e1s elementos que en otros.</p> <p>Si dos objetos tiene el mismo <code>hashCode()</code>, ambos objetos se guardar\u00e1n en el mismo caj\u00f3n. La estructura usa entonces el m\u00e9todo <code>equals()</code> dentro de ese caj\u00f3n para determinar cu\u00e1l corresponde con el solicitado y para eso depende de que el programador haya sobrescrito el m\u00e9todo, de lo contrario no garantiza un resultado correcto.</p> <p> Figura 2 - Hash</p> <p>Los objetos HashSet se construyen con un tama\u00f1o inicial de tabla (el tama\u00f1o del array) y un factor de carga que indica cu\u00e1ndo se debe redimensionar el array. Es decir, si se cre\u00f3 un array de 100 elementos y la carga se estableci\u00f3 al 80%, cuando se hayan rellanado 80 valores, se redimensiona el array. Por defecto, el tama\u00f1o del array se toma con 16 y el factor de carga con 0,75 (75%). No obstante, se puede construir una lista HashSet indicando ambos par\u00e1metros.</p> <p>Esta implementaci\u00f3n proporciona tiempos constantes en las operaciones b\u00e1sicas siempre y cuando la funci\u00f3n hash disperse de forma correcta los elementos dentro de la tabla hash. Es importante definir el tama\u00f1o inicial de la tabla ya que este tama\u00f1o marcar\u00e1 el rendimiento de esta implementaci\u00f3n.</p> <p>Veamos un ejemplo de <code>HashSet</code> con la clase <code>Vehicle</code>. Los atributos significativos a tener en cuenta para el <code>equals()</code> y el <code>hashCode()</code> son wheelCount y colour. La velocidad (speed) no se incluye ya que si comparamos el mismo coche pero con velocidades distintas, en realidad, no deja de ser el mismo coche.</p> VehicleMainConsola <pre><code>public class Vehicle {\nprivate int wheelCount;\nprivate double speed;\nprivate String colour;\npublic Vehicle(int wheelCount, String colour) {\nthis.wheelCount = wheelCount;\nthis.colour = colour;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic String getColour() {\nreturn colour;\n}\npublic void setColour(String colour) {\nthis.colour = colour;\n}\npublic void accelerate(double amount) {\nspeed += amount;\n}\npublic void brake(double amount) {\nspeed -= amount;\n}\n@Override\npublic String toString() {\nreturn \"Vehicle [wheelCount=\" + wheelCount + \", speed=\" + speed + \",colour=\" + colour + \"]\";\n}\n@Override\npublic int hashCode() {\nfinal int prime = 31;\nint result = 1;\nresult = prime * result + ((colour == null) ? 0 : colour.hashCode());\nresult = prime * result + wheelCount;\nreturn result;\n}\n@Override\npublic boolean equals(Object obj) {\nif (this == obj)\nreturn true;\nif (obj == null)\nreturn false;\nif (!(obj instanceof Vehicle))\nreturn false;\nVehicle other = (Vehicle) obj;\nif (colour == null) {\nif (other.colour != null)\nreturn false;\n} else if (!colour.equals(other.colour))\nreturn false;\nif (wheelCount != other.wheelCount)\nreturn false;\nreturn true;\n}\n}\n</code></pre> <pre><code>import java.util.HashSet;\nimport java.util.Set;\npublic class ShowHashSet {\npublic void show() {\nSet&lt;Vehicle&gt; set = new HashSet&lt;&gt;();\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"verde\"));\nfor (Vehicle v : set) {\nSystem.out.println(v);//Se llama al toString del objeto\n}\n}\npublic static void main(String[] args) {\nnew ShowHashSet().show();\n}\n}\n</code></pre> <pre><code>Vehicle [wheelCount=4, speed=0.0, colour=verde]\nVehicle [wheelCount=4, speed=0.0, colour=azul]\nVehicle [wheelCount=2, speed=0.0, colour=rojo]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/#clase-linkedhashset","title":"Clase LinkedHashSet","text":"<p>Almacena los elementos en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que HashSet.</p> MainConsola <pre><code>import java.util.LinkedHashSet;\nimport java.util.Set;\npublic class ShowLinkedHashSet {\npublic void show() {\nSet&lt;Vehicle&gt; set = new LinkedHashSet&lt;&gt;();\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"verde\"));\nfor (Vehicle v : set) {\nSystem.out.println(v);//Se llama al toString del objeto\n}\n}\npublic static void main(String[] args) {\nnew ShowLinkedHashSet().show();\n}\n}\n</code></pre> <pre><code>Vehicle [wheelCount=4, speed=0.0, colour=azul]\nVehicle [wheelCount=2, speed=0.0, colour=rojo]\nVehicle [wheelCount=4, speed=0.0, colour=verde]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/#clase-enumset","title":"Clase EnumSet","text":"<p>Es una implementaci\u00f3n de conjuntos de alto rendimiento de tipos enumerados. Require que las constantes de enumeraci\u00f3n colocadas en \u00e9l pertenezcan al mismo tipo de enumeraci\u00f3n. Veamos algunos de sus m\u00e9todos:</p> <ul> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; allOf(Class&lt;E&gt; elementType)</code>: crea un conjunto de enumeraciones que contiene todos los valores del tipo de enumeraci\u00f3n especificado.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(EnumSet&lt;E&gt; s)</code>: crea un conjunto de numeraciones con el mismo tipo que el conjunto de enumeraciones especificado, conteniendo inicialmente todos los elementos de este tipo que no est\u00e1n contenidos en el conjunto especificado.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; copyOf(EnumSet&lt;E&gt; s)</code>: crea un conjunto de enumeraciones a partir de otro.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType)</code>: crea un conjunto de enumeraciones vac\u00edo con el tipo de elemento especificado.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E e)</code>: crea un conjunto de enumeraciones que contiene el elemento especificado. Este m\u00e9todo tiene varias sobrecargas para admitir m\u00e1s elementos.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; range(E from, E to)</code>: crea un conjunto de enumeraciones que contiene inicialmente todos los elementos del rango definido por los dos elementos especificados.</li> </ul> ENUMShowEnumSet <pre><code>public enum Operation {\nPLUS(\"+\"), MINUS(\"-\"), TIMES(\"*\"), DIVIDE(\"/\");\nprivate final String symbol;\nprivate Operation(String symbol) {\nthis.symbol = symbol;\n}\npublic String getSymbol() {\nreturn symbol;\n}\n}\n</code></pre> <pre><code>public class ShowEnumSet {\npublic void show() {\nEnumSet&lt;Operation&gt; allOperations1, allOperations2, operations1, operations2, operations3, operations4;\nallOperations1 = EnumSet.allOf(Operation.class);\nSystem.out.printf(\"allOf: %s\", allOperations1);//allOf: [PLUS, MINUS,TIMES, DIVIDE]\nallOperations2 = EnumSet.copyOf(allOperations1);\nSystem.out.printf(\"\\ncopyOf: %s\", allOperations2);//copyOf: [PLUS,MINUS, TIMES, DIVIDE]\noperations1 = EnumSet.noneOf(Operation.class);\noperations1.add(Operation.PLUS);\noperations1.add(Operation.MINUS);\nSystem.out.printf(\"\\nnoneOf y add: %s\", operations1);//noneOf y add: [PLUS, MINUS]\noperations2 = EnumSet.complementOf(operations1);\nSystem.out.printf(\"\\ncomplementOf: %s\", operations2);//complementOf:[TIMES, DIVIDE]\noperations3 = EnumSet.of(Operation.DIVIDE, Operation.MINUS);\nSystem.out.printf(\"\\nof: %s\", operations3);//of: [MINUS, DIVIDE]\noperations4 = EnumSet.range(Operation.MINUS, Operation.DIVIDE);\nSystem.out.printf(\"\\nrange: %s\\n\", operations4);//range: [MINUS,TIMES, DIVIDE]\nSystem.out.println(operations4.contains(Operation.PLUS));//false\nSystem.out.println(operations4.contains(Operation.MINUS));//true\n}\npublic static void main(String[] args) {\nnew ShowEnumSet().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-4/","title":"4 Mapas","text":""},{"location":"bloque_iii/tema_11/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Las colecciones de tipo Set tienen el inconveniente de tener que almacenar una copia exacta del elemento a buscar. Sin embargo, en la pr\u00e1ctica es habitual que haya datos que se consideren clave, es decir, que identifican a cada objeto (el dni de las personas por ejemplo) de tal manera que buscan los datos en base a esa clave y por otro lado se almacenan el resto de los datos. Los mapas permiten definir colecciones de elementos que poseen pares de datos clave-valor. Esto se utiliza para localizar valores en funci\u00f3n de la clave que poseen. Son muy interesantes y r\u00e1pidos. Los mapas tambi\u00e9n son conocidos como diccionarios.</p> <p>La interfaz <code>Map&lt;K,V&gt;</code> es la ra\u00edz de todas las clases que implementan mapas. Hasta la versi\u00f3n 5, los mapas eran colecciones de pares clave-valor donde tanto la clave como el valor eran de tipo Object. Desde la versi\u00f3n versi\u00f3n 5, esta interfaz tiene dos gen\u00e9ricos: <code>K</code> para el tipo de datos de la clave y <code>V</code> para el tipo de los valores. Esta estructura de datos nos permite obtener el objeto <code>V</code> muy r\u00e1pidamente a partir de su clave <code>K</code>.</p> <p>Esta interfaz no hereda de Collection por lo que no tiene los m\u00e9todos vistos anteriormente. La raz\u00f3n es que la obtenci\u00f3n, b\u00fasqueda y borrado de elementos se hace de una manera muy distinta.</p> <p>Las claves no se pueden repetir por lo que se implementan con una tabla hash para que no haya duplicados. Por lo tanto, la clase que se utilice como clave tiene que sobrescribir sus m\u00e9todos <code>equals()</code> y <code>hashCode()</code>.</p> <p>Veamos algunos m\u00e9todos de esta interfaz:</p> <ul> <li><code>boolean containsKey(Object key)</code>: devuelve true si el mapa contiene dicha clave.</li> <li><code>boolean containsValue(Object value)</code>: devuelve true si el mapa contiene dicho valor.</li> <li><code>V get(Object key)</code>: devuelve el valor asociado a la clave o null si no existe esa clave en el mapa.</li> <li><code>V getOrDefault(Object V, defaultValue)</code>: devuelve el valor asociado a la clave o defaultValue si no existe esa clave en el mapa.</li> <li><code>V put(K key, V value)</code>: a\u00f1ade un par clave-valor al mapa. Si ya hab\u00eda un valor para esa clave, se reemplaza. Devuelve el valor que ten\u00eda antes dicha clave o null si la clave no estaba en el mapa.</li> <li><code>V putIfAbsent(K key, V value)</code>: si la clave especificada no est\u00e1 ya asociada a un valor o est\u00e1 asignada a null, se le asocia el valor dado y devuelve null, en caso contrario, devuelve el valor previamente asociado con la clave.</li> <li><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code>: a\u00f1ade los pares claves-valor del mapa m.</li> <li><code>V remove(Object key)</code>: elimina la clave y su valor asociado, el cual se devuelve. Si no existe dicha clave, devuelve null.</li> </ul> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java:</p> <ul> <li><code>HashMap</code>: esta implementaci\u00f3n almacena las claves en una tabla hash. Es la implementaci\u00f3n con mejor rendimiento de todas pero no garantiza ning\u00fan orden a la hora de realizar iteraciones.</li> <li><code>LinkedHashMap</code>: esta implementaci\u00f3n almacena las claves en funci\u00f3n del orden de la inserci\u00f3n. Es un poco m\u00e1s costosa que <code>HashMap</code>.</li> <li><code>TreeMap</code>: esta implementaci\u00f3n utiliza la estructura del \u00e1rbol para ordenar las claves. Es bastante m\u00e1s lenta que <code>HashMap</code>. La veremos m\u00e1s adelante en el apartado de los \u00e1rboles.</li> </ul>"},{"location":"bloque_iii/tema_11/page-4/#clase-hashmap","title":"Clase HashMap","text":"<p>Esta implementaci\u00f3n proporciona tiempos constantes en las operaciones b\u00e1sicas siempre y cuando la funci\u00f3n hash disperse de forma correcta las claves dentro de la tabla hash. Es importante definir el tama\u00f1o inicial de la tabla ya que este tama\u00f1o marcar\u00e1 el rendimiento de esta implementaci\u00f3n. No garantiza ning\u00fan orden a la hora de recorrer el mapa.</p> <p>Veamos un ejemplo de un mapa de veh\u00edculos donde la clave es la matr\u00edcula. A\u00f1adimos la matr\u00edcula como atributo por lo que hay generar de nuevo los m\u00e9todos <code>toString()</code>, <code>hashCode()</code>y <code>equals()</code>:</p> VehicleShowHashMapConsola <pre><code>public class Vehicle{\nprivate String registration; // Atributo para almacenar la matr\u00edcula del coche\nprivate int wheelCount;\nprivate double speed;\nprivate String colour;\npublic Vehicle(String registration, int wheelCount, String colour){\nthis.registration = registration;\nthis.wheelCount = wheelCount;\nthis.colour = colour;\nspeed = 0;\n}\npublic int getWheelCount(){\nreturn wheelCount;\n}\npublic double getSpeed(){\nreturn speed;\n}\npublic String getColour(){\nreturn colour;\n}\npublic void setColour(String colour){\nthis.colour = colour;\n}\npublic String getRegistration(){\nreturn registration;\n}\npublic void accelerate(double amount){\nspeed += amount;\n}\npublic void brake(double amount){\nspeed -= amount;\n}\n@Override\npublic String toString(){\nreturn \"Vehicle [registration=\" + registration + \", wheelCount=\" + wheelCount + \", speed=\" + speed + \", colour=\" + colour + \"]\";\n}\n@Override\npublic int hashCode(){\nfinal int prime = 31;\nint result = 1;\nresult = prime * result + ((colour == null) ? 0 : colour.hashCode());\nresult = prime * result + ((registration == null) ? 0 : registration.hashCode());\nresult = prime * result + wheelCount;\nreturn result;\n}\n@Override\npublic boolean equals(Object obj){\nif(this == obj) return true;\nif(obj == null) return false;\nif(!(obj instanceof Vehicle)) return false;\nVehicle other = (Vehicle) obj;\nif(colour == null){\nif(other.colour != null){\nreturn false;\n}\n} else if(!colour.equals(other.colour)){\nreturn false;\n}\nif(registration == null){\nif(other.registration != null){\nreturn false;\n}\n} else if(!registration.equals(other.registration)){\nreturn false;\n}\nif(wheelCount != other.wheelCount){\nreturn false;\n}\nreturn true;\n}\n}\n</code></pre> <pre><code>public class ShowHashMap {\npublic void show() {\nMap&lt;String, Vehicle&gt; map = new HashMap&lt;&gt;();\nMap&lt;String, Vehicle&gt; map2 = new HashMap&lt;&gt;();\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nfor (int i = 0; i &lt; vehicles.length; i++) {\nmap.put(vehicles[i].getRegistration(), vehicles[i]);\n}\nSystem.out.println(map.containsKey(\"1005SAW\"));//false\nSystem.out.println(map.containsKey(\"1705UBG\"));//true\nSystem.out.println(map.containsValue(new Vehicle(\"5930POI\", 4,\"negro\")));//false\nSystem.out.println(map.containsValue(new Vehicle(\"5930POI\", 2,\"negro\")));//true\nSystem.out.println(map.get(\"4554ASD\"));//null\nSystem.out.println(map.get(\"1705UBG\"));//Vehicle[registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nSystem.out.println(map.getOrDefault(\"8080SAS\", new Vehicle(\"4554ASD\", 4, \"negro\")));//Vehicle [registration=4554ASD, wheelCount=4, speed=0.0,colour=negro]\nSystem.out.println(map.getOrDefault(\"1705UBG\", new Vehicle(\"4554ASD\", 4, \"negro\")));//Vehicle [registration=1705UBG, wheelCount=4, speed=0.0,colour=blanco]\nSystem.out.println(map.put(\"6320LPL\", new Vehicle(\"6320LPL\", 2,\n\"verde\")));//null\nSystem.out.println(map.put(\"6320LPL\", new Vehicle(\"6320LPL\", 4,\n\"beis\")));//Vehicle [registration=6320LPL, wheelCount=2, speed=0.0,colour=verde]\nSystem.out.println(map.putIfAbsent(\"4687RTB\", new Vehicle(\"4687RTB\", 2, \"blanco\")));//null\nSystem.out.println(map.putIfAbsent(\"4687RTB\", new Vehicle(\"4687RTB\", 4, \"naranja\")));//Vehicle [registration=4687RTB, wheelCount=2, speed=0.0,colour=blanco]\nSystem.out.println(map.remove(\"1234ABC\"));//null\nSystem.out.println(map.remove(\"4687RTB\"));//Vehicle[registration=4687RTB, wheelCount=2, speed=0.0, colour=blanco]\nSystem.out.printf(\"El mapa tiene %d veh\u00edculos\", map.size());\nmap2.put(\"7410HJH\", new Vehicle(\"7410HJH\", 4, \"rojo\"));\nmap2.put(\"8520FGF\", new Vehicle(\"8520FGF\", 2, \"verde\"));\nmap.putAll(map2);//a\u00f1ade a map los pares clave-valor del mapa map2\nSystem.out.printf(\"\\nDespu\u00e9s de a\u00f1adirle map2, el mapa tiene %d veh\u00edculos\", map.size());\n}\npublic static void main(String[] args) {\nnew ShowHashMap().show();\n}\n}\n</code></pre> <pre><code>false\ntrue\nfalse\ntrue\nnull\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0 colour=blanco]\nVehicle [registration=4554ASD, wheelCount=4, speed=0.0, colour=negro]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nnull\nVehicle [registration=6320LPL, wheelCount=2, speed=0.0, colour=verde]\nnull\nVehicle [registration=4687RTB, wheelCount=2, speed=0.0, colour=blanco]\nnull\nVehicle [registration=4687RTB, wheelCount=2, speed=0.0, colour=blanco]\nEl mapa tiene 7 veh\u00edculos\nDespu\u00e9s de a\u00f1adirle map2, el mapa tiene 9 veh\u00edculos\n</code></pre> <p>Veamos las distintas maneras de recorrer un mapa:</p> <ul> <li><code>Set&lt;K&gt; keySet()</code>: devuelve un conjunto con todas las claves. como entre las claves no puede haber elementos duplicados, las claves forman un conjunto (Set).</li> <li><code>Collection&lt;V&gt; values()</code>: devuelve una colecci\u00f3n con todos los valores. Los valores s\u00ed pueden estar duplicados, por lo tanto, este m\u00e9todo devuelve un Collection.</li> <li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet</code>: devuelve un conjunto de objetos Map.Entry. Los pares de elementos (tambi\u00e9n llamados entradas) de los que est\u00e1 compuesto un Map son de un tipo que viene implementado por la interfaz Map.Entry. La interfaz Map.Entry se define de forma interna a la interfaz Map y representa un objeto de par clave-valor, es decir, mediante esta interfaz podemos trabajar con una entrada del mapa. Veamos algunos m\u00e9todos de la interfaz Map.Entry. <li><code>K getKey()</code>: retorna la clave.</li> <li><code>V getValue()</code>: retorna el valor.</li> <li><code>V setValue(V value)</code>: reemplaza el valor por value y devuelve el valor anterior.</li> TraverseHashMapConsola <pre><code>public class TraverseHashMap {\npublic void show() {\nMap&lt;String, Vehicle&gt; map = new HashMap&lt;&gt;();\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nfor (int i = 0; i &lt; vehicles.length; i++) {\nmap.put(vehicles[i].getRegistration(), vehicles[i]);\n}\nSystem.out.println(\"Claves del mapa:\\n\");\nfor (String s : map.keySet()) {//keySet() devuelve un conjunto con todas las claves\nSystem.out.println(s);\n}\nSystem.out.println(\"\\nValores del mapa:\\n\");\nfor (Vehicle v : map.values()) {//values() devuelve una colecci\u00f3n con todos los veh\u00edculos\nSystem.out.println(v);\n}\nSystem.out.println(\"\\nPares clave-valor del mapa usando un foreach:\\n\");\nfor (Map.Entry&lt;String, Vehicle&gt; entry : map.entrySet()) {\nSystem.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\",entry.getKey(), entry.getValue());\n}\nSystem.out.println(\"\\nPares clave-valor del mapa usando iteradores:\\n\");\nSet&lt;Map.Entry&lt;String, Vehicle&gt;&gt; entrySet = map.entrySet();\nIterator&lt;Map.Entry&lt;String, Vehicle&gt;&gt; it = entrySet.iterator();\nMap.Entry&lt;String, Vehicle&gt; entry;\nwhile (it.hasNext()) {\nentry = it.next();\nSystem.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\",\nentry.getKey(), entry.getValue());\n}\n}\npublic static void main(String[] args) {\nnew TraverseHashMap().show();\n}\n}\n</code></pre> <pre><code>Claves del mapa:\n\n3495JZA\n1705UBG\n1235GTR\n7314QWE\n9685KMX\n5930POI\n\nValores del mapa:\n\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nPares clave-valor del mapa usando un foreach:\n\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nMatr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nPares clave-valor del mapa usando iteradores:\n\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nMatr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-4/#clase-linkedhashmap","title":"Clase LinkedHashMap","text":"<p>Almacena las claves en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que <code>HashMap</code>.</p> MainConsola <pre><code>public class ShowLinkedHashMap {\npublic void show() {\nMap&lt;String, Vehicle&gt; map = new LinkedHashMap&lt;&gt;();\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nfor (int i = 0; i &lt; vehicles.length; i++) {\nmap.put(vehicles[i].getRegistration(), vehicles[i]);\n}\nfor (Map.Entry&lt;String, Vehicle&gt; entry : map.entrySet()) {\nSystem.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\",entry.getKey(), entry.getValue());\n}\n}\npublic static void main(String[] args) {\nnew ShowLinkedHashMap().show();\n}\n}\n</code></pre> <pre><code>Matr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nMatr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\n</code></pre> <p>Podemos observar que los datos se muestran en el mismo orden en el que se insertaron.</p>"},{"location":"bloque_iii/tema_11/page-4/#ejemplo-de-uso-de-un-mapa-en-un-enum","title":"Ejemplo de uso de un mapa en un enum","text":"<p>Si hemos sobrescrito el m\u00e9todo <code>toString()</code> o las instancias del enum tienen alguna forma adicional de referirnos a ellas, tiene bastante sentido que creemos un m\u00e9todo est\u00e1tico parecido a <code>valueOf()</code>, pero que reciba dicha forma adicional de referirnos a las instancias.</p> EnumMainConsola <pre><code>public enum Operation {\nPLUS(\"+\") {\n@Override\npublic double apply(double x, double y) {\nreturn x + y;\n}\n},\nMINUS(\"-\") {\n@Override\npublic double apply(double x, double y) {\nreturn x - y;\n}\n},\nTIMES(\"*\") {\n@Override\npublic double apply(double x, double y) {\nreturn x * y;\n}\n},\nDIVIDE(\"/\") {\n@Override\npublic double apply(double x, double y) {\nreturn x / y;\n}\n};\nprivate final String symbol;\nprivate static final Map&lt;String, Operation&gt; symbolToOperation = Map.of(Operation.PLUS.getSymbol(), Operation.PLUS, Operation.MINUS.getSymbol(), Operation.MINUS, Operation.TIMES.getSymbol(), Operation.TIMES,Operation.DIVIDE.getSymbol(), Operation.DIVIDE);\nprivate Operation(String symbol) {\nthis.symbol = symbol;\n}\npublic String getSymbol() {\nreturn symbol;\n}\npublic abstract double apply(double x, double y);\npublic static Operation fromSymbol(String symbol) {\nreturn symbolToOperation.get(symbol);\n}\n}\n</code></pre> <pre><code>public class ExampleUseMapEnum {\npublic void show() {\nOperation operation;\noperation = Operation.fromSymbol(\"+\");//operation se asigna con la instancia correspondiente al s\u00edmbolo +\nSystem.out.printf(\"La variable operation es de tipo enum %s y su s\u00edmbolo es %s\", operation, operation.getSymbol());\n}\npublic static void main(String[] args) {\nnew ExampleUseMapEnum().show();\n}\n}\n</code></pre> <pre><code>La variable operation es de tipo enum PLUS y su s\u00edmbolo es +\n</code></pre> <p>Como vemos en el c\u00f3digo anterior, creamos un mapa est\u00e1tico que relaciona cada s\u00edmbolo con cada instancia, de manera que podamos obtener la instancia adecuada a partir del s\u00edmbolo. Debemos tener en cuenta que no est\u00e1 permitido que los constructores de las instancias de un enum accedan a los atributos est\u00e1ticos del enum, con la excepci\u00f3n de las constantes de las instancias, dado que los atributos est\u00e1ticos a\u00fan no han sido inicializados cuando se est\u00e1n ejecutando los constructores de las instancias. Un caso especial de esta restricci\u00f3n es que en los constructores de las instancias tampoco se puede acceder a otras instancias del enum.</p>"},{"location":"bloque_iii/tema_11/page-4/#clases-enummap","title":"Clases EnumMap","text":"<p>Es una implementaci\u00f3n de mapa muy eficiente donde las claves son elementos de una enumeraci\u00f3n:</p> EnumMainConsola <pre><code>public enum Operation {\nPLUS(\"+\"), MINUS(\"-\"), TIMES(\"*\"), DIVIDE(\"/\");\nprivate final String symbol;\nprivate Operation(String symbol) {\nthis.symbol = symbol;\n}\npublic String getSymbol() {\nreturn symbol;\n}\n}\n</code></pre> <pre><code>public class ShowEnumMap {\npublic void show() {\nEnumMap&lt;Operation, String&gt; operationsMap = new EnumMap&lt;&gt;(Operation.class);\noperationsMap.put(Operation.PLUS, \"Esta operaci\u00f3n se utiliza para sumar\");\noperationsMap.put(Operation.MINUS, \"Esta operaci\u00f3n se utiliza para restar\");\noperationsMap.put(Operation.TIMES, \"Esta operaci\u00f3n se utiliza para multiplicar\");\noperationsMap.put(Operation.DIVIDE, \"Esta operaci\u00f3n se utiliza para dividir\");\nfor (Map.Entry&lt;Operation, String&gt; entry : operationsMap.entrySet()) {\nSystem.out.printf(\"%-6s: %s\\n\", entry.getKey(), entry.getValue());\n}\n}\npublic static void main(String[] args) {\nnew ShowEnumMap().show();\n}\n}\n</code></pre> <pre><code>PLUS : Esta operaci\u00f3n se utiliza para sumar\nMINUS : Esta operaci\u00f3n se utiliza para restar\nTIMES : Esta operaci\u00f3n se utiliza para multiplicar\nDIVIDE: Esta operaci\u00f3n se utiliza para dividir\n</code></pre>"},{"location":"bloque_iii/tema_11/page-5/","title":"5 \u00c1rboles","text":""},{"location":"bloque_iii/tema_11/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Los \u00e1rboles se caracterizan por almacenar sus nodos en forma jer\u00e1rquica y no en forma lineal como las listas</p> <p> Figura 1 - \u00c1rboles</p> <p>Un \u00e1rbol es una estructura en la que los datos se organizan en nodos. Los \u00e1rboles binarios son aquellos en los que un nodo solamente puede tener dos hijos como m\u00e1ximo. Se utilizan para ordenar datos, de tal manera que a la izquierda se colocan los valores menores y a la derecha los valores mayores. Un \u00e1rbol binario se puede recorrer de varias formas, siendo el recorrido inorden el que muestra los datos ordenados: sub\u00e1rbol izquierdo, ra\u00edz, sub\u00e1rbol derecho. Veamos un ejemplo.</p> <p> Figura 2 - Ejemplo \u00e1rbol</p> <p>Nos posicionamos en el 9. Mientras tenga sub\u00e1rbol izquierdo vamos avanzando hasta llegar al 1. Como es una hoja, la mostramos: el 1. Luego mostramos la ra\u00edz: el 3. Despu\u00e9s, continuamos con el sub\u00e1rbol derecho. Nos encontramos con el 6, pero tiene sub\u00e1rbol izquierdo, as\u00ed avanzamos hasta el 4. Como es una hoja, los mostramos: el 4. Luego, continuamos con la ra\u00edz: el 6. Despu\u00e9s, continuamos con el sub\u00e1rbol derecho, avanzando hasta el 7. Como es hoja, lo mostramos: el 7. Ya hemos tratado todo el sub\u00e1rbol izquierdo del 8, que es la ra\u00edz. Ahora mostramos la ra\u00edz: el 8 y a continuaci\u00f3n comenzamos con el sub\u00e1rbol derecho del 8. Y as\u00ed sucesivamente. El resultado final es: 1,3,4,6,7,8,10,13 y 14, es decir, los elementos ordenador de menor a mayor.</p> <p>Si queremos introducir un nuevo nodo en el \u00e1rbol, hay que tener en cuidado de no romper la estructura ni el orden del \u00e1rbol. Hay que tener en cuenta que cada nodo nunca se podr\u00e1 insertar como su hijo. Con esta restricci\u00f3n nos aseguramos de mantener la estructura del \u00e1rbol, pero a\u00fan nos falta mantener el orden. Para localizar el lugar adecuado del \u00e1rbol donde insertar el nuevo nodo se realizan comparaciones entre los nodos del \u00e1rbol y el elemento a insertar. El primer nodo que se compara es el nodo ra\u00edz, si el nuevo nodo es menor que el ra\u00edz, la b\u00fasqueda prosigue por el lado izquierdo de \u00e9ste. Si el nuevo nodo fuese mayor, la b\u00fasqueda seguir\u00eda por el hijo derecho. Y as\u00ed, sucesivamente hasta llegar a un nodo que no tenga hijo en la rama por la que la b\u00fasqueda deber\u00eda seguir. En este caso, el nuevo nodo se inserta en ese hueco, como su nuevo hijo.</p> <p>Por ejemplo, queremos insertar el elemento 9. Lo primero es comparar el nuevo elemento con el nodo ra\u00edz. Como 9 &gt; 8, entonces la b\u00fasqueda prosigue por el lado derecho. Ahora el nuevo nodo se compara con el elemento 10. En este caso 9 &lt; 10, por lo que hay que continuar la b\u00fasqueda por la rama izquierda. Como la rama izquierda de 10 no tiene ning\u00fan nodo, se inserta en ese lugar el nuevo nodo.</p> <p>La interfaz <code>SortedSet&lt;E&gt;</code> es la encargada de definir esta estructura. Esta interfaz es hija de <code>Set&lt;E&gt;</code>, que a su vez es hija de <code>Collection&lt;E&gt;</code>, que a su vez es hija de `Iterable. Por lo tanto, tiene los m\u00e9todos de todas y adem\u00e1s a\u00f1ade sus propios m\u00e9todos. <ul> <li><code>E first()</code>: devuelve el elemento m\u00e1s peque\u00f1o.</li> <li><code>E last()</code>: devuelve el elemento m\u00e1s grande.</li> <li><code>SortedSet&lt;E&gt; headSet(E toElement)</code>: devuelve un SortedSet que contendr\u00e1 todos los elementos menores que toElement.</li> <li><code>SortedSet&lt;E&gt; tailSet(E fromElement)</code>: devuelve un SortedSet que contendr\u00e1 todos los elementos mayores que fromElement.</li> <li><code>SortedSet&lt;E&gt; subSet(E fromElement, E toElement)</code>: devuelve un SortedSet que contendr\u00e1 los elementos que van desde fromElement incluido haste toElement excluido.</li> </ul> <p>Pero, \u00bfc\u00f3mo ordenamos los elementos por ejemplo veh\u00edculos? Para ello, Java nos proporciona dos interfaces: <code>Comparable&lt;T&gt;</code> y <code>Comparator&lt;T&gt;</code>. La diferencia entre ambas es que Comparable se implementa desde la propia clase que se quiere ordenar y Comparator^ no.</p>"},{"location":"bloque_iii/tema_11/page-5/#interfaz-comparable","title":"Interfaz Comparable","text":"<p>La interfaz <code>Comparable</code> contiene un \u00fanico m\u00e9todo, el m\u00e9todo <code>compareTo</code>, que recibe un objeto de la misma clase y que debe realizar una comparaci\u00f3n entre ambos objetos, retornando un valor entero negativo, cero o positivo, dependiendo de si el objeto sobre el que se ejecuta es respectivamente, menor, igual o mayor que el objeto recibido.</p> <p>La definici\u00f3n de la interfaz es la siguiente:</p> <pre><code>public interface Comparable&lt;T&gt;{\nint compareTo(T o);\n}\n</code></pre> <p>Por ejemplo, si quisi\u00e9ramos crear un \u00e1rbol para ordenar los veh\u00edculos lo primero que tendr\u00edamos que hacer es que la clase Vehicle implemente la interfaz Comparable y que el m\u00e9todo compareTo ordene por el atributo que deseemos. Por ejemplo, vamos a ordenar veh\u00edculos alfab\u00e9ticamente por el color. Como el color es de tipo String, debemos utilizar el compareTo de la clase String:</p> VehicleMain <pre><code>public class Vehicle implements Comparable&lt;Vehicle&gt; {\nprivate String registration;\nprivate int wheelCount;\nprivate double speed;\nprivate String colour;\npublic Vehicle(String registration, int wheelCount, String colour) {\nthis.registration = registration;\nthis.wheelCount = wheelCount;\nthis.colour = colour;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic String getColour() {\nreturn colour;\n}\npublic void setColour(String colour) {\nthis.colour = colour;\n}\npublic String getRegistration() {\nreturn registration;\n}\npublic void accelerate(double amount) {\nspeed += amount;\n}\npublic void brake(double amount) {\nspeed -= amount;\n}\n@Override\npublic String toString() {\nreturn \"Vehicle [registration=\" + registration + \", wheelCount=\" +  wheelCount + \", speed=\" + speed + \", colour=\"\n+ colour + \"]\";\n}\n@Override\npublic int compareTo(Vehicle o) {\nreturn colour.compareTo(o.colour);\n}\n}\n</code></pre> <pre><code>public class Compare{\npublic void show(){\nVehicle v1 = new Vehicle(\"9685KMX\", 4, \"azul\");\nVehicle v2 = new Vehicle(\"1235GTR\", 2, \"rojo\");\nVehicle v3 = new Vehicle(\"7314QWE\", 4, \"rojo\");\nSystem.out.println(v1.compareTo(v2)); // positivo -&gt; v1 &gt; v2\nSystem.out.println(v2.compareTo(v1)); // negativo -&gt; v2 &lt; v1\nSystem.out.println(v1.compareTo(v3)); // 0 -&gt; v1 == v3\n}\npublic static void main(String[] args){\nnew Compare().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-5/#interfaz-comparator","title":"Interfaz Comparator","text":"<p>La interfaz <code>Comparator&lt;T&gt;</code> es una interfaz que define el m\u00e9todo <code>compare</code>al que se le pasan los dos objetos a comparar y cuyo resultado es como el del compareTo (0 si son iguales, positivo si el primero es mayor y negativo si el segundo es mayor). Para definir un comparador de este forma, hay que crear una clase que implemente esta interfaz y definir el m\u00e9todo compare, despu\u00e9s crear un objeto de ese tipo y usarlo.</p> VehicleComparatorMain <pre><code>public class VehicleComparator implements Comparator&lt;Vehicle&gt;{\n@Override\npublic int compare(Vehicle o1, Vehicle o2){\nint result = o1.getColour().compareTo(o2.getColour());\n}\n}\n</code></pre> <pre><code>public class Comparator{\npublic void show(){\nVehicle v1 = new Vehicle(\"9685KMX\", 4, \"azul\");\nVehicle v2 = new Vehicle(\"1235GTR\", 2, \"rojo\");\nVehicle v3 = new Vehicle(\"7314QWE\", 4, \"rojo\");\nVehicleComparator comparator = new VehicleComparator();\nSystem.out.println(comparator.compare(v1, v2)); // positivo -&gt; v1 &gt; v2\nSystem.out.println(comparator.compare(v2, v1)); // negativo -&gt; v2 &lt; v1\nSystem.out.println(comparator.compare(v1, v3)); // 0 -&gt; v1 == v3\n}\npublic static void main(String[] args){\nnew Comparator().show();\n}\n}\n</code></pre> <p>Si dicha clase, solo va a ser utilizada una \u00fanica vez, se recomienda usar una clase an\u00f3nima en l\u00ednea:</p> <pre><code>public class ComparatorAnonymous{\npublic void show(){\nVehicle v1 = new Vehicle(\"9685KMX\", 4, \"azul\");\nVehicle v2 = new Vehicle(\"1235GTR\", 2, \"rojo\");\nVehicle v3 = new Vehicle(\"7314QWE\", 4, \"rojo\");\nComparator comparator = new Comparator&lt;Vehicle&gt;(){\n@Override\npublic int compare(Vehicle o1, Vehicle o2){\nreturn o1.getColour().compareTo(o2.getColour());\n}\n};\nSystem.out.println(comparator.compare(v1, v2)); // positivo -&gt; v1 &gt; v2\nSystem.out.println(comparator.compare(v2, v1)); // negativo -&gt; v2 &lt; v1\nSystem.out.println(comparator.compare(v1, v3)); // 0 -&gt; v1 == v3\n}\npublic static void main(String[] args){\nnew ComparatorAnonymous().show();\n}\n}\n</code></pre> <p>Para ordenar descendientemente se cambiar\u00eda el orden de <code>o1</code> por el de <code>o2</code>.</p>"},{"location":"bloque_iii/tema_11/page-5/#usos-de-comparable-y-comparator","title":"Usos de comparable y comparator","text":"<p>Cuando creemos clases que representen valores que posean un determinado orden natural, como por ejemplo un orden alfab\u00e9tico, num\u00e9rico o cronol\u00f3gico, deberemos hacer que dicha clase implemente la interfaz  Comparable, permitiendo as\u00ed que los objetos de dicha clase puedan trabajar con mucho algoritmos gen\u00e9ricos e implementaciones de colecciones que dependen de dicha interfaz.</p> <p>La mayor\u00eda de las clases est\u00e1ndar que representan valores y de las clases enums incorporadas a Java,  implementan  la  interfaz  Comparable,  como  por  ejemplo  la  clase  String.  Las  clases  que definamos nosotros que representen valores tambi\u00e9n deber\u00edan implementarla.</p> <p>A la hora de realizar la implementaci\u00f3n debemos respetar una serie de reglas:</p> <ul> <li><code>x.compareTo(y) == -y.compareTo(x)</code>  para todo valor de  x  e  y .</li> <li>La relaci\u00f3n es transitiva, es decir, que si  <code>(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt;0)</code> entonces  <code>x.compareTo(z) &gt; 0</code>.</li> <li>Si  <code>x.compareTo(y) == 0</code>  entonces  <code>x.compareTo(z) == y.compareTo(z)</code> para cualquier valor de  z.</li> <li>Aunque  no  es  obligatorio  se  recomienda  que  <code>(x.compareTo(y) == 0)</code> == <code>(x.equals(y))</code>.</li> </ul> <p>Si para comparar los objetos debemos comparar un atributo de un tipo primitivo, se recomienda usar los m\u00e9todos est\u00e1ticos de comparaci\u00f3n  compare   de  las  clases  boxed  correspondientes, como <code>Long.compare()</code>,  <code>Float.compare()</code>, etc., disponibles a partir de Java 7, en vez de usar los operadores <code>&lt;</code>  o <code>&gt;</code>, ya que son menos verbosos y propensos al error:</p>"},{"location":"bloque_iii/tema_11/page-5/#clase-treeset","title":"Clase TreeSet","text":"<p>La clase <code>TreeSet&lt;E&gt;</code> es la que se utiliza prioritariamente para trabajar con \u00e1rboles ordenados ya que implementa la interfaz <code>SortedSet&lt;E&gt;</code>.</p> <p>Los objetos a incluir en un TreeSet deben implementar Comparable o bien crear el \u00e1rbol con un constructor que reciba un Comparator</p> <p>Ejemplo:</p> VehicleMainConsola <pre><code>public class Vehicle implements Comparable&lt;Vehicle&gt; {\nprivate String registration;\nprivate int wheelCount;\nprivate double speed;\nprivate String colour;\npublic Vehicle(String registration, int wheelCount, String colour) {\nthis.registration = registration;\nthis.wheelCount = wheelCount;\nthis.colour = colour;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic String getColour() {\nreturn colour;\n}\npublic void setColour(String colour) {\nthis.colour = colour;\n}\npublic String getRegistration() {\nreturn registration;\n}\npublic void accelerate(double amount) {\nspeed += amount;\n}\npublic void brake(double amount) {\nspeed -= amount;\n}\n@Override\npublic String toString() {\nreturn \"Vehicle [registration=\" + registration + \", wheelCount=\" +  wheelCount + \", speed=\" + speed + \", colour=\"\n+ colour + \"]\";\n}\n@Override\npublic int compareTo(Vehicle o) {\nreturn colour.compareTo(o.colour);\n}\n}\n</code></pre> <pre><code>public class TreeSet1{\npublic void show(){\nSortedSet&lt;Vehicle&gt; = new TreeSet&lt;&gt;();\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"negro\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"naranja\"));\nfor(Vehicle v: tree){\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args){\nnew TreeSet1().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Pero, \u00bfqu\u00e9 ocurrir\u00eda si tuvi\u00e9ramos colores repetidos?:</p> MainConsola <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\npublic class TreeSet2 {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;();\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew TreeSet2().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Los tres primero veh\u00edculos se introducen en el \u00e1rbol. Cuando se va a introducir el cuarto que es de color azul, el \u00e1rbol lo va comparando con compareTo con los veh\u00edculos que ya existen el \u00e1rbol para encontrar la posici\u00f3n ordenada donde incluirlo. Pero cuando lo compara con el que es azul, el compareTo, devuelve 0, por lo que el \u00e1rbol interpreta que ese objeto ya existe en el \u00e1rbol, que es igual a otro, por lo tanto no lo incluye en el \u00e1rbol. Lo mismo ocurre con el quinto y el sexto. Por lo tanto, lo que ocurrir\u00eda es que los 3 \u00faltimos no se introducen en el \u00e1rbol porque compareTo devuelve 0 entre veh\u00edculos del mismo color, por lo que el \u00e1rbol considera que son iguales. En estos casos, lo que se hace es que se incluye un segundo criterio de comparaci\u00f3n: vamos a ordenar por el color, y en aquellos casos donde los veh\u00edculos tengan el mismo color entonces vamos a ordenar por matr\u00edcula.</p> VehicleMainConsola <pre><code>public class Vehicle implements Comparable&lt;Vehicle&gt;{\n//...\n@Override\npublic int compareTo(Vehicle o){\nint result = colour.compareTo(o.colour);\nif(result == 0){\nresult = registration.compareTo(o,registration);\n}\nreturn result;\n}\n}\n</code></pre> <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\npublic class ShowTreeSet {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;();\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew ShowTreeSet().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Pero, \u00bfqu\u00e9 ocurrir\u00eda si la clase Vehicle no implementase la interfaz Comparable? Pues que no contendr\u00eda el m\u00e9todo compareTo, entonces el \u00e1rbol no tendr\u00eda la informaci\u00f3n de c\u00f3mo ordenar los veh\u00edculos. En este caso, se lanzar\u00eda una excepci\u00f3n <code>ClassCastException</code>.</p> VehicleMainConsola <pre><code>public class Vehicle{\n//...\n// No contiene el m\u00e9todo compareTo\n}\n</code></pre> <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\npublic class ShowException{\npublic void show(){\nSortedSet&lt;Vehicle&gt; = new TreeSet&lt;&gt;();\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"negro\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"naranja\"));\nfor(Vehicle v: tree){\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args){\nnew ShowException().show();\n}\n}\n</code></pre> <pre><code>Exception in thread \"main\" java.lang.ClassCastException: class \ntema11_Colecciones.arboles3.Vehicle cannot be cast to class\njava.lang.Comparable (tema11_Colecciones.arboles3.Vehicle is in unnamed module\nof loader 'app'; java.lang.Comparable is in module java.base of loader\n'bootstrap')\nat java.base/java.util.TreeMap.compare(TreeMap.java:1291)\nat java.base/java.util.TreeMap.put(TreeMap.java:536)\nat java.base/java.util.TreeSet.add(TreeSet.java:255)\nat tema11_Colecciones.arboles3.ShowException.show(ShowException.java:11)\nat tema11_Colecciones.arboles3.ShowException.main(ShowException.java:25)\n</code></pre> <p>Otra posibilidad es utilizar un objeto <code>Comparator&lt;E&gt;</code>. Para ello, se crea la clase que implementa dicha interfaz y se usar\u00eda en la construcci\u00f3n del \u00e1rbol mediante un constructor que recibe un Comparator: <code>TreeSet(Comparator&lt;? super E&gt; comparator)</code>. En este caso, \u00e9sa ser\u00e1 la forma prioritaria para ordenar la lista, por encima del m\u00e9todo compareTo de la interfaz Comparable. Como ya dijimos anteriormente, la diferencia entre Comparable y Comparator es que Comparable se implementa desde la propia clase que se quiere ordenar y Comparator no, ya que Comparator se implementa desde otra clase distinta a la que se quiere ordenar:</p> VehicleComparatorMainConsola <pre><code>import java.util.comparator;\npublic class VehicleComparator implements Comparator&lt;Vehicle&gt;{\n@Override\npublic int compare(Vehicle o1, Vehicle o2){\nint result = o1.getColour().compareTo(o2.getColour());\nif(result == 0){\nresult = o1.getRegistration().compareTo(o2.getRegistration());\n}\nreturn result;\n}\n}\n</code></pre> <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\npublic class ShowComparator {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new VehicleComparator());\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew ShowComparator().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Pero si esta comparaci\u00f3n la vamos a utilizar solamente una vez, tenemos que crear una clase solamente para su uso. Y si necesitamos ordenar los veh\u00edculos de varias maneras, tenemos que tener una clase por cada criterio de ordenaci\u00f3n. En estos casos, podemos utilizar una clase inline an\u00f3nima:</p> MainConsola <pre><code>import java.util.Comparator;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\npublic class AnonymousComparator {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new Comparator&lt;Vehicle&gt;(){\n@Override\npublic int compare(Vehicle o1, Vehicle o2){\nint result = o1.getColour().compareTo(o2.getColour());\nif(result == 0){\nresult = o1.getRegistration().compareTo(o2.getRegistration());\n}\nreturn result;\n}\n});\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew AnonymousComparator().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Si quisi\u00e9ramos ordenar de manera descendente, cambiamos el orden entre o1 y o2, es decir, hacemos que sea o2 el que ejecute el compareTo</p> MainConsola <pre><code>import java.util.Comparator;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\npublic class DescendingOrder {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new Comparator&lt;Vehicle&gt;(){\n/*\n             * Si quisi\u00e9ramos ordenar de manera descendente,\n             * cambiamos el orden entre o1 y o2, es decir,\n             * hacemos que sea o2 el que ejecute el compareTo\n             */\n@Override\npublic int compare(Vehicle o1, Vehicle o2){\nint result = o2.getColour().compareTo(o1.getColour());\nif(result == 0){\nresult = o2.getRegistration().compareTo(o1.getRegistration());\n}\nreturn result;\n}\n});\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew DescendingOrder().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Los comparadores de tipo Comparator permiten ordenar de diferentes formas, por eso en la pr\u00e1ctica se utilizan mucho. Por ejemplo, el m\u00e9todo sort de la clase Arrays tambi\u00e9n admite indicar un comparador para saber de qu\u00e9 forma deseamos ordenar el array.</p> CompareBoxedClassesConsola <pre><code>import java.util.Comparator;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\npublic class CompareBoxedClasses {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new Comparator&lt;Vehicle&gt;() {\n@Override\npublic int compare(Vehicle o1, Vehicle o2) {\nint result = Integer.compare(o1.getWheelCount(), o2.getWheelCount());\nif (result == 0) {\nresult = Double.compare(o1.getSpeed(), o2.getSpeed());\n}\nreturn result;\n}\n});\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[0].accelerate(100);\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[1].accelerate(150);\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[2].accelerate(200);\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[3].accelerate(80);\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[4].accelerate(75);\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nvehicles[5].accelerate(170);\nfor (int i = 0; i &lt; vehicles.length; i++) {\ntree.add(vehicles[i]);\n}\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew CompareBoxedClasses().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=80.0, colour=negro]\nVehicle [registration=1235GTR, wheelCount=2, speed=150.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=170.0, colour=naranja]\nVehicle [registration=1705UBG, wheelCount=4, speed=75.0, colour=blanco]\nVehicle [registration=9685KMX, wheelCount=4, speed=100.0, colour=azul]\nVehicle [registration=7314QWE, wheelCount=4, speed=200.0, colour=verde]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-5/#clase-treemap","title":"Clase TreeMap","text":"<p>Esta implementaci\u00f3n utiliza una estructura de \u00e1rbol que permite que los elementos del mapa se ordenen en sentido ascendente seg\u00fan la clave, por lo tanto, la clase de las claves tiene que implementar la interfaz Comparable o bien indicar un objeto Comparator durante la creaci\u00f3n del TreeMap.</p> <p>TreeMap implementa la interfaz  <code>SortedMap</code>  que, a su vez, es heredera de  <code>Map</code> , por lo que todo lo dicho sobre los mapas funciona con las colecciones de tipo TreeMap.</p> MainConsola <pre><code>import java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\npublic class ShowTreeMap {\npublic void show() {\nSortedMap&lt;String, Vehicle&gt; sortedMap = new TreeMap&lt;&gt;();\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nfor (int i = 0; i &lt; vehicles.length; i++) {\nsortedMap.put(vehicles[i].getRegistration(), vehicles[i]);\n}\nfor (Map.Entry&lt;String, Vehicle&gt; entry : sortedMap.entrySet()) {\nSystem.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\", entry.getKey(), entry.getValue());\n}\n}\npublic static void main(String[] args) {\nnew ShowTreeMap().show();\n}\n</code></pre> <pre><code>Matr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4,\nspeed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2,\nspeed=0.0, colour=naranja]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2,\nspeed=0.0, colour=negro]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4,\nspeed=0.0, colour=verde]\nMatr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4,\nspeed=0.0, colour=azul]\n</code></pre> <p>Como podemos observar, est\u00e1 ordenado ascendentemente por la matr\u00edcula ya que la matr\u00edcula es de tipo <code>String</code> que implementa la interfaz  <code>Comparable</code>. Si la clave fuera una clase hecha por nosotros, tendr\u00edamos que hacer que implementara Comparable o bien indicar un Comparator en la creaci\u00f3n del TreeMap.</p>"},{"location":"bloque_iii/tema_11/page-6/","title":"6 Pilas y colas","text":""},{"location":"bloque_iii/tema_11/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Una cola es un tipo de dato que sigue el principio FIFO (first in, first out) que implica que el primer elemento en ser insertado en la cola es tambi\u00e9n el primero en ser eliminado de la misma.</p> <p>En el mundo real podemos encontrar este ejemplo en las colas de un banco, la cadena de impresi\u00f3n de documentos, etc. En el caso de la cola en el banco, la primera persona en llegar es tambi\u00e9n la primera en irse (suponiendo una \u00fanica ventanilla) y en los documentos a imprimir, la impresora imprime seg\u00fan el orden de llegada.</p> <p><code>Queue&lt;E&gt;</code> es una interfaz que hereda de Collection que proporciona operaciones para trabajar con una cola. Veamos alguna de ellas:</p> <ul> <li><code>boolean add(E e)</code>: inserta el elemento al final de la cola.</li> <li><code>E  element()</code>: Devuelve, pero no elimina,  el principio de la cola. Lanza la excepci\u00f3n <code>NoSuchElementException</code> si la cola est\u00e1 vac\u00eda.</li> <li><code>E peek()</code>:Devuelve, pero no elimina, el principio de la cola. Devuelve null si la cola est\u00e1 vac\u00eda.</li> <li><code>E poll()</code>: Devuelve y elimina el principio de la cola. Devuelve null si la cola est\u00e1 vac\u00eda.</li> <li><code>E  remove()</code>: Devuelve y elimina el principio de la cola. Lanza la excepci\u00f3n <code>NoSuchElementException</code> si la cola est\u00e1 vac\u00eda.</li> </ul> <p><code>Deque&lt;E&gt;</code> representa  una  cola  de  doble  extremo,  lo  que  significa  que  se  puede  insertar  y eliminar elementos desde ambos extremos de la cola. El nombre Deque es una abreviatura de Double Ended Queue. Admite,  por  lo  tanto, la  implementaci\u00f3n  de  la  cola  FIFO  como  la implementaci\u00f3n de la pila LIFO, que implica que el \u00faltimo elemento que se ha insertado, es el primero en ser eliminado: LIFO (last in, first out).</p> <p>Deque hereda de Queue, por lo que tiene todos sus m\u00e9todos y adem\u00e1s a\u00f1ade los suyos propios.Veamos algunos de ellos:</p> <ul> <li><code>void addFirst(E e)</code>: inserta el elemento al principio.</li> <li><code>void addLast(E e)</code>: inserta el elemento al final.</li> <li><code>E  getFirst()</code>: Devuelve, pero no  elimina,  el  primer  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code>  si el Deque est\u00e1 vac\u00edo.</li> <li><code>E  getLast()</code>: Devuelve, pero no elimina,  el  \u00faltimo  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code> si el Deque est\u00e1 vac\u00edo.</li> <li><code>E peekFirst()</code>: Devuelve, pero no elimina, el primer elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E peekLast()</code>: Devuelve, pero no elimina, el \u00faltimo elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E pollFirst()</code>: Devuelve y elimina el primer elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E pollLast()</code>: Devuelve y elimina el \u00faltimo elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E  removeFirst()</code>: Devuelve  y  elimina  el  primer  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code> si el Deque est\u00e1 vac\u00edo.</li> <li><code>E  removeLast()</code>: Devuelve y elimina el \u00faltimo  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code> si el Deque est\u00e1 vac\u00edo.</li> </ul>"},{"location":"bloque_iii/tema_11/page-6/#clase-arraydeque","title":"Clase ArrayDeque","text":"<p>La clase <code>ArrayDeque&lt;E&gt;</code> implementa la interfaz Deque y por lo tanto, tambi\u00e9n Queue, ya que Deque hereda de Queue.</p> ColaConsola ColaPilaConsola Pila <p><pre><code>import java.util.ArrayDeque;\nimport java.util.Queue;\npublic class ShowQueue{\npublic void show(){\nQueue&lt;Vehicle&gt; queue = new ArrayDeque();\nqueue.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\nqueue.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\nqueue.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\nSystem.out.println(queue.element()); //(1)!\nSystem.out.println(queue.peek());//(2)!\nSystem.out.println(queue.poll());//(3)!\nSystem.out.println(queue.remove());//(4)!\nSystem.out.println(queue.remove());//(5)!\nSystem.out.println(queue.peek());//(6)!\nSystem.out.println(queue.poll());//(7)!\nSystem.out.println(queue.element());//(8)!\nSystem.out.println(queue.remove());//(9)!\n}\npublic static void main(String[] args){\nnew ShowQueue().show();\n}\n}\n</code></pre> 1. Devuelve pero no elimina 9685KMX 1. Devuelve pero no elimina: 9685KMX 1. Devuelve y elimina: 9685KMX 1. Devuelve y elimina: 1235GTR 1. Devuelve y elimina el \u00faltimo, se queda la cola vac\u00eda: 7314QWE 1. Devuelve null 1. Devuelve null 1. Lanza NoSuchElementException porque la cola est\u00e1 vac\u00eda 1. Lanza NoSuchElementException porque la cola est\u00e1 vac\u00eda</p> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nnull\nnull\nException in thread \"main\" java.util.NoSuchElementException\nat java.base/java.util.ArrayDeque.getFirst(ArrayDeque.java:402)\nat java.base/java.util.ArrayDeque.element(ArrayDeque.java:551)\nat tema11_Colecciones.pilasYColas.ShowQueue.show(ShowQueue.java:21)\nat tema11_Colecciones.pilasYColas.ShowQueue.main(ShowQueue.java:28)\n</code></pre> <pre><code>import java.util.ArrayDeque;\nimport java.util.Deque;\npublic class ShowDeque{\npublic void show(){\nQueue&lt;Vehicle&gt; deque = new ArrayDeque();\ndeque.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ndeque.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ndeque.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\nSystem.out.println(deque.element()); //(1)!\nSystem.out.println(deque.peek());//(2)!\nSystem.out.println(deque.poll());//(3)!\nSystem.out.println(deque.remove());//(4)!\nSystem.out.println(deque.remove());//(5)!\nSystem.out.println(deque.peek());//(6)!\nSystem.out.println(deque.poll());//(7)!\nSystem.out.println(deque.element());//(8)!\nSystem.out.println(deque.remove());//(9)!\n}\npublic static void main(String[] args){\nnew ShowDeque().show();\n}\n}\n</code></pre> <ol> <li>Devuelve pero no elimina 7314QWE</li> <li>Devuelve pero no elimina: 7314QWE</li> <li>Devuelve y elimina: 7314QWE</li> <li>Devuelve y elimina: 1235GTR</li> <li>Devuelve y elimina el \u00faltimo, se queda la pila vac\u00eda: 9685KMX</li> <li>Devuelve null</li> <li>Devuelve null</li> <li>Lanza NoSuchElementException porque la pila est\u00e1 vac\u00eda</li> <li>Lanza NoSuchElementException porque la pila est\u00e1 vac\u00eda</li> </ol> <pre><code>Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nnull\nnull\nException in thread \"main\" java.util.NoSuchElementException\nat java.base/java.util.ArrayDeque.getLast(ArrayDeque.java:413)\nat tema11_Colecciones.pilasYColas.ShowDeque.show(ShowDeque.java:21)\nat tema11_Colecciones.pilasYColas.ShowDeque.main(ShowDeque.java:28)\n</code></pre>"},{"location":"bloque_iii/tema_11/page-6/#clase-collections","title":"Clase Collections","text":"<p>La clase  Collections  contiene numerosos m\u00e9todos est\u00e1ticos para utilizar con todo tipo de colecciones,  como  por  ejemplo,  para  a\u00f1adir,  buscar,  copiar,  reemplazar,  ordenar,  obtener  el m\u00e1ximo o el m\u00ednimo, etc.</p>"},{"location":"bloque_iii/tema_11/page-7/","title":"Ejercicios","text":""},{"location":"bloque_iii/tema_11/page-7/#ejercicio-1","title":"Ejercicio 1","text":"<p>Utilizando la clase gen\u00e9rica caja del bolet\u00edn de gen\u00e9ricos, haz un programa que haga lo siguiente:</p> <ul> <li>Guardar en una lista 5 cajas de cadenas. Recorrer la lista y mostrar por pantalla el contenido de todas las cajas. Mostrar una concatenaci\u00f3n de todas las cadenas.</li> <li>Guardar en otra lista 5 cajas de long. Recorrer la lista y mostrar por pantalla el contenido de las cajas. Mostrar un resultado de sumarlas todas.</li> </ul>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-2","title":"Ejercicio 2","text":"<p>Realiza una interfaz gen\u00e9rica que contenga dos m\u00e9todo:     T primerContenido();     T ultimoContenido();</p> <p>Realizar una clase Almacen que contenga una lista de cajas. Dicha clase debe implementar esa interfaz. Los m\u00e9todos devolver\u00e1n el contenido de la primera caja y el contenido de la \u00faltima caja respectivamente.</p>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-3","title":"Ejercicio 3","text":"<p>Realiza el siguiente men\u00fa para gestionar una lista simplemente enlazada de cadenas:</p> <ol> <li>Nueva lista</li> <li>N\u00famero de cadenas</li> <li>A\u00f1adir cadena</li> <li>Eliminar cadena</li> <li>Contiene cadena</li> <li>Mostrar lista entera</li> <li>Salir</li> </ol> <p>En la opci\u00f3n 1, se limpiar\u00e1 toda la lista dejando la lista vac\u00eda. En la opci\u00f3n 5, se le pedir\u00e1 una cadena al usuario y se le dir\u00e1 si est\u00e1 o no en la lista.</p>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-4","title":"Ejercicio 4","text":"<p>Rellena una lista simplemente enlazada circular de n\u00fameros decimales de tipo float. A continuaci\u00f3n, presentar el siguiente men\u00fa.</p> <ol> <li>Mostrar la lista</li> <li>Mostrar siguiente</li> <li>Eliminar \u00faltimo mostrado</li> <li>Salir</li> </ol> <p>En la opci\u00f3n 2, la primera vez que se ejecute saldr\u00e1 el primero de la lista. La Siguiente vez el segundo, y as\u00ed sucesivamente. Si el \u00faltimo mostrado ha sido el \u00faltimo y se le vuelve a dar esta opci\u00f3n, entonces se mostrar\u00e1 el primero. En la opci\u00f3n 3, se elimina el \u00faltimo mostrado por la opci\u00f3n 2.</p>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-5","title":"Ejercicio 5","text":"<p>Realiza el mismo ejercicio anterior pero con una lista doblemente enlazada circular. A\u00f1\u00e1dele una opci\u00f3n nueva al men\u00fa que sea 'Mostrar anterior'.</p>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-6","title":"Ejercicio 6","text":"<p>Realiza el siguiente men\u00fa para gestionar una pila de n\u00fameros de tipo byte.</p> <ol> <li>Nueva pila</li> <li>Consultar elemento</li> <li>A\u00f1adir elemento</li> <li>Eliminar elemento</li> <li>Consultar toda la pila</li> <li>Salir</li> </ol>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-7","title":"Ejercicio 7","text":"<p>Realiza el ejercicio anterior pero con una cola.</p>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-8","title":"Ejercicio 8","text":"<p>Un videoclub quiere que le hagamos una aplicaci\u00f3n para registrar sus pel\u00edculas. Los requisitos que nos exigen son los siguientes:</p> <ul> <li>Enum Genero<ul> <li>3 valores: COMEDIA, FICCION, TERROR<ul> <li>M\u00e9todo getCodigo que devuelva el siguiente car\u00e1cter para cada valor:<ul> <li>COMEDIA: C</li> <li>FICCION: F</li> <li>TERROR: T</li> </ul> </li> </ul> </li> </ul> </li> <li>Clase Clave:<ul> <li>Atributos: enum Genero y un n\u00famero entero</li> <li>Atributos privados y solamente los getters necesarios</li> <li>M\u00e9todo toString: devuelve una cadena concatenando del enum con el n\u00famero entero. Ej: C1, F2, T3</li> <li>M\u00e9todo est\u00e1tico asignarClave: recibe un g\u00e9nero y devuelve un objeto de tipo Clave. El n\u00famero de la clave ser\u00e1 1 para la primera pel\u00edcula de comedia, 1 para la primera pel\u00edcula de terror, ..., 2 para las segundas, etc.</li> </ul> </li> <li>Clase Pel\u00edcula<ul> <li>Atributos:<ul> <li>Clave: objeto de la clase Clave</li> <li>Nombre</li> <li>FechaEstreno. fecha de estreno en Espa\u00f1a</li> <li>FechaDVD: fecha de venta en DVD</li> </ul> </li> <li>Atributos privados y solamente los getters necesarios</li> <li>Constructor: <code>Pelicula(String nombre, Genero genero, LocalDate fechaEstreno, LocalDate fechaDVD)</code></li> <li>Criterio de comparaci\u00f3n de la clase: descendientemente por d\u00edas que ha tardado la pel\u00edcula en salir en DVD desde que se estren\u00f3. Si dos pel\u00edculas tienen el mismo n\u00famero de d\u00edas, ordenarlas ascendentemente por orden alfab\u00e9tico del nombre.</li> </ul> </li> <li> <p>Clase Videoclub: esta clase contendr\u00e1 la l\u00f3gica con varias colecciones para hacer lo siguiente:</p> <ul> <li>Se crear\u00e1n pel\u00edculas de la siguiente tabla:</li> </ul> Orden de la inserci\u00f3n en la colecciones Nombre G\u00e9nero Clave Fecha Estreno Fecha DVD 1 Poltergeist, juegos diab\u00f3licos Terror T1 22/05/2015 22/09/2015 2 La cumbre escarlata Terror T2 09/10/2015 12/02/2016 3 Ocho apellidos catalanes Comedia C1 20/112015 18/03/2016 4 Padres por desigual Comedia C2 01/01/2016 20/04/2016 5 Star Wars: El despertar de la Fuerza Ficci\u00f3n F1 18/12/2015 20/04/2016 6 Mad Max: Furia en la carretera Ficci\u00f3n F2 15/05/2015 01/09/2015 7 Clon de Poltergeist, juegos diab\u00f3licos 8 Clon de Star Wars: El despertar de la fuerza <ul> <li>Utilizar las colecciones oportunas para crear la siguiente salida por consola exactamente igual. Insertar las pel\u00edculas en las colecciones en el orden indicado en la primera columna de la tabla. Tener en cuenta lo siguiente:<ul> <li>En el 3, utiliza un Comparator de manera an\u00f3nima</li> <li>En el 4, el criterio de comparaci\u00f3n de la clave es primera las de ficci\u00f3n, luego las de terror y por \u00faltimo las de comedia. A igualdad de g\u00e9nero, se ordena ascendentemente por el n\u00famero de la clave. Es decir, el orden ser\u00eda: F1, F2, T1, T2, C1, C2.</li> <li>En el 5, utilizar ListIterator.</li> </ul> </li> </ul> </li> </ul> <p>Salidas por consola:</p> <p></p>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-9","title":"Ejercicio 9","text":"<p>Realiza una aplicaci\u00f3n para gestionar los ex\u00e1menes de junio de 1\u00baCFGS de Aplicaciones Multiplataforma. Se crear\u00e1n los ex\u00e1menes que aparecen en la siguiente tabla y se insertar\u00e1n en todas las colecciones en el orden indicado en la primera columna de la tabla. La clave estar\u00e1 formada por el d\u00eda del examen, un guion y la hora de inicio y ser\u00e1 autogenerada por la clase. La fecha tiene que ser mostrada con el formato d\u00eda/mes/a\u00f1o, yal y como est\u00e1 en la table.</p> Orden de inserci\u00f3n en las colecciones Asignatura Descripci\u00f3n Fecha Hora de Inicio Hora de Fin Clave 1 Programaci\u00f3n Herencia y colecciones 16/06/2017 08:15 13:30 16-08:15 2 Base de datos Disparadores y SQL 15/06/2017 11:45 14:30 15-11:45 3 Sistemas Inform\u00e1ticos Sistemas en red 20/06/2017 10:15 11:35 20-10:15 4 Entornos de Desarrollo Diagramas de clases 19/06/2017 09:15 11:15 19-09:15 5 Lenguaje de Marcas Hojas de estilo 14/06/2017 08:15 11:15 13-10:15 6 FOL Derechos del trabajador 13/06/2017 10:15 11:15 13-10:15 7 Base de datos Entidad-Relaci\u00f3n 15/06/2017 08:15 11:30 15-08:15 8 Clon de Programaci\u00f3n 9 Clon de Lenguaje de Marcas <p>Realizar con dichos ex\u00e1menes lo siguiente, teniendo en cuenta que las salidas en consola est\u00e9n bien alineadas y que las horas tienen que salir con dos d\u00edgitos. Ejemplo 08:15</p> <ol> <li>Insertarlos en un ArrayList. Muestra el contenido del ArrayList.</li> <li>Inserta los ex\u00e1menes en una colecci\u00f3n sin duplicados que mantenga el orden de inserci\u00f3n. Muestra la colecci\u00f3n sin duplicados.</li> <li>Muestra el contenido de la colecci\u00f3n sin duplicados del apartado 2 al rev\u00e9s.</li> <li>Utilizando la interfaz List, solic\u00edtale al usuario los valores necesarios para mostrar una sublista de la colecci\u00f3n sin duplicados del apartado 2. Ejemplo: si el usuario introduce 3 y 5, se muestran los ex\u00e1menes de Sistemas Inform\u00e1ticos, Entornos de Desarrollo y Lenguaje de Marcas.</li> <li>Inserta los ex\u00e1menes en un \u00e1rbol. Utilizando la interfaz Comparable, ordena los ex\u00e1menes en el \u00e1rbol ascendente de asignatura, fecha y hora de inicio en este orden. Es decir, si la asignatura es la mista, entonces ordena por fecha, y si la fecha tambi\u00e9n es la misma, entonces ordena por hora. El primer examen ser\u00e1 el de Base de Datos que empieza a las 08:15 y el \u00faltimo ser\u00e1 el de Sistemas Inform\u00e1ticos.</li> <li>Inserta los ex\u00e1menes en otro \u00e1rbol pero esta vez utilizando la interfaz Comparator de manera an\u00f3nima. En dicha \u00e1rbol, el orden ser\u00e1 por orden descendente de fecha y hora de inicio en ese orden. El primer examen ser\u00e1 el de Sistemas Inform\u00e1ticos y el \u00faltimo ser\u00e1 el de FOL.</li> <li>Inserta los ex\u00e1menes en un mapa ordenado utilizando como clave del mapa el campo clave de los ex\u00e1menes. Mostrar el contenido del mapa ordenado.</li> </ol>"},{"location":"bloque_iii/tema_11/page-7/#ejercicio-10","title":"Ejercicio 10","text":"<p>Una empresa nos ha contratado para hacer una aplicaci\u00f3n en Java para registrar a sus empleados. Pertenecemos a un equipo de trabajo de programadores dirigidos por un analista. El analista quiere que cumplamos una serie de requisitos ya que luego habr\u00e1 que unir todo el c\u00f3digo hecho por los programadores. Los requisitos son los siguientes:</p> <ul> <li>Enum Categoria<ul> <li>3 valoreS: JEFE, ENCARGADO y EMPLEADO</li> <li>M\u00e9todo getCodigo que devuelva el siguiente car\u00e1cter para cada valor:<ul> <li>JEFE: J</li> <li>ENCARGADO: E</li> <li>EMPLEADO: D</li> </ul> </li> </ul> </li> <li>Clase Clave<ul> <li>Atributos: enum Categoria y un n\u00famero entero.</li> <li>Atributos privados y solamente los getters necesarios.</li> <li>M\u00e9todo toString: devuelve una cadena concatenando el c\u00f3digo del enum con el n\u00famero entero. Ej: J1</li> <li>M\u00e9todo est\u00e1tico asignarClave: recibe una categor\u00eda y devuelve un objeto de tipo Clave. El n\u00famero de la clave ser\u00e1 1 para el primer jefe, primer encargado y primer empleado, 2 para los segundos, etc.</li> </ul> </li> <li>Clase Empleado<ul> <li>Atributos:<ul> <li>Clave: objeto de la clase Clave</li> <li>Nombre</li> <li>FechaAlta: fecha de alta en la empresa</li> <li>FechaBaja: fecha de baja en la empresa. Si contin\u00faan trabajando en la empresa, este atributo se rellena con null  </li> </ul> </li> <li>Atributos privados y solamente los getters necesarios.</li> <li>Constructor: Empleado(String nombre, Categoria categoria, LocalDate fechaAlta, LocalDate fechaBaja)</li> <li>Criterio de comparaci\u00f3n de la clase: descendentemente por d\u00edas trabajados.</li> </ul> </li> <li> <p>Clase Arboles: esta clase contendr\u00e1 el main con 3 \u00e1rboles de empleados:</p> <ul> <li> <p>En los 3 \u00e1rboles se a\u00f1adir\u00e1n los siguientes empleados y en este mismo orden:</p> Orden de inserci\u00f3n en los \u00e1rboles Nombre Categor\u00eda Fecha Alta Fecha Baja 1 Pepe Empleado 21/03/2011 22/04/2013 2 Juan Encargado 29/02/2012 No tiene 3 Mar\u00eda Jefe 30/04/2010 No tiene 4 Laura Empleado 30/12/2010 No tiene 5 Esteban Encargado 05/11/2010 11/02/2015 6 Pedro Jefe 16/08/2009 No tiene 7 Yolanda Empleado 27/07/2012 01/10/2013 8 Nuria Jefe 31/08/2009 No tiene 9 Antonio Encargado 28/01/2011 14/05/2014 10 Clone de Pepe 11 Clone de Esteban 12 Clone de Pedro </li> <li> <p>Los tres \u00e1rboles son los siguientes:</p> <ul> <li>\u00c1rbol con los empleados ordenados descendentemente por d\u00edas trabajados.</li> <li>\u00c1rbol con los empleados ordenados ascendentemente por orden alfab\u00e9tico de los nombres de los empleados. Utiliza l interfaz Comparator de manera an\u00f3nima.</li> <li>TreeMap con los empleados ordenador descendentemente por categor\u00eda profesional y a misma categor\u00eda, se ordena ascendentemente por n\u00famero. Utilizar como clave del TreeMap el atributo clave del empleado. </li> </ul> </li> <li>De todos los \u00e1rboles hay que mostrar los datos. La salida por consola debe ser exactamente igual a la siguiente:</li> </ul> <p> </p> </li> </ul>"},{"location":"proyects/cinema/proyecto_v1/","title":"Proyecto V1","text":"<p>Se quiere realizar una aplicaci\u00f3n para realizar la compra de entradas de cine. En este primera parte, se llevar\u00e1 a cabo el inicio de sesi\u00f3n.</p> <p>Se debe tener en cuenta que existen 4 tipos de usuarios diferentes, cliente, administrador, encargado y empleado. De todos los usuarios se desea almacenar las credenciales, que constar\u00e1 de correo, contrase\u00f1a y estado. Pero adem\u00e1s de los clientes se desea almacenar la direcci\u00f3n (compuesta de Nombre de la v\u00eda, n\u00famero, municipio, localidad y c\u00f3digo postal), su nombre completo y una breve biograf\u00eda de 160 caracteres. De los empleados se desea almacenar el a\u00f1o en el que empezaron ser empleados y de los encargados el a\u00f1o en el que se hicieron encargados. De los administradores no se desea conocer nada diferente. </p> <p>Al ejecutar la aplicaci\u00f3n le pedir\u00e1 las credenciales necesarias a un usuario para poder acceder a la aplicaci\u00f3n. Si las credenciales son err\u00f3neas, se las volver\u00e1 a solicitar hasta 3 veces, luego mostrar\u00e1 un mensaje de error y terminar\u00e1 la aplicaci\u00f3n. En caso de las credenciales sean correctas, mostrar\u00e1 un mensaje de bienvenida con el tipo de usuario que ha entrado en la aplicaci\u00f3n.</p> <p>Debes tener en cuenta:</p> <ul> <li>El estado de una credencial puede ser, activo, inactivo, dado de baja, email por confirmar.</li> <li>Al realizarse la petici\u00f3n de iniciar sesi\u00f3n, se deber\u00e1 comprobar si el usuario acreditado es de correo prueba@test.com y de contrase\u00f1a 1234. Este tipo de usuario es administrador</li> <li>La aplicaci\u00f3n se har\u00e1 por completo en INGL\u00c9S, incluyendo los mensajes al usuario.</li> <li>Se deber\u00e1 realizar la entrega a trav\u00e9s de GitHub.</li> <li>Se realizar\u00e1n tantos commits, como se considere, pero siempre m\u00e1s de uno.</li> <li>Se valorar\u00e1 la organizaci\u00f3n de paquetes.</li> <li>Se podr\u00e1 usar la librer\u00eda creada en el proyecto anterior llamada Help, pero ninguna librer\u00eda m\u00e1s. En caso de usarla, se deber\u00e1 hacer la importaci\u00f3n de forma correcta.</li> </ul>"},{"location":"proyects/cinema/proyecto_v2/","title":"Proyecto V2","text":"<p>Los primeros cambios a realizar sobre la aplicaci\u00f3n son los siguientes:</p> <p>Sobre las credenciales de usuarios debes validas:</p> <ul> <li>El email sea correcto, en caso de no serlo, se lanzar\u00e1 una excepci\u00f3n llama <code>EmailMalFormedEXception</code>.</li> <li>La constrase\u00f1a contenga de 8 a 16 caracteres, y como m\u00ednimo una letra min\u00fascula, una may\u00fascula, un d\u00edgito y un car\u00e1cter especial.</li> <li>Si la credencial no es v\u00e1lida, o no es ning\u00fana de las indicadas en la versi\u00f3n anterior, deber\u00e1 obtener por defecto el estado inactivo.</li> </ul> <p>Sobre los clientes se debe tener en cuenta que la bibliograf\u00eda no supere los 160 caracteres, y en caso de superarlo obtener solo los 160 primeros caracteres de la bibliograf\u00eda. Tambi\u00e9n hay que tener en cuenta que los campos num\u00e9ricos de la direcci\u00f3n, no pueden ser negativos, y en caso de serlos, se lanzar\u00e1 un excepci\u00f3n de tipo <code>IllegalArgumentException</code>.</p> <p>Sobre los encargados y los empleados, hay que tener en cuenta, que el a\u00f1o en el que comenzar\u00f3n sus puestos deben ser n\u00fameros positivos y a\u00f1os l\u00f3gicos y v\u00e1lidos, (no ser\u00eda l\u00f3gico que el empleado empezase a trabajar en la empresa en el a\u00f1o 2 a.C)</p> <p>Debe crear una aplicaci\u00f3n llamada SignUpCliente.java, SignUpEmpleado.java, SignUpEmcargado.java, donde se solicite los datos de registro, y en caso de que alguno sea err\u00f3neo debe volver a solicitarselo. Se debe tener en cuenta que el estado de un usuario debe ser EMAIL POR CONFIRMAR, durante su registro, y que no se debe soliciar al usuario.</p> <p>Una vez que el tipo de usuario haya sido creado\u00a1, se mostrar\u00e1 por pantalla con la siguiente estructura:</p> CLIENTEEMPLEADOENCARGADO <pre><code>Cliente Sa\u00fal Benitez\n - Email: saul@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - Direcci\u00f3n: Calle Inventida, n\u00ba 7 - 11300 - La L\u00ednea de la concepci\u00f3n (C\u00e1diz)\n- Bibliograf\u00eda: Soy cin\u00e9filo, en busca de las mejores ofertas para ir al cine.\n   Me gusta mucho las pel\u00edculas de Marvel y DC, aun que a veces tambi\u00e9n me pongo\n   sensibl\u00f3n y me pongo una comedia rom\u00e1ntica.\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> <pre><code>Cliente Rosa Soria\n - Email: rosa@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - A\u00f1o de contrataci\u00f3n: 2015\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> <pre><code>Cliente Marta Dominguez\n - Email: marta@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - A\u00f1o de contrataci\u00f3n: 2012\n- A\u00f1o de subida: 2018\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> Pregunta para pensar <p>\u00bfPor que no fue un error en la primera versi\u00f3n crear una clase exactamente Admin que heredase de la clase base User? Justifica tu respuesta</p>"}]}