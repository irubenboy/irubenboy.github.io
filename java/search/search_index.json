{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenidx al mundo de Java","text":""},{"location":"bloque_i/tema_1/page-1/","title":"1 Introducci\u00f3n","text":""},{"location":"bloque_i/tema_1/page-1/#conceptos-basicos","title":"Conceptos b\u00e1sicos","text":""},{"location":"bloque_i/tema_1/page-1/#computadora","title":"Computadora","text":"<p>Una computadora. o como se le conoce com\u00fan mente, un ordenador, es una m\u00e1quina electr\u00f3nica, anal\u00f3gica o digital, dotada de una memoria de gran capacidad y de m\u00e9todos de tratamiento de la informaci\u00f3n, capaz de resolver problemas matem\u00e1ticos y l\u00f3gicos mediante la utilizaci\u00f3n autom\u00e1tica de programas inform\u00e1ticos.</p>"},{"location":"bloque_i/tema_1/page-1/#informatica","title":"Inform\u00e1tica","text":"<p>Conjunto de conocimientos cient\u00edficos y t\u00e9cnicas que hacen posible el tratamiento autom\u00e1tico de la informaci\u00f3n por medio de ordenadores.</p>"},{"location":"bloque_i/tema_1/page-1/#hardware","title":"Hardware","text":"<p>Componentes f\u00edsicos que conforman parte de un ordenador (o de otro dispositivo electr\u00f3nico): procesador, RAM, impresora, teclado, rat\u00f3n,...</p>"},{"location":"bloque_i/tema_1/page-1/#software","title":"Software","text":"<p>Es el conjunto de programas de c\u00f3mputo, procedimientos, reglas, documentaci\u00f3n y datos asociados, que forman parte de las operaciones de un sistema de computaci\u00f3n.</p>"},{"location":"bloque_i/tema_1/page-1/#sistema-operativo","title":"Sistema Operativo","text":"<p>Se trata del software encargado de gestionar el ordenador. Es la aplicaci\u00f3n que oculta la f\u00edsica real del ordenador para mostrarnos una interfaz que permita al usuario un mejor y m\u00e1s f\u00e1cil manejo de la computadora. Por ejemplo: Windows, Linux, MacOS, etc.</p>"},{"location":"bloque_i/tema_1/page-1/#algoritmo","title":"Algoritmo","text":"<p>Conjunto ordenado y finito de operaciones que permite hallar la soluci\u00f3n de un problema.</p>"},{"location":"bloque_i/tema_1/page-1/#programa-informatico","title":"Programa inform\u00e1tico","text":"<p>Es una secuencia de instrucciones escritas para realizar una tarea espec\u00edfica en una computadora.</p>"},{"location":"bloque_i/tema_1/page-1/#aplicacion-informatica","title":"Aplicaci\u00f3n Inform\u00e1tica","text":"<p>Software formado por uno o m\u00e1s programas, la documentaci\u00f3n de los mismos y los archivos necesarios para su funcionamiento, de modo que el conjunto completo forma una herramienta de trabajo en un ordenador.</p>"},{"location":"bloque_i/tema_1/page-1/#codificacion-de-la-informacion","title":"Codificaci\u00f3n de la informaci\u00f3n","text":"<p>Un ordenador maneja informaci\u00f3n de todo tipo. Nuestra perspectiva humana nos permite r\u00e1pidamente diferenciar lo que no son n\u00fameros, de lo que es texto, imagen, ... Sin embargo al tratarse de una m\u00e1quina digital, el ordenador s\u00f3lo es capaz de representar n\u00fameros en forma binaria. Por ello todos los ordenadores necesitan codificar la informaci\u00f3n del mundo real al equivalente binario entendible por el ordenador.</p>"},{"location":"bloque_i/tema_1/page-1/#sistemas-numericos","title":"Sistemas Num\u00e9ricos","text":"<p>Existen dos tipos de sistemas num\u00e9ricos:</p> <ol> <li>Sistemas no posicionales. En ellos se utilizan s\u00edmbolos cuyo valor num\u00e9rico es siempre el mismo independientemente de donde se sit\u00faen.Es lo que ocurre con la numeraci\u00f3n romana. En esta numeraci\u00f3n el s\u00edmbolo <code>I</code> significa siempre <code>uno</code> independientemente de su posici\u00f3n.</li> <li>Sistemas posicionales. En ellos los s\u00edmbolos num\u00e9ricos cambian de valor en funci\u00f3n de la posici\u00f3n que ocupe. Es el caso de nuestra numeraci\u00f3n, el s\u00edmbolo 2, en la cifra 12 vale 2; mientra que en la cifra 21 vale viente.</li> </ol> <p>La historia ha demostrado que los sistemas posicionales son mucho mejores para los c\u00e1lculos matem\u00e1ticos ya que las operaciones matem\u00e1ticas son m\u00e1s sencillas. Todos los sistemas posicionales tienen una base, que es el n\u00famero total de s\u00edmbolos que utiliza el sistema.</p>"},{"location":"bloque_i/tema_1/page-1/#sistemas-posicionales","title":"Sistemas posicionales","text":"<ul> <li>Sistema decimal: la base es 10, ya que utiliza 10 s\u00edmbolos, desde el 0 hasta el 9.</li> <li>Sistema binario: la base es 2, utiliza 0 y 1.</li> <li>Sistema octal: la base es 8, desde el 0 hasta el 7. -Sistema hexadecimal: la base es 16, donde el 0 al 9 y desde la A a la F</li> </ul> <p>Para convertir un n\u00famero octal en binario, se representa cada d\u00edgito en octal por tres d\u00edgitos binarios seg\u00fan la siguiente tabla de conversi\u00f3n:</p> Octal Binario 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 <p>Por lo tanto, el n\u00famero 467 en octal ser\u00eda 100110111 en binario.</p> <p>Los mismo podemos hacer con el binario y el hexadecimal pero con 4 d\u00edgitos.</p> Octal Binario 0 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111 8 1000 9 1001 A 1010 B 1011 C 1100 D 1101 E 1110 F 1111 <p>El n\u00famero B3F en hexadecimal es 1011001111111 en binario</p>"},{"location":"bloque_i/tema_1/page-1/#representacion-de-texto-en-el-sistema-binario","title":"Representaci\u00f3n de texto en el sistema binario","text":"<p>Puesto que una computadora no s\u00f3lo maneja n\u00fameros, habr\u00e1 d\u00edgitos binarios que contengan informaci\u00f3n que no es traducible a decimal. Todo depende de c\u00f3mo se interprete esa traducci\u00f3n. Por ejemplo en el caso del texto, lo que se hace es codificar cada car\u00e1cter en una serie de n\u00fameros binarios. El c\u00f3digo ASCII es un est\u00e1ndar que ha sido durante mucho tiempo el m\u00e1s utilizado. Inicialmente era un c\u00f3digo que utilizaba 7 bits para representar texto, lo que significaba que era capaz de codificar 127 caracteres. Por ejemplo el n\u00famero 65 (1000001 en binario) se utiliza para la A may\u00fascula. Poco despu\u00e9s apareci\u00f3 un problema: este c\u00f3digo es suficiente para los caracteres del ingl\u00e9s, pero no para otras lenguas. Entonces se a\u00f1adi\u00f3 el octavo bit para representar otros 128 caracteres que son distintos seg\u00fan idiomas(Europa Occidental usa unos c\u00f3digos que no utiliza Europa Oriental). Eso provoca que un c\u00f3digo como el 190 signifique cosas diferentes si cambiamos de pa\u00eds. Por ello cuando un ordenador necesita mostrar texto, tiene que saber qu\u00e9 juego de c\u00f3digos debe de utilizar (lo cual supone un tremendo problema). Una ampliaci\u00f3n de este m\u00e9todo de codificaci\u00f3n de caracteres es el est\u00e1ndar Unicode que puede utilizar hasta 4 bytes (32 bits) con lo que es capaz de codificar cualquier car\u00e1cter en cualquier lengua del planeta utilizando el mismo conjunto de c\u00f3digos. Poco a poco es el c\u00f3digo que se va extendiendo, siendo actualmente utilizado en un n\u00famero considerable de tecnolog\u00edas recientes, como XML, Java y sistemas operativos modernos.</p> <p>La descripci\u00f3n completa del est\u00e1ndar est\u00e1 disponible en la p\u00e1gina web de Unicode https://unicode.org/. En <code>Quick Links -&gt; Code Charts</code> encontraremos las tablas de caracteres. Los caracteres b\u00e1sicos del espa\u00f1ol los encontraremos en <code>Latin -&gt; Basic Latin (ASCII)</code> y los caracteres especiales del espa\u00f1ol por ejemplo, las vocales acentuadas y la \u00f1, en <code>Latin1 -&gt; Supplement</code>.</p>"},{"location":"bloque_i/tema_1/page-1/#representacion-binaria-de-datos-no-numericos-ni-de-texto","title":"Representaci\u00f3n binaria de datos no num\u00e9ricos ni de texto","text":"<p>En el caso de datos m\u00e1s complejos (im\u00e1genes, v\u00eddeo, audio) se necesita una codificaci\u00f3n m\u00e1s compleja. En el caso, por ejemplo de las im\u00e1genes, una forma b\u00e1sica de codificarlas en binario es la que graba cada p\u00edxel (cada punto distinguible en la imagen) mediante tres bytes: el primero graba el nivel de rojo, el segundo el nivel de azul y el tercero el nivel de verde. Y as\u00ed por cada p\u00edxel. Esto se conoce como modelo de color RGB donde es posible representar un color mediante la mezcla por adici\u00f3n de los tres colores de luz primarios. Por ejemplo un punto en una imagen de color rojo puro: <code>11111111 00000000 00000000</code>. Naturalmente en una imagen no solo se graban los p\u00edxeles sino el tama\u00f1o de la imagen, el modelo de color,... de ah\u00ed que representar estos datos sea tan complejo para el ordenador (y tan complejo entenderlo para nosotros).</p>"},{"location":"bloque_i/tema_1/page-1/#multiplos-para-medir-digitos-binarios","title":"M\u00faltiplos para medir d\u00edgitos binarios","text":"<p>Puesto que toda la informaci\u00f3n de un ordenador se representa de forma binaria, se hizo indispensable el utilizar unidades de medida para poder indicar la capacidad de los dispositivos:</p> <ul> <li>Bit (de binary digit). Representa un d\u00edgito binario. Por ejemplo, se dice que el n\u00famero binario 1001 tiene cuatro bits.</li> <li>Byte. Es el conjunto de 8 bits.</li> <li>Kilobyte. Son 1024 bytes.</li> <li>Megabyte. Son 1024 Kilobytes.</li> <li>Gigabyte. Son 1024 Megabytes.</li> <li>Terabyte. Son 1024 Gigabytes.</li> <li>Petabyte. Son 1024 Terabytes.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#arquitectura-de-von-newmann","title":"Arquitectura de Von Newmann","text":"<p>La mayor\u00eda de los sistemas inform\u00e1ticos actuales se basan en la arquitectura propuesta por Von Newmann. Esta arquitectura se caracteriza porque el programa que ejecuta el sistema inform\u00e1tico est\u00e1 almacenado internamente en el propio sistema.</p> <p> Figura 1 - Arquitectura de Von Newmann</p> <p>Los buses transportan la informaci\u00f3n entre los diferentes elementos.</p> <p> Figura 2 - Buses</p> <ul> <li>Buses de datos: Como su nombre indica transporta datos. Estos datos pueden ser la informaci\u00f3n que se est\u00e1 procesando o las instrucciones del programa que se ejecuta. El ancho en bits del bus de datos define el tama\u00f1o de la palabra del sistema inform\u00e1tico, por ejemplo, 32 bits \u00f3 64 bits.</li> <li>Bus de direcciones: El bus de direcciones se utiliza para indicar el origen y/o el destino de los datos. En el bus de direcciones se indica la posici\u00f3n de memoria a la que se est\u00e1 accediendo en cada momento. Puede tratarse de una direcci\u00f3n de la memoria principal o puede tratarse de una direcci\u00f3n de memoria de un perif\u00e9rico. El ancho en bits del bus de direcciones determina el tama\u00f1o del espacio de memoria direccionable. Un ancho de 16 bits puede almacenar 2 elevado a 16 (65.536) valores diferentes.</li> <li>Bus de control: El bus de control proporciona se\u00f1ales para coordinar las diferentes tareas que se realizan en el sistema inform\u00e1tico. Por ejemplo, R/W indica si es una operaci\u00f3n de lectura o escritura.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#historia-del-software","title":"Historia del Software","text":"<p>Los primeros ordenadores cumpl\u00edan una \u00fanica programaci\u00f3n que estaba definida en los componentes el\u00e9ctricos que formaban el ordenador. La idea de que el ordenador hiciera varias tareas (ordenador programable o multiprop\u00f3sito) hizo que se idearan las tarjetas perforadas. En ellas se utilizaba c\u00f3digo binario, de modo que se hac\u00edan agujeros en ellas para indicar el c\u00f3digo 1 o el cero. Estos \u201cprimeros programas\u201d l\u00f3gicamente serv\u00edan para hacer tareas muy concretas.</p> <p>La llegada de ordenadores electr\u00f3nicos m\u00e1s potentes hizo que los ordenadores se convirtieran en verdaderas m\u00e1quinas digitales que segu\u00edan utilizando el 1 y el 0 del c\u00f3digo binario pero que eran capaces de leer miles de unos y ceros. Empezaron a aparecer los primeros lenguajes de programaci\u00f3n que escrib\u00edan c\u00f3digo m\u00e1s entendible por los humanos que posteriormente era convertido al c\u00f3digo entendible por la m\u00e1quina.</p> <p>Inicialmente la creaci\u00f3n de aplicaciones requer\u00eda escribir pocas l\u00edneas de c\u00f3digo en el ordenador, por lo que no hab\u00eda una t\u00e9cnica especificar a la hora de crear programas. Cada programador se defend\u00eda como pod\u00eda generando el c\u00f3digo a medida que se le ocurr\u00eda. Poco a poco las funciones que se requer\u00edan a los programas fueron aumentando produciendo miles de l\u00edneas de c\u00f3digo que al estar desorganizada hac\u00edan casi imposible su mantenimiento. S\u00f3lo el programador que hab\u00eda escrito el c\u00f3digo era capaz de entenderlo y eso no era en absoluto pr\u00e1ctico.</p> <p>La llamada crisis del software ocurri\u00f3 cuando se percibi\u00f3 que se gastaba m\u00e1s tiempo en hacer las modificaciones a los programas que en volver a crear el software. La raz\u00f3n era que ya se hab\u00edan codificado millones de l\u00edneas de c\u00f3digo antes de que se definiera un buen m\u00e9todo para crear los programas. La soluci\u00f3n a esta crisis ha sido la definici\u00f3n de la Ingenier\u00eda del software como un oficio que requer\u00eda un m\u00e9todo de trabajo similar al del resto de ingenier\u00edas. La b\u00fasqueda de una metodolog\u00eda de trabajo que elimine esta crisis parece que a\u00fan no est\u00e1 resuelta, de hecho los m\u00e9todos de trabajo siguen redefini\u00e9ndose una y otra vez.</p>"},{"location":"bloque_i/tema_1/page-1/#ciclo-de-vida-de-una-aplicacion","title":"Ciclo de vida de una aplicaci\u00f3n","text":"<p> Figura 3 - Ciclo de vida</p> <p>Una de las cosas que se han definido tras el nacimiento de la ingenier\u00eda del software ha sido el ciclo de vida de una aplicaci\u00f3n. El ciclo de vida define los pasos que sigue el proceso de creaci\u00f3n de una aplicaci\u00f3n desde que se propone hasta que finaliza su construcci\u00f3n. Los pasos son:</p> <ol> <li>An\u00e1lisis. En esta fase se determinan los requisitos que tiene que cumplir la aplicaci\u00f3n. Se anota todo aquello que afecta al futuro funcionamiento de la aplicaci\u00f3n. Este paso le realiza un analista.</li> <li>Dise\u00f1o. Se especifican los esquemas de dise\u00f1o de la aplicaci\u00f3n. Estos esquemas forman los planos del programador, los realiza el analista y representan todos los aspectos que requiere la creaci\u00f3n de la aplicaci\u00f3n.</li> <li>Codificaci\u00f3n. En esta fase se pasa el dise\u00f1o a c\u00f3digo escrito en alg\u00fan lenguaje de programaci\u00f3n. Esta es la primera labor que realiza el programador.</li> <li>Pruebas. Se trata de comprobar que el funcionamiento de la aplicaci\u00f3n es la adecuada. Se realiza en varias fases:<ol> <li>Prueba del c\u00f3digo. Las realizan programadores. Normalmente programadores distintos a los que crearon el c\u00f3digo, de ese modo la prueba es m\u00e1s independiente y generar\u00e1 resultados m\u00e1s \u00f3ptimos.</li> <li>Versi\u00f3n alfa. Es una primera versi\u00f3n terminada que se revisa a fin de encontrar errores. Estas pruebas conviene que sean hechas por personal no inform\u00e1tico. El producto s\u00f3lo tiene cierta apariencia de acabado.</li> <li>Versi\u00f3n beta. Versi\u00f3n casi definitiva del software en la que no se estiman fallos, pero que se distribuye a los clientes para que encuentren posibles problemas. A veces est\u00e1 versi\u00f3n acaba siendo la definitiva.</li> </ol> </li> <li>Mantenimiento. Tiene lugar una vez que la aplicaci\u00f3n ha sido ya distribuida. En esta fase se asegura que el sistema siga funcionando aunque cambien los requisitos o el sistema para el que fue dise\u00f1ado el software. Antes esos cambios se hacen los arreglos pertinentes, por lo que habr\u00e1 que retroceder a fases anteriores del ciclo de vida.</li> </ol>"},{"location":"bloque_i/tema_1/page-1/#errores","title":"Errores","text":"<p>Cuando un programa obtiene una salida que no es la esperada, se dice que posee errores. Los errores son uno de los caballos de batalla de los programadores ya que a veces son muy dif\u00edciles de encontrar (de ah\u00ed que hoy en d\u00eda en muchas aplicaciones se distribuyan parches para subsanar errores no encontrados en la creaci\u00f3n de la aplicaci\u00f3n). Tipos de errores:</p> <ul> <li>Error del usuario. Errores que se producen cuando el usuario realiza algo inesperado y el programa no reacciona apropiadamente (se entiende por usuario la persona que utiliza la aplicaci\u00f3n inform\u00e1tica).</li> <li>Errores de documentaci\u00f3n. Ocurren cuando la documentaci\u00f3n del programa no es correcta y provoca fallos en el manejo.</li> <li>Error de interfaz. Se entiende por interfaz el medio con que el usuario se comunica con la m\u00e1quina, como ventanas, men\u00fas, etc. El error de interfaz ocurre si la interfaz de usuario de la aplicaci\u00f3n es enrevesada para el usuario impidiendo su manejo normal. Tambi\u00e9n se llaman as\u00ed los errores de protocolo entre dispositivos.</li> <li>Error de entrada / salida o de comunicaciones. Ocurre cuando falla la comunicaci\u00f3n entre el programa y un dispositivo (se desea imprimir y no hay papel, falla el teclado,...)</li> <li>Error fatal. Ocurre cuando el hardware produce una situaci\u00f3n inesperada que el software no puede controlar (el ordenador se cuelga, errores en la grabaci\u00f3n de datos,...)</li> <li>Error de sintaxis. Ocurre cuando una instrucci\u00f3n del c\u00f3digo no est\u00e1 bien escrita, es decir, tiene un error de sintaxis. Por lo tanto, no puede ser traducida a c\u00f3digo binario.</li> <li>Error de ejecuci\u00f3n. Se produce cuando el ordenador no puede ejecutar alguna instrucci\u00f3n de forma correcta. Por ejemplo, la instrucci\u00f3n c = 5 / 0; es correcta sint\u00e1cticamente y ser\u00e1 traducida a c\u00f3digo binario. Sin embargo, cuando la computadora intente realizar la divisi\u00f3n 5 / 0 se producir\u00e1 un error de ejecuci\u00f3n, ya que, matem\u00e1ticamente, no se puede dividir entre cero.</li> <li>Error de l\u00f3gica. En cuanto a los errores de l\u00f3gica son los m\u00e1s dif\u00edciles de detectar. Cuando un programa no tiene errores de sintaxis ni de ejecuci\u00f3n, pero a\u00fan as\u00ed, no funciona bien, esto es debido a la existencia de alg\u00fan error l\u00f3gico. De manera que, un error de l\u00f3gica se produce cuando los resultados obtenidos no son los esperados.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-de-programacion","title":"Lenguajes de programaci\u00f3n","text":""},{"location":"bloque_i/tema_1/page-1/#historia","title":"Historia","text":""},{"location":"bloque_i/tema_1/page-1/#inicio-en-la-programacion","title":"Inicio en la programaci\u00f3n","text":"<p>Charles Babbage defini\u00f3 a mediados del siglo XIX lo que \u00e9l llam\u00f3 la m\u00e1quina anal\u00edtica. Se considera a esta m\u00e1quina el dise\u00f1o del primer ordenador. La realidad es que no se pudo construir hasta el siglo siguiente. El caso es que su colaboradora Ada Lovelace escribi\u00f3 en tarjetas perforadas una serie de instrucciones que la m\u00e1quina iba a ser capaz de ejecutar. Se dice que eso signific\u00f3 el inicio de la ciencia de la programaci\u00f3n de ordenadores. En la segunda guerra mundial debido a las necesidades militares, la ciencia de la computaci\u00f3n prospera y con ella aparece el famoso ENIAC (Electronic Numerical Integrator And Calculator), que se programaba cambiando su circuiter\u00eda. Esa es la primera forma de programar (que a\u00fan se usa en numerosas m\u00e1quinas) que s\u00f3lo vale para m\u00e1quinas de \u00fanico prop\u00f3sito. Si se cambia el prop\u00f3sito, hay que modificar la m\u00e1quina.</p>"},{"location":"bloque_i/tema_1/page-1/#codigo-maquina-primera-generacion-de-lenguajes-1gl","title":"C\u00f3digo m\u00e1quina. Primera generaci\u00f3n de lenguajes (1GL)","text":"<p>No mucho m\u00e1s tarde apareci\u00f3 la idea de que las m\u00e1quinas fueran capaces de realizar m\u00e1s de una aplicaci\u00f3n. Para lo cual se ide\u00f3 el hecho de que hubiera una memoria donde se almacenaran esas instrucciones. Esa memoria se pod\u00eda rellenar con datos procedentes del exterior. Inicialmente se utilizaron tarjetas perforadas para introducir las instrucciones. Durante mucho tiempo esa fue la forma de programar, que teniendo en cuenta que las m\u00e1quinas entend\u00edan s\u00f3lo c\u00f3digo binario, consist\u00eda en introducir la programaci\u00f3n de la m\u00e1quina mediante unos y ceros, el llamado c\u00f3digo m\u00e1quina. Todav\u00eda los ordenadores es el \u00fanico c\u00f3digo que entienden, por lo que cualquier forma de programar debe de ser convertida a c\u00f3digo m\u00e1quina. S\u00f3lo se ha utilizado por los programadores en los inicios de la inform\u00e1tica. Su incomodidad de trabajo hace que sea impensable para ser utilizado hoy en d\u00eda. Pero cualquier programa de ordenador debe, finalmente, ser convertido a este c\u00f3digo para que un ordenador puede ejecutar las instrucciones de dicho programa. Un detalle a tener en cuenta es que el c\u00f3digo m\u00e1quina es distinto para cada tipo de procesador. Lo que hace que los programas en c\u00f3digo m\u00e1quina no sean portables entre distintas m\u00e1quinas.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguaje-ensamblador-segunda-generacion-de-lenguajes-2gl","title":"Lenguaje ensamblador. Segunda generaci\u00f3n de lenguajes (2GL)","text":"<p>En los a\u00f1os 40 se intent\u00f3 concebir un lenguaje m\u00e1s simb\u00f3lico que permitiera no tener que programar utilizando c\u00f3digo m\u00e1quina. Poco m\u00e1s tarde se ide\u00f3 el lenguaje ensamblador, que es la traducci\u00f3n del c\u00f3digo m\u00e1quina a una forma m\u00e1s textual. Cada tipo de instrucci\u00f3n se asocia a una palabra mnemotecnia (como SUM para sumar por ejemplo), de forma que cada palabra tiene traducci\u00f3n directa en el c\u00f3digo m\u00e1quina. Tras escribir el programa en c\u00f3digo ensamblador, un programa (llamado tambi\u00e9n ensamblador) se encargar\u00e1 de traducir el c\u00f3digo ensamblador a c\u00f3digo m\u00e1quina. Esta traducci\u00f3n es r\u00e1pida puesto que cada l\u00ednea en ensamblador tiene equivalente directo en c\u00f3digo m\u00e1quina (en los lenguajes modernos no ocurre esto). La idea es la siguiente: si en el c\u00f3digo m\u00e1quina el n\u00famero binario 0000 significa sumar, una instrucci\u00f3n m\u00e1quina que sumara el n\u00famero 8 (00001000 en binario) al n\u00famero 16 (00010000 en binario) ser\u00eda <code>00000000100000010000</code>. El ordenador entender\u00eda que los primeros cuatro bits representan la instrucci\u00f3n y los 8 siguientes el primer n\u00famero y los ocho siguientes el segundo n\u00famero (suponiendo que los n\u00fameros ocupan 8 bits). L\u00f3gicamente trabajar de esta forma es muy complicado. Por eso se podr\u00eda utilizar la siguiente traducci\u00f3n en ensamblador: <code>SUM 8 16</code> , que ya se entiende mucho mejor. Puesto que el ensamblador es una representaci\u00f3n textual pero exacta del c\u00f3digo m\u00e1quina, cada programa s\u00f3lo funcionar\u00e1 para la m\u00e1quina en la que fue concebido el programa, es decir, no es portable. La ventaja de este lenguaje es que se puede controlar absolutamente el funcionamiento de la m\u00e1quina, lo que permite crear programas muy eficientes. Lo malo es precisamente que hay que conocer muy bien el funcionamiento de la computadora para crear programas con esta t\u00e9cnica. Adem\u00e1s las l\u00edneas requeridas para realizar una tarea se disparan ya que las instrucciones de la m\u00e1quina son excesivamente simples.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-de-alto-nivel-lenguajes-de-tercera-generacion-3gl","title":"Lenguajes de alto nivel. Lenguajes de tercera generaci\u00f3n (3GL)","text":"<p>Aunque el ensamblador signific\u00f3 una notable mejora sobre el c\u00f3digo m\u00e1quina, segu\u00eda siendo excesivamente cr\u00edptico. De hecho para hacer un programa sencillo, se necesitaban miles y miles l\u00edneas de c\u00f3digo. Para evitar los problemas del ensamblador apareci\u00f3 la tercera generaci\u00f3n de lenguajes de programaci\u00f3n, la de los lenguajes de alto nivel. En este caso el c\u00f3digo vale para cualquier m\u00e1quina pero deber\u00e1 ser traducido mediante software especial que adaptar\u00e1 el c\u00f3digo de alto nivel al c\u00f3digo m\u00e1quina correspondiente. Esta traducci\u00f3n es necesaria ya que el c\u00f3digo en un lenguaje de alto nivel no se parece en absoluto al c\u00f3digo m\u00e1quina. Tras varios intentos de representar lenguajes, en 1957 aparece el que se considera el primer lenguaje de alto nivel, el FORTRAN (FORmula TRANslation), lenguaje orientado a resolver f\u00f3rmulas matem\u00e1ticas. Poco a poco fueron evolucionando los lenguajes formando lenguajes cada vez mejores. As\u00ed en 1958 se crea LISP como lenguaje declarativo para expresiones matem\u00e1ticas, en 1960 se cre\u00f3 el COBOL como lenguaje de gesti\u00f3n y en 1963 se cre\u00f3 PL/I el primer lenguaje que admit\u00eda la multitarea y la programaci\u00f3n modular. BASIC se cre\u00f3 en el a\u00f1o 1964 como lenguaje de programaci\u00f3n sencillo de aprender y ha sido uno de los lenguajes m\u00e1s populares. En 1968 se crea LOGO para ense\u00f1ar a programar a los ni\u00f1os. Pascal se cre\u00f3 con la misma idea acad\u00e9mica pero siendo ejemplo de lenguaje estructurado para programadores avanzados. El creador del Pascal (Niklaus Wirdth) cre\u00f3 Modula en 1977 siendo un lenguaje estructurado para la programaci\u00f3n de sistemas (intentando sustituir al C). C es un lenguaje de programaci\u00f3n originalmente desarrollado por Dennis Ritchie entre 1969 y 1972 como evoluci\u00f3n del anterior lenguaje B a su vez basado en BCPL. Al igual que B, es un lenguaje orientado a la implementaci\u00f3n de Sistemas operativos, concretamente Unix. C es apreciado por la eficiencia del c\u00f3digo que produce y es el lenguaje de programaci\u00f3n m\u00e1s popular para crear software de sistemas, aunque tambi\u00e9n se utiliza para crear aplicaciones. Es un lenguaje de medio nivel ya que dispone de las estructuras t\u00edpicas de los lenguajes de alto nivel pero a su vez dispone de construcciones del lenguaje que permiten un control a muy bajo nivel pudiendo acceder directamente a memoria o dispositivos perif\u00e9ricos.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-de-cuarta-generacion-4gl","title":"Lenguajes de cuarta generaci\u00f3n (4GL)","text":"<p>En los a\u00f1os 70 se empez\u00f3 a utilizar \u00e9ste t\u00e9rmino para hablar de lenguajes en los que apenas hay c\u00f3digo y en su lugar aparecen indicaciones sobre qu\u00e9 es lo que el programa debe de obtener. Se consideraba que el lenguaje SQL (muy utilizado en las bases de datos) y sus derivados eran de cuarta generaci\u00f3n. Los lenguajes de consulta de datos, creaci\u00f3n de formularios, informes,... son lenguajes de cuarta generaci\u00f3n. Aparecieron con los sistemas de base de datos. Actualmente se consideran lenguajes de \u00e9ste tipo a aquellos lenguajes que se programan sin escribir casi c\u00f3digo (lenguajes visuales), mientras que tambi\u00e9n se propone que este nombre se reserve a los lenguajes orientados a objetos.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguaje-orientado-a-objetos","title":"Lenguaje orientado a objetos","text":"<p>En los 80 llegan los lenguajes preparados para la programaci\u00f3n orientada a objetos todos procedentes de Simula (1964) considerado el primer lenguaje con facilidades de uso de objetos. De estos destac\u00f3 inmediatamente C++. A partir de C++ aparecieron numerosos lenguajes que convirtieron los lenguajes cl\u00e1sicos en lenguajes orientados a objetos y adem\u00e1s con mejoras en el entorno de programaci\u00f3n, son los llamados lenguajes visuales: Visual Basic, Delphi (versi\u00f3n orientada a objetos de Pascal), Visual C++,...En 1995 aparece Java como lenguaje totalmente orientado a objetos y en el a\u00f1o 2000 aparece C# un lenguaje que toma la forma de trabajar de C++ y del propio Java.</p>"},{"location":"bloque_i/tema_1/page-1/#lenguajes-para-la-web","title":"Lenguajes para la web","text":"<p>La popularidad de Internet ha producido lenguajes h\u00edbridos que se mezclan con el c\u00f3digo HTML con el que se crean las p\u00e1ginas web. HTML no es un lenguaje en s\u00ed sino un formato de texto pensado para crear p\u00e1ginas web. Estos lenguajes se usan para poder realizar p\u00e1ginas web m\u00e1s potentes. Son lenguajes interpretados como JavaScript o VB Script, o lenguajes especiales para uso en servidores como ASP, JSP o PHP. Todos ellos permiten crear p\u00e1ginas web usando c\u00f3digo mezcla de p\u00e1ginas web y lenguajes de programaci\u00f3n sencillos.</p>"},{"location":"bloque_i/tema_1/page-1/#tipos-de-lenguajes","title":"Tipos de lenguajes","text":"<p>Seg\u00fan el estilo de programaci\u00f3n se puede hacer esta divisi\u00f3n:</p> <ul> <li>Lenguajes imperativos. Son lenguajes que se centran en c\u00f3mo resolver el problema. Las instrucciones se ejecutan secuencialmente y van modificando la memoria del ordenador para producir las salidas requeridas. La mayor\u00eda de lenguajes (C, Pascal, Basic, Cobol, ...) son de este tipo. Dentro de estos lenguajes est\u00e1n tambi\u00e9n los lenguajes orientados a objetos (C++, Java, C#,...).</li> <li>Lenguajes declarativos. Son lenguajes que se centran en el qu\u00e9 queremos resolver en lugar de en c\u00f3mo resolverlo. El m\u00e1s conocido de ellos es el SQL, lenguaje de consulta de Bases de datos.</li> <li>Lenguajes funcionales. Definen funciones que nos responden a trav\u00e9s de una serie de argumentos. Son lenguajes que usan expresiones matem\u00e1ticas. El m\u00e1s conocido de ellos es el LISP.</li> <li>Lenguajes l\u00f3gicos. Lenguajes utilizados para resolver expresiones l\u00f3gicas. Utilizan la l\u00f3gica para producir resultados. El m\u00e1s conocido es el PROLOG.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#interpretes-y-compiladores","title":"Interpretes y compiladores","text":"<p>A la hora de convertir un programa en c\u00f3digo m\u00e1quina, se pueden utilizar dos tipos de software: int\u00e9rpretes y compiladores.</p>"},{"location":"bloque_i/tema_1/page-1/#interpretes","title":"Int\u00e9rpretes","text":"<p>Se convierte cada l\u00ednea a c\u00f3digo m\u00e1quina y se ejecuta ese c\u00f3digo m\u00e1quina antes de convertir la siguiente l\u00ednea. De esa forma si las dos primeras l\u00edneas son correctas y la tercera tiene un fallo de sintaxis, ver\u00edamos el resultado de las dos primeras l\u00edneas y al llegar a la tercera se nos notificar\u00eda el fallo y finalizar\u00eda la ejecuci\u00f3n. El int\u00e9rprete hace una simulaci\u00f3n de modo que parece que la m\u00e1quina entiende directamente las instrucciones del lenguaje, pareciendo que ejecuta cada instrucci\u00f3n (como si fuese c\u00f3digo m\u00e1quina directo). El BASIC era un lenguaje interpretado, se traduc\u00eda l\u00ednea a l\u00ednea. Hoy en d\u00eda la mayor\u00eda de los lenguajes integrados en p\u00e1ginas web son interpretados, la raz\u00f3n es que como la descarga de Internet es lenta, es mejor que las instrucciones se vayan traduciendo seg\u00fan van llegando en lugar de cargar todas en el ordenador. Por eso lenguajes como JavaScript son interpretados.</p> <p>Un programa que se convierte a c\u00f3digo m\u00e1quina mediante un int\u00e9rprete sigue estos pasos:</p> <ol> <li>Lee la primera instrucci\u00f3n</li> <li>Comprueba si es correcta</li> <li>Convierte esa instrucci\u00f3n al c\u00f3digo m\u00e1quina equivalente</li> <li>Lee la siguiente instrucci\u00f3n</li> <li>Vuelve al paso 2 hasta terminar con todas las instrucciones</li> </ol> <p>Ventajas de los int\u00e9rpretes</p> <ul> <li>Se tarda menos en crear el primer c\u00f3digo m\u00e1quina. El programa se ejecuta antes.</li> <li>No hace falta cargar todas las l\u00edneas para empezar a ver resultados (lo que hace que sea una t\u00e9cnica id\u00f3nea para programas que se cargan desde Internet)</li> </ul> <p>Desventajas de los int\u00e9rpretes:</p> <ul> <li>El c\u00f3digo m\u00e1quina producido es peor ya que no se optimiza al valorar una sola l\u00ednea cada vez. El c\u00f3digo optimizado permite estudiar varias l\u00edneas a la vez para producir el mejor c\u00f3digo m\u00e1quina posible, por ello no es posible mediante el uso de int\u00e9rpretes.</li> <li>Todos los errores son errores en tiempo de ejecuci\u00f3n, no se pueden detectar antes de lanzar el programa. Esto hace que la depuraci\u00f3n de los errores sea m\u00e1s compleja.</li> <li>El c\u00f3digo m\u00e1quina resultante gasta m\u00e1s espacio.</li> <li>Hay errores dif\u00edcilmente detectables, ya que para que los errores se produzcan, las l\u00edneas de errores hay que ejecutarlas. Si la l\u00ednea es condicional, hasta que no probemos todas las posibilidades del programa, no sabremos todos los errores de sintaxis cometidos.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#compiladores","title":"Compiladores","text":"<p>Se trata de software que traduce las instrucciones de un lenguaje de programaci\u00f3n de alto nivel a c\u00f3digo m\u00e1quina. La diferencia con los int\u00e9rpretes reside en que se analizan todas las l\u00edneas antes de empezar la traducci\u00f3n. Durante muchos a\u00f1os, los lenguajes potentes han sido compilados. El uso masivo de Internet ha propiciado que esta t\u00e9cnica a veces no sea adecuada y haya lenguajes modernos interpretados o semi-interpretados, mitad se compila hacia un c\u00f3digo intermedio y luego se interpreta l\u00ednea a l\u00ednea (esta t\u00e9cnica la siguen Java y los lenguajes de la plataforma .NET de Microsoft).</p> <p>Ventajas de los compiladores:</p> <ul> <li>Se detectan errores antes de ejecutar el programa (errores de compilaci\u00f3n).</li> <li>El c\u00f3digo m\u00e1quina generado es m\u00e1s r\u00e1pido (ya que se optimiza).</li> <li>Es m\u00e1s f\u00e1cil hacer procesos de depuraci\u00f3n de c\u00f3digo.</li> </ul> <p>Desventajas de los compiladores:</p> <ul> <li>El proceso de compilaci\u00f3n del c\u00f3digo es lento.</li> <li>No es \u00fatil para ejecutar programas desde Internet ya que hay que descargar todo el programa antes de traducirle, lo que ralentiza mucho su uso.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#tipos-de-paradigmas-de-programacion","title":"Tipos de paradigmas de programaci\u00f3n","text":"<p>Un paradigma de programaci\u00f3n es un modelo b\u00e1sico de dise\u00f1o y desarrollo de programas que permite generar programas con un conjunto de normas espec\u00edficas.</p> <p>En general, la mayor\u00eda de paradigmas son variantes de los dos tipos principales de programaci\u00f3n, imperativa y declarativa. En la programaci\u00f3n imperativa se describe paso a paso un conjunto de instrucciones que deben ejecutarse para variar el estado del programa y hallar la soluci\u00f3n, es decir, un algoritmo en el que se describen los pasos necesarios para solucionar el problema.</p> <p>En la programaci\u00f3n declarativa las sentencias que se utilizan lo que hacen es describir el problema que se quiere solucionar; se programa diciendo lo que se quiere resolver pero no las instrucciones necesarias para solucionarlo. Esto \u00faltimo se realizar\u00e1 mediante mecanismos internos de deducci\u00f3n de informaci\u00f3n a partir de la descripci\u00f3n realizada.</p> <p>A continuaci\u00f3n se describen algunas de las distintas variantes de paradigmas de programaci\u00f3n:</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-imperativa","title":"Programaci\u00f3n imperativa","text":"<p>Es uno de los paradigmas de programaci\u00f3n de computadoras m\u00e1s utilizados. Bajo este paradigma, la programaci\u00f3n se describe en t\u00e9rminos del estado del programa y de sentencias que cambian dicho estado. Java es un lenguaje imperativo, lo que implica que un programa Java est\u00e1 compuesto por una secuencia de instrucciones, que son ejecutadas en el mismo orden en el que se escriben, de manera que al ejecutarla se produce cambios en el estado del programa.</p> <p>Dentro de esta categor\u00eda se engloban la programaci\u00f3n estructurada y la programaci\u00f3n orientada a objetos, las cuales han permitido mejorar la mantenibilidad y la calidad de los programas imperativos.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-estructurada","title":"Programaci\u00f3n estructurada","text":"<p>Est\u00e1 orientada a mejorar la claridad, calidad y tiempo de desarrollo de un programa de computadora recurriendo \u00fanicamente a subrutinas y tres estructuras b\u00e1sicas: secuencia, selecci\u00f3n (if y switch) e iteraci\u00f3n(bucles for y while).</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-orientada-a-objetos","title":"Programaci\u00f3n orientada a objetos","text":"<p>La programaci\u00f3n orientada a objetos encapsula elementos denominados objetos.</p> <p>Bajo este paradigma, la programaci\u00f3n se describe como una serie de objetos independientes que se comunican entre s\u00ed. Java es un lenguaje orientado a objetos.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-orientada-a-eventos","title":"Programaci\u00f3n orientada a eventos","text":"<p>La programaci\u00f3n dirigida por eventos es un paradigma de programaci\u00f3n en el que tanto la estructura como la ejecuci\u00f3n de los programas van determinados por los sucesos que ocurran en el sistema, definidos por el usuario o lo que sea que est\u00e9 accionando el programa.</p> <p>Mientras que en la programaci\u00f3n estructurada es el programador el que define cu\u00e1l va a ser el flujo del programa, en la programaci\u00f3n dirigida por eventos ser\u00e1 el propio usuario, o lo que sea que est\u00e9 accionando el programa, el que dirija el flujo del programa. Aunque en la programaci\u00f3n estructurada puede haber intervenci\u00f3n de un agente externo al programa, estas intervenciones ocurrir\u00e1n cuando el programador lo haya determinado, y no en cualquier momento como puede ser en el caso de la programaci\u00f3n dirigida por eventos.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-declarativa","title":"Programaci\u00f3n declarativa","text":"<p>Est\u00e1 basada en describir el problema declarando propiedades y reglas que deben cumplirse, en lugar de instrucciones. La soluci\u00f3n es obtenida mediante mecanismos internos de control, sin especificar exactamente c\u00f3mo encontrarla (tan solo se le indica a la computadora qu\u00e9 es lo que se desea obtener o qu\u00e9 es lo que se est\u00e1 buscando). Los lenguajes declarativos tienen la ventaja de ser razonados matem\u00e1ticamente, lo que permite el uso de mecanismos matem\u00e1ticos para optimizar el rendimiento de los programas.</p> <p>Dentro de esta categor\u00eda se engloban la programaci\u00f3n funcional y la programaci\u00f3n l\u00f3gica.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-funcional","title":"Programaci\u00f3n funcional","text":"<p>Es un paradigma de programaci\u00f3n en el que el resultado de un programa deriva de la aplicaci\u00f3n de distintas funciones a la entrada, sin cambiar el estado interno del programa. En la programaci\u00f3n funcional los bloques principales de construcci\u00f3n de nuestros programas son las funciones, y no los objetos.</p> <p>Al aplicar programaci\u00f3n funcional se produce normalmente un c\u00f3digo m\u00e1s corto y m\u00e1s sencillo de entender que aplicando programaci\u00f3n imperativa.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-logica","title":"Programaci\u00f3n l\u00f3gica","text":"<p>Es un paradigma de programaci\u00f3n basado en la definici\u00f3n de relaciones l\u00f3gicas.</p>"},{"location":"bloque_i/tema_1/page-1/#programacion-multiparadigma","title":"Programaci\u00f3n multiparadigma","text":"<p>Es el uso de dos o m\u00e1s paradigmas dentro de un programa. Por ejemplo, Java es imperativo y orientado a objetos</p>"},{"location":"bloque_i/tema_1/page-10/","title":"10 N\u00fameros aleatorios","text":""},{"location":"bloque_i/tema_1/page-10/#la-clase-random","title":"La clase Random","text":"<p>En java disponemos de la clase Random para generar n\u00fameros aleatorios. La clase dispone de dos constructores, uno sin par\u00e1metros y otro con un par\u00e1metro llamado semilla (seed). Aunque no  podemos  predecir  que  n\u00fameros  se  generar\u00e1n  con  una  semilla  particular,  podemos  sin embargo, duplicar una serie de n\u00fameros aleatorios usando la misma semilla. Es decir, cada vez que  creamos  un  objeto  de  la  clase  Random  con  la  misma  semilla  obtendremos  la  misma secuencia de n\u00fameros aleatorios. Podemos cambiar la semilla de los n\u00fameros aleatorios en cualquier momento utilizando el m\u00e9todo setSeed.</p>"},{"location":"bloque_i/tema_1/page-10/#metodos","title":"M\u00e9todos","text":"<p>Algunos m\u00e9todos de la clase Random para generar n\u00fameros aleatorios:</p> <ul> <li>nextInt(): genera un n\u00famero aleatorio entero de tipo int</li> <li>nextInt(int n): genera un n\u00famero aleatorio entero de tipo int entre 0(incluido) y n(excluido)</li> <li>nextLong(): genera un n\u00famero aleatorio entero de tipo long</li> <li>nextFloat(): genera un n\u00famero aleatorio de tipo float entre 0.0(incluido) y 1.0(excluido)</li> <li>nextDouble():  genera  un  n\u00famero  aleatorio  de  tipo  double  entre  0.0(incluido)  y 1.0(excluido)</li> <li>nextBoolean(): genera un booleano aleatorio</li> </ul>"},{"location":"bloque_i/tema_1/page-10/#numeros-aleatorios-en-un-rango","title":"N\u00fameros aleatorios en un rango","text":"<p>Para generar n\u00fameros aleatorios enteros comprendidos entre un rango de dos n\u00fameros enteros min y max, hay que utilizar la siguiente f\u00f3rmula:</p> <p><code>nextInt(max - min + 1) + min</code></p> <p>Por  ejemplo,  si  queremos  generar  un  n\u00famero  aleatorio  entre  5  y  10:  nextInt(10-5+1)+5  \u2192 nextInt(6)+5</p>"},{"location":"bloque_i/tema_1/page-10/#ejemplo-de-uso","title":"Ejemplo de uso","text":"<p>En el siguiente ejemplo, se puede observar en la ejecuci\u00f3n que utilizando el Random con semilla siempre se generan los mismos n\u00fameros</p> <pre><code>public class RandomClass {\npublic static void main(String[] args) {\nRandom random = new Random(); // Sin semilla\nRandom randomSeed = new Random(3816); // Con semilla. Siempre se generan los mimos n\u00fameros\nSystem.out.println(random.nextBoolean());\nSystem.out.println(random.nextInt());\nSystem.out.println(random.nextLong());\nSystem.out.println(random.nextFloat());\nSystem.out.println(random.nextDouble());\nSystem.out.println(random.nextInt(6) + 5); // Genera un n\u00famero aleatorio entre 5 y 10\nSystem.out.println(randomSeed.nextBoolean());\nSystem.out.println(randomSeed.nextInt());\nSystem.out.println(randomSeed.nextLong());\nSystem.out.println(randomSeed.nextFloat());\nSystem.out.println(randomSeed.nextDouble());\nSystem.out.println(randomSeed.nextInt(6) + 5); // Genera un n\u00famero aleatorio entre 5 y 10\n}\n}\n</code></pre> Ejercicio <p>Sacar aleatoriamente lo siguiente:</p> <ul> <li>La cara de una moneda</li> <li>El lanzamiento de un dado</li> <li>Un n\u00famero entre 34 y 68 ambos incluidos</li> <li>Un n\u00famero decimal</li> <li>Un d\u00eda de la semana y mostrar si es fin de semana o no</li> <li>Un mes del a\u00f1o y mostrar si es verano o no (entenderemos como veranos los meses de julio y agosto)</li> </ul>"},{"location":"bloque_i/tema_1/page-11/","title":"11 Lectura por teclado","text":""},{"location":"bloque_i/tema_1/page-11/#la-clase-system","title":"La clase System","text":"<p>Las aplicaciones pueden necesitar acceder a los recursos del sistema, como por ejemplo, a los dispositivos de entrada/salida est\u00e1ndar para recoger datos desde el teclado o mostrar datos por pantalla. En Java, la entrada por teclado y la salida de informaci\u00f3n por pantalla se hace mediante la clase System del paquete java.lang de la biblioteca de clases de Java. Dicha clase contiene el atributo in para el teclado y el atributo out para la pantalla.</p> <p>Dichos atributos son est\u00e1ticos por lo que se accede a ellos con el nombre de la clase System:</p> <ul> <li><code>System.in</code> Entrada est\u00e1ndar: teclado.</li> <li><code>System.out</code> Salida est\u00e1ndar: pantalla.</li> </ul>"},{"location":"bloque_i/tema_1/page-11/#la-clase-scanner","title":"La clase Scanner","text":"<p>El  kit  de  desarrollo  de  Java,  a  partir  de  su  versi\u00f3n  1.5,  incorpora  la  clase  Scanner  del  paquete java.util la cual posee m\u00e9todos para leer valores de entrada que pueden venir de varias fuentes, como por ejemplo, de datos introducidos por teclado o datos almacenados en un archivo. Para leer datos desde el teclado, tenemos que pasarle el  <code>System.in</code>  al constructor del Scanner:</p> <pre><code>Scanner keyboard = new Scanner (System.in);\n</code></pre> <p>Veamos algunos m\u00e9todos de esta clase:</p> <ul> <li>nextByte, nextShort, nextInt y nextLong: para leer datos de tipo entero.</li> <li>nextFloat y nextDouble: para leer n\u00fameros decimales.</li> <li>next: lee una palabra, es decir, hasta que encuentre un espacio.</li> <li>nextLine: lee una l\u00ednea completa, es decir, hasta que encuentre un salto de l\u00ednea (\\n).</li> </ul> <p>Por ejemplo, para leer un dato de tipo int ser\u00eda:</p> <pre><code>int i = keyboard.nextInt ();\n</code></pre> <p>O bien esta otra instrucci\u00f3n para leer una l\u00ednea completa:</p> <pre><code>String string = keyboard.nextLine();\n</code></pre> <p>He aqu\u00ed un ejemplo de entrada de teclado con la clase Scanner:</p> <pre><code>import java.util.Scanner;\npublic class ScannerClass {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString string;\nint i;\nfloat f;\nboolean b;\nstring = keyboard.nextLine();\nSystem.out.println(string);\ni = keyboard.nextInt();\nSystem.out.println(i);\nb = keyboard.nextBoolean();\nSystem.out.println(b);\nf = keyboard.nextFloat();//(1)!\nSystem.out.println(f);\n}\n}\n</code></pre> <ol> <li>El s\u00edmbolo separador de decimales ser\u00e1 la coma si nuestro idioma por defecto del sistema operativo est\u00e1 configurado en espa\u00f1ol.</li> </ol> <p>El  s\u00edmbolo  separador  de  decimales  ser\u00e1  la  coma  si  nuestro  idioma  por  defecto  del  sistema operativo  est\u00e1  configurado  en  espa\u00f1ol.  Si  deseamos  que  el  separador  decimal  sea  el  punto  en lugar  de  la  coma,  entonces  tendremos  que  a\u00f1adir <code>useLocale(Locale.US)</code>   cuando  creemos  el Scanner:</p> <pre><code>import java.util.Locale;\nimport java.util.Scanner;\npublic class ScannerClassLocale {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in).useLocale(Locale.US);\nfloat f;\n// Debido al useLocale(Locale.US), el s\u00edmbolo separador de decimales ser\u00e1 el punto\nf = keyboard.nextFloat();\nSystem.out.println(f);\n}\n}\n</code></pre> <p>Veamos un ejemplo de lectura de palabras con next():</p> <pre><code>import java.util.Scanner;\npublic class Next {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString string1, string2, string3;\nSystem.out.println(\"Introduzca 3 palabras separadas por espacio: \");\nstring1 = keyboard.next();\nstring2 = keyboard.next();\nstring3 = keyboard.next();\nSystem.out.println(\"Primera palabra: \" + string1);\nSystem.out.println(\"Segunda palabra: \" + string2);\nSystem.out.println(\"Tercera palabra: \" + string3);\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_1/page-11/#buffer-de-datos","title":"Buffer de datos","text":"<p>Un buffer de datos es un espacio de memoria donde se almacenan datos de manera temporal mientras  son  transferidos  o  procesados.  Los  sistemas  de  entrada  de  teclado  poseen  un  buffer que almacena las teclas presionadas.</p> <p>Cuando  introducimos  un  dato  por  teclado,  para  indicar  que  hemos  finalizado  la  introducci\u00f3n pulsamos la tecla Enter. Cuando se ejecuta cualquier next con la clase Scanner(excepto nextLine), se coge el dato correspondiente del buffer pero el Enter se queda guardado como un <code>\\n</code> (salto de l\u00ednea) en el buffer. Si a continuaci\u00f3n se ejecuta un nextLine, lee hasta el salto de l\u00ednea del buffer, es  decir,  lee  cadena  vac\u00eda  y  ya  no  le  da  opci\u00f3n  al  usuario  de  introducir  la  cadena.  Una  posible soluci\u00f3n  ser\u00eda  limpiar  el  buffer  con  un  nextLine  y  luego  realizar  otro  nextLine  para  pedirle  la cadena al usuario.</p> <pre><code>import java.util.Scanner;\npublic class NextLine {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString string;\nint number;\nboolean b;\n// El nextLine() toma el salto de l\u00ednea dejado por cualquier otro next\nSystem.out.println(\"Introduzca un n\u00famero entero: \");\nnumber = keyboard.nextInt();\nSystem.out.println(number);\nSystem.out.println(\"Introduzca una cadena: \");\nstring = keyboard.nextLine();\nSystem.out.println(string);\nSystem.out.println(\"Introduzca un booleano: \");\nb = keyboard.nextBoolean();\nSystem.out.println(b);\nSystem.out.println(\"Introduzca una cadena: \");\nstring = keyboard.nextLine();\nSystem.out.println(string);\nSystem.out.println(\"Introduzca una cadena con next: \");\nstring = keyboard.next();\nSystem.out.println(string);\nSystem.out.println(\"Introduzca una cadena: \");\nstring = keyboard.nextLine();\nSystem.out.println(string);\n// Soluci\u00f3n: poner un nextLine que coja el salto de l\u00ednea. A esto se le conoce\n// como limpiar el buffer\nSystem.out.println(\"Vamos a solucionar el problema.\\nIntroduzca un n\u00famero entero: \");\nnumber = keyboard.nextInt();\nSystem.out.println(number);\nSystem.out.println(\"Introduce una cadena: \");\nkeyboard.nextLine(); // Limpieza del buffer\nstring = keyboard.nextLine();\nSystem.out.println(string);\n}\n}\n</code></pre> <p>Otra soluci\u00f3n ser\u00eda indicarle al objeto scanner que como delimitador use el \\n ya que por defecto es el car\u00e1cter espacio. De esta forma, cuando utilicemos next(), leer\u00e1 todos los caracteres hasta el siguiente \\n. El \u00fanico inconveniente de esto es que no podremos leer palabra a palabra.</p> <pre><code>public class NextDelimiter {\npublic static void main(String[] args) {\nString delimiterWindows = \"\\\\r\\\\n\";\nString delimiterLinuxMac = \"\\\\n\";\nScanner keyboard = new Scanner(System.in).useDelimiter(delimiterWindows);\nString string;\nint number;\nSystem.out.println(\"Introduzca un n\u00famero entero: \");\nnumber = keyboard.nextInt();\nSystem.out.println(number);\nSystem.out.println(\"Introduzca una cadena: \");\nstring = keyboard.next();\nSystem.out.println(string);\n}\n}\n</code></pre> Ejercicio <p>Solic\u00edtale al usuario los siguientes datos. A continuaci\u00f3n, mu\u00e9stralos por consola:</p> <ol> <li>Nombre</li> <li>Apellidos</li> <li>Edad</li> <li>Direcci\u00f3n<ul> <li>Calle</li> <li>N\u00famero</li> <li>C\u00f3digo postal</li> <li>Provincia</li> </ul> </li> <li>Si es estudiante (boolean)</li> <li>Altura (con decimales)</li> </ol>"},{"location":"bloque_i/tema_1/page-12/","title":"12 Escritura en pantalla","text":""},{"location":"bloque_i/tema_1/page-12/#introduccion","title":"Introducci\u00f3n","text":"<p>La salida por pantalla en Java se hace con el objeto System.out. Este objeto es una instancia de la clase  PrintStream  del  paquete  java.lang.  Si  miramos  la  API  de  PrintStream  obtendremos  la variedad de m\u00e9todos para mostrar datos por pantalla, algunos de estos son:</p> <ul> <li>print y println: muestran los datos por pantalla. Est\u00e1n sobrecargados para varios tipos de datos. El println inserta un salto de l\u00ednea despu\u00e9s de mostrar el dato.</li> <li>printf: escribe una cadena de texto utilizando formato.</li> </ul> <p>En print y println, cuando queramos escribir un mensaje y el valor de una variable debemos utilizar el operador de  <code>concatenaci\u00f3n</code>  de cadenas (+), por ejemplo:</p> <pre><code>System.out.println(\"Bienvenido, \" + nombre);\n</code></pre> <p>Escribe el mensaje de \"Bienvenido, Carlos\", si el valor de la variable nombre es Carlos. En print y println, todas las variables que se muestran se consideran como cadenas de texto sin formato,por ejemplo, no ser\u00eda posible indicar que escriba un n\u00famero decimal con dos cifras decimales.</p> <p>Para ello se utiliza printf</p> Ejercicio 1 <p>Muestra en consola lo siguiente, exactamente igual, utilizando <code>System.out.print</code></p> <pre><code>La letra n\u00famero \"101\" es la:    'e'\nEl car\u00e1cter '\\' es:\n        \"especial\"\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#el-metodo-printf","title":"El m\u00e9todo printf","text":"<p><code>printf(String format, Object... args)</code></p> <p>En <code>String format</code> se coloca la cadena a la cual se le quiere dar formato. Utiliza unos c\u00f3digos de conversi\u00f3n para indicar del contenido a mostrar de qu\u00e9 tipo es. Estos c\u00f3digos se caracterizan porque llevan delante el s\u00edmbolo <code>%</code>, algunos de ellos son:</p> <ul> <li><code>%c</code>: car\u00e1cter.</li> <li><code>%s</code>: cadena de texto.</li> <li><code>%d</code>: entero.</li> <li><code>%f</code>: n\u00famero decimal.</li> </ul> <p>Tambi\u00e9n se pueden usar las secuencias de escape que van precedidas de <code>\\</code>, como por ejemplo <code>\\n</code> y <code>\\t</code>, incluso el salto de l\u00ednea <code>\\n</code> tambi\u00e9n se puede especificar como <code>%n</code> .</p> <p>En <code>Object... args</code> se colocan los valores correspondientes. El primero corresponde al primer %, el segundo al segundo, y as\u00ed sucesivamente. Dichos valores tienen que ser expresiones que devuelvan resultados con tipos compatibles a los % que correspondan.</p> <p>Ejemplos:</p> <pre><code>System.out.printf(\"El car\u00e1cter es %c\", 'a');\n</code></pre> <p>Nos mostrar\u00eda por pantalla: <code>El car\u00e1cter es a</code></p> <pre><code>int integer = 10;\nSystem.out.printf(\"%d\", integer);\n</code></pre> <p>Salida por pantalla: <code>10</code></p> <p>Si queremos mostrar el s\u00edmbolo % se utiliza otro % delante:</p> <pre><code>System.out.printf(\"El 20%% de %d es %d\\n\", 200, 200*20/100);\n</code></pre> <p>Salida por pantalla: <code>El 20% de 200 es 40</code></p>"},{"location":"bloque_i/tema_1/page-12/#decimales","title":"Decimales","text":"<p>Para <code>%f</code> podemos especificar el n\u00famero de decimales escribiendo <code>.n</code> entre % y f, siendo n el n\u00famero de decimales:</p> <pre><code>System.out.printf(\"%.2f\", 12.3698);\n</code></pre> <p>La salida por pantalla es <code>12,37</code> ya que se realiza un redondeo para mostrar los decimales indicados.</p>"},{"location":"bloque_i/tema_1/page-12/#numeros-con-signo","title":"N\u00fameros con signo","text":"<p>Para mostrar n\u00fameros con signo se utiliza el s\u00edmbolo + entre % y d si es un n\u00famero entero o entre % y f si es un n\u00famero decimal.</p> <pre><code>int integer = 10;\nSystem.out.printf(\"%+d\", integer);\n</code></pre> <p>Salida por pantalla: <code>+10</code></p> <pre><code>int integer = -10;\nSystem.out.printf(\"%-d\", integer);\n</code></pre> <p>Salida por pantalla: <code>-10</code></p> <pre><code>double decimal = 3.968;\nSystem.out.printf(\"%+.2f\", decimal);\n</code></pre> <p>Salida por pantalla: <code>+3.97</code></p> <pre><code>double decimal = -3.968;\nSystem.out.printf(\"%+f\", decimal);\n</code></pre> <p>Salida por pantalla: <code>-3.968000</code></p>"},{"location":"bloque_i/tema_1/page-12/#mostrar-mas-de-un-valor","title":"Mostrar m\u00e1s de un valor","text":"<p>Utilizaremos tantos % como valores vamos a formatear. Despu\u00e9s de la primera coma, se van poniendo los valores separados por comas, el primero corresponde al primer %, el segundo al segundo %, y as\u00ed sucesivamente.</p> <pre><code>double decimal = 1.25036;\nint integer = 10;\nSystem.out.printf(\"decimal = %.2f integer = %d\", decimal, integer);\n</code></pre> <p>Salida por pantalla: <code>decimal = 1,25 integer = 10</code></p> <p>Tambi\u00e9n podemos cambiar el orden por defecto de correspondencia entre los valores y los % con el s\u00edmbolo <code>$</code>. Ejemplo: <code>%2$d</code> significa que al n\u00famero entero (%d) se le va a asignar el segundo valor (<code>2$</code>).</p> <pre><code>System.out.printf(\"decimal1 = %2$.2f integer = %1$d decimal2 = %2$+.1f\", integer, decimal);\n</code></pre> <p>Salida por pantalla: <code>decimal1 = 1,25 integer = 10 decimal2 = +1,3</code></p> <p>Ejemplo: mostrar el n\u00fameros 123.4567 y su cuadrado ambos con dos decimales:</p> <pre><code>double decimal = 123.4567;\nSystem.out.printf(\"El cuadrado de %.2f es %.2f\", decimal, decimal * decimal)\n</code></pre> <p>Salida por pantalla: <code>El cuadrado de 123,46 es 15241,56</code></p>"},{"location":"bloque_i/tema_1/page-12/#especificar-un-ancho-de-campo","title":"Especificar un ancho de campo","text":"<p>printf permite tambi\u00e9n mostrar valores con un ancho de campo determinado. Por ejemplo, si queremos mostrar un n\u00famero entero en un ancho de 10 caracteres, escribimos 10 enter % y d:</p> EJEMPLOSALIDA <pre><code>int integer = 1234;\nSystem.out.printf(\"Ancho de 10 caracteres con un entero: %10d\", integer);\n</code></pre> <pre><code>Ancho de 10 caracteres con un entero:      1234\n</code></pre> <p>Otro ejemplo con n\u00fameros decimales: mostrar con dos decimales, con signo y en un ancho de campo de 10 caracteres:</p> EJEMPLOSALIDA <pre><code>double decimal = 1.25036;\nSystem.out.printf(\"Ancho de 10 caracteres con un decimal: %+10.2f\", decimal);\n</code></pre> <pre><code>Ancho de 10 caracteres con un decimal:      +1,25\n</code></pre> <p>En el ancho de 10 caracteres, se cuentan adem\u00e1s de las cifras del n\u00famero, la coma decimal, el signo si lo lleva. En este caso, el n\u00famero ocupa un espacio de 5 caracteres (3 cifras, la coma y el signo), por lo tanto, se a\u00f1aden 5 espacios en blanco al principio para completar el tama\u00f1o de 10.</p> <p>Para completar el ancho de caracteres con ceros en lugar de con espacios, se coloca un 0 delante del ancho de caracteres:</p> EJEMPLOSALIDA <pre><code>double decimal = 1.25036;\nSystem.out.printf(\"Ancho de caracteres rellenado con ceros: %+010.2f\", decimal);\n</code></pre> <pre><code>Ancho de caracteres rellenado con ceros: +000001,25\n</code></pre> <p>Veamos un ejemplo con cadenas: mostrar la cadena \"Manolo\" con un ancho de 10 caracteres:</p> EJEMPLOSALIDA <pre><code>System.out.printf(\"Ancho de caracteres con cadenas:%10s\", \"Manolo\");\n</code></pre> <pre><code>Ancho de caracteres con cadenas:    Manolo\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#alineacion-a-la-izquierda","title":"Alineaci\u00f3n a la izquierda","text":"<p>Con el signo <code>-</code> se indica alineaci\u00f3n a la izquierda.</p> <p>Ejemplo: mostrar un decimal con un ancho de 9 caracteres, con tres decimales y alineado a la izquierda:</p> EJEMPLOSALIDA <pre><code>double decimal = 58.965874f;\nSystem.out.printf(\"decimal=%-9.3fQue ocupe 9 caracteres, con tres decimales y alineado a la izquierda\", decimal);\n</code></pre> <pre><code>decimal=58.966   Que ocupe 9 caracteres, con tres decimales y alineado a la izquierda\n</code></pre> <p>Ejemplo con cadenas: mostrar la cadena \"Manolo\" con un ancho de 10 caracteres y alineada a la izquierda:</p> EJEMPLOSALIDA <pre><code>System.out.printf(\"%-10s:Alineaci\u00f3n a la izquierda con cadenas\", \"Manolo\");\n</code></pre> <pre><code>Manolo    :Alineaci\u00f3n a la izquierda con cadenas\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#ejemplos","title":"Ejemplos","text":"<p>He aqu\u00ed todos los ejemplos de printf vistos en este apartado:</p> <pre><code>public class Printf {\npublic static void main(String[] args) {\ndouble decimal;\nint integer;\nSystem.out.printf(\"El car\u00e1cter es %c%n\", 'a');\ninteger = 10;\nSystem.out.printf(\"%d\\n\", integer);\nSystem.out.printf(\"El 20%% de %d es %d\\n\", 200, 200 * 20 / 100);\nSystem.out.printf(\"%.2f\\n\", 12.3698);\ndecimal = 1.25036;\nSystem.out.printf(\"%.3f\\n\", decimal);\nSystem.out.printf(\"%+d\\n\", integer);\ninteger = -10;\nSystem.out.printf(\"%+d\\n\", integer);\ndecimal = 3.968;\nSystem.out.printf(\"%+.2f\\n\", decimal);\ndecimal = -3.968;\nSystem.out.printf(\"%+f\\n\", decimal);\ndecimal = 1.25036;\ninteger = 10;\nSystem.out.printf(\"decimal = %.2f integer = %d\\n\", decimal, integer);\nSystem.out.printf(\"decimal1 = %2$.2f integer = %1$d decimal2 = %2$+.1f\\n\", integer, decimal);\ndecimal = 123.4567;\nSystem.out.printf(\"El cuadrado de %.2f es %.2f\\n\", decimal, decimal * decimal);\ninteger = 1234;\nSystem.out.printf(\"Ancho de 10 caracteres con un entero:%10d\\n\", integer);\ndecimal = 1.25036;\nSystem.out.printf(\"Ancho de 10 caracteres con un decimal:%+10.2f\\n\", decimal);\ndecimal = 1.25036;\nSystem.out.printf(\"Ancho de caracteres rellenado con ceros:%+010.2f\\n\", decimal);\nSystem.out.printf(\"Ancho de caracteres con cadenas:%10s\\n\", \"Manolo\");\ndecimal = 58.965874f;\nSystem.out.printf(\"decimal=%-9.3fQue ocupe 9 caracteres, con tres decimales y alineado a la izquierda\\n\", decimal);\nSystem.out.printf(\"%-10s:Alineaci\u00f3n a la izquierda con cadenas\\n\", \"Manolo\");\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#ejemplo-de-scanner-y-printf","title":"Ejemplo de Scanner y printf","text":"<p>He aqu\u00ed un ejemplo de entrada/salida de datos utilizando Scanner y printf.</p> <pre><code>import java.util.Scanner;\npublic class InputOutput {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString name;\nint age;\nfloat salary;\n// Entrada de datos\nSystem.out.print(\"Nombre: \");\nname = keyboard.nextLine();\nSystem.out.print(\"Edad: \");\nage = keyboard.nextInt();\nSystem.out.print(\"Salario: \");\nsalary = keyboard.nextFloat();\n// Salida de datos\nSystem.out.printf(\"\\nBienvenido: %s\\n\", name);\nSystem.out.printf(\"Tienes: %d a\u00f1os\\n\", age);\nSystem.out.printf(\"Tu salario es: %.2f euros\\n\", salary);\n}\n}\n</code></pre> Ejercicio 2     <p>Utilizando las siguientes variables:</p> <pre><code>int x = 10;\nint y = -10;\nfloat n = 13.269834f;\nString cad = \"Ana\";\n</code></pre> <p>Muestra en consola el siguiente resultado, exactamente igual, utilizando <code>System.out.printf</code>, sin utilizar espacios ni tabulaciones en la cadena de formato y utilizando solamente las variables indicadas anteriormente.</p> <pre><code>10\n+10\n-10\n13,27\n  +13,2698\n  13,26983\n+00013,270\nn=13,27   x=10\n      AnaAna  Ana\n</code></pre>"},{"location":"bloque_i/tema_1/page-12/#colores","title":"Colores","text":"<p>Para poder utilizar colores en la escritura de datos por pantalla, hay que comprobar si es necesario instalar alg\u00fan plugin en el IDE.</p> <p>Las secuencias de escape ANSI permiten enviar informaci\u00f3n de control a la consola para cambiar los  atributos  del  texto  representado.  Solo  debemos  anteponer  a  la  cadena  que  queremos mostrar en color el c\u00f3digo de escape ANSI referente al color.</p> <p>Cuando aplicamos un color a la salida por consola, el resto de salida por consola seguir\u00e1 saliendo de dicho color hasta que se especifique otro color de salida o finalicemos el texto con el c\u00f3digo RESET, en cuyo caso se vuelve al color por defecto.</p> <pre><code>public class Colors {\npublic static final String RESET = \"\\u001B[0m\";\npublic static final String BLACK = \"\\u001B[30m\";\npublic static final String RED = \"\\u001B[31m\";\npublic static final String GREEN = \"\\u001B[32m\";\npublic static final String YELLOW = \"\\u001B[33m\";\npublic static final String BLUE = \"\\u001B[34m\";\npublic static final String PURPLE = \"\\u001B[35m\";\npublic static final String CYAN = \"\\u001B[36m\";\npublic static final String WHITE = \"\\u001B[37m\";\npublic static final String BLACK_BACKGROUND = \"\\u001B[40m\";\npublic static final String RED_BACKGROUND = \"\\u001B[41m\";\npublic static final String GREEN_BACKGROUND = \"\\u001B[42m\";\npublic static final String YELLOW_BACKGROUND = \"\\u001B[43m\";\npublic static final String BLUE_BACKGROUND = \"\\u001B[44m\";\npublic static final String PURPLE_BACKGROUND = \"\\u001B[45m\";\npublic static final String CYAN_BACKGROUND = \"\\u001B[46m\";\npublic static final String WHITE_BACKGROUND = \"\\u001B[47m\";\npublic static final String BOLD = \"\\u001B[1m\";// Negrita\npublic static final String UNDERLINE = \"\\u001B[4m\";// Subrayado\npublic static final String REVERSED = \"\\u001B[7m\";// Invierte los colores del texto y del fondo\n}\n</code></pre> <pre><code>import static examples.tema_01.Colors.*;\npublic class ColorUse {\npublic static void main(String[] args) {\nSystem.out.println(RED + \"Este texto es de color rojo\" + RESET);\nSystem.out.println(\"Volvemos al color por defecto\");\nSystem.out.println(GREEN + \"...y ahora es verde\");\nSystem.out.println(PURPLE_BACKGROUND + \"Fondo morado\");\nSystem.out.println(CYAN + WHITE_BACKGROUND + \"Fondo blanco con texto celeste\");\nSystem.out.println(CYAN + WHITE_BACKGROUND + BOLD + \"Fondo blanco con texto celeste en negrita\");\nSystem.out.println(CYAN + WHITE_BACKGROUND + UNDERLINE + \"Fondo blanco con texto celeste subrayado\");\nSystem.out.printf(\"%s\\n\", YELLOW + RED_BACKGROUND + (char) 9733); //Estrella\nSystem.out.println(YELLOW + GREEN_BACKGROUND + \"Fondo verde con texto amarillo\");\nSystem.out.println(REVERSED + \"Fondo amarillo con texto verde usando REVERSED\");\n}\n}\n</code></pre> Ejercicio 3 <p>Muestra en consola una l\u00ednea de texto con 3 colores y fondos diferentes usando solamente un printf.</p>"},{"location":"bloque_i/tema_1/page-13/","title":"Proyecto","text":"<p>Se desea realizar un proyecto Java en el cu\u00e1l se le solicitar\u00e1 al usuario la siguiente informaci\u00f3n sobre un tri\u00e1ngulo.</p> <ol> <li>Valor de hipotenusa</li> <li>Valor de su base</li> <li>Valor de su altura</li> <li>Nombre</li> </ol> <p>Se mostrar\u00e1 una salida con el siguiente formato, con dicha informaci\u00f3n, usando color de letras azul y un fondo morado:</p> <pre><code>Tri\u00e1ngulo  : Sombra\nHipotenusa : 20,75 cm\nBase       : 15,75 cm\nAltura     : 14.00 cm\n======================\n   \u00c1rea: 189,00 cm\u00b2\n======================\n- No es recto\n- No es equil\u00e1tero\n</code></pre> <p>Para realizar el proyecto se tendr\u00e1 en cuenta los siguientes objeciones:</p> <ol> <li>Se crear\u00e1 un proyecto nuevo cuyo nombre sea el siguiente formato <code>pr01java-NOMBRE-triangulos</code> siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se deber\u00e1 realizar las operaciones pertinentes, incluso si no se han dictado expl\u00edcitamente en el enunciado</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> </ol>"},{"location":"bloque_i/tema_1/page-2/","title":"2 Introducci\u00f3n al lenguaje Java","text":""},{"location":"bloque_i/tema_1/page-2/#historia","title":"Historia","text":"<p>Java es un lenguaje de programaci\u00f3n de prop\u00f3sito general, concurrente, orientado a objetos, que fue dise\u00f1ado espec\u00edficamente para que los desarrolladores de aplicaciones escribieran el programa una vez y lo ejecutaran en cualquier dispositivo, lo que quiere decir que el c\u00f3digo que es ejecutado en una plataforma no tiene que ser recompilado para correr en otra.</p> <p>El lenguaje de programaci\u00f3n Java fue originalmente desarrollado por James Gosling, de Sun Microsystems (constituida en 1982 y posteriormente adquirida el 27 de enero de 2010 por la compa\u00f1\u00eda Oracle). Su sintaxis deriva en gran medida de C y C++, pero tiene menos utilidades de bajo nivel que cualquiera de ellos.</p> <p>El lenguaje Java se cre\u00f3 con cinco objetivos principales:</p> <ol> <li>Deber\u00eda usar el paradigma de la programaci\u00f3n orientada a objetos.</li> <li>Deber\u00eda permitir la ejecuci\u00f3n de un mismo programa en m\u00faltiples sistemas operativos.</li> <li>Deber\u00eda incluir por defecto soporte para trabajo en red.</li> <li>Deber\u00eda dise\u00f1arse para ejecutar c\u00f3digo en sistemas remotos de forma segura.</li> <li>Deber\u00eda ser f\u00e1cil de usar y tomar lo mejor de otros lenguajes orientados a objetos, como C++.</li> </ol>"},{"location":"bloque_i/tema_1/page-2/#bytecode-jvm-jre-jdk","title":"Bytecode, JVM, JRE, JDK","text":"<p>En el mundo de la programaci\u00f3n siempre se ha hablado de lenguajes compilados y de lenguajes interpretados. El resultado del proceso de compilaci\u00f3n (en realidad de compilaci\u00f3n y enlazado) es un archivo ejecutable. Un archivo ejecutable es un programa que se puede lanzar directamente en el sistema operativo; en el caso de Windows o Linux simplemente con hacer doble clic sobre el archivo, se ejecutan sus instrucciones. La ventaja es que los programas ejecutables no necesitan compilarse de nuevo, son programas terminados. El problema es que los sistemas operativos utilizan diferentes tipos de archivos ejecutables: es decir, un archivo ejecutable en Linux no ser\u00eda compatible con Windows.</p> <p>En Java el c\u00f3digo no se traduce a c\u00f3digo ejecutable. En Java el proceso se conoce como precompilaci\u00f3n y sirve para producir un archivo (de extensi\u00f3n class) que contiene c\u00f3digo que no es directamente ejecutable (no es c\u00f3digo Java). Es un c\u00f3digo intermedio llamado bytecode. Al no ser ejecutable, el archivo class no puede ejecutarse directamente con un doble clic en el sistema. El bytecode tiene que ser interpretado (es decir, traducido l\u00ednea a l\u00ednea) por una aplicaci\u00f3n conocida como la m\u00e1quina virtual de Java (JVM).</p> <p>JRE es el Java Runtime Environment o, en espa\u00f1ol, el Entorno de Ejecuci\u00f3n de Java. Contiene a la JVM y otras herramientas que permiten la ejecuci\u00f3n de las aplicaciones Java. La gran ventaja es que el entorno de ejecuci\u00f3n de Java se fabrica para todas las plataformas; lo que significa que un archivo class se puede ejecutar en cualquier ordenador o m\u00e1quina que incorpore el JRE. S\u00f3lo hay una pega, si programamos utilizando por ejemplo la versi\u00f3n 10 de Java, el ordenador en el que queramos ejecutar el programa deber\u00e1 incorporar el JRE al menos de la versi\u00f3n 10.</p> <p>A la forma de producir c\u00f3digo final de Java se la llama JIT (Just In Time,justo en el momento) ya que el c\u00f3digo ejecutable se produce s\u00f3lo en el instante de ejecuci\u00f3n del programa. Es decir, no hay en ning\u00fan momento c\u00f3digo ejecutable.</p> <p>JRE no posee compiladores ni herramientas para desarrollar las aplicaciones Java, solo posee las herramientas para ejecutarlas. JDK es el Java Development Kit o, en espa\u00f1ol, Herramientas de Desarrollo de Java. Sirve para construir programas usando el lenguaje de programaci\u00f3n Java. Trae herramientas \u00fatiles como el compilador (javac), el debugger, herramientas de evaluaci\u00f3n de rendimiento de aplicaciones, etc. Una instalaci\u00f3n de JDK ya contiene un JRE dentro de las carpetas.</p> <p>Para programar en Java, el primer paso que tiene que realizar el alumno es instalarse el JDK de la \u00faltima versi\u00f3n de Java. La descarga la puede efectuar desde la p\u00e1gina web de Oracle https://www.oracle.com/technetwork/java/javase/downloads/index.html/ en la pesta\u00f1a Downloads. Buscar la \u00faltima versi\u00f3n y descargar el JDK del Sistema Operativo con el que el alumno va a trabajar. Pero si al instalar el JDK ya existe una instalaci\u00f3n del JRE en el ordenador de una versi\u00f3n anterior, el JDK no actualizar\u00e1 el JRE a la \u00faltima versi\u00f3n. En este caso, hay que desinstalar primero el JRE y ya despu\u00e9s instalar el JDK de la \u00faltima versi\u00f3n.</p>"},{"location":"bloque_i/tema_1/page-2/#entornos-de-desarrollo-integrado-ide-eclipse","title":"Entornos de desarrollo integrado (IDE): Eclipse","text":"<p>El c\u00f3digo en Java se puede escribir en cualquier editor de texto, y para compilar el c\u00f3digo en bytecodes, s\u00f3lo hace falta descargar la versi\u00f3n del JDK deseada. Sin embargo, la escritura y compilaci\u00f3n de programas hecha de esta forma es un poco inc\u00f3moda. Por ello numerosas empresas fabrican sus propios entornos de edici\u00f3n, algunos incluyen el compilador y otras utilizan el propio JDK de Java.</p> <p>Un IDE ( integrated development environment )  es  un  entorno  de  programaci\u00f3n  que  consiste  b\u00e1sicamente en un editor de c\u00f3digo, un compilador y un depurador.</p> <p>Algunas ventajas que ofrecen son</p> <ul> <li>Facilidades  para  escribir  c\u00f3digo:  coloreado  de  las  palabras  clave,  autocorrecci\u00f3n  al  escribir, abreviaturas,...</li> <li>Facilidades de depuraci\u00f3n, para probar el programa.</li> <li>Facilidad de configuraci\u00f3n del sistema.</li> <li>Facilidades para organizar los archivos de c\u00f3digo.</li> <li>Facilidad para exportar e importar proyectos.</li> </ul> <p>Algunos IDEs para programar en Java son Eclipse, Netbeans e IntelliJ IDEA.</p>"},{"location":"bloque_i/tema_1/page-2/#sentencias","title":"Sentencias","text":"<p>Una sentencia es la unidad m\u00ednima de ejecuci\u00f3n de un programa. Un programa se compone de conjunto de sentencias  que  acaban  resolviendo  un  problema.  Al  final  de  cada  una  de  las  sentencias  encontraremos  un punto y coma (<code>;</code>).</p> <p>Veamos algunos ejemplos de sentencias en java:</p> <ul> <li>Sentencias de declaraci\u00f3n:  <code>int x;</code></li> <li>Invocaciones o llamadas a m\u00e9todos de tipo void: <code>System.out.println(\"Bienvenidos a Programaci\u00f3n\");</code></li> <li>Sentencias de control de flujo: alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</li> </ul>"},{"location":"bloque_i/tema_1/page-2/#expresiones","title":"Expresiones","text":"<p>Una  expresi\u00f3n  es  una  combinaci\u00f3n  de  operadores  y  operandos  que  se  eval\u00faa  gener\u00e1ndose  un  \u00fanico resultado de un tipo determinado.</p> <p>La diferencia entre las sentencias y los operadores es que las expresiones devuelven un valor y las sentencias no devuelven nada.</p>"},{"location":"bloque_i/tema_1/page-2/#bloques","title":"Bloques","text":"<p>Un bloque es un conjunto de sentencias las cuales est\u00e1n delimitadas por llaves:</p> <pre><code>{\nsentencias\n}\n</code></pre>"},{"location":"bloque_i/tema_1/page-3/","title":"3 Variables y constantes","text":""},{"location":"bloque_i/tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Las variables son contenedores que sirven para almacenar los datos que utiliza un programa. Dicho m\u00e1s sencillamente, son nombres que asociamos a determinados datos. La realidad es que cada variable ocupa un espacio  en  la  memoria  RAM  del  ordenador  para  almacenar  el  dato  al  que  se  refiere.  Es  decir,  cuando utilizamos el nombre de la variable realmente estamos haciendo referencia a un dato que est\u00e1 en memoria.</p> <p>Las  variables  tienen  un  nombre  (un  identificador)  que  se  escribe  en  min\u00fascula,  y  si  consta  de  varias palabras,  se  utiliza  la  notaci\u00f3n  lowerCamelCase.  Ejemplo:  myFirstVariable.  Adem\u00e1s,  deben  cumplir  lo siguiente:</p> <ul> <li>No deben comenzar con los caracteres guion bajo ( _ ) o el signo de d\u00f3lar ( $ ), aunque ambos se admiten.</li> <li>Se admiten los n\u00fameros pero no como primer car\u00e1cter.</li> <li>Deben ser cortos pero significativos. La elecci\u00f3n de un nombre de variable debe ser mnem\u00f3nico, es decir, dise\u00f1ado para indicar al observador casual la intenci\u00f3n de su uso. Por ejemplo, si queremos usar una variable para almacenar una edad, la llamaremos edad.</li> <li>Se deben evitar los nombres de variables de un solo car\u00e1cter excepto para las variables temporales \"usar y tirar\". Los nombres comunes de las variables temporales son i, j, k, m, y n para enteros; c, d, y e para los caracteres.</li> </ul>"},{"location":"bloque_i/tema_1/page-3/#declaracion-de-variables","title":"Declaraci\u00f3n de variables","text":"<p>Antes de poder utilizar una variable, esta se debe declarar de la siguiente manera: <code>tipo nombreVariable;</code> Donde tipo es el tipo de datos que almacenar\u00e1 la variable (texto, n\u00fameros enteros,...) y nombreVariable es el identificador de la variable. Ejemplos:</p> <pre><code>int days; boolean exit;\n</code></pre> <p>Java es un lenguaje muy estricto al utilizar tipos de datos. Variables de datos distintos son incompatibles. Algunos autores hablan de lenguaje fuertemente tipado o incluso lenguaje muy tipificado. Se debe a una traducci\u00f3n muy directa del ingl\u00e9s strongly typed referida a los lenguajes que, como Java, son muy r\u00edgidos en el uso de tipos. El caso contrario ser\u00eda el lenguaje C en el que jam\u00e1s se comprueban de manera estricta los tipos de datos. Parte de le seguridad y robustez de las que hace gala Java se deben a esta caracter\u00edstica.</p> <p>Por convenci\u00f3n de c\u00f3digo, todas las declaraciones de variables se ponen al principio.</p>"},{"location":"bloque_i/tema_1/page-3/#inicializacion-de-variables","title":"Inicializaci\u00f3n de variables","text":"<p>En Java se utiliza el operador asignaci\u00f3n <code>=</code> para inicializar una variable, es decir, para darle un valor inicial.</p> <p>La inicializaci\u00f3n se puede realizar:</p> <ul> <li> <p>En la misma l\u00ednea de c\u00f3digo que la declaraci\u00f3n:</p> <pre><code>int x = 7;\n</code></pre> </li> <li> <p>En cualquier otro momento, pero siempre despu\u00e9s de haberla declarado:</p> <pre><code>int x;\n// ...\nx = 7;\n</code></pre> </li> <li> <p>Tambi\u00e9n se puede utilizar una expresi\u00f3n para asignar un valor a una variable:</p> <pre><code>int x;\n// ...\nx =7;\n//...\nx = x * 2;\n</code></pre> </li> <li> <p>Incluso se puede utilizar una expresi\u00f3n en la misma inicializaci\u00f3n:</p> <pre><code>int a = 13, b = 18;\nint c = a + b;\n</code></pre> </li> <li> <p>Se puede declarar m\u00e1s de una variable a la vez del mismo tipo en la misma l\u00ednea si las separamos con comas:</p> <pre><code>int days, year, weeks;\n</code></pre> </li> <li> <p>Incluso se pueden tambi\u00e9n inicializar:</p> <pre><code>int days = 365, years = 2019, weeks;\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_1/page-3/#ambito-de-vida-de-las-variables","title":"\u00c1mbito de vida de las variables","text":"<p>Toda variable tiene un \u00e1mbito de vida. Esto es la parte del c\u00f3digo en la que una variable se puede utilizar, que es en el bloque donde se ha declarado. De hecho las variables tienen un ciclo de vida:</p> <ol> <li>En la declaraci\u00f3n se reserva el espacio necesario para que se puedan comenzar a utilizar (digamos que se avisa de su futura existencia)</li> <li>Se la asigna su primer valor (la variable nace)</li> <li>Se la utiliza en diversas sentencias. Cuando finaliza el bloque en el que fue declarada, la variable muere. Es decir, se libera el espacio que ocupa esa variable en memoria.</li> <li>Una vez que la variable ha sido eliminada, no se puede utilizar. Dicho de otro modo, no se puede utilizar una variable m\u00e1s all\u00e1 del bloque en el que ha sido definida. Ejemplo:</li> </ol> <pre><code>{ // (1)!\nint x = 9;\n} // (2)!\nint y = x;\n</code></pre> <ol> <li>Se utiliza <code>{</code> para indicar el comienzo del bloque dde c\u00f3digo</li> <li>Se utiliza <code>}</code> para indicar el fin del bloque de c\u00f3digo</li> </ol>"},{"location":"bloque_i/tema_1/page-3/#constantes","title":"Constantes","text":"<p>Una constante es un valor que no puede ser modificado durante la ejecuci\u00f3n de un programa, \u00fanicamente puede ser le\u00eddo.</p> <p>La forma de declarar constantes es la misma que la de las variables pero hay que anteponer la palabra final que es la que indica que estamos declarando una constante:</p> <pre><code>final double PI = 3.141591;\n</code></pre> <p>Los nombres de las constantes se deben escribir en may\u00fasculas. Pueden contener tambi\u00e9n guiones bajos. Incluso pueden contener d\u00edgitos pero no como primer car\u00e1cter.</p> <p>Ejemplos:</p> <pre><code>final int MAX_PARTICIPANTS = 10;\nfinal int _MIN1 = 1;\n</code></pre> <p>Cuando  un  mismo  valor  se  utilice  en  varias  partes  del  c\u00f3digo,  entonces  hay  que  declararlo  como  una constante ya que si en alg\u00fan momento de la vida de la aplicaci\u00f3n, ese valor var\u00eda, solamente hay que cambiar el valor de la constante y no estar cambi\u00e1ndolo en todos los sitios del c\u00f3digo donde aparezca.</p> Ejercicio 1 <p>Indica cu\u00e1les de los siguientes no son identificadores.</p> <ol> <li>hola</li> <li>\"a\"</li> <li>1nombre</li> <li>mi variable</li> <li>mi_variable</li> <li>esto_es_una_variable</li> <li>nombre1</li> </ol>"},{"location":"bloque_i/tema_1/page-4/","title":"4 Tipos de datos primitivos","text":""},{"location":"bloque_i/tema_1/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Se llaman tipos primitivos a los tipos de datos originales de un lenguaje de programaci\u00f3n, esto es, aquellos que nos proporciona el lenguaje, java posee los siguientes:</p> Tipo de variable Bytes que ocupa Rango de valores boolean 1 true, false char 2 Caracteres en Unicode byte 1 -128 a 127 short 2 -32.768 a 32.767 int 4 -2.147.483.648 a 2.147.483.647 long 8 -9\u00b71018 a 9\u00b71018 float 4 -3.4\u00b71038 a 3.4\u00b71038 double 8 -3.4\u00b710308 a 3.4\u00b710308"},{"location":"bloque_i/tema_1/page-4/#enteros","title":"Enteros","text":"<p>Los tipos byte, short, int y long sirven para almacenar datos enteros. Los enteros son n\u00fameros sin decimales.</p> <p>Un literal es un elemento de programa que representa directamente un valor:</p> <pre><code>int number = 16; // 16 es un literal\n</code></pre> <p>Los literales se pueden expresar de varias maneras</p> <ul> <li>En decimal, es como se representan por defecto: <code>16</code></li> <li>En binario, anteponiendo 0b: <code>0b10000</code></li> <li>En octal, anteponiendo 0: <code>020</code></li> <li>En hexadecimal, anteponiendo 0x: <code>0x10</code></li> </ul> <p>Por defecto, un literal entero es de tipo int. Si se le coloca detr\u00e1s la letra L, entonces el literal ser\u00e1 de tipo long.</p> <pre><code>int number = 16; //(1)!\nlong number_long = 16L; //(2)!\n</code></pre> <ol> <li>16 es un literal entero</li> <li>16L es un literal de tipo long</li> </ol> <p>No se acepta en general asignar variables de distinto tipo pero existen excepciones. Por ejemplo, si se pueden asignar valores de variables enteras a variables enteras de un tipo superior (por ejemplo, asignar un valor int a una variable long). Pero al rev\u00e9s no se puede:</p> <pre><code>int i = 12;\nbyte b = i; //(1)!\n</code></pre> <ol> <li>Error de compilaci\u00f3n, posible p\u00e9rdida de precisi\u00f3n</li> </ol> <p>La soluci\u00f3n es hacer un casting. Esta operaci\u00f3n permite convertir valores de un tipo a otro tipo, siempre y cuando sea posible:</p> <pre><code>int i = 12;\nbyte b = (byte) i; //(1)!\n</code></pre> <ol> <li>El casting evita el error</li> </ol> <p>Hay que tener en cuenta en estos castings que si el valor asignado sobrepasa el rango del elemento, el valor convertido no tendr\u00e1 ning\u00fan sentido ya que no puede almacenar todos los bits necesarios para representar ese n\u00famero:</p> <pre><code>int i = 1200;\nbyte b = (byte) i; //(1)!\n</code></pre> <ol> <li>El valor de b no tiene sentido</li> </ol> <p>Si lo que asignamos a la variables es un literal, java hace una conversi\u00f3n impl\u00edcita siempre y cuando el literal est\u00e9 dentro del rango permitido para dicho tipo. Por ejemplo, el siguiente c\u00f3digo no da error porque 127 est\u00e1 dentro del rango de los bytes aunque el literal sea por defecto int:</p> <pre><code>byte b = 127;\n</code></pre> <p>Sin embargo, el siguiente c\u00f3digo si da error porque 128 sobrepasa el rango de los tipos byte:</p> <pre><code>byte b = 128; //ERROR\n</code></pre> <p>A partir de Java7, se pueden usar guiones, como separador de miles, para facilitar la lectura al programador:</p> <pre><code>int i = 1_000_000;\n</code></pre> <p>En el siguiente c\u00f3digo de ejemplo, utilizamos <code>System.out.println</code> para escribir en pantalla el valor de las variables:</p> <pre><code>public class Integers {\npublic static void main(String[] args) {\nint i;\nlong l;\nbyte b;\nshort s;\ni = 16; //(1)!\nSystem.out.println(i);\ni = 020; //(2)!\nSystem.out.println(i);\ni = 0x10; //(3)!\nSystem.out.println(i);\ni = 0b10000; //(4)!\nSystem.out.println(i);\nl = 6985742369L; //(5)!\nSystem.out.println(l);\nb = 127; //(6)!\nSystem.out.println(b);\ns = 32767; //(7)!\nSystem.out.println(s);\ni = 1200;\nSystem.out.println(i);\nb = (byte) i;\nSystem.out.println(b); //(8)!\nSystem.out.println(1_000_000); //(9)!\n}\n}\n</code></pre> <ol> <li>16 en decimal</li> <li>20 en octal = 16 decimal</li> <li>10 hexadecimal = 16 decimal</li> <li>10000 binario = 16 decimal</li> <li>Si se le quita la L da error</li> <li>No da error porque est\u00e1 dentro del rango de los bytes aunque su valor por defecto sea int</li> <li>No da error porque est\u00e1 dentro del rango de los shorts aunque su valor por defecto sea int</li> <li>El valor b no tiene sentido</li> <li>Salida por consola: 1000000</li> </ol>"},{"location":"bloque_i/tema_1/page-4/#numeros-decimales","title":"N\u00fameros decimales","text":"<p>Los decimales se almacenan en los tipos float y double. Los decimales no son almacenados de forma exacta por eso siempre hay un posible error y se habla de precisi\u00f3n. Es mucho m\u00e1s preciso el tipo double que el tipo float.</p> <p>Para asignar valores literales a una variable decimal, hay que tener en cuenta que el separador decimal es el punto y no la coma. Es decir para asignar el valor 2,75 a la variable x se har\u00eda: <code>x=2.75;</code></p> <p>A un valor literal (como 1.5 por ejemplo), se le puede indicar con una f al final del n\u00famero que es float (1.5f por ejemplo) o una d para indicar que es double. Si no se indica nada, un n\u00famero literal siempre se entiende que es double, por lo que al usar tipos float hay que convertir los literales:</p> <pre><code>double d = 3.49; //(1)!\nfloat f = 3.49f; //(2)!\n</code></pre> <ol> <li>El literal 3.49 por defecto es double</li> <li>El literal 3.49 se tiene que convertir a float</li> </ol> <p>L\u00f3gicamente no podemos asignar valores decimales a tipos de datos enteros:</p> <pre><code>int x = 9.5; //Error\nint x = (int) 9.5;//(1)!\n</code></pre> <ol> <li>Podemos mediante un casting, pero perderemos los decimales. En este caso, x valdr\u00e1 9.</li> </ol> <p>El caso contrario, sin embargo, si se puede haceR:</p> <pre><code>int x = 9;\ndouble y = z;\n</code></pre> <p>La raz\u00f3n es que los tipos decimales son m\u00e1s grandes que los enteros, por lo que no hay problema de p\u00e9rdida de valores.</p>"},{"location":"bloque_i/tema_1/page-4/#booleanos","title":"Booleanos","text":"<p>Los valores booleanos o l\u00f3gicos se almacenan en el tipo boolean. Sirven para indicar si algo es verdadero (true) o falso (false).</p> <p>Por otro lado, a diferencia del lenguaje C, no se puede en Java asignar n\u00fameros a una variable booleana (en C, el valor false se asocia al n\u00famero 0, y cualquier valor distinto de cero se asocia a true). Tampoco tiene sentido asignar valores de otros tipos de datos a variables booleanas mediante casting:</p> <pre><code>boolean b = (boolean) 9; // no tiene sentido\n</code></pre>"},{"location":"bloque_i/tema_1/page-4/#5-caracteres","title":"5 Caracteres","text":"<p>Los valores de tipo car\u00e1cter sirven para almacenar s\u00edmbolos de escritura. En Java se puede almacenar cualquier c\u00f3digo Unicode en el tipo char.</p> <p>Los literales car\u00e1cter van entre comillas simples, como por ejemplo: <code>'a'</code>.</p> <p>En programaci\u00f3n, secuencias de escape es el conjunto de caracteres que en el c\u00f3digo es interpretado con alg\u00fan fin. En Java, la barra invertida <code>\\</code> se denomina car\u00e1cter de escape, el cual indica que el car\u00e1cter puesto a continuaci\u00f3n ser\u00e1 convertido en car\u00e1cter especial o, si ya es especial, dejar\u00e1 de ser especial. Por ejemplo, si el car\u00e1cter <code>n</code> no es especial pero con la <code>\\</code> delante se convierte en especial ya que <code>\\n</code> se interpreta como un salto de l\u00ednea. La <code>\\</code> es un car\u00e1cter especial pero con otra <code>\\</code> delante deja de ser especial y simplemente es una barra invertida.</p> Car\u00e1cter Significado \\t Tabulador \\n Salto de l\u00ednea \" Dobles comillas ' Comillas simples \\ Barra invertida \\udddd Representa el car\u00e1cter Unicode cuyo c\u00f3digo es representado por dddd en hexadecimal <p>Como se vio en el tema 1. Introducci\u00f3n, la descripci\u00f3n completa del est\u00e1ndar Unicode est\u00e1 disponible en la p\u00e1gina web https://unicode.org/. En dicha p\u00e1gina, encontramos las tablas de caracteres en hexadecimal en el enlace Code Charts. Para saber saber el c\u00f3digo de los caracteres en decimal, podemos acceder al siguiente enlace: https://unicode-table-com/es. Los caracteres imprimibles son del 32 al 126 y del 161 al 255.</p> <p>Para insertar el c\u00f3digo caracteres no disponibles en el teclado, se hace de manera diferente seg\u00fan el Sistema Operativo:</p> <ul> <li>Linux: Ctrl+Shift y luego se pulsa u(para indicar que es Unicode) y el c\u00f3digo Unicode en hexadecimal en el teclado num\u00e9rico desactivado.</li> <li>Windows: ++Alt++ y el c\u00f3digo Unicode en hexadecimal.</li> </ul> <p>Tambi\u00e9n se le puede asignar a una variable de tipo char un car\u00e1cter Unicode, ya sea usando el c\u00f3digo decimal o hexadecimal del car\u00e1cter.</p> <pre><code>public class Characters {\npublic static void main(String[] args) {\nchar character;\ncharacter = 'C'; //(1)!\nSystem.out.println(character);\ncharacter = 67; // (2)!\nSystem.out.println(character);\ncharacter = '\\u0043'; // (3)!\nSystem.out.println(character);\ncharacter = '\\n'; // (4)!\nSystem.out.println(character);\ncharacter = '\\''; // (5)!\nSystem.out.println(character);\ncharacter = '\\\"'; // (6)!\nSystem.out.println(character);\ncharacter = '\"'; // (7)!\nSystem.out.println(character);\ncharacter = '\\\\'; // (8)!\nSystem.out.println(character);\ncharacter = 9752; // (9)!\nSystem.out.println(character);\ncharacter = '\\u2618'; // (10)!\nSystem.out.println(character);\ncharacter = '\u2618'; // (11)!\nSystem.out.println(character);\n}\n}\n</code></pre> <ol> <li>Los literales car\u00e1cter van entre comillas simples</li> <li>El c\u00f3digo Unicode de la C es el 67</li> <li>El c\u00f3digo Unicode de la C en hexadecimal es el 0043</li> <li>Car\u00e1cter especial salto de l\u00ednea</li> <li>Car\u00e1cter especial Comillas Simples</li> <li>Car\u00e1cter especial Comillas Dobles</li> <li>Car\u00e1cter especial comillas dobles se puede utilizar sin el car\u00e1cter de escape en un literal de car\u00e1cter</li> <li>Car\u00e1cter especial barra inclinada</li> <li>C\u00f3digo decimal del car\u00e1cter tr\u00e9bol</li> <li>C\u00f3digo hexadecimal del car\u00e1cter tr\u00e9bol</li> <li>Car\u00e1cter tr\u00e9bol</li> </ol> <p>Si necesitamos almacenar m\u00e1s de un car\u00e1cter, entonces debemos usar otro tipo de datos que nos permite manejar cadenas de caracteres: String.</p> Ejercicio 1 <p>Muestra en consola los siguientes caracteres</p> <ol> <li>\u2764</li> <li>\u2602</li> <li>\u260e</li> <li>\u265e</li> </ol> <p>En Java, las cadenas no se modelan como un dato de tipo primitivo, sino a trav\u00e9s de la clase String. El texto es uno de los tipos de datos m\u00e1s importantes y por ello java lo trata de manera especial. Para Java, las cadenas de texto son objectos especiales. Los textos deben manejarse creando objetos de tipo String.</p> <p>Los literales cadena se escriben entre comillas dobles: <code>\"Esto es un literal cadena</code>\".</p> <p>Ejemplo:</p> <pre><code>String s = \"Estamos aprendiendo a programar\";\n</code></pre> <p>En Java existe tambi\u00e9n la cadena vac\u00eda o nula(\"\"), es decir, una cadena sin ning\u00fan car\u00e1cter. Ejemplo: <code>String s = \"\";</code> A la variable s se le est\u00e1 asignando la cadena vac\u00eda o nula.</p> Ejercicio 2 <p>Sea MAX una constante que vale 1000, a,b e i variables enteras, x una variable decimal, c una variable car\u00e1cter y s una variable cadena. Indicar las sentencias v\u00e1lidas y su valor, razonando la respuesta. Suponer que a = 3 y b = 4.</p> <ol> <li>i = (900 - MAX) / a</li> <li>i = b / 0</li> <li>i = a % (MAX - 900)</li> <li>i = (MAX - 900) % a</li> <li>i = 3.34 * a</li> <li>x = a / b</li> <li>x = a % (a / b)</li> <li>i = a / b</li> <li>i = ++a</li> <li>i = a++</li> <li>c = '''</li> <li>c = '\"'</li> <li>s = 'c'</li> <li>s = \"'\"</li> <li>s = \"\"\"</li> <li>c = '\\u0041'</li> <li>c = 65</li> </ol>"},{"location":"bloque_i/tema_1/page-5/","title":"5 Operadores","text":""},{"location":"bloque_i/tema_1/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Un operador lleva a cabo operaciones sobre uno (operador unario), dos (operador binario) o tres (operador ternario) datos u operandos de tipo primitivo devolviendo un valor determinado tambi\u00e9n de un tipo primitivo. El tipo de valor devuelto tras la evaluaci\u00f3n depende del operador y del  tipo  de  los  operandos.  Por  ejemplo,  los  operadores  aritm\u00e9ticos  trabajan  con  operandos num\u00e9ricos,  llevan  a  cabo  operaciones  aritm\u00e9ticas  b\u00e1sicas  y  devuelven  el  valor  num\u00e9rico correspondiente. Los operadores se pueden clasificar en distintos grupos seg\u00fan se muestra en los siguientes apartados</p>"},{"location":"bloque_i/tema_1/page-5/#operador-asignacion","title":"Operador asignaci\u00f3n","text":"<p>El operador asignaci\u00f3n <code>=</code> es un operador binario que asigna el valor del t\u00e9rmino de la derecha al operando de la izquierda. El operando de la izquierda es una variable. El t\u00e9rmino de la derecha es una expresi\u00f3n de un tipo de dato compatible.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo = Operador asignaci\u00f3n n = 4 n vale 4 <p>No debe confundirse el operador asignaci\u00f3n (=) con el operador relacional de igualdad (==) que se ver\u00e1 m\u00e1s adelante. Adem\u00e1s Java dispone de otros operadores que combinan la asignaci\u00f3n con otras operaciones (operadores aritm\u00e9ticos combinados).</p>"},{"location":"bloque_i/tema_1/page-5/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>El lenguaje de programaci\u00f3n Java tiene varios operadores aritm\u00e9ticos para los datos num\u00e9ricos enteros y decimales.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo - Operador unario de cambio de signo -4 -4 + Suma 2.5 + 7.1 9.6 - Resta 235.6 - 103.5 132.1 * Multiplicaci\u00f3n 1.2 * 1.1 1.32 / Divisi\u00f3n 0.050 / 0.027 / 2 0.253 % M\u00f3dulo 20 % 714.5 % 2 60.5 <p>El resultado exacto depende de los tipos de operandos involucrados. Es conveniente tener en cuenta las siguientes peculiaridades:</p> <ul> <li> <p>El resultado de una expresi\u00f3n se convierte al tipo m\u00e1s general seg\u00fan el siguiente orden de generalidad:     byte \u2192 short \u2192 int \u2192 long \u2192 float \u2192 double     Teniendo esto en cuenta, tenemos que:</p> <ul> <li>El resultado es de tipo long si, al menos, uno de los operandos es de tipo long y ninguno es decimal. </li> <li>El resultado es de tipo int si ninguno de los operandos es de tipo long ni decimal.</li> <li>El resultado es de tipo double si, al menos, uno de los operandos es de tipo double.</li> <li>El resultado es de tipo float si, al menos, uno de los operandos es de tipo float y ninguno es double.</li> </ul> </li> <li> <p>Con  los  n\u00fameros  enteros,  si  se  divide  entre  cero,  se  genera  la  excepci\u00f3n ArithmeticException. Pero si se realiza la divisi\u00f3n entre cero con decimales, el resultado es infinito (<code>Infinity</code>).</p> </li> <li>El resultado de una expresi\u00f3n inv\u00e1lida, por ejemplo, dividir infinito por infinito, no genera una excepci\u00f3n ni un error de ejecuci\u00f3n: es un valor Not a Number (<code>NaN</code>).</li> </ul> <pre><code>public class ArithmeticOperators {\npublic static void main(String[] args) {\nint int1 = 100, int2 = 0;\ndouble dec1 = 20.36, dec2 = 0;\nSystem.out.println(int1 / int2); //(1)!\nSystem.out.println(dec1 / dec2); //(2)!\nSystem.out.println(dec1 % dec2); //(3)!\n}\n}\n</code></pre> <ol> <li>Genera ArithmeticException</li> <li>Infinity</li> <li>NaN</li> </ol> <p>Hay que tener en cuenta que el resultado de estos operadores var\u00eda notablemente si usamos enteros o si usamos n\u00fameros decimales. Por ejemplo:</p> <pre><code>double result1, d1 = 14, d2 = 5;\nint result2, i1 = 14, i2 = 5;\nresult1 = d1 / d2; // result1 = 2.8\nresult2 = i1 / i2; // result2 = 2\n</code></pre> <p>Es m\u00e1s incluso:</p> <pre><code>double result;\nint i1 = 7, i2 = 2;\nresult = i1 / i2; // resultado = 3.0\nresult = (double) i1 / i2; // resultado 3.5\n</code></pre> <p>El operador del m\u00f3dulo (<code>%</code>) sirve para calcular el resto de una divisi\u00f3n tanto entera como decimal.</p> <pre><code>int remainder, i1 = 14, i2 = 5;\nremainder = i1 % i2; // remainder = 4\n</code></pre> <p>En los decimales, el resto se calcula asumiendo que la divisi\u00f3n produce un resultado entero:</p> <pre><code>double remainder, d1 = 7.5, d2 = 2;\nremainder = d1 % d2; // remainder = 1.5\n</code></pre>"},{"location":"bloque_i/tema_1/page-5/#operadores-aritmeticos-incrementales","title":"Operadores aritm\u00e9ticos incrementales","text":"<p>Los  operadores  aritm\u00e9ticos  incrementales  son  operadores  unarios  (un  \u00fanico  operando).  El operando puede ser num\u00e9rico o de tipo char y el resultado es del mismo tipo que el operando.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo ++ Incremento 4++ 5 -- Decremento 4-- 3 <p>En el caso de los caracteres, el incremento/decremento se realiza a su c\u00f3digo Unicode. Es decir, si  una  variable  char  tiene  el  valor  'C',  su  c\u00f3digo  Unicode  es  67.  Si  se  incrementa,  su  c\u00f3digo Unicode pasa a valer 68 que corresponde al valor 'D'.</p> <p>Estos operadores pueden emplearse de dos formas dependiendo de su posici\u00f3n con respecto al operando:</p> <ul> <li>si  el  operador  est\u00e1  detr\u00e1s  del  operando,  primero  se  utiliza  la  variable  y  luego  se incrementa/decrementa su valor:<ul> <li>Post-incremento: a++</li> <li>Post-decremento: a- -</li> </ul> </li> <li>si el operador est\u00e1 delante del operando, primero se incrementa/decrementa el valor de la variable y luego se utiliza.<ul> <li>Pre-incremento: ++a</li> <li>Pre-decremento: - -a</li> </ul> </li> </ul> <pre><code>public class IncrementalArithmeticOperators {\npublic static void main(String[] args) {\nint integer1, integer2;\nchar character1, character2;\ncharacter1 = 'C'; //(1)!\ncharacter1++;\nSystem.out.println(character1); //(2)!\n//(3)!\ncharacter2 = (char) (character1 + 6);\nSystem.out.println(character2); //(4)!\ninteger1 = character2 + 2;\nSystem.out.println(integer1); //(5)!\ncharacter2++;\nSystem.out.println(character2); //(6)!\ninteger1 = character2;\nSystem.out.println(integer1); //(7)!\ninteger1 = 5;\ninteger2 = integer1++;\nSystem.out.println(integer1); //(8)!\nSystem.out.println(integer2); //(9)!\ninteger1 = 5;\ninteger2 = ++integer1;\nSystem.out.println(integer1); //(10)!\nSystem.out.println(integer2); //(11)!\n}\n}\n</code></pre> <ol> <li>Unicode 67</li> <li>Al incrementarse vale 'D', Unicode 68</li> <li>Tambi\u00e9n se pueden utilizar los caracteres con los operadores aritm\u00e9ticos, pero entonces hace falta usar casting</li> <li>character2 vale 'J', Unicode 74</li> <li>integer1 vale 76</li> <li>character2 vale 'K', Unicode 75</li> <li>integer1 vale 75</li> <li>integer1 vale 6</li> <li>integer2 vale 5</li> <li>integer1 vale 6</li> <li>integer2 vale 6</li> </ol>"},{"location":"bloque_i/tema_1/page-5/#operadores-aritmeticos-combinados","title":"Operadores aritm\u00e9ticos combinados","text":"<p>Combinan  un  operador  aritm\u00e9tico  con  el  operador  asignaci\u00f3n.  Como  en  el  caso  de  los operadores  aritm\u00e9ticos,  pueden  tener  operandos  num\u00e9ricos  enteros  o  decimales  y  el  tipo espec\u00edfico del resultado num\u00e9rico depender\u00e1 del tipo de \u00e9stos.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo += Suma combinada a+=b a=a+b -= Resta combinada a-=b a=a-b *= Multiplicaci\u00f3n combinada a*=b a=a*b /= Divisi\u00f3n combinada a/=b a=a/b %= Resto combinado a%=b a=a%b <p>Tambi\u00e9n se pueden utilizar con caracteres:</p> <pre><code>char character='a';\ncharacter+=2; //character vale 'c'\n</code></pre>"},{"location":"bloque_i/tema_1/page-5/#operadores-relacionales","title":"Operadores relacionales","text":"<p>Realizan  comparaciones  entre  datos  compatibles  de  tipos  primitivos  (num\u00e9ricos,  car\u00e1cter  y booleanos)  teniendo  siempre  un  resultado  booleano.  Los  operandos  booleanos  s\u00f3lo  pueden emplear los operadores de igualdad y desigualdad.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo == Igual que 7 == 3 false != Distinto que 'a' != 'k' true &lt; Menor que 'G' &lt; 'B' false &gt; Mayor que 'b' &gt; 'a' true &lt;= Menor o igual que 7.5 &lt;= 7.38 false &gt;= Mayor o igual que 38 &gt;= 7 true"},{"location":"bloque_i/tema_1/page-5/#operadores-logicos-o-booleanos","title":"Operadores l\u00f3gicos o booleanos","text":"<p>Las puertas l\u00f3gicas son circuitos electr\u00f3nicos capaces de realizar operaciones l\u00f3gicas b\u00e1sicas:</p> <ul> <li> <p>Puerta NOT: la salida es la inversa de la entrada. Se corresponde con la siguiente tabla de verdad:</p> A (entrada) S (salida) 0 1 1 0 </li> <li> <p>Puerta AND:  la  se\u00f1al  de  salida  se  activa  solo  cuando  se  activan  todas  las  se\u00f1ales  de entrada. Equivale al producto l\u00f3gico S = A \u00b7 B y se corresponde con la siguiente tabla de verdad:</p> A (entrada1) B (entrada 2) S (salida) 0 0 0 0 1 0 1 0 0 1 1 1 </li> <li> <p>Puerta OR: la salida se activa cuando cualquiera de las entradas est\u00e1 activada. Equivale a la suma l\u00f3gica S = A + B y se corresponde con la siguiente tabla de verdad:</p> A (entrada1) B (entrada 2) S (salida) 0 0 0 0 1 1 1 0 1 1 1 1 </li> </ul> <p>Los operadores l\u00f3gicos o booleanos realizan operaciones sobre datos booleanos y tienen como resultado un valor booleano:</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo ! Negaci\u00f3n - NOT (unario) !false!(5 == 5) truefalse || Suma l\u00f3gica - OR (binario) true || false(5 == 5) || (5 &lt; 4) truetrue &amp;&amp; Producto l\u00f3gico - AND (binario) false &amp;&amp; true(5 == 5) &amp;&amp; (5 &lt; 4) falsefalse <p>El producto l\u00f3gico se realiza con cortocircuito, es decir, si el primer operando es false entonces el segundo operando no se eval\u00faa ya que el resultado va a ser de todas maneras false. En este caso es conveniente situar la condici\u00f3n m\u00e1s propensa a ser falsa en el t\u00e9rmino de la izquierda.</p> <p>La suma l\u00f3gica tambi\u00e9n  se  realiza  con  cortocircuito,  es  decir,  si  el  primer  operando  es  true entonces el segundo operando no se eval\u00faa ya que el resultado va a ser de todas maneras true. En este caso es conveniente colocar la condici\u00f3n m\u00e1s propensa a ser verdadera en el t\u00e9rmino de la izquierda.</p> <p>Estas t\u00e9cnicas reducen el tiempo de ejecuci\u00f3n del programa y ayudan al programador a evitar ciertos  errores.  Por  ejemplo,  <code>5/b==2</code> , si b es  una  variable  de  tipo  entero y  su  valor es 0,  se genera la excepci\u00f3n ArithmeticException. Para evitar este problema, el programador puede hacer lo siguiente: <code>b!=0 &amp;&amp; 5/b==2</code>.Si b contiene el valor 0, <code>b!=0</code> dar\u00e1 false, entonces <code>5/b==2</code> no se eval\u00faa, evitando as\u00ed la generaci\u00f3n de la excepci\u00f3n.</p> <p>Ejemplos de uso de operadores l\u00f3gicos o booleanos:</p> <pre><code>boolean adult, younger;\nint age = 21;\nadult = age &gt;= 18; //adult ser\u00e1 true\nyounger = !adult; //younger ser\u00e1 false\n</code></pre> <pre><code>boolean drivingLicense=true;\nint age=20;\nboolean canDrive= (age&gt;=18) &amp;&amp; drivingLicense;\n/*Si la edad es de al menos 18 a\u00f1os y tiene carnet de conducir,\n  entonces puede conducir*/\n</code></pre> <pre><code>boolean snow =true, rain=false, hail=false;\nboolean badWeather= snow || rain || hail;\n//Si nieva o llueve o graniza, hace mal tiempo\n</code></pre>"},{"location":"bloque_i/tema_1/page-5/#operador-condicional","title":"Operador condicional","text":"<p>Este operador ternario permite devolver valores en funci\u00f3n de una expresi\u00f3n l\u00f3gica. Su sintaxis es la siguiente:</p> <p><code>expresionLogica ? expresion_1 : expresion_2</code></p> <p>Si el resultado de evaluar la expresi\u00f3n l\u00f3gica es verdadero, devuelve el valor de la primera expresi\u00f3n, y en caso contrario, devuelve el valor de la segunda expresi\u00f3n.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo ?: Operador condicional a = 4;b = a == 4 ? a+5 : 6-a;b = a &gt; 4 ? a*7 : a+8; b vale 9 b vale 12 <p>Ejemplo:</p> <pre><code>pay = (age &gt; 18) ? 6000 : 3000;\n</code></pre> <p>En este caso, si la variable edad es mayor de 18, la paga ser\u00e1 de 6000, sino ser\u00e1 de 3000.</p>"},{"location":"bloque_i/tema_1/page-5/#operador-de-concatenacion-de-cadenas","title":"Operador de concatenaci\u00f3n de cadenas","text":"<p>El operador concatenaci\u00f3n <code>+</code> es un operador binario que devuelve una cadena resultado de concatenar dos cadenas que act\u00faan como operando. Si solo uno de los operandos es de tipo cadena, el otro se convierte impl\u00edcitamente en tipo cadena.</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo + Operador concatenaci\u00f3n \"Hola\" + \"Juan\"\"Hola\" + 5 \"HolaJuan\"\"Hola5\""},{"location":"bloque_i/tema_1/page-5/#operador-a-nivel-de-bits","title":"Operador a nivel de bits","text":"<p>Manipulan los bits de los n\u00fameros.</p> Operador Descripci\u00f3n &amp; AND | OR ~ NOT ^ XOR &gt;&gt; Desplazamiento a la derecha &lt;&lt; Desplazamiento a la izquierda &gt;&gt;&gt;&gt; Desplazamiento a la derecha con relleno de ceros &lt;&lt;&lt;&lt; Desplazamiento a la izquierda con relleno de ceros Ejercicio <p>De las siguientes asignaciones, \u00bfcu\u00e1les son v\u00e1lidas? \u00bfCu\u00e1l es el efecto de su ejecuci\u00f3n? \u00bfDe qu\u00e9 tipo deben ser las variables?</p> <ol> <li>z = 2 &lt; 1</li> <li>a = a + 1</li> <li>sqrt(3) = 32717</li> <li>'x' = 'y'</li> <li>x = 'y'</li> <li>a = b</li> <li>precio = precio - precio * (30/100)</li> </ol>"},{"location":"bloque_i/tema_1/page-6/","title":"6 Sentencias y Expresiones","text":""},{"location":"bloque_i/tema_1/page-6/#sentencias","title":"Sentencias","text":"<p>Una sentencia es la unidad m\u00ednima de ejecuci\u00f3n de un programa. Un programa se compone de un  conjunto  de  sentencias  que  acaban  resolviendo  un  problema.  Al  final  de  cada  una  de  las sentencias encontraremos un punto y coma (<code>;</code>).</p> <p>Veamos algunos ejemplos de sentencias en java:</p> <ul> <li>Sentencias de declaraci\u00f3n:  int x;</li> <li>Invocaciones o llamadas a m\u00e9todos de tipo void: <code>System.out.println(\"Bienvenidos a Programaci\u00f3n\");</code></li> <li>Sentencias de control de flujo: alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</li> </ul>"},{"location":"bloque_i/tema_1/page-6/#expresiones","title":"Expresiones","text":"<p>Una expresi\u00f3n es una combinaci\u00f3n de operadores y operandos que se eval\u00faa gener\u00e1ndose un \u00fanico resultado de un tipo determinado.</p> <p>La diferencia entre las sentencias y las expresiones es que las expresiones devuelven un valor y las sentencias no devuelven nada.</p>"},{"location":"bloque_i/tema_1/page-6/#prioridad-entre-operadores","title":"Prioridad entre operadores","text":"<p>A veces hay expresiones con operadores que resultan confusas. Por ejemplo:</p> <p><code>resultado=8+4/2;</code></p> <p>Es  dif\u00edcil  saber  el  resultado.  \u00bfCu\u00e1l  es?  \u00bfseis  o  diez?  La  respuesta  es  10  y  la  raz\u00f3n  es  que  el operador de divisi\u00f3n siempre precede en el orden de ejecuci\u00f3n al de la suma. Es decir, siempre se ejecuta antes la divisi\u00f3n que la suma. Siempre se pueden usar par\u00e9ntesis para forzar el orden deseado:</p> <p><code>resultado=(8+4)/2;</code></p> <p>Ahora no hay duda, el resultado es seis.</p> <p>\u00bfC\u00f3mo podemos saber en qu\u00e9 orden se van a ejecutar los operadores en una expresi\u00f3n en Java? Pues se ejecutan en funci\u00f3n de una prioridad, es decir, primero se ejecuta el que tenga m\u00e1s prioridad. La siguiente tabla muestra todos los operadores Java ordenados de mayor a menor prioridad. La primera l\u00ednea de la tabla contiene los operadores de mayor prioridad y la \u00faltima los de menor prioridad. Los operadores que aparecen en la misma l\u00ednea tienen la misma prioridad.</p> <p>Cuando una expresi\u00f3n tenga dos operadores con la misma prioridad, la expresi\u00f3n se eval\u00faa seg\u00fan su asociatividad.</p> Nivel Operador Descripci\u00f3n Asociatividad 1 [].() acceso elementos arrayacceso miembros objetospar\u00e9ntesis de izquierda a derecha 2 ++-- unario post-incrementounario post-incremento no asociativos 3 ++--+-!~ unario pre-incrementounario pre-decrementounario m\u00e1sunario menosunario l\u00f3gico NOTunario NOT a nivel de bits de derecha a izquierda 4 ()new castcreaci\u00f3n objetos de derecha a izquierda 5 */% multiplicaci\u00f3ndivisi\u00f3nm\u00f3dulo de izquierda a derecha 6 +-+ sumarestaconcatenaci\u00f3n cadenas de izquierda a derecha 7 &lt;&lt;&gt;&gt;&gt;&gt;&gt; desplazamiento a nivel de bits de izquierda a derecha 8 &lt;&lt;=&gt;&gt;=instanceof relacionales no asociativos 9 ==!= igualdistinto de izquierda a derecha 10 &amp; AND nivel de bits de izquierda a derecha 11 ^ XOR nivel de bits de izquierda a derecha 12 | OR nivel de bits de izquierda a derecha 13 &amp;&amp; AND de izquierda a derecha 14 || OR de izquierda a derecha 15 ?: ternario condicional de derecha a izquierda 16 =+=-=*=/=%=&amp;=^|=&lt;&lt;&lt;=&gt;&gt;=&gt;&gt;= asignaciones de derecha a izquierda <p>Por ejemplo:<code>resultado = 9 / 3 * 3;</code> En este caso, la multiplicaci\u00f3n y la divisi\u00f3n tienen la misma prioridad y su asociatividad es de izquierda a derecha por lo que se realiza primero la operaci\u00f3n que est\u00e9 m\u00e1s a la izquierda, que en este caso es la divisi\u00f3n. El resultado por lo tanto es nueve.  Si  se  desea  que  se  haga  primero  la  multiplicaci\u00f3n,  habr\u00eda  que  utilizar  un  par\u00e9ntesis: <code>resultado = 9 / (3 * 3);</code> En este caso, el resultado ser\u00eda 1.</p> <p>Otro  ejemplo: <code>x  =  y  =  z  =  17;</code> Como  la  asociatividad  de  la  asignaci\u00f3n  es  de  derecha a izquierda, primero se asigna el valor 17 a <code>z</code>, luego a <code>y</code> y por \u00faltimo a <code>x</code>.Esto se puede realizar porque el operador de asignaci\u00f3n devuelve el valor asignado.</p> <p>Algunos operadores son no asociativos, por ejemplo, la expresi\u00f3n  <code>x &lt;= y &lt;= z</code> es inv\u00e1lida ya que  el  valor  devuelto  por  estos  operadores  es  de  un  tipo  diferente  (booleano)  al  de  los operandos que necesita (num\u00e9rico o car\u00e1cter).</p>"},{"location":"bloque_i/tema_1/page-6/#evaluacion-de-cortocircuito","title":"Evaluaci\u00f3n de cortocircuito","text":"<p>La evaluaci\u00f3n de cortocircuito denota la sem\u00e1ntica de algunos operadores booleanos en algunos lenguajes  de  programaci\u00f3n  en  los  cuales  si  con  la  evaluaci\u00f3n  de  la  primera  expresi\u00f3n  ya  se conoce el resultado, ya no se eval\u00faan el resto de expresiones. En Java, se utiliza la evaluaci\u00f3n de cortocircuito.</p> <p>Por ejemplo, veamos la siguiente expresi\u00f3n que utiliza operadores <code>AND</code>:</p> <pre><code>12 &lt; 9 &amp;&amp; 5 &gt; 1 &amp;&amp; 8 &lt;= 13\n</code></pre> <p>Se  eval\u00faa  la  primera  expresi\u00f3n <code>12  &lt;  9</code>   dando  false.  Como  el  resultado  va  a  ser  false independientemente del resultado de la segunda y tercera expresi\u00f3n, entonces no se eval\u00faan ni la segunda <code>5 &gt; 1</code> ni la tercera expresi\u00f3n <code>8&lt;= 13</code>, sino que solamente se eval\u00faa la primera, dando como resultado false. Lo mismo ocurre con el operador <code>OR</code>:</p> <pre><code>8 &lt;= 13 || 12 &lt; 9 || 5 &gt; 1\n</code></pre> <p>Se  eval\u00faa  la  primera  expresi\u00f3n <code>8  &lt;=  13</code>   dando true.  Como  el  resultado  va  a  ser  true independientemente del resultado de la segunda y tercera expresi\u00f3n, entonces no se eval\u00faan ni la segunda <code>12 &lt; 9</code> ni la tercera expresi\u00f3n <code>5 &gt; 1</code>, sino que solamente se eval\u00faa la primera, dando como resultado true.</p> Ejercicio 1 <p>Suponiendo realizadas las siguientes sentencias de asignaci\u00f3n: lado1 = 3; precio = 325,6; lado2 = 4; comprar = false; hipotenusa = 5; ch = '7'. Determinar cu\u00e1les de las expresiones siguientes dan un resultado booleano y cu\u00e1les no. Para aquellas que produzcan un resultado booleano determinar si el resultado es verdadero o falso. Para las que no lo sean, explicar la raz\u00f3n. Indicar tambi\u00e9n si existe alguna expresi\u00f3n err\u00f3nea, y crea una aplicaci\u00f3n Java para comprobar los resultados.</p> <ol> <li>5 * precio - 1.50</li> <li>(precio &lt; 300 + 0.1 * precio) ||comprar</li> <li>sqrt(lado1) + sqrt(lado2) = sqrt(hipotenusa)</li> <li>(!comprar) &amp;&amp; (precio + 125.3)</li> <li>(ch &lt;= 'A') &amp;&amp; comprar</li> <li>ch = '7' || !comprar</li> </ol> Ejercicio 2 <p>Calcula el resultado de las siguientes expresiones de forma manual, y luego creando un programa JAVA:</p> <ol> <li>3 * 5 - 4 / 2</li> <li>3 - (3*5)2 / 4</li> <li>32 - 5 * 2</li> <li>7 - 4 * 2 - 5 * 2</li> <li>5 + 4 &lt; 7 + 8</li> <li>4 &lt; 5 * 4 / 2 - 7</li> <li>3 + 6 * 14</li> <li>8 + 7 * 3 + 4 * 6</li> <li>-4 * 7 + 23 / 4 - 5</li> <li>12 + 3 * 7 + 5 * 4</li> <li>!(4 &gt; 6)</li> <li>73 / 2 + 6</li> </ol> Ejercicio 3 <p>Dados los siguientes valores para las variables booleanas a,b y c (a = true, b = false y c = true), evaluar las expresiones que aparecen a continuaci\u00f3n y crear un programa JAVA para comprobar las soluciones:</p> <ol> <li>a &amp;&amp; b || a &amp;&amp; c</li> <li>(a || b) &amp;&amp; (!a || c)</li> <li>a || b &amp;&amp; c</li> <li>!(a || b) &amp;&amp; c</li> </ol> Ejercicio 4 <p>Dado los siguientes valores de las variables x, y, j y k, a\u00f1adir los par\u00e9ntesis que sean necesarios para que las expresiones que las siguen eval\u00faen a verdadero: x = 10; y = 19; j = true; k = false.</p> <ol> <li>x == y || j</li> <li>x &gt;= y || x &lt;=y &amp;&amp; j</li> <li>!j || j</li> <li>!k &amp;&amp; k</li> </ol> Ejercicio 5 <p>Sea n un dato de tipo Entero que suponemos positivo. Empareja las expresiones con la descripci\u00f3n que les corresponda:</p> <p>a) El mayor n\u00famero par no superior a n. b) El primer n\u00famero par mayor o igual que n c) El primer impar mayor o igual que n</p> <p>1) (n / 2)*2 2) n + (n+1) % 2 3) ((n+1)/2)*2</p>"},{"location":"bloque_i/tema_1/page-7/","title":"7 Introducci\u00f3n a las funciones","text":""},{"location":"bloque_i/tema_1/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ol> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ol>"},{"location":"bloque_i/tema_1/page-7/#construccion","title":"Construcci\u00f3n","text":"<p>Una funci\u00f3n se construye de la siguiente manera:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro\nnombre_par\u00e1metro, ... ) {\ninstrucciones\nreturn expresi\u00f3n;\n}\n</code></pre> <ul> <li>modificador_acceso: es la visibilidad que posee la funci\u00f3n (Lo veremos m\u00e1s adelante. De momento, lo utilizaremos como public).</li> <li>tipo_resultado: es el tipo del resultado que devuelve la funci\u00f3n.</li> <li>nombre_funci\u00f3n:  es  el  nombre  que  identifica  a  la  funci\u00f3n.  Utiliza  la  notaci\u00f3n lowerCamelCase. Ejemplo: imprimirResultadoDecimal.</li> <li>tipo_par\u00e1metro nombre_par\u00e1metro,...:  puede  ocurrir  que  la  funci\u00f3n  necesite  ciertos valores para efectuar la misi\u00f3n para la que ha sido creada. Por ejemplo, la funci\u00f3n suma necesitar\u00eda  los  valores  que  tiene  que  sumar.  En  este  caso,  se  deben  indicar  cada  uno  de dichos  valores  con  sus  tipos  correspondientes. A  estos  valores  se  les  conoce como par\u00e1metros  de  la  funci\u00f3n.  Si  la  funci\u00f3n  no  necesita  par\u00e1metros,  entonces  solamente se ponen los par\u00e9ntesis:  <code>nombre_funcion( )</code></li> </ul> <p>A todo esto se le conoce como la firma (signature) de la funci\u00f3n:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro\nnombre_par\u00e1metro, ... )\n</code></pre> <ul> <li>instrucciones: instrucciones que conforman el algoritmo de la funci\u00f3n, para que realice la misi\u00f3n para la que ha sido creada.</li> <li>return expresi\u00f3n;: el return es el que nos devuelve el resultado, por lo tanto la expresi\u00f3n que  acompa\u00f1a  al  return  tiene  que  devolver  un  valor  correspondiente  al  tipo_resultado indicado en la firma de la funci\u00f3n.</li> </ul> <p>Ejemplo de funci\u00f3n con dos par\u00e1metros:</p> <pre><code>public static int add(int sum1,int sum2) {\nreturn sum1+sum2;\n}\n</code></pre> <p>Puede  ser  tambi\u00e9n  que  haya  m\u00e1s  de  un  return.  En  ese  caso,  el  flujo  de  ejecuci\u00f3n  abandona  la funci\u00f3n en cuanto ejecute el primer return. Ejemplo:</p> <pre><code>public static boolean isPar(int n){\nif(n%2==0){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n</code></pre> <p>En  el  caso  de  que  estemos  definiendo  un  procedimiento,  no  tendremos  return  ya  que  no devuelve ning\u00fan resultado y el tipo_resultado es void. Como por ejemplo <code>System.out.println</code>, que escribe en pantalla lo que recibe por par\u00e1metro pero no devuelve nada.</p>"},{"location":"bloque_i/tema_1/page-7/#llamada-a-la-funcion","title":"Llamada a la funci\u00f3n","text":"<p>Una  funci\u00f3n  permite  que  reutilicemos  un  algoritmo  ya  que  se  puede  utilizar  cuando  nos  haga falta.  Para  ello,  solamente  tendremos  que  llamar  a  la  funci\u00f3n  por  su  nombre  y  pasarle  los par\u00e1metros en el mismo orden que se han definido y pertenecientes al mismo tipo de dato. En la llamada, dichos par\u00e1metros se llaman argumentos.</p> <pre><code>public class Functions {\npublic static void main(String[] args) {\nboolean par;\nint result;\npar = isPar(5);//(1)!\nSystem.out.println(par);//(2)!\npar = isPar(4);//(3)!\nSystem.out.println(par);//(4)!\nresult = add(5, 2);//(5)!\nSystem.out.println(result);//(6)!\n}\npublic static boolean isPar(int n) {\nif (n % 2 == 0) {\nreturn true;\n} else {\nreturn false;\n}\n}\npublic static int add(int sum1, int sum2) {\nreturn sum1 + sum2;\n}\n}\n</code></pre> <ol> <li>Se llama a la funci\u00f3n isPar con un valor de 5 en el argumento</li> <li>Mostrar\u00e1 false</li> <li>Se llama a la funci\u00f3n isPar con un valor de 4 en el argumento</li> <li>Mostrar\u00e1 true</li> <li>Se llama a la funci\u00f3n add con los valores 5 y 2 en los argumentos</li> <li>Mostrar\u00e1 7</li> </ol>"},{"location":"bloque_i/tema_1/page-8/","title":"8 Tipos enumerados simples","text":""},{"location":"bloque_i/tema_1/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Los tipos enumerados sirven para restringir el contenido de una variable a una serie de valores predefinidos. Esto suele ayudar a reducir los errores en nuestro c\u00f3digo.</p> <p>En  las  versiones  anteriores  a  la  versi\u00f3n  5  de  Java  no  exist\u00edan  los  tipos  de  datos  enumerados  con  lo  que deb\u00edamos usar constantes de la siguiente forma:</p> <pre><code>final String RED_COLOR = \"rojo\";\nfinal String GREEN_COLOR = \"verde\";\nfinal String BLUE_COLOR = \"azul\";\n</code></pre> <p>A partir de la versi\u00f3n 5 de Java se incorporaron al lenguaje los tipos de datos enumerados con el objetivo de mejorar varios aspectos sobre el uso de las constantes. B\u00e1sicamente, un enumerado en Java es un conjunto fijo  y  relacionado  de  constantes  y deben  usarse  siempre  que  se  necesite  representar  un  conjunto  de constantes con esas caracter\u00edsticas.</p>"},{"location":"bloque_i/tema_1/page-8/#definicion","title":"Definici\u00f3n","text":"<p>Los  enumerados  se  definen  con  la  palabra  enum, el nombre del enumerado  y  luego  el  conjunto  de  las constantes, que por las convenciones del lenguaje se escriben en may\u00fascula. Ejemplo:</p> <pre><code>public enum DayOfWeek {\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n</code></pre> <p>En Java, los tipos enumerados se pueden definir dentro de una clase o como una clase independiente. Si varias clases  van  a  utilizar  el  enum,  entonces  se  define  como  una  clase  independiente.  Si  por  el  contrario,  es solamente una clase la que lo utiliza, entonces se define dentro de dicha clase.</p> <ul> <li> <p>Dentro de una clase:</p> <pre><code>public class SimpleEnum {\npublic enum DayOfWeek {\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\npublic static void main(String[] args) {\nDayOfWeek d;\nd = DayOfWeek.MONDAY;\nSystem.out.println(d == DayOfWeek.MONDAY ? true:false);\nd = DayOfWeek.SUNDAY;\nSystem.out.println(d == DayOfWeek.MONDAY ? true:false);\n}\n}\n</code></pre> </li> <li> <p>Como  una  clase  independiente: hay  que  colocarse  en  el  paquete donde se quiera crear el enum. Luego se pulsa el bot\u00f3n derecho del rat\u00f3n y New \u2192 Enum.</p> <pre><code>public enum DayOfWeeks {\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n</code></pre> <pre><code>public class EnumSimple {\npublic static void main(String[] args) {\nDayOfWeeks d;\nd = DayOfWeeks.MONDAY;\nSystem.out.println(d == DayOfWeeks.MONDAY ? true:false);\nd = DayOfWeeks.SUNDAY;\nSystem.out.println(d == DayOfWeeks.MONDAY ? true:false);\n}\n}\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_1/page-9/","title":"9 Iniciaci\u00f3n a la Programaci\u00f3n Orientada a Objetos","text":""},{"location":"bloque_i/tema_1/page-9/#introduccion","title":"Introducci\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es una t\u00e9cnica de programar aplicaciones basada en una serie de objetos independientes que se comunican entre s\u00ed.</p> <p>A Java se le considera un lenguaje orientado a objetos ya que siempre que se crea un programa en Java, por simple que sea, se necesita declarar una clase, y el concepto de clase pertenece a la programaci\u00f3n orientada a objetos.</p> <p>Un  objeto  es  un  elemento  del  programa  que  integra  sus  propios  datos  y  su  propio funcionamiento. Es decir, un objeto est\u00e1 formado por datos (atributos o propiedades) y por las funciones que es capaz de realizar el objeto (m\u00e9todos). Esta forma de programar se asemeja m\u00e1s al pensamiento humano. La cuesti\u00f3n es detectar adecuadamente los objetos necesarios para una aplicaci\u00f3n. De hecho hay que detectar las distintas clases de objetos.</p> <p>Una clase es lo que define a un tipo de objeto. Al definir una clase lo que se hace es indicar como funciona un determinado tipo de objeto. Luego, a partir de la clase, podremos crear objetos de esa  clase, es  decir,  la  clase  es  como  un  molde  a  partir  del  cual  se  crean  los  objetos  que pertenecen  a  ella.  Realmente  la  programaci\u00f3n  orientada  a  objetos  es  una  programaci\u00f3n orientada a clases. Es decir, lo que necesitamos programar es como funcionan las clases de objetos.</p> <p>Por ejemplo, una clase podr\u00eda ser la clase Coche. Cuando se defina esta clase, indicaremos los atributos o propiedades (como el color, modelo, marca, velocidad m\u00e1xima,...) y los m\u00e9todos (arrancar, parar, repostar, acelerar, frenar...). Todos los coches, es decir, todos los objetos de la clase Coche, tendr\u00e1n esas propiedades y esos m\u00e9todos. Para explicar la diferencia entre clase y objeto:</p> <ul> <li>la clase Coche representa a todos los coches.</li> <li>un coche concreto es un objeto, es decir, un ejemplar de una clase es un objeto. Tambi\u00e9n se le llama a los objetos instancias de la clase. Este t\u00e9rmino procede del ingl\u00e9s, instance, que realmente significa ejemplar.</li> </ul> <p>Por ejemplo, si quisi\u00e9ramos crear el juego del parch\u00eds en Java, una clase ser\u00eda la casilla, otra las fichas,  otra  el  dado,  etc.  En  el  caso  de  la  casilla,  se  definir\u00eda  la  clase  para  indicar  su funcionamiento y sus propiedades, y luego se crear\u00edan tantos objetos casilla como casillas tenga el juego. Lo mismo ocurrir\u00eda con las fichas, la clase ficha definir\u00eda las propiedades de la ficha (color  y  posici\u00f3n  por  ejemplo)  y  su  funcionamiento  mediante  sus  m\u00e9todos  (por  ejemplo  un m\u00e9todo ser\u00eda mover, otro llegar a la meta, etc), luego se crear\u00edan tantos objetos ficha como fichas tenga el juego.</p>"},{"location":"bloque_i/tema_1/page-9/#creacion-de-objetos","title":"Creaci\u00f3n de objetos","text":"<p>Una vez definida la clase, ya se pueden crear objetos de la misma. Para crear un objeto, hay que declarar una variable cuyo tipo ser\u00e1 la propia clase.</p> <p>Si por ejemplo defini\u00e9ramos una clase llamada Vehicle para modelar veh\u00edculos, para crear un objeto tendr\u00edamos que declarar una variable de tipo Vehicle:</p> <pre><code>Vehicle car; // car es una variable de tipo Vehicle\n</code></pre> <p>Una vez definida la variable, se le crea el objeto llamando a un m\u00e9todo que se llama constructor. Un constructor es un m\u00e9todo que se invoca cuando se crea un objeto y que sirve para inicializar los atributos del objeto y para realizar las acciones pertinentes que requiera el mismo para ser creado. El constructor tiene el mismo nombre que la clase y para invocarlo se utiliza el operador new.</p> <pre><code>car = new Vehicle(); // Vehicle() es un m\u00e9todo constructor\n</code></pre> <p>Tambi\u00e9n se puede hacer todo en la misma l\u00ednea:</p> <pre><code>Vehicle car = new Vehicle();\n</code></pre>"},{"location":"bloque_i/tema_1/page-9/#acceso-a-los-atributos-y-metodos-del-objeto","title":"Acceso a los atributos y m\u00e9todos del objeto","text":"<p>Una  vez  creado  el  objeto,  se  puede  acceder  a  sus  atributos  de  la  siguiente  manera: <code>objeto.atributo</code>.</p> <pre><code>car.wheelCount = 4; //(1)!\n</code></pre> <ol> <li>Se le asigna 4 al atributo de ruedas de la variable car.</li> </ol> <p>Los m\u00e9todos se utilizan de la misma forma que los atributos, a excepci\u00f3n de que los m\u00e9todos poseen  siempre  par\u00e9ntesis  ya  que  son  funciones  que  pertenecen  a  un  objeto: <code>objeto.m\u00e9todo(argumentos)</code>.</p> <pre><code>car.accelerate(30); //(1)!\n</code></pre> <ol> <li>El coche incrementa su velocidad en 30. Es decir, si iba a 90km/h, despu\u00e9s de ejecutar el m\u00e9todo, el coche va a 120km/h.</li> </ol>"},{"location":"bloque_i/tema_1/page-9/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<p>Java admite sobrecargar los m\u00e9todos, es decir, crear distintas variantes del mismo m\u00e9todo con el mismo nombre pero que se diferencien en el orden, tipo o n\u00famero de los par\u00e1metros. Por ejemplo, tenemos el m\u00e9todo para <code>sumar  add(int x,double y)</code>:</p> <ul> <li>S\u00ed  podr\u00edamos  definir  el  m\u00e9todo <code>add(double  x,int  y)</code> porque  var\u00eda  el  orden  de  los par\u00e1metros.</li> </ul> <p>Otro ejemplo donde tenemos el m\u00e9todo <code>add(int x,int y)</code>:</p> <ul> <li>No  podr\u00edamos  definir  otro  m\u00e9todo <code>add(int  a,int  b)</code>porque  no  var\u00eda  el  tipo  ni  el n\u00famero de par\u00e1metros.</li> <li>S\u00ed podr\u00edamos definir <code>add(int a)  y  add(int  a,int  b,int  c)</code> porque  el  n\u00famero  de par\u00e1metros var\u00eda. Tambi\u00e9n podr\u00edamos definir `add(int x,double y)p porque aunque no var\u00ede el n\u00famero de par\u00e1metros, s\u00ed var\u00eda uno de los tipos.</li> </ul>"},{"location":"bloque_i/tema_1/page-9/#metodos-estaticos-y-dinamicos","title":"M\u00e9todos est\u00e1ticos y din\u00e1micos","text":"<p>A los m\u00e9todos asociados a los objetos se les conoce como m\u00e9todos din\u00e1micos. Pero puede ocurrir que tengamos m\u00e9todos que no est\u00e9n asociados a ning\u00fan objeto, por ejemplo, m\u00e9todos de utilidad general. Dichos m\u00e9todos se les conoce como m\u00e9todos est\u00e1ticos y se definen con la palabra static. Al no estar asociados a ning\u00fan objeto, se utilizan con el nombre de la clase: <code>Clase.metodoEst\u00e1tico(argumentos)</code>. Ejemplos de llamadas a m\u00e9todos din\u00e1micos y est\u00e1ticos:</p> <ul> <li>Llamada a m\u00e9todo din\u00e1mico: <code>car.accelerate(30);</code></li> <li>Llamada a m\u00e9todo est\u00e1tico: <code>Math.pow(2,3);</code></li> </ul>"},{"location":"bloque_i/tema_1/page-9/#api-de-java","title":"Api de Java","text":"<p>La API de Java es una interfaz de programaci\u00f3n de aplicaciones (API, por sus siglas del ingl\u00e9s: Application Programming Interface) provista por los creadores del lenguaje de programaci\u00f3n Java, que da a los programadores los medios para desarrollar aplicaciones Java.</p> <p>Al instalar Java (el paquete JDK) en nuestro ordenador, adem\u00e1s del compilador y la m\u00e1quina virtual de Java se instalan bastantes m\u00e1s elementos. Entre ellos, una cantidad muy importante de clases que ofrece la multinacional desarrolladora de Java y que est\u00e1n a disposici\u00f3n de todos los programadores listas para ser usadas.  Estas clases junto a otros elementos forman lo que se denomina API de Java.</p> <p>Los paquetes donde se encuentran dichas clases los podemos encontrar en https://docs.oracle.com/  \u2192 Java \u2192 Java SE Documentation \u2192 JDK  de  la  versi\u00f3n  deseada  \u2192  Specifications \u2192 API Documentation \u2192 Module: java.base.</p> <p>Otra manera de acceder r\u00e1pido es poniendo en un buscador de Internet <code>Api  Java  Version Clase</code>, como por ejemplo: Api Java 12 Math.</p>"},{"location":"bloque_i/tema_1/page-9/#la-clase-math","title":"La clase Math","text":"<p>La  clase  Math  contiene  los  m\u00e9todos  para  realizar  operaciones  matem\u00e1ticas  b\u00e1sicas,  como potencias, logaritmos, ra\u00edces cuadradas y funciones trigonom\u00e9tricas.</p> <p>Si observamos esta clase en la API, todos los m\u00e9todos tienen al principio la palabra static, ya que son m\u00e9todos est\u00e1ticos porque son funciones de utilidad que no se utilizan asociadas a un objeto. Despu\u00e9s de la palabra static nos encontramos con el tipo del resultado que devuelve el m\u00e9todo. Y  a  continuaci\u00f3n,  nos  encontramos  con  el  nombre  del  m\u00e9todo  y  sus  par\u00e1metros.  Ejemplo:</p> <p><code>static double abs(double a)</code>Esto se conoce como la firma del m\u00e9todo (signature en ingl\u00e9s).</p> <pre><code>public class MathClass {\npublic static void main(String[] args) {\nSystem.out.println(Math.abs(-3.2));\nSystem.out.println(Math.pow(2,3));\nSystem.out.println(Math.sqrt(16));\nSystem.out.println(Math.min(20,5));\n}\n}\n</code></pre> Ejercicio 1 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Math. Realiza un programa Java donde uses cada uno de esos m\u00e9todos realizando comentarios explicando cada uno de ellos. (Hacer ejemplo con n\u00fameros positivos y negativos)</p> <ol> <li><code>static float abs(float a)</code></li> <li><code>static int addExact(int x, int y)</code></li> <li><code>static double ceil(double a)</code></li> <li><code>static int decrementExact(int a)</code></li> <li><code>static double floor(double a)</code></li> <li><code>static int incrementExact(int a)</code></li> <li><code>static double max(double a, double b)</code></li> <li><code>static int multiplyExact(int x, int y)</code></li> <li><code>static int negateExact(int a)</code></li> </ol> <p>Obs\u00e9rvese en la API la sobrecarga de los m\u00e9todos abs y min.</p>"},{"location":"bloque_i/tema_1/page-9/#la-clase-string","title":"La clase String","text":"<p>El texto es uno de los tipos de datos m\u00e1s importantes y por ello Java lo trata de manera especial. Para Java, las cadenas de texto son objetos especiales. Los textos deben manejarse creando objetos de tipo String. Las cadenas se pueden inicializar de dos maneras:</p> <ul> <li>Usando el operador asignaci\u00f3n: <code>String s=\"hola\";</code></li> <li>Usando el constructor: <code>String s=new String(\"hola\");</code></li> </ul> <p>Los literales cadena se escriben entre comillas dobles: <code>\"Esto es un literal cadena\"</code>.</p> <p>En java existe tambi\u00e9n la cadena vac\u00eda o nula, es decir, una cadena sin ning\u00fan car\u00e1cter. Ejemplo: <code>String s=\"\";</code> A la variable s se le est\u00e1 asignando la cadena vac\u00eda o nula.</p> <p>Como vimos en el tema 1.5 Operadores, el operador concatenaci\u00f3n <code>+</code>  es un operador binario que devuelve una cadena resultado de concatenar las dos cadenas que act\u00faan como operandos. Si s\u00f3lo uno de los operandos es de tipo cadena, el otro operando se convierte impl\u00edcitamente en tipo cadena.</p> <p>Obs\u00e9rvese en la API el m\u00e9todo valueOf: es est\u00e1tico y est\u00e1 sobrecargado. Sirve para obtener la representaci\u00f3n String de un valor u objeto.</p> <pre><code>public class StringClass {\npublic static void main(String[] args) {\nint i = 100;\nString string1, string2, string3, string4;\nstring1 = \"Esto es un literal cadena\"; //(1)!\nSystem.out.println(string1);\nSystem.out.println(string1 + \" al cual le hemos concatenado este literal cadena\"); //(2)!\nstring2 = \"hola\";\nstring3 = \" que tal\";\nstring4 = string2 + string3;\nSystem.out.println(string4);\nSystem.out.println(i + 100); //(3)!\nSystem.out.println(String.valueOf(i) + 100); //(4)!\n}\n}\n</code></pre> <ol> <li>Se le da el valor inicial con el operador asignaci\u00f3n =</li> <li>Se concatena otra cadena con el operador +</li> <li>suma de enteros</li> <li>Concatenaci\u00f3n de cadenas</li> </ol> <p>Otros m\u00e9todos de las cadenas muy \u00fatiles son:</p> <ul> <li>charAt: devuelve el car\u00e1cter de la cadena del especificado \u00edndice. Dicho \u00edndice empieza en cero, es decir, con el cero se obtiene el primer car\u00e1cter de la cadena.</li> <li>length: devuelve la longitud de la cadena.</li> <li>equals: compara si dos cadenas son iguales.</li> </ul> <pre><code>public class StringClass2 {\npublic static void main(String[] args) {\nString string = \"hola\";\nSystem.out.println(string.charAt(0)); //h\nSystem.out.println(string.charAt(1)); //o\nSystem.out.println(string.charAt(2)); //l\nSystem.out.println(string.charAt(3)); //a\nSystem.out.println(string.length()); //4\nSystem.out.println(string.equals(\"hola\")); //true\nSystem.out.println(string.equals(\"hola\")); //false\n}\n}\n</code></pre> Ejercicio 2 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase String. Realiza un programa Java con ejemplos de cada uno de ellos comentando su uso.</p> <ol> <li><code>char charAt(int index)</code></li> <li><code>int length()</code></li> <li><code>boolean equals(Object anObject)</code><ul> <li>Compara dos cadenas</li> <li>Compara tres cadenas</li> </ul> </li> <li><code>int codePointAt(int index)</code></li> <li><code>int compareTo(String anotherString)</code></li> <li><code>int compareToIgnoreCase(String str)</code></li> <li><code>String concat(String str)</code></li> <li><code>boolean endsWith(String suffix)</code></li> <li><code>boolean equalsIgnoreCase(String anotherString)</code></li> <li><code>int indexOf(int ch)</code></li> <li><code>int indexOf(int ch, int fromIndex)</code></li> <li><code>boolean isEmpty()</code></li> <li><code>int lastIndexOf(int ch)</code></li> <li><code>int lastIndexOf(int ch, int fromIndex)</code></li> <li><code>String replace(char oldChar, char newChar)</code></li> <li><code>String toUpperCase()</code></li> <li><code>String trim()</code></li> </ol>"},{"location":"bloque_i/tema_1/page-9/#wrappers","title":"Wrappers","text":"<p>En ocasiones es muy conveniente poder tratar los datos primitivos (int, boolean, etc.) como objetos. Pero los datos primitivos no son objetos. Para resolver esta situaci\u00f3n, la API de Java incorpora las clases envoltorio (wrapper class), que no son m\u00e1s que dotar a los datos primitivos con  un  envoltorio  que  permita  tratarlos  como  objetos.  Las  clases  envoltorio  proporcionan m\u00e9todos de utilidad para la manipulaci\u00f3n de datos primitivos (conversiones de / hacia datos primitivos, conversiones a String, etc).</p> <p>La siguiente tabla muestra los tipos primitivos y sus wrappers asociados:</p> Tipo primitivo Wrapper asociado byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean <p>Todos estos wrappers los encontraremos en la API de Java. Por ejemplo, si observamos en la API la clase Integer, podemos ver la siguiente firma de m\u00e9todo: <code>static int parseInt(String s)</code> que convierte la cadena pasada por par\u00e1metro a entero.</p> <pre><code>public class IntegerClass {\npublic static void main(String[] args) {\nInteger integer1, integer2;\nint i;\ninteger1 = 5;\nSystem.out.println(integer1);\ni = Integer.parseInt(\"7\"); //(1)!\nSystem.out.println(i);\ninteger2 = Integer.valueOf(i); //(2)!\nSystem.out.println(integer2);\ni = integer1.intValue(); //(3)!\nSystem.out.println(i);\n}\n</code></pre> <ol> <li>Convierte la cadena a int. M\u00e9todo est\u00e1tico por lo que se utiliza con Integer</li> <li>Convierte el int a Integer. Tambi\u00e9n es est\u00e1tico</li> <li>Convierte el integer a int. M\u00e9todo din\u00e1mico por lo que se utiliza con el objeto</li> </ol>"},{"location":"bloque_i/tema_1/page-9/#encadenamiento-de-llamadas-a-metodos","title":"Encadenamiento de llamadas a m\u00e9todos","text":"<p>Se emplea cuando invocamos a un m\u00e9todo de un objeto que nos devuelve como resultado otro objeto al que podemos volver a invocar otro m\u00e9todo y as\u00ed encadenar varias operaciones.</p> <pre><code>public class CallsToMethods {\npublic void showCallsToMethods(){\nBoolean b;\nString string;\nstring = \"EntornoDeDesarrollo\";\nSystem.out.println(string.substring(10).toUpperCase()); // DESARROLLO\nb = Boolean.TRUE;\nSystem.out.println(b.toString().charAt(2)); //u\n}\npublic static void main(String[] args) {\nnew CallsToMethods().showCallsToMethods();\n}\n}\n</code></pre> <p>En este ejemplo, el m\u00e9todo <code>substring(10)</code>  est\u00e1 devolviendo una subcadena de la cadena string a partir del car\u00e1cter 10 empezando en 0, es decir, \"Desarrollo\", al que se le invoca luego el m\u00e9todo <code>toUpperCase</code> devolviendo como resultado la cadena \"DESARROLLO\".</p> <p>Y el m\u00e9todo <code>toString()</code> de la variable b de tipo Boolean est\u00e1 devolviendo la cadena \"true\" a la que se le encadena el m\u00e9todo <code>charAt(2)</code>  devolviendo el car\u00e1cter 'u'.</p> Ejercicio 3 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Character. Realiza un programa Java donde realices ejemplos us\u00e1ndolos y comentando su uso.</p> <ol> <li><code>char charValue()</code></li> <li><code>static int compare(char x, char y)</code></li> <li><code>boolean equals(Object obj)</code></li> <li><code>static boolean isDigit(char ch)</code></li> <li><code>static boolean isLetter(char ch)</code></li> <li><code>static boolean isLowerCase(char ch)</code></li> <li><code>static boolean isSpaceChar(char ch)</code></li> <li><code>static boolean isUpperCase(char ch)</code></li> <li><code>static char toLowerCase(char ch)</code></li> <li><code>static char toUpperCase(char ch)</code></li> <li><code>static Character valueOf(char c)</code></li> </ol> Ejercicio 4 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Integer. Realiza un programa Java donde realices ejemplos us\u00e1ndolos y comentando su uso.</p> <ol> <li><code>byte byteValue()</code></li> <li><code>static int compare(int x, int y)</code></li> <li><code>int compareTo(Integer anotherInteger)</code></li> <li><code>double doubleValue()</code></li> <li><code>boolean equals(Object obj)</code></li> <li><code>int intValue()</code></li> <li><code>static int max(int a, int b)</code></li> <li><code>static int min(int a, int b)</code></li> <li><code>static int parseInt(String s)</code></li> <li><code>static int sum(int a, int b)</code></li> <li><code>static Integer valueOf(int i)</code></li> <li><code>static Integer valueOf(String s)</code></li> </ol> Ejercicio 5 <p>Investiga en la API de Java para qu\u00e9 sirven los siguientes m\u00e9todos de la clase Double. Realiza un programa Java donde realices ejemplos us\u00e1ndolos y comentando su uso.</p> <ol> <li><code>static int compare(double d1, double d2)</code></li> <li><code>int compareTo(Double anotherDouble)</code></li> <li><code>double doubleValue()</code></li> <li><code>boolean equals(Object obj)</code></li> <li><code>float floatValue()</code></li> <li><code>int intValue()</code></li> <li><code>boolean isInfinite()</code></li> <li><code>static boolean isInfinite(double v)</code></li> <li><code>boolean isNaN()</code></li> <li><code>static boolean isNaN(double v)</code></li> <li><code>static double max(double a, double b)</code></li> <li><code>static double min(double a, double b)</code></li> <li><code>static double parseDouble(String s)</code></li> <li><code>static double sum(double a, double b)</code></li> <li><code>static Double valueOf(double i)</code></li> <li><code>static Double valueOf(String s)</code></li> </ol> Ejercicio 6 <p>Declara un booleano, un entero, un car\u00e1cter y un decimal, inicial\u00edzalas. Luego, transforma todas las variables a variable cadena. Luego, obtener una cadena resultante de concatenar todas las cadenas obtenidas anteriormente. Muestra esta cadena resultante por pantalla.</p>"},{"location":"bloque_i/tema_2/page-1/","title":"1 Condicionales","text":""},{"location":"bloque_i/tema_2/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Los  programas  se  construyen  para  procesar  datos,  manipul\u00e1ndolos  de  formas diferentes  dependiendo  de  los  valores  que  tengan.  Los  lenguajes  de  programaci\u00f3n deben proveer estructuras que les permitan a los  programadores controlar el flujo de ejecuci\u00f3n  de  un  programa  dependiendo  de  los  datos  que  procesan.  Para  ello,  se incluyen las sentencias de control de flujo, que alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</p> <p>La programaci\u00f3n estructurada es un paradigma de programaci\u00f3n orientado a mejorar la claridad, calidad y tiempo  de  desarrollo  de  un  programa  de  computadora  recurriendo  \u00fanicamente  a subrutinas y tres estructuras b\u00e1sicas: secuencia, sentencias condicionales y bucles.</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo  principal,  el  cual  permite  resolver  una  tarea  espec\u00edfica.  Por  ejemplo,  los m\u00e9todos en Java.</p>"},{"location":"bloque_i/tema_2/page-1/#secuencia","title":"Secuencia","text":"<p>La  ejecuci\u00f3n  secuencial  es  el  m\u00e1s  b\u00e1sico  de  los  mecanismos  de  control  de  flujo  y consiste en la ejecuci\u00f3n de instrucciones en el orden en que se encuentran en el c\u00f3digo fuente del programa.</p> <p>Hasta  ahora  las  instrucciones  que  hemos  visto,  son  instrucciones  que  se  ejecutan secuencialmente; es decir, podemos saber lo que hace el programa leyendo las l\u00edneas de izquierda a derecha y de arriba abajo.</p>"},{"location":"bloque_i/tema_2/page-1/#sentencias-condicionales","title":"Sentencias condicionales","text":"<p>La sentencia condicional consiste en ejecutar instrucciones diferentes dependiendo del resultado de evaluar una expresi\u00f3n l\u00f3gica. Una expresi\u00f3n l\u00f3gica es cualquier tipo de expresi\u00f3n que devuelva un resultado booleano (true o false). Las expresiones l\u00f3gicas se construyen  por  medio  de  variables  booleanas  o  bien  a  trav\u00e9s  de  los  operadores relacionales (==, &gt;, &lt;,...) y/o l\u00f3gicos (&amp;&amp;,||, !).</p>"},{"location":"bloque_i/tema_2/page-1/#condicional-simple","title":"Condicional simple","text":"<p>Se ejecutan una serie de instrucciones en el caso de que la expresi\u00f3n l\u00f3gica sea verdadera:</p> EstructuraEjemplo <pre><code>if(expresi\u00f3nL\u00f3gica){\n// instrucciones\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class If {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint age;\nString name;\nSystem.out.print(\"Introduce tu nombre: \");\nname = keyboard.nextLine();\nSystem.out.print(\"Introduce tu edad: \");\nage = keyboard.nextInt();\nif(age &gt;= 18){\nSystem.out.printf(\"Bienvenido/a %s\\n\", name);\nSystem.out.println(\"Eres mayor de edad\");\n}\n}\n}\n</code></pre> Ejercicio 1 <p>Dada una cantidad, si es mayor que 1000, que muestre el 15% de dicha cantidad. Si no, que no haga nada.</p>"},{"location":"bloque_i/tema_2/page-1/#condicional-doble","title":"Condicional doble","text":"<p>Es igual que la anterior, s\u00f3lo que se a\u00f1ade un apartado else que contiene instrucciones que se ejecutar\u00e1n si la expresi\u00f3n evaluada por el if es falsa.</p> EstructuraEjemplo <pre><code>if(expresi\u00f3nL\u00f3gica){\n// instrucciones si la expresi\u00f3n l\u00f3gica es verdadera\n} else {\n// expresiones si la expresi\u00f3n l\u00f3gica es falsa\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class IfElse {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint age;\nString name;\nSystem.out.print(\"Introduce tu nombre: \");\nname = keyboard.nextLine();\nSystem.out.print(\"Introduce tu edad: \");\nage = keyboard.nextInt();\nSystem.out.printf(\"Bienvenido/a %s\\n\", name);\nif(age &gt;= 18){\nSystem.out.println(\"Eres mayor de edad\");\n} else {\nSystem.out.println(\"Eres menor de edad\");\n}\n}\n}\n</code></pre> Ejercicio 2 <p>Dada una edad, que te muestre por pantalla si es mayor de edad o no.</p> Ejercicio 3 <p>Dado un n\u00famero, indicar si es par o impar.</p> Ejercicio 4 <p>Pedir dos n\u00fameros por teclado e indicar si el primer n\u00famero es m\u00faltiplo del segundo.</p>"},{"location":"bloque_i/tema_2/page-1/#condicional-multiple","title":"Condicional M\u00faltiple","text":""},{"location":"bloque_i/tema_2/page-1/#anidacion","title":"Anidaci\u00f3n","text":"<p>Dentro  de  una  sentencia  if  se  puede  colocar  otra  sentencia  if.  A  esto  se  le  llama anidaci\u00f3n  y  permite  crear  programas  donde  se  valoren  expresiones  complejas.  La nueva sentencia puede ir tanto en la parte if como en la parte else.</p> <p>Las anidaciones se utilizan much\u00edsimo al programar. Solo hay que tener en cuenta que siempre se debe cerrar primero el \u00faltimo if que se abri\u00f3. Es muy importante tambi\u00e9n tabular el c\u00f3digo correctamente para que las anidaciones sean legibles.</p> <p>Ejemplo:</p> <pre><code>if(x == 1){\n// instrucciones\n} else {\nif(x == 2){\n// instrucciones\n} else {\nif(x == 3){\n// instrucciones\n}\n}\n}\n</code></pre> <p>Una forma m\u00e1s legible de escribir ese mismo c\u00f3digo dando lugar a la llamada estructura if-else-if ser\u00eda:</p> <pre><code>if(x == 1){\n// instrucciones\n} else if(x == 2){\n// instrucciones\n} else if(x == 3){\n// instrucciones\n}\n</code></pre> <p>Cuando  se  cumpla  alguna  de  las  condiciones,  se  ejecutan  sus  instrucciones correspondientes y despu\u00e9s ya se sale de la estructura if-else-if ya que las condiciones son autoexcluyentes, es decir, solamente se va a cumplir una. Por eso, no estar\u00eda bien hacer lo siguiente:</p> <pre><code>if(x == 1){ // Forma incorrecta de programar\n// instrucciones\n}\nif(x == 2){\n// instrucciones\n}\nif(x == 3){\n// instrucciones\n}\n</code></pre> <p>El motivo de que no sea adecuado es porque se pierde tiempo en comprobar todas las condiciones. Por ejemplo, si x vale 1, se ejecutan sus instrucciones correspondientes y luego se comprobar\u00eda si x vale 2, si x vale 3, etc. cuando no se va a cumplir ninguna m\u00e1s ya que si x vale 1 no puede valer ni 2 ni 3.</p> <pre><code>import java.util.Scanner;\npublic class IfElseIf {\npublic static void main(String[] args) {         Scanner keyboard = new Scanner(System.in);\nint age;\nSystem.out.print(\"Introduce tu edad: \");\nage = keyboard.nextInt();\nif (age &gt;= 18) {\nSystem.out.println(\"Eres mayor de edad\");\n} else if (age &gt;= 16 &amp;&amp; age &lt; 18) {\nSystem.out.println(\"Eres menor de edad pero tienes ciertos privilegios\");\n} else if (age &gt;= 14 &amp;&amp; age &lt; 16) {\nSystem.out.println(\"Eres menor de edad y adem\u00e1s no tienes privilegios\");\n} else {\nSystem.out.println(\"Eres menor de edad\");\n}     }\n}\n</code></pre> Ejercicio 5 <p>Dada una nota, que te muestre lo siguiente:</p> <ul> <li>0, 1, 2: Muy deficiente</li> <li>3, 4: Insuficiente</li> <li>5: Suficiente</li> <li>6: Bien</li> <li>7, 8: Notable</li> <li>9, 10: Sobresaliente</li> </ul> Ejercicio 6 <p>Hacer un programa que lea por teclado un n\u00famero entero y nos diga si el n\u00famero es positivo, negativo o cero.</p> Ejercicio 7 <p>Realiza un programa que lea tres n\u00fameros positivos y compruebe si son iguales. Por ejemplo: Si la entrada fuese 5 5 5, la salida deber\u00eda ser \u201chay tres n\u00fameros iguales a 5\u201d. Si la entrada fuese 4 6 4, la salida deber\u00eda ser \u201chay dos n\u00fameros iguales a 4\u201d. Si la entrada fuese 0 1 2, la salida deber\u00eda ser \u201cno hay n\u00fameros iguales\u201d.</p>"},{"location":"bloque_i/tema_2/page-1/#switch","title":"Switch","text":"<p>El cuerpo de una sentencia switch se conoce como bloque switch.</p> <p>Esta  sentencia  eval\u00faa  una  expresi\u00f3n  y  cada  case  contiene  un  posible  valor  del resultado  de  dicha  expresi\u00f3n;  si  efectivamente  el  resultado  equivale  a  ese  valor,  se ejecutan las instrucciones de ese case y de los siguientes.</p> <p>La instrucci\u00f3n break se utiliza para salir del switch. De tal modo que si queremos que para un determinado valor se ejecuten las instrucciones de un apartado case y solo las de ese apartado, entonces habr\u00e1 que finalizar ese case con un break. Cuando se alcanza una sentencia break, el switch termina y el flujo de control salta a la siguiente l\u00ednea que sigue a la sentencia switch.</p> <p>Fall through condition (condici\u00f3n de ca\u00edda): esta condici\u00f3n se produce en la sentencia switch cuando no se utiliza  break en un case y causa la ejecuci\u00f3n de los siguientes case hasta que no se produce un break o se sale de la sentencia switch.</p> <p>El  bloque  default  sirve  para  ejecutar  instrucciones  para  los  casos  en  los  que  la expresi\u00f3n no se ajuste a ning\u00fan case. T\u00e9cnicamente, el break del default no es necesario porque el flujo se sale de la sentencia switch, pero se recomienda utilizarlo para que la modificaci\u00f3n del c\u00f3digo sea m\u00e1s f\u00e1cil y menos propensa a errores.</p> <p>Funciona con los tipos de datos primitivos, con los tipos enumerados, con las cadenas(a partir de Java 7) y con los wrappers.</p> EstructuraEjemplo 1Ejemplo 2 <pre><code>switch(expresi\u00f3n) {\ncase valor1 :\ninstrucciones\nbreak; // opcional\ncase valor2 :\ninstrucciones\nbreak; // opcional\n//....\n//....\ndefault : // opcional\ninstrucciones\nbreak; // opcional\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class Switch1 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint weekday;\nSystem.out.print(\"Introduce un n\u00famero del 1 al 7 correspondiente al d\u00eda de la semana: \");\nweekday = keyboard.nextInt();\nswitch (weekday) {\ncase 1:\nSystem.out.println(\"Lunes\");\nbreak;\ncase 2:\nSystem.out.println(\"Martes\");\nbreak;\ncase 3:\nSystem.out.println(\"Mi\u00e9rcoles\");\nbreak;\ncase 4:\nSystem.out.println(\"Jueves\");\nbreak;\ncase 5:\nSystem.out.println(\"Viernes\");\nbreak;\ncase 6:\nSystem.out.println(\"S\u00e1bado\");\nbreak;\ncase 7:\nSystem.out.println(\"Domingo\");\nbreak;\ndefault:\nSystem.out.println(\"D\u00eda incorrecto\");\nbreak;\n}\n}\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class Switch2 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint month, year, numDays = 0;\nSystem.out.print(\"Introduce un n\u00famero del 1 al 12 correspondiente a un mes: \");\nmonth = keyboard.nextInt();\nSystem.out.print(\"Introduce un a\u00f1o: \");\nyear = keyboard.nextInt();\nswitch (month) {\ncase 1:\ncase 3:\ncase 5:\ncase 7:\ncase 8:\ncase 10:\ncase 12:\nnumDays = 31;\nbreak;\ncase 4:\ncase 6:\ncase 9:\ncase 11:\nnumDays = 30;\nbreak;\ncase 2://Se calcula si es un a\u00f1o bisiesto\nif (((year % 4 == 0) &amp;&amp; !(year % 100 == 0)) || (year % 400 == 0)) {\nnumDays = 29;\n} else {\nnumDays = 28;\n}\nbreak;\ndefault:\nSystem.out.println(\"Mes inv\u00e1lido\");\nbreak;\n}\nif (month &gt;= 1 &amp;&amp; month &lt;= 12) {\nSystem.out.printf(\"N\u00famero de d\u00edas del mes %d del a\u00f1o %d: %d\", month, year, numDays);\n}\n}\n}\n</code></pre> <p>La  decisi\u00f3n  de  utilizar  sentencias  if-then-else  o  una  sentencia  switch  se  basa  en  la legibilidad y en la expresi\u00f3n que la sentencia est\u00e1 probando. Una sentencia if-then-else puede comprobar expresiones basadas en rangos de valores o condiciones, mientras que una sentencia switch comprueba expresiones basadas s\u00f3lo en un \u00fanico valor.</p> Ejercicio 8 <p>Realiza el ejercicio 4, haciendo uso de la estructura Switch.</p>"},{"location":"bloque_i/tema_2/page-1/#nuevo-switch","title":"Nuevo Switch","text":"<p>Desde la versi\u00f3n de Java 14, hay una nueva estructura de la sentencia switch, que la hace m\u00e1s \"elegante\" pero sobretodo legible.</p> EstructuraEjemplo 1Ejemplo 2 <pre><code>switch(expresi\u00f3n){\ncase valor1 -&gt; /* instrucci\u00f3n de una l\u00ednea*/;\ncase valor2 -&gt; {\n// instrucciones de m\u00e1s de una l\u00ednea\n}\n// ...\ndefault -&gt; /* instrucci\u00f3n de una l\u00ednea */;\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class NewSwitch1 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint weekday;\nSystem.out.print(\"Introduce un n\u00famero del 1 al 7 correspondiente al d\u00eda de la semana: \");\nweekday = keyboard.nextInt();\nswitch (weekday) {\ncase 1 -&gt; System.out.println(\"Lunes\");\ncase 2 -&gt; System.out.println(\"Martes\");\ncase 3 -&gt; System.out.println(\"Mi\u00e9rcoles\");\ncase 4 -&gt; System.out.println(\"Jueves\");\ncase 5 -&gt; System.out.println(\"Viernes\");\ncase 6 -&gt; System.out.println(\"S\u00e1bado\");\ncase 7 -&gt; System.out.println(\"Domingo\");\ndefault -&gt; System.out.println(\"D\u00eda incorrecto\");\n}\n}\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class NewSwitch2 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint month, year, numDays = 0;\nSystem.out.print(\"Introduce un n\u00famero del 1 al 12 correspondiente a un mes: \");\nmonth = keyboard.nextInt();\nSystem.out.print(\"Introduce un a\u00f1o: \");\nyear = keyboard.nextInt();\nswitch (month) {\ncase 1, 3, 5, 7, 8, 10, 12 -&gt; numDays = 31;\ncase 4, 6, 9, 11 -&gt; numDays = 30;\ncase 2 -&gt; {\n//Se calcula si es un a\u00f1o bisiesto\nif (((year % 4 == 0) &amp;&amp; !(year % 100 == 0)) || (year % 400 == 0)) {\nnumDays = 29;\n} else {\nnumDays = 28;\n}\n}\ndefault -&gt; System.out.println(\"Mes inv\u00e1lido\");\n}\nif (month &gt;= 1 &amp;&amp; month &lt;= 12) {\nSystem.out.printf(\"N\u00famero de d\u00edas del mes %d del a\u00f1o %d: %d\", month, year, numDays);\n}\n}\n}\n</code></pre> Ejercicio 9 <p>Realiza el ejercicio 4, haciendo uso de la nueva estructura Switch</p>"},{"location":"bloque_i/tema_2/page-1/#ejercicios","title":"Ejercicios","text":"Ejercicio 10 <p>Realiza un programa que calcule el precio de un billete de ida y vuelta por avi\u00f3n, conociendo la distancia a recorrer, el n\u00famero de d\u00edas de estancia y sabiendo que si la distancia es superior a 1.000 Km y el n\u00famero de d\u00edas de estancia es superior a 7, la l\u00ednea a\u00e9rea le hace un descuento del 30 %. (Precio por kil\u00f3metro = 0,35 \u20ac).</p> Ejercicio 11 <p>Los empleados de una f\u00e1brica trabajan en dos turnos: diurno y nocturno. Se desea calcular el jornal diario de acuerdo con los siguientes tarifas: la tarifa de las horas diurnas es de 3 \u20ac por hora, mientras que el de las nocturnas es de 4,80 \u20ac po hora. Cuando se trata de un d\u00eda festivo, la tarifa se incrementa en 1,20 \u20ac por hora en el turno diurno y 1,80 \u20ac por hora en el nocturno.</p> Ejercicio 12 <p>Realiza un programa que dados tres n\u00fameros, los devuelva en orden ascendente.</p> Ejercicio 13 <p>Dada una cadena solicitada al usuario, obtener y mostrar uno de sus caracteres elegidos aleatoriamente. Mostrar tambi\u00e9n en qu\u00e9 posici\u00f3n se encuentra dicho car\u00e1cter.</p> Ejercicio 14 <p>Realiza un programa que saque una carta aleatoria de una baraja con 4 palos y 13 cartas por cada palo. Los palos son Picas \u2660, Corazones \u2665, Diamantes \u2666 y Tr\u00e9boles \u2663. Las 13 cartas por cada palo ir\u00e1n del as al diez y adem\u00e1s tres figuras: jota, reina y rey. Mostrar la carta incluyendo el s\u00edmbolo del palo(\u2660,\u2665,\u2666,\u2663).</p>"},{"location":"bloque_i/tema_2/page-2/","title":"2 Bucles","text":""},{"location":"bloque_i/tema_2/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>En programaci\u00f3n, un bucle o instrucci\u00f3n de control repetitiva (o iterativa)  permite  ejecutar  una  o m\u00e1s  instrucciones  varias  veces,  es  decir,  permite  ejecutar  un  bloque  de  instrucciones repetidamente, escribi\u00e9ndolas una sola vez en el programa, reduciendo de este modo el c\u00f3digo del mismo. Cada vuelta que da el bucle se conoce como iteraci\u00f3n.</p> <p>Las variables que se utilizan en los bucles pueden tener distintas funciones:</p> <ul> <li>\u00edndice: es una variable que apunta a un recurso concreto. En los bucles, apunta al n\u00famero de iteraci\u00f3n. Se suelen utilizar por convenio los identificadores de variables i, j y k.</li> <li>contador: cuenta cu\u00e1ntas veces ocurre algo.</li> <li>acumulador: acumula operaciones parciales.</li> </ul> <p>Las instrucciones b\u00e1sicas que permiten construir este tipo de estructuras son while, do-while y for.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-while","title":"Bucle while","text":"<p>El bucle while agrupa instrucciones las cuales se ejecutan continuamente mientras una condici\u00f3n que se eval\u00faa sea verdadera. La condici\u00f3n se eval\u00faa antes de entrar dentro del while y cada vez que se termina de ejecutar las instrucciones del while.</p> <p>El programa se ejecuta siguiendo estos pasos:</p> <ol> <li>Se eval\u00faa la expresi\u00f3n l\u00f3gica.</li> <li>Si  la  expresi\u00f3n  es  verdadera  ejecuta  las  instrucciones,  sino  el  programa  abandona  la sentencia while.</li> <li>Tras ejecutar las instrucciones, volvemos al paso 1.</li> </ol> EstructuraEjemplo <pre><code>while(expresi\u00f3nL\u00f3gica){\n//instrucciones\n}\n</code></pre> <pre><code>import java.util.Random;\npublic class While1 {\npublic static void main(String[] args) {\nint number;\nRandom random = new Random();\n/*\n         * Se obtiene un n\u00famero aleatorio entre 1 y 500.\n         * Mientras dicho n\u00famero sea par, continuamos en el bucle while\n         */\nwhile ((number = random.nextInt(500)+1) % 2 == 0){\nSystem.out.println(number);\n}\n}\n}\n</code></pre> Ejercicio 1 <p>Dados dos n\u00fameros n1 y n2, tal que n1 &lt;= n2, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle while.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-do-while","title":"Bucle do-while","text":"<p>La \u00fanica diferencia respecto al while est\u00e1 en que la expresi\u00f3n l\u00f3gica se eval\u00faa despu\u00e9s de haber ejecutado  las  instrucciones.  Es  decir,  el  bucle  al  menos  se  ejecuta  una  vez.  Los  pasos  son  los siguientes:</p> <ol> <li>Ejecutar instrucciones.</li> <li>Evaluar expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera, volver al paso 1. Si es falsa, salir del do-while.</li> </ol> <p>Ejemplo que muestra n\u00fameros aleatorios entre 1 y 500 hasta que salga uno m\u00faltiplo de 7:</p> EstructuraEjemploEjemplo 2Ejemplo 3Ejemplo 4 <pre><code>do{\n// instrucciones\n} while(expresi\u00f3nL\u00f3gica)\n</code></pre> <pre><code>import java.util.Random;\npublic class DoWhile1 {\npublic static void main(String[] args) {\nboolean exit = false;\nint number;\nRandom random = new Random();\ndo{\nnumber = random.nextInt(500) + 1; //(1)!\nSystem.out.println(number);\nexit = (number % 7 == 0); //(2)!\n} while (!exit); //(3)!\n}\n}\n</code></pre> <ol> <li>Se calcula un n\u00famero aleatorio entre 1 y 500</li> <li>exit se pone a true si el n\u00famero es m\u00faltiplo de 7</li> <li>Condici\u00f3n de repetici\u00f3n: que exit sea false</li> </ol> <p>Si le a\u00f1adimos al ejemplo anterior que solamente haya 5 posibilidades para encontrar el m\u00faltiplo de 7, eso significa que necesitamos una variable que apunte al n\u00famero de iteraci\u00f3n del bucle para poder controlar que solamente se ejecute 5 veces, es decir, necesitamos un \u00edndice:</p> <pre><code>import java.util.Random;\npublic class DoWhile2 {\npublic static void main(String[] args) {\nboolean exit = false;\nint number, i = 1; //(1)!\nRandom random = new Random();\ndo{\nnumber = random.nextInt(500) + 1;\nSystem.out.println(number);\nexit = (number % 7 == 0);\ni++;\n} while (!exit &amp;&amp; i &lt;= 5); //(2)!\nif(!exit){\nSystem.out.println(\"No se encontr\u00f3 el m\u00faltiplo de 7\");\n}\n}\n}\n</code></pre> <ol> <li>i es un \u00edndice porque apunta al n\u00famero de iteraci\u00f3n del bucle</li> <li>Mientras exit sea false y adem\u00e1s i sea menor o igual que 5</li> </ol> <p>El  bucle  do-while  se  utiliza  cuando  se  sabe  que  las  instrucciones  del  bucle  se  van  a  ejecutar  al menos  una  vez.  En  el  bucle  while  puede  ser  que  no  se  ejecuten  nunca  si  la  condici\u00f3n  es  falsa desde un principio. Las peticiones de usuario se realizan con bucles do-while, ya que la petici\u00f3n del  dato  al  usuario  siempre  se  realiza,  y  si  el  usuario  no  introduce  lo  que  le  hemos  pedido, entonces utilizamos el bucle para volv\u00e9rselo a pedir.</p> <pre><code>import java.util.Scanner;\npublic class DoWhile3 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint number;\ndo{\nSystem.out.print(\"Introduzca un n\u00famero del 1 al 5: \");\nnumber = keyboard.nextInt();\nSystem.out.printf(\"Has introducido un %d\\n\", number);\n}while (number &lt; 1 || number &gt; 5);\n}\n}\n</code></pre> <pre><code>import java.util.Scanner;\npublic class DoWhile4 {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint number, counter = 0, sum = 0, index = 0;\n/*\n         * index: es un \u00edndice porque apunta al n\u00famero de iteraci\u00f3n del bucle\n         * counter: es un contador para contar el n\u00famero de pares\n         * sum: es un acumulador donde se acumula la suma de los n\u00fameros pares\n         */\ndo{\nSystem.out.print(\"Introduzca un n\u00famero \u00f3 0 para terminar: \");\nnumber = keyboard.nextInt();\nif(number != 0){\nindex++; // Se incrementa el n\u00famero de iteraciones del bucle\nSystem.out.printf(\"El n\u00famero introducido en la iteraci\u00f3n %d es %d\\n\", index, number);\nif(number % 2 == 0){ // si el n\u00famero es par\ncounter++; // Se incrementa el contador\nsum += number; // Se acumula la suma en el acumulador\n}\n}\n}while (number != 0);\nSystem.out.printf(\"En %d iteraciones se han introducido %d n\u00fameros pares cuya suma vale %d\", index, counter, sum);\n}\n}\n</code></pre> Ejercicio 2 <p>Dados dos n\u00fameros n1 y n2, tal que n1 &lt;= n2, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle do-while.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-for","title":"Bucle for","text":"<p>El funcionamiento es el siguiente:</p> <ol> <li>Se ejecuta la instrucci\u00f3n de inicializaci\u00f3n.</li> <li>Se comprueba la condici\u00f3n.</li> <li>Si la condici\u00f3n es cierta, entonces se ejecutan las instrucciones. Si la condici\u00f3n es falsa, se abandona el bloque for.</li> <li>Tras ejecutar las instrucciones, se ejecuta la instrucci\u00f3n de incremento y se vuelve al paso</li> </ol> EstructuraEjemploEjemplo con While <pre><code>for(inicializaci\u00f3n;condici\u00f3n;incremento){\n// instrucciones\n}\n</code></pre> <p>Escribir n\u00fameros del 1 al 100:</p> <pre><code>public class For1 {\npublic static void main(String[] args) {\nint i;\nfor (i = 1; i &lt;= 100; i ++){ //(1)!\nSystem.out.println(i);\n}\n}\n}\n</code></pre> <ol> <li>i es un \u00edndice porque apunta al n\u00famero de iteraci\u00f3n del bucle</li> </ol> <p>Los bucles for tambi\u00e9n se pueden hacer con while o do-while pero los for tienen una sintaxis m\u00e1s abreviada. Veamos el ejemplo For1 hecho con un while:</p> <pre><code>public class While2 {\npublic static void main(String[] args) {\nint i = 1;\nwhile (i &lt;= 100){\nSystem.out.println(i);\ni++;\n}\n}\n}\n</code></pre> <p>Todos los bucles se pueden hacer con for, while y do-while, entonces, \u00bfcu\u00e1l se debe usar? Es importante que le programador utilice la estructura m\u00e1s adecuada en cada caso:</p> <ul> <li> <p>Un bucle for se utiliza cuando se conozca el n\u00famero de veces que se va a ejecutar el bucle, es decir, cuando se conozcan el n\u00famero de iteraciones de antemano.</p> </li> <li> <p>Si no se sabe de antemano el n\u00famero de iteraciones, entonces hay que utilizar while o do-while</p> <ul> <li>Un bucle do-while se utiliza cuando las instrucciones del bucle se van a ejecutar al menos una vez.</li> <li>Un bucle while se utiliza, entonces, cuando las instrucciones del bucle pueden no ejecutarse nunca si la condici\u00f3n es falsa desde un principio.</li> </ul> </li> </ul> <p>Tambi\u00e9n es posible declarar la variable dentro del propio bucle for, pero su \u00e1mbito de vida se reduce exclusivamente al bucle for, es decir, no se conoce fuera del for ya que muere en cuando el bucle se finalice.</p> <pre><code>public class For2 {\npublic static void main(String[] args) {\nfor (int i = 1; i &lt;= 100; i++) { //(1)!\nSystem.out.println(i);\n}\ni = 1; //(2)!\n}\n}\n</code></pre> <ol> <li>Se declara la variable i como int dentro del for</li> <li> Error de compilaci\u00f3n: <code>i cannot be resolved to a variable</code></li> </ol> <p>El bucle for tambi\u00e9n admite m\u00e1s de una variable, en cuyo caso, en las partes de inicializaci\u00f3n e incremento, se utiliza como separador la coma <code>,</code>:</p> <pre><code>public class For3 {\npublic static void main(String[] args) {\nfor(int i = 0, j = 10; i &lt;= j; i++, j--){\nSystem.out.printf(\"i: %d j: %d\\n\", i, j);\n}\n}\n}\n</code></pre> <p>CUIDADO</p> <p>En los IDEs, se puede seleccionar variables l\u00edneas de c\u00f3digos y se puede insertar f\u00e1cilmente en un if o en un bucle.</p> <p>Por motivos de legibilidad de c\u00f3digo, es muy importante que las variables del for aparezcan en las  3  partes  del  for,  es  decir,  en  la  inicializaci\u00f3n,  en  la  condici\u00f3n  y  en  el  incremento,  ya  que  el programador  que  quiera  saber  cu\u00e1ntas  iteraciones  realiza  el  bucle,  solamente  con  fijarse  en  la l\u00ednea de c\u00f3digo donde se encuentra el for, pueda saberlo. Si las variables del for no aparecen en las 3 partes, eso nos indica que es m\u00e1s conveniente realizar un while o un do-while.</p> <p>Veamos el ejemplo que muestra n\u00fameros aleatorios entre 1 y 500 hasta que salga uno m\u00faltiplo de 7:</p> <pre><code>import java.util.Random;\npublic class For4 {\npublic static void main(String[] args) {\nboolean exit = false;\nint number = 0, i;\nRandom random = new Random();\nfor(i = 1; !exit; i++){ // Este for no es legible, se debe sustituir por un do-while\nnumber = random.nextInt(500)+1;\nSystem.out.printf(\"Iteraci\u00f3n %d, n\u00famero: %d\\n\", i, number);\nexit = (number % 7 == 0);\n}\nSystem.out.printf(\"El m\u00faltiplo de 7 con valor %d se ha encontrado en la iteraci\u00f3n %d\", number, i - 1);\n}\n}\n</code></pre> <p>Si le a\u00f1adimos al ejemplo anterior que solamente haya 5 posibilidades para encontrar el m\u00faltiplo de 7:</p> <pre><code>import java.util.Random;\npublic class For5 {\npublic static void main(String[] args) {\nboolean exit = false;\nint number = 0, i;\nRandom random = new Random();\n/*\n         * Ahora el for s\u00ed es legible porque la variable i aparece en las 3 partes:\n         * en la inicializaci\u00f3n, en la condici\u00f3n y en el incremento\n         */\nfor(i = 1; i &lt;= 5 &amp;&amp; !exit; i++){\nnumber = random.nextInt(500) + 1;\nSystem.out.printf(\"Iteraci\u00f3n: %d, n\u00famero: %d\\n\", i, number);\nexit = (number % 7 == 0);\n}\nif(exit){\nSystem.out.printf(\"El m\u00faltiplo de 7 con valor de %d se ha encontrado en la iteraci\u00f3n %d\", number, i - 1);\n} else {\nSystem.out.println(\"El m\u00faltiplo de 7 no se ha encontrado\");\n}\n}\n}\n</code></pre> <p>Tambi\u00e9n  es  muy  importante  por  motivos  de  legibilidad  del  c\u00f3digo,  que  el  \u00fanico  sitio  donde  se modifiquen  los  valores  de  las  variables  del  for  sea  en  la  zona  del  incremento  ya  que  el programador que quiera saber cu\u00e1ntas iteraciones realiza el bucle, solamente con ver la l\u00ednea de c\u00f3digo del for, pueda saberlo. Por ejemplo, este c\u00f3digo no es adecuado ya que para salirse del bucle del for, se est\u00e1 modificando la variable i.</p> <pre><code>import java.util.Random;\npublic class For6 {\npublic static void main(String[] args) {\nint number = 0, i;\nRandom random = new Random();\nfor(i = 1; i &lt; = 5; i++){\nnumber = random.nextInt(500) + 1;\nSystem.out.printf(\"Iteraci\u00f3n %d, n\u00famero: %d\\n\", i, number);\nif(number % 7 == 0){\ni = 5; // No se pueden modificar las variables del for, solamente en el incremento\n}\n}\nif(number % 7 == 0){\nSystem.out.printf(\"El m\u00faltiplo de 7 encontrado vale %d\", number);\n} else {\nSystem.out.println(\"El m\u00faltiplo de 7 no se ha encontrado\");\n}\n}\n}\n</code></pre> Ejercicio 3 <p>Dados dos n\u00fameros n1 y n2, tal que n1 &lt;= n2, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle for.</p>"},{"location":"bloque_i/tema_2/page-2/#bucle-for-each","title":"Bucle for-each","text":"<p>Una de las cosas que incorpor\u00f3 Java 5 fue el bucle for-each. Esta estructura nos permite recorrer una colecci\u00f3n o un array de elementos de una forma sencilla, evitando el uso de iteradores o de un bucle for normal.</p> <p>Tambi\u00e9n se usa el for-each para recorrer los valores de un enum. Para ello, se utiliza el m\u00e9todo values() de los enum que est\u00e1 impl\u00edcitamente declarado por el compilador:</p> EstructuraEjemplo <pre><code>for(TipoVariable variable : values){\n//instrucciones\n}\n</code></pre> <pre><code>public class ForEachEnum {\npublic enum DayOfWeek{\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\npublic static void main(String[] args) {\nfor (DayOfWeek d : DayOfWeek.values()) {\nSystem.out.println(d);\n}\n}\n}\n</code></pre> Ejercicio 4 <p>Crea un enum con los meses del a\u00f1o, y haciendo uso de un bucle for-each, muestra aquellos meses de verano.</p>"},{"location":"bloque_i/tema_2/page-2/#ejercicios","title":"Ejercicios","text":"Ejercicio 5 <p>Haz un programa para simular 20 lanzamientos de un dado.</p> Ejercicio 6 <p>Genera 15 n\u00fameros aleatorios entre el rango de dos n\u00fameros solicitados al usuario.</p> Ejercicio 7 <p>Dados dos n\u00fameros enteros positivos, calcula su producto utilizando solo sumas.</p> Ejercicio 8 <p>Solic\u00edtale al usuario un n\u00famero entre 0 y 10 ambos incluidos:</p> <ul> <li>Si el usuario introduce un n\u00famero que no est\u00e9 dentro de ese rango, vuelve a ped\u00edrselo tantas veces como sea necesario, ese decir, hasta que introduzca un n\u00famero entre 0 y 10.</li> <li>Una vez obtenido el n\u00famero dentro de ese rango, muestra la tabla de multiplicar de dicho n\u00famero.</li> </ul> Ejercicio 9 <p>Realiza un programa que solicite al usuario un n\u00famero entero positivo n y dibuje un tri\u00e1ngulo de asteriscos. El tri\u00e1ngulo debe contener un asterisco en la primera l\u00ednea, dos en la segunda, etc.; es decir, en la fila en\u00e9sima deben aparecer n asteriscos. Ejemplo para n=5.</p> <pre><code>    *\n* *\n* * *\n* * * *\n* * * * *\n</code></pre> Ejercicio 10 <p>Realiza un programa que solicite al usuario un n\u00famero entero positivo n y dibuje un rombo de asteriscos. Por ejemplo, si n = 5 deber\u00eda dibujarse:</p> <pre><code>    *\n* *\n* * *\n* * * *\n* * * * *\n* * * *\n* * *\n* *\n*\n</code></pre> Ejercicio 11 <p>Realiza un programa que dibuje el tri\u00e1ngulo hasta un valor dado. El tri\u00e1ngulo contiene los n\u00fameros naturales correlativos, uno en la primera l\u00ednea, dos en la segunda, etc,; es decir, en la fila en\u00e9sima aparecen n valores. Ejemplo para n=5</p> <pre><code>        1\n1   2\n1   2   3\n1   2   3   4\n1   2   3   4   5\n</code></pre> Ejercicio 12 <p>Realiza un programa que dibuje una pir\u00e1mide de d\u00edgitos como la de la figura, pidiendo por teclado el n\u00famero de filas de la misma. Ejemplo para n = 5:</p> <pre><code>            1\n1  2  1\n1  2  3  2  1\n1  2  3  4  3  2  1\n1  2  3  4  5  4  3  2  1\n</code></pre> Ejercicio 13 <p>Crea un programa que dibuje un table de ajedrez.</p> Ejercicio 14 <p>Solic\u00edtale al usuario una casilla de un tablero de ajedrez. Dibuja el tablero de ajedrez con el alfil colocado en dicha casilla y marca con un color diferente en el tablero las casillas a las que puede mover dicho alfil.</p> Ejercicio 15 <p>Realiza un dibujo de una estrella de 6 puntas. Solic\u00edtale al usuario:</p> <ul> <li>La altura de las puntas, como m\u00ednimo 2.</li> <li>El color de la estrella: rojo o verde.</li> </ul> <p> Figura 1 - Salida del ejercicio 15 </p> Ejercicio 16 <p>Realiza un dibujo de un c\u00edrculo rojo con fondo amarillo. Solic\u00edtale al usuario el n\u00famero de l\u00edneas. </p> <p>Ejemplo con 13 l\u00edneas</p> <p> Figura 2 - Salida del ejercicio 16 </p> <p>Ejemplo con 21 l\u00edneas:</p> <p> Figura 3 - Salida del ejercicio 16 </p>"},{"location":"bloque_i/tema_2/page-3/","title":"3 Funciones","text":""},{"location":"bloque_i/tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ol> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ol> <p>Dichas  funciones  se  pueden  utilizar  desde  muchos  sitios  diferentes,  por  lo  que  de  manera general, no se suelen poner mensajes en consola en las funciones ya que puede ser que dichos mensajes no interesen en todos los sitios donde se utilice dicha funci\u00f3n. A no ser que la funci\u00f3n se haya creado espec\u00edficamente para dar mensajes informativos en consola.</p>"},{"location":"bloque_i/tema_2/page-3/#construccion","title":"Construcci\u00f3n","text":"<p>Una funci\u00f3n se construye de la siguiente manera:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro nombre_par\u00e1metro, ...){\n// instrucciones\nreturn expresi\u00f3n;\n}\n</code></pre> <ul> <li>modificador_acceso: es la visibilidad que posee la funci\u00f3n (Lo veremos m\u00e1s adelante. De momento, lo utilizaremos como public).</li> <li>tipo_resultado: es el tipo del resultado que devuelve la funci\u00f3n.</li> <li>nombre_funci\u00f3n:  es  el  nombre  que  identifica  a  la  funci\u00f3n.  Utiliza  la  notaci\u00f3n lowerCamelCase. Ejemplo: imprimirResultadoDecimal.</li> <li>tipo_par\u00e1metro  nombre_par\u00e1metro,  ...:  puede  ocurrir  que  la  funci\u00f3n  necesite  ciertos valores para efectuar la misi\u00f3n para la que ha sido creada. Por ejemplo, la funci\u00f3n suma necesitar\u00eda los valores que tiene que sumar. En este caso, se deben indicar cada uno de dichos  valores  con  sus  tipos  correspondientes.  A  estos  valores  se  les  conoce  como par\u00e1metros de la funci\u00f3n. Si la funci\u00f3n no necesita par\u00e1metros, entonces solamente se ponen los par\u00e9ntesis: <code>nombre_funci\u00f3n( )</code>.</li> </ul> <p>A todo esto se le conoce como firma (signature) de la funci\u00f3n:</p> <pre><code>modificador_acceso tipo_resultado nombre_funci\u00f3n (tipo_par\u00e1metro nombre_par\u00e1metro, ...)\n</code></pre> <ul> <li>instrucciones: instrucciones que conforman el algoritmo de la funci\u00f3n, para que realice la misi\u00f3n para la que ha sido creada.</li> <li>return expresi\u00f3n: con el return se termina la ejecuci\u00f3n de la funci\u00f3n y si va acompa\u00f1ado de una expresi\u00f3n, la funci\u00f3n devuelve como resultado el valor de dicha expresi\u00f3n. Dicho valor tiene que ser del tipo_resultado indicado en la firma de la funci\u00f3n.</li> </ul> <p>Ejemplo de la funci\u00f3n con dos par\u00e1metros:</p> <pre><code>public static int add(int sum1, int sum2){\nreturn sum1 + sum2;\n}\n</code></pre> <p>Puede ser tambi\u00e9n que haya m\u00e1s de un return. En ese caso, el flujo de ejecuci\u00f3n abandona la funci\u00f3n en cuanto ejecute el primer return. Ejemplo:</p> <pre><code>public static boolean isPair(int n){\nif(n % 2 == 0){\nreturn true;\n} else {\nreturn false;\n}\n}\n</code></pre> <p>En el caso de que estemos definiendo un procedimiento, no tendremos <code>return expresi\u00f3n</code> ya que no devuelve ning\u00fan resultado y el tipo_resultado es void. Como por ejemplo <code>System.put.println</code>, que escribe en pantalla lo que recibe por par\u00e1metro pero no devuelve nada.</p>"},{"location":"bloque_i/tema_2/page-3/#llamada-a-la-funcion","title":"Llamada a la funci\u00f3n","text":"<p>Una funci\u00f3n permite que reutilicemos un algoritmo ya que se puede utilizar cuando nos haga falta.  Para  ello,  solamente  tendremos  que  llamar  a  la  funci\u00f3n  por  su  nombre  y  pasarle  los par\u00e1metros en el mismo orden que se han definido y pertenecientes al mismo tipo de dato o compatible. En la llamada, dichos par\u00e1metros se llaman argumentos, es decir, los argumentos son los valores iniciales de los par\u00e1metros.</p> <pre><code>public class Functions1 {\npublic static void main(String[] args) {\nboolean pair;\nint result;\n/*\n         * Se llama a la funci\u00f3n isPair con un valor de 5 en el argumento, es decir,\n         * el valor inicial del par\u00e1metro n es 5:\n         */\npair = isPair(5);\nSystem.out.println(pair); // false\n/*\n         * Se lla a la funci\u00f3n isPair con un valor de 4 en el argumento, es decir,\n         * ahora el valor inicial del par\u00e1metro n es 4.\n         */\npair = isPair(4);\nSystem.out.println(pair); // true\n/*\n         * Se llama a la funci\u00f3n add con los valores 5 y 2 en los argumentos, es decir,\n         * los valores iniciales de los par\u00e1metros sum1 y sum2 son 5 y 2 respectivamente.\n         */\nresult = add(5,2);\nSystem.out.println(result); // 7\n}\npublic static int add(int sum1, int sum2){\nreturn sum1 + sum2;\n}\npublic static boolean isPair(int n){\nif(n % 2 == 0){\nreturn true;\n} else {\nreturn false;\n}\n}\n}\n</code></pre> Ejercicio 1 <p>Realiza una funci\u00f3n que reciba la base y el exponente y devuelva la potencia baseexponente sin utilizar Math.pow</p>"},{"location":"bloque_i/tema_2/page-3/#ambito-de-vida-de-los-parametros","title":"\u00c1mbito de vida de los par\u00e1metros","text":"<p>A nivel de visibilidad y de \u00e1mbito de vida, los par\u00e1metros funcionan como las variables locales (Ver tema 1.3 Variables y constantes 4. \u00c1mbito de vida de las variables), por lo tanto el \u00e1mbito de vida de los par\u00e1metros es el bloque donde han sido definidos, es decir, la propia funci\u00f3n. Cada vez  que  se  llame  a  la  funci\u00f3n,  los  par\u00e1metros  nacen,  se  ejecuta  la  funci\u00f3n  y  una  vez  que  la funci\u00f3n ha terminado de ejecutarse, los par\u00e1metros mueren.</p> <pre><code>public class Functions2 {\npublic static void main(String[] args) {\nboolean pair;\nint result;\npair = isPair(5); //(1)!\n//(2)!\nSystem.out.println(pair);\npair = isPair(4); //(3)!\n//(4)!\nSystem.out.println(pair);\nresult = add(5, 2); //(5)!\n//(6)!\nSystem.out.println(result);\n}\npublic static int add(int sum1, int sum2){ //(7)!\nreturn sum1 + sum2;\n} //(8)!\npublic static boolean isPair(int n){ //(9)!\nif(n % 2 == 0){\nreturn true;\n} else {\nreturn false;\n}\n} //(10)!\n}\n</code></pre> <ol> <li>Nace el par\u00e1metro n con el valor 5</li> <li>Aqu\u00ed n ya no existe porque la funci\u00f3n isPair ya ha terminado de ejecutarse</li> <li>Vuelve a nacer n pero esta vez con un valor de 4</li> <li>Aqu\u00ed n ya no existe porque la funci\u00f3n isPair ya ha terminado de ejecutarse</li> <li>Nacen los par\u00e1metros sum1 y sum2 con los valores 5 y 2 respectivamente</li> <li>Aqu\u00ed sum1 y sum2 ya no existen porque la funci\u00f3n add ha terminado de ejecutarse</li> <li>Comienzo del \u00e1mbito de vida de los par\u00e1metros sum1 y sum2</li> <li>Fin del \u00e1mbito de vida de los par\u00e1metros sum1 y sum2</li> <li>Comienzo del \u00e1mbito de vida del par\u00e1metro n</li> <li>Fin del \u00e1mbito de vida del par\u00e1metro n</li> </ol> Ejercicio 2 <p>Realiza una funci\u00f3n que reciba 3 par\u00e1metros: dos de tipo entero y uno de tipo car\u00e1cter. La funci\u00f3n deber\u00e1 sumar, restar, multiplicar o dividir los valores de los dos primeros par\u00e1metros dependiendo de la operaci\u00f3n indicada en el tercer par\u00e1metro, y devolver el resultado</p> Ejercicio 3 <p>Sobrecarga la funci\u00f3n del ejercicio anterior para que se pueda operar con enteros y con decimales. Haz un programa que utilice las dos funciones, con enteros y con decimales</p>"},{"location":"bloque_i/tema_2/page-3/#ejemplo-de-funcion-el-factorial-de-un-numero","title":"Ejemplo de funci\u00f3n: el factorial de un n\u00famero","text":"<p>El factorial de un entero positivo n, tambi\u00e9n indicado como n!, se define como el producto de todos los n\u00fameros enteros positivos desde 1 hasta n. Por ejemplo:</p> <p>5! = 1 x 2 x 3 x 4 x 5 = 120</p> <p>La  operaci\u00f3n  de  factorial  aparece  en  muchas  \u00e1reas  de  las  matem\u00e1ticas,  particularmente  en combinatoria  y  an\u00e1lisis  matem\u00e1tico.  De  manera  fundamental,  el  factorial  de  n  representa  el n\u00famero de formas distintas de ordenar n objetos distintos (elementos sin repetici\u00f3n). Este hecho ha sido conocido desde hace varios siglos, en el siglo XII, por los hind\u00faes.</p> <p>Veamos  c\u00f3mo  se  programar\u00eda  dicha  funci\u00f3n  factorial  y  las  llamadas  con  distintos  tipos  de argumentos:</p> <pre><code>import java.util.Scanner;\npublic class Factorial {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint n, variable;\nSystem.out.println(\"Llamada a la funci\u00f3n con argumentos literales: \");\nSystem.out.printf(\"El factorial de 5 es %d\\n\", factorial(5));\nSystem.out.println(\"Llamada a la funci\u00f3n usando una variable como argumento: \");\nvariable = 5;\nSystem.out.printf(\"El factorial de %d es %d\\n\", variable, factorial(variable));\nSystem.out.println(\"Llamada a la funci\u00f3n usando una expresi\u00f3n como argumento: \");\nvariable = 3;\nSystem.out.printf(\"El factorial de %d es %d\\n\", variable + 2, factorial(variable + 2));\nSystem.out.println(\"Llamada a la funci\u00f3n con argumentos introducidos por el usuario: \");\ndo {\nSystem.out.println(\"Introduzca un n\u00famero entero positivo: \");\nn = keyboard.nextInt();\n} while (n &lt;= 0);\nSystem.out.printf(\"El factorial de %d es %d\", n, factorial(n));\n}\npublic static int factorial(int n) {\nint result = 1;\nfor (int i = 2; i &lt;= n; i++) {\nresult *= i;\n}\nreturn result;\n}\n}\n</code></pre> <p>El concepto del factorial se aplica a los n\u00fameros enteros positivos, pero como los int admiten n\u00fameros  negativos,  se  podr\u00eda  llamar  a  la  funci\u00f3n  con  un  n\u00famero  negativo  aunque  no  tenga sentido:</p> <pre><code>int result = factorial(-5); //(1)!\nSystem.out.println(\"El factorial de %d es %d\\n\", -5, result); //(2)!\n</code></pre> <ol> <li>No tiene mucho sentido porque el factorial se aplica a n\u00fameros positivos</li> <li>El factorial de -5 es 1</li> </ol> <p>Es decir, cuando programamos una funci\u00f3n, no podemos dar por hecho que el programador que la vaya a utilizar lo haga de manera adecuada con la l\u00f3gica que representa su funcionalidad. As\u00ed que  siempre  que  programemos  una  funci\u00f3n,  debemos  asegurarnos  que  va  a  funcionar correctamente para todos los valores posibles del par\u00e1metro. En nuestro caso, no podemos dar un  resultado  coherente  para  los  n\u00fameros  negativos  puesto  que  no  tiene  sentido matem\u00e1ticamente el factorial de un n\u00famero negativo, as\u00ed que lo m\u00e1s conveniente es lanzar un error cuando llamen a la funci\u00f3n con un n\u00famero negativo.</p> <pre><code>import java.util.Scanner;\npublic class Factorial {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint n, variable;\nSystem.out.println(\"Llamada a la funci\u00f3n con argumentos literales: \");\nSystem.out.printf(\"El factorial de 5 es %d\\n\", factorial(5));\nSystem.out.println(\"Llamada a la funci\u00f3n usando una variable como argumento: \");\nvariable = 5;\nSystem.out.printf(\"El factorial de %d es %d\\n\", variable, factorial(variable));\nSystem.out.println(\"Llamada a la funci\u00f3n usando una expresi\u00f3n como argumento: \");\nvariable = 3;\nSystem.out.printf(\"El factorial de %d es %d\\n\", variable + 2, factorial(variable + 2));\nSystem.out.println(\"Llamada a la funci\u00f3n con argumentos introducidos por el usuario: \");\ndo {\nSystem.out.println(\"Introduzca un n\u00famero entero positivo: \");\nn = keyboard.nextInt();\n} while (n &lt;= 0);\nSystem.out.printf(\"El factorial de %d es %d\", n, factorial(n));\nSystem.out.println(\"Llamada a la funci\u00f3n con argumentos negativos\");\nvariable = - 5;\nSystem.out.printf(\"El factorial %d es %d\\n\", variable, factorial(variable));\n}\npublic static int factorial(int n) {\nint result = 1;\nif(n &lt; 0){\nthrow new IllegalArgumentException(\"El factorial se aplica a n\u00fameros positivos\");\n}\nfor (int i = 2; i &lt;= n; i++) {\nresult *= i;\n}\nreturn result;\n}\n}\n</code></pre> <p>Salida por consola:</p> <pre><code>Exception in thread \"main\" java.lang.IllegalArgumentException: El factorial se aplica a n\u00fameros positivos\nat tema2_3_Funciones.Factorial3.factorial(Factorial3.java:19)\nat tema2_3_Funciones.Factorial3.main(Factorial3.java:9)\n</code></pre> Ejercicio 4 <p>Realiza una funci\u00f3n que encuentre el primer valor N para el que la suma <code>1 + 2 + 3 + .. + N</code> exceda a un valor M que se introduce por par\u00e1metro. Es decir, si M vale:</p> <ul> <li>1: devuelve 2</li> <li>3: devuelve 3</li> <li>7: devuelve 4</li> <li>10: devuelve 5</li> <li>15: devuelve 6</li> </ul> Ejercicio 5 <p>El m\u00e1ximo com\u00fan divisor de dos enteros es el entero m\u00e1s grande que es divisor exacto de los dos n\u00fameros. Realiza una funci\u00f3n que devuelva el m\u00e1ximo com\u00fan divisor de dos enteros. Por ejemplo, 12 es el mcd de 36 y 60.</p>"},{"location":"bloque_i/tema_2/page-3/#ejemplo-de-procedimiento","title":"Ejemplo de Procedimiento","text":"<p>No tendremos  <code>return expresi\u00f3n</code>  ya que no devuelve ning\u00fan resultado y el <code>tipo_resultado</code> es void:</p> <pre><code>import java.util.Scanner;\nimport static examples.tema_01.Colors.GREEN;\nimport static examples.tema_01.Colors.RESET;\npublic class Procedure {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString string;\nSystem.out.print(\"Introduce una cadena: \");\nstring = keyboard.nextLine();\npaintGreen(string);\n}\nprivate static void paintGreen(String string) {\nSystem.out.printf(\"La cadena que has introducido en verde: %s\", GREEN + string + RESET);\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#resultado-de-las-funciones","title":"Resultado de las funciones","text":"<p>En las llamadas a funciones, no hay que obligatoriamente utilizar el valor devuelto:</p> <pre><code>import java.util.Scanner;\nimport static examples.tema_01.Colors.GREEN;\nimport static examples.tema_01.Colors.RESET;\npublic class Result {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nString string, stringGreen;\nSystem.out.print(\"Introduce una cadena: \");\nstring = keyboard.nextLine();\n/*\n         * En la llamada a la funci\u00f3n turnGreen, no estamos utilizando el valor devuelto\n         */\nturnGreen(string);\n/*\n         * En la siguiente llamada, s\u00ed lo vamos a utilizar\n         */\nstringGreen = turnGreen(string);\nSystem.out.printf(\"La cadena %s convertida a verde: %s\", string, stringGreen);\n}\nprivate static String turnGreen(String string) {\nString result = String.format(\"%s\", GREEN + string + RESET);\nSystem.out.println(result);\nreturn result;\n}\n}\n</code></pre> Ejercicio 6 <p>Se dice que un n\u00famero entero es primo si s\u00f3lo es divisible entre 1 y entre s\u00ed mismo. Por ejemplo, 2, 3, 5 y 7 son primos, pero 4, 6, 8 y 9 no lo son.</p> <ol> <li>Realiza una funci\u00f3n que determine si un n\u00famero es primo o no.</li> <li>Realiza una funci\u00f3n que muestre todos los n\u00fameros primos comprendidos entre 1 y 10.000</li> <li>Realiza una funci\u00f3n que descomponga un n\u00famero en factores primos. Ejemplo:<ul> <li>18 = 2 x 3 x 3</li> <li>11 = 11</li> <li>35 = 5 x 7</li> <li>40 = 2 x 2 x 2 x 5</li> </ul> </li> </ol> Ejercicio 7 <p>Se dice que un n\u00famero entero es un n\u00famero perfecto si la suma de sus divisores propios (incluyendo el 1 y sin incluirse \u00e9l mismo) da como resultado el mismo n\u00famero. Por ejemplo, 6 es un n\u00famero perfecto, porque sus divisores propios son 1, 2 y 3; y 6 = 1 + 2 + 3. Los siguientes n\u00fameros perfectos son 28, 496 y 8128.</p> <ol> <li>Realiza una funci\u00f3n que determine si el par\u00e1metro es perfecto o no.</li> <li>Realiza una funci\u00f3n que dado un n\u00famero perfecto, imprima los divisores para confirmar que el n\u00famero es perfecto. Si no lo es, que no haga nada.</li> <li>Realiza una funci\u00f3n que muestre todos los n\u00fameros perfectos entre 1 y 10.000 con sus correspondientes factores.</li> </ol> Ejercicio 8 <p>La serie Fibonacci se define mediante: a0 = 0 a1 = 1 an = an-1 + an-2, es decir, la serie Fibonacci ser\u00eda la siguiente 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p> <ol> <li>Realiza una funci\u00f3n que devuelva el elemento en\u00e9simo de la serie Fibonacci. Es decir, si recibe:<ul> <li>0: devuelve 0</li> <li>1: devuelve 1</li> <li>4: devuelve 3</li> <li>7: devuelve 13</li> </ul> </li> <li>Realiza una funci\u00f3n que muestre los 30 primeros n\u00fameros de la serie de Fibonacci</li> <li>Realiza una funci\u00f3n que calcule el primer elemento de la serie Fibonacci que se mayor o igual que un valor introducido por par\u00e1metro. Por ejemplo, si recibe 20, devolver\u00e1 21, ya que es el primer elemento de la serie mayor o igual que 20.</li> </ol> Ejercicio 9 <p>Realiza una funci\u00f3n que reciba un n\u00famero entero positivo de n cifras y devuelva el n\u00famero con sus cifras en orden inverso. No utilizar String ni calcular previamente el n\u00famero de cifras. Ej: 24.321 debe devolver 12.345</p>"},{"location":"bloque_i/tema_2/page-3/#recursividad","title":"Recursividad","text":"<p>La recursividad es una t\u00e9cnica de escritura de funciones pensada para problemas complejos. La idea parte de que una funci\u00f3n pueda invocarse a s\u00ed misma.</p> <p>Esta t\u00e9cnica es peligrosa ya que se pueden generar f\u00e1cilmente llamadas infinitas (la funci\u00f3n se llama a s\u00ed misma, tras la llamada se vuelve a llamar a s\u00ed misma, y as\u00ed sucesivamente sin freno ni control).  Por  lo  tanto,  es  muy  importante  tener  en  cuenta  cu\u00e1ndo  la  funci\u00f3n  debe  dejar  de llamarse.</p> <p>Hay  que  ser  muy  cauteloso  cuando  se  utiliza  la  recursividad,  pero  permite  soluciones  muy originales y abre la posibilidad de solucionar problemas muy complejos.</p> <p>Veamos como ejemplo la versi\u00f3n recursiva del factorial:</p> <pre><code>import java.util.Scanner;\npublic class RecursiveFactorial {\npublic static void main(String[] args) {\nScanner keyboard = new Scanner(System.in);\nint n;\ndo{\nSystem.out.println(\"Introduce un n\u00famero entero positivo: \");\nn = keyboard.nextInt();\n} while (n &lt;= 0);\nSystem.out.printf(\"El factorial de %d es %d\\n\", factorial(n));\n}\nprivate static int factorial(int n) {\nint result;\nif(n == 1){ // Caso base: devuelve 1\nresult = 1;\n} else { // Caso recursivo\nresult = n * factorial(n-1);\n}\n/*\n         * Mensaje intermedio para comprobar\n         * como funciona\n         */\nSystem.out.printf(\"Factorial de %d  Resultado: %d\\n\", n, result);\nreturn result;\n}\n}\n</code></pre> <p>\u00bfRecursividad o iteraci\u00f3n? Hay otra versi\u00f3n del factorial resuelto mediante un bucle for (soluci\u00f3n iterativa) en lugar de utilizar la recursividad. La cuesti\u00f3n es \u00bfcu\u00e1l es mejor? Ambas implican sentencias repetitivas hasta llegar a una determinada condici\u00f3n, por lo que ambas pueden generar programas que no finalizan si la condici\u00f3n nunca se cumple. En el caso de la iteraci\u00f3n es una condici\u00f3n la que permite determinar el final, la recursividad lo que hace es ir simplificando el problema hasta generar una llamada a la funci\u00f3n que devuelva un valor y no se vuelva a llamar. Para un ordenador es m\u00e1s costosa la recursividad ya que implicar realizar muchas llamadas a funciones, es decir, es m\u00e1s r\u00e1pida la soluci\u00f3n iterativa. Entonces, \u00bfpor qu\u00e9 elegir recursividad? La recursividad se utiliza s\u00f3lo s\u00ed:</p> <ul> <li>No encontramos la soluci\u00f3n iterativa a un problema.</li> <li>El c\u00f3digo es mucho m\u00e1s claro en su versi\u00f3n recursiva.</li> </ul> Ejercicio 10 <p>Realiza el ejercicio 1, haciendo uso de la recursividad</p> Ejercicio 11 <p>El m\u00e1ximo com\u00fan divisor de los enteros a y b es el entero m\u00e1s grande que es divisor exacto de a y de b. Escribe una funci\u00f3n recursiva llamada gcd que devuelva el m\u00e1ximo com\u00fan divisor de a y b. El m\u00e1ximo com\u00fan divisor de a y b se define recursivamente como sigue:</p> <ul> <li>si b = 0 \u2192 gcd(a, b) = a</li> <li>si b \u2260 0 \u2192 gcd(a, b) = gcd(b, a % b)</li> </ul> Ejercicio 12 <p>Realiza el ejercicio 4 haciendo uso de la recursividad</p> Ejercicio 13 <p>Realiza el ejercicio 8 haciendo uso de la recursividad</p>"},{"location":"bloque_i/tema_2/page-3/#la-pila","title":"La pila","text":"<p>Una pila(stack) es una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del ingl\u00e9s Last In, First Out, \u00faltimo en entrar,  primero  en  salir) de  supuestos  en  el  \u00e1rea  de inform\u00e1tica debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.</p> <p>Para el manejo de los datos cuenta con dos operaciones b\u00e1sicas: apilar (push), que coloca un objeto en la pila, y su operaci\u00f3n inversa, desapilar (pop), que retira el \u00faltimo elemento apilado.</p> <p>En cada momento s\u00f3lo se tiene acceso a la parte superior de la pila, es decir, al \u00faltimo objeto apilado  (denominado  TOS,  Top of Stack).  La  operaci\u00f3n  desapilar  permite  la  obtenci\u00f3n  de  este elemento, que es retirado de la pila permitiendo el acceso al anterior (apilado con anterioridad), que pasa a ser el \u00faltimo, el nuevo TOS.</p> <p>Para las llamadas entre funciones, se utiliza una estructura de tipo pila: supongamos que se est\u00e1 procesando  una  funci\u00f3n  y  en  su  interior  llama  a  otra  funci\u00f3n.  La  funci\u00f3n  se  abandona  para procesar la funci\u00f3n de la llamada, pero antes se almacena en una pila la direcci\u00f3n que apunta a la funci\u00f3n. Ahora supongamos que esa nueva funci\u00f3n llama a su vez a otra funci\u00f3n. Igualmente, se almacena su direcci\u00f3n, se abandona y se atiende la petici\u00f3n. As\u00ed en tantos casos como existan peticiones.  La  ventaja  de  la  pila  es  que  no  requiere  definir  ninguna  estructura  de  control  ni conocer las veces que el programa estar\u00e1 saltando entre funciones para despu\u00e9s retomarlas, con la \u00fanica limitaci\u00f3n de la capacidad de almacenamiento de la pila. Conforme se van cerrando las funciones, se van rescatando las funciones precedentes mediante sus direcciones almacenadas en la pila y se va concluyendo su proceso, esto hasta llegar a la primera.</p> <p>En el caso de una funci\u00f3n recursiva, esto es posible implementarlo con sencillez mediante una pila. La funci\u00f3n se llama a s\u00ed misma tantas veces como sea necesario hasta que el resultado de la funci\u00f3n cumpla la condici\u00f3n de retorno; entonces, todas las funciones abiertas van completando su proceso en cascada. No se necesita saber cuantas veces se anidar\u00e1 y, por tanto, tampoco cuando  se  cumplir\u00e1  la  condici\u00f3n,  con  la  \u00fanica  limitaci\u00f3n  de  la  capacidad  de  la  pila.  De sobrepasarse ese l\u00edmite, normalmente porque se entra en un bucle sin final, se produce el error de desbordamiento de la pila (stack overflow).</p> Ejercicio 15 <p>Realiza una funci\u00f3n recursiva que invierta los caracteres de una cadena. Por ejemplo, si la funci\u00f3n recibe \"Hola a todos\", devuelve \"sodot a aloH\".</p> Ejercicio 14 <p>Realiza  un  programa  para  resolver  el  juego  de  las  Torres de Hanoi.  El  juego  consiste  en  tres  varillas verticales. En una de las varillas se apila un n\u00famero indeterminado de discos. Los discos se apilan sobre una varilla en tama\u00f1o decreciente. No hay dos discos iguales, y todos ellos est\u00e1n apilados de mayor a menor radio en una de las varillas, quedando las otras dos varillas vacantes. El juego consiste en pasar todos los discos de la varilla ocupada a una de las otras varillas vacantes. Para realizar este objetivo, es necesario seguir estas simples reglas:</p> <ul> <li>Solo se puede mover un disco cada vez.</li> <li>Un disco de mayor tama\u00f1o no puede descansar sobre uno m\u00e1s peque\u00f1o que \u00e9l mismo.</li> <li>Solo puedes desplazar el disco que se encuentre arriba en cada varilla.</li> </ul> <p>El movimiento de n discos se puede visualizar en t\u00e9rminos de mover s\u00f3lo n-1 discos (y de ah\u00ed la recursividad) como sigue:</p> <ol> <li>Pasar n-1 discos de la varilla 1 a la 2, usando la varilla 3 como \u00e1rea de retenci\u00f3n temporal.</li> <li>Pasar el \u00faltimo disco (el m\u00e1s grande) de la varilla 1 a la 3.</li> <li>Pasar los n-1 discos de la varilla 2 a la 3, empleando la varilla 1 como \u00e1rea de retenci\u00f3n temporal.</li> </ol> <p>El  proceso  termina  cuando  la  \u00faltima  tarea  implica  pasar  n=1  disco,  esto  es,  el  caso  base.  Esto  se  logra transfiriendo  el  disco  sin  necesidad  de  un  \u00e1rea  de  retenci\u00f3n  temporal.  Escribe  una  funci\u00f3n  recursiva  con cuatro par\u00e1metros:</p> <ol> <li>El n\u00famero de discos por transferir.</li> <li>La varilla en la que est\u00e1n colocados inicialmente esos discos.</li> <li>La varilla a la que debe pasarse esa pila de discos.</li> <li>La varilla que se usar\u00e1 como \u00e1rea de retenci\u00f3n temporal.</li> </ol> <p>El programa deber\u00e1 imprimir las instrucciones precisas requeridas para pasar los discos de la varilla inicial a  la varilla de destino. Por ejemplo, para pasar una pila de tres discos de la varilla 1 a la varilla 3, el programa deber\u00e1 imprimir la siguiente serie de movimientos:</p> <pre><code>1 \u2192 3\n1 \u2192 2\n3 \u2192 2\n1 \u2192 3\n2 \u2192 1\n2 \u2192 3\n1 \u2192 3\n</code></pre>"},{"location":"bloque_i/tema_2/page-4/","title":"Proyecto","text":"<p>Se desea realizar un proyecto Java en el cu\u00e1l se le mostrar\u00e1 al usuario un men\u00fa d\u00f3nde se le solicitar\u00e1 una de las siguiente figuras, teniendo en cuenta que cada vez que acceda a una de ellas, se les solicitar\u00e1 los datos pertinentes para el calculo de su \u00e1rea. Las figuras son las siguientes:</p> <ol> <li>Tri\u00e1ngulo (solicitar base y altura)</li> <li>Cuadrado (solicitar lado)</li> <li>Rect\u00e1ngulo (solicitar base y altura)</li> <li>Rombo (solicitar diagonal mayor y menor)</li> <li>Romboide (solicitar base y altura)</li> <li>Trapecio (solicitar base mayor, base menor y altura)</li> <li>C\u00edrculo (solicitar di\u00e1metro)</li> </ol> <p>Una vez realizado el \u00e1rea se deber\u00e1 comprobar sin hacer uso del resto de la divisi\u00f3n si el \u00e1rea (solo la parte entera) es m\u00faltiplo de 3 y de 9.</p> <p>Adem\u00e1s se le dar\u00e1 una opci\u00f3n al usuario para salir del men\u00fa, ya que aunque el usuario elija una opci\u00f3n se le volver\u00e1 a mostrar el men\u00fa de opciones una vez finalizada la operaci\u00f3n.</p> <p>Para realizar el proyecto se tendr\u00e1 en cuenta los siguientes objeciones:</p> <ol> <li>Se crear\u00e1 un proyecto nuevo cuyo nombre sea el siguiente formato pr02java-NOMBRE-geometria siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>Se har\u00e1 uso de la recursividad donde sea necesario.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ol>"},{"location":"bloque_i/tema_3/page-1/","title":"1 Cadenas","text":""},{"location":"bloque_i/tema_3/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>El texto es uno de los tipos de datos m\u00e1s importantes y por ello java lo trata de manera especial. Las cadenas deben manejarse creando objetos de tipo String. Se pueden inicializar de dos maneras:</p> <ul> <li>Usando el operador asignaci\u00f3n como los primitivos: <code>String s = \"hola\"</code></li> <li>Usando el constructor como los objetos: <code>String s = new String(\"hola\");</code></li> </ul> <p>Los literales cadena se escriben entre comillas dobles: <code>\"Esto es un literal cadena\"</code>.</p> <p>En Java existe tambi\u00e9n la cadena vac\u00eda o nula(\"\"), es decir, una cadena sin ning\u00fan car\u00e1cter.</p> <p>Ejemplo: <code>String s = \"\";</code> A la variable s se le est\u00e1 asignando la cadena vac\u00eda o nula.</p>"},{"location":"bloque_i/tema_3/page-1/#inmutabulidad","title":"Inmutabulidad","text":"<p>Uno  de  los  conceptos  que  suele  venir  asociado  a  la  programaci\u00f3n  funcional  es  el  de  la inmutabilidad.  Si  bien  es  cierto  que  la  inmutabilidad  es  una  idea  que  no  es  exclusiva  de  la programaci\u00f3n  funcional,  s\u00ed  que  cobra  una  importancia  vital  en  este  tipo  de  lenguajes.  La programaci\u00f3n funcional se asienta sobre muchos conceptos matem\u00e1ticos que requieren de la inmutabilidad para seguir siendo v\u00e1lidos. A\u00fan as\u00ed, es un concepto que es interesante conocer independientemente del tipo de paradigma de programaci\u00f3n que se utilice.</p>"},{"location":"bloque_i/tema_3/page-1/#que-es-la-inmutabilidad","title":"\u00bfQu\u00e9 es la inmutabilidad?","text":"<p>La idea es muy sencilla de entender: algo es inmutable cuando no se puede modificar. En el contexto de la programaci\u00f3n, una variable es inmutable cuando su valor no se puede modificar. Y un objeto lo es cuando su estado no puede ser actualizado tras la creaci\u00f3n del objeto. Es por tanto una forma de asegurar que los objetos no se modifican en lugares inesperados afectando con ello la ejecuci\u00f3n de nuestro programa.</p> <p>La inmutabilidad genera muchas ventajas en las aplicaciones multihilo, donde la inmutabilidad simplifica mucho el tratamiento de la concurrencia. Si algo no se puede modificar, da igual que se acceda a ello desde distintos hilos a la vez, as\u00ed como el orden en que se haga.</p> <p>La inmutabilidad hace que el c\u00f3digo sea mucho m\u00e1s predecible y m\u00e1s f\u00e1cil de testear, porque se acota mucho m\u00e1s los lugares donde se producen modificaciones de estado.</p> <p>La inmutabilidad tiene el sobrecoste de la generaci\u00f3n de objetos nuevos cada vez que cambia el estado, as\u00ed que esto puede penalizar bastante en el rendimiento. As\u00ed como gu\u00eda muy general, es recomendable usar objetos mutables en cualquier situaci\u00f3n que requiera de un estado que se modifica a menudo y/o la duplicaci\u00f3n de ese estado sea costosa.</p> <p>La inmutabilidad, por el contrario, presenta ventajas en las siguientes situaciones:</p> <ul> <li>En objetos que no vayan a requerir modificaciones de estado.</li> <li>En objetos que sean simples de duplicar.</li> <li>En situaciones de concurrencia.</li> </ul> <p>As\u00ed que hay que hacer inmutable todo el c\u00f3digo que sea posible ya que es un concepto muy potente que nos puede ayudar a simplificar la complejidad de comprensi\u00f3n de nuestro c\u00f3digo y, por tanto, a disminuir las probabilidades de que se produzcan errores inesperados.</p> <p>En java, los objetos String son inmutables.</p>"},{"location":"bloque_i/tema_3/page-1/#formatos-de-codificacion-de-caracteres","title":"Formatos de codificaci\u00f3n de caracteres","text":"<p>En  el  Unicode,  el  Plano  Multiling\u00fce  B\u00e1sico  (Basic  Multilingual  Plane,  BMP)  incluye  los  65.536 caracteres  cuyos  c\u00f3digos  van  desde  U+0000  a  U+FFFF,  que  son  la  mayor\u00eda  de  los  caracteres utilizados m\u00e1s frecuentemente.</p> <p>El n\u00famero 65.536 es 2 elevado a 16, es decir, la cantidad m\u00e1xima de combinaciones de bits que se pueden obtener en dos bytes.</p> <p>El resto de caracteres se denominan caracteres complementarios.</p> <p>Los formatos de codificaci\u00f3n que se pueden usar con Unicode se denominan UTF-8, UTF-16 y UTF-32:</p> <p>UTF-8  utiliza  1  byte  para  representar  caracteres  ASCII,  dos  bytes  para  caracteres  en  otros bloques alfab\u00e9ticos y tres bytes para el resto del BMP. Para los caracteres complementarios se utilizan 4 bytes.</p> <p>UTF-16  utiliza  2  bytes  para  cualquier  car\u00e1cter  en  el  BMP  y  4  bytes  para  los  caracteres complementarios.</p> <p>UTF-32 emplea 4 bytes para todos los caracteres.</p> <p> Figura 1 - Encodings</p> <p>En Java, las cadenas utilizan el formato de codificaci\u00f3n UTF-16.</p>"},{"location":"bloque_i/tema_3/page-1/#formateo-de-cadenas","title":"Formateo de cadenas","text":"<p>Hay un m\u00e9todo est\u00e1tico en la clase String que sirve para construir una cadena con cierto formato. Funciona de la misma manera que el m\u00e9todo <code>printf</code> que vimos en el tema 1.12. Escritura en pantalla.</p> <pre><code>public class StringFormat {\npublic static void main(String[] args) {\nString formattedString;\nformattedString = String.format(\"Nombre: %s Edad: %d Sueldo: %.2f\", \"Juan\", 20, 1896.23);\nSystem.out.println(formattedString);\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#metodos-de-la-clase-string","title":"M\u00e9todos de la clase String","text":"<p>Si observamos en la API la clase String, incluye m\u00e9todos para examinar los caracteres individuales de una cadena, para comparar cadenas, para buscar cadenas, para extraer subcadenas, para convertir cadenas a may\u00fasculas o min\u00fasculas, etc.</p> <p>Como vimos en el Tema 1.5 - Operadores, el operador concatenaci\u00f3n <code>+</code> es un operador binario que devuelve una cadena resultado para concatenar las dos cadenas que act\u00faan como operandos. Si s\u00f3lo uno de los operandos es de tipo cadena, el otro operando se convierte impl\u00edcitamente en tipo cadena.</p> <p>Obs\u00e9rvese en la API en el m\u00e9todo valueOf, es est\u00e1tico y est\u00e1 sobrecargado. Sirve para obtener la representaci\u00f3n String de un valor u objeto.</p> <pre><code>public class StringConcatPlus {\npublic static void main(String[] args) {\nint i = 100;\nString string1, string2, string3, string4;\nstring1 = \"Esto es un literal cadena\"; //(1)!\nSystem.out.println(string1);\nSystem.out.println(string1 + \" al cual le hemos concatenado este literal cadena\"); //(2)!\nstring2 = \"hola\";\nstring3 = \" que tal\";\nstring4 = string2 + string3;\nSystem.out.println(string4);\nSystem.out.println(i + 100);\nSystem.out.println(String.valueOf(i) + 100);\n}\n}\n</code></pre> <ol> <li>Se le da un valor inicial con el operador asignaci\u00f3n</li> <li>Se concatena otra cadena con el operador +</li> </ol> <p>Otros m\u00e9todos de las cadenas muy \u00fatiles son:</p> <ul> <li>charAt: devuelve el car\u00e1cter de la cadena del especificado \u00edndice. Dicho \u00edndice empieza en cero, es decir, con el cero se obtiene el primer car\u00e1cter de la cadena.</li> <li>length: devuelve la longitud de la cadena.</li> <li>equals: compara si dos cadenas son iguales. Las cadenas se comparan con equals como los objetos y los primitivos se comparan con <code>==</code>.</li> <li>equalsIgnoreCase: hace lo mismo que el anterior pero no tiene en cuenta las may\u00fasculas y min\u00fasculas.</li> </ul> <pre><code>public class StringMethods {\npublic static void main(String[] args) {\nString string = \"hola\";\nSystem.out.println(string.charAt(0));//h\nSystem.out.println(string.charAt(1));//o\nSystem.out.println(string.charAt(2));//l\nSystem.out.println(string.charAt(3));//a\nSystem.out.println(string.length());//4\nSystem.out.println(string.equals(\"hola\"));//true\nSystem.out.println(string.equals(\"Hola\"));//false\nSystem.out.println(string.equals(\"adi\u00f3s\"));//false\nSystem.out.println(string.equalsIgnoreCase(\"Hola\"));//true\nSystem.out.println(string.equalsIgnoreCase(\"HOLA\"));//true\n//Tambi\u00e9n se le pueden aplicar m\u00e9todos a un literal cadena:\nSystem.out.println(\"hola\".equals(\"hola\")); //true\nSystem.out.println(\"adios\".equals(\"hola\"));//false\n}\n}\n</code></pre> <p>M\u00e1s m\u00e9todos de cadenas interesantes:</p> <ul> <li>compareTo: compara dos cadenas lexicogr\u00e1ficamente. La comparaci\u00f3n se basa en el valor Unicode de cada car\u00e1cter de las cadenas. <code>s1.compareTo(s2)</code> devuelve un n\u00famero negativo si s1 es menor, un n\u00famero positivo si s1 es mayor o cero si son iguales.</li> <li>compareToIgnoreCase: hace lo mismo que el anterior pero no tiene en cuenta may\u00fasculas y min\u00fasculas.</li> <li>concat: se utiliza para concatenar cadenas, como el operador <code>+</code>.</li> <li>endsWith: devuelve true si la cadena termina con un determinado texto.</li> <li>startsWith: devuelve true si la cadena empieza con un determinado texto.</li> <li>indexOf: devuelve la primera posici\u00f3n en la que aparece un determinado texto en la cadena. En el caso de que el texto buscado no se encuentre, devuelve -1. Este m\u00e9todo est\u00e1 sobrecargado para que el texto a buscar pueda ser char o String.</li> <li>lastIndexOf: es como el anterior pero busca desde el final.</li> <li>isEmpty: devuelve true si la cadena est\u00e1 vac\u00eda, es decir, si su longitud es cero.</li> <li>repeat: devuelve una cadena cuyo valor es la concatenaci\u00f3n de la cadena repetida varias veces.</li> <li>replace: reemplaza todas las apariciones de un texto por otro texto. Este m\u00e9todo est\u00e1 sobrecargado para que el texto pueda ser char o String.</li> <li>substring: obtiene una subcadena.</li> <li>toLowerCase: devuelve la cadena en min\u00fasculas.</li> <li>toUpperCase: devuelve la cadena en may\u00fasculas.</li> <li>trim: elimina los espacios en blanco del principio y del final de la cadena.</li> </ul> <pre><code>public class StringOtherMethods {\npublic static void main(String[] args) {\nString string1 = \"hola\", string2 = \"adios\", string3 = \"Hola\", string4;\n//hola es mayor que adios\nSystem.out.println(string1.compareTo(string2) &gt; 0 ? String.format(\"%s es mayor que %s\", string1, string2)\n: String.format(\"%s es menor que %s\", string1, string2));\n//adios es menor que hola\nSystem.out.println(string2.compareTo(string1) &gt; 0 ? String.format(\"%s es mayor que %s\", string2, string1)\n: String.format(\"%s es menor que %s\", string2, string1));\n//En el Unicode, las may\u00fasculas est\u00e1n antes: Hola es menor que adios\nSystem.out.println(string3.compareTo(string2) &gt; 0 ? String.format(\"%s es mayor que %s\", string3, string2)\n: String.format(\"%s es menor que %s\", string3, string2));\n//Hola es mayor que adios si no tenemos en cuenta las may\u00fasculas y min\u00fasculas\nSystem.out.println(string3.compareToIgnoreCase(string2) &gt; 0\n? String.format(\"%s es mayor que %s si no tenemos en cuenta las may\u00fasculas y min\u00fasculas\", string3, string2)\n: String.format(\"%s es menor que %s si no tenemos en cuenta las may\u00fasculas y min\u00fasculas\", string3, string2));\nSystem.out.println(string4 = string1.concat(\" que tal\"));//string4=\"hola que tal\"\nSystem.out.println(string4.endsWith(\"tal\"));//true\nSystem.out.println(string4.endsWith(\"hola\"));//false\nSystem.out.println(string4.startsWith(\"hola\"));//true\nSystem.out.println(string4.startsWith(\"tal\"));//false\nSystem.out.println(string4.indexOf(\"hola\"));//0\nSystem.out.println(string4.indexOf(\"tal\"));//9\nSystem.out.println(string4.indexOf(\"que\"));//5\nSystem.out.println(string4.indexOf(string2));//-1\nSystem.out.println(string4.indexOf(string3));//-1\nSystem.out.println(string4.indexOf('a'));//3\nSystem.out.println(\"hola que tal hola que tal\".lastIndexOf(\"tal\"));//22\nSystem.out.println(string4.isEmpty());//false\nSystem.out.println(\"\".isEmpty());//true\nSystem.out.println(\"ole \".repeat(6));//ole ole ole ole ole ole \nSystem.out.println(string4.replace('a', '*'));//hol* que t*l\nSystem.out.println(\"hola que tal hola que tal\".replace(\"hola\",\n\"buenas\"));//buenas que tal buenas que tal\n//Para hacer desaparecer partes de una cadena, se reemplazan por cadena vac\u00eda\nSystem.out.println(\"hola que tal hola que tal\".replace(\" \",\"\"));//holaquetalholaquetal\nSystem.out.println(string4.substring(9));//tal\nSystem.out.println(string4.substring(5, 8));//que\nSystem.out.println(\"HOLA QUE TAL\".toLowerCase());//hola que tal\nSystem.out.println(\"hola que tal\".toUpperCase());//HOLA QUE TAL\nSystem.out.println(\"       Hola que tal      \".trim());//Hola que tal\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza una funci\u00f3n que reciba una cadena y devuelva el n\u00famero de vocales que tiene.</p> Ejercicio 2 <p>Realiza una funci\u00f3n que reciba una cadena y devuelva otra cadena igual pero sin espacios en blanco. No se pueden utilizar m\u00e9todos replace.</p> Ejercicio 3 <p>Realiza una funci\u00f3n que reciba una cadena y un car\u00e1cter y devuelva otra cadena igual pero con todas las apariciones del car\u00e1cter reemplazadas por un asterisco. No se pueden utilizar m\u00e9todos replace.</p> Ejercicio 4 <p>Realiza una funci\u00f3n que reciba una cadena y un car\u00e1cter y devuelva el n\u00famero de apariciones del car\u00e1cter en la cadena. No se pueden utilizar los m\u00e9todos indexOf ni contains.</p> Ejercicio 5 <p>Realiza una funci\u00f3n que reciba una cadena y un car\u00e1cter y devuelva el n\u00famero de caracteres que hay entre la primera y la \u00faltima aparici\u00f3n del car\u00e1cter en la cadena. No se pueden utilizar los m\u00e9todos indexOf ni contains.</p> Ejercicio 6 <p>Realiza una funci\u00f3n que reciba dos cadenas y devuelva la concatenaci\u00f3n de ambas. El m\u00e9todo concat o el operador + solamente se pueden utilizar a nivel de car\u00e1cter.</p> Ejercicio 7 <p>Realiza una funci\u00f3n que reciba una cadena y un n\u00famero y devuelva otra cadena con los primeros caracteres de cadena, tantos como indique el par\u00e1metro. No se puede utilizar el m\u00e9todo substring. Por ejemplo, si recibe \"Programaci\u00f3n\" y 5, devuelve \"Progr\".</p> Ejercicio 8 <p>Realiza una funci\u00f3n que reciba una cadena y un n\u00famero y devuelva otra cadena con los \u00faltimos caracteres de la cadena, tantos como indique, el par\u00e1metro. No se puede utilizar el m\u00e9todo substring. Por ejemplo, si recibe \"Programaci\u00f3n\" y 5, devuelve \"aci\u00f3n\".</p> Ejercicio 9 <p>Realiza una funci\u00f3n que reciba una cadena y devuelva otra cadena con los caracteres en orden inverso. Por ejemplo, si recibe \"hola\", devuelve \"aloh\".</p> Ejercicio 10 <p>Realiza una funci\u00f3n que reciba una cadena y devuelva la suma de todos los d\u00edgitos que hay en ella. Por ejemplo, si recibe \"abc12de3f4gh\", devuelve 10.</p> Ejercicio 11 <p>Realiza una funci\u00f3n que reciba dos cadenas y devuelva el n\u00famero de apariciones de una de ellas en la otra. No se pueden utilizar los m\u00e9todos indexOf, contains ni substring. Hacer las comparaciones a nivel de car\u00e1cter. Por ejemplo, si recibe \"Estoy matriculado en Programaci\u00f3n, en Entornos y en Marcas\" y \"en\", devuelve 3. Si recibe \"hola que tal, hola que pasa, hola\" y \"hola\", devuelve 3.</p> Ejercicio 12 <p>Realiza  una  funci\u00f3n  que  reciba  una  cadena  y  devuelva  el  n\u00famero  de  palabras  que  tiene.  Hacer  las comparaciones a nivel de car\u00e1cter. No se pueden utilizar m\u00e9todos replace, indexOf ni trim. Las palabras dentro de la cadena est\u00e1n separadas por un espacio. Por ejemplo, si recibe \"Estoy matriculado en Programaci\u00f3n en Entornos y en Marcas\", devuelve 9. Si recibe \" Estoy matriculado en Programaci\u00f3n en Entornos y en Marcas \", es decir, con un espacio al principio y otro al final, devuelve 9.</p> Ejercicio 13 <p>Realiza  una  funci\u00f3n  que  reciba  una  cadena  y  devuelva  el  n\u00famero  de  palabras  que  tiene.  Hacer  las comparaciones a nivel de car\u00e1cter. No se pueden utilizar m\u00e9todos replace ni indexOf. Las palabras dentro de la cadena pueden estar separadas por m\u00e1s de un espacio. No se pueden eliminar los espacios de la cadena. Por ejemplo, si recibe \"Estoy         matriculado      en        Programaci\u00f3n       en         Entornos         y        en           Marcas\", devuelve 9.</p>"},{"location":"bloque_i/tema_3/page-2/","title":"2 StringBuilder y StringBuffer","text":""},{"location":"bloque_i/tema_3/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Como se ha dicho en el apartado anterior, las cadenas son objetos constantes e inmutables, es decir, una vez que son creadas no pueden ser modificadas. Por ejemplo:</p> <pre><code>String s = \"hello\";\ns += \" world\";\nSystem.out.println(s); // Hello world\n</code></pre> <p>En primer lugar, se ha creado un objeto String y se ha referenciado a \u00e9l n the first line, a String \"Hello\" object is created and a reference to it, is stored in the s variable.</p> <p>En la segunda l\u00ednea otro objeto \"world\" es creado y despu\u00e9s viene una concatenaci\u00f3n de objetos (\"Hello\" y \"world\"). La concatenaci\u00f3n produce un nuevo objeto cadena \"Hello world\" cuya referencia ser\u00e1 almacenada en la variable s.</p> <p>Los objetos \"Hello\" y \"world\" son objetos obsoletos porque nadie usa su referencia, as\u00ed que no son usados. La JVM tiene un recolector de basura el cu\u00e1l limpia esos objetos de la memoria.</p> <p>Cuando manipulamos cadenas, ya sea concatenando, insertando o remplazando caracteres, muchos objetos son creados y r\u00e1pidamente descartados. Esta creaci\u00f3n de objetos de forma masiva puede provocar un incremento del uso de la memoria.</p> <p>El recolector de basura de Java limpia la memoria, pero dicha operaci\u00f3n tiene un tiempo costoso. Si nosotros creamos y destruimos muchos objetos, la ejecuci\u00f3n de nuestro programa puede ser poco eficiente.</p> <p>StringBuffer y StringBuilder son clases que nos permite crear objetos que almacenan cadenas que pueden ser modificadas sin necesidad de crear nuevos objetos.</p> <p>Ambas clases, tienen m\u00e9todos que nos permite manipular cadenas, como append, insert, etc.</p> <p>StringBuilder y StringBuffer son muy parecidos, pero StringBuffer puede ser usado en programas concurrentes con el uso de m\u00faltiples hilos de forma que sea thread safe (seguro para hilos), lo que hace que StringBuilder sea mucho m\u00e1s eficientes para programas no concurrentes.</p>"},{"location":"bloque_i/tema_3/page-2/#stringbuilder","title":"StringBuilder","text":"<p>StringBuilder es una clase de Java que nos permite manipular cadenas evitando la problem\u00e1tica de la creaci\u00f3n de objetos innecesarios. Algunos m\u00e9todos de esta clase son:</p> <ul> <li>StringBuilder append(String s). A\u00f1ade la cadena pasada por par\u00e1metro a la secuencia de caracteres. Este m\u00e9todo esta sobrescrito para a\u00f1adir cualquier tipo primitivo (int, boolean, char, etc.), para a\u00f1adir Object o un StringBuffer</li> <li>int capacity(). Retorna el n\u00famero de caracteres actuales que hay almacenados.</li> <li>StringBuilder delete(int start, int end). Elimina la subcadena en la secuencia de caracteres.</li> <li>StringBuilder deleteCharAt(). Elimina el car\u00e1cter especificado en la secuencia de caracteres.</li> <li>StringBuilder insert(int offset, String str). Inserta la cadena especificada a la secuencia de caracteres en la posici\u00f3n indicada, moviendo, si es necesario, el resto de caracteres. Este m\u00e9todo est\u00e1 sobrescrito para los tipos primitivos y el tipo Object.</li> <li>StringBuilder reverse(). Reemplaza la secuencia de caracteres actual por la secuencia de caracteres invertida.</li> <li>String toString(). Devuelve la secuencia de caracteres como String.</li> </ul> <p>Adem\u00e1s de estos m\u00e9todos, tambi\u00e9n tiene m\u00e9todos parecidos de la clase String como charAt(), indexOf(), lastIndexOf(), length(), subString().</p> <pre><code>import java.util.Scanner;\npublic class StringBuilderExample {\npublic static void main(String[] args) {\nStringBuilder builder = new StringBuilder();\nScanner scanner = new Scanner(System.in);\nfor(int i = 1; i &lt;= 10; i++){\nSystem.out.print(\"Introduce una cadena: \");\nbuilder.append(scanner.nextLine());\n}\nSystem.out.printf(\"Capacidad actual: %d\\n\", builder.capacity());\nbuilder.insert(5, \"String insertada en el car\u00e1cter 5\");\nbuilder.insert(0, true);\nSystem.out.printf(\"Cadena actual: %s\\n\", builder);\nSystem.out.printf(\"Primer car\u00e1cter: %s\\n\", builder.charAt(0));\nSystem.out.printf(\"Tama\u00f1o de la cadena: %d\\n\", builder.length());\nSystem.out.printf(\"La letra 'A' se encuentra en: %d\\n\", builder.indexOf(\"A\"));\nSystem.out.printf(\"Cadena invertida: %s\\n\", builder.reverse());\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#stringbuffer","title":"StringBuffer","text":"<p>La clase StringBuffer funciona de forma muy similar a la clase StringBuilder pero con la diferencia que \u00e9sta es thread-safe, segura para trabajar con hilos. Algunos m\u00e9todos de esta clase son:</p> <ul> <li>StringBuffer append(String s). A\u00f1ade la cadena pasada por par\u00e1metro a la secuencia de caracteres. Este m\u00e9todo esta sobrescrito para a\u00f1adir cualquier tipo primitivo (int, boolean, char, etc.), para a\u00f1adir Object u otro StringBuffer</li> <li>int capacity(). Retorna el n\u00famero de caracteres actuales que hay almacenados.</li> <li>StringBuffer delete(int start, int end). Elimina la subcadena en la secuencia de caracteres.</li> <li>StringBuffer deleteCharAt(). Elimina el car\u00e1cter especificado en la secuencia de caracteres.</li> <li>StringBuffer insert(int offset, String str). Inserta la cadena especificada a la secuencia de caracteres en la posici\u00f3n indicada, moviendo, si es necesario, el resto de caracteres. Este m\u00e9todo est\u00e1 sobrescrito para los tipos primitivos y el tipo Object.</li> <li>StringBuffer reverse(). Reemplaza la secuencia de caracteres actual por la secuencia de caracteres invertida.</li> <li>String toString(). Devuelve la secuencia de caracteres como String.</li> </ul> <p>Adem\u00e1s de estos m\u00e9todos, tambi\u00e9n tiene m\u00e9todos parecidos de la clase String como charAt(), indexOf(), lastIndexOf(), length(), subString().</p>"},{"location":"bloque_i/tema_3/page-2/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Crea un m\u00e9todo que reciba una cadena de s\u00f3lo d\u00edgitos, y devolver la misma cadena pero con separadores de miles, si es posible. Por ejemplo, si recibe la cadena 3456 devolver\u00e1 3.456, si recibe 123456789, devolver\u00e1 123.456.789 y si recibe 123 devolver\u00e1 123. Hacer uso de la clase StringBuilder.</p> Ejercicio 2 <p>Realiza el ejercicio anterior, pero ahora haciendo uso de la clase StringBuffer.</p>"},{"location":"bloque_i/tema_3/page-3/","title":"3 Expresiones regulares","text":""},{"location":"bloque_i/tema_3/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Una  expresi\u00f3n regular  es  una  secuencia  de  caracteres  que  forma  un  patr\u00f3n  de  b\u00fasqueda proporcionando una manera muy flexible de buscar o reemplazar cadenas de texto.</p> <p>En la clase String hay un m\u00e9todo llamado matches que indica si la cadena coincide o no con la expresi\u00f3n regular que se le pasa por par\u00e1metro . He aqu\u00ed algunas de las construcciones de expresiones regulares que se encuentran en la API de Java en la clase Pattern:</p> <ul> <li> <p>Characters</p> Construct Matches x The character x \\ The backslash character \\u*hhhh* The character with hexadecimal value 0x*hhhh* \\t The tab character (\\u0009) \\n The newline (line feed) character (\\u000A) <pre><code>public class Characters {\npublic static void main(String[] args) {\nSystem.out.println(\"a\".matches(\"a\")); //true\nSystem.out.println(\"b\".matches(\"a\")); //false\nSystem.out.println(\"A\".matches(\"\\u0041\")); //true\nSystem.out.println(\"\\n\".matches(\"\\n\")); //true\nSystem.out.println(\"\\t\".matches(\"\\t\")); //true\nSystem.out.println(\"\\\\\".matches(\"\\\\\\\\\")); //true\n}\n}\n</code></pre> <p>Tal  y  como  vimos  en  el  tema  1.4  Tipos  de  datos  primitivos  en  el  apartado  de  los  caracteres, secuencias de escape es el conjunto de caracteres que en el c\u00f3digo es interpretado con alg\u00fan fin. En Java, la barra invertida <code>\\</code> se denomina car\u00e1cter de escape, el cual indica que el car\u00e1cter puesto  a  continuaci\u00f3n  ser\u00e1  convertido  en  car\u00e1cter  especial  o,  si  ya  es  especial,  dejar\u00e1  de  ser especial.  Por  ejemplo,  el  car\u00e1cter <code>n</code> no es especial  pero  con  la <code>\\</code> delante  se  convierte  en especial ya que <code>\\n</code> se interpreta como un salto de l\u00ednea. La <code>\\</code>  es un car\u00e1cter especial pero con otra <code>\\</code> delante deja de ser especial y simplemente es una barra invertida.</p> <p>En las expresiones regulares tambi\u00e9n se utiliza la barra invertida <code>\\</code>  como car\u00e1cter de escape.</p> <p>Veamos la \u00faltima l\u00ednea del c\u00f3digo anterior  <code>\"\\\\\".matches(\"\\\\\\\\\")</code>: la cadena <code>\"\\\\\"</code> es una barra  invertida,  y  el  argumento  del  matches  <code>\"\\\\\\\\\"</code>   son  dos  barras  invertidas  ya  que  la expresi\u00f3n regular de la barra invertida son dos barras tal y como podemos observar en la tabla anterior.</p> </li> <li> <p>Logical Operators</p> Construct Matches XY X seguido Y X Y <pre><code>public class LogicalOperators {\npublic static void main(String[] args) {\nSystem.out.println(\"hola\".matches(\"hola\")); //true\nSystem.out.println(\"hol\".matches(\"hola\")); //false\nSystem.out.println(\"hola\".matches(\"hola|adios\")); //true\nSystem.out.println(\"adios\".matches(\"hola|adios\")); //true\nSystem.out.println(\"hol\".matches(\"hola|adios\")); //false\nSystem.out.println(\"Adios\".matches(\"hola|adios\")); //false\n}\n}\n</code></pre> </li> <li> <p>Character classes</p> Construct Matches [abc] a, b, o c (simple class) [^abc] Cualquier car\u00e1cter excepto a, b o c (negaci\u00f3n) [a-zA-Z] Desde la a hasta la z o desde la A hasta la Z, ambos incluidos (rango) [a-d[m-p]] Desde la a hasta la d o desde la m hasta la p (union) [a-z&amp;&amp;[def]] d, e o f (intersecci\u00f3n) [a-z&amp;&amp;[^bc]] Desde la a a la z, excepto b y c (subtracci\u00f3n) [a-z&amp;&amp;[^m-p]] Desde la a a la z, excepto los caracteres que van de la m a la p (subtracci\u00f3n) <pre><code>public class CharactersClasses {\npublic static void main(String[] args) {\nSystem.out.println(\"a\".matches(\"[abc]\")); //true\nSystem.out.println(\"d\".matches(\"[abc]\")); //false\nSystem.out.println(\"a\".matches(\"[abc][abc]\")); //false\nSystem.out.println(\"ac\".matches(\"[abc][abc]\")); //true\nSystem.out.println(\"ad\".matches(\"[abc][abc]\")); //false\nSystem.out.println(\" a\".matches(\"[abc ][abc]\")); //true\nSystem.out.println(\"d\".matches(\"[^abc]\")); //true\nSystem.out.println(\"a\".matches(\"[^abc]\")); //false\nSystem.out.println(\"d\".matches(\"[^abc][^abc]\")); //false\nSystem.out.println(\"de\".matches(\"[^abc][^abc]\")); //true\nSystem.out.println(\"da\".matches(\"[^abc][^abc]\")); //false\nSystem.out.println(\"A\".matches(\"[a-zA-Z]\")); //true\nSystem.out.println(\"9\".matches(\"[a-zA-Z]\")); //false\nSystem.out.println(\"A\".matches(\"[a-zA-Z][a-zA-Z]\")); //false\nSystem.out.println(\"Az\".matches(\"[a-zA-Z][a-zA-Z]\")); //true\nSystem.out.println(\"A9\".matches(\"[a-zA-Z][a-zA-Z]\")); //false\nSystem.out.println(\"b\".matches(\"[a-d[m-p]]\")); //true\nSystem.out.println(\"n\".matches(\"[a-d[m-p]]\")); //true\nSystem.out.println(\"s\".matches(\"[a-d[m-p]]\")); //false\nSystem.out.println(\"d\".matches(\"[a-z&amp;&amp;[def]]\")); //true\nSystem.out.println(\"a\".matches(\"[a-z&amp;&amp;[def]]\")); //false\nSystem.out.println(\"d\".matches(\"[a-z&amp;&amp;[^bc]]\")); //true\nSystem.out.println(\"b\".matches(\"[a-z&amp;&amp;[^bc]]\")); //false\nSystem.out.println(\"d\".matches(\"[a-z&amp;&amp;[^m-p]]\")); //true\nSystem.out.println(\"n\".matches(\"[a-z&amp;&amp;[^m-p]]\")); //false\n}\n}\n</code></pre> </li> <li> <p>Predefined character clasess</p> Construct Matches . Cualquier car\u00e1cter (puede o no ser determinadores de l\u00ednea) \\d Un d\u00edgito: [0-9] \\D Un no d\u00edgito: [^0-9] \\s Un car\u00e1cter de espacio en blanco: [\\t\\n\\x0B\\f\\r] \\S Un no car\u00e1cter de espacio en blanco: [^\\s] \\w Un car\u00e1cter de palabra: [a-zA-Z_0-9] \\W Un no car\u00e1cter de palabra: [^\\w] <p>Estas  expresiones  regulares  van  contenidas  en  una  cadena.  Entonces,  aquellas  expresiones regulares que lleven una barra invertida, como por ejemplo  <code>\\d</code>, tienen que llevar otra barra invertida <code>\\</code> delante ya que en las cadenas una barra invertida se expresa como <code>\\\\</code>.</p> </li> <li> <p>POSIX character classes (US-ASCII only)</p> Construct Matches \\p{Lower} Un car\u00e1cter alfab\u00e9tico en min\u00fascula: [a-z] \\p{Upper} Un car\u00e1cter alfab\u00e9tico en may\u00fasculas: [A-Z] \\p{ASCII} Todo caracteres ASCII: [\\x00-\\x7F] \\p{Alpha} Un car\u00e1cter alfab\u00e9tico: [\\p{Lower}\\p{Upper}] \\p{Digit} Un car\u00e1cter decimal: [0-9] \\p{Alnum} Un car\u00e1cter alfanum\u00e9rico: [\\p{Alpha}\\p{Digit}] \\p{Punct} Puntuaci\u00f3n: !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{}~ \\p{Graph} Un car\u00e1cter visible: [\\p{Alnum}\\p{Punct}] \\p{Print} Un car\u00e1cter imprimible: [\\p{Graph}\\x20] \\p{Blank} Un espacio o una tabulaci\u00f3n: [ \\t] \\p{Cntrl} Un car\u00e1cter de control: [\\x00-\\x1F\\x7F] \\p{XDigit} Un d\u00edgito hexadecimal: [0-9a-fA-F] \\p{Space} Un car\u00e1cter de espacio en blanco: [\\t\\n\\x0B\\f\\r] <p>En los caracteres imprimibles (\\p{Print}), \\x20 es el car\u00e1cter espacio.</p> <pre><code>public class PosixCharactersClasses {\npublic static void main(String[] args) {\nSystem.out.println(\"a\".matches(\"\\\\p{Lower}\"));//true\nSystem.out.println(\"A\".matches(\"\\\\p{Lower}\"));//false\nSystem.out.println(\"A\".matches(\"\\\\p{Upper}\"));//true\nSystem.out.println(\"a\".matches(\"\\\\p{Upper}\"));//false\nSystem.out.println(\"aC\".matches(\"\\\\p{Lower}\\\\p{Upper}\"));//true\nSystem.out.println(\"a\".matches(\"\\\\p{Alpha}\"));//true\nSystem.out.println(\"A\".matches(\"\\\\p{Alpha}\"));//true\nSystem.out.println(\"8\".matches(\"\\\\p{Alpha}\"));//false\nSystem.out.println(\"8\".matches(\"\\\\p{Digit}\"));//true\nSystem.out.println(\"A\".matches(\"\\\\p{Digit}\"));//false\nSystem.out.println(\"8A\".matches(\"\\\\p{Digit}\\\\p{Alpha}\"));//true\nSystem.out.println(\"A\".matches(\"\\\\p{Alnum}\"));//true\nSystem.out.println(\"8\".matches(\"\\\\p{Alnum}\"));//true\nSystem.out.println(\"a\".matches(\"\\\\p{Alnum}\"));//true\nSystem.out.println(\"\\n\".matches(\"\\\\p{Alnum}\"));//false\nSystem.out.println(\"?\".matches(\"\\\\p{Punct}\"));//true\nSystem.out.println(\"!\".matches(\"\\\\p{Punct}\"));//true\nSystem.out.println(\";\".matches(\"\\\\p{Punct}\"));//true\nSystem.out.println(\"a\".matches(\"\\\\p{Punct}\"));//false\nSystem.out.println(\" \".matches(\"\\\\p{Blank}\"));//true\nSystem.out.println(\"\\t\".matches(\"\\\\p{Blank}\"));//true\nSystem.out.println(\"\\n\".matches(\"\\\\p{Blank}\"));//false\nSystem.out.println(\" \".matches(\"\\\\p{Space}\"));//true\nSystem.out.println(\"\\t\".matches(\"\\\\p{Space}\"));//true\nSystem.out.println(\"\\n\".matches(\"\\\\p{Space}\"));//true\nSystem.out.println(\"a\".matches(\"\\\\p{Space}\"));//false\n}\n}\n</code></pre> </li> <li> <p>Boundary matchers</p> Construct Matches ^ Principio de una l\u00ednea $ Final de una l\u00ednea \\b L\u00edmite de una palabra \\B L\u00edmite de una no-palabra <pre><code>public class BoundaryMatchers {\npublic static void main(String[] args) {\nSystem.out.println(\"hola\".matches(\"^hola\"));//true\nSystem.out.println(\"hola9\".matches(\"^hola\"));//false\nSystem.out.println(\"hola9\".matches(\"^hola\\\\d\"));//true\nSystem.out.println(\"ab\".matches(\"^[aA]\\\\p{Lower}\"));//true\nSystem.out.println(\"bA\".matches(\"^[aA]\\\\p{Upper}\"));//false\nSystem.out.println(\"hhola\".matches(\".hola$\"));//true\nSystem.out.println(\"hola\".matches(\".hola$\"));//false\nSystem.out.println(\"9hola\".matches(\"\\\\dhola$\"));//true\nSystem.out.println(\"hc\".matches(\".[abc]$\"));//true\nSystem.out.println(\"ch\".matches(\".[abc]$\"));//false\n// (1)!\nSystem.out.println(\"hola\".matches(\"\\\\bhol.\"));//true, hol est\u00e1 al principio de una palabra\nSystem.out.println(\"hola\".matches(\".ola\\\\b\"));//true, ola est\u00e1 al final de una palabra\n//(2)!\nSystem.out.println(\"hola\".matches(\"\\\\bhola\\\\b\"));//true, hola est\u00e1 al principio y al final\n// \\B es justo lo contrario que \\b\nSystem.out.println(\"abc\".matches(\".\\\\Bb\\\\B.\"));//true, b no est\u00e1 al principio ni al final\nSystem.out.println(\"abc\".matches(\"a\\\\B..\"));//true, a no est\u00e1 al final\n}\n}\n</code></pre> <ol> <li>La expresi\u00f3n regular \\b se llama l\u00edmite de palabra ya que busca en los l\u00edmites de una palabra, al principio o al final.</li> <li>Para realizar una b\u00fasqueda de palabras espec\u00edficas se coloca la palabra entre dos l\u00edmites de palabra:</li> </ol> </li> </ul>"},{"location":"bloque_i/tema_3/page-3/#la-clase-pattern","title":"La clase Pattern","text":"<p>En Java disponemos de las clases Pattern y Matcher para poder hacer uso de las expresiones regulares. Ambas se encuentran en el paquete <code>java.util.regex</code>.</p> <p>La  clase  Pattern  nos  permite  definir  el  patr\u00f3n,  es  decir,  representa  a  la  expresi\u00f3n  regular. Veamos algunos m\u00e9todos de esta clase:</p> <ul> <li>compile: crea un patr\u00f3n a partir de una expresi\u00f3n regular.</li> <li>pattern: devuelve la expresi\u00f3n regular a partir de la cual se cre\u00f3 el patr\u00f3n.</li> <li>matches: indica si la cadena coincide o no con la expresi\u00f3n regular.</li> </ul> <pre><code>import java.util.regex.Pattern;\npublic class PatternClass {\npublic static void main(String[] args) {\nPattern pattern = Pattern.compile(\"\\\\p{Upper}\\\\p{Lower}\");\nSystem.out.println(pattern.pattern());\nSystem.out.println(Pattern.matches(\"\\\\p{Upper}\\\\p{Lower}\",\n\"Ho\"));//true\nSystem.out.println(Pattern.matches(\"\\\\p{Upper}\\\\p{Lower}\",\n\"ho\"));//false\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-3/#la-clase-matcher","title":"La clase Matcher","text":"<p>La clase Matcher realiza operaciones de coincidencia del patr\u00f3n en una secuencia de caracteres.</p> <p>Se puede crear un objeto de tipo Matcher mediante el m\u00e9todo matcher de la clase Pattern. Una vez creado, un matcher puede ser utilizado para realizar tres tipos diferentes de operaciones:</p> <ul> <li>matches: intenta hacer coincidir toda la secuencia de entrada con el patr\u00f3n.</li> <li>lookingAt: intenta hacer coincidir el principio de la secuencia de entrada con el patr\u00f3n.</li> <li>find: intenta encontrar la pr\u00f3xima secuencia de entrada que coincide con el patr\u00f3n. Si hay varias coincidencias con el patr\u00f3n dentro del mismo texto, cada llamada a find devolver\u00e1 la siguiente coincidencia.</li> <li>start: devuelve el \u00edndice de la secuencia de entrada donde empieza la coincidencia del \u00faltimo find</li> <li>end: devuelve el \u00edndice de la secuencia de entrada el car\u00e1cter que est\u00e1 justo despu\u00e9s del \u00faltimo de la coincidencia del \u00faltimo find.</li> <li>reset: resetea el matcher.</li> </ul> <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class MatcherClass {\npublic static void main(String[] args) {\nint count;\nPattern pattern = Pattern.compile(\"es\", Pattern.CASE_INSENSITIVE);//(1)!\nMatcher matcher = pattern.matcher(\"Estoy en Espa\u00f1a\");\nSystem.out.println(matcher.matches());//false   \nSystem.out.println(matcher.lookingAt());//true\nmatcher.reset(\"Esto es un escrito en espa\u00f1ol\");\ncount = 0;\nwhile (matcher.find()) {\ncount++;\nSystem.out.printf(\"Coincidencia n\u00famero %d: empieza en %d y termina en %d\\n\", count, matcher.start(), matcher.end() - 1);\n}\n}\n}\n</code></pre> <ol> <li>Con Pattern.CASE_INSENSITIVE, no se distingue entre may\u00fasculas y min\u00fasculas</li> </ol> <p>La expresi\u00f3n regular . coincide con cualquier car\u00e1cter excepto un terminador de l\u00ednea, a menos que se especifique la bandera DOTALL.</p> <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class Point {\npublic static void main(String[] args) {\nPattern pattern = Pattern.compile(\".\", Pattern.DOTALL);\nMatcher matcher = pattern.matcher(\"\\n\");\nSystem.out.println(matcher.matches());//true\nSystem.out.println(\"\\n\".matches(\".\"));//false\n}\n}\n</code></pre> <p>Veamos m\u00e1s ejemplos de boundary matchers utilizando objetos de tipo Matcher:</p> <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class BoundaryMatchersAvanzed {\npublic static void main(String[] args) {\nString text = \"Esto es un texto escrito en espa\u00f1ol\";\nPattern pattern;\nMatcher matcher;\npattern = Pattern.compile(\"\\\\be\", Pattern.CASE_INSENSITIVE);\nmatcher = pattern.matcher(text);\nSystem.out.println(\"Las palabras que empiezan por e o por E se  encuentran en las siguientes posiciones:\");\nwhile (matcher.find()) {\nSystem.out.println(matcher.start());\n}\npattern = Pattern.compile(\"\\\\Be\");\nmatcher = pattern.matcher(text);\nSystem.out.println(\"Las e que no son comienzos de palabra se encuentran en las siguientes posiciones:\");\nwhile (matcher.find()) {\nSystem.out.println(matcher.start());\n}\npattern = Pattern.compile(\"o\\\\b\");\nmatcher = pattern.matcher(text);\nSystem.out.println(\"Las o que son finales de palabras se encuentran en las siguientes posiciones:\");\nwhile (matcher.find()) {\nSystem.out.println(matcher.start());\n}\npattern = Pattern.compile(\"o\\\\B\");\nmatcher = pattern.matcher(text);\nSystem.out.println(\"Las o que no son finales de palabras se encuentran en las siguientes posiciones:\");\nwhile (matcher.find()) {\nSystem.out.println(matcher.start());\n}\n/*\n         * Para realizar una b\u00fasqueda de palabras espec\u00edficas se coloca la palabra entre\n         * dos l\u00edmites de palabra:\n         */\npattern = Pattern.compile(\"\\\\btexto\\\\b\");\nmatcher = pattern.matcher(text);\nSystem.out.println(\"La palabra texto se encuentra en las siguientes posiciones:\");\nwhile (matcher.find()) {\nSystem.out.println(matcher.start());\n}\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-3/#quantifiers-cuantificadores","title":"Quantifiers (cuantificadores)","text":"<ul> <li> <p>Greedy quantifiers</p> <p>Por defecto los cuantificadores son greedy. Se llaman greedy (glot\u00f3n) porque tratan de coger lo m\u00e1ximo posible de la cadena pero siempre intentando que el patr\u00f3n completo se cumpla.</p> Construct Matches X? X, una vez o ninguna X* X, ninguna o m\u00e1s veces X+ X, una o m\u00e1s veces X{n} X, exactamente n veces X{n,} X, al menos n veces X{n,m} X, al menos n pero no m\u00e1s de m <pre><code>public class GreedyQuantifiers {\npublic static void main(String[] args) {\nSystem.out.println(\"a\".matches(\"a?\"));//true\nSystem.out.println(\"\".matches(\"a?\"));//true\nSystem.out.println(\"b\".matches(\"a?\"));//false\nSystem.out.println(\"a\".matches(\"a*\"));//true\nSystem.out.println(\"\".matches(\"a*\"));//true\nSystem.out.println(\"aaaa\".matches(\"a*\"));//true\nSystem.out.println(\"b\".matches(\"a*\"));//false\nSystem.out.println(\"a\".matches(\"a+\"));//true\nSystem.out.println(\"aaaa\".matches(\"a+\"));//true\nSystem.out.println(\"\".matches(\"a+\"));//false\nSystem.out.println(\"b\".matches(\"a+\"));//false\nSystem.out.println(\"aaa\".matches(\"a{3}\"));//true\nSystem.out.println(\"aaa\".matches(\"a{4}\"));//false\nSystem.out.println(\"aaa\".matches(\"a{3,}\"));//true\nSystem.out.println(\"aaaaa\".matches(\"a{3,}\"));//true\nSystem.out.println(\"aa\".matches(\"a{3,}\"));//false\nSystem.out.println(\"aaa\".matches(\"a{3,6}\"));//true\nSystem.out.println(\"aaaaaa\".matches(\"a{3,6}\"));//true\nSystem.out.println(\"aa\".matches(\"a{3,6}\"));//false\nSystem.out.println(\"aaaaaaa\".matches(\"a{3,6}\"));//false\n}\n}\n</code></pre> </li> <li> <p>Reluctant quantifiers</p> <p>Otro posible comportamiento es reluctant (reacio, reticente). Este comportamiento es el contrario de greedy, trata de coger lo menos posible pero siempre intentando que se cumpla el patr\u00f3n.</p> Construct Matches X?? X, una vz o ninguna X*? X, cero o m\u00e1s veces X+? X, una o m\u00e1s veces X{n,}? X, al menos n veces X{n,m}? X, al menos n veces pero no m\u00e1s que m veces <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class ReluctantQuantifiers {\npublic static void main(String[] args) {\nPattern patternGreedy = Pattern.compile(\"a+\");\nPattern patternReluctant = Pattern.compile(\"a+?\");\nMatcher matcherGreedy = patternGreedy.matcher(\"aaaa\");\nMatcher matcherReluctant = patternReluctant.matcher(\"aaaa\");\nwhile (matcherGreedy.find()) {\nSystem.out.printf(\"Greedy: coincidencia desde %d hasta %d\\n\",\nmatcherGreedy.start(), matcherGreedy.end() - 1);\n}\nwhile (matcherReluctant.find()) {\nSystem.out.printf(\"Reluctant: coincidencia desde %d hasta %d\\n\",\nmatcherReluctant.start(), matcherReluctant.end() - 1);\n}\n}\n}\n</code></pre> </li> <li> <p>Possessive quantifiers</p> <p>Tratan  de  coger  lo  m\u00e1ximo  posible  de  la  cadena  pero  no  se  preocupan  de  que  se  cumpla  el patr\u00f3n. Este comportamiento se usa \u00fanicamente por motivos de eficiencia. Si en la cadena hay un trozo que queramos quitar y que podamos distinguir con una expresi\u00f3n regular, podemos ponerlo con este modo possessive. De esta forma, el possessive se comer\u00e1 directamente ese trozo de cadena y no perder\u00e1 el tiempo tratando de hacer casar ese trozo con el patr\u00f3n de alguna u otra forma.</p> <p>Se escriben como los greedy pero a\u00f1adiendo un + detr\u00e1s.</p> Construct Matches X?+ X, una vz o ninguna X*+ X, cero o m\u00e1s veces X++ X, una o m\u00e1s veces X{n,}+ X, al menos n veces X{n,m}+ X, al menos n veces pero no m\u00e1s que m veces <pre><code>public class PossessiveQuantifiers {\npublic static void main(String[] args) {\nPattern patternGreedy = Pattern.compile(\"a+a\");\nPattern patternPossessive = Pattern.compile(\"a++a\");\nMatcher matcherGreedy = patternGreedy.matcher(\"aaaa\");\nMatcher matcherPossessive = patternPossessive.matcher(\"aaaa\");\nwhile (matcherGreedy.find()) {\nSystem.out.printf(\"Greedy: coincidencia desde %d hasta %d\\n\",\nmatcherGreedy.start(), matcherGreedy.end() - 1);\n}\nwhile (matcherPossessive.find()) {\nSystem.out.printf(\"Possessive: coincidencia desde %d hasta %d\\n\",\nmatcherPossessive.start(), matcherPossessive.end() - 1);\n}\n}\n}\n</code></pre> <p>En el modo possessive, con la primera parte del patr\u00f3n a++ ya coge la cadena completa <code>\"aaaa\"</code>. Como no se preocupa de que el patr\u00f3n se cumpla, entonces la \u00faltima <code>a</code> del patr\u00f3n ya no tiene coincidencia con lo que el find devuelve false.</p> </li> </ul>"},{"location":"bloque_i/tema_3/page-3/#grupos","title":"Grupos","text":"<p>Los grupos sirven para extraer partes de una cadena y se marcan con un par\u00e9ntesis en la expresi\u00f3n regular. Cuando se encuentra una coincidencia en un texto, se puede acceder a la parte que se encuentra dentro del grupo a trav\u00e9s del m\u00e9todo group. Una expresi\u00f3n regular puede tener m\u00e1s de un grupo, en cuyo caso cada uno lleva sus propios par\u00e9ntesis. El grupo con n\u00famero 0 es toda la expresi\u00f3n regular y los grupos marcados con par\u00e9ntesis empiezan a enumerarse a partir del 1. Tambi\u00e9n puede hacer grupos dentro de otros grupos, como en el siguiente ejemplo, donde el grupo 2 y grupo 3 est\u00e1n dentro del grupo 1.</p> <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class Group {\npublic static void main(String[] args) {\nPattern pattern = Pattern.compile(\"((\\\\d+)\\\\+(\\\\d+))=(\\\\d+)\");\nMatcher matcher = pattern.matcher(\"23+56=79;15+13=28;30+60=90\");\nwhile (matcher.find()) {\nSystem.out.println(matcher.group(0));\nSystem.out.printf(\"Sumandos: %s\\n\", matcher.group(1));\nSystem.out.printf(\"Sumando 1: %s\\n\", matcher.group(2));\nSystem.out.printf(\"Sumando 2: %s\\n\", matcher.group(3));\nSystem.out.printf(\"Resultado: %s\\n\\n\", matcher.group(4));\n}\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-3/#reemplazar-partes-de-una-cadena","title":"Reemplazar partes de una cadena","text":"<p>La clase Matcher tiene m\u00e9todos para reemplazar partes de la cadena que cumplan con el patr\u00f3n:</p> <ul> <li>replaceAll: reemplaza todas las coincidencias.</li> <li>replaceFirst: reemplaza solamente la primera coincidencia.</li> </ul> <pre><code>import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class Replace {\npublic static void main(String[] args) {\nPattern pattern = Pattern.compile(\"\\\\d\");\nMatcher matcher = pattern.matcher(\"Tengo 20 a\u00f1os y vivo en la calle Puerto Real 15\");\nString replaceAll = matcher.replaceAll(\"*\");\nString replaceFirst = matcher.replaceFirst(\"*\");\nSystem.out.printf(\"replaceAll: %s\\n\", replaceAll);\nSystem.out.printf(\"replaceFirst: %s\\n\", replaceFirst);\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-3/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Crea y comprueba las siguientes expresiones regulares:</p> <ol> <li>que la cadena sea exactamente \u201ctrue\u201d.</li> <li>que la cadena sea de tres letras, may\u00fasculas o min\u00fasculas.</li> <li>que la cadena contenga 5 o m\u00e1s caracteres que no sean la \u00f1, la z ni la x.</li> <li>que la cadena no empiece con un n\u00famero.</li> <li>que la cadena tenga varios caracteres excepto la b.</li> <li>que la cadena sea un n\u00famero de tel\u00e9fono.</li> <li>que la cadena sea un DNI.</li> <li>que la cadena sea un nombre, es decir, que no tenga espacios, que no sea una cadena vac\u00eda y que empiece por may\u00fasculas.</li> <li>que la cadena empiece con vocal y luego tenga varias consonantes o ninguna.</li> <li>que la cadena tenga un n\u00famero positivo m\u00e1s peque\u00f1o que 300.</li> </ol> Ejercicio 2 <p>Dada una cadena que contiene c\u00f3digo en Java, mostrar lo siguiente:</p> <ol> <li>En qu\u00e9 car\u00e1cter empiezan los comentarios de una l\u00ednea.</li> <li>En qu\u00e9 car\u00e1cter empiezan los bloques de c\u00f3digo.</li> <li>En qu\u00e9 car\u00e1cter empiezan y terminan los comentarios de m\u00e1s de 1 l\u00ednea.</li> <li>En qu\u00e9 car\u00e1cter empiezan y terminan las declaraciones de variables de tipo int. Ejemplos:<ul> <li>int a;</li> <li>int number=5;</li> <li>int i=0,j=10,k;</li> </ul> </li> </ol> Ejercicio 3 <p>Dada una cadena que contiene c\u00f3digo en Java, mostrar lo siguiente utilizando grupos:</p> <ol> <li>El nombre del paquete.</li> <li>Las clases que se importan con sus rutas de paquetes. Ejemplo: java.util.regex.Pattern</li> <li>Las condiciones de los while.</li> </ol> Ejercicio 4 <p>Dada una cadena que contiene c\u00f3digo en Java, reemplazar los int por byte y los double por float</p>"},{"location":"bloque_i/tema_3/page-4/","title":"Proyecto","text":"<p>Se va a realizar un proyecto que va a contener una librer\u00eda con m\u00e9todos y clases \u00fatiles para facilitar ciertas operaciones.</p> <p>En esta primera parte se llevar\u00e1 a cabo la creaci\u00f3n de la clase de utilidad Strings que contendr\u00e1 los m\u00e9todos de utilidad para mejorar y facilitar el trabajo con cadenas.</p> <p>Realiza los m\u00e9todos que consideres para realizar estas operaciones:</p> <ul> <li>Comprobar si una cadena no est\u00e1 vac\u00eda.</li> <li>Comprobar si una cadena no es una cadena compuesta solamente por espacios.</li> <li>Comprobar si una cadena es num\u00e9rica.</li> <li>Comprobar si una cadena es alfab\u00e9tica.</li> <li>Comprobar si una cadena es alfanum\u00e9rica.</li> <li>Comprobar si una cadena es \u00fanicamente contiene caracteres especiales: !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{}~</li> <li>Comprobar si una cadena es un espacio en blanco.</li> <li>Convertir una cadena en Upper Camel case. Ejemplo Hola mundo -&gt; \"Hola Mundo\"</li> <li>Convertir la primera letra de una cadena en may\u00fasculas. Ejemplo: hola mundo -&gt; Hola mundo</li> <li>Convertir la primera letra de una cadena en min\u00fasculas. Ejemplo: Hola mundo -&gt; hola mundo</li> <li>Centrar una cadena dada una tama\u00f1o m\u00e1ximo de pantalla.</li> <li>Mostrar una cadena con ellipsis dado un tama\u00f1o m\u00e1ximo.</li> <li>Mostrar una cadena con saltos dado un tama\u00f1o m\u00e1ximo</li> <li>Comprobar si una cadena es pal\u00edndroma, es decir, que se pueda leer exactamente igual del derecho que del rev\u00e9s. Por ejemplo: Roma ni se conoce sin oro, ni se conoce sin amor</li> <li>Contar el n\u00famero de palabras de una cadena.</li> <li>Contar el n\u00famero de veces que aparece una subcadena en una cadena.</li> <li>Contar el n\u00famero de veces que una cadena cumple un patr\u00f3n.</li> <li>Comprobar si una cadena cumple una expresi\u00f3n.</li> <li>Comprobar si una cadena tiene un formato email.</li> <li>Comprobar si una cadena tiene un formato telef\u00f3nico.</li> <li>Comprobar si una cadena tiene un formato de contrase\u00f1a b\u00e1sica, es decir, que tenga como m\u00ednimo 8 caracteres.</li> <li>Comprobar si una cadena tiene un formato de contrase\u00f1a compleja, es decir, que tenga como m\u00ednimo 8 caracteres, una min\u00fascula, una may\u00fascula, un d\u00edgito y un car\u00e1cter especial.</li> <li>Comprobar si una cadena es un DNI o NIE v\u00e1lido.</li> <li>Comprobar si una cadena es una matr\u00edcula de coche v\u00e1lido.</li> </ul> <p>Adem\u00e1s se crear\u00e1 una clase de utilidad Maths que contendr\u00e1 m\u00e9todos que facilite trabajar con operaciones matem\u00e1ticas:</p> <ul> <li>Comprobar si un n\u00famero es par.</li> <li>Comprobar si un n\u00famero es impar.</li> <li>Calcular el m\u00ednimo com\u00fan m\u00faltiplo de dos n\u00fameros.</li> <li>Calcular el m\u00ednimo com\u00fan m\u00faltiplo de tres n\u00fameros.</li> <li>Calcular el m\u00e1ximo com\u00fan divisor de dos n\u00fameros.</li> <li>Calcular el m\u00e1ximo com\u00fan divisor de tres n\u00fameros.</li> <li>Invertir un n\u00famero.</li> <li>Contar el n\u00famero de cifras que tiene.</li> <li>Comprobar si un n\u00famero es perfecto.</li> <li>Comprobar si un n\u00famero es primo.</li> <li>Comprobar si un n\u00famero es compuesto.</li> <li>Calcular el factorial de un n\u00famero.</li> </ul> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ol> <li>Se crear\u00e1 un paquete principal llamado <code>com.NOMBRE.common</code> donde nombre ser\u00e1 el nombre del alumno y common el nombre del proyecto.</li> <li>Se crear\u00e1 una clase Main, donde se ponga en pr\u00e1ctica los usos de la librer\u00eda y se valorar\u00e1 la complejidad de dicho Main.</li> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>Sobrescribe los m\u00e9todos que consideres oportunos.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre pr03java-NOMBRE-strings siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>Se har\u00e1 uso de la recursividad donde sea necesario.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ol>"},{"location":"bloque_i/tema_4/page-1/","title":"1 Clases vs Objetos","text":""},{"location":"bloque_i/tema_4/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es una t\u00e9cnica de programar aplicaciones basada en una serie de objetos independientes que se comunican entre s\u00ed.</p> <p>A Java se le considera un lenguaje orientado a objetos ya que siempre que se crea un programa en Java, por simple que sea, se necesita declarar una clase, y el concepto de clase pertenece a la programaci\u00f3n orientada a objetos.</p> <p>Un  objeto  es  un  elemento  del  programa  que  integra  sus  propios  datos  y  su  propio funcionamiento. Es decir, un objeto est\u00e1 formado por datos (atributos o propiedades) y por las funciones que es capaz de realizar el objeto (m\u00e9todos). Esta forma de programar se asemeja m\u00e1s al pensamiento humano. La cuesti\u00f3n es detectar adecuadamente los objetos necesarios para una aplicaci\u00f3n. De hecho hay que detectar las distintas clases de objetos.</p> <p>Una clase es lo que define a un tipo de objeto. Al definir una clase lo que se hace es indicar como funciona un determinado tipo de objeto. Luego, a partir de la clase, podremos crear objetos de esa  clase,  es  decir,  la  clase  es  como  un  molde  a  partir  del  cual  se  crean  los  objetos  que pertenecen  a  ella.  Realmente  la  programaci\u00f3n  orientada  a  objetos  es  una  programaci\u00f3n orientada a clases. Es decir, lo que necesitamos programar es como funcionan las clases de objetos.</p> <p>Por ejemplo, una clase podr\u00eda ser la clase Coche. Cuando se defina esta clase, indicaremos los atributos o propiedades (como el color, modelo, marca, velocidad m\u00e1xima,...) y los m\u00e9todos (arrancar, parar, repostar, acelerar, frenar...). Todos los coches, es decir, todos los objetos de la clase Coche, tendr\u00e1n esas propiedades y esos m\u00e9todos. Para explicar la diferencia entre clase y objeto:</p> <ul> <li>la clase Coche representa a todos los coches.</li> <li>un coche concreto es un objeto, es decir, un ejemplar de una clase es un objeto. Tambi\u00e9n se le llama a los objetos instancias de la clase. Este t\u00e9rmino procede del ingl\u00e9s, instance, que realmente significa ejemplar.</li> </ul> <p>Por ejemplo, si quisi\u00e9ramos crear el juego del parch\u00eds en Java, una clase ser\u00eda la casilla, otra las fichas,  otra  el  dado,  etc.  En  el caso de la  casilla,  se  definir\u00eda  la  clase  para  indicar  su funcionamiento y sus propiedades, y luego se crear\u00edan tantos objetos casilla como casillas tenga el juego. Lo mismo ocurrir\u00eda con las fichas, la clase ficha definir\u00eda las propiedades de la ficha (color  y  posici\u00f3n  por  ejemplo)  y  su  funcionamiento  mediante  sus  m\u00e9todos  (por  ejemplo  un m\u00e9todo ser\u00eda mover, otro llegar a la meta, etc), luego se crear\u00edan tantos objetos ficha como fichas tenga el juego.</p>"},{"location":"bloque_i/tema_4/page-1/#creacion-de-clases","title":"Creaci\u00f3n de clases","text":"<p>Una clase sirve para definir una serie de objetos con propiedades (atributos), comportamientos (m\u00e9todos)  y  sem\u00e1ntica  comunes.  Hay  que  pensar  en  una  clase  como  un  molde  para  crear objetos.</p> <p>La definici\u00f3n de una clase incluye lo siguiente:</p> <ul> <li>El nombre o identificador de clase. Debe empezar con letra may\u00fascula y seguir letras min\u00fasculas,  y  si  consta  de  varias palabras,  se  utiliza  la  notaci\u00f3n  UpperCamelCase. Tambi\u00e9n pueden contener n\u00fameros pero no como primer car\u00e1cter. Por ejemplo, <code>1Coche</code> no  es  un  identificador  v\u00e1lido  de  clase,  pero <code>Coche1</code> s\u00ed  ser\u00eda  v\u00e1lido.  Veamos  algunos consejos a la hora de elegir los identificadores de las clases:<ul> <li>Evitar abreviaturas a favor de la legibilidad del c\u00f3digo. Es muy importante que el nombre de las clases sea claro y simbolice perfectamente al tipo de objetos que representa.</li> <li>Evitar  nombres  excesivamente  largos.Aunque  parece  que  se  contradice  con  la norma anterior, se trata de que los nombres sean concisos. No es conveniente que sean descripciones de clase, para eso ya est\u00e1n los comentarios javadoc.</li> <li>Utilizar nombres ya reconocidos. Hay abreviaturas reconocidas como por ejemplo TCP,  por  eso  el  nombre  de  clase  <code>ManejadorTCP</code> es  mejor  que <code>ManejadorProtocoloControlTransmision</code> .</li> </ul> </li> <li>Los atributos, tambi\u00e9n llamados propiedades o campos. Los atributos son variables que poseer\u00e1 cada objeto de la clase y por lo tanto marcar\u00e1n el estado de los mismos. Por ejemplo, un coche puede estar parado, en marcha, estropeado, funcionando, sin gasolina, etc. El estado lo marca el valor que tengan los atributos del objeto.</li> <li>Los m\u00e9todos. Son las acciones que pueden realizar los objetos de la clase, es decir, lo que determina el comportamiento de los objetos.</li> </ul> <p>En Java, cada clase se define en un archivo. Adem\u00e1s, el nombre de la clase y el del archivo tiene que ser el mismo. Es decir, si queremos definir la clase Vehicle, tendremos que hacerlo en un archivo llamado Vehicle.java. Dicho archivo contiene la definici\u00f3n de la clase Vehicle:</p> <pre><code>public class Vehicle {\nint wheelCount; // N\u00ba ruedas\ndouble speed; // Velocidad\nString color; // Color del veh\u00edculo\nvoid accelerate(double amount){ // acelerar\nspeed += amount;\n}\nvoid brake(double amount){ // frenar\nspeed -= amount;\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-1/#creacion-de-objetos","title":"Creaci\u00f3n de objetos","text":"<p>Una vez definida la clase, ya se pueden crear objetos de la misma. Para crear un objeto, hay que declarar una variable cuyo tipo ser\u00e1 la propia clase:</p> <pre><code>Vehicle car; //(1)!\n</code></pre> <ol> <li><code>car</code> es una variable de tipo Vehicle</li> </ol> <p>Una vez definida la variable, se le crea el objeto llamando a un m\u00e9todo que se llama constructor. Un constructor es un m\u00e9todo que se invoca cuando se crea un objeto y que sirve para inicializar los atributos del objeto y para realizar las acciones pertinentes que requiera el mismo para ser creado. El constructor tiene el mismo nombre que la clase y para invocarlo se utiliza el operador new.</p> <pre><code>car = new Vehicle(); //(1)!\n</code></pre> <ol> <li>Vehicle() es un m\u00e9todo constructor</li> </ol> <p>Tambi\u00e9n se puede hacer todo en la misma l\u00ednea:</p> <pre><code>Vehicle car = new Vehicle();\n</code></pre>"},{"location":"bloque_i/tema_4/page-1/#acceso-a-los-atributos-y-metodos-del-objeto","title":"Acceso a los atributos y m\u00e9todos del objeto","text":"<p>Una  vez  creado  el  objeto,  se  puede  acceder  a  sus  atributos  de  la  siguiente  manera: <code>objeto.atributo</code></p> <pre><code>car.wheelCount = 4; //(1)!\n</code></pre> <ol> <li>Se le asigna 4 al atributo n\u00famero de ruedas de la variable car-</li> </ol> <p>Los m\u00e9todos se utilizan de la misma forma que los atributos, a excepci\u00f3n de que los m\u00e9todos poseen  siempre  par\u00e9ntesis  ya  que  son  funciones  que  pertenecen  a  un  objeto: <code>objeto.m\u00e9todo(argumentos)</code>.</p> <pre><code>car.accelerate(30); //(1)!\n</code></pre> <ol> <li>El coche incrementa su velocidad a 30, es decir, si iba a 90km/h, despu\u00e9s de ejecutar el m\u00e9todo el coche va a 120km/h.</li> </ol> Ejercicio 1 <p>Crea un paquete llamado exercise01 el cual contenga una clase llamada Persona con los atributos: nombre, edad, altura y ocupaci\u00f3n. Crea una clase Main donde se le solicite al usuario el nombre de la persona, modif\u00edquelo y mu\u00e9strelo por pantalla.</p>"},{"location":"bloque_i/tema_4/page-2/","title":"2 Acceso y sobrecarga","text":""},{"location":"bloque_i/tema_4/page-2/#modificadores-de-acceso","title":"Modificadores de acceso","text":"<p>Los modificadores de acceso son palabras reservadas del lenguaje Java que determinan \u00e1mbitos de visibilidad de los atributos y   m\u00e9todos de una clase.</p> <p>Los modificadores de acceso son los siguientes:</p> <ul> <li>Private: el modificador private en Java es el m\u00e1s restrictivo de todos, cualquier elemento de una clase que sea privado puede ser accedido \u00fanicamente por la propia clase. Ninguna otra clase, sin importar la relaci\u00f3n que tengan, podr\u00e1 tener acceso a elementos privados.</li> <li>El modificador por defecto: Java nos da la opci\u00f3n de no usar un modificador de acceso y al no hacerlo, el elemento tendr\u00e1 un acceso conocido como default o friendly, que permite que tanto la propia clase como las clases del mismo paquete accedan a dichos elementos.</li> <li>Protected: lo veremos en el tema donde se explica el funcionamiento de la herencia en Java.</li> <li>Public: el modificador de acceso public es el m\u00e1s permisivo de todos, nos permite acceso a los elementos desde cualquier clase incluso de otros paquetes.</li> </ul> <p>Veamos una tabla que resume el funcionamiento de los modificadores de acceso en Java:</p> Private Friendly Public Misma clase x x x Mismo paquete x x Otro paquete x <p>El modificador se indica:</p> <ul> <li>Delante de class en la clase.</li> <li>Delante del tipo de datos en los atributos y m\u00e9todos.</li> </ul> <p>Veamos la clase Vehicle con los modificadores de acceso:</p> <pre><code>public class Vehicle {\nprivate int wheelCount; // N\u00ba ruedas\nprivate double speed; // Velocidad\nprivate String color; // Color del veh\u00edculo\npublic void accelerate(double amount){ // acelerar\nspeed += amount;\n}\npublic void brake(double amount){ // frenar\nspeed -= amount;\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-2/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<p>Java admite sobrecargar los m\u00e9todos, es decir, crear distintas variantes del mismo m\u00e9todo con el mismo nombre pero que se diferencien en el orden, tipo o n\u00famero de los par\u00e1metros.</p> <p>Por ejemplo, tenemos el m\u00e9todo para sumar <code>add(int x,int y)</code>:</p> <ul> <li>No  podr\u00edamos  definir  otro  m\u00e9todo <code>add(int  a,int  b)</code> porque  no  var\u00eda  el  tipo  ni  el n\u00famero de par\u00e1metros.</li> <li>S\u00ed podr\u00edamos definir <code>add(int a)</code> y <code>add(int  a,int  b,int  c)</code> porque  el  n\u00famero  de par\u00e1metros var\u00eda.</li> <li>Tambi\u00e9n podr\u00edamos definir <code>add(int x,double y)</code> porque aunque no var\u00ede el n\u00famero de par\u00e1metros, s\u00ed var\u00eda uno de los tipos.</li> </ul> <p>Otro ejemplo donde tenemos el m\u00e9todo <code>add(int x,double y)</code>:</p> <ul> <li>S\u00ed  podr\u00edamos  definir  el  m\u00e9todo <code>add(double  x,int  y)</code> porque  var\u00eda  el  orden  de  los par\u00e1metros.</li> </ul> <p>El tipo resultado de los m\u00e9todos sobrecargados puede ser igual o diferente.</p>"},{"location":"bloque_i/tema_4/page-2/#atributos-metodos-y-bloques-estaticos","title":"Atributos, m\u00e9todos y bloques est\u00e1ticos","text":"<p>El concepto de est\u00e1tico es que pertenece a la clase, por lo tanto, puede ser accedido o invocado sin la necesidad de tener que instanciar un objeto de la clase. Se indica con la palabra clave static.</p> <p>Los atributos y m\u00e9todos asociados a los objetos se les conoce como din\u00e1micos.</p> <p>Los atributos est\u00e1ticos son variables que pertenecen a la clase y son compartidos por todos los objetos  de  la  clase.  Son  inicializados  en  el  momento  en  que  se  carga  la  clase  en  memoria, respetando  el  orden  de  declaraci\u00f3n.  Para  acceder  a  un  atributo  est\u00e1tico,  hay  que  indicar  el nombre de la clase: <code>Clase.AtributoEst\u00e1tico</code></p> <p>Los m\u00e9todos est\u00e1ticos son m\u00e9todos que pertenecen a la clase y no al objeto por lo que pueden llamarse sin tener que crear un objeto de dicha clase. Para llamar a un m\u00e9todo est\u00e1tico, hay que indicar el nombre de la clase:  Clase.M\u00e9todoEst\u00e1tico(Argumentos) . Un m\u00e9todo est\u00e1tico solo puede acceder a datos est\u00e1ticos y llamar a m\u00e9todos est\u00e1ticos. No pueden utilizar el operador this ni super ya que son conceptos din\u00e1micos. Los m\u00e9todos est\u00e1ticos es lo m\u00e1s parecido a lo que son las funciones en los lenguajes estructurados con la diferencia que se encuentran encapsulados en una clase.</p> <p>Cada vez que creamos un programa en Java debemos especificar el m\u00e9todo main:</p> <pre><code>public static void main(String[] args)\n</code></pre> <p>El m\u00e9todo main es est\u00e1tico para que la m\u00e1quina virtual de Java pueda llamarlo directamente sin tener que crear un objeto de la clase que lo contiene.</p> <p>Ejemplos de llamadas a m\u00e9todos din\u00e1micos y est\u00e1ticos:</p> <ul> <li>Llamada a m\u00e9todo din\u00e1mico: <code>car.accelerate(30)</code>;</li> <li>Llamada a m\u00e9todo est\u00e1tico: <code>Math.pow(2,3);</code></li> </ul> <p>El bloque est\u00e1tico es un bloque de instrucciones dentro de una clase Java que se ejecutar\u00e1 cuando una clase se cargue por primera vez en la JVM.</p> <pre><code>class MyClass{\nstatic{\n//instrucciones\n}\n}\n</code></pre> MyClassMainConsola <pre><code>public class MyClass {\nstatic int a;\nstatic int b;\nstatic {\na = 10;\nb = 20;\n}\n}\n</code></pre> <pre><code>public class Main {\nprivate void showStatic() {\nSystem.out.printf(\"Valor de a: %d\\n\", MyClass.a);\nSystem.out.printf(\"Valor de b: %d:\\n\", MyClass.b);\n}\npublic static void main(String[] args) {\nnew Main().showStatic();\n}\n}\n</code></pre> <pre><code>Valor de a: 10\nValor de b: 20\n</code></pre>"},{"location":"bloque_i/tema_4/page-3/","title":"3 Convenciones","text":""},{"location":"bloque_i/tema_4/page-3/#javabean","title":"JavaBean","text":"<p>Los JavaBeans son un modelo de componentes para la construcci\u00f3n de aplicaciones en Java. Se usan para encapsular varios objetos en un \u00fanico objeto (la vaina o Bean en ingl\u00e9s), para hacer uso de un solo objeto en lugar de varios m\u00e1s simples. La especificaci\u00f3n de JavaBeans los define como \"componentes de software reutilizables que se puedan manipular visualmente en una herramienta de construcci\u00f3n\".</p> <p>Para funcionar como una clase JavaBean, una clase debe obedecer ciertas convenciones sobre nomenclatura de m\u00e9todos, construcci\u00f3n y comportamiento. Estas convenciones permiten tener herramientas que puedan utilizar, reutilizar, sustituir y conectar JavaBeans.</p> <p>Las convenciones requeridas son:</p> <ul> <li>Debe tener un constructor sin argumentos.</li> <li>Sus atributos de clase deben ser privados.</li> <li>Sus  propiedades  deben  ser  accesibles  mediante  m\u00e9todos  get  y  set  que  siguen  una convenci\u00f3n de nomenclatura est\u00e1ndar.</li> <li>Debe ser serializable.</li> </ul> <p>Dentro de un JavaBean podemos distinguir tres partes:</p> <ul> <li>Propiedades: Los atributos que contiene.</li> <li>M\u00e9todos: Se establecen los m\u00e9todos get y set para acceder y modificar los atributos.</li> <li>Eventos: Permiten comunicar con otros JavaBeans</li> </ul>"},{"location":"bloque_i/tema_4/page-3/#metodos-get-y-set","title":"M\u00e9todos get y set","text":"<p>Los m\u00e9todos get y set son m\u00e9todos de las clases para mostrar o modificar el valor de un atributo. Para mostrar se utiliza el m\u00e9todo get y para modificar el m\u00e9todo set.</p> <p>Seg\u00fan las convenciones JavaBean, la nomenclatura de ambos debe ser la siguiente:</p> <ul> <li>get:         - Debe ser declarado con el modificador de acceso public.         - El  nombre  del  m\u00e9todo  comienza  con  get  y  le  sigue  el  nombre  del  atributo  en UpperCamelCase. En el caso de los booleanos, el nombre del m\u00e9todo comienza con is.         - El tipo de retorno del m\u00e9todo debe ser el mismo que el tipo del atributo.</li> <li>set:         - Debe ser declarado con el modificador de acceso public.         - El  nombre  del  m\u00e9todo  comienza  con  set  y  le  sigue  el  nombre  del  atributo  en UpperCamelCase.         - El tipo de retorno del m\u00e9todo debe ser void.         - El tipo del par\u00e1metro del m\u00e9todo debe ser el mismo que el tipo del atributo.</li> </ul> <p>Hacer uso de este convenio nos facilitar\u00e1 trabajar con el resto del mundo y nos permitir\u00e1 ampliar las capacidades de nuestro c\u00f3digo utilizando frameworks existentes que hacen uso del convenio y que si no seguimos no podremos utilizar.</p> <p>En los IDEs, se pueden generar de forma autom\u00e1tica.</p> <p>Vamos a incluir en la clase Vehicle los getters y setters. Para ello, nos tenemos que plantear qu\u00e9 atributos vamos a permitir consultar y modificar. En cuanto a la consulta, vamos a permitir consultar  todos  los  atributos  por  lo  que  tendremos  que  realizar  3  getters.  En  cuanto  a  las modificaciones, el n\u00famero de ruedas de un veh\u00edculo no cambia a lo largo del tiempo por lo que no hace falta ponerle un m\u00e9todo set. La velocidad se va modificando con los m\u00e9todos de acelerar y frenar por lo que tampoco le vamos a poner un m\u00e9todo set. En cuanto al color, vamos a permitir que un veh\u00edculo pueda cambiar de color por lo que s\u00ed vamos a hacerle un m\u00e9todo set al color.</p> <pre><code>public class Vehicle {\nprivate int wheelCount; // N\u00ba ruedas\nprivate double speed; // Velocidad\nprivate String color; // Color del veh\u00edculo\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic void setWheelCount(int wheelCount) {\nthis.wheelCount = wheelCount;\n}\npublic String getColor() {\nreturn color;\n}\npublic void setColor(String color) {\nthis.color = color;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic void accelerate(double amount){ // acelerar\nspeed += amount;\n}\npublic void brake(double amount){ // frenar\nspeed -= amount;\n}\n}\n</code></pre> <p>Fij\u00e9monos en el m\u00e9todo setColor:</p> <pre><code>public void setColor(String color) {\nthis.color = color;\n}\n</code></pre> <p>Tenemos dos variables que se llaman igual: color. Una es un par\u00e1metro y otra es un atributo. Para  diferenciarlas,  el  atributo  se  utiliza  con  la  palabra  this.  El  uso  de  this  se  explica  con detenimiento m\u00e1s adelante.</p> <p>En el caso de los booleanos, el getter comienza por is. Si la clase Vehicle tuviera un atributo booleano llamado empty para detectar cu\u00e1ndo est\u00e1 vac\u00edo el dep\u00f3sito de gasolina, el getter se llamar\u00eda isEmpty():</p> <pre><code>private boolean empty;\npublic boolean isEmpty(){\nreturn empty;\n}\n</code></pre> Ejercicio 2 <p>Cree un paquete llamado exercise02 y copie la clase Persona del ejercicio anterior. Luego, realice las modificaciones necesarias para poder modificar y acceder a los atributos sin necesidad de usar directamente el atributo. Crea un m\u00e9todo Main donde le solicite al usuario todos los atributos y mu\u00e9strelos por pantalla haciendo uso de dichos m\u00e9todos.</p>"},{"location":"bloque_i/tema_4/page-3/#constructores","title":"Constructores","text":"<p>Un constructor es un m\u00e9todo que se invoca cuando se crea un objeto y que sirve para inicializar los atributos del objeto y para realizar las acciones pertinentes que requiera el mismo para ser creado. El constructor tiene el mismo nombre que la clase y para invocarlo se utiliza el operador new.</p> <pre><code>Vehicle car = new Vehicle(); //(1)!\n</code></pre> <ol> <li>Vehicle() es un constructor de la clase Vehicle</li> </ol> <p>En los constructores no se especifica tipo de retorno:</p> VehicleMainConsola <pre><code>public class Vehicle {\nprivate int wheelCount; // N\u00ba ruedas\nprivate double speed; // Velocidad\nprivate String color; // Color del veh\u00edculo\npublic Vehicle(){\nwheelCount = 4;\nspeed = 0;\ncolor = \"blanco\";\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic void setWheelCount(int wheelCount) {\nthis.wheelCount = wheelCount;\n}\npublic String getColor() {\nreturn color;\n}\npublic void setColor(String color) {\nthis.color = color;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic void accelerate(double amount){ // acelerar\nspeed += amount;\n}\npublic void brake(double amount){ // frenar\nspeed -= amount;\n}\n}\n</code></pre> <pre><code>public class Main {\npublic void showDefaultConstructor(){\nVehicle car1, car2;\ncar1 = new Vehicle();\ncar2 = new Vehicle();\nSystem.out.printf(\"Coche1: %d ruedas y de color %s\\n\", car1.getWheelCount(), car1.getColor());\nSystem.out.printf(\"Coche2: %d ruedas y de color %s\\n\", car2.getWheelCount(), car2.getColor());\nSystem.out.printf(\"Velocidad del coche1: %.2f km/h\\n\", car1.getSpeed());\nSystem.out.printf(\"Velocidad del coche2: %.2f km/h\\n\", car2.getSpeed());\nSystem.out.println(\"Aceleramos el coche1 a 90,50km/h\");\ncar1.accelerate(90.50);\nSystem.out.printf(\"Velocidad del coche1: %.2f km/h\\n\", car1.getSpeed());\nSystem.out.println(\"Aceleramos el coche2 a 20,30km/h\");\ncar2.accelerate(20.30);\nSystem.out.printf(\"Velocidad del coche2: %.2f km/h\\n\", car2.getSpeed());\n}\npublic static void main(String[] args) {\nnew Main().showDefaultConstructor();\n}\n}\n</code></pre> <pre><code>Coche1: 4 ruedas y de color blanco\nCoche2: 4 ruedas y de color blanco\nVelocidad del coche1: 0,00 km/h\nVelocidad del coche2: 0,00 km/h\nAceleramos el coche1 a 90,50km/h\nVelocidad del coche1: 90,50 km/h\nAceleramos el coche2 a 20,30km/h\nVelocidad del coche2: 20,30 km/h\n</code></pre> <p>El constructor que no tiene par\u00e1metros se llama constructor  por  defecto, como por ejemplo Vehicle(). Si nos fijamos en la salida por consola, los dos coches tienen los mismos datos ya que el constructor por defecto crea todos los objetos de la misma manera. Para poder crear objetos diferentes, tendremos que usar un constructor con par\u00e1metros:</p> VehiclesMainConsola <pre><code>public class Vehicle {\nprivate int wheelCount; // N\u00ba ruedas\nprivate double speed; // Velocidad\nprivate String color; // Color del veh\u00edculo\npublic Vehicle(){\nwheelCount = 4;\nspeed = 0;\ncolor = \"blanco\";\n}\npublic Vehicle(int wheelCount, String color) {\nthis.wheelCount = wheelCount;\nthis.color = color;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic void setWheelCount(int wheelCount) {\nthis.wheelCount = wheelCount;\n}\npublic String getColor() {\nreturn color;\n}\npublic void setColor(String color) {\nthis.color = color;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic void accelerate(double amount){ // acelerar\nspeed += amount;\n}\npublic void brake(double amount){ // frenar\nspeed -= amount;\n}\n}\n</code></pre> <pre><code>public class ConstructorParameterized {\npublic void show(){\nVehicle car, moto;\ncar = new Vehicle(4, \"azul\");\nmoto = new Vehicle(2, \"rojo\");\nSystem.out.printf(\"Coche: %d ruedas y de color %s\\n\", car.getWheelCount(), car.getColor());\nSystem.out.printf(\"Moto: %d ruedas y de color %s\\n\", moto.getWheelCount(), moto.getColor());\n}\npublic static void main(String[] args) {\nnew ConstructorParameterized().show();\n}\n}\n</code></pre> <pre><code>Coche: 4 ruedas y de color azul\nMoto: 2 ruedas y de color rojo\n</code></pre> <p>Al tener par\u00e1metros el constructor, esto nos permite poder crear objetos diferentes.</p> <p>En los IDEs, se puede generar el constructor con par\u00e1metros de forma autom\u00e1tica.</p> <p>Los constructores se pueden sobrecargar, por lo tanto una clase puede tener varios constructores, en el ejemplo anterior la clase Vehicle mantiene el constructor por defecto, adem\u00e1s del constructor con par\u00e1metros.</p> <pre><code>public class ShowConstructors {\npublic void show(){\nVehicle car, moto;\ncar = new Vehicle();\nmoto = new Vehicle(2, \"rojo\");\nSystem.out.printf(\"Coche: %d ruedas y de color %s\\n\", car.getWheelCount(), car.getColor());\nSystem.out.printf(\"Moto: %d ruedas y de color %s\\n\", moto.getWheelCount(), moto.getColor());\n}\n}\n</code></pre> <p>Si una clase no tiene constructor, Java crea uno por defecto. Los atributos se inicializan a su valor por defecto en funci\u00f3n del tipo que posean:</p> <ul> <li>Tipos num\u00e9ricos enteros: 0</li> <li>Tipos num\u00e9ricos decimales: 0</li> <li>Caracteres: Car\u00e1cter nulo (C\u00f3digo Unicode 0)</li> <li>Booleanos: false</li> <li>Referencias a objetos: null</li> </ul> <p>Solo se inicializan los atributos, las variables locales de los m\u00e9todos no son inicializados por defecto.</p> <p>\u00a1OJO!</p> <p>Java solamente crea un constructor cuando la clase no tiene ninguno, pero si la clase tiene un constructor, aunque sea con par\u00e1metros, Java ya no crea ninguno por defecto.</p> <p>Si la clase posee alg\u00fan constructor con par\u00e1metros pero se usa Class() el compilador nos da un mensaje de error de que el constructor no est\u00e1 definido.</p> Ejercicio 3 <p>Crea un paquete llamado exercise03 y copia la clase persona del ejercicio anterior. Crea un m\u00e9todo constructor para dicha clase que asigne los siguientes valores a sus atributos:</p> <p>nombre = \"Sin nombre\" edad = 0 altura = 0.0f ocupacion = \"sin ocupaci\u00f3n\"</p> <p>Crea un Main que declare un objeto de tipo persona utilizando el constructor, para posteriormente mostrar el contenido de sus atributos por pantalla.</p> Ejercicio 4 <p>Crea un paquete llamado exercise04 y copie la clase persona del ejercicio anterior. Crea un m\u00e9todo constructor con par\u00e1metros sin anular el ya creado. Realiza un Main que declare un objeto tipo persona utilizando dicho constructor y muestre el contenido posteriormente por pantalla.</p>"},{"location":"bloque_i/tema_4/page-3/#visibilidad","title":"Visibilidad","text":"<p>La visibilidad de los atributos y m\u00e9todos de una clase se establece utilizando los modificadores de acceso.</p> <p>Los modificadores de acceso permiten dar un nivel de seguridad mayor a nuestras aplicaciones restringiendo el acceso a diferentes atributos y m\u00e9todos asegur\u00e1ndonos que el cliente no va a consultar el valor de un atributo que no debe, no va a modificar incorrectamente el valor de un atributo o que no va a utilizar un m\u00e9todo que no le est\u00e9 permitido. Cuando nos referimos al t\u00e9rmino cliente es cualquier programador que utilice nuestras clases.</p> <p>Tal y como vimos en el apartado 2. Modificadores de acceso, se resume su funcionamiento en la siguiente tabla:</p> Private Friendly Public Misma clase x x x Mismo paquete x x Otro paquete x <p>Veamos un ejemplo de la clase Vehicle que est\u00e1 en el mismo paquete que una clase cliente Main.</p> <p>Vamos a comprobar la visibilidad que tiene la clase Main sobre la clase Vehicle en funci\u00f3n de los modificadores de acceso. Tal y como podemos observar en la tabla anterior, tendr\u00e1 acceso a public y a friendly pero no a private</p> VehicleMain <pre><code>public class Vehicle {\nprivate int wheelCount; // N\u00ba ruedas\nprivate double speed; // Velocidad\nprivate String color; // Color del veh\u00edculo\npublic Vehicle(int wheelCount, String color) {\nthis.wheelCount = wheelCount;\nthis.color = color;\nspeed = 0;\n}\nint getWheelCount() {\nreturn wheelCount;\n}\npublic void setWheelCount(int wheelCount) {\nthis.wheelCount = wheelCount;\n}\npublic String getColor() {\nreturn color;\n}\npublic void setColor(String color) {\nthis.color = color;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic void accelerate(double amount){ // acelerar\nspeed += amount;\n}\npublic void brake(double amount){ // frenar\nspeed -= amount;\n}\n}\n</code></pre> <pre><code>public class Main {\npublic void showVisibility(){\nVehicle car = new Vehicle(4, \"azul\");\nSystem.out.printf(\"El coche tiene %d ruedas\\n\", car.getWheelCount()); //(1)!\ncar.accelerate(100); //(2)!\nSystem.out.printf(\"El coche va a %.2f km/h\\n\", car.speed); //(3)!\n}\n}\n</code></pre> <ol> <li>getWheelCount es visible porque es friendly y la clase Main est\u00e1 en el mismo paquete que la clase Vehicle.</li> <li>accelerate es visible porque es public.</li> <li>Error de compilaci\u00f3n: speed no es visible porque es private</li> </ol> Ejercicio 5 <p>Cree un paquete exercise05 copiando la clase Persona del exercise04 y modifica al acceso a algunos de sus m\u00e9todos, haci\u00e9ndolos public, private o friendly y realiza las siguientes operaciones y observa si da o no error, justificando sus respuesta con comentarios:</p> <ul> <li>Crea un m\u00e9todo main dentro de la clase Persona y crea un objeto persona, intente acceder a todos sus m\u00e9todos.</li> <li>Crea una clase Main dentro del paquete exercise_05 y realice la misma operaci\u00f3n anterior</li> <li>Crea un paquete llamado exercise05_bis y una clase Main realizando la misma operaci\u00f3n anterior</li> </ul>"},{"location":"bloque_i/tema_4/page-3/#instanceof","title":"instanceof","text":"<p>El operador instanceof permite comprobar si un determinado objeto pertenece a una clase concreta. Se utiliza de esta forma:</p> <pre><code>object instanceof class\n</code></pre> <p>Devuelve true si el objeto pertenece a dicha clase.</p> <pre><code>public class InstanceOf {\npublic void show(){\nVehicle vehicle = new Vehicle();\nSystem.out.println(vehicle instanceof  Vehicle);\n}\npublic static void main(String[] args) {\nnew InstanceOf().show();\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/","title":"4 Referencias","text":""},{"location":"bloque_i/tema_4/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Una referencia en cualquier lenguaje de programaci\u00f3n hace alusi\u00f3n a la posici\u00f3n en memoria RAM que tiene una variable.</p> <p>Una variable es conceptualmente un recipiente donde guardamos un dato. Java es un lenguaje fuertemente tipado. Las variables se definen siempre con un tipo asociado. No se puede meter en una variable ning\u00fan dato que no sea del tipo con que se defini\u00f3.</p> <p>Una variable es un lugar en la memoria donde se guarda un dato. Para ser exacto, este lugar en la memoria es la Pila o Stack. En el caso de los datos primitivos, como en <code>int i = 5;</code> hay cuatro bytes en la Pila donde se almacena el n\u00famero 5. Pero cuando se crea un objeto en Java, el objeto se guarda en una parte de la memoria llamada Heap. Cuando asignamos el objeto a una variable como en <code>Vehicle car=new Vehicle();</code>, lo que guardamos en car es la direcci\u00f3n de memoria Heap donde est\u00e1 el objeto.</p> <p>Stack en java es una secci\u00f3n de memoria que contiene m\u00e9todos, variables locales y variables de referencia. La memoria de pila siempre se referencia en el orden de \u00faltimo en entrar primero en salir. Las variables locales se crean en la pila.</p> <p>Heap es una secci\u00f3n de memoria que contiene objetos y tambi\u00e9n puede contener variables de referencia. Los atributos se crean en el heap.</p>"},{"location":"bloque_i/tema_4/page-4/#representacion-en-memoria-de-tipos-primitivos","title":"Representaci\u00f3n en memoria de tipos primitivos","text":"<p>Veamos paso a paso un ejemplo:</p> <ul> <li> <p>Cuando se declara una variable de un tipo primitivo, el compilador reserva un \u00e1rea de memoria para ella:</p> <pre><code>int i, j;\n</code></pre> <p> Figura 1 - Referencia de primitivos </p> </li> <li> <p>Cuando se asigna un valor, \u00e9ste es escrito en el \u00e1rea reservada:</p> <pre><code>i = 16;\nj = 3;\n</code></pre> <p> Figura 2 - Referencia de primitivos </p> </li> <li> <p>La asignaci\u00f3n entre variables significa copiar el contenido de una variable en la otra:</p> <pre><code>i = j;\n</code></pre> <p> Figura 3 - Referencia de primitivos </p> </li> <li> <p>La comparaci\u00f3n entre variables compara los contenidos de las mismas:</p> <pre><code>i == j; // true porque 3 es igual a 3\n</code></pre> </li> </ul> PrimitivesConsola <pre><code>public class Primitives {\npublic void show(){\nint i = 10, j = 20;\nSystem.out.printf(\"Valor de la variable i: %d\\n\", i);\nSystem.out.printf(\"Valor de la variable j: %d\\n\", j);\ni = j;\nSystem.out.printf(\"Valor de la variable i: %d\\n\", i);\nSystem.out.printf(\"Valor de la variable j: %d\\n\", j);\nSystem.out.printf(\"i y j%s tiene el mismo contenido\", i == j ? \"\" : \" no\");\n}\npublic static void main(String[] args) {\nnew Primitives().show();\n}\n}\n</code></pre> <pre><code>Valor de la variable i: 10\nValor de la variable j: 20\nValor de la variable i: 20\nValor de la variable j: 20\ni y j tiene el mismo contenido\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#representacion-en-memoria-de-objetos","title":"Representaci\u00f3n en memoria de objetos","text":"<p>Supongamos que tenemos una clase Complex con dos atributos: r, i.</p> <ul> <li> <p>Cuando se declara una variable de un objeto, el compilador reserva un \u00e1rea de memoria para ella. Mientras no se cree ning\u00fan objeto con el operador new, lo que contendr\u00e1 ser\u00e1 null. La palabra reservada null indica que una variable que referencia a un objeto se encuentra de momento sin referenciar a ninguno:</p> <pre><code>Complex cl;\n</code></pre> <p> Figura 4 - Referencia de objetos </p> </li> <li> <p>Cuando se crea el objeto llamando la constructor con el operador new, lo que se guarda en la variable c1 es la direcci\u00f3n de memoria donde se ha almacenado el objeto en el heap, es decir, la diferencia entre los tipos primitivos y los objetos es que en los primitivos la variable almacena el valor y en los objetos, la variable almacena la direcci\u00f3n de memoria donde se encuentra el objeto.</p> <pre><code>c1 = new Complex(7.2, 2.4);\n</code></pre> <p> Figura 5 - Referencia de objetos </p> </li> <li> <p>La asignaci\u00f3n entre variables de objetos significa copiar la direcci\u00f3n de memoria donde se encuentra el objeto:</p> <pre><code>Complex c2 = c1;\n</code></pre> <p>En este caso, el valor de la variable c2 es 0x2A18, por lo tanto, ambas variables apuntan al mismo objeto. Si una de ellas modifica alg\u00fan valor del objeto, tambi\u00e9n le afectar\u00e1 a la otra variable. Por ejemplo, si a c2 le cambiamos el valor de r a 9.7, si consultamos el valor de r de c1, tambi\u00e9n valdr\u00e1 9.7, en lugar de 7.2.</p> </li> <li> <p>La comparaci\u00f3n entre referencias no compara los contenidos de los objetos sino las direcciones de memoria, es decir, si apuntan al mismo sitio.</p> <pre><code>c2 == c1; // true porque apuntan al mismo sitio\nComplex c3 = new Complex(7.2, 2.4);\nc3 == c1; // false porque aunque tengan los mismos valores, no apuntan al mismo sitio\n</code></pre> <p>Para comparar el contenido de los objetos, se utiliza el m\u00e9todo equals:</p> <pre><code>c3.equals(c1); // true porque los contenidos de los objetos son los mismos\n</code></pre> </li> </ul> ComplexMainConsole <pre><code>public class Complex {\ndouble r;\ndouble j;\npublic Complex(double r, double j) {\nthis.r = r;\nthis.j = j;\n}\n}\n</code></pre> <pre><code>public class Objects {\npublic void show(){\nComplex c1 = new Complex(7.2, 2.3);\nComplex c2 = c1;\nSystem.out.printf(\"C1 -&gt; r: %.2f j: %.2f\\n\", c1.r, c1.j);\nSystem.out.printf(\"C2 -&gt; r: %.2f j: %.2f\\n\", c2.r, c2.j);\nc1.r = 10;\nc2.j = 7.6;\nSystem.out.printf(\"C1 -&gt; r: %.2f j: %.2f\\n\", c1.r, c1.j);\nSystem.out.printf(\"C2 -&gt; r: %.2f j: %.2f\\n\", c2.r, c2.j);\nComplex c3 = new Complex(10, 7.6);\nSystem.out.printf(\"C3 -&gt; r: %.2f j: %.2f\\n\", c3.r, c3.j);\nSystem.out.printf(\"c1 == c2 -&gt; %b\\n\", c1 == c2);\nSystem.out.printf(\"c1 == c3 -&gt; %b\\n\", c1 == c3);\nSystem.out.printf(\"c1 equals c3 -&gt; %b\\n\", c1.equals(c3));\n}\npublic static void main(String[] args) {\nnew Objects().show();\n}\n}\n</code></pre> <pre><code>C1 -&gt; r: 7,20 j: 2,30\nC2 -&gt; r: 7,20 j: 2,30\nC1 -&gt; r: 10,00 j: 7,60\nC2 -&gt; r: 10,00 j: 7,60\nC3 -&gt; r: 10,00 j: 7,60\nc1 == c2 -&gt; true\nc1 == c3 -&gt; false\nc1 equals c3 -&gt; false\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#garbage-collector","title":"Garbage Collector","text":"<p>Garbage Collector (recolector de basura) es un programa que se ejecuta en el Java Virtual Machine que elimina los objetos que ya no est\u00e1n siendo utilizados por una aplicaci\u00f3n Java. Es una forma de gesti\u00f3n autom\u00e1tica de la memoria.</p> <p>Un objeto es elegible para el recolector de basura cuando deja de existir alguna referencia hacia \u00e9l. Veamos algunos ejemplos.</p> <pre><code>Complex c1 = new Complex(7.2, 2.4);\n//...\nc1 = null;\n//...\n</code></pre> <p>Existe un objeto referenciado por la variable c1. Cuando la variable c1 pierde la referencia porque se le asigna el null, se pierde cualquier forma de acceder al objeto, de modo que pasa a ser elegible para el recolector de basura.</p> <pre><code>Complex c1 = new Complex(7.2, 2.4);\nComplex c2 = c1;\n// ...\nc1 = null;\n// ...\n</code></pre> <p>En este segundo ejemplo, el objeto no pasa a ser elegible para ser recolectado pues aunque la variable c1 haya perdido la referencia porque se le asigna el null, todav\u00eda existe una referencia hacia el objeto por la variable c2</p> <pre><code>Complex c1 = new Complex(7.2, 2.4);\n//...\nc1 = new Complex(8.3, 2.7);\n//...\n</code></pre> <p>En este otro ejemplo, la variable c1 es reasignada, es decir, se le asigna otro objeto mediante el operador  new, por  lo  tanto  se  pierde  cualquier  referencia  al  objeto  creado  al  principio  <code>new Complex(7.2 , 2.4)</code> por lo que dicho objeto pasa a ser elegible para el recolector de basura.</p>"},{"location":"bloque_i/tema_4/page-5/","title":"5 This","text":""},{"location":"bloque_i/tema_4/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Cuando se llama a un m\u00e9todo, se pasa autom\u00e1ticamente un argumento impl\u00edcito que es una referencia al objeto invocado, es decir, el objeto sobre el que se llama el m\u00e9todo. Esta referencia se llama this, es decir, this es una variable que hace referencia al objeto actual.</p> <p>Veamos los distintos usos que puede tener:</p>"},{"location":"bloque_i/tema_4/page-5/#para-acceder-a-un-atributo-del-objeto-actual","title":"Para acceder a un atributo del objeto actual","text":"<p>Centr\u00e9monos en el getter del atributo color de la clase Vehicle:</p> <pre><code>public String getColor(){\nreturn color;\n}\n</code></pre> <p>color es un atributo de la clase Vehicle. El m\u00e9todo getColor() de la clase Vehicle puede acceder perfectamente al atributo color  ya  que  cuando  el  m\u00e9todo  getColor()  es  llamado,  recibe  de forma impl\u00edcita el objeto actual, es decir, el objeto sobre el que se llama el m\u00e9todo. Esto le permite al m\u00e9todo getColor() poder acceder a todos los atributos de la clase y llamar a cualquier m\u00e9todo de la misma.</p> <p>Como color es un atributo de la clase Vehicle, tambi\u00e9n pod\u00edamos haber accedido a \u00e9l como this.colour. Pero en realidad, cuando desde un m\u00e9todo se accede a un atributo, se usa this de forma impl\u00edcita, es decir, que aunque no escribamos this, el compilador lo sobreentiende. Por eso  en  la  pr\u00e1ctica,  solo  se  indica  si  es  imprescindible.  Veamos  un  ejemplo  en  el  que  sea imprescindible:</p> <pre><code>public void setColor(String color){\nthis.color = color;\n}\n</code></pre> <p>En este caso, nos encontramos con dos variables que se llaman color: el atributo y el par\u00e1metro del m\u00e9todo. El shadow (sombra) de variables se refiere a la pr\u00e1ctica en programaci\u00f3n de utilizar dos variables con el mismo nombre dentro de \u00e1mbitos que se superponen. La variable con el alcance de nivel superior se oculta porque la variable con el alcance de nivel inferior la anula. La variable de nivel superior se dice entonces que es \"sombreada\". En nuestro ejemplo, el atributo es  \"sombreado\" por  el  par\u00e1metro,  es  decir,  cuando  en  el  m\u00e9todo  accedemos  a  colour,  es  el par\u00e1metro al que nos estamos refiriendo. Para poder acceder al atributo, necesitamos utilizar la palabra this: <code>this.colour</code>. \u00bfQu\u00e9 es lo que estamos haciendo entonces con esta l\u00ednea de c\u00f3digo: <code>this.colour = colour</code>? Pues le estamos asignando el valor del par\u00e1metro al atributo, es decir, estamos actualizando el color del objeto actual con el color pasado por par\u00e1metro al m\u00e9todo setColor.</p>"},{"location":"bloque_i/tema_4/page-5/#para-invocar-un-constructor","title":"Para invocar un constructor","text":"<p>Un constructor puede llamar a otro constructor de la clase utilizando this, pero esta llamada solamente puede estar en la primera linea de c\u00f3digo.</p> <pre><code>public class Vehicle{\n//...\npublic Vehicle(){\nthis(4, \"Blanco\");\n}\npublic Vehicle(int wheelCount, String color) {\nthis.wheelCount = wheelCount;\nthis.color = color;\nspeed = 0;\n}\n//...\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-5/#como-referencia-al-objeto-actual","title":"Como referencia al objeto actual","text":"<p>Dentro de la clase, siempre que queramos obtener una referencia al objeto actual, podemos utilizar this.</p> <p>Supongamos que queremos modificar el m\u00e9todo acelerar los veh\u00edculos para que devuelvan el objeto actual con la velocidad modificada por la aceleraci\u00f3n:</p> <pre><code>public Vehicle accelerate(double amount){\nspeed += amount;\nreturn this;\n}\n</code></pre> <p>Veamos m\u00e1s ejemplos del uso de this como referencia al objeto actual. Vamos a a\u00f1adir los m\u00e9todo nuevos a la clase Vehicle:</p> <ul> <li>addSpeeds: devuelve la suma de dos velocidades, la del objeto actual y la del veh\u00edculo pasado como par\u00e1metro.</li> <li>doubleSpeed: dobla la velocidad del objeto actual utilizando el m\u00e9todo addSpeeds.</li> </ul> <pre><code>public double addSpeeds(Vehicle vehicle){\nreturn speed + vehicle.speed;\n}\npublic void doubleSpeed(){\nspeed = addSpeeds(this);\n}\n</code></pre> <p>Para doblar la velocidad utilizando el m\u00e9todo addSpeeds, tenemos que pasarle a este m\u00e9todo la referencia al objeto actual para que sume la velocidad consigo mismo, doblando de esta forma su propia velocidad.</p> MainConsola <pre><code>public class Main{\npublic void showThisCurrentObject(){\nVehicle car1, car2;\ncar1 = new Vehicle(4, \"azul\");\ncar2 = new Vehicle(2, \"rojo\");\ncar1.accelerate(90.3);\ncar2.accelerate(120.5);\nSystem.out.printf(\"Velocidad del coche1: %.2f\\n\", car1.getSpeed());\nSystem.out.printf(\"Velocidad del coche2: %.2f\\n\", car2.getSpeed());\nSystem.out.printf(\"Suma de las velocidades de los dos coches: %.2f\\n\", car1.addSpeeds(car2));\ncar1.doubleSpeed();\nSystem.out.printf(\"El coche1 ha doblado su velocidad: %.2f\\n\", car1.getSpeed());\n}\npublic static main(String[] args){\nnew Main().showThisCurrentObject();\n}\n}\n</code></pre> <pre><code>Velocidad del coche1: 90,30\nVelocidad del coche2: 120,50\nSuma de las velocidades de los dos coches: 210,80\nEl coche1 ha doblado su velocidad: 180,60\n</code></pre> <p>El m\u00e9todo doubleSpeed de la clase Vehicle puede llamar perfectamente al m\u00e9todo addSpeeds ya que cuando el m\u00e9todo doubleSpeed es llamado, recibe de forma impl\u00edcita el objeto actual, es decir, el objeto sobre el que se llama el m\u00e9todo. Esto le permite al m\u00e9todo doubleSpeed poder acceder a todos los atributos de la clase y llamar a cualquier m\u00e9todo de la misma.</p> <p>Como addSpeeds es un m\u00e9todo de la clase Vehicle, el m\u00e9todo doubleSpeed pod\u00eda haberlo llamado tambi\u00e9n utilizando el this: <code>this.addSpeeds(this)</code>, pero en realidad, cuando desde un m\u00e9todo se llama a otro de la clase, se usa this de forma impl\u00edcita, es decir, que aunque no escribamos this, el compilador lo sobreentiende. Por eso en la pr\u00e1ctica, solo se indica si es imprescindible.</p> Ejercicio 6 <p>Crea un paquete llamado exercise06 y copia la clase Persona del paquete exercise04 y crea un constructor que reciba todos los par\u00e1metros excepto la ocupaci\u00f3n, siendo su valor por defecto \"sin ocupaci\u00f3n\". Realice dicho constructor y los ya creados haciendo uso de la referencia this. Crea una clase Main para probar todos los constructores.</p> Ejercicio 7 <p>Crea un paquete llamado exercise07 y copia la clase Persona del ejercicio anterior y crea un atributo decimal para almacenar el sueldo. Crea un m\u00e9todo sumarSueldo que reciba una persona por par\u00e1metro. Dicho m\u00e9todo tiene que incrementar el sueldo con el sueldo de la persona recibida como par\u00e1metro. Crear otro m\u00e9todo, doblarSueldo, que doble el sueldo utilizando el m\u00e9todo sumarSueldo y this. Crea un main para probarlos.</p>"},{"location":"bloque_i/tema_4/page-6/","title":"6 T\u00e9cnicas","text":""},{"location":"bloque_i/tema_4/page-6/#encadenamiento-de-llamadas-a-metodos","title":"Encadenamiento de llamadas a m\u00e9todos","text":"<p>Se emplea cuando invocamos a un m\u00e9todo de un objeto que nos devuelve como resultado otro objeto al que podemos volver a invocar otro m\u00e9todo y as\u00ed encadenar varias operaciones:</p> <pre><code>public class CallsToMethods {\npublic void show(){\nBoolean b;\nString string;\nstring = \"EntornosDeDesarrollo\";\nSystem.out.println(string.substring(10).toUpperCase()); //DESARROLLO\nb = Boolean.TRUE;\nSystem.out.println(b.toString().charAt(2));\n}\npublic static void main(String[] args) {\nnew CallsToMethods().show();\n}\n}\n</code></pre> <p>En este ejemplo, el m\u00e9todo <code>substring(10)</code>  est\u00e1 devolviendo una subcadena de la cadena string a partir del car\u00e1cter 10 empezando en 0, es decir, \"Desarrollo\", al que se le invoca luego el m\u00e9todo  <code>toUpperCase</code>  devolviendo como resultado la cadena \"DESARROLLO\".</p> <p>Y el m\u00e9todo <code>toString()</code> de la variable b de tipo Boolean est\u00e1 devolviendo la cadena \"true\" a la que se le encadena el m\u00e9todo  <code>charAt(2)</code> devolviendo el car\u00e1cter 'u'.</p>"},{"location":"bloque_i/tema_4/page-6/#sintaxis-fluida","title":"Sintaxis fluida","text":"<p>Cuando un m\u00e9todo modifica alg\u00fan atributo del objeto, se puede devolver el objeto con un return para  que  dicho  m\u00e9todo  pueda  insertarse  en  una  expresi\u00f3n.  Esto  permite  encadenar  otras llamadas de m\u00e9todos consiguiendo que el c\u00f3digo sea m\u00e1s corto, m\u00e1s legible y m\u00e1s f\u00e1cil de manejar para los programadores.</p> <p>Veamos un ejemplo de clases, una con sintaxis fluida y otra sin ella para ver la diferencia.</p> Vehicle sin fluidezVehicle con sintaxis fluidaMainConsola <pre><code>public class Vehicle {\nprivate int wheelCount; // N\u00ba ruedas\nprivate double speed; // Velocidad\nprivate String color; // Color del veh\u00edculo\npublic Vehicle(){\nthis(4, \"Blanco\");\n}\npublic Vehicle(int wheelCount, String color) {\nthis.wheelCount = wheelCount;\nthis.color = color;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic void setWheelCount(int wheelCount) {\nthis.wheelCount = wheelCount;\n}\npublic String getColor() {\nreturn color;\n}\npublic void setColor(String color) {\nthis.color = color;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic void accelerate(double amount){ // acelerar\nspeed += amount;\n}\npublic void brake(double amount){ // frenar\nspeed -= amount;\n}\n}\n</code></pre> <pre><code>public class Vehicle2 {\nprivate int wheelCount; // N\u00ba ruedas\nprivate double speed; // Velocidad\nprivate String color; // Color del veh\u00edculo\npublic Vehicle2(){\nthis(4, \"Blanco\");\n}\npublic Vehicle2(int wheelCount, String color) {\nthis.wheelCount = wheelCount;\nthis.color = color;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic void setWheelCount(int wheelCount) {\nthis.wheelCount = wheelCount;\n}\npublic String getColor() {\nreturn color;\n}\npublic Vehicle2 setColor(String color) {\nthis.color = color;\nreturn this;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic Vehicle2 accelerate(double amount){ // acelerar\nspeed += amount;\nreturn this;\n}\npublic Vehicle2 brake(double amount){ // frenar\nspeed -= amount;\nreturn this;\n}\n}\n</code></pre> <pre><code>public class FluidSyntax {\npublic void show(){\nVehicle car1;\nVehicle2 car2;\ncar1 = new Vehicle(4, \"rojo\");\ncar2 = new Vehicle2(4, \"azul\");\ncar1.accelerate(120.55);\ncar1.brake(20.32);\nSystem.out.printf(\"Velocidad del coche1: %.2f\\n\", car1.getSpeed());\nSystem.out.printf(\"Velocidad del coche2: %.2f\\n\", car2.accelerate(120.55).brake(20.32).getSpeed());\n}\npublic static void main(String[] args) {\nnew FluidSyntax().show();\n}\n}\n</code></pre> <pre><code>Velocidad del coche1: 100,23\nVelocidad del coche2: 100,23\n</code></pre>"},{"location":"bloque_i/tema_4/page-6/#invariante-de-una-clase","title":"Invariante de una clase","text":"<p>El invariante de una clase es el conjunto de restricciones que deben cumplir todos los objetos que se instancien de dicha clase, como por ejemplo:</p> <ul> <li>Restricciones sobre los valores que pueden tomar los atributos de la clase. Ejemplo: el atributo wheelCount de la clase Vehicle tiene que ser mayor que 0.</li> <li>Restricciones que afecten a m\u00e1s de un atributo. Por ejemplo, si una clase modela un rango de valores, el atributo que corresponda al l\u00edmite superior del rango debe ser forzosamente mayor o igual que el atributo que corresponda al l\u00edmite inferior del rango, dada la definici\u00f3n matem\u00e1tica del rango.</li> <li>Restricciones con respecto a los objetos con los que se relaciona. Ejemplo: un empleado tiene un atributo que es objeto de la clase Empresa donde trabaja. Una restricci\u00f3n posible ser\u00eda que dicha empresa no pueda ser nula.</li> </ul> <p>Los m\u00e9todos constructores de una clase deben respetar el invariante de la clase a la hora de construir los objetos.</p> <p>Los m\u00e9todos p\u00fablicos de la clase tambi\u00e9n deben respetar el invariante. Un m\u00e9todo puede no respetar el invariante en el transcurso de la ejecuci\u00f3n, pero cuando el m\u00e9todo finalice, el invariante se tiene que cumplir, es decir, es perfectamente viable que un m\u00e9todo para alcanzar su objetivo pueda perder de forma temporal el invariante pero siempre y cuando finalice con el invariante cumplido, es decir, antes de la llamada el invariante se debe cumplir y despu\u00e9s de la llamada tambi\u00e9n, durante la ejecuci\u00f3n del mismo puede no satisfacerse.</p> <p>\u00danicamente se deben satisfacer los invariantes en las llamadas a m\u00e9todos p\u00fablicos, la ejecuci\u00f3n de m\u00e9todos privados de la misma clase pueden saltarse esta norma aunque no es aconsejable.</p> <p>Definir invariantes de clase puede ayudar a los programadores y controladores de calidad a localizar m\u00e1s errores durante las pruebas de software.</p>"},{"location":"bloque_i/tema_4/page-6/#encapsulamiento","title":"Encapsulamiento","text":"<p>La encapsulaci\u00f3n es un principio fundamental de la programaci\u00f3n orientada a objetos que consiste en ocultar el estado o los atributos de un objeto y obligar a que toda interacci\u00f3n se realice a trav\u00e9s de los m\u00e9todos del objeto definidos en su clase para conservar su invariante.</p> <p>El encapsulamiento se consigue utilizando los modificadores de acceso. Se recomienda que los atributos de una clase sean privados, por lo tanto, aquellos atributos que se permitan consultar deben tener sus propios m\u00e9todos get, y los que se permitan modificar, deben tener sus propios m\u00e9todos set. Hacer uso de este convenio nos facilitar\u00e1 trabajar con el resto del mundo y nos permitir\u00e1 ampliar las capacidades de nuestro c\u00f3digo utilizando frameworks existentes que hacen uso del convenio y que si no seguimos no podremos utilizar.</p> VehicleMain <pre><code>public class Vehicle {\npublic int wheelCount; // N\u00ba ruedas\npublic double speed; // Velocidad\npublic String color; // Color del veh\u00edculo\npublic Vehicle(int wheelCount, String color) {\nthis.wheelCount = wheelCount;\nthis.color = color;\nspeed = 0;\n}\npublic void accelerate(double amount){ // acelerar\nspeed += amount;\n}\npublic void brake(double amount){ // frenar\nspeed -= amount;\n}\n}\n</code></pre> <pre><code>public class NoEncapsulation {\npublic void show(){\nVehicle car = new Vehicle(4, \"azul\");\ncar.accelerate(90.54);\nSystem.out.printf(\"Velocidad: %.2f\\n\", car.speed);\ncar.speed = 120; // Se accede directamente\nSystem.out.printf(\"Velocidad: %.2f\\n\", car.speed);\n}\npublic static void main(String[] args) {\nnew NoEncapsulation().show();\n}\n}\n</code></pre> <p>Podemos observar que no se est\u00e1 cumpliendo el principio de encapsulamiento ya que el cliente est\u00e1 accediendo directamente al atributo speed modificando incorrectamente su valor ya que la velocidad solamente se debe modificar acelerando o frenando el veh\u00edculo.</p> <p>El ejemplo anterior pero cumpliendo encapsulamiento ocultando el estado o los atributos del objeto y obligando a toda interacci\u00f3n se realice a trav\u00e9s de los m\u00e9todos del objeto definidos en su clase, ser\u00eda tal y como hemos estado viendo en ejemplos anteriores, es decir, haciendo privado sus atributos y creando los m\u00e9todos getters y setters necesarios.</p> Vehicle <pre><code>public class Vehicle{\nprivate int wheelCount; // N\u00ba ruedas\nprivate double speed; // Velocidad\nprivate String color; // Color del veh\u00edculo\npublic Vehicle(){\nthis(4, \"Blanco\");\n}\npublic Vehicle(int wheelCount, String color) {\nthis.wheelCount = wheelCount;\nthis.color = color;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic void setWheelCount(int wheelCount) {\nthis.wheelCount = wheelCount;\n}\npublic String getColor() {\nreturn color;\n}\npublic void setColor(String color) {\nthis.color = color;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic void accelerate(double amount){ // acelerar\nspeed += amount;\n}\npublic void brake(double amount){ // frenar\nspeed -= amount;\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-6/#metodo-tostring","title":"M\u00e9todo toString","text":"<p>El m\u00e9todo <code>toString()</code> se utiliza para obtener una cadena de texto que represente al objeto. Lo veremos en m\u00e1s profundidad en el tema de herencia. Veamos su uso:</p> VehicleMain <pre><code>public class Vehicle {\n//...\n@Override\npublic String toString() {\nreturn \"Vehicle [wheelCount =\" + wheelCount + \", speed=\" + speed + \", color =\" + color + \"]\";\n}\n}\n</code></pre> <pre><code>public static void main(String[] args){\nVehicle car = new Vehicle(4, \"rojo\");\nSystem.out.println(car.toString());\n}\n</code></pre> <p>Algunos IDEs pueden generar toString() de forma autom\u00e1tica.</p> <p>El m\u00e9todo <code>System.out.println</code> y sus derivados llaman autom\u00e1ticamente al m\u00e9todo toString si se le pasa el objeto</p> <pre><code>public static void main(String[] args){\nVehicle car = new Vehicle(4, \"rojo\");\nSystem.out.println(car); // Es lo mismo que car.toString()\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-7/","title":"Ejercicios","text":"Ejercicio 8 <p>Crea un paquete llamado exercise08 y realiza una clase de nombre Alumno que cumpla estas especificaciones:</p> <ul> <li>El constructor admite como argumentos el n\u00famero de matr\u00edcula y el nombre y almacena \u00e9stos en los correspondientes atributos.</li> </ul> <p>Contiene los siguientes m\u00e9todos:</p> <ul> <li>ponNota: con dos argumentos de tipo double que corresponden a dos notas de su examen. El m\u00e9todo almacena \u00e9stos en dos atributos de tipo double.</li> <li>dameMedia: retorna la media de las notas.</li> <li>toString: retorna una descripci\u00f3n del alumno con todos sus datos, incluida la nota media</li> </ul> <p>Realiza una aplicaci\u00f3n de nombre VerAlumno que solicite los datos de un alumno y sus notas, construya un objeto de la clase Alumno y muestre los datos de \u00e9ste.</p> Ejercicio 9 <p>Crea un paquete llamado exercise09 y realiza una clase que represente una pel\u00edcula en DVD de nombre DVDCine con los atributos necesarios para mostrar su ficha. La pel\u00edcula tiene dos nombres, el original y el traducido. Esta clase contar\u00e1 con un constructor que admite como argumentos todos los atributos de la clase.</p> <p>Escribe los siguientes m\u00e9todos para la clase DVDCine:</p> <ul> <li>esThriller: este m\u00e9todo devuelve cierto si la pel\u00edcula pertenece a este g\u00e9nero cinematogr\u00e1fico (tratar los g\u00e9neros de las pel\u00edculas como enum)</li> <li>tieneResumen: devuelve cierto si la ficha de la pel\u00edcula tiene el resumen escrito.</li> <li>muestraDuracion: devuelve una cadena con la duraci\u00f3n en minutos. Ejemplo: 114 min.</li> <li> <p>toString: este m\u00e9todo devuelve una descripci\u00f3n completa de la pel\u00edcula de la siguiente manera:</p> <p>UN FINAL MADE IN HOLLYWOOD (HOLLYWOOD ENDING) De: Woody Allen Con: Woody Allen y George Hamilton Comedia - 114 min Resumen: Los Oscars ganados en el pasado por el ex-genio del cine Val Waxman...</p> </li> </ul> <p>Si la pel\u00edcula no tiene resumen, la \u00faltima l\u00ednea no aparece. Escribe una aplicaci\u00f3n que solicite los datos de una pel\u00edcula, genere un objeto DVD y pruebe todos los m\u00e9todos.</p> Ejercicio 10 <p>Realizar una clase de nombre Alimento en el paquete exercise10 cuyos objetivos representen alimentos. \u00c9stos tendr\u00e1n los atributos siguientes:</p> <ul> <li>Nombre</li> <li>Contenido en l\u00edpidos expresado en tanto por ciento</li> <li>Contenido en hidratos de carbono expresado en tanto por ciento</li> <li>Contenido en prote\u00ednas expresado en tanto por ciento</li> <li>Si es o no de origen animal</li> <li>Contenido en vitaminas expresado mediante un enum ALTO, MEDIO y BAJO.</li> <li>Contenido en minerales expresado con el mismo enum que las vitaminas.</li> </ul> <p>La clase tiene dos constructores: uno que admite como argumentos el nombre del alimento y otro que admite todos los atributos. La clase contiene los siguientes m\u00e9todos:</p> <ul> <li>esDietetico. Este m\u00e9todo retorna cierto si el alimento contiene menos del 20% de l\u00edpidos y el contenido en vitaminas no es bajo.</li> <li>toString. Retorna una descripci\u00f3n del alimentos, mostrando el contenido de vitaminas y minerales solo la inicial, es decir, si es ALTO solo muestra A.</li> <li>calculaContenidoEnergetico. Este m\u00e9todo retorna el contenido en Kcal de un gramo de alimento, considerando que un gramo de l\u00edpidos contiene 9.4Kcal, un gramo de prote\u00ednas contiene 5.3 y un gramo de hidratos de carbono contiene 4.1 Kcal.</li> <li>esRecomendableParaDeportistas. Este m\u00e9todo retorna cierto si el alimento cumple la siguiente lista: prote\u00ednas: 10-15%, l\u00edpidos: 30-35%, hidratos de carbono: 55-65%.</li> </ul> <p>Hacer una aplicaci\u00f3n en la que se creen dos alimentos usando los dos constructores. Mostrar los datos de los alimentos, sus contenidos energ\u00e9ticos, si son diet\u00e9ticos y recomendables para deportistas.</p> Ejercicio 11 <p>Realiza una clase de nombre Veh\u00edculo en el paquete exercise11 que contenga como atributos el modelo de tipo  String, la potencia de tipo double y la tracci\u00f3n a las cuatro ruedas(cRuedas) de tipo boolean. El constructor de la clase admitir\u00e1 como argumento el modelo. La clase tendr\u00e1 como m\u00e9todos de tipo get y set para la potencia y para la tracci\u00f3n a las cuatro ruedas. La clase contar\u00e1 con el m\u00e9todo toString el cual retorna los datos de cada veh\u00edculo y si tiene tracci\u00f3n a las cuatro ruedas. Realiza una aplicaci\u00f3n que solicite al usuario los datos de varios veh\u00edculos hasta que el usuario escriba como modelo la cadena \u201cfin\u201d en may\u00fascula o en min\u00fascula, en cuyo caso no se generar\u00e1 el objeto de la clase Veh\u00edculo. Una vez introducidos todos los veh\u00edculos, la aplicaci\u00f3n terminar\u00e1 mostrando los datos de todos los veh\u00edculos y emitiendo un mensaje de despedida.</p> Ejercicio 12 <p>Una tienda de inform\u00e1tica nos ha contratado para hacerle una aplicaci\u00f3n en java. De los  productos que tiene, quiere almacenar el modelo, el stock, el procesador y el precio, con las siguientes caracter\u00edsticas:</p> <ul> <li>El modelo tiene el siguiente formato: tres d\u00edgitos, guion y cuatro letras may\u00fasculas(incluida la \u00f1). Ejemplos:  112-ACER,334-HHPP,435-ASUS</li> <li>El procesador solamente puede ser de dos tipos: Intel o Amd. Los intel traen una memoria de 8Gb y los Amd de 4Gb.</li> <li>El precio en formato decimal y el stock. Ambos deben ser positivos.</li> </ul> <p>Crea la clase Producto en el paquete exercise12 haciendo lo siguiente:</p> <ul> <li>Los atributos no ser\u00e1n visibles desde fuera de la clase.</li> <li>Crea un m\u00e9todo para consultar el modelo que solamente sea visible para las clases del mismo paquete.</li> <li>Crea un m\u00e9todo para consultar el stock visible para todas las clases.</li> <li>Crea m\u00e9todos para actualizar los atributos que sean visibles tambi\u00e9n para las clases de otro paquete. Se encargar\u00e1n de hacer las comprobaciones necesarias para garantizar que el   formato o los rangos de valores son correctos y lanzar\u00e1n la excepci\u00f3n IllegalArgumentException cuando no sean v\u00e1lidos.</li> <li>Crea un constructor con par\u00e1metros que inicialice los atributos del objeto con los valores indicados en los par\u00e1metros. El constructor no construir\u00e1 el objeto si alg\u00fan atributo no es v\u00e1lido. Para ello, utilizar\u00e1 los m\u00e9todos anteriores para garantizar que los valores de los atributos sean correctos.</li> <li>Crea un constructor que inicialice los atributos del objeto con los siguientes valores. Utiliza el this(par\u00e1metros).<ul> <li>Modelo: 000-NNNN</li> <li>Stock: 0</li> <li>Procesador Intel</li> <li>Precio: 0</li> </ul> </li> <li>Crea el m\u00e9todo toString(). Muestra el precio con 2 decimales.</li> <li>Crea el m\u00e9todo disminuirStock() que decremente en 1 el stock del producto</li> </ul>"},{"location":"bloque_i/tema_4/page-8/","title":"Proyecto","text":"<p>Se va a realizar un proyecto para almacenar la informaci\u00f3n referente al usuario sobre su cuenta bancaria.</p> <p>La informaci\u00f3n se escribir\u00e1 en una clase llamada Account y contendr\u00e1 los siguientes atributos, m\u00e9todos y restricciones:</p> <ul> <li>Un titular, que por ninguna circunstancia podr\u00e1 faltar.</li> <li>N\u00famero de la cuenta, que debe tener 24 caracteres, siendo los dos primeros caracteres el pa\u00eds al que pertenece y los dos siguientes n\u00fameros el n\u00famero de la entidad en la cu\u00e1l se creo la cuenta. Los 8 primeros caracteres (incluido el pa\u00eds y la entidad) hacen referencia al c\u00f3digo IBAN.</li> <li>Saldo de la cuenta, puede ser negativo.</li> <li>M\u00e9todos para mostrar informaci\u00f3n de la cuenta (N\u00ba de la cuenta, IBAN, etc).</li> <li>M\u00e9todos para sacar e ingresar dinero en la cuenta.</li> <li>M\u00e9todo para consultar el saldo.</li> </ul> <p>Crea una clase App que contenga el main del proyecto, solicit\u00e1ndole al usuario los datos necesarios para crear una cuenta si no la tiene creada ya, y luego se le mostrar\u00e1 las siguientes opciones de forma infinita hasta que desee salir de la app:</p> <ol> <li>Ver cuenta</li> <li>Ver saldo</li> <li>Retirar dinero</li> <li>Ingresar dinero</li> <li>Salir</li> </ol> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ol> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>Se har\u00e1 uso del encapsulamiento y de todo las formas \u00f3ptimas vista durante la unidad</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre pr04-java-NOMBRE-poo siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ol>"},{"location":"bloque_i/tema_5/page-1/","title":"1 Excepciones","text":""},{"location":"bloque_i/tema_5/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Uno de los problemas m\u00e1s importantes al escribir aplicaciones es el tratamiento de los errores. Los  errores  detienen  la  ejecuci\u00f3n  del  programa  e  impiden  su  desarrollo  normal  y,  lo  peor, adem\u00e1s provocan que el usuario est\u00e9 desinformado. Los programadores tiene que reconocer las situaciones que pueden provocar el fin de la ejecuci\u00f3n normal del programa por un error no controlado.  Dicho  de  otra  forma,  todos  los  posibles  errores  en  un  programa  deben  de  estar controlados. A veces es imposible evitarlos (por ejemplo no hay papel en la impresora, o falla el disco  duro),  pero  s\u00ed  reaccionar  de  forma  l\u00f3gica  para  que  el  usuario  reconozca  lo  que  est\u00e1 ocurriendo</p> <p>Java nos echa una mano para ello a trav\u00e9s de las excepciones. Se denomina excepci\u00f3n a un hecho que podr\u00eda provocar la detenci\u00f3n del programa; es decir una condici\u00f3n de error en tiempo de ejecuci\u00f3n pero que puede ser controlable (a trav\u00e9s de los mecanismos adecuados). En java sin embargo se denomina error a una condici\u00f3n de error incontrolable (ejemplos son el error que ocurre cuando no se dispone de m\u00e1s memoria o errores de sintaxis). Los  errores  de  sintaxis  son  detectados  durante  la  compilaci\u00f3n,  pero  los  errores  de  ejecuci\u00f3n pueden  provocar  situaciones  irreversibles,  su  control  debe  hacerse  tambi\u00e9n  en  tiempo  de ejecuci\u00f3n y eso siempre ha sido problem\u00e1tico para la programaci\u00f3n de aplicaciones.</p> <p>En Java se puede preparar el c\u00f3digo susceptible a provocar excepciones de modo que si ocurre una excepci\u00f3n, el c\u00f3digo es lanzado (throw) a una determinada rutina previamente preparada por el programador, que permite manipular esa excepci\u00f3n. Si la excepci\u00f3n no fuera capturada, la ejecuci\u00f3n del programa se detendr\u00eda irremediablemente (en muchas ocasiones la propia sintaxis de Java impide que la excepci\u00f3n no sea controlada; es decir, obliga a controlarla)</p>"},{"location":"bloque_i/tema_5/page-1/#try-catch","title":"Try-catch","text":"<p>El control de las excepciones se realiza mediante las sentencias try y catch.</p> <pre><code>try{\n// instrucciones que puedan provocar la excepci\u00f3n\n} catch(ClassException1 objetoQueLoCaptura){\n// instrucciones que se ejecutan si hay un error de tipo ClassException1\n} catch(ClassException2 objetoQueLoCaptura){\n// instrucciones que se ejecutan si hay un error de tipo ClassException2\n}\n// ...\n</code></pre> <p>Como se puede observar, puede haber m\u00e1s de una sentencia catch para un mismo bloque try debido a que un bloque de c\u00f3digo puede ser susceptible a provocar varios tipos diferentes de excepciones.</p> <p>Dentro del bloque try se colocan las instrucciones susceptibles de provocar una excepci\u00f3n, el bloque catch sirve para capturar esa excepci\u00f3n y evitar el fin de la ejecuci\u00f3n del programa. Desde el bloque catch se maneja, en definitiva, la excepci\u00f3n.</p> <p>Cada catch maneja un tipo de excepci\u00f3n. Cuando se produce una excepci\u00f3n, se busca el catch que posea el manejador de excepci\u00f3n adecuado, ser\u00e1 el que utilice el mismo tipo de excepci\u00f3n que se ha producido. La b\u00fasqueda del catch se realiza en el orden en que se han escrito. Si se produce una excepci\u00f3n, primero se mira si cuadra en el primer catch. Si no cuadra, se pasa al siguiente, y as\u00ed sucesivamente. Por este motivo, es importante el orden en que se coloquen los bloques catch.</p> <p>Cuando acaba la ejecuci\u00f3n del bloque catch, el programa contin\u00faa con la ejecuci\u00f3n del c\u00f3digo que le sigue al bloque del try-catch.</p> <pre><code>public class TryCatch {\npublic void show(){\nfinal String FIN = \"fin\";\nint base, exponent;\nString baseString;\nScanner keyboard = new Scanner(System.in);\ntry{\nSystem.out.println(\"Bienvenido al programa para calcular la potencia\");\nSystem.out.print(\"Introduce la base o fin para terminar\");\nbaseString = keyboard.nextLine();\nif(!baseString.equalsIgnoreCase(FIN)){\nbase = Integer.parseInt(baseString);\nSystem.out.print(\"Introduce el exponente: \");\nexponent = keyboard.nextInt();\nSystem.out.printf(\"%d elevado a %d es igual a %d\\n\", base, exponent, (int) Math.pow(base, exponent));\n}\n} catch (NumberFormatException e){\nSystem.out.println(\"Error en la base\");\n} catch (InputMismatchException e){\nSystem.out.println(\"Error en el exponente\");\n}\n}\npublic static void main(String[] args) {\nnew TryCatch().show();\n}\n}\n</code></pre> <p>Para  la  base,  si  el  usuario  no  introduce  fin  y  tampoco  introduce  un  n\u00famero  entero,  el <code>Integer.parseInt</code> al  intentar  convertir  la  cadena  a  n\u00famero  lanzar\u00e1  una  excepci\u00f3n  de  tipo <code>NumberFormatException</code> y ser\u00e1 manejada por el catch correspondiente. Para el exponente, si se introduce algo que no sea un n\u00famero (una letra, un s\u00edmbolo...), se producir\u00e1 una excepci\u00f3n de tipo <code>InputMismatchException</code> y se manejar\u00e1 por su correspondiente catch. Si se produce un error de otro tipo, el programa se detendr\u00e1.</p> <p>Puede  ser  que  el  programador  quiera  mostrar  el  mismo  mensaje  de  error  para  ambas excepciones. En este caso se utiliza el multi-catch, incorporado en Java desde la versi\u00f3n 7:</p> <pre><code>public class MultiCatch {\npublic void show(){\nfinal String FIN = \"fin\";\nint base, exponent;\nString baseString;\nScanner keyboard = new Scanner(System.in);\ntry{\nSystem.out.println(\"Bienvenido al programa para calcular la potencia\");\nSystem.out.print(\"Introduce la base o fin para terminar\");\nbaseString = keyboard.nextLine();\nif(!baseString.equalsIgnoreCase(FIN)){\nbase = Integer.parseInt(baseString);\nSystem.out.print(\"Introduce el exponente: \");\nexponent = keyboard.nextInt();\nSystem.out.printf(\"%d elevado a %d es igual a %d\\n\", base, exponent, (int) Math.pow(base, exponent));\n}\n} catch (NumberFormatException | InputMismatchException e){\nSystem.out.println(\"Error en la base o en el exponente\");\n}\n}\npublic static void main(String[] args) {\nnew MultiCatch().show();\n}\n}\n</code></pre> <p>En la programaci\u00f3n de aplicaciones en general siempre ha habido dos formas de manejar una excepci\u00f3n:</p> <ul> <li>Interrupci\u00f3n: en este caso se asume que el programa ha encontrado un error irrecuperable. La operaci\u00f3n que dio lugar a la excepci\u00f3n se anula y se entiendo que no hay manera de regresar al c\u00f3digo que provoc\u00f3 la excepci\u00f3n.</li> <li>Reanudaci\u00f3n: se puede manejar el error y regresar al c\u00f3digo que provoc\u00f3 el error.</li> </ul> <p>La filosof\u00eda de Java es del tipo interrupci\u00f3n, pero se puede intentar emular la reanudaci\u00f3n encerrando el bloque try en un bucle que se repetir\u00e1 hasta que el error deje existir:</p> <pre><code>public class Resumption {\npublic void show(){\nbyte number = 0;\nScanner keyboard = new Scanner(System.in);\nboolean error = false;\ndo{\ntry{\nSystem.out.print(\"Introduce un n\u00famero de tipo byte, es decir, entre -128 y 127: \");\nnumber = keyboard.nextByte();\nSystem.out.printf(\"Valor del n\u00famero: %d\\n\", number);\nerror = false; // Si se ha entrado antes en el catch, error est\u00e1 a true\n} catch (InputMismatchException e){\nSystem.out.println(\"Error\");\nerror = true;\nkeyboard.nextLine(); // Limpieza de buffer\n}\n} while (error);\n}\npublic static void main(String[] args) {\nnew Resumption().show();\n}\n}\n</code></pre> <p>Si el usuario introduce cualquier cosa que no sea un n\u00famero, el m\u00e9todo <code>nextByte()</code> lanza la excepci\u00f3n <code>InputMismatchException</code> y lo que ha metido el usuario se queda en el buffer. Para solucionarlo, se realiza una limpieza del buffer con <code>keyboard.nextLine()</code>.</p>"},{"location":"bloque_i/tema_5/page-1/#metodos-de-las-excepciones","title":"M\u00e9todos de las excepciones","text":"<ul> <li>getMessage: obtiene el mensaje descriptivo de la excepci\u00f3n.</li> <li>toString: devuelve una cadena sobre la situaci\u00f3n de la excepci\u00f3n. Suele indicar la clase de excepci\u00f3n y el texto de getMessage.</li> <li>printStackTrace: escribe el m\u00e9todo y mensaje de la excepci\u00f3n (la llamada informaci\u00f3n de pila). El resultado es el mismo mensaje que muestra el ejecutor (la m\u00e1quina virtual de Java) cuando no se controla la excepci\u00f3n.</li> </ul> <pre><code>public class MethodsOfExceptions {\npublic void show(){\nfinal String FIN = \"fin\";\nint base, exponent;\nString baseString;\nScanner keyboard = new Scanner(System.in);\ntry{\nSystem.out.println(\"Bienvenido al programa para calcular la potencia\");\nSystem.out.print(\"Introduce la base o fin para terminar\");\nbaseString = keyboard.nextLine();\nif(!baseString.equalsIgnoreCase(FIN)){\nbase = Integer.parseInt(baseString);\nSystem.out.print(\"Introduce el exponente: \");\nexponent = keyboard.nextInt();\nSystem.out.printf(\"%d elevado a %d es igual a %d\\n\", base, exponent, (int) Math.pow(base, exponent));\n}\n} catch (NumberFormatException e){\nSystem.out.println(GREEN + e.getMessage() + RESET);\nSystem.out.println(CYAN + e + RESET); // e.toString()\ne.printStackTrace();\n} catch (InputMismatchException e){\nSystem.out.println(GREEN + e.getMessage() + RESET);\nSystem.out.println(CYAN + e + RESET); // e.toString()\ne.printStackTrace();\n}\n}\npublic static void main(String[] args) {\nnew MethodsOfExceptions().show();\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-1/#cuando-se-debe-capturar-una-excepcion","title":"Cuando se debe capturar una excepci\u00f3n","text":"<p>Una excepci\u00f3n se debe capturar cuando no sea un error de programaci\u00f3n, es decir, el programador debe distinguir si esa excepci\u00f3n es un error suyo de programaci\u00f3n o no, poeque si es un error de programaci\u00f3n, no debe capturar el error sino solucionarlo.</p> <p>Por ejemplo, cuando se intenta acceder a una parte de la cadena que no existe, por ejemplo, si la cadena hola le hacemos charAt(4), Java nos lanza la excepci\u00f3n StringIndexOutOfBoundsException. El programador no debe capturar con un try-catch, sino que debe corregir el error de programaci\u00f3n que ha producido dicha excepci\u00f3n.</p>"},{"location":"bloque_i/tema_5/page-2/","title":"2 Throws, throws y finally","text":""},{"location":"bloque_i/tema_5/page-2/#tipos-de-excepciones","title":"Tipos de excepciones","text":"<p>En Java, la herencia define una relaci\u00f3n entre clases en la cual una clase posee caracter\u00edsticas (m\u00e9todos y propiedades) que proceden de otra. A la clase que posee las caracter\u00edsticas a heredar se la llama superclase o clase padre y la clase que las hereda se llama subclase o clase hija. Lo beneficioso de este tipo de relaciones es que los hijos pueden heredar las caracter\u00edsticas de los padres y luego aportar caracter\u00edsticas propias convirti\u00e9ndose en una manera de reutilizar c\u00f3digo muy eficiente.</p> <p>Java  utiliza  much\u00edsimo  la  herencia  en  las  clases  que  conforman  su  API.  En  cuanto  a  las excepciones se refiere, existen tres tipos de excepciones que Java maneja a trav\u00e9s de la herencia: errores,  comprobadas  (checked)  y  no  comprobadas  (unchecked).  El  gr\u00e1fico  que  se  muestra  a continuaci\u00f3n muestra el \u00e1rbol de herencia de las excepciones en Java. El paquete de todas es java.lang:</p> <pre><code>classDiagram\n    Throwable &lt;|-- Error\n    Throwable &lt;|-- Exception\n    Error &lt;|-- Error Exception\n    Exception &lt;|-- OtrasExceptions\n    Exception &lt;|-- RuntimeExceptions\n    RuntimeExceptions &lt;|-- OtrasRuntimeExceptions</code></pre> <p>La clase principal de la cual heredan todas las excepciones Java es Throwable. De ella nacen dos ramas: Error y Exception. Error representa errores de una magnitud tal que una aplicaci\u00f3n nunca deber\u00eda intentar realizar nada con ellos (como errores de la JVM, desbordamientos de buffer, etc). La segunda rama, encabezada por Exception, representa aquellos errores que normalmente s\u00ed solemos gestionar, y a los que com\u00fanmente solemos llamar excepciones.</p> <p>De  Exception  nacen  m\u00faltiples  ramas:  ClassNotFoundException,  IOException,  ParseException, SQLException y otras  muchas,  todas  ellas  de  tipo  checked.  La  \u00fanica  excepci\u00f3n  es RuntimeException que es de tipo unchecked y encabeza todas las de este tipo.</p>"},{"location":"bloque_i/tema_5/page-2/#excepciones-checked","title":"Excepciones checked","text":"<p>Una  excepci\u00f3n  de  tipo  checked  representa  un  error  del  cual  t\u00e9cnicamente  podemos recuperarnos. En ciertos momentos, a pesar de la promesa de recuperabilidad, nuestro c\u00f3digo no  estar\u00e1  preparado  para  gestionar  la  situaci\u00f3n  de  error,  o  simplemente  no  ser\u00e1  su responsabilidad. En estos casos lo m\u00e1s razonable es relanzar la excepci\u00f3n y confiar en que un m\u00e9todo superior en la cadena de llamadas sepa gestionarla.</p> <p>Por  tanto,  todas  las  excepciones  de  tipo  checked  deben  ser  capturadas  o  relanzadas.  En  el primer caso, utilizamos el bloque try-catch. En caso de querer relanzar la excepci\u00f3n, debemos declarar dicha intenci\u00f3n en la firma de la funci\u00f3n que contiene las sentencias que lanzan la excepci\u00f3n, y lo hacemos mediante la clausula throws.</p> <p>Hay que tener presente que cuando se relanza una excepci\u00f3n estamos forzando al c\u00f3digo cliente de nuestro m\u00e9todo a capturarla o relanzarla. Una excepci\u00f3n que sea relanzada una y otra vez hacia arriba terminar\u00e1 llegando al m\u00e9todo primigenio y, en caso de no ser capturada por \u00e9ste, producir\u00e1 la finalizaci\u00f3n de su hilo de ejecuci\u00f3n (thread).</p> <p>La  dos  preguntas  que  debemos  hacernos  en  este  momento  es:  \u00bfCu\u00e1ndo  capturar  una excepci\u00f3n? \u00bfCu\u00e1ndo relanzarla? La respuesta es muy simple. Capturamos una excepci\u00f3n cuando: - - Podemos recuperarnos del error y continuar con la ejecuci\u00f3n.</p> <ul> <li>Queremos registrar el error.</li> <li>Queremos relanzar el error con un tipo de excepci\u00f3n distinto.</li> </ul> <p>En  definitiva,  cuando  tenemos  que  realizar  alg\u00fan  tratamiento  del  propio  error.  Por  contra, relanzamos una excepci\u00f3n cuando:</p> <ul> <li>No es competencia nuestra ning\u00fan tratamiento de ning\u00fan tipo sobre el error que se ha producido.</li> <li>Para centralizar el control de excepciones y facilitar el mantenimiento del c\u00f3digo.</li> </ul>"},{"location":"bloque_i/tema_5/page-2/#excepciones-unchecked","title":"Excepciones unchecked","text":"<p>Son excepciones de tipo RuntimeException o de cualquiera de sus subclases. El aspecto m\u00e1s destacado de las excepciones de tipo unchecked es que no deben ser forzosamente declaradas ni capturadas (en otras palabras, no son comprobadas). Por ello no son necesarios bloques try-catch ni declarar formalmente en la firma de la funci\u00f3n el lanzamiento de excepciones de este tipo. \u00c9sto, por supuesto, tambi\u00e9n afecta a funciones y/o clases m\u00e1s hacia arriba en la cadena invocante.</p>"},{"location":"bloque_i/tema_5/page-2/#throws","title":"Throws","text":"<p>En caso de querer relanzar la excepci\u00f3n, debemos declarar dicha intenci\u00f3n en la firma de la funci\u00f3n que contiene las sentencias que lanzan la excepci\u00f3n, y lo hacemos mediante la clausula throws.</p> <p>\u00bfTiene obligaci\u00f3n de tener un try-catch el que llame a la funci\u00f3n? Si la excepci\u00f3n es de tipo RuntimeException o cualquiera de sus hijas, no existe la obligaci\u00f3n de poner un try-catch. En cualquier  otro  caso,  s\u00ed  existe  dicha  obligaci\u00f3n,  de  hecho  si  no  se  hace,  Java  da  un  error  de compilaci\u00f3n.</p> <pre><code>public class Throws {\npublic void show(){\nfinal String FIN = \"fin\", SIGUIENTE = \"siguiente\";\nint number;\nString string;\nScanner keyboard = new Scanner(System.in);\ntry{\nSystem.out.print(\"Introduce un n\u00famero o siguiente para pasar al siguiente n\u00famero: \");\nstring = keyboard.nextLine();\nif(!string.equalsIgnoreCase(SIGUIENTE)){\n/*\n                 * Aqu\u00ed no estamos obligados a poner un try-catch porque\n                 * NumberFormatException es hija de RuntimeException\n                 */\nnumber = convertirNumero(string);\nSystem.out.printf(\"Valor del n\u00famero introducido: %d\\n\", number);\n}\n} catch (NumberFormatException e){\nSystem.out.println(\"Error en el n\u00famero\");\n}\ntry {\nSystem.out.print(\"Introduce un n\u00famero o fin para terminar: \");\nstring = keyboard.nextLine();\nif(!string.equalsIgnoreCase(FIN)){\n/*\n                 * Aqu\u00ed estamos obligados a poner un try-catch porque\n                 * Exception no es hija de RuntimeException\n                 */\nnumber = convertirNumero2(string);\nSystem.out.printf(\"Valor del n\u00famero introducido: %d\\n\", number);\n}\n} catch (Exception e){\nSystem.out.println(\"Error en el n\u00famero\");\n}\n}\nprivate int convertirNumero2(String string) {\nreturn Integer.parseInt(string);\n}\nprivate int convertirNumero(String string) throws NumberFormatException {\nreturn Integer.parseInt(string);\n}\npublic static void main(String[] args) {\nnew Throws().show();\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-2/#orden-de-los-catch","title":"Orden de los catch","text":"<p>Cuando se tienen varios catch para el mismo try, hay que tener la precauci\u00f3n de poner los catch de las subclases antes que los de las superclases porque si no, los catch de las subclases nunca se capturar\u00edan. Ejemplo:</p> <pre><code>public class CatchOrder1 {\npublic void show(){\nfinal String FIN = \"fin\";\nString string;\nbyte number = 0;\nScanner keyboard = new Scanner(System.in);\ntry {\nSystem.out.print(\"Introduce un n\u00famero de tipo byte, es decir, entre -128 y 127: \");\nnumber = keyboard.nextByte();\nkeyboard.nextLine(); //Limpieza del buffer\nSystem.out.printf(\"Valor del n\u00famero introducido: %d\\n\", number);\nSystem.out.print(\"Introduzca otro n\u00famero de tipo byte o fin para terminar: \");\nstring = keyboard.nextLine();\nif (!string.equalsIgnoreCase(FIN)) {\nnumber = Byte.parseByte(string);\nSystem.out.printf(\"Valor del otro n\u00famero introducido: %d\\n\", number);\n}\n} catch (Exception e) {\nSystem.out.println(\"Error: no ha introducido un n\u00famero entre -128 y 127\");\n} catch (InputMismatchException e) { //Error de compilaci\u00f3n:inalcanzable bloque catch\nSystem.out.println(\"Error\");\n}\n}\npublic static void main(String[] args) {\nnew CatchOrder1().show();\n}\n}\n</code></pre> <p>En  este  caso,  Java  da  un  error  de  compilaci\u00f3n  ya  que  InputMismatchException  es  hija  de Exception. Si el usuario no introduce un n\u00famero de tipo byte, se lanza una excepci\u00f3n de tipo InputMismatchException.  Dicho  objeto  tambi\u00e9n  es  un  objeto  de  tipo  Exception,  ya  que  los objetos de tipo hijo, tambi\u00e9n son objetos de tipo padre.  Entonces, nunca entrar\u00eda en el catch del InputMismatchException. La soluci\u00f3n es cambiar el orden de los catch:</p> <pre><code>public class CatchOrder2 {\npublic void show(){\nfinal String FIN = \"fin\";\nString string;\nbyte number = 0;\nScanner keyboard = new Scanner(System.in);\ntry {\nSystem.out.print(\"Introduce un n\u00famero de tipo byte, es decir, entre -128 y 127: \");\nnumber = keyboard.nextByte();\nkeyboard.nextLine(); //Limpieza del buffer\nSystem.out.printf(\"Valor del n\u00famero introducido: %d\\n\", number);\nSystem.out.print(\"Introduzca otro n\u00famero de tipo byte o fin para terminar: \");\nstring = keyboard.nextLine();\nif (!string.equalsIgnoreCase(FIN)) {\nnumber = Byte.parseByte(string);\nSystem.out.printf(\"Valor del otro n\u00famero introducido: %d\\n\",\nnumber);\n}\n} catch (InputMismatchException e) {\nSystem.out.println(\"Error: no ha introducido un n\u00famero entre -128 y 127\");\n} catch (Exception e) {\nSystem.out.println(\"Error\");\n}\n}\npublic static void main(String[] args) {\nnew CatchOrder2().show();\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-2/#throw","title":"Throw","text":"<p>Esta instrucci\u00f3n le permite al programador lanzar una excepci\u00f3n. Por ejemplo: <code>throw new Exception();</code>. El flujo del programa se dirigir\u00e1 a la instrucci\u00f3n try-catch m\u00e1s cercana.</p> <p>Se pueden utilizar constructores en esta llamada (el formato de los constructores depende de la clase que se utilice): <code>throw new Exception(\"Error grave\");</code> Esto construye una excepci\u00f3n con el mensaje indicado. Ese mensaje se puede obtener en el catch con el m\u00e9todo <code>getMessage()</code> del objeto que contiene la excepci\u00f3n.</p> <pre><code>public class Throw {\npublic void show() {\ndouble n;\nScanner keyboard = new Scanner(System.in);\ntry {\nSystem.out.println(\"Introduce un n\u00famero: \");\nn = keyboard.nextDouble();\ndivision(n);\n} catch (ArithmeticException e) {\nSystem.out.println(e.getMessage());\n}\n}\npublic void division(double n) {\n/*\n         * float y double admiten Infinity por lo que no se lanza\n         * una excepci\u00f3n cuando se divide entre cero.\n         * Podemos lanzar la excepci\u00f3n usando throw\n         * */\nif (n == 0) {\nthrow new ArithmeticException(\"Error: no se puede dividir entre cero\");\n}\nSystem.out.printf(\"500 entre %.2f: %.2f\\n\", n, 500 / n);\n}\npublic static void main(String[] args) {\nnew Throw().show();\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-2/#finally","title":"Finally","text":"<p>Las instrucciones que se encuentran en el finally se ejecutan independientemente de si hubo o no excepci\u00f3n. Es decir, esas sentencias se ejecutan siempre. Si el c\u00f3digo del try ha ido bien y no se ha lanzado ninguna excepci\u00f3n, despu\u00e9s se ejecutan las instrucciones del finally y luego se contin\u00faa  por  el  c\u00f3digo  que  le  sigue  al  bloque  del  try-catch.  Pero  si  se  ha  lanzado  alguna excepci\u00f3n,  se  ejecutan  las  instrucciones  del  catch  correspondiente,  luego  se  ejecutan  las instrucciones del finally y luego se contin\u00faa por el c\u00f3digo que le sigue al bloque del try-catch. Por ello se coloca en el bloque finally c\u00f3digo com\u00fan para todas las excepciones y tambi\u00e9n para cuando no hay excepciones. Normalmente se suelen poner instrucciones de limpieza. Ejemplo:</p> <pre><code>public class Finally {\npublic void show() {\nint number = 0;\nString string;\nboolean error = false;\nScanner keyboard = new Scanner(System.in);\ntry {\nSystem.out.print(\"Introduce un n\u00famero: \");\nnumber = keyboard.nextInt();\n} catch (InputMismatchException e) {\nSystem.out.println(\"Error\");\nerror = true;\n} finally {\nkeyboard.nextLine();//Limpieza del buffer\n}\nSystem.out.print(\"Introduce una cadena: \");\nstring = keyboard.nextLine();\nSystem.out.printf(\"El n\u00famero introducido ha sido: %s\\n\", error ? \"error\" : number);\nSystem.out.printf(\"La cadena introducida ha sido: %s\", string);\n}\npublic static void main(String[] args) {\nnew Finally().show();\n}\n}\n</code></pre> <p>En el ejemplo, hay que limpiar el buffer haya o no una excepci\u00f3n, por lo tanto, se limpia en el finally.</p> <p>Pero \u00bfqu\u00e9 diferencia hay entre poner c\u00f3digo en el finally o ponerlo despu\u00e9s del bloque try-catch? Pues que en el finally siempre se va a ejecutar aunque se rompa el flujo de ejecuci\u00f3n, es decir, aunque exista por ejemplo un  <code>return</code>  en el try  o  un  <code>throw</code>   en  el  catch.  El  c\u00f3digo  que  se encuentre despu\u00e9s del bloque try-catch, no se ejecutar\u00eda en esos casos</p>"},{"location":"bloque_i/tema_5/page-3/","title":"Ejercicios","text":"Ejercicio 1 <p>Escribe un programa que juegue con el usuario a adivinar un n\u00famero. El ordenador debe generar un n\u00famero entre 1 y 500, y el usuario tiene que intentar adivinarlo. Para ello, cada vez que el usuario introduce un valor, el ordenador debe decirle al usuario si el n\u00famero que tiene  que adivinar es mayor o menor que el que ha introducido el usuario. Cuando consiga adivinarlo, debe indic\u00e1rselo e imprimir en pantalla el n\u00famero de veces que el usuario ha intentado adivinar el n\u00famero. Si el usuario introduce algo que no es un n\u00famero, debe indicarlo en pantalla, y contarlo como un intento.</p> Ejercicio 2 <p>Crea un m\u00e9todo que se llame readInt() que se encargue de leer un n\u00famero introducido por teclado teniendo en cuentas las excepciones que puede provocar. Crea un main para probarlo.</p>"},{"location":"bloque_i/tema_5/page-4/","title":"Proyecto","text":"<p>Se va a continuar el proyecto que contiene una librer\u00eda con m\u00e9todos y clases \u00fatiles para facilitar ciertas operaciones.</p> <p>En esta versi\u00f3n, se crear\u00e1 una clase ConsoleInput que trabajar\u00e1 con m\u00e9todos para facilitar la lectura por teclado.</p> <p>La clase contendr\u00e1 una serie de m\u00e9todos que permitan solicitar al usuario distintos datos y que gestionen el hecho de que los datos introducidos no correspondan a los tipos esperados o que no sean valores v\u00e1lidos, de  manera que se les vuelva a solicitar de nuevo, hasta que los valores introducidos sean v\u00e1lidos. Internamente un m\u00e9todo puede llamar a otro m\u00e9todo de la clase.</p> <p>Info</p> <p>SE PODR\u00c1N CREAR ADEM\u00c1S LOS M\u00c9TODOS Y ATRIBUTOS QUE SE CONSIDEREN NECESARIOS</p> <p>\u00a1OJO!</p> <p>Se deber\u00e1 de tratar con minuciosidad todas las posibilidades haciendo uso de estructuras de control de excepciones.</p> <p>Los m\u00e9todos que aparecen a continuaci\u00f3n se refieren al tipo byte. Realizarlos tambi\u00e9n para los tipos short, int,long, float y double:</p> <ul> <li><code>readByte()</code>: retorna un byte introducido por el usuario.</li> <li><code>readByteUnsigned()</code>: lo mismo que el anterior, pero n\u00fameros sin signos.</li> <li><code>readByteLessThan(byte upperBound)</code>: retorna un byte introducido por el usuario inferior al par\u00e1metro.</li> <li><code>readByteUnsignedLessThan(byte upperBound)</code>: lo mismo que el anterior, pero n\u00fameros sin signos.</li> <li><code>readByteLessOrEqualThan(byte upperBound)</code>: retorna un byte introducido por el usuario inferior igual al par\u00e1metro.</li> <li><code>readByteUnsignedLessOrEqualThan(byte upperBound)</code>: lo mismo que el anterior, pero n\u00fameros sin signos</li> <li><code>readByteGreaterThan(byte lowerBound)</code>: retorna un byte introducido por el usuario superior al par\u00e1metro.</li> <li><code>readByteUnsignedGreaterThan(byte lowerBound)</code>: lo mismo que el anterior, pero n\u00fameros sin signos.</li> <li><code>readByteGreaterOrEqualThan(byte lowerBound)</code>: retorna un byte introducido por el usuario superior o igual al par\u00e1metro.</li> <li><code>readByteUnsignedGreaterOrEqualThan(byte lowerBound)</code>: Lo mismo que el anterior, pero n\u00fameros sin signos.</li> <li><code>readByteInRangeInclusive(byte lowerBound, byte upperBound)</code>: retorna un byte introducido por el usuario cuyo valor est\u00e9 en el rango [lowerBound, upperBound], ambos incluidos.</li> <li><code>readByteInRangeExclusive(byte lowerBound, byte upperBound)</code>: retorna un byte introducido por  el usuario cuyo valor est\u00e9 en el rango [lowerBound, upperBound], donde upperBound no est\u00e9 incluido.</li> </ul> <p>Adem\u00e1s, realizar los m\u00e9todos siguientes:</p> <ul> <li><code>readChar()</code>: retorna un car\u00e1cter introducido por el usuario. Si \u00e9ste introduce m\u00e1s de un car\u00e1cter, se le vuelve a solicitar.</li> <li><code>readChar(String validCharacters)</code>: retorna un car\u00e1cter introducido por el usuario. El par\u00e1metro validCharacters contiene los posibles caracteres v\u00e1lidos.</li> <li><code>readVowel()</code>: retorna una vocal introducida por el usuario.</li> <li><code>readDigit()</code>: retorna un car\u00e1cter d\u00edgito introducido por el usuario.</li> <li><code>readConsonant()</code>: retorna una consonante introducida por el usuario.</li> <li><code>readLowerCase()</code>: retorna una letra min\u00fascula introducida por el usuario.</li> <li><code>readUpperCase()</code>: retorna una letra may\u00fascula introducida por el usuario.</li> <li><code>readString()</code>: retorna una cadena de caracteres introducida por el usuario.</li> <li><code>readString(int maxLength)</code>: retorna una cadena de caracteres de como m\u00e1ximo maxLength caracteres.</li> <li><code>readBooleanUsingChar(char affirmativeValue)</code>: retorna un booleano a partir de un car\u00e1cter introducido por el usuario, de manera que si coincide con affirmativeValue (en may\u00fasculas o min\u00fasculas) retornar\u00e1 true, y si se trata de cualquier otro car\u00e1cter retornar\u00e1 false.</li> <li><code>readBooleanUsingChar()</code>: retorna un booleano a partir de un car\u00e1cter introducido por el usuario, de manera que si coincide con s o S retornar\u00e1 true y en caso contrario retornar\u00e1 false.</li> <li><code>readBooleanUsingInt(int affirmativeValue)</code>: retorna un booleano a partir de un entero introducido por el usuario, de manera que si coincide con el valor proporcionado retornar\u00e1 true, y si se trata de cualquier otro valor entero retornar\u00e1 false.</li> <li><code>readBooleanUsingInt()</code>: retorna un booleano a partir de un entero introducido por el usuario, de manera que si coincide con 1 retornar\u00e1 true, y si se trata de cualquier otro valor entero retornar\u00e1 false.</li> </ul> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ol> <li>NO se realizar\u00e1 una versi\u00f3n sobre el proyecto 3, sino que se realizar\u00e1 un copia de dicho proyecto en esta versi\u00f3n</li> <li>Se mantendr\u00e1 el paquete principal llamado <code>com.NOMBRE.common</code> donde nombre ser\u00e1 el nombre del alumno y common el nombre del proyecto.</li> <li>Se crear\u00e1 una clase Main, donde se ponga en pr\u00e1ctica los usos de la librer\u00eda y se valorar\u00e1 la complejidad de dicho Main.</li> <li>Se deber\u00e1n respetar el nombre de las funciones as\u00ed como el nombre de los par\u00e1metros.</li> <li>El nombre del resto de funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre <code>pr05java-NOMBRE-console</code>siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ol>"},{"location":"bloque_ii/tema_10/page-1/","title":"10.1 Introducci\u00f3n a los Gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-1/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Se trata de la implementaci\u00f3n en Java de una de las opciones de C++ m\u00e1s a\u00f1oradas por los programadores que proceden de ese lenguaje; las plantillas (templates). Son similares a las plantillas de C++. Sirven para evitar conversiones de clases.</p> <p>Uno de los motivos de la creaci\u00f3n de los gen\u00e9ricos fueron las colecciones. Sin los gen\u00e9ricos todas las colecciones ser\u00edan de tipo Object, lo que tendr\u00eda una serie de desventajas:</p> <ul> <li>Nada impide crear listas heterog\u00e9neas de objetos. Eso causa problemas evidentes de casting, adem\u00e1s de imposible incoherencias.</li> <li>Si se desea acceder a propiedades espec\u00edficas de otro tipo de clases, ser\u00e1 necesario realizar una cantidad grande de conversiones en el c\u00f3digo, lo que har\u00e1 que sea m\u00e1s pesado de comprender.</li> <li>Los m\u00e9todos de las clases e interfaces de las colecciones no se adaptan al tipo de datos que contienen dificultando su uso.</li> </ul> <p>Por ello aparecieron los tipos gen\u00e9ricos en la versi\u00f3n 1.5 de Java consiguiendo solucionar los problemas anteriores en las colecciones.</p>"},{"location":"bloque_ii/tema_10/page-1/#2-idea-general-de-los-genericos","title":"2. Idea general de los gen\u00e9ricos","text":"<p>Los gen\u00e9ricos permiten crear clases y m\u00e9todos en los que los tipos de datos (las clases) sobre los que act\u00faan son un par\u00e1metro m\u00e1s. Gracias a ello se pueden crear clases y m\u00e9todos que se adaptan a distintos tipos de datos de forma autom\u00e1tica.</p> <p>Anteriormente a la aparici\u00f3n de los gen\u00e9ricos el que las clases y m\u00e9todos se adaptaran autom\u00e1ticamente pasaba por especificar par\u00e1metros de tipo Object, ya que las referencias de tipo Object valen para cualquier otro tipo de objeto.</p> <p>El problema es que la coherencia no est\u00e1 asegurada con los tipos Object, la sintaxis del lenguaje puede provocar excepciones de tipo ClassCastException ante conversiones err\u00f3neas de Object a otro tipo de datos.</p> <p>La idea es:</p> <ol> <li>El programar declara un gen\u00e9rico en un m\u00e9todo de clase, por ejemplo T</li> <li>Cuando se utilice dicha clase o m\u00e9todo se indicar\u00e1 un tipo concreto, entonces se cambia el gen\u00e9rico para que se refiera a ese tipo concreto.</li> </ol>"},{"location":"bloque_ii/tema_10/page-2/","title":"10.2 Uso de gen\u00e9ricos","text":""},{"location":"bloque_ii/tema_10/page-2/#1-genericos-en-metodos","title":"1. Gen\u00e9ricos en m\u00e9todos","text":"<p>Se pueden indicar gen\u00e9ricos en los m\u00e9todos. Para indicar que el m\u00e9todo se puede utilizar con cualquier tipo de objeto y que el m\u00e9todo se adaptar\u00e1 a dicho tipo. La sintaxis es: <code>modificadores &lt;Gen\u00e9rico&gt; tipoRetorno nombreM\u00e9todo(...)</code></p> <p>Ejemplo:</p> <pre><code>public class ArrayUtils{\npublic static &lt;T&gt; T getRandom(T a[]){\nint i = new Random().nexInt(a.length-1);\nreturn a[i];\n}\n}\n</code></pre> <p>En el ejemplo anterior, se desea obtener un elemento aleatorio de un array. En el ejemplo la letra T entre los signos &lt; y &gt; indica que se va a utilizar un tipo gen\u00e9rico, el hecho de que le siga otra T significa que el tipo que devuelve el m\u00e9todo tomarAleatorio ser\u00e1 el mismo que el del par\u00e1metro a, y se corresponder\u00e1 al tipo gen\u00e9rico T. Despu\u00e9s cuando se invoque a este m\u00e9todo, la letra gen\u00e9rica T ser\u00e1 traducida por el tipo con el que se invoque al m\u00e9todo. Por ejemplo desde este c\u00f3digo:</p> <pre><code>String a[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString element = ArraysUtils.getRandom(a);\nSystem.out.println(element);\n</code></pre> <p>En ese c\u00f3digo, como se invoca usando un array de Strings, por lo tanto la letra gen\u00e9rica T ser\u00e1 traducida por String. Es decir es como si el c\u00f3digo anterior se tradujera como:</p> <pre><code>public class UtilesArrays {\npublic static String tomarAleatorio(String a[]){\nint i=(int)(Math.random()*a.length);\nreturn a[i];\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#2-genericos-en-las-clases","title":"2. Gen\u00e9ricos en las clases","text":"<p>El m\u00e9todo habitual de utilizar gen\u00e9ricos, debido a su mayor potencia, es declarar el gen\u00e9rico en una clase. De esta forma indicados que el c\u00f3digo de la clase utiliza tipos gen\u00e9ricos que ser\u00e1n traducidos por el tipo de datos que se desee.</p> <p>Por ejemplo una clase pensada para extraer elementos aleatorios de un array del tipo que sea se podr\u00eda declarar as\u00ed:</p> <pre><code>public class RandomElement&lt;T&gt; {\nprivate final T element;\npublic RandomElement(T[] array){\nelement = array[new Random().nextInt(array.length - 1)];\n}\npublic T getElement(){\nreturn element;\n}\n}\n</code></pre> <p>Los tipos se indican tras el nombre de la clase. De esta forma cuando se creen objetos de clase RandomElement habr\u00e1 que indicar la clase por la que se traducir\u00e1 el gen\u00e9rico T. Por ejemplo:</p> <pre><code>public static void main(String[] args) {\nString[] a = {\"uno\", \"dos\", \"tres\", \"cuatro\"};\nRandomElement&lt;String&gt; e = new RandomElement&lt;String&gt;(a);\nSystem.out.println(e.getElement());\n}\n</code></pre> <p>Obs\u00e9rvese que tanto al declarar el objeto e hay que concretar el valor del gen\u00e9rico de ah\u00ed que la declaraci\u00f3n sea <code>RandomElement&lt;String&gt; e</code> de ese modo ya queda claro la traducci\u00f3n de <code>T</code>. A partir de ese momento ya todos los m\u00e9todos de clase y propiedades que utilizaran el gen\u00e9rico <code>T</code>, ahora utilizar\u00e1n el tipo <code>String</code>. En definitiva los gen\u00e9ricos de clase marcan las posiciones para la clase concreta que habr\u00e1 que especificar en la creaci\u00f3n del objeto. Lo bueno es que pueden convivir distintas concreciones de gen\u00e9ricos, podr\u00eda ser:</p> <pre><code>RandomElement&lt;String&gt; e1 = new RandomElement&lt;String&gt;(a1);\nRandomElement&lt;Integer&gt; e2 = new RandomElement&lt;Integer&gt;(a2);\n</code></pre>"},{"location":"bloque_ii/tema_10/page-2/#3-interfaces-con-genericos","title":"3. Interfaces con gen\u00e9ricos","text":"<p>Al igual que las clases, las interfaces pueden utilizar gen\u00e9ricos en las mismas condiciones que en \u00e9stas:</p> <pre><code>public interface Comparable&lt;T&gt;{\nT lower();\nT upper();\n}\n</code></pre> <p>Una clase que implemente la interfaz puede hacerlo as\u00ed:</p> <pre><code>public class Clase1 implements Compar&lt;String&gt;{\n</code></pre> <p>De modo que traduce el gen\u00e9rico de la interfaz por un tipo concreto o bien:</p> <pre><code>public class Clase1 &lt;T&gt; implements Compar&lt;T&gt;{\n</code></pre> <p>De modo que no traduce el gen\u00e9rico y espera a que durante la creaci\u00f3n de objetos de esa clase se indique el tipo concreto para el gen\u00e9rico.</p>"},{"location":"bloque_ii/tema_10/page-2/#4-uso-de-varios-genericos","title":"4. Uso de varios gen\u00e9ricos","text":"<p>Tanto en m\u00e9todos, como en clases o interfaces, es posible utilizar dos tipos gen\u00e9ricos e incluso m\u00e1s. Para ello se separan por comas dentro del operador diamante. Ejemplo:</p> <pre><code>public class CompareObjects&lt;T, U&gt;{\nprotected T object1;\nprotected U object2;\npublic CompareObjects(T object1, U object2){\nthis.object1 = object1;\nthis.object2 = object2;\n}\npublic boolean sameFirstLetter(){\nString letter1 = object1.getClass().getName().substring(1,1);\nString letter2 = object2.getClass().getName().substring(1,1);\nreturn letter1.equalsIgnoreCase(letter2);\n}\n}\n</code></pre> <p>Esta clase (que en realidad no es muy \u00fatil), construye un objeto a partir de otros dos. El primero de tipo gen\u00e9rico <code>T</code>, y el segundo de tipo <code>U</code>. El m\u00e9todo <code>sameFirstLetter</code> devuelve verdadero si el nombre de clase de <code>T</code> empieza por la misma letra que <code>U</code>.</p> <p>Para utilizar esta clase:</p> <pre><code>public static void main(String[] args){\nString s1 = \"Hola\";\nStringBuffer s2 = new StringBuffer(\"Adi\u00f3s\");\nCompareObjects&lt;String, StringBuffer&gt; comp = new CompareObjects&lt;String, StringBuffer&gt;(s1,s2);\nSystem.out.println(comp.sameFirstLetter());\n}\n</code></pre> <p>Devolver\u00e1 verdadero porque tanto <code>String</code> como <code>StringBuffer</code> empiezan por <code>S</code>. En el ejemplo <code>T</code> se convertir\u00e1 en String y <code>U</code> en <code>StringBuffer</code>.</p>"},{"location":"bloque_ii/tema_10/page-3/","title":"10.3 Gen\u00e9ricos avanzados","text":""},{"location":"bloque_ii/tema_10/page-3/#limitacion-de-los-tipos-posibles-en-un-generico","title":"Limitaci\u00f3n de los tipos posibles en un gen\u00e9rico","text":"<p>A veces no interesa que las clases acepten a cualquier tipo de objeto, sino a objetos de un determinado tipo y sus descendientes. Eso es posible indicarlo mediante la palabra <code>extends</code> dentro de la declaraci\u00f3n del gen\u00e9rico. Ejemplo:</p> <pre><code>public class HandlerVehicle &lt;V extends Vehicle&gt;{\nprotected V vehicle;\npublic HandlerVehicle(V vehicle){\nthis.vehicle = vehicle;\n}\npublic void start(){\nvehicle.accelerate(100);\n}\n}\n</code></pre> <p>En el ejemplo, a la clase se le puede indicar cualquier clase descendiente de <code>Vehicle</code>, pero ninguna otra. Por ejemplo:</p> <pre><code>HandlerVehicle&lt;Car&gt; v1 = new HandlerVehicle&lt;Car&gt;();\nHandlerVehicle&lt;Autocar&gt; v2 = new HandlerVehicle&lt;Autocar&gt;\n</code></pre> <p>Sin embargo, no se podr\u00eda declarar:</p> <pre><code>HandlerVehicle&lt;String&gt; v3 = HandlerVehicle&lt;String&gt;(e);\n</code></pre> <p>No es posible porque la clase String no es heredera de ning\u00fan veh\u00edculo. La raz\u00f3n de utilizar esta cl\u00e1usula tan restrictiva est\u00e1 en el hecho de poder realizar acciones que sabemos que s\u00f3lo son posibles en cierto tipo de objetos. La clase <code>HandlerVehicle</code> necesita arrancar el veh\u00edculo, por ello tenemos que asegurar que el gen\u00e9rico no puede ser ninguna clase incompatible.</p> <p>Por otro lado extends no tiene por qu\u00e9 referirse a clases, tambi\u00e9n puede referirse a interfaces. Ejemplo:</p> <pre><code>public class Clase1 &lt;V extends Comparable&gt;{\n</code></pre> <p>Significa que la Clase1 usa un gen\u00e9rico al que se le puede asignar cualquier clase que implemente la interfaz Comparable.</p>"},{"location":"bloque_ii/tema_10/page-3/#tipos-comodin","title":"Tipos comod\u00edn","text":"<p>Aunque parece que todo est\u00e1 resuelto de esta forma. Hay problemas cuando mezclamos objetos de la misma clase pero distinta traducci\u00f3n de gen\u00e9rico. Es el caso de este ejemplo:</p> <pre><code>public class RandomElement&lt;T&gt; {\nprivate final T element;\nprivate final int index;\npublic RandomElement(T[] array){\nindex = new Random().nextInt(array.length - 1);\nelement = array[index];\n}\npublic T getElement(){\nreturn element;\n}\npublic static void main(String[] args) {\nString[] a = {\"uno\", \"dos\", \"tres\", \"cuatro\"};\nRandomElement&lt;String&gt; e = new RandomElement&lt;String&gt;(a);\nSystem.out.println(e.getElement());\n}\npublic int getIndex(){\nreturn index;\n}\npublic boolean sameIndex(RandomElement&lt;T&gt; random){\nreturn random.index == index;\n}\n}\n</code></pre> <p>En este caso la clase RandomElement se le ha a\u00f1adido una propiedad que almacena el \u00edndice aleatorio que obtiene el constructor. Eso permite que construyamos un m\u00e9todo llamado <code>sameIndex</code> que recibe un objeto de clase RandomElement y nos dice si el \u00edndice aleatorio calculado fue el mismo. Para usar este m\u00e9todo:</p> <pre><code>String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nString[] s2 = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"};\nRandomElement&lt;String&gt; r1 = new RandomElement&lt;String&gt;(s1);\nRandomElement&lt;String&gt; r2 = new RandomElement&lt;String&gt;(s2);\nSystem.out.println(r1.sameIndex(r2));\n</code></pre> <p>El c\u00f3digo funciona, s\u00f3lo devolver\u00e1 verdadero si tanto el objeto <code>r1</code> como en <code>r2</code>, el \u00edndice tiene el mismo valor. Sin embargo, este otro c\u00f3digo fallara:</p> <pre><code>String[] s1 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\nInteger[] s2 = {1,2,3,4,5,6};\nRandomElement&lt;String&gt; r1 = new RandomElement&lt;String&gt;(s1);\nRandomElement&lt;Integer&gt; r2 = new RandomElement&lt;Integer&gt;(s2);\nSystem.out.println(r1.sameIndex(r2));\n</code></pre> <p>El error ocurre en tiempo de compilaci\u00f3n. La raz\u00f3n, que en la l\u00ednea remarcada, el objeto <code>r1</code> es ya de tipo <code>RandomElement&lt;String&gt;</code> por lo que el m\u00e9todo <code>sameIndex</code> s\u00f3lo puede aceptar objetos de tipo <code>RandomElement&lt;String&gt;</code>, ya que el gen\u00e9rico T se tradujo como STring. El problema est\u00e1 en que dicho m\u00e9todo tiene que poder aceptar cualquier tipo de objeto de tipo <code>RandomElement</code>.</p> <p>Para ello se usa el signo <code>&lt;?&gt;</code> de ese modo indicamos la posibilidad de aceptar cualquier tipo de clase con gen\u00e9rico. Es decir el m\u00e9todo se reescribir\u00eda as\u00ed:</p> <pre><code>public boolean sameIndex(RandomElement&lt;?&gt; random){\nreturn random.getIndex() == index;\n}\n</code></pre> <p>De esa forma se indica que random es un objeto de tipo <code>RandomElement</code> tenga el tipo que tenga el gen\u00e9rico.</p> <p>Incluso se puede delimitar el gen\u00e9ricos:</p> <pre><code>public boolean sameIndex(RandomElement&lt;? extends Number&gt; random){\nreturn random.getIndex() == index;\n}\n</code></pre> <p>Ahora el m\u00e9todo acepta cualquier tipo de <code>RandomElement</code> pero siempre y cuando el tipo gen\u00e9rico forme parte de la herencia <code>Number</code></p>"},{"location":"bloque_ii/tema_10/page-4/","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza una clase gen\u00e9rica Caja que pueda guardar un objeto de cualquier tipo. Realiza para dicha clase los m\u00e9todos get y  set. Haz un programa para probar dichos m\u00e9todos.</p> Ejercicio 2 <p>Realiza una clase gen\u00e9rica Pareja que contenga dos elementos de cualquier tipo. Realiza los siguientes m\u00e9todos:</p> <ul> <li>M\u00e9todo get para ambos.</li> <li>M\u00e9todo mostrarTipos que muestre el tipo de ambos elementos. Ejemplo: java.lang.String</li> <li>M\u00e9todo mismoTipo que devuelva true si ambos elementos tienen el mismo tipo.</li> </ul> Ejercicio 3 <p>Realiza la clase anterior con la restricci\u00f3n de que el segundo elemento pertenezca a una subclase del primero. (Probar con Number que es padre de todos los wrappers de n\u00fameros: Integer, Short, etc)</p> Ejercicio 4 <p>Realiza una clase gen\u00e9rica OperaMate que tenga un elemento de cualquier tipo num\u00e9rico. Realiza los siguientes m\u00e9todos:</p> <ul> <li>M\u00e9todo rec\u00edproco para obtener el el rec\u00edproco del n\u00famero (se obtiene dividiendo 1 entre el n\u00famero)</li> <li>M\u00e9todo fracci\u00f3n para obtener la parte fraccionaria.</li> </ul>"},{"location":"bloque_ii/tema_10/page-5/","title":"Proyecto","text":"<p>En este proyecto se va a realiza clases wrappers de Arrays, para manejarlos en diferentes situaciones. Para ello se va a crear una interfaz llamada Collection con los siguientes m\u00e9todos:</p> <ul> <li>first(): devuelve el primer elemento de la colecci\u00f3n</li> <li>last(): devuelve el \u00faltimo elemento de la colecci\u00f3n</li> <li>isEmpty(): comprueba si la colecci\u00f3n est\u00e1 vac\u00eda</li> <li>get(): devuelve el primer elemento de la colecci\u00f3n y lo elimina</li> <li>pop(): devuelve el \u00faltimo elemento de la colecci\u00f3n y lo elimina</li> <li>add(element): a\u00f1ade el elemento a la colecci\u00f3n</li> </ul> <p>Los tipos de colecciones que se quieren tratar son las siguientes:</p> <ul> <li>Cola. Este tipo de colecci\u00f3n funciona como la cola de un supermercado y sigue el proceso de una cola FIFO (First In, First Out), es decir, el primero en entrar en la cola, es el primero en salir.</li> <li>Pila. Este tipo de colecci\u00f3n funciona como una pila platos y sigue el proceso de una cola LIFO (Last In, First Out), es decir, el \u00faltimo que ha entrado es el primero en salir.</li> <li>Conjunto. Funciona exactamente igual que una cola, pero con la caracter\u00edstica de que no puede contener elementos repetidos. En caso de que se intentase a\u00f1adir un elemento repetido, \u00e9ste se lo saltar\u00eda.</li> <li>Entradas. Es una cola de elementos de pares clave-valor, donde la clave representada el identificador del valor. Al igual que los conjuntos, en una entrada no puede haber dos elementos iguales con la misma clave. En caso de que se intentase a\u00f1adir un elemento repetido, \u00e9ste se lo saltar\u00eda.</li> </ul> <p>Crea las clases necesarias para representar todas las colecciones, que deben implementar la interfaz creada.</p> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>Se deber\u00e1 hacer uso de Gen\u00e9ricos donde sea requerido.</li> <li>Se deber\u00e1 entregar un diagrama de clase que represente las relaciones entre las clases y las interfaces.</li> <li>Se valorar\u00e1 la complejidad de un Main que ponga aprueba los m\u00e9todos y clases creadas.</li> <li>Se podr\u00e1 usar la librer\u00eda common realiza en proyectos anteriores, haciendo uso de JARs.</li> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre pr10java-NOMBRE-collections siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_ii/tema_6/page-1/","title":"1 Arrays unidimensionales","text":""},{"location":"bloque_ii/tema_6/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Los tipos de datos que conocemos hasta ahora no permiten solucionar problemas que requieren gestionar muchos datos a la vez. Por ejemplo, imaginemos que deseamos almacenar las notas de  una  clase  de  25  alumnos,  para  ello,  con  lo  que  conocemos  hasta  ahora,  no  habr\u00e1  m\u00e1s remedio que declarar 25 variables. Eso es tremendamente pesado de programar. Manejar esos datos  significar\u00eda  estar  continuamente  manejando  25  variables.  Por  ello,  en  casi  todos  los lenguajes se pueden agrupar una serie de variables del mismo tipo en una misma estructura que com\u00fanmente se conoce como array. Esa estructura permite referirnos a todos los elementos, pero tambi\u00e9n nos permite acceder individualmente a cada uno de ellos.</p> <p>Los arrays son una colecci\u00f3n de datos del mismo tipo al que se le pone un nombre. Para acceder a  un  dato  individual  de  la  colecci\u00f3n  hay  que  utilizar  su  posici\u00f3n.  La  posici\u00f3n  es  un  n\u00famero entero, normalmente se le llama \u00edndice. Hay que tener en cuenta que en los arrays el primer elemento tiene como \u00edndice el n\u00famero cero, el segundo el uno y as\u00ed sucesivamente.</p> <p>Un  array  unidimensional  es  aquel  que  tiene  una  \u00fanica  dimensi\u00f3n,  es  decir,  un  \u00fanico  \u00edndice. Tambi\u00e9n se le suele llamar vector</p>"},{"location":"bloque_ii/tema_6/page-1/#declaracion","title":"Declaraci\u00f3n","text":"<p>Existen dos formas de declarar un array unidimensional:</p> <ul> <li><code>tipo nombre_array[];</code></li> <li><code>tipo[] nombre_array;</code></li> </ul> <p>tipo declara el tipo de elemento del array, es decir, el tipo de datos de cada elemento que comprende el array. Dicho tipo de datos puede ser un tipo primitivo o un objeto.</p> <p>Esta declaraci\u00f3n le dice al compilador que dicha variable va a contener un array con elementos de dicho tipo pero todav\u00eda no se reserva espacio en la memoria RAM ya que no se conoce el tama\u00f1o del mismo.</p>"},{"location":"bloque_ii/tema_6/page-1/#creacion","title":"Creaci\u00f3n","text":"<p>Se realiza con el operador new, que es el que realmente crea el array indicando un tama\u00f1o. Cuando se usa new es cuando se reserva el espacio necesario en memoria para el array.</p> <p>Se crea un array de la siguiente manera:  <code>nombre_array = new tipo[tama\u00f1o];</code></p> <p>Ejemplo:</p> <pre><code>int[] grades; //(1)!\ngrades = new int[3]; //(2)!\n</code></pre> <ol> <li>Declaraci\u00f3n del array de enteros llamado grades</li> <li>Creaci\u00f3n del array grades reservando en memoria espacio para 3 enteros</li> </ol> <p>Se puede realizar lo mismo en una \u00fanica l\u00ednea de c\u00f3digo:</p> <pre><code>int[] grades = new int[3];\n</code></pre>"},{"location":"bloque_ii/tema_6/page-1/#referencia-a-los-elementos-del-array","title":"Referencia a los elementos del array","text":"<p>Para referencias los elementos del array se utiliza el \u00edndice de los mismos entre corchetes:</p> <ul> <li><code>grades[0]</code>: es el primer elemento del array, es decir, la primera nota.</li> <li><code>grades[1]</code>: es el segundo elemento del array, es decir, la segunda nota.</li> <li><code>grades[2]</code>: es el tercer elemento del array, es decir, la tercera nota.</li> </ul>"},{"location":"bloque_ii/tema_6/page-1/#asignacion-de-valores","title":"Asignaci\u00f3n de valores","text":"<p>Se puede asignar valores a los elementos del array utilizando el signo =:</p> <pre><code>grades[2] = 8; // Se le asigna un 8 a la tercera nota.\n</code></pre> <p>Tambi\u00e9n se pueden asignar valores a todos los elementos del array utilizando literales array:</p> <pre><code>int[] grades = new int[] {8, 7, 9};\n</code></pre> <p>No es necesario escribir new int[] en las \u00faltimas versiones de Java:</p> <pre><code>int[] grades = {8, 7, 9}; </code></pre> <p>En este caso, se est\u00e1 asignando un 8 a la primera nota, un 7 a la segunda nota y un 9 a la tercera.</p>"},{"location":"bloque_ii/tema_6/page-1/#el-atributo-length","title":"El atributo length","text":"<p>Los arrays poseen el atributo length que contiene el tama\u00f1o del array:</p> <pre><code>System.out.println(grades.length); // 3\n</code></pre>"},{"location":"bloque_ii/tema_6/page-1/#utilizando-el-bucle-for","title":"Utilizando el bucle for","text":"<p>La ventaja de usar arrays es que gracias a un simple bucle for se pueden recorrer f\u00e1cilmente todos los elementos de un array:</p> <pre><code>public class ArrayFor {\npublic void show(){\nint[] grades = {8, 7, 9};\nfor(int i = 0; i &lt; grades.length; i++){\nSystem.out.printf(\"Nota del \u00edndice %d: %d\\n\", i, grades[i]);\n}\n}\npublic static void main(String[] args) {\nnew ArrayFor().show();\n}\n}\n</code></pre> <p>\u00a1CUIDADO!</p> <p>Los \u00edndices del array van desde el 0 hasta length-1. Si un array es de tama\u00f1o 3, sus \u00edndices son 0, 1 y 2. Por eso en la condici\u00f3n del for se debe iterar mientras i sea menor que array.length, y no menor o igual, de esta forma toma como \u00faltimo \u00edndice el length-1. Si pusi\u00e9ramos la condici\u00f3n menor o igual, nos lanzar\u00eda la excepci\u00f3n ArrayIndexOutOfBoundsException ya que estar\u00edamos accediendo al array con el \u00edndice 3, el cual es un \u00edndice no v\u00e1lido.</p> <pre><code>for(int i = 0; i &lt;= grades.length; i++){ // Lanza ArrayIndexOutOfBoundsException\n//...\n}\n</code></pre> <p>Tambi\u00e9n se pueden utilizar con los arrays los bucles for-each:</p> <pre><code>public class ArraysForEach {\npublic void show(){\nint[] grades = {8, 7, 9};\nfor (int grade : grades) {\nSystem.out.printf(\"Nota: %d\\n\", grade);\n}\n}\npublic static void main(String[] args) {\nnew ArraysForEach().show();\n}\n}\n</code></pre> Ejercicio 1 <p>Dado un array de 10 n\u00fameros, realiza la suma de los n\u00fameros pares.</p>"},{"location":"bloque_ii/tema_6/page-1/#metodo-split","title":"M\u00e9todo split","text":"<p>Las clases String y Pattern poseen el m\u00e9todo split que divide una cadena en subcadenas en funci\u00f3n de una expresi\u00f3n regular y devuelve un array con las subcadenas restantes.</p> <pre><code>public class Split {\npublic void show(){\nString string = \"Esto:es:una:cadena:dividida:por:split\";\nString[] stringArray = string.split(\":\");\nSystem.out.println(Arrays.toString(stringArray)); // [Esto, es, una, cadena, dividida, por, split]\n}\npublic static void main(String[] args) {\nnew Split().show();\n}\n}\n</code></pre> <p>Tip</p> <p>F\u00edjense en el m\u00e9todo est\u00e1tico toString de la clase Arrays. Devuelve una cadena con los elementos del array entre corchetes y separados por comas.</p> Ejercicio 2 <p>Realiza un programa que solicite al usuario una frase. Transforma esa frase en un array que cuyo valores sean las palabras de la frase, luego recorre el array.</p>"},{"location":"bloque_ii/tema_6/page-1/#los-arrays-se-implementan-como-objetos","title":"Los arrays se implementan como objetos","text":"<p>En Java, los arrays se implementan como objetos. Una de las ventajas que tiene esto es que los arrays que pierden la referencia pueden ser recolectados. (Ver el apartado referencias del tema 4 Programaci\u00f3n Orientada a Objetos)</p> <p>En la perspectiva de Java, un array es una referencia a una serie de valores que se almacenan en la memoria. El operador new en realidad lo que hace es devolver dicha referencia para poder leer y escribir esos valores.</p> <p>Veamos el efecto del uso operador new en los arrays y c\u00f3mo afectan en la memoria:</p> <p> Figura 1 - Referencia arrays</p> <p>Vemos como el anterior array se ha quedado sin referencia y se marca como elegible para el recolector de basura.</p>"},{"location":"bloque_ii/tema_6/page-1/#que-puede-contener-un-array","title":"\u00bfQu\u00e9 puede contener un array?","text":"<p>El array puede contener objetos o tipos de datos primitivos. En el caso de los tipos de datos primitivos, los valores reales se almacenan en ubicaciones de memoria contigua. En el caso de los objetos de una clase, los objetos reales se almacenan en heap.</p>"},{"location":"bloque_ii/tema_6/page-1/#arrays-de-tipos-primitivos","title":"Arrays de tipos primitivos","text":"<ul> <li> <p>Crear una variable de tipo array s\u00f3lo crea una referencia:</p> <pre><code>int[] a;\n</code></pre> <p> Figura 2 - Declaraci\u00f3n de arrays de tipo primitivos </p> </li> <li> <p>El espacio en memoria para el array se crea con new. Cuando se trata de un array de un tipo primitivo, se crean los elementos del array y se inicializan sus valores por defecto:</p> <pre><code>a = new int[5];\n</code></pre> <p> Figura 3 - Inicializaci\u00f3n de arrays de tipo primitivos </p> </li> </ul>"},{"location":"bloque_ii/tema_6/page-1/#array-de-objetos","title":"Array de objetos","text":"<ul> <li> <p>Crear una variable de tipo array de objetos s\u00f3lo crea la referencia:</p> <pre><code>Complejo[] a;\n</code></pre> <p> Figura 4 - Declaraci\u00f3n de arrays de objetos </p> </li> <li> <p>Con new se reserva el espacio para el array de referencias pero no los objetos a los que apuntar\u00e1n esas referencias. Las referencias se inicializan a su valor por defecto (null):</p> <pre><code>a = new Complejo[4];\n</code></pre> <p> Figura 5 - Inicializaci\u00f3n de arrays de objetos </p> </li> <li> <p>Los objetos hay que crearlos posteriormente:</p> <p> Figura 6 - Creaci\u00f3n de objetos de objetos </p> </li> </ul>"},{"location":"bloque_ii/tema_6/page-1/#asignacion-de-arrays","title":"Asignaci\u00f3n de arrays","text":"<p>Como en Java los arrays son objetos, la asignaci\u00f3n se realiza como los objetos (Ver el apartado referencias del tema 4 Programaci\u00f3n Orientada a Objetos)</p> <p>Un array se puede asignar a otro array (si son del mismo tipo). La asignaci\u00f3n solo copia referencias, es decir, la direcci\u00f3n de memoria. Por lo tanto, ambos arrays apuntar\u00e1n al mismo sitio:</p> <pre><code>int[] a;\nint[] b = {3, 4, 5, 6, 7, 8};\na = b;\n</code></pre> <p> Figura 7 - Referencia array</p> <p>Esta asignaci\u00f3n provoca que cualquier cambio en a tambi\u00e9n cambie el array b ya que de hecho, son el mismo array:</p> <pre><code>public class Assignment {\npublic void show(){\nint[] a;\nint[] b = {3, 4, 5, 6, 7, 8};\na = b;\nSystem.out.println(Arrays.toString(b)); // [3, 4, 5, 6, 7, 8]\na[0] = 1;\nSystem.out.println(Arrays.toString(b)); // [1, 4, 5, 6, 7, 8]\n}\npublic static void main(String[] args) {\nnew Assignment().show();\n}\n}\n</code></pre> Ejercicio 3 <p>Realiza un programa que contenga un m\u00e9todo que calcule los n primeros m\u00faltiplos de un n\u00famero. Luego realiza otro m\u00e9todo donde calcule la mitad de esos n\u00fameros. NO SE PUEDEN UTILIZAR PAR\u00c1METROS DE TIPO ARRAY</p>"},{"location":"bloque_ii/tema_6/page-1/#comparacion-de-arrays","title":"Comparaci\u00f3n de arrays","text":"<p>Como en Java los arrays son objetos, la comparaci\u00f3n se realiza como los objetos (Ver el apartado referencias del tema 4 Programaci\u00f3n Orientada a Objetos).</p> <p>El operador de igualdad <code>==</code> cuando se utiliza con arrays, no compara el contenido de los arrays sino sus direcciones de memoria o referencias, es decir, si apuntan al mismo array. Lo mismo ocurre con el m\u00e9todo equals de los arrays, que compara las direcciones de memoria. Si queremos comparar el contenido de los arrays, tendremos que utilizar el m\u00e9todo est\u00e1tico equals de la clase Arrays.</p> <pre><code>public class Comparison {\npublic void show(){\nint[] array1;\nint[] array2 = {3, 4, 5, 6, 7, 8};\nint[] array3 = {3, 4, 5, 6, 7, 8};\narray1 = array2;\nSystem.out.println(array1 == array2); //(1)!\nSystem.out.println(array2 == array3); //(2)!\nSystem.out.println(array1.equals(array2)); //(3)!\nSystem.out.println(array2.equals(array3)); //(4)!\nSystem.out.println(Arrays.equals(array1, array2)); //(5)!\nSystem.out.println(Arrays.equals(array2, array3)); //(6)!\n}\npublic static void main(String[] args) {\nnew Comparison().show();\n}\n}\n</code></pre> <ol> <li>true porque apuntan al mismo array</li> <li>false porque no apuntan al mismo array</li> <li>true porque apuntan al mismo array</li> <li>false porque apuntan al mismo array</li> <li>true porque el contenido es el mismo ya que apuntan al mismo array</li> <li>true porque el contenido es el mismo</li> </ol>"},{"location":"bloque_ii/tema_6/page-1/#arrays-como-parametros","title":"Arrays como par\u00e1metros","text":"<p>Al igual que las variables, tambi\u00e9n podemos pasar arrays a los m\u00e9todos, es decir, se pueden definir par\u00e1metros del tipo array. En la llamada al m\u00e9todo, lo que el m\u00e9todo recibe como argumento es la direcci\u00f3n de memoria del array, por lo que si el m\u00e9todo modifica el array, el array del m\u00e9todo que efect\u00faa la llamada tambi\u00e9n se ve afectado por dichos cambios.</p> <pre><code>public class ArraysAsParameters {\npublic void show(){\nint[] array = {3, 4, 5, 6, 7, 8};\nSystem.out.println(Arrays.toString(array)); // [3, 4, 5, 6, 7, 8]\nmethod(array);\nSystem.out.println(Arrays.toString(array)); // [6, 8, 10, 12, 14, 16]\n}\npublic void method(int[] array){\nfor (int i = 0; i &lt; array.length; i++) {\narray[i] *= 2;\n}\n}\npublic static void main(String[] args) {\nnew ArraysAsParameters().show();\n}\n}\n</code></pre> Ejercicio 4 <p>Realiza un aplicaci\u00f3n que contenga un m\u00e9todo que reciba un array de cadenas y una palabra. El m\u00e9todo localizar\u00e1 dicha palabra en el array, y devolver\u00e1 true en caso de encontrarla, y false en cualquier otro caso.</p>"},{"location":"bloque_ii/tema_6/page-1/#como-retornar-un-array","title":"C\u00f3mo retornar un array","text":"<p>Un m\u00e9todo tambi\u00e9n puede devolver un array, en cuyo caso, lo que retorna es la direcci\u00f3n de dicho array.</p> <pre><code>public class ReturningAnArray {\npublic void show(){\nint[] a;\na = method();\nSystem.out.println(Arrays.toString(a)); // [3, 4, 5, 6, 7, 8]\n}\npublic int[] method(){\nreturn new int[]{3, 4, 5, 6, 7, 8};\n}\npublic static void main(String[] args) {\nnew ReturningAnArray().show();\n}\n}\n</code></pre> <p>En este caso, el main define una variable a de tipo array de enteros pero no hace el new del array, sino que recibe la direcci\u00f3n de memoria que le devuelve el m\u00e9todo method. Sin embargo, el m\u00e9todo method s\u00ed que hace el new del array porque su responsabilidad es crear el array, darle valores y devolverlo.</p> Ejercicio 5 <p>Realiza un programa con un m\u00e9todo que dado un n\u00famero positivo, devuelva sus divisores.</p>"},{"location":"bloque_ii/tema_6/page-1/#excepcion-arrayindexoutofboundsexception","title":"Excepci\u00f3n ArrayIndexOutOfBoundsException","text":"<p>Cuando se intenta acceder a un elemento del array que no existe, Java nos lanza una excepci\u00f3n ArrayIndexOutOfBoundsException. El programador no debe capturar con un try-catch la excepci\u00f3n sino que debe corregir el error de programaci\u00f3n que ha producido dicha excepci\u00f3n. Veamos un ejemplo:</p> <pre><code>public class ArrayIndexOutOfBoundsException1 {\npublic void show(){\nint[] grades = {8, 7, 9};\nfor (int i = 0; i &lt;= grades.length; i++) {\nSystem.out.printf(\"Nota en el \u00edndice %d: %d\\n\", i, grades[i]);\n}\n}\npublic static void main(String[] args) {\nnew ArrayIndexOutOfBoundsException1().show();\n}\n}\n</code></pre> <p>Como vemos en el ejemplo, al usar <code>&lt;=</code>, se lanzar\u00e1 una excepci\u00f3n al intentar acceder al valor de la posici\u00f3n <code>grades[3]</code>, que es el valor de grades.length, que es inexistente. No se debe usar un try-catch para manejar este error, sino que el programador debe corregir el error.</p>"},{"location":"bloque_ii/tema_6/page-2/","title":"2 Arrays Multidimensionales","text":""},{"location":"bloque_ii/tema_6/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Los arrays multidimensionales son aquellos que tienen m\u00e1s de una dimensi\u00f3n, es decir, son arrays que contienen otros arrays. Tienen m\u00e1s de un \u00edndice, uno por cada dimensi\u00f3n.</p> <p>Un array con dos dimensiones es un array bidimensional y tambi\u00e9n se le suele llamar matriz. Si adem\u00e1s, la matriz tiene el mismo n\u00famero de filas que de columnas, entonces se llama matriz cuadrada.</p>"},{"location":"bloque_ii/tema_6/page-2/#declaracion","title":"Declaraci\u00f3n","text":"<p>Se declaran como los arrays unidimensionales a\u00f1adiendo tantos corchetes <code>[ ]</code> como dimensiones haya. Por ejemplo, veamos las dos formas de declarar un array bidimensional:</p> <ul> <li><code>tipo nombre_array[][];</code></li> <li><code>tipo[][] nombre_array:</code></li> </ul> <p>tipo declara el tipo de elemento del array, es decir, el tipo de datos de cada elemento que comprende el array. Dicho tipo de datos puede ser un tipo primitivo o un objeto.</p> <p>Esta declaraci\u00f3n le dice al compilador que dicha variable va a contener un array con elementos de dicho tipo pero todav\u00eda no se reserva espacio en la memoria RAM ya que no se conoce el tama\u00f1o del mismo.</p>"},{"location":"bloque_ii/tema_6/page-2/#creacion","title":"Creaci\u00f3n","text":"<p>Se realiza con el operador new, que es realmente crea el array indicando un tama\u00f1o. Cuando se usa un new es cuando se reserva el espacio necesario en memoria para el array.</p> <p>Se crea un array bidimensional de la siguiente manera: <code>nombre_array = new tipo[filas][columnas]</code></p> <pre><code>int[] a = new int[10]; // Array de una dimensi\u00f3n\nint[][] b = new int[3][5]; // Array bidimensional (dos dimensiones)\nint[][][] c = new int[4][6][2]; // Array tridimensional (tres dimensiones)\n</code></pre> <p> Figura 8 - Array multidimensionales</p> <p>Los arrays multidimensionales son arrays que contienes arrays, por lo tanto un array bidimensional se puede representar de la siguiente manera</p> <p> Figura 9 - Array bidimensional</p>"},{"location":"bloque_ii/tema_6/page-2/#referencia-a-los-objetos-del-array","title":"Referencia a los objetos del array","text":"<p>Para referencias los elementos del array se utiliza el \u00edndice de los mismos entre corchetes:</p> <ul> <li><code>a[9]</code>: es el \u00faltimo elemento unidimensional de a.</li> <li><code>b[1][2]</code>: es el elemento que est\u00e1 justo en medio del array bidimensional b.</li> <li><code>c[0][0][0]</code>: es el primer elemento del array tridimensional c.</li> </ul> <p>Supongamos que tenemos el siguiente array bidimensional:</p> <pre><code>int[][] = new int[5][4];\n</code></pre> <p>Es un array que contiene 5 arrays unidimensionales de 4 posiciones cada uno. Veamos en la imagen la referencia de sus elementos:</p> <p> Figura 10 - Referencia a un array multidimensional</p> <ul> <li>m: contiene la referencia al array completo.</li> <li>m[0]: contiene la referencia del primer array unidimensional.</li> <li>m[4]: contiene la referencia del quinto array unidimensional.</li> <li>m[0] [0]: contiene el primer elemento del primer array unidimensional.</li> <li>m[0] [3]: contiene el \u00faltimo elemento del primer array unidimensional.</li> <li>m[4] [3]: contiene el \u00faltimo elemento del \u00faltimo array unidimensional.</li> </ul>"},{"location":"bloque_ii/tema_6/page-2/#asignacion-de-valores","title":"Asignaci\u00f3n de valores","text":"<p>Se pueden asignar valores a los elementos del array utilizando el signo <code>=</code>.</p> <pre><code>a[9] = 8; //(1)!\nb[1][2] = 9; //(2)!\nc[0][0][0] = 1; //(3)!\n</code></pre> <ol> <li>Se asigna un 8 al \u00faltimo elemento del array unidimensional a.</li> <li>Se asigna un 9 al elemento que est\u00e1 justo en medio del array bidimensional b.</li> <li>Se asigna un 1 al primer elemento del array tridimensional c.</li> </ol> <p>Tambi\u00e9n se pueden asignar valores a todos los elementos del array utilizando literales array:</p> <pre><code>// Array de dos dimensiones [3][5]\nint[][] twoDimensions = {\n{0, 1, 2, 3, 4},\n{5, 6, 7, 8, 9},\n{10, 11, 12, 13, 14}\n}\n// Array de tres dimensiones [2][3][2]\nint[][][] threeDimensions = {\n{ {0, 1}, {2, 3}, {4, 5}},\n{ {6, 7}, {8, 9}, {10, 11}}\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-2/#el-atributo-length","title":"El atributo length","text":"<p>Los arrays poseen el atributo length que contiene el tama\u00f1o del array. Como los arrays multidimensionales son arrays de arrays, se puede aplicar a cualquier posici\u00f3n que contenga una referencia. Si se aplica a una posici\u00f3n que contenga un elemento, entonces da error de compilaci\u00f3n.</p> <pre><code>public class LengthMultidimensional {\npublic void show(){\n// Array de dos dimensiones [3][5]\nint[][] twoDimensions = {\n{0, 1, 2, 3, 4},\n{5, 6, 7, 8, 9},\n{10, 11, 12, 13, 14}\n};\n// Array de tres dimensiones [2][3][2]\nint[][][] threeDimensions = {\n{ {0, 1}, {2, 3}, {4, 5}},\n{ {6, 7}, {8, 9}, {10, 11}}\n};\nSystem.out.println(twoDimensions.length); // 3\nSystem.out.println(twoDimensions[0].length); // 5\nSystem.out.println(twoDimensions[1].length); // 5\nSystem.out.println(twoDimensions[2].length); // 5\nSystem.out.println(threeDimensions.length); // 2\nSystem.out.println(threeDimensions[0].length); // 3\nSystem.out.println(threeDimensions[1].length); // 3\nSystem.out.println(threeDimensions[0][0].length); // 2\nSystem.out.println(threeDimensions[1][2].length); // 2\nSystem.out.println(threeDimensions[1][2][0].length); // Error\n}\npublic static void main(String[] args) {\nnew LengthMultidimensional().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-2/#utilizacion-del-bucle-for","title":"Utilizaci\u00f3n del bucle for","text":"<p>La ventaja de usar arrays es que gracias a un simple bucle for se pueden recorrer f\u00e1cilmente todos los elementos de un array multidimensional.</p> <pre><code>public class ForMultidimensional {\npublic void show(){\n// Array de dos dimensiones [3][5]\nint[][] twoDimensions = {\n{0, 1, 2, 3, 4},\n{5, 6, 7, 8, 9},\n{10, 11, 12, 13, 14}\n};\n// Array de tres dimensiones [2][3][2]\nint[][][] threeDimensions = {\n{ {0, 1}, {2, 3}, {4, 5}},\n{ {6, 7}, {8, 9}, {10, 11}}\n};\nfor(int i = 0; i &lt; twoDimensions.length; i++){\nfor(int j = 0; j &lt; twoDimensions[0].length; j++){\nSystem.out.printf(\"%2d \", twoDimensions[i][j]);\n}\nSystem.out.println();\n}\nSystem.out.println();\nfor (int i = 0; i &lt; threeDimensions.length; i++) {\nfor (int j = 0; j &lt; threeDimensions[i].length; j++) {\nfor (int k = 0; k &lt; threeDimensions[i][j].length; k++) {\nSystem.out.printf(\"%2d \", threeDimensions[i][j][k]);\n}\n}\n}\n}\npublic static void main(String[] args) {\nnew ForMultidimensional().show();\n}\n}\n</code></pre> <p>Tambi\u00e9n se pueden utilizar los bucles for-each pero solamente con arrays unidimensionales. En un array multidimensional, se puede utilizar un for-each en cualquiera de los arrays unidimensionales que forman parte del array multidimensional</p> <p>Para mostrar un array multidimensional, tambi\u00e9n se puede utilizar el m\u00e9todo est\u00e1tico deepToString de la clase Arrays. Devuelve una cadena con los elementos del array entre corchetes y separados por comas. Se utiliza con arrays multidimensionales. Para los arrays unidimensionales se usa el m\u00e9todo Arrays.toString.</p> <pre><code>public class DeepToString {\npublic void show(){\nint[][] twoDimensions = {\n{0, 1, 2, 3, 4},\n{5, 6, 7, 8, 9},\n{10, 11, 12, 13, 14}\n};\nSystem.out.println(Arrays.deepToString(twoDimensions)); // [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]\n}\npublic static void main(String[] args) {\nnew DeepToString().show();\n}\n}\n</code></pre> Ejercicio 1 <p>Realiza un programa que solicite las 3 notas de 5 alumnos, hallando la nota mayor, y a qui\u00e9n pertenece, la nota inferior, y a qui\u00e9n pertenece, y la nota mayor e inferior de cada alumno.</p>"},{"location":"bloque_ii/tema_6/page-2/#comparacion-de-arrays","title":"Comparaci\u00f3n de arrays","text":"<p>Como en Java los arrays son objetos, la comparaci\u00f3n se realiza como los objetos (Ver el apartado referencias del tema 4 Programaci\u00f3n Orientada a Objetos).</p> <p>El operador de igualdad <code>==</code> cuando se utiliza con arrays, no compara el contenido de los arrays sino sus direcciones de memoria o referencias, es decir, si apuntan al mismo array. Lo mismo ocurre cuando el m\u00e9todo equals de los arrays, que compara las direcciones de memoria. Si queremos comparar el contenido de los arrays, tendremos que utilizar el m\u00e9todo est\u00e1tico equals de la clase Arrays para los unidimensionales y el m\u00e9todo deepEquals para los multidimensionales.</p> <pre><code>public class ComparisonMultidimensional {\npublic void show(){\nint[][] twoDimension1;\nint[][] twoDimension2 = {\n{0, 1, 2, 3, 4},\n{5, 6, 7, 8, 9},\n{10, 11, 12, 13, 14}\n};\nint[][] twoDimension3 = {\n{0, 1, 2, 3, 4},\n{5, 6, 7, 8, 9},\n{10, 11, 12, 13, 14}\n};\ntwoDimension1 = twoDimension2;\nSystem.out.println(twoDimension1 == twoDimension2); // true porque apuntan al mismo array\nSystem.out.println(twoDimension2 == twoDimension3); // false porque no apuntan al mismo array\nSystem.out.println(twoDimension1.equals(twoDimension2)); // true porque apuntan al mismo array\nSystem.out.println(twoDimension2.equals(twoDimension3)); // false porque no apuntan al mismo array\nSystem.out.println(Arrays.deepEquals(twoDimension1, twoDimension2)); // true porque el contenido es el mismo ya que apuntan al mismo array\nSystem.out.println(Arrays.deepEquals(twoDimension2, twoDimension3)); // true porque el contenido es el mismo\nSystem.out.println(Arrays.equals(twoDimension2, twoDimension3)); // false porque para arrays multidimensionales es deepEquals en lugar de equals\n}\npublic static void main(String[] args) {\nnew Comparison().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-2/#arrays-irregulares","title":"Arrays irregulares","text":"<p>Los arrays unidimensionales que forman un array multidimensional no tienen porqu\u00e9 tener todos el mismo tama\u00f1o.</p> <p> Figura 11 - Arrays Irregulares</p> <pre><code>public class IrregularArrays {\npublic void show(){\nint[][] b = { {1,2,3}, {4,5,6,7}, {8,9}};\nfor (int i = 0; i &lt; b.length; i++) {\nfor (int j = 0; j &lt; b[i].length; j++) {\nSystem.out.printf(\"%2d \", b[i][j]);\n}\nSystem.out.println();\n}\n}\npublic static void main(String[] args) {\nnew IrregularArrays().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-3/","title":"3 Argumentos variables","text":""},{"location":"bloque_ii/tema_6/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Se puede dar el caso de que se necesite crear un m\u00e9todo que tome una cantidad variable de argumentos, seg\u00fan su uso preciso. Por ello, Java en su versi\u00f3n 5 incorpor\u00f3 los llamados varargs que es la abreviatura de argumentos de longitud variable (Variable - Length Arguments). Un m\u00e9todo que toma una cantidad variable de argumentos se denomina m\u00e9todos varargs.</p>"},{"location":"bloque_ii/tema_6/page-3/#sintaxis-de-varargs","title":"Sintaxis de Varargs","text":"<p>Un par\u00e1metro de longitud variable se espec\u00edfica por tres punts(...).</p> <pre><code>public static int add(int... nums)\n</code></pre> <p>Esta sintaxis le dice al compilador que se puede llamar al m\u00e9todo add con cero o m\u00e1s argumentos . Adem\u00e1s hace que nums se declare impl\u00edcitamente como un array de tipo int[]. Por lo tanto, dentro del m\u00e9todo add se accede a nums usando la sintaxis de array normal:</p> <pre><code>public class Varargs1 {\npublic void show(){\nSystem.out.println(add());\nSystem.out.println(add(1));\nSystem.out.println(add(new int[]{1}));\nSystem.out.println(add(1,2));\nSystem.out.println(add(1,2,3));\nSystem.out.println(add(1,2,3,4));\nSystem.out.println(add(new int[]{1, 2, 3, 4}));\n}\nprivate int add(int... nums) {\nint sum = 0;\nfor (int i = 0; i &lt; nums.length; i++) {\nsum += nums[i];\n}\nreturn sum;\n}\npublic static void main(String[] args) {\nnew Varargs1().show();\n}\n}\n</code></pre> <p>Si nos fijamos en el ejemplo, el m\u00e9todo add se llama con diferentes n\u00fameros de argumentos, incluyendo ning\u00fan argumento. Los argumentos se colocan autom\u00e1ticamente en un array y se pasan nums. En el caso de que no haya argumentos, la longitud del array es cero.</p> Ejercicio 1 <p>Realiza un programa que contenga un m\u00e9todo que pueda recibir todos los par\u00e1metros que desee. Halla la suma de esos n\u00fameros</p>"},{"location":"bloque_ii/tema_6/page-3/#metodos-con-parametros-normales-y-parametros-variables","title":"M\u00e9todos con par\u00e1metros normales y par\u00e1metros variables","text":"<p>Un m\u00e9todo puede tener par\u00e1metros normales junto con un par\u00e1metro de longitud variable. Sin embargo, el par\u00e1metro de longitud variable debe ser el \u00faltimo par\u00e1metro declarado por el m\u00e9todo y solamente se acepta un varargs por m\u00e9todo. Por ejemplo, esta declaraci\u00f3n de m\u00e9todo es perfectamente aceptable:</p> <pre><code>int compute(int x, int y, double x, int... values)\n</code></pre> <p>En este caso, los tres primeros argumentos utilizados en una llamada al m\u00e9todo compute se corresponden con los primeros tres par\u00e1metros. Entonces, se supone que los argumentos restantes pertenecen a values.</p> <pre><code>public class Varargs2 {\npublic void show(){\nSystem.out.println(operate(2));\nSystem.out.println(operate(2, 1));\nSystem.out.println(operate(2, 1, 2));\nSystem.out.println(operate(2, 1, 2, 3));\nSystem.out.println(operate(2, 1, 2, 3, 4));\n}\npublic int operate(int mult, int... summands){\nint sum = 0;\nfor (int i = 0; i &lt; summands.length; i++) {\nsum += summands[i];\n}\nreturn sum * mult;\n}\npublic static void main(String[] args) {\nnew Varargs2().show();\n}\n}\n</code></pre> <p>Recuerda, el par\u00e1metro varargs debe ser el \u00faltimo. Por ejemplo, la siguiente declaraci\u00f3n es incorrecta:</p> <pre><code>int compute(int x, int y, double z, int... values, boolean exit); //error\n</code></pre> <p>Adem\u00e1s, solamente se acepta un varargs por m\u00e9todo. Por ejemplo, esta declaraci\u00f3n tampoco es v\u00e1lida:</p> <pre><code>int compute(int x, int y, double z, int... values, double... nums); //error\n</code></pre> Ejercicio 2 <p>Realiza un m\u00e9todo que reciba un par\u00e1metro num\u00e9rico y pueda recibir varios n\u00fameros. Devuelve el resultado de sumar cada n\u00famero multiplicado por el par\u00e1metro.</p>"},{"location":"bloque_ii/tema_6/page-4/","title":"4 La clase Arrays","text":""},{"location":"bloque_ii/tema_6/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>En el paquete java.utils se encuentra la clase Arrays. Esta clase contiene m\u00e9todos est\u00e1ticos para manipular arrays, como por ejemplo, b\u00fasquedas, comparaciones, copias y ordenaciones.</p>"},{"location":"bloque_ii/tema_6/page-4/#contenido-de-un-array","title":"Contenido de un array","text":"<ul> <li> <p>M\u00e9todo toString: devuelve una representaci\u00f3n en cadena del contenido del array especificado. Dicha cadena est\u00e1 formada por los elementos del array entre corchetes y separados por comas. Es muy \u00fatil para sacar por consola la informaci\u00f3n sobre el array. Se utiliza con arrays unidimensionales.</p> <pre><code>public class ToString {\npublic void show(){\nint[] array = {3, 4, 5, 6, 7, 8};\nSystem.out.printf(\"La informaci\u00f3n del array es %s\", Arrays.toString(array));\n}\npublic static void main(String[] args) {\nnew ToString().show();\n}\n}\n</code></pre> </li> <li> <p>M\u00e9todo deepToString: igual que el anterior pero para arrays multidimensionales:</p> <pre><code>public class DeepToString {\npublic void show(){\nint[][] twoDimensions = {\n{0, 1, 2, 3, 4},\n{5, 6, 7, 8, 9},\n{10, 11, 12, 13, 14}\n};\nSystem.out.println(Arrays.deepToString(twoDimensions)); // [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]\n}\npublic static void main(String[] args) {\nnew DeepToString().show();\n}\n}\n</code></pre> </li> </ul>"},{"location":"bloque_ii/tema_6/page-4/#rellenar-un-array","title":"Rellenar un array","text":"<p>El m\u00e9todo fill permite rellenar todo un array unidimensional con un determinado valor. Tambi\u00e9n tiene una versi\u00f3n sobrecargado para especificar un rango.</p> <pre><code>public class Fill {\npublic void show(){\nint[] array = new int[6];\nArrays.fill(array, 1);\nSystem.out.println(Arrays.toString(array)); // [1, 1, 1, 1, 1, 1]\nArrays.fill(array, 2, 5, 0);\nSystem.out.println(Arrays.toString(array)); // [1, 1, 0, 0, 0, 1]\n}\npublic static void main(String[] args) {\nnew Fill().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-4/#busquedas","title":"B\u00fasquedas","text":"<p>El m\u00e9todo binarySearch:</p> <ul> <li>permite buscar un elemento de forma ultra r\u00e1pida en un array ordenado (en un array desordenado, sus resultados son impredecibles)</li> <li>Devuelve el \u00edndice en el que est\u00e1 colocado el elemento.</li> <li>Si el elemento no se encuentra, devuelve un n\u00famero negativo.</li> <li>Si el array contiene m\u00faltiples elementos con el valor especificado, no hay garant\u00eda de cu\u00e1l ser\u00e1 encontrado.</li> <li>Est\u00e1 sobrecargado para buscar en un determinado rango del array. Se proporcionan dos par\u00e1metros m\u00e1s para especificar el rango:<ul> <li>fromIndex: el \u00edndice (incluido) de la parte inferior del rango.</li> <li>toIndex: el \u00edndice (excluido) de la parte superior del rango.</li> </ul> </li> </ul> <pre><code>public class BinarySearch {\npublic void show(){\nint lowerRange, higherRange;\nint[] array = {3, 4, 5, 6, 7, 8};\nint number = 9;\nint index = Arrays.binarySearch(array, number);\nif(index &gt;= 0){\nSystem.out.printf(\"El n\u00famero %d se encuentra en el \u00edndice %d\\n\", number, index);\n} else {\nSystem.out.printf(\"El n\u00famero %d no se encuentra en el array\\n\", number);\n}\nlowerRange = 3;\nhigherRange = 6; // Como est\u00e1 excluido, se busca hasta el \u00edndice 5\nindex = Arrays.binarySearch(array, lowerRange, higherRange, number);\nif(index &gt;= 0){\nSystem.out.printf(\"El n\u00famero %d se encuentra en el \u00edndice %d\\n\", number, index);\n} else {\nSystem.out.printf(\"El n\u00famero %d no se encuentra en el array\\n\", number);\n}\n}\npublic static void main(String[] args) {\nnew BinarySearch().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-4/#comparaciones","title":"Comparaciones","text":"<p>Adem\u00e1s de los m\u00e9todos, equals para los arrays unidimensionales, y deepEquals para los multidimensionales, existen otros m\u00e9todos para comparar:</p> <ul> <li> <p>M\u00e9todo compare: compara dos arrays lexicogr\u00e1ficamente. Tambi\u00e9n tiene una versi\u00f3n sobrecargada para especificar un rango. Devuelve:         - el valor 0: si los dos arrays son iguales y contienen los mismos elementos en el mismo orden.         - un n\u00famero negativo: si el primer array es lexicogr\u00e1ficamente inferior al segundo.         - un n\u00famero positivo: si el primer array es lexicogr\u00e1ficamente superior al segundo.</p> <pre><code>public class Compare {\npublic void show(){\nint result;\nboolean[] arrayBoolean1 = {true, true, false};\nboolean[] arrayBoolean2 = {true, true, false};\nchar[] arrayChar1 = {'m', 'n', 't'};\nchar[] arrayChar2 = {'m', 'n', 'a'};\nchar[] arrayChar3 = {'M', 'n', 't'};\nint[] arrayInt1 = {3, 4, 5};\nint[] arrayInt2 = {3, 4, 5};\nint[] arrayInt3 = {3, 4, 5, 6};\nresult = Arrays.compare(arrayBoolean1, arrayBoolean2);\nSystem.out.printf(\"El resultado de comparar %s y %s es: \",\nArrays.toString(arrayBoolean1), Arrays.toString(arrayBoolean2));\ncomparison(result);\nresult = Arrays.compare(arrayChar1, arrayChar2);\nSystem.out.printf(\"El resultado de comparar %s y %s es: \",\nArrays.toString(arrayChar1), Arrays.toString(arrayChar2));\ncomparison(result);\nresult = Arrays.compare(arrayChar3, arrayChar2);\nSystem.out.printf(\"El resultado de comparar %s y %s es: \",\nArrays.toString(arrayChar3), Arrays.toString(arrayChar2));\ncomparison(result);\nresult = Arrays.compare(arrayInt1, arrayInt2);\nSystem.out.printf(\"El resultado de comparar %s y %s es: \",\nArrays.toString(arrayInt1), Arrays.toString(arrayInt2));\ncomparison(result);\nresult = Arrays.compare(arrayInt1, arrayInt3);\nSystem.out.printf(\"El resultado de comparar %s y %s es: \",\nArrays.toString(arrayInt1), Arrays.toString(arrayInt3));\ncomparison(result);\nresult = Arrays.compare(arrayInt1,0, 3 ,arrayInt3, 0, 3);\nSystem.out.printf(\"El resultado de comparar %s y %s en el rango 0-2 es: \",\nArrays.toString(arrayInt1), Arrays.toString(arrayInt3));\ncomparison(result);\n}\npublic void comparison(int result){\nif(result == 0){\nSystem.out.println(\"los arrays son iguales\");\n} else if(result &lt; 0){\nSystem.out.println(\"el primer array es menor\");\n} else {\nSystem.out.println(\"el primer array es mayor\");\n}\n}\npublic static void main(String[] args) {\nnew Compare().show();\n}\n}\n</code></pre> </li> <li> <p>M\u00e9todo mismatch: encuentra y devuelve el \u00edndice de la primera diferencia entre dos arrays. Si no encuentra ninguna diferencia, devuelve -1. Tambi\u00e9n tiene una versi\u00f3n sobrecargada para especificar un rango.</p> </li> </ul> <pre><code>public class Mismatch {\npublic void show(){\nint[] array1 = {3, 4, 5, 6, 7, 8};\nint[] array2 = {3, 4, 5, 6, 7, 8};\nint[] array3 = {3, 4, 5, 6, 7, 8, 9, 10, 11};\nint indexMismatch;\nindexMismatch = Arrays.mismatch(array1, array2);\nif(indexMismatch == -1){\nSystem.out.printf(\"%s y %s son iguales\\n\", Arrays.toString(array1), Arrays.toString(array2));\n} else {\nSystem.out.printf(\"%s y %s tienen su primera diferencia en el elemento %d\\n\",\nArrays.toString(array1), Arrays.toString(array2), indexMismatch);\n}\nindexMismatch = Arrays.mismatch(array1, array3);\nif(indexMismatch == -1){\nSystem.out.printf(\"%s y %s son iguales\\n\", Arrays.toString(array1), Arrays.toString(array3));\n} else {\nSystem.out.printf(\"%s y %s tienen su primera diferencia en el elemento %d\\n\",\nArrays.toString(array1), Arrays.toString(array3), indexMismatch);\n}\nindexMismatch = Arrays.mismatch(array1, 2, 6, array3, 2, 6);\nif(indexMismatch == -1){\nSystem.out.printf(\"%s y %s son iguales en el rango 2-5\\n\", Arrays.toString(array1), Arrays.toString(array2));\n} else {\nSystem.out.printf(\"%s y %s tienen su primera diferencia en el elemento %d en el rango 2-5\\n\",\nArrays.toString(array1), Arrays.toString(array2), indexMismatch);\n}\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-4/#copias","title":"Copias","text":"<ul> <li> <p>M\u00e9todo copyOf: obtiene una copia de un array. Recibe dos par\u00e1metros, el array a copiar y el tama\u00f1o del array resultante. De mode que:         - si el tama\u00f1o es menor que el del array original: s\u00f3lo obtiene una copia de los primeros elementos, tantos como indique el tama\u00f1o.         - si el tama\u00f1o es mayor que el original: devuelve un array en el que los elementos superan al original se rellenaran con el valor por defecto seg\u00fan el tipo de datos del array.</p> <pre><code>public class CopyOf {\npublic void show(){\nint[] array1 = {3, 4, 5, 6, 7, 8, 9, 10};\nint[] array2 = Arrays.copyOf(array1, 5);\nint[] array3 = Arrays.copyOf(array1, 10);\nSystem.out.println(Arrays.toString(array2)); // [3, 4, 5, 6, 7]\nSystem.out.println(Arrays.toString(array3)); // [3, 4, 5, 6, 7, 8, 9, 10, 0, 0]\n}\npublic static void main(String[] args) {\nnew CopyOf().show();\n}\n}\n</code></pre> </li> <li> <p>M\u00e9todo copyOfRange: obtiene una copia de un array especificando el rango, es decir, de qu\u00e9 elemento a qu\u00e9 elemento se hace la copia.</p> <pre><code>public class CopyOfRange {\npublic void show(){\nint[] array1 = {3, 4, 5, 6, 7, 8, 9, 10};\nint[] array2 = Arrays.copyOfRange(array1, 2, 6);\nSystem.out.println(Arrays.toString(array2)); // [5, 6, 7, 8]\n}\npublic static void main(String[] args) {\nnew CopyOfRange().show();\n}\n}\n</code></pre> </li> </ul>"},{"location":"bloque_ii/tema_6/page-4/#ordenaciones","title":"Ordenaciones","text":"<p>El m\u00e9todo sort ordena un array de forma ascendente. Tambi\u00e9n tiene una versi\u00f3n sobrecargada para especificar un rango.</p> <pre><code>public class Sort {\npublic void show(){\nint[] array1 = {8, 4, 3, 7, 5, 6};\nint[] array2 = {8, 4, 3, 7, 5, 6};\nArrays.sort(array1);\nSystem.out.println(Arrays.toString(array1)); // [3, 4, 5, 6, 7, 8]\nArrays.sort(array2,1 ,5);\nSystem.out.println(Arrays.toString(array2)); // [8, 3, 4, 5, 7, 6]\n}\npublic static void main(String[] args) {\nnew Sort().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_6/page-5/","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza una funci\u00f3n que reciba varios n\u00fameros enteros y devuelva la multiplicaci\u00f3n de todos los n\u00fameros enteros.</p> Ejercicio 2 <p>Realiza una funci\u00f3n que reciba un array y devuelva otro array con sus elementos invertidos. Por ejemplo, si recibe {1, 2, 3} devuelve {3, 2, 1}.</p> Ejercicio 3 <p>Realiza el mismo ejercicio anterior pero haciendo uso de una funci\u00f3n recursiva.</p> Ejercicio 4 <p>Crea un array de caracteres que contengan de la 'A' a la 'Z' (solo may\u00fasculas). Despu\u00e9s, ve pidiendo posiciones de array por teclado y si la posici\u00f3n es correcta, se a\u00f1adir\u00e1 a una cadena que se mostrar\u00e1 al final. Se dejar\u00e1 de insertar cuando se introduzca -1.</p> Ejercicio 5 <p>Realiza el juego del ahorcado. El programa tendr\u00e1 un array con varias palabras y elegir\u00e1 de forma aleatoria una al azar.</p> <p>Se le solicitar\u00e1 al usuario si quiere completar la palabra o escribir un car\u00e1cter. Si elige la primera opci\u00f3n se le solicitar\u00e1 la palabra, en caso de coincidir con la elegida, mostrar\u00e1 un mensaje de ganador, en caso de fallarla, se le mostrar\u00e1 un mensaje de perdedor y se terminar\u00e1 el juego.</p> <p>En caso de elegir la segunda opci\u00f3n, se le solicitar\u00e1 al usuario un car\u00e1cter y se comprobar\u00e1 si forma parte de la palabra, mostrando el avance de la siguiente forma \"_ _ _ _ A\"</p> Ejercicio 6 <p>Realiza un programa que cree un array bidimensional rellen\u00e1ndolo de valores aleatorios comprendidos entre 1 y 10. Luego crea un array con el mismo array, y el valor de la suma de filas y columnas y el tama\u00f1o total. Solicita el tama\u00f1o de la matriz por consola.</p> Ejercicio 7 <p>Realiza una funci\u00f3n que reciba un array de tres dimensiones de n\u00fameros decimales y muestre cu\u00e1l es el elemento mayor y su posici\u00f3n</p> Ejercicio 8 <p>Realiza una funci\u00f3n que reciba un array bidimensional de enteros y devuelva otro array bidimensional con los elementos copiados pero con el doble de columnas. Los elementos nuevos se rellenan con ceros. Por ejemplo, si recibe {{1,2}, {3, 4}, {5, 6}} devuelve {{1, 2, 0, 0}, {3,4, 0, 0}, {5, 6, 0, 0}}</p> Ejercicio 9 <p>Se desea realizar una encuesta a varias personas, en la cu\u00e1l se quiere conocer su sexo (1 si es Hombre, 2 si es mujer), si trabaja (1 si trabaja o 2 si no), y su sueldo (comprendido entre 600 y 2000, siendo 0 en caso de que no trabaje). Crea un array bidimensional aleatorio y calcula:</p> <ul> <li>Porcentaje de hombre</li> <li>Porcentaje de mujeres</li> <li>Porcentaje de hombres que trabajan</li> <li>Porcentaje de mujeres que trabajan</li> <li>El sueldo promedio de los hombres que trabajan</li> <li>El sueldo promedio de las mujeres que trabajan</li> </ul> Ejercicio 10 <p>Realiza el juego del 3 en raya. Para ello se crear\u00e1 una matriz de 3x3 de tipo char. Se le solicitar\u00e1 al usuario la posici\u00f3n donde querr\u00e1 poner su marca, validando que sea correcta y que no tenga una marca puesta. El segundo jugador ser\u00e1 la m\u00e1quina.</p> <p>Al final, se mostrar\u00e1 un mensaje con el nombre del ganador o \"Empate\" en caso de que no haya ganado nadie.</p>"},{"location":"bloque_ii/tema_6/page-6/","title":"Proyecto","text":"<p>En este proyecto se va a realizar cambios en el proyecto conocido como common.</p> <p>Para ello, se debe modificar todas las funciones que se crean oportunas de la clase Strings y Maths haciendo uso de arrays, o de m\u00e9todos que devuelvan arrays si es necesario.</p> <p>Por otro lado, se a\u00f1adir\u00e1 los siguientes m\u00e9todos a la clase Maths:</p> <ul> <li>multiple(n, num): devolver\u00e1 los n m\u00faltiplos de un n\u00famero</li> <li>dividers(num): devolver\u00e1 los divisores de un n\u00fameros.</li> <li>primes(n): devolver\u00e1 los n primeros n\u00fameros primos comprendidos entre 0 y 100.</li> <li>primes(n, from, to): devolver\u00e1 los n primeros n\u00fameros primos comprendidos entre from, inclusivo, y end, exclusivo</li> <li>max(nums): obtiene el m\u00e1ximo valor de los n\u00fameros pasados por par\u00e1metros</li> <li>min(nums): obtiene el m\u00ednimo valor de los n\u00fameros pasados por par\u00e1metros.</li> <li>avg(nums): devolver\u00e1 la media de los n\u00fameros pasados como par\u00e1metros. Crear las versiones sobrecargadas para cada tipo de dato posible</li> <li>mode(nums): devolver\u00e1 la moda de los n\u00fameros pasados como par\u00e1metros. Crear las versiones sobrecargadas para cada tipo de dato posible</li> <li>median(nums): devolver\u00e1 la mediana de los n\u00fameros pasados como par\u00e1metros. Crear las versiones sobrecargadas para cada tipo de dato posible</li> <li>typicalDeviation(nums): devolver\u00e1 la desviaci\u00f3n t\u00edpica de los n\u00fameros pasados como par\u00e1metros. Crear las versiones sobrecargadas para cada tipo de dato posible</li> <li>variance(nums): devolver\u00e1 la varianza de los n\u00fameros pasados como par\u00e1metros. Crear las versiones sobrecargadas para cada tipo de dato posible</li> </ul> <p>Adem\u00e1s, en esta versi\u00f3n, se crear\u00e1 la clase Arrays que contendr\u00e1n m\u00e9todos de utilidad para trabajar con arrays:</p> <ul> <li>randomArray(n): devolver\u00e1 un array rellenado con n\u00fameros aleatorios entre el 0 y el 10 tantas veces como indique n. Comprobar que la capacidad indicada sea un n\u00famero positivo</li> <li>randomArray(n, fromIndex, toIndex): devolver\u00e1 un array rellenado con n\u00fameros aleatorios entre los indicados por par\u00e1metros, ambos inclusivos, tantas veces como indique n. Comprobar que la capacidad indicada sea un n\u00famero positivo</li> <li>add(array, element): a\u00f1adir\u00e1 el elemento al final del array. Crear las versiones sobrecargadas para cada tipo de dato.</li> <li>add(array, index, element): a\u00f1adir\u00e1 el elemento en el \u00edndice indicado del array, comprobando que el \u00edndice no supere el tama\u00f1o del array, y desplazando el resto de elementos, eliminando si fuese necesario el \u00faltimo valor. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>remove(array, index): elimina el elemento en el \u00edndice indicado, comprobando que el \u00edndice no supere el tama\u00f1o del array.</li> <li>set(array, index, element): reemplaza el elemento en el \u00edndice especificado de la lista con el nuevo elemento proporcionado, comprobando que el \u00edndice no supere el tama\u00f1o del array. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>indexOf(array, element): devuelve el primer \u00edndice del array que contenga el elemento indicado, en caso de no encontrarlo devolver\u00e1 -1. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>lastIndexOf(array, element): devuelve el \u00faltimo \u00edndice del array que contenga el elemento indicado, en caso de no encontrarlo devolver\u00e1 -1. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>isEmpty(array): retorna si el array est\u00e1 vac\u00edo, es decir, si no ha sido inicializado o todos sus valores son por defecto. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>isNotEmpty(array): retorna si el array no est\u00e1 vac\u00edo, es decir, si ha sido inicializado y adem\u00e1s tiene alg\u00fan valor que no sea el de por defecto. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>contains(array, element): retorna true si en el array se encuentra el elemento especificado, por el contrario devuelve false. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>notContains(array, element): retorna true si en el array no se encuentra el elemento indicado, por el contrario devuelve true. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>clear(array): vac\u00eda el array, dejando todos sus valor por defecto. Crear las versiones sobrecargadas para cada tipo de dato.</li> <li>addAll(array1, array2): A\u00f1ade todos los elementos del array2 en array1, retornando un nuevo array. Crear las versiones sobrecargadas para cada tipo de dato.</li> <li>subArray(array, fromIndex, toIndex): devuelve un nuevo array con los elementos del array desde el \u00edndice indicado (inclusivo) hasta el \u00edndice especificado (exclusivo), comprobando previamente, que los \u00edndices no superen el tama\u00f1o del array.</li> <li>reverse(array): Invierte el array. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>plus(arrayA, arrayB): suma ambos array retornando el resultado.</li> <li>minus(arrayA, arrayB): resta ambos array retornando el resultado.</li> <li>scalarProduct(n, arrayA): devuelve el array A multiplicando cada uno de sus elementos por n</li> <li>product(arrayA, arrayB): devuelve la multiplicaci\u00f3n de ambos arrays multiplicando cada elemento de A por cada elemento de B.</li> </ul> <p>Tambi\u00e9n se crear\u00e1 la clase Matrixs que contendr\u00e1 los m\u00e9todos de utilidad para trabajar con arrays bidimensionales:</p> <ul> <li>isRegular(array): devolver\u00e1 true si el array bidimensional es regular, false si no lo es. Crear las versiones sobrecargadas para cada tipo de dato</li> <li>isIrregular(array): devolver\u00e1 true si el array bidimensional es irregular, false si no lo es.Crear las versiones sobrecargadas para cada tipo de dato</li> <li>randomMatrix(n, m): devolver\u00e1 una matriz rellenada con n\u00fameros aleatorios entre el 0 y el 10 tantas veces como indique n y m.</li> <li>randomMatrix(n, m, fromIndex, toIndex): devolver\u00e1 un array rellenado con n\u00fameros aleatorios entre los indicados por par\u00e1metros, ambos inclusivos, tantas veces como indique n y m.</li> <li>sum(matrix): devolver\u00e1 la suma de todos los elementos de la matriz.</li> <li>sumFiles(matrix): devolver\u00e1 la suma de todas las filas de la matriz.</li> <li>sumColumns(matrix): devolver\u00e1 la suma de todas las columnas de la matriz.</li> <li>sumDiagonal(matrix): devolver\u00e1 la suma de la diagonal de la matriz</li> <li>sumDiagonalReverse(matrix): devolver\u00e1 la suma de la diagonal inversa de la matriz.</li> <li>transpose(matrix): devolver\u00e1 la matriz transpuesta de la matriz indicada.</li> <li>isSymmetric(matrix): devolver\u00e1 true si la matriz indicada es sim\u00e9trica, o false si no lo es.</li> <li>determinant(matrix): calcula el determinante de la matriz.</li> <li>add(matrixA, matrixB): suma ambas matrices retornando el resultado.</li> <li>minus(matrixA, matrixB): resta ambas matrices retornando el resultado.</li> <li>scalarProduct(n, matrixA): devuelve la matriz A multiplicando cada uno de sus elementos por n</li> <li>product(matrixA, matrixB): devuelve la multiplicaci\u00f3n de ambas matrices multiplicando cada elemento de A por cada elemento de B.</li> </ul> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>NO se realizar\u00e1 una versi\u00f3n sobre el proyecto 5, sino que se realizar\u00e1 un copia de dicho proyecto en esta versi\u00f3n</li> <li>Se mantendr\u00e1 el paquete principal llamado <code>com.NOMBRE.common</code> donde nombre ser\u00e1 el nombre del alumno y common el nombre del proyecto.</li> <li>Se crear\u00e1 una clase Main, donde se ponga en pr\u00e1ctica los usos de la librer\u00eda y se valorar\u00e1 la complejidad de dicho Main.</li> <li>Se deber\u00e1n respetar el nombre de las funciones.</li> <li>El nombre del resto de funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre <code>pr06java-NOMBRE-arrays</code> siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_ii/tema_7/page-1/","title":"1 Introducci\u00f3n a la herencia","text":""},{"location":"bloque_ii/tema_7/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La herencia permite definir una clase tomando como base a otra clase ya existente. Dicha clase base se conoce como superclase o clase padre y la clase que hereda se denomina subclase o clase hija. Por lo tanto, una subclase es una versi\u00f3n especializada de una superclase, ya que hereda tanto los atributos como los m\u00e9todos definidos por la superclase y adem\u00e1s a\u00f1ade los suyos propios.</p> <p>Esto es una de las bases de la reutilizaci\u00f3n de c\u00f3digo ya que cuando se quiere crear una clase nueva y ya existe una clase que incluye parte del c\u00f3digo que queremos, podemos heredar nuestra nueva clase de la clase existente reutilizando los atributos y m\u00e9todos de la misma. La herencia facilita el trabajo del programador porque permite crear clases est\u00e1ndar y a partir de ellas crear nuestras propias clases personales. Esto es m\u00e1s c\u00f3modo que tener que crear todas las clases desde cero.</p> <p>Por ejemplo, si quisi\u00e9ramos realizar una aplicaci\u00f3n de veh\u00edculos, definir\u00edamos una superclase o clase padre con lo com\u00fan a todos los veh\u00edculos y luego definir\u00edamos una subclase o clase hija para cada tipo de veh\u00edculo donde se a\u00f1adir\u00eda lo particular de cada uno.</p> <p>En  java,  la  herencia  se  especifica  en  la  subclase  a\u00f1adiendo  la  palabra  extends  seguida  del nombre de la superclase. Por ejemplo, as\u00ed ser\u00eda para indicar que Coche es hija de Veh\u00edculo:</p> <pre><code>public class Car extends Vehicle{\n// ...\n}\n</code></pre> <p>En Java, solamente se puede tener un padre pero puede hacer varios niveles de herencia, es decir, clases hijas que a su vez son padres de otras clases. Por ejemplo, el Car es hija de Vehicle pero puede ser padre de otra clase, como por ejemplo TodoTerreno:</p> <pre><code>public class TodoTerreno extends Car{\n// ...\n}\n</code></pre> <p>Si  el  padre  tiene  alg\u00fan  atributo  est\u00e1tico,  tambi\u00e9n  lo  pueden  usar  los  hijos. <code>ClasePadre.AtributoEst\u00e1tico</code> y  <code>ClaseHijo.AtributoEst\u00e1tico</code> acceden a la misma variable porque es el mismo atributo est\u00e1tico.</p>"},{"location":"bloque_ii/tema_7/page-1/#modificadores-de-acceso","title":"Modificadores de acceso","text":"<p>En  el  tema  4.  Programaci\u00f3n  Orientada  a  Objetos  vimos  los  modificadores  de  acceso  y  c\u00f3mo afectaban a la visibilidad. En este tema vamos a incorporar el modificador de acceso protected que es el que est\u00e1 pensado para la herencia.</p> <p>Los modificadores de acceso afectan a la visibilidad y tambi\u00e9n afectan a la herencia. Visibilidad es lo que una clase puede ver de otra clase y herencia es lo que una clase hereda de otra clase. He aqu\u00ed dos tablas con los modificadores de acceso, una para la visibilidad y otra para la herencia</p> <p>Tabla de visibilidad</p> Private Friendly Protected Public Misma clase x x x x Mismo paquete x x x Otro paquete x Subclase en el mismo paquete x x x Subclase en distinto paquete x <p>Tabla de herencia</p> Private Friendly Protected Public Subclase en el mismo paquete x x x Subclase en distinto paquete x <p>Si las clases est\u00e1n en un subpaquete, a efectos de visibilidad y herencia se considera que est\u00e1n en otro paquete.</p> <p>Las conclusiones que se pueden obtener a partir de las dos tablas son las siguientes:</p> <ul> <li>La visibilidad es la misma independientemente de que la clase sea hija o no.</li> <li>En herencia, siempre se hereda el protected independientemente del paquete donde se encuentre  la  clase  hija.  Por  lo  tanto,  cuando  dise\u00f1emos  una  clase  que  vaya  a  tener descendientes, es conveniente declarar sus atributos como protected.</li> </ul> <p>Un atributo private no se hereda pero si los getters y setters del padre tienen un modificador distinto de private, s\u00ed puede el hijo utilizar dicho atributo a trav\u00e9s de dichos m\u00e9todos. Pero no es conveniente programar de esta manera, es m\u00e1s adecuado utilizar el modificador protected.</p> VehicleCarMainSalida <pre><code>public class Vehicle {\nprotected int wheelCount;\nprotected double speed;\nprotected String color;\npublic String getColor() {\nreturn color;\n}\npublic void setColor(String color) {\nthis.color = color;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic void accelerate(double amount){\nspeed += amount;\n}\npublic void brake(double amount){\nspeed -= amount;\n}\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n/*\n     * Car hereda de Vehicle los atributos wheelCount, speed y color porque\n     son protected\n     * Tambi\u00e9n hereda todos los m\u00e9todos de Vehicle, ya que son public\n     * Adem\u00e1s, puede tener atributos y m\u00e9todos propios\n     */\nprivate double gasoline;\npublic double getGasoline() {\nreturn gasoline;\n}\npublic void refuel(double liters) {\ngasoline += liters;\n}\n}\n</code></pre> <pre><code>public class MainProtected {\npublic void show(){\nCar car = new Car();\ncar.accelerate(100);\nSystem.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\ncar.refuel(40.35);\nSystem.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\n}\npublic static void main(String[] args) {\nnew MainProtected().show();\n}\n}\n</code></pre> <pre><code>La velocidad del coche es 100,00 km/h\nEl coche tiene 40,35 litros de gasolina\n</code></pre>"},{"location":"bloque_ii/tema_7/page-1/#sobrecarga-y-anulacion-de-metodos","title":"Sobrecarga y anulaci\u00f3n de m\u00e9todos","text":"<p>Se puede sobrecargar un m\u00e9todo heredado para proporcionar una versi\u00f3n del mismo adaptado a las necesidades de la subclase.</p> CarMainSalida <pre><code>public class Car extends Vehicle {\nprivate double gasoline;\npublic double getGasoline() {\nreturn gasoline;\n}\npublic void refuel(double liters) {\ngasoline += liters;\n}\npublic void accelerate(){\nspeed += 10;\n}\n}\n</code></pre> <pre><code>public class Overload {\npublic void show(){\nCar car = new Car();\ncar.accelerate(100); // Heredado\nSystem.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\ncar.accelerate(); // sobrecargado\nSystem.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\n}\npublic static void main(String[] args) {\nnew Overload().show();\n}\n}\n</code></pre> <pre><code>La velocidad del coche es 100,00 km/h\nLa velocidad del coche es 110,00 km/h\n</code></pre> <p>Si la subclase define un m\u00e9todo con la misma firma que un m\u00e9todo heredado, entonces anula o sobrescribe el m\u00e9todo de la superclase. Veamos un ejemplo donde el coche ha anulado el m\u00e9todo heredado de acelerar para a\u00f1adirle el consumo de gasolina:</p> CarMainSalida <pre><code>public class Car extends Vehicle {\nprivate double gasoline;\npublic double getGasoline() {\nreturn gasoline;\n}\npublic void refuel(double liters) {\ngasoline += liters;\n}\n@Override\npublic void accelerate(double amount){\nspeed += amount;\ngasoline *= 0.9;\n}\n}\n</code></pre> <pre><code>public class MainOverride {\npublic void show(){\nCar car = new Car();\ncar.refuel(40.35);\nSystem.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\ncar.accelerate(100);\nSystem.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\n}\npublic static void main(String[] args) {\nnew MainOverride().show();\n}\n}\n</code></pre> <pre><code>El coche tiene 40,35 litros de gasolina\nEl coche tiene 36,32 litros de gasolina\n</code></pre> <p>En  la  clase Car,  se  puede  observar  la  anotaci\u00f3n  @Override  antes  de  la  firma  del  m\u00e9todo accelerate.</p> <p>Las anotaciones de Java comienzan con @ y permiten incrustar informaci\u00f3n suplementaria en un programa para que pueda ser utilizada por varias herramientas.</p> <p>La anotaci\u00f3n @Override le indica al compilador que el m\u00e9todo debe sobrescribir un m\u00e9todo de la superclase.  Si  no  lo  hace,  el  compilador  generar\u00e1  un  error.  Se  utiliza  para  asegurar  que  un m\u00e9todo  de  superclase  est\u00e9  anulado,  y  no  simplemente  sobrecargado.  Es  una  manera  de comprobar en tiempo de compilaci\u00f3n que se est\u00e1 anulando correctamente un m\u00e9todo, y de este modo evitar errores en tiempo de ejecuci\u00f3n los cuales ser\u00edan mucho m\u00e1s dif\u00edciles de detectar.</p> <p>La visibilidad de lo que se hereda es con respecto al paquete de la superclase, no con respecto al paquete de la subclase. Si no interesa, la subclase tendr\u00e1 que sobrescribir lo heredado aunque no  haga  ning\u00fan  cambio  para  que  la  visibilidad  sea  con  respecto  al  paquete  de  la  subclase.</p> <p>Veamos un ejemplo donde Vehicle est\u00e1 en un paquete distinto que Car. Vehicle tiene el m\u00e9todo accelerate  como  protected,  por  lo  tanto  Car  lo  hereda  aunque  est\u00e9  en  otro  paquete  como podemos observar en la tabla de herencia. La clase Main se encuentra en el mismo paquete que Car y quiere acceder al m\u00e9todo accelerate del mismo. Pero la visibilidad de accelerate  es  con respecto al paquete de Vehicle  ya  que  la  visibilidad  de  lo  que  se  hereda  es  con  respecto  al paquete de la superclase, no con respecto al paquete de la subclase. Dicho m\u00e9todo es protected y si nos fijamos en la tabla de visibilidad, un protected no es visible desde otro paquete, por lo que no se le va a permitir dando un error de compilaci\u00f3n:</p> VehicleCarMain <pre><code>public class Vehicle {\nprotected int wheelCount;\nprotected double speed;\nprotected String color;\npublic String getColor() {\nreturn color;\n}\npublic void setColor(String color) {\nthis.color = color;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic double getSpeed() {\nreturn speed;\n}\nprotected void accelerate(double amount){\nspeed += amount;\n}\npublic void brake(double amount){\nspeed -= amount;\n}\n}\n</code></pre> <pre><code>public class Car extends Vehicle {\nprivate double gasoline;\npublic double getGasoline() {\nreturn gasoline;\n}\npublic void refuel(double liters) {\ngasoline += liters;\n}\n}\n</code></pre> <pre><code>public class Visibility {\npublic void show(){\nexercises.bloque_ii.tema_07.modifier_protected.Car car = new Car();\ncar.accelerate(100); // Error de compilaci\u00f3n porque no es visible\nSystem.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\ncar.refuel(40.35);\nSystem.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\n}\npublic static void main(String[] args) {\nnew Visibility().show();\n}\n}\n</code></pre> <p>La soluci\u00f3n es que Car anule el m\u00e9todo accelerate heredado de Vehicle para que la visibilidad de dicho m\u00e9todo sea con respecto al paquete de Car. Car no va a realizar ning\u00fan cambio en dicho m\u00e9todo, es decir, lo va a anular para dejarlo exactamente igual, pero de esta forma modifica el paquete para la visibilidad:</p> <pre><code>public class Car extends Vehicle{\n// ...\n@Override\nprotected void accelerate(double amount){\nspeed += amount;\n}\n}\n</code></pre> <p>Pero, \u00bfqu\u00e9 ocurrir\u00eda si la clase Main estuviera en un paquete distinto a Car? Dar\u00eda un error de compilaci\u00f3n porque un protected no es visible desde otro paquete.</p> <p>La soluci\u00f3n ser\u00eda que Car cambiara la visibilidad del m\u00e9todo. Si una subclase quiere anular alg\u00fan m\u00e9todo  de  la  superclase  para  cambiar  la  visibilidad,  se  permite  \u00fanicamente  si  amplia  la visibilidad, no si la reduce. La escala de valores de m\u00e1s restrictivo a menos es: private, friendly, protected y public. Por ejemplo, no se puede cambiar de protected a friendly pero s\u00ed al rev\u00e9s. Solucionemos el ejemplo anterior para que la clase Main pueda acceder al m\u00e9todo accelerate de Car. Si nos fijamos en la tabla de visibilidad, el \u00fanico modificador que nos permite visibilidad desde  otro  paquete  es  public.  Entonces,  tendr\u00edamos  que  cambiar  el  protected  a  public  y  se permite porque se amplia la visibilidad, no se reduce:</p> <pre><code>public class Car extends Vehicle{\n// ...\n@Override\npublic void accelerate(double amount){\nspeed += amount;\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-2/","title":"2 Constructores","text":""},{"location":"bloque_ii/tema_7/page-2/#super","title":"Super","text":"<p>A veces se requiere llamar a un m\u00e9todo de la superclase. Eso se realiza con la palabra reservada super. En el tema 4. Programaci\u00f3n Orientada a Objetos vimos que this es una variable que hace referencia al objeto actual, pues super es una variable que hace referencia a la superclase del objeto actual, por lo tanto es un m\u00e9todo imprescindible para poder acceder a m\u00e9todos anulados por herencia.</p> CarMainSalidas <pre><code>public class Car extends Vehicle {\nprivate double gasoline;\npublic double getGasoline() {\nreturn gasoline;\n}\npublic void refuel(double liters) {\ngasoline += liters;\n}\n@Override\npublic void accelerate(double amount){\nsuper.accelerate(amount); // Llamo al accelerate del padre\ngasoline *= 0.9;\n}\n}\n</code></pre> <pre><code>public class Super {\npublic void show(){\nCar car = new Car();\ncar.refuel(40.35);\nSystem.out.printf(\"El coche tiene %.2f litros de gasolina, y va a %.2f km/h\\n\",\ncar.getGasoline(), car.getSpeed());\ncar.accelerate(100);\nSystem.out.printf(\"El coche tiene %.2f litros de gasolina, y va a %.2f km/h\\n\",\ncar.getGasoline(), car.getSpeed());\n}\npublic static void main(String[] args) {\nnew Super().show();\n}\n}\n</code></pre> <pre><code>El coche tiene 40,35 litros de gasolina y va a 0,00 km/h\nEl coche tiene 36,32 litros de gasolina y va a 100,00 km/h\n</code></pre> <p>En el ejemplo anterior, super.accelerate(amount) llama al m\u00e9todo accelerate de la clase Vehicle el cual acelerar\u00e1 la marcha. Es necesario redefinir el m\u00e9todo accelerate en la clase Car  ya  que aunque la velocidad var\u00eda igual que en la superclase, hay que tener en cuenta el consumo de gasolina.</p>"},{"location":"bloque_ii/tema_7/page-2/#constructores","title":"Constructores","text":"<p>Los constructores no se heredan de la superclase a las subclases pero s\u00ed se pueden invocar los constructores de la superclase desde los constructores de las subclases mediante super:</p> VehicleCarMainSalida <pre><code>public class Vehicle{\n// ...\npublic Vehicle(int wheelCount, String color) {\nthis.wheelCount = wheelCount;\nthis.color = color;\nspeed = 0;\n}\n// ...\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n//...\npublic Car(int wheelCount, String color){\nsuper(wheelCount, color); // Llama constructor del padre\ngasoline = 0;\n}\n// ...\n}\n</code></pre> <pre><code>public class Constructors {\npublic void show(){\nVehicle vehicle = new Vehicle(2, \"azul\");\nCar car = new Car(4, \"rojo\");\nSystem.out.printf(\"Veh\u00edculo: %d ruedas y de color %s\\n\", vehicle.getWheelCount(), vehicle.getColor());\nSystem.out.printf(\"Coche: %d ruedas y de color %s\\n\", car.getWheelCount(), car.getColor());\n}\npublic static void main(String[] args) {\nnew Constructors().show();\n}\n}\n</code></pre> <pre><code>Veh\u00edculo: 2 ruedas y de color azul\nCoche: 4 ruedas y de color rojo\n</code></pre> <p>Si una clase no tiene constructor, Java crea uno por defecto. Pero en el caso de que sea una subclase, Java lo crea con la l\u00ednea de c\u00f3digo super(), es decir, con una llamada al constructor de la superclase.</p> <p>Pero si la superclase tuviera un constructor con par\u00e1metros, Java ya no crear\u00eda el constructor por defecto Vehicle() y a las subclases les dar\u00eda un error de compilaci\u00f3n con la llamada del super():</p> VehicleCar <pre><code>public class Vehicle{\n// ...\n/*\n     * Tiene un constructor con par\u00e1metros, por lo tanto, Java\n     * no crea el constructor por defecto\n     * Vehicle()\n    */\npublic Vehicle(int wheelCount, String color) {\nthis.wheelCount = wheelCount;\nthis.color = color;\nspeed = 0;\n}\n// ...\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n//...\n/* \n     * No tiene constructor. Java lo crea por defecto con la l\u00ednea de c\u00f3digo \n     * super(), es decir, con una llamada al constructor por defecto de la\n     * superclase. Por lo tanto, est\u00e1 llamando a Vehicle(), dando un error \n     * de compilaci\u00f3n ya que no se ha creado. \n     */\n// ...\n}\n</code></pre> <p>Incluso aunque se defina un constructor con par\u00e1metros en la clase Car, Java sigue a\u00f1adiendo de manera impl\u00edcita la llamada super() en el constructor y como no hay constructor por defecto en la clase Vehicle, contin\u00faa dando error de compilaci\u00f3n</p> <pre><code>public class extends Vehicle{\n//...\n/*\n     * Java sigue a\u00f1adiendo de manera impl\u00edcita la llamada super()\n     * en el constructor y como no hay constructor por defecto en\n     * la clase Vehicle, da un error de compilaci\u00f3n\n     */\npublic Car(int wheelCount, String color){\nthis.wheelCount = wheelCount;\nthis.color = color;\nspeed = 0;\ngasoline = 0;\n}\n// ...\n}\n</code></pre> <p>Se  puede  arreglar  realizando  una  llamada  expl\u00edcita  al  constructor  con  par\u00e1metros  de  la superclase:</p> <pre><code>public class Car extends Vehicle{\n//...\npublic Car(int wheelCount, String color){\nsuper(wheelCount, color); // Llama constructor del padre\ngasoline = 0;\n}\n// ...\n}\n</code></pre> <p>Si una subclase tiene m\u00e1s constructores, este problema habr\u00eda que arreglarlo en cada uno de ellos:</p> <pre><code>public class Car extends Vehicle{\n//...\npublic Car(int wheelCount, String color){\nsuper(wheelCount, color); // Llama constructor del padre\ngasoline = 0;\n}\npublic Car(int wheelCount){ // ERROR\nthis.wheelCount = count;\nthis.color = \"blanco\";\nspeed = 0;\ngasoline = 0;\n}\n// ...\n}\n</code></pre> <p>Se puede solucionar de dos maneras:</p> <ol> <li>Haciendo una llamada a un constructor de la superclase mediante super.</li> <li>Haciendo una llamada a un constructor de la propia clase mediante this.</li> </ol> <p>En ambos casos, tienen que ser la primera instrucci\u00f3n del constructor, por lo que el uso de super y this no puede ser simult\u00e1neo, lo que significa que hay que elegir entre ambas.</p> Primera Soluci\u00f3nSegunda Soluci\u00f3n <pre><code>public class Car extends Vehicle{\n//...\npublic Car(int wheelCount, String color){\nsuper(wheelCount, color); // Llama constructor del padre\ngasoline = 0;\n}\npublic Car(int wheelCount){ super(wheelCount, \"blanco\")\nspeed = 0;\ngasoline = 0;\n}\n//...\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n//...\npublic Car(int wheelCount, String color){\nsuper(wheelCount, color); // Llama constructor del padre\ngasoline = 0;\n}\npublic Car(int wheelCount){ this(wheelCount, \"blanco\")\n}\n//...\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-3/","title":"3 Polimorfismo","text":""},{"location":"bloque_ii/tema_7/page-3/#casting-de-objetos","title":"Casting de objetos","text":"<p>Como ocurre con los tipos primitivos, tambi\u00e9n es posible realizar casting entre objetos siempre y cuando est\u00e9 dentro de la estructura jer\u00e1rquica en su herencia.</p> <p>Para crear un objeto, hay que declarar una variable cuyo tipo es una clase:</p> <pre><code>Vehicle vehicle; // vehicle es una variable de tipo Vehicle\n</code></pre> <p>Eso significa que vehicle es de tipo Vehicle y que nunca va a cambiar de tipo, siempre va a ser de tipo Vehicle</p> <p>Creemos ahora una variable de tipo Car:</p> <pre><code>Car car; // car es una variable de tipo car.\n</code></pre> <p>Lo mismo que antes, car es una variable de tipo Car y nunca va a cambiar de tipo, siempre va a ser de tipo Car.</p> <p>A la variable vehicle se le puede asignar un objeto de tipo Vehicle y tambi\u00e9n se le puede asignar objetos cuyo tipo sean una subclase de Vehicle:</p> <pre><code>vehicle = car; // A vehicle se le est\u00e1 asignando un objeto de tipo Car, que es una subclase de Vehicle\n</code></pre> <p>La variable vehicle contiene un objeto de tipo Car pero su tipo es Vehicle, entonces solamente podr\u00e1 acceder a los atributos y m\u00e9todos de Vehicle:</p> <pre><code>vehicle.refuel(50); // Error de compilaci\u00f3n: el m\u00e9todo refuel no est\u00e1 definido para el tipo Vehicle\n</code></pre> <p>La variable vehicle no puede acceder al m\u00e9todo refuel porque dicho m\u00e9todo est\u00e1 definido en la clase Car. Es decir, una variable padre puede contener un objeto de tipo hijo pero solamente podr\u00e1 acceder a los atributos y m\u00e9todos definidos en el padre.</p> <p>\u00bfy si la asignaci\u00f3n la hici\u00e9ramos al rev\u00e9s, es decir, a car le asignamos vehicle?</p> <pre><code>car = vehicle; // Error de compilaci\u00f3n\n</code></pre> <p>Dar\u00eda un error de coincidencia de tipos, pero se podr\u00eda solucionar con un casting:</p> <pre><code>car = (Car) vehicle; // Solucionado con un casting ya que Vehicle contiene un Car\n</code></pre> <p>Hay que tener en cuenta que para que el casting funciones, la variable vehicle debe contener objeto de tipo Car, porque si no, dar\u00e1 un error de ejecuci\u00f3n ClassCastException.</p> <pre><code>vehicle = new Vehicle(2, \"blanco\");\ncar = (Car) vehicle; // Error de ejecuci\u00f3n: ClassCastException ya que Vehicle no contiene un objeto de tipo car\n</code></pre>"},{"location":"bloque_ii/tema_7/page-3/#modificador-final","title":"Modificador final","text":"<p>El modificador final tiene varios usos en funci\u00f3n de d\u00f3nde se utilice:</p> <ul> <li> <p>Delante de una variable en su declaraci\u00f3n, crea una constante. La constante puede recibir el valor en tiempo de compilaci\u00f3n o en tiempo de ejecuci\u00f3n.</p> Compilaci\u00f3nEjecuci\u00f3n <pre><code>final double PI = 3.141591;\n</code></pre> <p><pre><code>public class MyClass{\nprivate final int NUMBER;\npublic MyClass(int n){\nNUMBER = n;\n}\n}\n</code></pre> La constante NUMBER recibe el valor en la construcci\u00f3n del objeto.</p> </li> <li> <p>Delante de una variable que referencia a un objeto: dicha variable no puede referenciar a otro objeto.</p> <pre><code>final Car car = new Car(4, \"rojo\");\ncar = new Car(4, \"blanco\"); //ERROR: no puede referencias a otro objeto\n</code></pre> </li> <li> <p>En la declaraci\u00f3n de un m\u00e9todo: dicho m\u00e9todo no se puede anular por las subclases:</p> VehicleCar <pre><code>public class Vehicle{\n//...\nfinal public void accelerate(double amount){\nspeed += amount;\n}\n//...\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n//...\n@Override\npublic void accelerate(double amount){ // ERROR, no se puede anular el m\u00e9todo\nsuper.accelerate(amount);\ngasoline *= 0.5;\n}\n// ...\n}\n</code></pre> <ul> <li>En la definici\u00f3n de una clase: significa que ese clase no puede tener descendencia.</li> </ul> </li> </ul>"},{"location":"bloque_ii/tema_7/page-3/#polimorfismo","title":"Polimorfismo","text":"<p>Polimorfismo es la capacidad de un objeto de adquirir varias formas.</p> <p>La sobrecarga de m\u00e9todos es un tipo de polimorfismo est\u00e1tico porque se resuelve en tiempo de compilaci\u00f3n el m\u00e9todo apropiado a ser llamado basado en la lista de argumentos.</p> <p>La anulaci\u00f3n de m\u00e9todos es un tipo de polimorfismo din\u00e1mico porque se resuelve en tiempo de ejecuci\u00f3n atendiendo al tipo del objeto. Con una variable de tipo padre, si se utiliza un objeto del padre para invocar al m\u00e9todo, entonces se ejecutar\u00e1 el m\u00e9todo de la clase padre, pero si se utiliza un objeto de la clase hija para invocar al m\u00e9todo, entonces se ejecutar\u00e1 el m\u00e9todo de la clase hija</p> <pre><code>public class Polimorfismo {\npublic void show(){\nVehicle vehicle = new Vehicle(2, \"azul\");\nvehicle.accelerate(100.39); // M\u00e9todo del padre\nSystem.out.printf(\"La velocidad del veh\u00edculo es %.2f km/h\\n\", vehicle.getSpeed());\nvehicle = new Car(4, \"rojo\");\nvehicle.accelerate(50.89); // M\u00e9todo del hijo\nSystem.out.printf(\"La velocidad del veh\u00edculo es %.2f km/h\\n\", vehicle.getSpeed());\n}\npublic static void main(String[] args) {\nnew Polimorfismo().show();\n}\n}\n</code></pre> <p>Otro de las ventajas del polimorfismo es poder tener un m\u00e9todo que solicite un padre, y poder pasarle un hijo:</p> <pre><code>public class Polimorfismo2 {\npublic void show(){\naccelerateVehicle(new Car(4, \"rojo\"));\n}\nprivate void accelerateVehicle(Vehicle vehicle) {\nvehicle.accelerate(100.39); // M\u00e9todo del padre\nSystem.out.printf(\"La velocidad del veh\u00edculo es %.2f km/h\\n\", vehicle.getSpeed());s\n}\npublic static void main(String[] args) {\nnew Polimorfismo2().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-3/#instanceof","title":"instanceof","text":"<p>El  operador  instanceof  permite  comprobar  si  un  determinado  objeto  pertenece  a  una  clase concreta. Se utiliza de esta forma:</p> <pre><code>object instanceof class\n</code></pre> <p>Devuelve true si el objeto pertenece a dicha clase.</p> <pre><code>public class InstanceOf {\npublic void show(){\nVehicle vehicle = new Vehicle(2, \"azul\");\nCar car = new Car(4, \"rojo\");\nSystem.out.println(vehicle instanceof Vehicle); // true\nSystem.out.println(vehicle instanceof Car); // false\nSystem.out.println(car instanceof Vehicle); // true\nSystem.out.println(car instanceof Car); // true\n}\npublic static void main(String[] args) {\nnew InstanceOf().show();\n}\n}\n</code></pre> <p>Tal y como podemos observar en el ejemplo, car tambi\u00e9n devuelve true con Vehicle ya que los objetos de las subclases tambi\u00e9n devuelven true con la superclase.</p>"},{"location":"bloque_ii/tema_7/page-3/#tostring","title":"toString","text":"<p>La clase Object es la clase ra\u00edz de todo el \u00e1rbol de la jerarqu\u00eda de clases Java, es decir, es una superclase impl\u00edcita de todas las dem\u00e1s clases. En otras palabras, todas las dem\u00e1s clases son subclases de Object. Esto significa que una variable de referencia de tipo Object puede referirse a un objeto de cualquier otra clase.</p> <p>La clase Object proporciona un cierto n\u00famero de m\u00e9todos de utilidad general que pueden utilizar todos  los  objetos  ya  que  los  heredan.  Pero  normalmente  hay  que  sobrescribirlos  para  que funcionen adecuadamente adapt\u00e1ndolos a la clase correspondiente. Esto se hace con la idea de que todas las clases utilicen el mismo nombre y prototipo de m\u00e9todo para hacer operaciones comunes. Como por ejemplo, <code>toString()</code> que se utiliza para obtener una cadena de texto que represente al objeto. El m\u00e9todo toString() de la clase Object devuelve una cadena que consiste en el nombre de la clase del objeto, el car\u00e1cter arroba \u2018@\u2019 y la representaci\u00f3n hexadecimal sin signo del c\u00f3digo hash del objeto. Siempre se recomienda sobrescribir el m\u00e9todo toString() para obtener nuestra propia representaci\u00f3n del objeto.</p> <pre><code>public class Vehicle{\n//...\n@Override\npublic String toString() {\nreturn \"Vehicle [wheelCount=\" + wheelCount+ \", speed=\" + speed + \", color=\" + color + \"]\";\n}\n}\n</code></pre> <p>Algunos entornos IDEs, puede autogenerar el c\u00f3digo del m\u00e9todo toString.</p> <p>Haciendo uso del m\u00e9todo para sacar por consola un objeto no es necesario hacer toString de forma expl\u00edcita, ya que dicho m\u00e9todo lo llama de forma impl\u00edcita.</p> <pre><code>public class ToString {\npublic void show(){\nVehicle vehicle = new Vehicle(2, \"azul\");\nSystem.out.println(vehicle);\n}\npublic static void main(String[] args) {\nnew ToString().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-4/","title":"4 Clases abstractas e interfaces","text":""},{"location":"bloque_ii/tema_7/page-4/#clases-abstractas","title":"Clases abstractas","text":"<p>Cuando se crea una estructura con herencia, puede darse el caso de que alg\u00fan m\u00e9todo del padre no se pueda implementar porque los detalles de la implementaci\u00f3n dependan de cada uno de los hijos. Entonces, dicho m\u00e9todo se declara como abstracto en el padre y solamente se define su firma, no se implementa c\u00f3digo en \u00e9l. Los hijos pueden hacer dos cosas:</p> <ol> <li>Implementar el c\u00f3digo de dicho m\u00e9todo.</li> <li>Declararlo tambi\u00e9n como abstracto.</li> </ol> <p>Si  la  clase  contiene  alg\u00fan  m\u00e9todo  abstracto,  se  convierte  en  una  clase  abstracta.  Una  clase abstracta puede contener m\u00e9todos no abstractos pero al menos uno de los m\u00e9todos debe ser abstracto.</p> <p>Para indicar en Java que un m\u00e9todo o una clase son abstractos, se utiliza la palabra reservada abstract.</p> VehicleCarMainSalida <pre><code>public abstract class Vehicle {\n// ...\npublic abstract void accelerate(double amount);\n//..\n}\n</code></pre> <pre><code>public class Car extends Vehicle{\n// ...\n@Override\npublic void accelerate(double amount){\nspeed += amount;\ngasoline *= 0.9;\n}\n}\n</code></pre> <pre><code>public class AbstractClass {\npublic void show(){\nCar car = new Car(4, \"rojo\");\nSystem.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\ncar.refuel(40.35);\nSystem.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\ncar.accelerate(100);\nSystem.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\nSystem.out.printf(\"El coche tiene %.2f litros de gasolina\\n\", car.getGasoline());\n}\npublic static void main(String[] args) {\nnew AbstractClass().show();\n}\n}\n</code></pre> <pre><code>La velocidad del coche es 0,00 km/h\nEl coche tiene 40,35 litros de gasolina\nLa velocidad del coche es 100,00 km/h\nEl coche tiene 36,32 litros de gasolina\n</code></pre> <p>Una clase abstracta no se puede instanciar, es decir, no se pueden crear objetos de ella haciendo uso del new:</p> <pre><code>Vehicle = new Vehicle(2, \"azul\"); // Error de compilaci\u00f3n\n</code></pre> <p>Haciendo  uso  del  polimorfismo,  se  puede  declarar  una  variable  de  una  clase  abstracta  que referencie a un objeto hijo, de tal forma que si se invoca el m\u00e9todo abstracto, se ejecutar\u00e1 la implementaci\u00f3n realizada por el hijo de dicho m\u00e9todo abstracto:</p> <pre><code>Vehicle vehicle = new Car(4, \"rojo\");\nvehicle.accelerate(50.89); //(1)!\nSystem.out.printf(\"La velocidad del coche es %.2f km/h\\n\", car.getSpeed());\n</code></pre> <ol> <li>Se ejecuta la implementaci\u00f3n realizada en Car del m\u00e9todo abstracto accelerate</li> </ol>"},{"location":"bloque_ii/tema_7/page-4/#interfaces","title":"Interfaces","text":"<p>Una  interfaz  en  Java  es  una  colecci\u00f3n  de  m\u00e9todos  abstractos,  es  decir,  en  una  interfaz  se especifica qu\u00e9 se debe hacer pero no c\u00f3mo hacerlo. Ser\u00e1n las clases que implementen estas interfaces las que describen la l\u00f3gica del comportamiento de los m\u00e9todos.</p> <p>Una clase puede implementar m\u00e1s de una interfaz, lo que implica que debe realizar todos los m\u00e9todos de cada una de ellas. Si alg\u00fan m\u00e9todo lo deja como abstracto, entonces se convierte en una clase abstracta.</p> <p>En una interfaz tambi\u00e9n se pueden declarar constantes que luego puedan ser utilizadas por las clases que implementen dicha interfaz.</p> <p>Una interfaz se define en un archivo con el mismo nombre de la interfaz y con extensi\u00f3n .java.</p> <p>Las clases que quieran implementarla, tienen que a\u00f1adir la palabra reservada implements detr\u00e1s del nombre de la clase.</p> <p>Veamos un ejemplo de una interfaz que va a contener acciones que pueda realizar un veh\u00edculo, como por ejemplo, acelerar y frenar:</p> InterfazVehicle <pre><code>public interface ActionVehicle {\nvoid accelerate(double amount);\nvoid brake(double amount);\n}\n</code></pre> <pre><code>public class Vehicle implements ActionVehicle{\n@Override\npublic void accelerate(double amount){\nspeed += amount;\n}\n@Override\npublic void brake(double amount){\nspeed -= amount;\n}\n}\n</code></pre> <p>Para comprobar si una clase implementa una interfaz se puede usar <code>instanceof</code>:</p> <pre><code>Vehicle vehicle = new Vehicle(2, \"rojo\");\nvehicle instanceof Vehicle; // true\n</code></pre>"},{"location":"bloque_ii/tema_7/page-4/#herencia-entre-interfaces","title":"Herencia entre interfaces","text":"<p>Las  interfaces  tambi\u00e9n  pueden  heredar  de  otras  interfaces.  En  este  caso,  la  clase  que implemente la interfaz hija tendr\u00e1 que realizar los m\u00e9todos de la interfaz hija y los m\u00e9todos de la interfaz  padre.  Por  ejemplo,  vamos  a  crear  una  interfaz  GasolineMotor  que  va  a  contener m\u00e9todos de un veh\u00edculo con motor de gasolina y que herede de la interfaz ActionsVehicle:</p> GasolineMotorCar <pre><code>public interface GasolineMotor extends ActionVehicle {\ndouble getGasoline();\nvoid refuel(double liters);\n}\n</code></pre> <pre><code>public class Car extends Vehicle implements GasolineMotor {\n//...\n@Override\npublic double getGasoline() {\nreturn gasoline;\n}\n@Override\npublic void refuel(double liters) {\ngasoline += liters;\n}\n//...\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-4/#metodos-por-defecto","title":"M\u00e9todos por defecto","text":"<p>A partir de Java 8, se pueden definir m\u00e9todos con una implementaci\u00f3n por defecto dentro de las interfaces. Las clases que implementan la interfaz pueden usar dicho m\u00e9todo o anularlo si les interesa otra implementaci\u00f3n diferente.</p> <p>Para indicar que un m\u00e9todo es por defecto se utiliza la palabra reservada default.</p> <p>Por ejemplo, si definimos la siguiente interfaz con el siguiente m\u00e9todo por defecto:</p> <pre><code>public interface Interfaz1{\ndefault void method(String str){\n// Implementaci\u00f3n del m\u00e9todo\n}\n}\n</code></pre> <p>y ahora queremos crear una clase que implemente la interfaz, dicha clase no estar\u00e1 obligada a implementar el m\u00e9todo  <code>method()</code>. Por ejemplo, el siguiente c\u00f3digo es totalmente v\u00e1lido:</p> <pre><code>public class Class1 implements Interfaz1{\n// No estamos obligados a implementar method(), aunque\n// tenemos la posibilidad de anularlo\n}\n</code></pre> <p>Pero  \u00bfqu\u00e9  ocurre  si  una  clase  implementa  dos  interfaces  que  tienen  el  mismo  m\u00e9todo  con implementaci\u00f3n por defecto? En ese caso la clase estar\u00e1 obligada a anular dicho m\u00e9todo, porque no se puede decidir qu\u00e9 implementaci\u00f3n por defecto usar. Por ejemplo:</p> <pre><code>public interface Interfaz1{\ndefault void method1(String str){\n//Implementaci\u00f3n\n}\n}\npublic interface Interfaz2{\ndefault void method1(String str){\n//Implementaci\u00f3n\n}\n}\npublic class Class1 implements Interfaz1, Interfaz2{\n@Override // Estamos oblogado a deshacer la ambig\u00fcedad\nvoid method1(String str){\n//Implementaci\u00f3n en Clase1\n}\n}\n</code></pre> <p>\u00a1Cuidado!</p> <p>Un m\u00e9todo con implementaci\u00f3n por defecto no puede anular a un m\u00e9todo de la clase  <code>java.lang.Object</code>, ya que es la clase base de todas las clases.</p>"},{"location":"bloque_ii/tema_7/page-4/#metodos-estaticos","title":"M\u00e9todos est\u00e1ticos","text":"<p>A partir de Java 8, las interfaces tambi\u00e9n puede contener m\u00e9todos est\u00e1ticos con implementaci\u00f3n por  defecto,  cuya  caracter\u00edstica  principal  es  que  pueden  ser  anulados  por  las  clases  que implementan la interfaz para evitar implementaciones no correctas en dichas clases. Se usan sobre todo para m\u00e9todos de utilidad. Veamos un ejemplo:</p> <pre><code>public interface Interfaz3 {\ndefault void print(String str){\n// Se llama al m\u00e9todo est\u00e1tico de la interfaz desde otro\n// m\u00e9todo default de la interfaz\nif(!isNull(str)){\nSystem.out.println(\"Cadena: \" + str);\n}\n}\nstatic boolean isNull(String str){\nSystem.out.println(\"Interface Null Check\");\nreturn str == null ? true : \"\".equals(str) ? true : false;\n}\n}\n</code></pre> <p>Un m\u00e9todo est\u00e1tico con implementaci\u00f3n por defecto de una interfaz, como el m\u00e9todo <code>isNull()</code> anterior, puede ser llamado desde otro m\u00e9todo de la propia interfaz , por ejemplo desde el m\u00e9todo <code>print()</code>.</p> <p>Tambi\u00e9n puede ser llamado est\u00e1ticamente usando el nombre de la interfaz, como en:</p> <pre><code>boolean resultado = Interfaz3.isNull(\"abc\");\n</code></pre> <p>Pero no puede ser llamado a trav\u00e9s de una instancia de una clase que implemente la interfaz. Por ejemplo, el siguiente c\u00f3digo da un error de compilaci\u00f3n:</p> <pre><code>Class1 myObject = new Class1();\nmyObject.isNull(\"hola\"); // ERROR de compilaci\u00f3n\n</code></pre> <p>No  se  pueden  definir  en  una  interfaz  m\u00e9todos  est\u00e1ticos  con  implementaci\u00f3n  que  tengan  la misma firma que m\u00e9todos de la clase  java.lang.Object , ya que es la clase base de todas las clases.</p>"},{"location":"bloque_ii/tema_7/page-4/#metodos-privados","title":"M\u00e9todos privados","text":"<p>A  partir  de  Java  9,  las  interfaces  pueden  contener  m\u00e9todos  privados,  que  s\u00f3lo  pueden  ser llamados desde m\u00e9todos default de dicha interfaz u otros m\u00e9todos privados de la misma. Sirven, b\u00e1sicamente,  para  poder  separar  el  c\u00f3digo  de  m\u00e9todos  con  implementaci\u00f3n  por  defecto. Veamos un ejemplo:</p> <pre><code>public interface Interfaz4{\n// Este m\u00e9todo privado s\u00f3lo puede ser llamado por m\u00e9todos default\n// de la misma interfaz.\nprivate int getNumeroAleatorio(){\nreturn (new Random()).nextInt(100);\n}\ndefault String method1(String s){\n// Un m\u00e9todo default puede llamar a un m\u00e9todo privado de la interfaz\nreturn s + getNumeroAleatorio();\n}\n}\n</code></pre> <p>A partir de Java 9 tambi\u00e9n podemos definir en una interfaz m\u00e9todos est\u00e1ticos privados, que s\u00f3lo podr\u00e1n ser llamados desde otros m\u00e9todos est\u00e1ticos de la interfaz. Sirven, b\u00e1sicamente, para poder separar el c\u00f3digo de m\u00e9todos est\u00e1ticos de la interfaz. Por ejemplo:</p> <pre><code>public interface Interfaz5{\nprivate static String getPrefix(String p){\nreturn p.equals(\"male\") ? \"Mr. \" : \"Ms. \"\n}\npublic static String getName(String n, String p){\nreturn getPrefix(p) + n;\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-4/#diferencias-entre-una-interfaz-y-una-clase-abstracta","title":"Diferencias entre una interfaz y una clase abstracta","text":"<p>Pero  entonces,  si  las  interfaces  pueden  tener  m\u00e9todos  con  implementaci\u00f3n  por  defecto  y m\u00e9todos privados \u00bfqu\u00e9 diferencia hay entre una interfaz con m\u00e9todos por defecto y una clase abstracta? La diferencia principal es que una interfaz no tiene estado, es decir no podemos almacenar atributos en ella, mientras que una clase abstracta s\u00ed.</p>"},{"location":"bloque_ii/tema_7/page-4/#utilizacion-de-una-interfaz-como-un-tipo-de-dato","title":"Utilizaci\u00f3n de una interfaz como un tipo de dato","text":"<p>Al declarar una interfaz, se declara un nuevo tipo de datos, lo que significa que se puede declarar una variable cuyo tipo es una interfaz. Pero, \u00bfqu\u00e9 va a contener dicha variable? Puede contener un objeto de cualquier clase que implemente dicha interfaz. Con dicha variable, las acciones que se pueden realizar son los m\u00e9todos de la interfaz.</p> <pre><code>public class Interfaces {\npublic void show(){\nVehicle vehicle = new Vehicle(2, \"rojo\");\nActionVehicle actionVehicle;\nSystem.out.printf(\"La velocidad del veh\u00edculo es %.2f km/h\\n\", vehicle.getSpeed());\nactionVehicle = vehicle;\nactionVehicle.accelerate(100.30);\nSystem.out.printf(\"La velocidad del veh\u00edculo es %.2f km/h\\n\", vehicle.getSpeed());\n}\npublic static void main(String[] args) {\nnew Interfaces().show();\n}\n}\n</code></pre> <p>\u00a1OJO!</p> <p>Con una variable de tipo interfaz, las acciones que se pueden realizar son los m\u00e9todos de la interfaz, es decir, con una variable de tipo ActionsVehicle lo que se puede realizar son los m\u00e9todos accelerate y brake que son los m\u00e9todos que pertenecen a la interfaz. Si intent\u00e1ramos realizar un getSpeed que pertenece a la clase Vehicle y no se encuentra entre los m\u00e9todos de la interfaz, nos dar\u00eda un error de compilaci\u00f3n.</p> <pre><code>ActionVehicle actionVehicle = vehicle;\nvehicle.getSpeed(); // ERROR\n</code></pre>"},{"location":"bloque_ii/tema_7/page-5/","title":"5 Clases anidadas","text":""},{"location":"bloque_ii/tema_7/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>En Java se permite escribir una clase dentro de otra clase. La clase de dentro se llama clase anidada y la que la contiene, clase contenedora o externa.</p> <p>Estas clases se utilizan con los siguientes prop\u00f3sitos:</p> <ul> <li>Agrupaci\u00f3n de clases relacionadas.</li> <li>Control de visibilidad de las clases.</li> <li>Proximidad entre la definici\u00f3n y el uso de las clases.</li> <li>Definici\u00f3n de clases simples de ayuda o adaptaci\u00f3n.</li> <li>C\u00f3digo m\u00e1s claro que evita el exceso de clases muy peque\u00f1as que no necesitan conocer los usuarios de un paquete.</li> </ul> <p>Las  clases  anidadas  se  dividen  en  dos  categor\u00edas:  las  clases  anidadas  est\u00e1ticas  y  las  clases anidadas no est\u00e1ticas o clases internas.</p>"},{"location":"bloque_ii/tema_7/page-5/#clases-anidadas-estaticas","title":"Clases anidadas est\u00e1ticas","text":"<p>Son clases declaradas de tipo static que se comportan como una clase normal de Java pero que se encuentran dentro de otra clase. Tambi\u00e9n se pueden usar dentro de una interfaz.</p> <p>Desde la clase anidada est\u00e1tica solamente se pueden acceder a los atributos est\u00e1ticos de la clase contenedora.</p> <p>Se pueden crear objetos sin crear ning\u00fan objeto de la clase contenedora.</p> <p>Para hacer referencia a una clase anidada est\u00e1tica hay que indicar tambi\u00e9n la clase contenedora: <code>ClaseContenedora.ClaseAnidada</code>.</p> ContainerClassMainSalida <pre><code>public class ContainerClass {\npublic static class StaticNestedClass{\npublic void staticNestedMethod(){\nSystem.out.println(\"Clase anidada est\u00e1tica\");\n}\n}\npublic void containerMethod(){\nSystem.out.println(\"Clase externa o contenedora\");\n}\n}\n</code></pre> <pre><code>public class ShowStaticNestedClass {\npublic void show(){\nContainerClass.StaticNestedClass nested = new ContainerClass.StaticNestedClass();\nnested.staticNestedMethod();\nContainerClass container = new ContainerClass();\ncontainer.containerMethod();\n}\npublic static void main(String[] args) {\nnew ShowStaticNestedClass().show();\n}\n}\n</code></pre> <pre><code>Clase anidada est\u00e1tica\nClase externa o contenedora\n</code></pre>"},{"location":"bloque_ii/tema_7/page-5/#clases-anidadas-no-estaticas-o-clases-internas","title":"Clases anidadas no est\u00e1ticas o clases internas","text":"<p>Las clases anidadas no est\u00e1ticas o clases internas tienen acceso a todos los atributos y m\u00e9todos de la clase contenedora, por lo tanto, para que exista un objeto de una clase interna es necesario que exista un objeto de la clase contenedora.</p> ContainerMainSalida <pre><code>public class ContainerClass {\nprivate int numContainer = 10;\npublic class InnerClass{\npublic void innerMethod(){\nSystem.out.printf(\"Clase interna. Puede acceder a la numContainer: %d\\n\", numContainer);\n}\n}\npublic void containerMethod(){\nInnerClass innerClass = new InnerClass();\ninnerClass.innerMethod();\n}\n}\n</code></pre> <pre><code>public class ShowInnerClass {\nprivate void show() {\nContainerClass container = new ContainerClass();\ncontainer.containerMethod();\n}\npublic static void main(String[] args) {\nnew ShowInnerClass().show();\n}\n}\n</code></pre> <pre><code>Clase interna. Puede acceder a numContainer: 10\n</code></pre> <p>Tambi\u00e9n se puede crear un objeto de la clase interna desde fuera de la clase externa siempre y cuando la clase interna sea visible:</p> <pre><code>ContainerClass container = new ContainerClass();\nContainerClass.InnerClass inner = container.new InnerClass();\ninner.innerMethod();\n</code></pre> <p>Se puede hacer una clasificaci\u00f3n de las clases internas en funci\u00f3n de d\u00f3nde y c\u00f3mo se utilicen:</p> <ul> <li>Clases miembro</li> <li>Clases dentro de un m\u00e9todo.</li> <li>Clases dentro de un bloque.</li> <li>Clases an\u00f3nimas</li> </ul>"},{"location":"bloque_ii/tema_7/page-5/#clases-internas-miembro","title":"Clases internas miembro","text":"<p>Se  utilizan  como  atributos  de  la  clase  contenedora.  Si  se  declaran  como  privadas,  la  clase contenedora es la \u00fanica que conoce su existencia.</p> ContainerMainSalida <pre><code>public class ContainerClass {\nprivate int num = 10;\nprivate InnerClass inner = new InnerClass();\nprivate class InnerClass{\nprivate int num = 20;\npublic void innerMethod(){\nSystem.out.printf(\"N\u00famero de la contenedora: %d. N\u00famero de la interna: %d\\n\",\nContainerClass.this.num, num);\n}\n}\npublic void containerMethod(){\ninner.innerMethod();\n}\n}\n</code></pre> <pre><code>public class ShowInnerMemberClass {\nprivate void show() {\nContainerClass container = new ContainerClass();\ncontainer.containerMethod();\n}\npublic static void main(String[] args) {\nnew ShowInnerMemberClass().show();\n}\n}\n</code></pre> <pre><code>N\u00famero de la contenedora: 10. N\u00famero de la interna: 20\n</code></pre> <p>Al usar this dentro de una clase interna, \u00e9ste se refiere al objeto de la clase interna. Para poder referirse al objeto de la clase contenedora, hay que anteponerle al this el nombre de dicha clase, tal y como se puede observar en el ejemplo: <code>ContainerClass.this.num</code>.</p>"},{"location":"bloque_ii/tema_7/page-5/#clases-internas-dentro-de-un-metodo","title":"Clases internas dentro de un m\u00e9todo","text":"<p>Se definen dentro de un m\u00e9todo de la clase contenedora por lo que solamente se pueden utilizar dentro de dicho m\u00e9todo.</p> <p>Se utilizan cuando el m\u00e9todo intenta solucionar un problema y necesita apoyarse en una clase pero no se necesita que esta clase est\u00e9 disponible fuera, por lo tanto, son clases que quedan fuera del dise\u00f1o.</p> <p>La clase interna tiene acceso a los m\u00e9todos y atributos de la clase contenedora y a las variables locales y par\u00e1metros del m\u00e9todo donde se la declara.</p> ContainerMainSalida <pre><code>public class ContainerClass {\nprivate int attribute = 10;\npublic void containerMethod(int parameter){\nint localVariable = 20;\nclass InnerClass{\npublic void innerMethod(){\nSystem.out.printf(\"Clases interna a m\u00e9todo---&gt;\\nAtributo de la clase contenedora: %d\\n\", attribute);\nSystem.out.printf(\"Variable local: %d\\n\", localVariable);\nSystem.out.printf(\"Par\u00e1metro: %d\\n\", parameter);\n}\n}\n}\n}\n</code></pre> <pre><code>public class ShowInnerMethodClass {\nprivate void show() {\nContainerClass container = new ContainerClass();\ncontainer.containerMethod(30);\n}\npublic static void main(String[] args) {\nnew ShowInnerMethodClass().show();\n}\n}\n</code></pre> <pre><code>Clase interna a m\u00e9todo---&gt;\nAtributo de la contenedora: 10\nVariable local: 20\nPar\u00e1metro: 30\n</code></pre>"},{"location":"bloque_ii/tema_7/page-5/#clases-internas-dentro-de-un-bloque","title":"Clases internas dentro de un bloque","text":"<p>S\u00f3lo son visibles y utilizables dentro del bloque de c\u00f3digo en el que se encuentran definidas.</p> ContainerMainSalida <pre><code>public class ContainerClass {\nprivate int attribute = 10;\npublic void containerMethod(int parameter){\nint localVariable = 20;\nif(parameter &gt; localVariable){\nclass InnerClass{\npublic void innerMethod(){\nSystem.out.printf(\"Clase interna a bloque---&gt;\\nAtributo de la contenedora: %d\\n\", attribute);\nSystem.out.printf(\"Variable local: %d\\n\", localVariable);\nSystem.out.printf(\"Par\u00e1metro; %d\\n\", parameter);\n}\n}\nInnerClass inner = new InnerClass();\ninner.innerMethod();\n}\n}\n}\n</code></pre> <pre><code>public class ShowInnerBlockClass {\npublic void show(){\nContainerClass container = new ContainerClass();\ncontainer.containerMethod(30);\n}\npublic static void main(String[] args) {\nnew ShowInnerBlockClass().show();\n}\n}\n</code></pre> <pre><code>Clase interna a bloque---&gt;\nAtributo de la contenedora: 10\nVariable local: 20\nPar\u00e1metro: 30\n</code></pre> <p>\u00a1Cuidado!</p> <p>Si se intenta utilizar la clase fuera del bloque, da un error de compilaci\u00f3n informando que la clase no puede ser resulta como tipo</p>"},{"location":"bloque_ii/tema_7/page-5/#clases-inline-anonimas","title":"Clases inline an\u00f3nimas","text":"<p>Son clases sin nombre que se definen e instancian en una sola operaci\u00f3n. Este tipo de clases se utiliza cuando se quiere anular el m\u00e9todo de una clase o implementar una interfaz solamente para un momento puntual evitando crear una clase nueva para un solo uso. El t\u00e9rmino inline se debe a que en el cuerpo de un m\u00e9todo se puede escribir una clase ah\u00ed mismo, en la l\u00ednea, es decir, sin necesidad de hacerlo en otro archivo.</p> <p>Por ejemplo, tenemos la siguiente class Class:</p> <pre><code>public class Class{\nprotected String message = \"Clases inline an\u00f3nimas\";\npublic void showMessage(){\nSystem.out.println(message);\n}\n}\n</code></pre> <p>Supongamos que queremos anular el m\u00e9todo <code>showMessage()</code> para mostrar el mensaje en rojo en un momento puntual y creamos una subclase o clase hija de Class que sobrescribiera el m\u00e9todo:</p> <pre><code>public class Subclass extends Class{\n@Override\npublic void showMessage(){\nSystem.out.println(RED + message + RESET);\n}\n}\n</code></pre> <p>Entonces estar\u00edamos creando una clase para algo que vamos a hacer solamente una vez. Y si quisi\u00e9ramos en otro momento hacer lo mismo pero en azul, tendr\u00edamos que crear otra subclase para hacerlo. Entonces, la soluci\u00f3n es crear una clase inline an\u00f3nima. Se llama an\u00f3nima porque en ning\u00fan otro momento aparece el nombre <code>Subclass</code>, es decir, estamos haciendo lo mismo que antes pero sin crear la subclase y lo estamos haciendo sobre la marcha:</p> <pre><code>public class AnonymousInlineClass {\npublic void show(){\nClass anonymousInner = new Class(){\npublic void showMessage(String message){\nSystem.out.println(RED + message + RESET);\n}\n};\nanonymousInner.showMessage();\nnew Class(){ // Lo mismo pero sin utilizar una variable\npublic void showMessage(String message){\nSystem.out.println(RED + message + RESET);\n}\n}.showMessage();\n}\npublic static void main(String[] args) {\nnew AnonymousInlineClass().show();\n}\n}\n</code></pre> <p>Veamos un ejemplo con interfaces</p> InterfazMain <pre><code>public interface Message {\nvoid showMessage();\n}\n</code></pre> <pre><code>    public class ShowAnonymousInlineClassWithInterface {\npublic void show(){\nnew Message(){\n@Override\npublic void showMessage() {\nSystem.out.println(RED + \"Clases inline an\u00f3nimas\" + RESET);\n}\n}.showMessage();\nnew Message(){\n@Override\npublic void showMessage() {\nSystem.out.println(BLUE + \"Clases inline an\u00f3nimas\" + RESET);\n}\n}.showMessage();\n}\npublic static void main(String[] args) {\nnew ShowAnonymousInlineClassWithInterface().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-6/","title":"Ejercicios","text":"Ejercicio 1 <p>Queremos hacer una aplicaci\u00f3n para profesores y alumnos. De ambos se quiere conocer el nombre, la edad, el sexo y la nacionalidad. De los profesores se quiere conocer adem\u00e1s el sueldo, y del alumno si es o no repetidor. Realiza los siguientes apartados creando tres paquetes diferentes (uno para apartado). Cada paquete debe contener las clases y la clase con el main.</p> <ol> <li>Realiza en java las clases que consideres oportunas teniendo en cuenta las relaciones de herencia. Realiza un constructor por defecto para todas las clases sin usar super(). Realiza tambi\u00e9n los toString para todas las clases. Haz un programa para probarlo que haga lo siguiente:<ul> <li>Crea un profesor y saca por consola toString.</li> <li>Crea un alumno y saca por consola su toString.</li> <li>Crea una variable del padre y seg\u00fan un valor solicitado por consola, introduce en ella un objeto profesor o alumno. Muestra por consola el toString.</li> </ul> </li> <li>Hacer otra versi\u00f3n sustituyendo el constructor por defecto del padre por otro con par\u00e1metros. Soluciona los errores que surja realizando una llamada expl\u00edcita al constructor de la superclase.</li> <li>Lo mismo que el anterior pero utilizando el this(par\u00e1metros)</li> </ol> Ejercicio 2 <p>Queremos colocar figuras geom\u00e9tricas en un plano bidimensional y adem\u00e1s calcular el \u00e1rea de dichas figuras. Para ello, crear la clase abstracta FiguraGeom\u00e9trica que tendr\u00e1 como m\u00e9todo abstracto calcular_area. Dicha clase iniciar\u00e1 los valores de las coordenadas x e y del plano bidimensional para indicar la posici\u00f3n de la figura en dicho plano. Para el c\u00edrculo ser\u00e1 el centro de la circunferencia y para el resto, el v\u00e9rtice inferior izquierdo. Crea las clases Rect\u00e1ngulo, C\u00edrculo y Tri\u00e1ngulo heredadas de la clase abstracta.</p> Ejercicio 3 <p>Crea una clase empleado y una clase encargado. Los encargados reciben un 10% m\u00e1s de sueldo base que un empleado normal aunque realicen el mismo trabajo. Implementa dichas clases con el m\u00e9todo calcularSueldo() para ambas clases.</p> Ejercicio 4 <p>\u00bfPor qu\u00e9 no compila el siguiente c\u00f3digo?</p> <pre><code>class Prueba{\nprotected String nombre;\nprotected int id;\npublic String getIndent() {\nreturn nombre;\n}\npublic int getIndent(){\nreturn id;\n}\n}\n</code></pre> Ejercicio 5 <p>Implementa la siguiente estructura de clases:</p> <p>Forma es una superclase que tiene cuatro subclases: c\u00edrculo, cuadrado, tri\u00e1ngulo y rombo. Ni forma ni las subclases contienen atributos. La clase Forma es abstracta y contiene el m\u00e9todo abstracto toString(). Las subclases, al no tener atributos, en el m\u00e9todo toString() informar\u00e1n del tipo de forma que son.</p> <p>La clase forma tendr\u00e1 implementado un m\u00e9todo identidad que devuelva una cadena con la clase a la que pertenece. Realiza el m\u00e9todo identidad de tres maneras:</p> <ol> <li>Con el m\u00e9todo getClass(). Investigar en la API sobre este m\u00e9todo.</li> <li>Con instanceof</li> <li>Sin usar getClass() ni instanceof</li> </ol> <p>Hacer un programa que cree un array con cuatro objetos, uno de cada subclase y ejecutar de todos el m\u00e9todo identidad.</p> Ejercicio 6 <p>Este c\u00f3digo est\u00e1 utilizando la estructura de clases del ejercicio anterior. Modifica la sintaxis de las l\u00edneas que dan problema y elimina aquellas l\u00edneas que aunque sean sint\u00e1cticamente correctas nunca pueden funcionar:</p> <pre><code>public class TestForma{\npublic static void main(String[] args){\nForma f = new Circulo();\nf.identidad();\nCirculo c = new Circulo();\n((Forma) c).identidad();\n((Circulo) f).identidad();\nForma f2 = new Forma();\nf2.identidad();\n(Forma) f.identidad();\nf = c;\nc = f;\n}\n}\n</code></pre> Ejercicio 7 <p>Averigua los errores del siguiente c\u00f3digo:</p> <pre><code>public class Test{\npublic int dato = 0;\npublic static int datoStatic = 0;\npublic void metodo(){\nthis.datoStatic++;\n}\npublic static void metodoStatic(){\nthis.datoStatic++;\ndatoStatic++;\n}\npublic static void main(String[] args){\ndato++;\ndatoStatic++;\nmetodosStatic();\nmetodo();\n}\n}\n</code></pre> Ejercicio 8 <p>\u00bfQu\u00e9 mostrar\u00e1 el siguiente programa por pantalla?</p> <pre><code>public class Bebe{\nBebe(int i ){\nthis(\"Soy un bebe consentido\");\nSystem.out.println(\"Hola, tengo \" + i + \" meses\");\n}\nBebe(String s){\nSystem.out.println(s);\n}\nvoid berrea(){\nSystem.out.println(\"Buaaaaaaaa\");\n}\npublic static void main(String[] args){\nnew Bebe(8).berrea();\n}\n}\n</code></pre> Ejercicio 9 <p>Averigua sin ejecutar el c\u00f3digo, que mostrar\u00e1 el siguiente programa por pantalla. Una vez que tengas claro lo que el programa deber\u00eda de mostrar por pantalla ejecuta el c\u00f3digo y verifica que lo que has pensado se cumple.</p> <pre><code>public class Bebe{\nstatic void pedir(){\nSystem.out.println(str1 + \", \" + str2 + \", \" + str3);\n}\nstatic{\nstr2 = \"mama pipi\";\nstr3 = \"mama agua\";\n}\nBebe(){\nSystem.out.println(\"Nacimiento del bebe\");\n}\nstatic String str2, str3, str1 = \"papa tengo caca\";\npublic static void main(String[] args){\nSystem.out.println(\"El bebe se ha despertado y va a pedir cosas\");\nSystem.out.println(\"El bebe dice \" + Bebe.str1);\nBebe.pedir();\n}\nstatic Bebe bebe1 = new Bebe();\nstatic Bebe bebe2 = new Bebe();\nstatic Bebe bebe3 = new Bebe();\n}\n</code></pre> Ejercicio 10 <p>Tenemos la siguiente clase:</p> <pre><code>public abstract class Sorteo{\nprotected int posibilidades;\npublic abstract int lanzar();\n}\n</code></pre> <p>Se pide:</p> <ul> <li>Crear una clase Dado, la cual desciende de la clase Sorteo. La clase Dado, en la llamada al m\u00e9todo lanzar devolver\u00e1 un n\u00famero aleatorio del 1 al 6.</li> <li>Crear la clase Moneda, la cual desciende de la clase Sorteo. Esta clase en la llamada al m\u00e9todo lanzar devolver\u00e1 las palabras cara o cruz</li> </ul> Ejercicio 11 <p>Averigua por qu\u00e9 el compilador da un mensaje de error en el siguiente c\u00f3digo:</p> <pre><code>class TestFinal{\npublic static void main(String[] args){\nfinal String s1 = new String(\"Hola\");\nString s2 = new String(\" Mundo\");\ns1 = s1 + s2;\n}\n}\n</code></pre> Ejercicio 12 <p>Tenemos la siguiente clase:</p> <pre><code>public abstract class Vehiculo{\nprivate int peso;\npublic final void setPeso(int p){\npeso = p;\n}\npublic abstract int getVelocidadActual();\n}\n</code></pre> <ul> <li>\u00bfpodr\u00e1 tener descendencia esta clase?</li> <li>\u00bfse pueden sobrescribir todos sus m\u00e9todos?</li> </ul> Ejercicio 13 <p>Tenemos una jardiner\u00eda donde se venden plantas de jard\u00edn y productos de alfarer\u00eda. Ambas disponen de atributos precio y descripci\u00f3n pero no tienen relaci\u00f3n de herencia. Adem\u00e1s, las plantas disponen de un atributo para indicar si el producto es fr\u00e1gil. Ambas implementan la interfaz Mercanc\u00eda:</p> <pre><code>interface Mercancia{\npublic double damePrecio();\npublic String dameDescripcion();\n}\n</code></pre> <p>Haz un programa para probarlo que contenga el siguiente m\u00e9todo est\u00e1tico: <code>public static void dameDatos(Mercancia mercancia)</code>. Dicho m\u00e9todo deber\u00e1 mostrar el precio y la descripci\u00f3n del producto.</p> Ejercicio 14 <p>Implementa las siguientes interfaces que  heredan de la interface Mercancia del ejercicio anterior:</p> <pre><code>interface MercanciaViva extends Mercancia{\npublic boolean necesitaComida();\npublic boolean necesitaRiego();\n}\n</code></pre> <pre><code>interface MercanciaFragil extends Mercancia{\npublic String dameEmbalaje();\npublic double damePeso();\n}\n</code></pre> <p>Las plantas implementan la interface MercanciaViva y los productos de alfarer\u00eda implementan MercanciaFr\u00e1gil. Haz un programa para probarlo que contenta el siguiente m\u00e9todo est\u00e1tico: <code>public static void dameDatos(Mercancia producto)</code>. Dicho m\u00e9todo deber\u00e1 utilizar los m\u00e9todos de Mercancia, MercanciaViva y MercanciaFragil.</p> Ejercicio 15 <p>Realiza una clase pez con los atributos nombre, especie y zona donde vive. Realiza una subclase llamada pezAguaDulce con un atributo booleano para saber si es un pez de acuario. Realiza para ambas clases el toString y el equals. Haz un programa para probarlos.</p> Ejercicio 16 <p>Para la clase pez anterior, crea un atributo privado entero numpeces, com\u00fan a todos los objetos pez, el cual cuente el n\u00famero de peces creados. Crea un programa que compruebe que est\u00e1 variable se incrementa cada vez que se crea un objeto pez.</p> Ejercicio 17 <p>Realiza una clase huevo que est\u00e9 compuesta por dos clases internas, una clara y otra yema. Realiza un programa para probarlo.</p> Ejercicio 18 <p>\u00bfQu\u00e9 resultado da el siguiente c\u00f3digo? Analiza qu\u00e9 tipo de clase interna se est\u00e1 utilizando y haz una reflexi\u00f3n del resultado.</p> <p><pre><code>public class VerClaseInterna{\npublic static void main(String[] args){\nContenedor c1 = new Contenedor(34);\nContenedor.Contenido i1 = c1.new Contenido(23);\nSystem.out.println(c1.muestraContenedor(i1));\nc1.numero = 50;\nSystem.out.println(i1.muestraContenido());\ni1.numero2 = 25;\nSystem.out.println(c1.muestraContenedor(i1));\ni1.numero2 = 65;\nSystem.out.println(i1.muestraContenido());\n}\n}\n</code></pre> <pre><code>public class Contenedor{\npublic int numero = 0;\npublic Contenedor(int numero){\nthis.numero = numero;\n}\npublic String muestraContenedor(Contenido refCont){\nreturn \"N. contenedor= \" + numero + \" N. contenido= \" + refCont.numero2;\n}\npublic class Contenido{\npublic int numero2;\npublic Contenido(int numero){\nnumero2 = numero;\n}\npublic String muestraContenido(){\nreturn \"N. contenedor= \"+numero+\" N. contenido = \" + numero2;\n}\n}\n}\n</code></pre></p> Ejercicio 19 <p>\u00bfQu\u00e9 resultado da el siguiente c\u00f3digo? Analiza qu\u00e9 tipo de clase interna se est\u00e1 utilizando y haz una reflexi\u00f3n del resultado.</p> <pre><code>public class ClaseLocal{\npublic int numero = 0;\npublic ClaseLocal(int numero){\nthis.numero = numero;\n}\npublic String muestraContenido(){\nclass Mostrador{\npublic String muestraDato(){\nreturn \"N\u00famero = \"+numero;\n}\n}\nMostrador m = new Mostrador();\nreturn m.muestraDato();\n}\n}\n</code></pre> <pre><code>public class VerClaseLocal{\npublic static void main(String[] args){\nClaseLocal c1 = new ClaseLocal(346);\nSystem.out.println(c1.muestraContenido());\n}\n}\n</code></pre> Ejercicio 20 <p>\u00bfQu\u00e9 resultado da el siguiente c\u00f3digo? Analiza qu\u00e9 tipo de clase interna se est\u00e1 utilizando y haz una reflexi\u00f3n del resultado.</p> <pre><code>public class VerClaseAnidada{\npublic static void main(String[] args){\nPrimerContenedor.Contenido i1 = new PrimerContenedor.Contenido(29);\ni1.numero2 = 25;\nSystem.out.println(i1.muestraContenido());\nPrimerContenedor c1 = new PrimerContenedor(34);\nSystem.out.println(c1.muestraContenedor(i1));\n}\n}\n</code></pre> <pre><code>public class PrimerContenedor{\npublic int numero = 0;\nstatic public int numero3 = 13;\npublic PrimerContenedor(int numero){\nthis.numero = numero;\n}\npublic String muestraContenedor(Contenido refCont){\nreturn \"N\u00ba contenedor=\" +numero+ \"N\u00ba contenido=\" + refCont.numero2;\n}\nstatic class Contenido{\npublic int numero2;\npublic Contenido(int numero){\nnumero2 = numero;\n}\npublic String muestraContenido(){\nreturn \"N\u00ba contenedor=\" + numero3 + \" N\u00ba contenido= \" + numero2; }\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_7/page-7/","title":"Proyecto","text":"<p>En este proyecto se quiere almacenar informaci\u00f3n sobre los profesores y alumnos de un instituto.</p> <p>De ambos se desea almacenar su dni, su nombre y su apellidos. De los profesores adem\u00e1s se quiere almacenar el a\u00f1o en el que empez\u00f3 en el instituto.</p> <p>De los alumnos se desea almacenar:</p> <ul> <li>Curso</li> <li>A\u00f1o de matriculaci\u00f3n</li> <li>Notas de cada asignatura.</li> </ul> <p>Existen dos tipos de profesores: Tutores y no tutores, de los tutores se desea almacenar el curso del cual son tutores y adem\u00e1s pueden realizar las siguientes acciones:</p> <ul> <li>Comunicarse con los padres de alg\u00fan alumno (debe recibir el alumno como par\u00e1metro).</li> <li>Dar boletines de notas de un alumno.</li> <li>Pasar lista.</li> </ul> <p>Adem\u00e1s puede hacer tambi\u00e9n podr\u00e1 poner las notas de un alumno, como cualquier profesor.</p> <p>Tambi\u00e9n se quiere guardar informaci\u00f3n de los directores, que no son considerados profesores ya que no imparten clases, pero pueden hacer cualquier acci\u00f3n realizada por un profesor, ya sea tutor o no.</p> <p>Tambi\u00e9n se almacenar\u00e1 la informaci\u00f3n importante del instituto, dividiendo dicha informaci\u00f3n en: informaci\u00f3n de la direcci\u00f3n, que mostrar\u00e1 los datos de la direcci\u00f3n donde se encuentra el instituto, informaci\u00f3n de los directores y del claustro e informaci\u00f3n con todos los alumnos.</p> <p>Realiza una aplicaci\u00f3n Java con la estructura de clase detallada por lo dicho anteriormente, creando un Diagrama de clases. En el Main, se deber\u00e1 crear varios profesor y alumnos y probar todo los m\u00e9todos que contengan.</p> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>Se deber\u00e1 hacer uso de la herencia, de interfaces y clases internas. Valorando el uso de cada una.</li> <li>Se valorar\u00e1 la complejidad de dicho Main.</li> <li>Se podr\u00e1 usar la librer\u00eda common realiza en proyectos anteriores, haciendo uso de JARs.</li> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante. El repositorio de GitHub tendr\u00e1 el siguiente nombre pr07java-NOMBRE-hig-school siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_ii/tema_8/page-1/","title":"1 Introducci\u00f3n a los tipos enumerados","text":""},{"location":"bloque_ii/tema_8/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Un tipo enumerado (enum type) es un tipo cuyos \u00fanicos valores legales consisten en un conjunto fijo de constantes, como por ejemplo las estaciones del a\u00f1o o los palos en una baraja de cartas.</p> <p>Antes  de  que  los  lenguajes  nos  permitieran  definir  tipos  enumerados,  \u00e9stos  eran  simulados declarando un grupo de constantes enteras, una para cada valor posible del tipo. Por ejemplo, para definir los tipos de manzanas y los tipos de naranjas podr\u00edamos hacer:</p> <pre><code>// APPLE TYPES\npublic static final int APPLE_FUJI = 0;\npublic static final int APPLE_PIPPIN = 1;\npublic static final int APPLE_GRANNY_SMITH = 2;\n// ORANGE TYPES\npublic static final int ORANGE_NAVEL = 0;\npublic static final int ORANGE_TEMPLE = 1;\n</code></pre> <p>Esta t\u00e9cnica, conocida como el patr\u00f3n de enumeraci\u00f3n entera, tiene muchos defectos, por lo que no se recomienda su uso.</p> <p>Para  empezar,  al  no  definir  realmente  un  tipo,  el  compilador  no  puede  proporcionarnos seguridad real respecto al tipo. Por ejemplo, podemos pasar un tipo de naranja como argumento de un m\u00e9todo que espera recibir un tipo de manzana, o almacenar un tipo de naranja en una variable que debe tener un tipo de manzana.</p> <pre><code>// Para el compilador esto es correct\nint appleType = ORANGE_TEMPLE;\n</code></pre> <p>No solo eso, podemos comparar err\u00f3neamente tipos de manzanas y tipos de naranjas.</p> <pre><code>int appleType = APPLE_PIPPIN;\nint orangeType = ORANGE_TEMPLE;\nif(appleType == orangeType){\n// ...\n}\n</code></pre> <p>Como Java no proporciona espacios de nombre para grupos de constantes enteras, debemos usar  prefijos  para  evitar  conflictos  con  los  nombres  de  las  constantes  correspondientes  a distintos grupos, como por ejemplo entre <code>ELEMENT_MERCURY</code> y <code>PLANET_MERCURY</code>.</p> <p>Otro problema es que si se cambia el valor asociado a una constante, todas las clases que la usen seguir\u00e1n compilando, pero su comportamiento puede llegar a ser incorrecto.</p> <p>Finalmente, el patr\u00f3n de enumeraci\u00f3n entera tiene el inconveniente de que no hay una forma f\u00e1cil de traducir las constantes enteras a cadenas imprimibles, es decir, la descripci\u00f3n textual del valor que desea representar.</p> <p>En otras ocasiones se usa una variante del patr\u00f3n anterior, pero usando el tipo  String  como tipo para las constantes en lugar de  int. Por ejemplo:</p> <pre><code>// Apple types\npublic static final String APPLE_FUJI = \"FUJI\";\npublic static final String APPLE_PIPPIN = \"PIPPIN\";\npublic static final String APPLE_GRANNY_SMITH = \"SMITH\";\n// Orange types\npublic static final String ORANGE_NAVEL = \"NAVEL\";\npublic static final String ORANGE_TEMPLE = \"TEMPLE\";\n</code></pre> <p>Esta  variaci\u00f3n  se  conoce  como  patr\u00f3n  de  enumeraci\u00f3n  con  cadenas,  y  es  a\u00fan  menos deseable  que  la  anterior,  porque  aunque  proporciona  cadenas  imprimibles  para  sus constantes, los desarrolladores pueden tener la tentaci\u00f3n de usar en otras clases los valores de cadena  directamente  en  vez  de  las  constantes,  por  lo  que  un  simple  error  tipogr\u00e1fico  puede conllevar  fallos  en  tiempo  de  ejecuci\u00f3n.  Adem\u00e1s,  la  comparaci\u00f3n  de  cadenas  es  mucho  m\u00e1s costosa que la de enteros.</p> <p>La  alternativa  adecuada  a  los  patrones  de  enumeraci\u00f3n  anteriores  es  que  el  lenguaje  de programaci\u00f3n  nos  permita  definir  tipos  enumerados,  es  decir,  que  nos  permita  definir  un nuevo tipo indicando cu\u00e1les son los valores legales para dicho tipo y con qu\u00e9 nombre queremos referirnos a dichos valores.</p> <p>En algunos lenguajes de programaci\u00f3n, estos tipos enumerados son internamente tipos enteros. Sin  embargo,  en  Java  cuando  definimos  un  tipo  enumerado,  estamos  definiendo  una  clase completa,  lo  que  nos  proporciona  una  mayor  funcionalidad  a  la  de  otros  lenguajes  de programaci\u00f3n.  En  la  versi\u00f3n  5  de  Java,  se  incorporaron  al  lenguaje  los  tipos  de  datos enumerados.</p> <p>As\u00ed, siguiendo el ejemplo anterior, definir\u00edamos las siguientes clases <code>enum</code>:</p> <pre><code>public enum Apple{\nFUJI, PIPPIN, GRANNY_SMITH\n}\npublic enum Orange{\nNAVEL, TEMPLE\n}\n</code></pre> <p>Los enums presentan numerosas ventajas frente al uso de los patrones de enumeraci\u00f3n entera y de enumeraci\u00f3n con cadenas. La m\u00e1s importante es que la clase enum corresponder\u00e1 a un tipo, por lo que el compilador va a ser capaz de proporcionar comprobaci\u00f3n de tipos en tiempo de compilaci\u00f3n.  Por  ejemplo,  si  se  declara  que  un  par\u00e1metro  es  del  tipo <code>Apple</code>,  el  compilador garantiza que cualquier referencia de objeto no nulo pasada al par\u00e1metro debe ser alguno de las instancias de  Apple  v\u00e1lidas que hemos definido en el enum. En caso contrario, se producir\u00e1 un error  de  compilaci\u00f3n.  Ocurre  exactamente  lo  mismo  al  asignar  una  expresi\u00f3n  de  un  tipo  de enumeraci\u00f3n a una variable de un tipo enum, o al usar el operador <code>==</code> para comparar valores de diferentes tipos enum.</p> <p>Adem\u00e1s,  los  tipos  enum  definen  su  propio  espacio  de  nombres,  por  lo  que  no  hay  ning\u00fan problema en usar constantes con el mismo nombre en distintos enums.</p> <p>Otra ventaja es que si cambiamos el orden de las constantes en el enum, esto no afecta al c\u00f3digo de  los  clientes  del  enum,  dado  que  las  constantes  no  son  compiladas  en  el  c\u00f3digo  cliente,  a diferencia de como ocurr\u00eda en los patrones anteriores.</p>"},{"location":"bloque_ii/tema_8/page-1/#definicion","title":"Definici\u00f3n","text":"<p>Los enumerados se definen con la palabra reservada enum, el nombre del enumerado y luego el conjunto de las constantes, que por las convenciones del lenguaje se escriben en may\u00fascula. Las constantes de la enumeraci\u00f3n son public y static de forma impl\u00edcita.Ejemplo:</p> <pre><code>public enum DayOfWeek{\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n</code></pre> <p>Por otra parte, \u00bfd\u00f3nde debemos definir un enum? Si va a ser usado desde varios lugares, lo l\u00f3gico es definir el enum como una clase en su propio fichero. Si su uso est\u00e1 restringido a una \u00fanica clase cliente, es m\u00e1s razonable definir el enum como una clase interna miembro de dicha clase. Una vez definido el enum, se pueden crear variables de ese tipo:</p> <pre><code>DayOfWeek day; // day es una variable del tipo de enumeraci\u00f3n DayOfWeek\n</code></pre> <p>Como day es de tipo DayOfWeek, los \u00fanicos valores que se le pueden asignar son los definidos por la enumeraci\u00f3n:</p> <pre><code>day = DayOfWeek.MONDAY; // Se asigna a day el valor MONDAY\n</code></pre> <p>El  compilador  nos  da  un  error  si  intentamos  asignar  a  una  variable  enum  un  tipo  que  no  le corresponde:</p> <pre><code>DayOfWeek day = Apple.FUJI; //(1)!\n</code></pre> <ol> <li>ERROR -&gt; falta de correspondencia entre tipos; No se puede convertir de Apple a DayOfWeek</li> </ol>"},{"location":"bloque_ii/tema_8/page-2/","title":"2 Operaciones con tipos enumerados","text":""},{"location":"bloque_ii/tema_8/page-2/#constructores","title":"Constructores","text":"<p>Los  enum  se  implementan  internamente  como  clases.  El  enum DayOfWeek  internamente  se convierte en:</p> <pre><code>class DayOfWeek {\npublic static final DayOfWeek MONDAY = new DayOfWeek();\npublic static final DayOfWeek TUESDAY = new DayOfWeek();\npublic static final DayOfWeek WEDNESDAY = new DayOfWeek();\n// ...\n}\n</code></pre> <p>Los  enum  de  Java  son  clases  que  exportan  una  instancia  (objeto)  para  cada  constante  de enumeraci\u00f3n  a  trav\u00e9s  de  un  campo  final  est\u00e1tico  p\u00fablico.  Estas  instancias  son  creadas autom\u00e1ticamente  al  hacer  referencia  al  enum  en  nuestro  c\u00f3digo,  es  decir,  el  constructor  se ejecuta para cada constante en el momento de la carga de la clase enum. No podemos crear objetos enum expl\u00edcitamente y, por lo tanto, no podemos invocar al constructor directamente:</p> <pre><code>DayOfWeek day = new DayOfWeek(); // ERROR \n</code></pre> <p>Los \u00fanicos modificadores de acceso permitidos para los constructores de los enum son friendly y private. Los modificadores de acceso protected y public dan un error de compilaci\u00f3n.</p> <p>Como vemos, los  enum  de Java son una generaci\u00f3n del patr\u00f3n de dise\u00f1o singleton permitiendo una  determinada  serie  de  instancias,  cada  una  de  las  cuales  es  accesible  a  trav\u00e9s  de  una constante. Visto de forma inversa, podr\u00edamos decir que un singleton no es m\u00e1s que un enum con una sola instancia.</p>"},{"location":"bloque_ii/tema_8/page-2/#comparaciones","title":"Comparaciones","text":"<p>Los enum se pueden comparar utilizando el operador relacional ==:</p> <pre><code>if(day == DayOfWeek.MONDAY){ // ...\n}\nDayOfWeek day = DayOfWeek.MONDAY;\nSystem.out.println(day == DayOfWeek.MONDAY ? \"Es lunes\" : \"No es lunes\")\n</code></pre> <p>El compilador nos da un error si intentamos comparar valores de diferentes tipos enum:</p> <pre><code>DayOfWeek day = DayOfWeek.Monday;\nApple apple = Apple.FUJI;\nif(day == apple){ // ERROR\n}\n</code></pre>"},{"location":"bloque_ii/tema_8/page-2/#enums-en-switch","title":"Enums en switch","text":"<p>Tambi\u00e9n podemos utilizar switch para comprobar en los case los distintos valores del enum:</p> <pre><code>switch(day){\ncase MONDAY:\nSystem.out.println(\"Lunes\");\nbreak;\ncase MONDAY:\nSystem.out.println(\"Martes\");\nbreak;\n// ...\n}\n</code></pre> <p>\u00a1OJO!</p> <p>No es necesario calificar las constantes en las declaraciones de case con su nombre de tipo enum. De hecho, intentar hacerlo provocar\u00e1 un error de compilaci\u00f3n</p>"},{"location":"bloque_ii/tema_8/page-3/","title":"3 Tipo de enumerados compuestos","text":""},{"location":"bloque_ii/tema_8/page-3/#atributos","title":"Atributos","text":"<p>Los enums no dejan de ser clases, por lo que podemos declararles atributos, que deben ser final, ya que los enums son inmutables por naturaleza. Aunque estos atributos pueden ser public, se recomienda definirlos como private y definir los getters correspondientes si es necesario acceder a los atributos desde fuera del enum.</p> <p>Para  establecer  el  valor  de  estos  atributos,  debemos  definir  en  la  clase  enum  el  constructor adecuado y al establecer las instancias pasaremos como argumento los valores deseados que se pasar\u00e1n al constructor. En el ejemplo, cuando definimos PLUS, le ponemos entre par\u00e9ntesis la cadena  \"+\".  Cuando  se  cree  el  objeto  para PLUS,  se  ejecuta  el  constructor  private <code>Operation(String symbol)</code>  y en symbol se pasa \"+\":</p> EnumMainSalida <pre><code>public enum Operation {\nPLUS(\"+\"), MINUS(\"-\"), TIMES(\"*\"), DIVIDE(\"/\");\nprivate final String symbol;\nOperation(String symbol){\nthis.symbol = symbol;\n}\npublic String getSymbol() {\nreturn symbol;\n}\n}\n</code></pre> <p>Observa</p> <p>Del ejemplo se pueden destacar dos cosas importantes y a tener en cuenta:</p> <ul> <li>El constructor es privado aunque no es necesario indic\u00e1rselo, ya que si se indica un modificar diferente dar\u00eda error de compilaci\u00f3n. Esto ocurre para evitar crear objetos fuera del enum.</li> <li>Cuando se declaran atributos, constructores y/o m\u00e9todos es obligatorio poner <code>;</code> al terminar de declarar los valores del enum.</li> </ul> <pre><code>public class EnumAttributes {\npublic void show(){\nOperation operation1 = Operation.PLUS;\nOperation operation2 = Operation.MINUS;\nSystem.out.printf(\"El atributo de PLUS es una cadena con el valor %s\\n\", operation1.getSymbol());\nSystem.out.printf(\"El atributo de MINUS es una cadena con el valor %s\\n\", operation2.getSymbol());\n}\npublic static void main(String[] args) {\nnew EnumAttributes().show();\n}\n}\n</code></pre> <pre><code>El atributo de PLUS es una cadena con el valor +\nEl atributo de MINUS es una cadena con el valor -\n</code></pre>"},{"location":"bloque_ii/tema_8/page-3/#metodos","title":"M\u00e9todos","text":"<p>Una  enumeraci\u00f3n  no  puede  heredar  de  otra  clase  ni  puede  actuar  como  superclase  de  otra clase, pero por defecto, hereda de la clase <code>java.lang.Enum&lt;E&gt;</code> y por tanto tiene una serie de m\u00e9todos heredados, como por ejemplo los m\u00e9todos <code>toString()</code> y <code>ordinal()</code>.</p> <p>Adem\u00e1s, todas las enumeraciones tienen autom\u00e1ticamente dos m\u00e9todos est\u00e1ticos predefinidos: <code>values()</code> y <code>valueOf(String str)</code>.</p>"},{"location":"bloque_ii/tema_8/page-3/#metodo-tostring","title":"M\u00e9todo toString","text":"<p>Las clases enum proporcionan de serie implementaciones de alta calidad de todos los m\u00e9todos de  la  clase <code>Object</code> (la  clase  <code>Enum</code> hereda de <code>Object</code>), como el m\u00e9todo <code>public  String toString()</code>, que retornar\u00e1 el nombre de la constante asociada a la instancia correspondiente. Por ejemplo <code>Apple.FUJI.toString()</code> retorna la cadena <code>FUJI</code>, aunque si no estamos contentos con  dicha  implementaci\u00f3n,  podemos  sobrescribir  nosotros  dicho  m\u00e9todo.  Adem\u00e1s,  las  clases enum implementan de serie las interfaces  <code>Comparable</code> y <code>Serializable</code> .</p> <pre><code>public class EnumToString {\nprivate void show() {\nOperation operation1 = Operation.PLUS;\nOperation operation2 = Operation.MINUS;\nString operation1ToString = operation1.toString();\nString operation2ToString = operation2.toString();\nSystem.out.println(operation1ToString);\nSystem.out.println(operation2ToString);\nSystem.out.println(Operation.DIVIDE);\n}\npublic static void main(String[] args) {\nnew EnumToString().show();\n}\n}\n</code></pre> <p>El m\u00e9todo <code>name()</code> tambi\u00e9n devuelve el nombre del enum.</p>"},{"location":"bloque_ii/tema_8/page-3/#metodo-valueof","title":"M\u00e9todo valueOf","text":"<p><code>public  static  E  valueOf(String  name)</code>   es  un  m\u00e9todo  declarado  impl\u00edcitamente  que devuelve la instancia del enum que posee asociado el nombre de constante recibida.</p> <pre><code>public class EnumValueOf {\nprivate void show() {\nOperation operation = Operation.valueOf(\"PLUS\"); // Se le asigna a operation la instancia correspondiente a PLUS\nSystem.out.printf(\"La variable operation es de tipo enum %s y su s\u00edmbolo es %s\", operation,\noperation.getSymbol());\n}\npublic static void main(String[] args) {\nnew EnumValueOf().show();\n}\n}\n</code></pre> <p>\u00a1CUIDADo!</p> <p>Si el argumento cadena que recibe el m\u00e9todo valueOf no corresponde a ninguna constante de enumeraci\u00f3n, el m\u00e9todo lanza la excepci\u00f3n <code>IllegalArgumentException</code>.</p> <p><pre><code>Operation operation = Operation.valueOf(\"PLUS1\"); //ERROR\n</code></pre> Ten en cuenta que la cadena que corresponda a la enumeraci\u00f3n ha de ser escrita tal y como est\u00e1 escrita en el enum, sino no la reconoce y lanzar\u00e1 la excepci\u00f3n</p> <pre><code>Operation operation = Operation.valueOf(\"plus\"); // ERROR\n</code></pre>"},{"location":"bloque_ii/tema_8/page-3/#metodo-values","title":"M\u00e9todo values","text":"<p><code>public static E[] values()</code> es un m\u00e9todo declarado impl\u00edcitamente que devuelve un array con todas las instancias de la clase enum en el orden en que fueron declarados.</p> <pre><code>public class EnumValues {\nprivate void show() {\nfor (Operation operation : Operation.values()) {\nSystem.out.println(operation);\n}\n}\npublic static void main(String[] args) {\nnew EnumValues().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_8/page-3/#metodo-ordinal","title":"M\u00e9todo ordinal","text":"<p>Una  enumeraci\u00f3n  hereda  de  la  clase <code>java.lang.Enum&lt;E&gt;</code> y por  tanto  tiene  una  serie  de m\u00e9todos heredados, como por ejemplo <code>ordinal()</code>.</p> <p><code>public final int ordinal()</code> devuelve un entero que indica la posici\u00f3n de la constante dentro de la enumeraci\u00f3n. La primera constante tiene el valor 0.</p> <pre><code>public class EnumOrdinal {\nprivate void show() {\nfor (Operation operation : Operation.values()) {\nSystem.out.println(operation.ordinal());\n}\n}\npublic static void main(String[] args) {\nnew EnumOrdinal().show();\n}\n}\n</code></pre> <p>El problema de usar el m\u00e9todo <code>ordinal()</code> es que el funcionamiento del c\u00f3digo cliente depende completamente del orden en el que se definen las constantes en el enum, lo que puede resultar problem\u00e1tico  para  el  mantenimiento  del  c\u00f3digo  si  en  un  futuro  se  cambia  dicho  orden.  En realidad,  este  m\u00e9todo  est\u00e1  dise\u00f1ado  para  ser  utilizado  por  estructuras  de  datos  sofisticadas basadas en enumeraciones como <code>EnumSet</code> y <code>EnumMap</code>. (Se explican en el Tema 11. Colecciones).</p> <p>Por  lo  tanto  se  recomienda  no  hacer  uso  del  m\u00e9todo <code>ordinal()</code>, sino  definir  un  atributo  y asignar un valor para dicho atributo en cada instancia:</p> ENUMMain <pre><code>public enum Operation {\nPLUS(\"+\", 1), MINUS(\"-\", 2), TIMES(\"*\", 3), DIVIDE(\"/\", 4);\nprivate final String symbol;\nprivate final int optionNumber;\nOperation(String symbol, int optionNumber){\nthis.symbol = symbol;\nthis.optionNumber = optionNumber;\n}\npublic String getSymbol() {\nreturn symbol;\n}\npublic int getOptionNumber() {\nreturn optionNumber;\n}\n}\n</code></pre> <pre><code>public class EnumAttributeInsteadOfOrdinal {\nprivate void show() {\nfor (Operation operation : Operation.values()) {\nSystem.out.println(operation.getOptionNumber());\n}\n}\npublic static void main(String[] args) {\nnew EnumAttributeInsteadOfOrdinal().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_8/page-3/#metodos-abstractos","title":"M\u00e9todos abstractos","text":"<p>En algunas ocasiones es necesario asociar un comportamiento ligeramente diferente en cada instancia del enum. En estos casos, debemos declarar un m\u00e9todo abstracto en el enum e incluir la implementaci\u00f3n concreta de dicho m\u00e9todo abstracto en la definici\u00f3n de cada instancia. Estas implementaciones reciben el nombre de constant-specific methods. Por ejemplo:</p> EnumMainSalida <pre><code>public enum Operation {\nPLUS(\"+\"){\n@Override\npublic double apply(double x, double y) {\nreturn x + y;\n}\n}, MINUS(\"-\") {\n@Override\npublic double apply(double x, double y) {\nreturn x - y;\n}\n}, TIMES(\"*\") {\n@Override\npublic double apply(double x, double y) {\nreturn x * y;\n}\n}, DIVIDE(\"/\") {\n@Override\npublic double apply(double x, double y) {\nreturn x / y;\n}\n};\nprivate final String symbol;\nOperation(String symbol){\nthis.symbol = symbol;\n}\npublic String getSymbol() {\nreturn symbol;\n}\npublic abstract double apply(double x, double y);\n}\n</code></pre> <pre><code>public class EnumAbstractMethods {\nprivate void show() {\nfor (Operation operation :\nOperation.values()) {\nSystem.out.printf(\"%-8s %.2f %s %.2f = %.2f\\n\", operation + \":\", 5f, operation.getSymbol(), 5f,\noperation.apply(5, 3));\n}\n}\npublic static void main(String[] args) {\nnew EnumAbstractMethods().show();\n}\n}\n</code></pre> <pre><code>PLUS:     5,00 + 3,00 = 8,00\nMINUS:    5,00 - 3,00 = 2,00\nTIMES:    5,00 * 3,00 = 15,00\nDIVIDE:   5,00 / 3,00 = 1,67\n</code></pre>"},{"location":"bloque_ii/tema_8/page-3/#implementacion-de-interfaces","title":"Implementaci\u00f3n de interfaces","text":"<p>Como  ya  hemos  comentado,  un  enum  no  puede  heredar  de  otro  enum.  Pero  hay  ocasiones donde  tiene  sentido  que  otros  programadores  puedan  \"extender\"  un  enum  que  hayamos proporcionado en nuestra API. Por ejemplo cuando el enum corresponda a c\u00f3digos de operaci\u00f3n sobre una determinada m\u00e1quina, como por ejemplo el enum  Operation , ser\u00eda recomendable que  quien  use  nuestra  API  puede  \"a\u00f1adir\"  nuevas  operaciones.  Para  estos  casos  podemos simular la herencia entre enums definiendo una interfaz con el m\u00e9todo de la operaci\u00f3n y hacer 1ue nuestro enum implemente dicha interfaz. Por ejemplo</p> InterfazBasicOperationExtendOperationMainSalida <pre><code>public interface Operation {\ndouble apply(double x, double y);\nString getSymbol();\n}\n</code></pre> <pre><code>public enum BasicOperation implements Operation {\nPLUS(\"+\"){\n@Override\npublic double apply(double x, double y) {\nreturn x + y;\n}\n}, MINUS(\"-\") {\n@Override\npublic double apply(double x, double y) {\nreturn x - y;\n}\n}, TIMES(\"*\") {\n@Override\npublic double apply(double x, double y) {\nreturn x * y;\n}\n}, DIVIDE(\"/\") {\n@Override\npublic double apply(double x, double y) {\nreturn x / y;\n}\n};\nprivate final String symbol;\nBasicOperation(String symbol){\nthis.symbol = symbol;\n}\n@Override\npublic String getSymbol() {\nreturn symbol;\n}\n}\n</code></pre> <p><pre><code>public enum ExtendedOperation implements Operation{\nEXP(\"^\"){\n@Override\npublic double apply(double x, double y) {\nreturn Math.pow(x, y);\n}\n},\nREMAINDER(\"%\"){\n@Override\npublic double apply(double x, double y) {\nreturn x % y;\n}\n};\nprivate final String symbol;\nExtendedOperation(String symbol) {\nthis.symbol = symbol;\n}\n@Override\npublic String getSymbol() {\nreturn symbol;\n}\n}\n</code></pre> De esta manera, el c\u00f3digo cliente que quiera trabajar con una operaci\u00f3n, tendr\u00e1 que definir la variable correspondiente de tipo interfaz:</p> <p><pre><code>Operation operation = ExtendedOperation.EXT;\n</code></pre> El problema principal de est\u00e1 t\u00e9cnica es que dado de que no se trata de herencia real, no podemos reutilizar c\u00f3digo entre los enums.</p> <pre><code>public class InterfacesImplementation {\nprivate void show() {\nfor (Operation operation : BasicOperation.values()) {\nshow(operation);\n}\nfor (Operation operation : ExtendedOperation.values()) {\nshow(operation);\n}\n}\npublic void show(Operation operation){\nSystem.out.printf(\"%-8s %.2f %s %.2f = %.2f\\n\", operation + \":\", 5f, operation.getSymbol(), 5f,\noperation.apply(5, 3));\n}\npublic static void main(String[] args) {\nnew InterfacesImplementation().show();\n}\n}\n</code></pre> <pre><code>PLUS:       5,00 + 3,00 = 8,00\nMINUS:      5,00 - 3,00 = 2,00\nTIMES:      5,00 * 3,00 = 15,00\nDIVIDE:     5,00 / 3,00 = 1,67\nEXP:        5,00 ^ 3,00 = 125,00\nREMAINDER:  5,00 % 3,00 = 2,00\n</code></pre>"},{"location":"bloque_ii/tema_8/page-4/","title":"Ejercicios","text":"Ejercicio 1 <p>Crea una aplicaci\u00f3n Java que controle los tipos de manera existentes (Roble, Caoba, Nogal, Cerezo, Boj, Otro). Solic\u00edtale al usuario un tipo de manera existen. La aplicaci\u00f3n finalizar\u00e1 cuando el usuario elija una tipo de madera correcto.</p> Ejercicio 2 <p>Se desea controlar los tipos de lenguaje de programaci\u00f3n que se cursa en el IES BellaVista (Java, C#, Python, Javascript, Typescript, C++). Crea un enum que contenga dichos lenguajes de la forma correcta y crea un main que recorra todos los valores del enum, teniendo en cuenta que a la hora de mostrarlo por pantalla la salida deber\u00e1 ser as\u00ed: <code>Lenguaje de programaci\u00f3n Java</code>.</p> Ejercicio 3 <p>En una empresa existen 3 tipos de empleados: Ingeniero, encargado y vendedor, cuyos salarios bases son 50000, 40000 y 30000, respectivamente. Teniendo en cuenta que se le puede aplicar un aumento de sueldo en base a las prestaciones ofrecidas (como por ejemplo, las horas extras, cantidad de venta realizada, etc.) o incluso un descuento si no cumple ciertas condiciones, crea un enum con los tipos de empleados y un main para probar dichas operaciones.</p> Ejercicio 4 <p>En un bar se vende cerveza en diferentes tipos de vasos, siendo su capacidad, altura y precio diferente:</p> Vaso Capacidad Altura Jarra 500 20,7 Tubo 250 16,7 Tercio 333 12,3 Ca\u00f1a 200 8,5 <p>El precio var\u00eda seg\u00fan el tipo de vaso, teniendo en cuenta que se a\u00f1adir\u00e1 0,10 c\u00e9ntimos por cada 100 ml de capacidad y un 1 euro por cada 10 cm de altura, m\u00e1s una cantidad de impuestos que se deber\u00e1 indicar.</p> <p>Haciendo uso de un m\u00e9todo abstracto crea un enum con los tipos de vasos y luego un main para probarlo.</p> Ejercicio 5 <p>Realiza el mismo ejercicio anterior pero haciendo uso de una interfaz.</p>"},{"location":"bloque_ii/tema_9/page-1/","title":"1 Introducci\u00f3n a las Fechas Java8","text":""},{"location":"bloque_ii/tema_9/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>A partir de Java 8, Java incorpora una nueva API para el manejo de fechas, pero hasta entonces el manejo de fechas era muy diferente.</p> <p>Hoy en d\u00eda la mayor\u00eda de aplicaciones Java usan est\u00e1 nueva API, pero a\u00fan hay aplicaciones que usan las versiones antiguas.</p> <p>Las tres clases principales para el manejo de fechas en Java anterior a la 8 son:</p> <ul> <li><code>Date</code>: Almacena la fecha.</li> <li><code>DateFormat</code> y <code>SimpleDateFormat</code>: Aplica formatos a las fechas.</li> <li><code>Calendar</code>: Realizar c\u00e1lculos sobre fechas.</li> </ul> <p>Una de las desventajas que tiene est\u00e1 API es que no trabaja con la internacionalizaci\u00f3n.</p>"},{"location":"bloque_ii/tema_9/page-1/#la-clase-date","title":"La clase Date","text":"<p>La clase <code>Date</code> representa un tiempo espec\u00edfico con la precisi\u00f3n de los milisegundos.</p> <p>Los constructores de esta clase son:</p> <ul> <li><code>Date()</code>: Crea un objeto Date con la fecha y hora actuales.</li> <li><code>Date(int year, int month, int date)</code>: Crea un objeto Date con los datos del a\u00f1o, del mes (comienza en 0 y acaban en 11) y con el d\u00eda.</li> </ul> <p>Estos m\u00e9todos tambi\u00e9n tienen una versi\u00f3n para recibir la hora y los minutos y la hora, los minutos y los segundos.</p> <p>Otra versi\u00f3n del m\u00e9todo es <code>Date(long date)</code> que crea un objeto de tipo Date a partir de los milisegundos especificados desde el tiempo base est\u00e1ndar conocido como epoch, es decir, desde el 1 de Enero de 1970, OO:OO:OO GTM.</p> <p>\u00a1CUIDADA!</p> <p>Todos estos constructores est\u00e1n deprecated y la mayor\u00eda de m\u00e9todos como por ejemplo <code>getYear()</code>, <code>getMonth()</code>, etc. tambi\u00e9n est\u00e1n deprecated.</p> <p>Algunos m\u00e9todos c\u00f3mo after(Date when) o before(Date when) no est\u00e1n deprecated. Estos m\u00e9todos sirven para comprobar si una fecha sucede despu\u00e9s o antes que otra, respectivamente.</p>"},{"location":"bloque_ii/tema_9/page-1/#dateformat-y-simpledateformat","title":"DateFormat y SimpleDateFormat","text":"<p><code>DateFormat</code> es una clase abstracta hecha para subclases de formateo de fecha/tiempo.</p> <p><code>SimpleDateFormat</code> es una clase concreta para formatear y parsear fechas de manera sensible a la configuraci\u00f3n regional.</p> <p>El formato de fecha y hora se especifican con cadenas de patr\u00f3n de fechas y horas:</p> <p>|Letra    |Componente de fecha u hora|Presentaci\u00f3n    |Ejemplo    | |:-------:|:-----------M-------------:|:-------------:|:---------:| |G        |Designador de era         |Texto           |AD         | |y        |A\u00f1o                       |A\u00f1o             |1996;96    | |M        |Mes del a\u00f1o               |Mes             |July;Jul;07| |d        |D\u00eda del mes               |N\u00famero          |9;09       | |H        |Hora del d\u00eda(0-23)        |N\u00famero          |23         | |m        |Minutos en una hora       |N\u00famero          |10         | |s        |Segundo en un minuto      |N\u00famero          |2;02       |</p> <p>Info</p> <p>Para comprobar el resto de patrones puedes ir a la API y observar la tabla: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/text/SimpleDateFormat.html</p> <p>Con el m\u00e9todo <code>format(Date date)</code>, formateamos la fecha indicada con el patr\u00f3n indicado:</p> <pre><code>Date date = new Date(2022, 10, 10, 7, 2 ,5);\nDateFormat format = new SimpleDateFormat(\"dd/M/yy\");\nSystem.out.println(format.format(date)); // 10/11/22\n</code></pre> <p>Con el m\u00e9todo <code>parse(String str)</code> se parsea una cadena a la clase Date siempre y cuando cumpla el formato, por el contrario, lanzar\u00e1 una excepci\u00f3n <code>ParseException</code>:</p> <pre><code>Date newDate = format.parse(\"12/10/22\");\n</code></pre>"},{"location":"bloque_ii/tema_9/page-1/#calendar","title":"Calendar","text":"<p>Una vez creada una fecha , esta simplemente almacena la informaci\u00f3n . Si queremos realizar operaciones sobre ella lo que tenemos que construir es un <code>Calendar</code>. Una vez construido el calendario le asignamos nuestra fecha con el m\u00e9todo <code>setTime(Date date)</code></p> <p>Calendar es una clase abstracta que permite trabajar con fechas en un tipo de calendario. Existe diferentes tipos de subclases que funcionan como calendarios, como por ejemplo, <code>GregorianCalendar()</code> que permite crear un calendario gregoriano.</p> <pre><code>Calendar calendario = new GregorianCalendar();\ncalendario.setTime(date);\n</code></pre> <p>Para obtener el calendario de la zona actual y de la fecha actual se puede usar el m\u00e9todo est\u00e1tico <code>getInstance()</code>:</p> <pre><code>Calendar calendario = Calendar.getInstance();    </code></pre> <p>La clase Calendar tiene varios atributos est\u00e1ticos para indicar meses, <code>Calendar.FEBRUARY</code>, d\u00edas de la semana, <code>Calendar.MONDAY</code>, momentos del a\u00f1o, <code>Calendar.DAY_OF_MONTH</code>, <code>Calendar.HOUR</code>, etc.</p> <p>Una vez establecido el calendario, se puede hacer diferentes operaciones sobre \u00e9l:</p> <ul> <li><code>add(int field, int amount)</code>, siendo el primer par\u00e1metro el atributo est\u00e1tico para indicar que es lo que vamos a\u00f1adir, y el segundo par\u00e1metro la cantidad a a\u00f1adir.</li> <li><code>after(Object object)</code>, comprueba si el calendario representa un momento posterior a la hora indicada en el objeto especificado.</li> <li><code>before(Object objet)</code>, comprueba si el calendario representa un momento anterior a la hora indicada en el objeto especificado.</li> </ul> <pre><code>Date date = new Date(2022, 10, 12); // 12/11/22\nCalendar calendar = Calendar.getInstance(); // Se obtiene el calendario actual\ncalendar.setTime(date); // se le indica la fecha\ncalendar.add(Calendar.MONTH, 5); // A\u00f1adimos cinco meses 12/04/23\n</code></pre>"},{"location":"bloque_ii/tema_9/page-1/#nueva-api-de-java","title":"Nueva API de Java","text":"<p>A partir de Java 8, se creo una nueva API en Java para el manejo de fechas, con muchas ventajas sobre la API anterior, siendo una de ellas la internacionalizaci\u00f3n.</p>"},{"location":"bloque_ii/tema_9/page-2/","title":"2 Fechas en Java 8","text":""},{"location":"bloque_ii/tema_9/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Java 8 introduce una nueva API para fechas y horas que es thread-safe, m\u00e1s f\u00e1cil de leer y m\u00e1s amplia que la API anterior.</p> <p>Esta API se introduce para cubrir los siguientes inconvenientes de la vieja API de fecha y hora:</p> <ol> <li><code>java.util.Date</code> no es thread-safe por lo que los desarrolladores tienen que hacer frente a problemas de concurrencia durante el uso de la fecha. La nueva API de fecha y hora es inmutable y no tiene m\u00e9todos setter. Al ser inmutables, no necesitan ser clonadas.</li> <li>Dificultad para manejar zona-horaria.</li> </ol> <p>En java 8 se crea un nuevo paquete para el manejo de fechas, se trata del paquete <code>java.time</code>. Este paquete es una extensi\u00f3n a las clases <code>java.util.Date</code> y <code>java.util.Calendar</code> que vemos un poco limitado para manejo de fechas, horas y localizaci\u00f3n.</p> <p>Las clases definidas en este paquete representan los principales conceptos de fecha - hora, incluyendo instantes, fechas, horas, per\u00edodos, zonas de tiempo, etc. Est\u00e1n basados en el sistema de calendario ISO, el cual es el calendario mundial de-facto que sigue las reglas del calendario Gregoriano.</p>"},{"location":"bloque_ii/tema_9/page-2/#enumerado-de-dia-de-la-semana","title":"Enumerado de d\u00eda de la semana","text":"<p>Existe un enum donde se definen todos los d\u00edas de la semana. Este enum se llama <code>java.time.DayOfWeek</code> y contiene algunos m\u00e9todos interesantes que permiten manipular d\u00edas hacia adelante, <code>plus(int amount)</code> y hacia atr\u00e1s, <code>minus(int amount)</code>:</p> <pre><code>DayOfWeek dia = DayOfWeek.MONDAY;\nSystem.out.printf(\"8 d\u00edas ser\u00e1: %s%n\",dia.plus(8));\nSystem.out.printf(\"2 d\u00edas antes fue: %s%n\",dia.minus(2));\n</code></pre> <p>Adem\u00e1s, con el m\u00e9todo <code>getDisplayName()</code> se puede acceder al texto que corresponde a la fecha. Este m\u00e9todo recibe dos par\u00e1metros:</p> <ul> <li>TextStyle: Es una enum del paquete <code>java.time.format</code> que define diferentes formas de formatear una fecha:<ul> <li><code>TextStyle.FULL</code>, la descripci\u00f3n completa, por ejemplo Monday.</li> <li><code>TextStyle.NARROW</code>, la letra que representa ese d\u00eda, M.</li> <li><code>TextStyle.SHORT</code>, la abreviaci\u00f3n del d\u00eda, Mon.</li> </ul> </li> <li> <p>Locale: Es una clase que trabaja con la localizaci\u00f3n, de est\u00e1 forma ponemos obtener Monday si estamos en UK, o Lunes si estamos en Espa\u00f1a. Para crear una instancia del objeto <code>Locale</code>, se puede hacer de dos formas:</p> <ul> <li>Usando los atributos est\u00e1ticos que representas los m\u00e1s utilizados, por ejemplo: <code>Locale.ENGLISH</code>.</li> <li>Usando el m\u00e9todo est\u00e1tico <code>of()</code>, que recibe el c\u00f3digo de lenguaje, por ejemplo, si es para espa\u00f1ol. Dicho constructor esta sobrecargado para recibir el c\u00f3digo del pa\u00eds, ES para Espa\u00f1a. Tambi\u00e9n tiene una tercera versi\u00f3n que adem\u00e1s de recibir los dos par\u00e1metros indicados antes, recibe el c\u00f3digo de la variante, por ejemplo ca, para el Catal\u00e1n.</li> </ul> <pre><code>Locale locale = Locale.of(\"es\",\"ES\", \"ca\");\n</code></pre> <p>Java 19</p> <p>En versiones anterior a Java 19, el m\u00e9todo est\u00e1tico <code>of()</code>, no exist\u00eda. En su lugar se usan los constructores (que tienen la misma firma que este m\u00e9todo), que est\u00e1n deprecated en esta versi\u00f3n.</p> </li> </ul> <p>Veamos un ejemplo de como mostrar todos los d\u00edas de la semana en espa\u00f1ol:</p> MainSALIDA <pre><code>public class EnumDays {\npublic void show(){\nLocale locale = Locale.of(\"es\", \"ES\");\nfor (DayOfWeek day : DayOfWeek.values()) {\nSystem.out.printf(\"D\u00eda completo: %s\\n\", day.getDisplayName(TextStyle.FULL, locale));\nSystem.out.printf(\"Letra del d\u00eda: %s\\n\", day.getDisplayName(TextStyle.NARROW, locale));\nSystem.out.printf(\"D\u00eda abreviado: %s\\n\", day.getDisplayName(TextStyle.SHORT, locale));\n}\n}\npublic static void main(String[] args) {\nnew EnumDays().show();\n}\n}\n</code></pre> <pre><code>D\u00eda completo: lunes\nLetra del d\u00eda: L\nD\u00eda abreviado: lun\nD\u00eda completo: martes\nLetra del d\u00eda: M\nD\u00eda abreviado: mar\nD\u00eda completo: mi\u00e9rcoles\nLetra del d\u00eda: X\nD\u00eda abreviado: mi\u00e9\nD\u00eda completo: jueves\nLetra del d\u00eda: J\nD\u00eda abreviado: jue\nD\u00eda completo: viernes\nLetra del d\u00eda: V\nD\u00eda abreviado: vie\nD\u00eda completo: s\u00e1bado\nLetra del d\u00eda: S\nD\u00eda abreviado: s\u00e1b\nD\u00eda completo: domingo\nLetra del d\u00eda: D\nD\u00eda abreviado: dom\n</code></pre>"},{"location":"bloque_ii/tema_9/page-2/#enumerado-de-mes-del-ano","title":"Enumerado de mes del a\u00f1o","text":"<p>En est\u00e1 API, tambi\u00e9n se a\u00f1adi\u00f3 el enum <code>java.time.Month</code> que representa los meses del a\u00f1o. Tiene los mismos m\u00e9todos que los d\u00edas de la semana:</p> <pre><code>public class EnumMonths {\npublic void show(){\nLocale locale = Locale.of(\"es\", \"ES\");\nfor (Month day : Month.values()) {\nSystem.out.printf(\"Mes completo: %s\\n\", day.getDisplayName(TextStyle.FULL, locale));\nSystem.out.printf(\"Letra del mes: %s\\n\", day.getDisplayName(TextStyle.NARROW, locale));\nSystem.out.printf(\"Mes abreviado: %s\\n\", day.getDisplayName(TextStyle.SHORT, locale));\n}\n}\npublic static void main(String[] args) {\nnew EnumMonths().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-3/","title":"3 Fechas","text":""},{"location":"bloque_ii/tema_9/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Para poder trabajar con fechas, en Java se usa la clase <code>LocalDate</code>, la cu\u00e1l solo maneja la fecha (no la hora), a diferencia de la clase <code>Date</code> del paquete <code>java.util</code>.</p> <p>Para poder crear una instancia de dicha clase, esta API nos proporciona los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>now()</code>: Obtiene la fecha actual.</li> <li><code>of()</code>: Recibe tres par\u00e1metros, el a\u00f1o, el mes (1 al 12) y el d\u00eda, respectivamente de tipo entero. Existe una versi\u00f3n sobrecargada, que en lugar de recibir el mes como un entero lo recibe como tipo enum Month. Si alg\u00fan dato no es correcto, por ejemplo, se espec\u00edfica un mes err\u00f3neo, o un d\u00eda del mes incorrecto, se lanzar\u00e1 la excepci\u00f3n <code>DateTimeException</code>.</li> <li><code>ofEpochDay()</code>: Recibe un par\u00e1metro de tipo long y crea una fecha a partir de milisegundos, partiendo desde el 01 de Enero de 1970.</li> <li><code>ofYearDay()</code>: Recibe dos par\u00e1metros, el a\u00f1o y el d\u00eda del a\u00f1o de tipo entero. Crear\u00e1 la fecha a partir de ambos datos.</li> </ul> <pre><code>LocalDate today = LocalDate.now();\nLocalDate date1 = LocalDate.of(2022, 5, 24); // 24 de Mayo de 2022\nLocalDate date2 = LocalDate.of(2022, Month.MAY; 24);\nLocalDate date3 = LocalDate.of(2022, 2, 30); // DateTimeException\nLocalDate date4 = LocalDate.ofEpochDay(19527); // 2023-06-19\nLocalDate date5 = LocalDate.ofYearDay(2023, 115); // 2023-04-25\n</code></pre> <p>Algunos m\u00e9todos importantes para trabajar con fechas:</p> <ul> <li><code>getDayOfMonth()</code>. Devuelve el d\u00eda del mes de la fecha indicada.</li> <li><code>getDayOfWeek()</code>. Devuelve una instancia del enum <code>DayOfWeek</code> con el d\u00eda de la semana.</li> <li><code>getDayOfYear()</code>. Devuelve el d\u00eda del a\u00f1o.</li> <li><code>getMonth()</code>. Devuelve una instancia del enum <code>Month</code> con el mes al cual pertenece la fecha.</li> <li><code>getMontValue()</code>. Devuelve un n\u00famero entero (1-12) representativo del mes.</li> <li><code>getYear()</code>. Devuelve el a\u00f1o de una fecha.</li> <li><code>isLeapYear()</code>. Comprueba si la instancia fecha es un a\u00f1o bisiesto.</li> <li><code>lengthOfMonth()</code>. Devuelve el n\u00famero de d\u00edas que tiene el mes.</li> <li><code>lengthOfYear()</code>. Devuelve el n\u00famero de d\u00edas que tiene el a\u00f1o.</li> </ul> <p>Adem\u00e1s de estos m\u00e9todos, tambi\u00e9n posee m\u00e9todos para a\u00f1adir d\u00edas (<code>plusDays()</code>), meses (<code>plusMonths()</code>), semanas (<code>plusWeeks()</code>) y a\u00f1os (<code>plusYears()</code>), y los mismos para restar(<code>minusDays()</code>, <code>minusMOnths()</code>, <code>minusWeeks()</code>, <code>minusYears()</code>, <code>minusDays()</code>)</p> <p>Veamos un ejemplo:</p> <pre><code>public class LocalDateExample {\npublic void show(){\nLocalDate date = LocalDate.now();\ninfoDate(date);\nLocalDate datePlusTenDays = date.plusDays(10);\ninfoDate(datePlusTenDays);\nLocalDate datePlusTwoMonths = date.plusMonths(2);\ninfoDate(datePlusTwoMonths);\nLocalDate dateMinusOneYear = date.minusYears(1);\ninfoDate(dateMinusOneYear);\n}\nprivate void infoDate(LocalDate date) {\nSystem.out.printf(\"La fecha es: %s\\n- D\u00eda de la semana: %s\\n- Mes: %s\\n- A\u00f1o: %d\\n- \u00bfEs a\u00f1o bisiesto?: %s\\n\",\ndate, date.getDayOfWeek(), date.getMonth(), date.getYear(), date.isLeapYear() ? \"S\u00ed\" : \"No\");\n}\npublic static void main(String[] args) {\nnew LocalDateExample().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-3/#yearmonth","title":"YearMonth","text":"<p>Es una clase que representa el mes especifico de un a\u00f1o. Se puede instanciar haciendo uso de los m\u00e9todos est\u00e1ticos <code>now()</code> y <code>of(year, month)</code>, siendo month un entero o un tipo enum <code>Month</code>.</p> <p>Con el m\u00e9todo <code>lengthOfMonth()</code> obtenemos el n\u00famero de d\u00edas que tiene ese mes en ese a\u00f1o.</p> <pre><code>YearMonth year = YearMonth.of(2022, 12); System.out.println(year.lengthOfMonth()); // 31\n</code></pre> <p>Tiene m\u00e9todos parecidos a los vistos en el punto anterior, para a\u00f1adir y restar meses y a\u00f1os y para saber si el a\u00f1o es bisiesto. Adem\u00e1s tiene lo siguientes m\u00e9todos:</p> <ul> <li><code>isAfter(YearMonth other)</code>: Comprueba si la fecha instanciada es posterior a other.</li> <li><code>isBefore(YearMonth other)</code>: Comprueba si la fecha instanciada es anterior a other.</li> <li><code>isValidDay(int day)</code>: Comprueba si el d\u00eda especificado es un d\u00eda v\u00e1lido dentro de ese mes y a\u00f1o. Por ejemplo, el d\u00eda 29 s\u00ed ser\u00eda un d\u00eda v\u00e1lido para el mes Marzo del 2023 pero no ser\u00eda v\u00e1lido para el 29 de Febrero de 2023.</li> <li><code>withMoth()</code>. Devuelve una copia del a\u00f1o y del mes, pero con el mes alterado.</li> <li><code>withYear()</code>. Devuelve una copia del a\u00f1o y del mes, pero con el a\u00f1o alterado.</li> <li><code>atDay(int day)</code>. Devuelve un objeto de tipo <code>LocalDate</code> con el d\u00eda especificado, pudiendo lanzar un <code>DateTimeException</code> si el d\u00eda no es v\u00e1lido para ese mes y ese a\u00f1o.</li> <li><code>atEndOfMonth</code>: Devuelve un objeto de tipo <code>LocalDate</code>con el d\u00eda en el final del mes.</li> </ul> <p>Veamos un ejemplo haciendo uso de estos m\u00e9todos:</p> <pre><code>public class YearMonthExample {\npublic void show(){\nYearMonth ym1 = YearMonth.now();\nYearMonth ym2 = YearMonth.of(2023, 5);\nYearMonth ym3 = ym1.withMonth(10);\nSystem.out.println(ym1.isAfter(ym2));\nSystem.out.println(ym1.isValidDay(31));\nSystem.out.println(ym3.atDay(10));\nSystem.out.println(ym3.atEndOfMonth());\n}\npublic static void main(String[] args) {\nnew YearMonthExample().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-3/#monthday","title":"MonthDay","text":"<p>La clase <code>MonthDay</code> representa un d\u00eda de un mes en particular. Para construir una objeto de dicha clase tenemos los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>of(int month, int day)</code>: Recibe el mes y el d\u00eda del mes de los cuales se quiere construir el objeto. Tiene un versi\u00f3n sobrecargada, que en vez de recibir el mes en formato entero lo recibe como un enum Month.</li> <li><code>now()</code>: Crea una instancia de la clase con el mes y el d\u00eda actual.</li> </ul> <p>La mayor\u00eda de m\u00e9todos son parecidos a los vistos anteriormente, pero adem\u00e1s a\u00f1ade:</p> <ul> <li><code>isValidYear()</code>. Comprueba si ese d\u00eda en ese mes concreto es v\u00e1lido para cierto a\u00f1o. Por ejemplo, si pasamos como par\u00e1metro 2023, y validamos si es correcto el 29 de Febrero, retornar\u00eda false, como dicho d\u00eda en dicho mes y en dicho a\u00f1o, el mes de Febrero no tiene 29 d\u00edas.</li> <li><code>atYear()</code>: Crea una instancia de la clase <code>LocalDate</code> con el a\u00f1o indicado. Si la fecha no es v\u00e1lida, lanzar\u00e1 una excepci\u00f3n de tipo <code>DateTimeException</code>.</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>public class MonthDayExample {\npublic void show(){\nMonthDay md1 = MonthDay.now();\nMonthDay md2 = md1.withDayOfMonth(20);\nSystem.out.println(md1.isBefore(md2));\nSystem.out.println(MonthDay.of(2, 29).isValidYear(2024));\nSystem.out.println(md1.atYear(2020));\n}\npublic static void main(String[] args) {\nnew MonthDayExample().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-3/#year","title":"Year","text":"<p>La clase <code>Year</code> nos permite obtener informaci\u00f3n de un a\u00f1o especifico sin importar ni el d\u00eda ni el mes. Para construir un objeto de dicha clase se usa los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>now()</code>. Crea una instancia con el a\u00f1o actual.</li> <li><code>of(int year)</code>: Crea una instancia con el a\u00f1o indicado.</li> </ul> <p>Alguno de sus m\u00e9todos son:</p> <ul> <li><code>atDay(int dayOfYear)</code>: Devuelve un <code>LocalDate</code> con el d\u00eda y el mes obtenido del dayOfYear.</li> <li><code>atMonth(int month)</code>: Devuelve un <code>YearMonth</code> con el mes indicado. Tiene una versi\u00f3n sobrecargada que recibe una instancia del enum <code>Month</code>.</li> <li><code>athMonthDay(MonthDay monthDay)</code>: Devuelve un <code>LocalDate</code> con el d\u00eda y el mes indicados.</li> <li><code>getValue()</code>. Retorna el valor entero del a\u00f1o.</li> <li><code>isLeap()</code>. Comprueba si el a\u00f1o es bisiesto. Adem\u00e1s tiene una versi\u00f3n est\u00e1tica <code>isLeap(int year)</code> para comprobar si el a\u00f1o indicado es bisiesto sin necesidad de crear una instancia de la clase <code>Year</code>.</li> <li><code>length()</code>. Devuelve el n\u00famero de d\u00edas que tiene ese a\u00f1o.</li> </ul> <p>Adem\u00e1s tiene m\u00e9todos similares a las clases anteriores. Veamos un ejemplo:</p> <pre><code>public class YearExample {\npublic void show(){\nYear year1 = Year.now();\nYear year2 = Year.of(2023);\nSystem.out.println(year1.isAfter(year2));\nSystem.out.println(year1.atDay(123));\nSystem.out.println(year1.atMonth(Month.APRIL));\nSystem.out.println(\"A\u00f1o en entero: \" + year1.getValue());\nSystem.out.println(\"N\u00famero de d\u00edas: \" + year1.length());\nSystem.out.println(Year.isLeap(2024));\n}\npublic static void main(String[] args) {\nnew YearExample().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-4/","title":"Horas","text":""},{"location":"bloque_ii/tema_9/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta API, las horas se pueden manejar de forma independiente a la fecha, con la clase <code>LocalTime</code>. Tiene un funcionamiento bastante similar a la clase <code>LocalDate</code>.</p> <p>Una de las utilidades de esta clase es la capacidad de representar el tiempo de un d\u00eda, como por ejemplo, la hora de inicio de una pel\u00edcula, la hora de apertura de una biblioteca, etc. Hacen referencia a un d\u00eda cualquiera, sin indicar una fecha concreta.</p> <pre><code>public class LocalTimeExample {\npublic void show(){\nLocalTime time = LocalTime.now();\nSystem.out.println(time);\ntime = time.plusHours(10);\nSystem.out.println(time);\ntime = time.minusMinutes(20);\nSystem.out.println(time);\n}\npublic static void main(String[] args) {\nnew LocalTimeExample().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-4/#localdatetime","title":"LocalDateTime","text":"<p>Por el contrario, si se desea manejar el tiempo de una fecha concreta, la API nos proporciona la clase <code>LocalDateTime</code>, que representa la fecha y la hora y es una combinaci\u00f3n de LocalDate y LocalTime.</p> <p>Tiene m\u00e9todos muy parecidos de las dos clases que combina y adem\u00e1s tiene m\u00e9todos est\u00e1ticos para construir una instancia de la clase:</p> <ul> <li><code>of(int year, int month, int day, int hour, int minute, int second)</code>. Crea una instancia de la clase con los datos proporcionados. Adem\u00e1s tiene una sobrecarga donde no recibe los segundos, otra sobrecarga donde tambi\u00e9n recibe los nano segundos, adem\u00e1s de las sobrecargas donde recibe un valor del enum <code>Month</code>.</li> <li><code>of(LocalDate date, LocalTime time)</code>. Crea una instancia de la clase combinando el date y el time indicados.</li> <li><code>now()</code>. Crea una instancia de la clase con la fecha y hora actual.</li> </ul> <p>Veamos un ejemplo con el uso de estos constructores y algunos de sus m\u00e9todos</p> <pre><code>public class LocalDateTimeExample {\nprivate void show() {\nLocalDate date = LocalDate.now();\nLocalTime time = LocalTime.now();\nLocalDateTime dateTime = LocalDateTime.of(date, time);\nSystem.out.println(dateTime.plusHours(10));\nSystem.out.println(dateTime.minusMonths(12));\nSystem.out.println(dateTime.toLocalDate());\n}\npublic static void main(String[] args) {\nnew LocalDateTimeExample().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-5/","title":"Formateo de fechas","text":""},{"location":"bloque_ii/tema_9/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>La API de Java nos proporciona clase clase para formatear las fechas y las horas, <code>DateTimeFormatter</code>, al igual que su antecesora est\u00e1 compuesta de patrones de cadena que representas diferentes s\u00edmbolos relacionados con las fechas:</p> <ul> <li>y, nos permite acceder al a\u00f1o en formato de cuatro o dos d\u00edgitos (2014 o 14).</li> <li>D, nos permite obtener el n\u00famero de d\u00eda del a\u00f1o (225).</li> <li>d, al contrario del anterior nos devuelve el n\u00famero del d\u00eda del mes en cuesti\u00f3n (27).</li> <li>L, nos ayuda a obtener el mes del a\u00f1o en forma num\u00e9rica, M nos da el mes en texto.</li> <li>H, nos da la hora.</li> <li>s, nos da los segundos.</li> <li>m, nos permite obtener los minutos.</li> <li>a, nos da el am o pm de la hora.</li> <li>z, nos permite acceder al nombre de la zona horaria.</li> </ul> <p>Info</p> <p>Para ver m\u00e1s patrones puede visitar la API: https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/time/format/DateTimeFormatter.html</p> <p>Para construir una instancia de esta clase, existe un m\u00e9todo est\u00e1tico <code>ofPattern(str)</code> que recibe una cadena con los patronos indicados. Existe una versi\u00f3n sobrecargada que adem\u00e1s recibe un <code>Locale</code> para devolver la fecha formateado al idioma deseado.</p> <p>Si el m\u00e9todo recibe un patr\u00f3n err\u00f3neo lanzar\u00e1 la excepci\u00f3n <code>IllegalArgumentException</code></p> <pre><code>DateTimeFormatter format = DateTimeFormatter.ofPattern(\"dd/M/yyyy\", Locale.of(\"es\", \"ES\"));\n</code></pre>"},{"location":"bloque_ii/tema_9/page-5/#parsear-una-fecha-a-cadena","title":"Parsear una fecha a cadena","text":"<p>Las clases LocalDate, LocalTime, LocalDateTime, YearMonth, MonthDay, y el resto de clases referidas a las fechas tienen un m\u00e9todo <code>format()</code> que recibe un objeto de la clase <code>DateTimeFormatter</code> para formatear la fecha con dicho formato. Adem\u00e1s la clase <code>DateTimeFormatter</code> tiene el mismo m\u00e9todo, pero recibe un objeto fecha.</p> <p>Veamos un ejemplo:</p> <pre><code>public class DateToString {\npublic void show(){\nLocalDateTime date = LocalDateTime.now();\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd/M/yy\");\nSystem.out.println(date.format(formatter));\n}\npublic static void main(String[] args) {\nnew DateToString().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-5/#parsear-una-cadena-a-una-fecha","title":"Parsear una cadena a una fecha","text":"<p>Las clases de manejo de fecha, tienen un m\u00e9todo est\u00e1tico llamado <code>parse</code>, que recibe la fecha en formato cadena, y un formato (en caso de no recibirlo, tiene una versi\u00f3n sobrecargada donde obtiene el formato est\u00e1ndar) devolviendo as\u00ed un objeto de tipo fecha. En caso de que la cadena no cumpla con el patr\u00f3n se lanzar\u00e1 una excepci\u00f3n <code>DateTimeParseException</code></p> <pre><code>public class StringToDate {\npublic void show(){\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd-LL-yyyy\");\nSystem.out.println(LocalDate.parse(\"20-03-2023\", formatter));\n}\npublic static void main(String[] args) {\nnew StringToDate().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-6/","title":"Otras clase de manejo de fechas","text":""},{"location":"bloque_ii/tema_9/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>La API de Java, a parte de todas las clases ya vistas, contiene otras clases para el manejo de fechas y horas:</p> <ul> <li><code>Instant</code>: Esta clase modela un solo punto instant\u00e1neo en la l\u00ednea de tiempo. Esto podr\u00eda usarse para registrar marcas de tiempo de eventos en la aplicaci\u00f3n.</li> <li><code>Period</code>: Una cantidad de tiempo basada en fechas en el sistema de calendario ISO-8601, como '2 a\u00f1os, 3 meses y 4 d\u00edas'. Esta clase modela una cantidad o cantidad de tiempo en t\u00e9rminos de a\u00f1os, meses y d\u00edas.</li> <li><code>ZonedDateTime</code> es una representaci\u00f3n inmutable de una fecha y hora con una zona horaria. Esta clase almacena todos los campos de fecha y hora, con una precisi\u00f3n de nanosegundos, y una zona horaria, con un desplazamiento de zona utilizado para manejar fechas y horas locales ambiguas. Por ejemplo, el valor \"2 de octubre de 2007 a las 13:45.30.123456789 +02:00 en la zona horaria de Europa/Par\u00eds\" se puede almacenar en un archivo ZonedDateTime.</li> </ul>"},{"location":"bloque_ii/tema_9/page-6/#chronounit","title":"ChronoUnit","text":"<p>El enum <code>ChronoUnit</code> contiene unidades para fechas y horas, como por ejemplo, DAYS, MONTHS, WEEKS, YEARS, HOURS, MINUTES, SECONDS, etc. Representa una unidad de tiempo y tiene m\u00e9todo que nos permite manejar fechas como <code>between</code> que te devuelve la distancia entre dos fechas. Veamos un ejemplo:</p> <pre><code>public class ChronosUnitExample {\nprivate void show() {\nLocalDateTime today = LocalDateTime.now();\nLocalDateTime someDay = LocalDateTime.of(2022, 6, 6, 0, 0, 0);\nfor (ChronoUnit chronoUnit: ChronoUnit.values()) {\nSystem.out.printf(\"La diferencia entre %s y %s en %s: %d\\n\", today, someDay, chronoUnit,\nchronoUnit.between(today, someDay));\n}\n}\npublic static void main(String[] args) {\nnew ChronosUnitExample().show();\n}\n}\n</code></pre>"},{"location":"bloque_ii/tema_9/page-7/","title":"Ejercicios","text":"Ejercicio 1 <p>Escribir un m\u00e9todo que reciba una fecha y devuelva el d\u00eda de la semana que corresponde para esta fecha.</p> Ejercicio 2 <p>Realiza un m\u00e9todo que reciba una hora y devuelva los nanosegundos. Comprueba que ta el mismo resultado que el m\u00e9todo toNanoOfDay de la clase LocalTime.</p> Ejercicio 3 <p>Realiza un m\u00e9todo que reciba una fecha de nacimiento de devuelva la edad.</p> Ejercicio 4 <p>Realiza una clase para convertir fechas que tenga los siguientes m\u00e9todos. Haz un programa para probarlo:</p> <ul> <li><code>String europeaToAmerican(String)</code>: este m\u00e9todo convierte una fecha en formato europeo (dia/mes/a\u00f1o) a formato americano (mes/dia/a\u00f1o).</li> <li><code>String americanToEuropea(string)</code>: este m\u00e9todo realiza el paso contrario, convierte fechas de formato americano a formato europeo.</li> </ul> Ejercicio 5 <p>Realiza un programa que muestre la fecha del sistema de la siguiente manera: Hoy es s\u00e1bado 12-marzo-2011 a las 10:22:13</p> Ejercicio 6 <p>Realiza un m\u00e9todo que reciba un mes y un d\u00eda correspondiente a este a\u00f1o y devuelva el n\u00famero de d\u00edas que han pasado desde el 1 de Enero de este a\u00f1o hasta dicho d\u00eda.</p> Ejercicio 7 <p>Realiza un m\u00e9todo de decodifique fechas del siglo XXI. El dato es un entero comprendido entre 10100 y 311299. El resultado es una secuencia de caracteres: n\u00famero del d\u00eda dentro del mes, del mes dentro del a\u00f1o y del a\u00f1o dentro del siglo. Por ejemplo, para el dato 30485, el resultado es el texto 3-4-2085.</p> Ejercicio 8 <p>Realiza un m\u00e9todo que reciba d\u00eda, mes y a\u00f1o y devuelva una cadena con la fecha. Ejemplo:</p> <p>D\u00eda: Jueves Mes: Mayo A\u00f1o: 2012 El m\u00e9todo devolver\u00e1 03/05/2012 ya que coge el primer jueves de mayo.</p> Ejercicio 9 <p>Realiza un m\u00e9todo que reciba una cadena con una fecha y devuelva si dicha fecha es correcta.</p> Ejercicio 10 <p>Realiza un m\u00e9todo que reciba un a\u00f1o y devuelva si es bisiesto o no. No se puede usar el m\u00e9todo isLeap().</p> Ejercicio 11 <p>Realiza un m\u00e9todo que dada dos fechas te devuelva la diferencia de ambas. Utilizar una de las clases indicadas (investigar API).</p> Ejercicio 12 <p>Realiza un m\u00e9todo que reciba un a\u00f1o y un mes y dibuje el calendario de ese mes dentro de ese a\u00f1o con el siguiente formato:</p> <pre><code>      Jun-23\nL  M  X  J  V  S  D\n1  2  3  4\n5  6  7  8  9 10 11\n12 13 14 15 16 17 18\n19 20 21 22 23 24 25\n26 27 28 29 30\n</code></pre> <p>Realiza una nueva version donde reciba solamente el a\u00f1o y muestre el calendario de ese a\u00f1o. Por \u00faltimo realiza otra versi\u00f3n, donde no reciba ning\u00fan par\u00e1metro y muestre el calendario del a\u00f1o actual, marcando el d\u00eda actual.</p>"},{"location":"bloque_ii/tema_9/page-8/","title":"Proyecto","text":"<p>En este proyecto se va a realizar cambios en el proyecto conocido como common.</p> <p>Para ello se va a a\u00f1adir los siguientes m\u00e9todos a la clase ConsoleInput:</p> <ul> <li>readDate(): Este m\u00e9todo retornar\u00e1 una fecha v\u00e1lida le\u00edda por teclado con el formato por defecto.</li> <li>readTime(): Este m\u00e9todo retornar\u00e1 una hora v\u00e1lida le\u00edda por teclado con el formato por defecto.</li> <li>readDateTime(): Este m\u00e9todo retornar\u00e1 una fecha y hora v\u00e1lida le\u00edda por teclado con el formato por defecto.</li> </ul> <p>Se sobrescribir\u00e1n los m\u00e9todos anteriores para que adem\u00e1s reciban un par\u00e1metro con el formato con el que se desea leer.</p> <p>Adem\u00e1s, se va a crear la clase Dates en la cu\u00e1l se llevaran a cabo atributos y m\u00e9todos de utilidad (est\u00e1ticos) para trabajar con fechas de la API Java 8.</p> <p>Se crear\u00e1n varios atributos con los patrones de fechas siguientes, (teniendo en cuenta que coger\u00e1 el idioma por defecto del ordenador)</p> <ul> <li>FULL_DATE: Tuesday, 20 June 2023, 12:40:15</li> <li>DATE: Tue, 20 June 2023, 12:40</li> <li>SHORT_DATE: 20 June 2023, 12:40</li> <li>NUMBER_DATE: 20/06/2023, 12:40</li> <li>ONLY_FULL_DATE: Tuesday, 20 June 2023</li> <li>ONLY_DATE: Tue, 20 June 2023</li> <li>ONLY_SHORT_DATE: 20 June 2023</li> <li>ONLY_NUMBER_DATE: 20/06/2023</li> <li>ONLY_TIME: 12:40</li> </ul> <p>Info</p> <p>Puedes a\u00f1adir todos los patrones que consideres oportunos si no est\u00e1n en la lista anterior.</p> <p>Se crear\u00e1n, tambi\u00e9n, los siguientes m\u00e9todos:</p> <ul> <li>betweenDay(date1, date2): Calcula la diferencia en d\u00edas de dos fechas.</li> <li>betweenMonth(date1, date2): Calcula la diferencia en meses de dos fechas.</li> <li>betweenYear(date1, date2): Calcula la diferencia en a\u00f1os de dos fechas.</li> <li>betweenHours(date1, date2): Calcula la diferencia en horas de dos fechas.</li> <li>betweenMinutes(date1, date2): Calcula la diferencia en minutos de dos fechas.</li> <li>betweenSeconds(date1, date2): Calcula la diferencia en segundos de dos fechas.</li> <li>betweenDecades(date1, date2): Calcula la diferencia en d\u00e9cadas de dos fechas.</li> <li>betweenCenturies(date1, date2): Calcula la diferencia en siglos de dos fechas.</li> <li>betweenMillennia(date1, date2): Calcula la diferencia en milenios de dos fechas.</li> <li>between(date1, date2): Calcula el per\u00edodo de tiempo entre dos fechas.</li> <li>format(date): Devuelve una cadena formateada por el formato por defecto.</li> <li>isValidDate(string): Comprueba si la cadena cumple con un formato de fecha.</li> <li>getFirstDate(dayOfWeek, month, year): Devuelve una fecha con el primer un d\u00eda de la semana, mes y a\u00f1o.</li> <li>getLastDate(dayOfWeek, month, year): Devuelve una fecha con el \u00faltimo d\u00eda de la semana, mes y a\u00f1o.</li> <li>calendar(month, year): Muestra un calendario de la mes y a\u00f1o indicado.</li> <li>calendar(month, year, date): Muestra un calendario del mes y del a\u00f1o indicado con la fecha se\u00f1alizada. Si la fecha no coincide con el mes y a\u00f1o indicado, no se se\u00f1alizar\u00e1.</li> <li>calendar(year): Muestra un calendario del a\u00f1o especificado.</li> <li>calendar(year, date): Muestra un calendario del a\u00f1o especificado con la fecha se\u00f1alada. Si la fecha no coincide con el  a\u00f1o indicado, no se se\u00f1alizar\u00e1.</li> <li>calendar(date): Muestra un calendario del a\u00f1o actual con la fecha se\u00f1alada. Si la fecha no coincide con el a\u00f1o actual no se se\u00f1alizar\u00e1.</li> <li>calendar(): Muestra un calendario del a\u00f1o actual con la fecha de hoy se\u00f1alada.</li> </ul> <p>Adem\u00e1s de todos estos m\u00e9todos indicados, se a\u00f1adir\u00e1 un m\u00e9todo a la clase String, toDate(string), que devuelve una fecha dado una cadena.</p> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>NO se realizar\u00e1 una versi\u00f3n sobre el proyecto 6, sino que se realizar\u00e1 un copia de dicho proyecto en esta versi\u00f3n</li> <li>Se mantendr\u00e1 el paquete principal llamado <code>com.NOMBRE.common</code> donde nombre ser\u00e1 el nombre del alumno y common el nombre del proyecto.</li> <li>Se deber\u00e1n sobrescribir los m\u00e9todos necesarios para que reciban los diferentes tipos de fechas que hay.</li> <li>Se crear\u00e1 una clase Main, donde se ponga en pr\u00e1ctica los usos de la librer\u00eda y se valorar\u00e1 la complejidad de dicho Main.</li> <li>Se deber\u00e1n respetar el nombre de las funciones.</li> <li>El nombre del resto de funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre <code>pr09java-NOMBRE-dates</code> siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_iii/tema_11/page-1/","title":"1 Introducci\u00f3n a las colecciones","text":""},{"location":"bloque_iii/tema_11/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Una colecci\u00f3n representa un grupo de objetos. Estos objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almac\u00e9n donde poder guardarlos.</p> <p>Las colecciones son estructuras de datos con la peculiaridad de que son estructuras din\u00e1micas. Eso quiere decir que pueden aumentar o disminuir su tama\u00f1o dependiendo de los elementos que almacenan, lo que suponen una mejora respecto a las estructuras de datos est\u00e1ticas cuyo tama\u00f1o se define en su creaci\u00f3n y no se puede alterar en tiempo de ejecuci\u00f3n, como por ejemplo, los arrays.</p> <p>El API de Java nos proporciona en el paquete <code>java.util</code> el framework de las colecciones, que nos permite utilizar diferentes estructuras de datos para almacenar y recuperar objetos de cualquier clase. Java tiene desde la versi\u00f3n 2 todo un juego de clases e interfaces para guardar colecciones de objetos donde todas las entidades conceptuales est\u00e1n representadas por interfaces y las clases se usan para proveer implementaciones de esas interfaces. Estas clases e interfaces est\u00e1n estructuradas en una jerarqu\u00eda.</p> <p>Pero \u00bfqu\u00e9 podemos almacenar dentro de una colecci\u00f3n? Podemos almacenar cualquier objeto que herede de la clase <code>Object</code>. Pero esto presenta ciertos inconvenientes:</p> <ul> <li>Podr\u00edamos tener una colecci\u00f3n con objetos completamente distintos, lo que puede dar lugar a problemas ya que en todo momento deber\u00edamos saber qu\u00e9 tipo de objeto y qu\u00e9 posici\u00f3n de la colecci\u00f3n se encuentra el elementos con el que queremos trabajar, de otro modo podr\u00edamos tener incongruencias en el c\u00f3digo e incluso hacer saltar una excepci\u00f3n.</li> <li>Otro inconveniente es que tendr\u00edamos que hacer continuos castings para poder trabajar con los elementos de la colecci\u00f3n, lo cual resulta tedioso y poco productivo.</li> </ul> <p>Veamos un ejemplo para obtener la suma de los valores almacenados en una lista:</p> <pre><code>int total = 0;\nArrayList numbers = new ArrayList(); // Creaci\u00f3n de la lista\nnumbers.add(1); // Se a\u00f1ade el elemento 1 a la lista utilizando el m\u00e9todo add\nnumbers.add(2);\nnumbers.add(3);\nfor(int i = 0; i &lt; numbers.size(); i++){\n// No vemos obligados a hacer cast, dado que numbers.get(i) retorna un Object:\ntotal += (int) numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>Como vemos en el ejemplo anterior, nos vemos obligados a hacer expl\u00edcitamente un cast cuando obtenemos un elemento de la lista, dado que la lista internamente trabaja con elementos de la clase <code>Object</code>. No hay ning\u00fan contrato que permita a la clase <code>ArrayList</code> saber qu\u00e9 tipo de datos queremos que trabaje.</p> <p>Adem\u00e1s, es posible a\u00f1adir elementos de distinto tipo a la lista, con el agravante de que m\u00e1s adelante cuando se intenta acceder al elemento y se hace cast sobre \u00e9l se producir\u00e1 un error en tiempo de ejecuci\u00f3n. As\u00ed, si modificamos el ejemplo anterior de la siguiente manera:</p> <pre><code>int total = 0;\nArrayList numbers = new ArrayList(); numbers.add(1);\nnumbers.add(2);\nnumbers.add(\"Antonio\");\nfor(int i = 0; i &lt; numbers.size(); i++){\n// Esta l\u00ednea lanza una excepci\u00f3n cuando\n// se trata de convertir a entero el elemento \"Antonio\",\ntotal += (int) numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>As\u00ed pues, para resolver este problema, a partir de la versi\u00f3n 5 de Java empezaron a utilizar los gen\u00e9ricos. Los gen\u00e9ricos nos permiten establecer un tipo con el que vamos a trabajar en esa colecci\u00f3n, de esa manera podemos evitar los problemas mencionados anteriormente.</p> <p>As\u00ed el ejemplo anterior podr\u00edamos modificarlo de la siguiente manera:</p> <pre><code>int total = 0;\nArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); numbers.add(1);\nnumbers.add(2);\n//Esta l\u00ednea da un error de compilaci\u00f3n, dado que el compilador\n// detecta que estamos intentado a\u00f1adir una cadena a la lista de enteros:\nnumbers.add(\"Antonio\");\nfor(int i = 0; i &lt; numbers.size(); i++){\n// Ya no es necesario hacer un cast expl\u00edcito, dado que el compilador\n// lo har\u00e1 internamente por nosotros, al haberle informado de que quer\u00edamos\n// trabajar con una lista de enteros\ntotal += numbers.get(i);\n}\nSystem.out.printf(\"Total: %d\\n\", total);\n</code></pre> <p>Como vemos en el ejemplo anterior, gracias a la informaci\u00f3n que le suministramos al compilador sobre el tipo de lista con el que queremos trabajar, en este caso <code>Integer</code>, el compilador es capaz de detectar en tiempo de compilaci\u00f3n que no deber\u00eda ser posible a\u00f1adir una cadena a la lista, y adem\u00e1s nos evita tener que hacer expl\u00edcitamente el cast a entero cuando obtenemos los elementos de la lista, porque ya lo puede hacer \u00e9l internamente por nosotros.</p> <p>Lo que se use en un gen\u00e9rico debe ser un objeto, por lo tanto, los gen\u00e9ricos no funcionan con datos primitivos. Para resolver esta situaci\u00f3n, la API de Java incorpora las clases envoltorio (wrapper class) que no son m\u00e1s que dotar a los datos primitivos con un envoltorio que permita tratarlos como objetos. Las clases envoltorios proporcionan m\u00e9todos de utilidad para la manipulaci\u00f3n de datos primitivos (conversiones de / hacia datos primitivos, conversiones a String, etc).</p>"},{"location":"bloque_iii/tema_11/page-2/","title":"2 ArrayList","text":""},{"location":"bloque_iii/tema_11/page-2/#interfaz-collection","title":"Interfaz Collection","text":"<p>Es la interfaz ra\u00edz de la jerarqu\u00eda de las colecciones. Java no proporciona ninguna implementaci\u00f3n directa de esta interfaz, sino que proporciona implementaciones de sub-interfaces m\u00e1s espec\u00edficas como Set y List. Esta interfaz se utiliza normalmente para pasar colecciones y manipularlas cuando se desea la m\u00e1xima generalidad.</p> <p>Veamos algunos de los m\u00e9todos que podemos observar en la API</p> <ul> <li><code>boolean add(E e)</code>: a\u00f1ade el elemento e a la colecci\u00f3n.</li> <li><code>boolean addAll(Collection &lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de la colecci\u00f3n c.</li> <li><code>void clear()</code>: elimina todos los elementos de la colecci\u00f3n.</li> <li><code>boolean contains(Object o)</code>: comprueba si el elemento o est\u00e1 en la colecci\u00f3n.</li> <li>boolean containsAll(Collection&lt;?&gt; c) : comprueba si todos los elementos de c est\u00e1n en la colecci\u00f3n.</li> <li><code>boolean isEmpty()</code>: comprueba si la colecci\u00f3n est\u00e1 vac\u00eda.</li> <li><code>boolean remove(Object o)</code>: elimina de la colecci\u00f3n el elemento o.</li> <li><code>boolean removeAll(Collection&lt;?&gt; c)</code>: elimina de la colecci\u00f3n todos los elementos de c.</li> <li><code>boolean retainAll(Collection&lt;?&gt; c)</code>: elimina de la colecci\u00f3n todos los elementos exceptos los que est\u00e1n en c, es decir, obtiene la intersecci\u00f3n.</li> <li><code>int size()</code>: devuelve el tama\u00f1o de la colecci\u00f3n.</li> </ul>"},{"location":"bloque_iii/tema_11/page-2/#interfaz-list","title":"Interfaz List","text":"<p>Esta interfaz es una sub-interfaz o interfaz hija de Collection, por lo tanto, tiene todos los m\u00e9todos de Collection y adem\u00e1s a\u00f1ade los suyos propios.</p> <p>Este tipo de colecci\u00f3n se refiere a listas en las que los elementos de la colecci\u00f3n tienen un orden, es decir, existe una secuencia de elementos. Cada elemento tiene un \u00edndice o posici\u00f3n. El primer elemento ocupa la posici\u00f3n 0. La interfaz List s\u00ed admite elementos duplicados.</p> <p>Veamos algunos de los m\u00e9todos que podemos observar en la API:</p> <ul> <li><code>void add(int index, E element)</code>: inserta el elemento E en la posici\u00f3n index.</li> <li><code>boolean add(E e)</code>: a\u00f1ade el elemento e al final de la lista.</li> <li><code>boolean addAll(int index, Collection &lt;? extends E&gt; c)</code>: inserta todos los elementos de c en la posici\u00f3n index.</li> <li><code>boolean addAll(Collection &lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de c al final de la lista.</li> <li><code>E get(int index)</code>: devuelve el elemento de la posici\u00f3n index.</li> <li><code>int indexOf(Object o)</code>: devuelve el \u00edndice de la primera ocurrencia del elemento o en la lista, o -1 si la lista no contiene el elemento.</li> <li><code>int lastIndexOf(Object o)</code>: devuelve el \u00edndice de la \u00faltima ocurrencia del elemento o en la lista, o -1 si la lista no contiene el elemento.</li> <li><code>E remove(int index)</code>: elimina el elemento que se encuentra en la posici\u00f3n index. E set(int index, E element): reemplaza el elemento que se encuentra en index por el elemento element.</li> <li><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code>: devuelve la sub-lista comprendida entre las posiciones fromIndex incluida y toIndex excluida.</li> </ul> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java para la interfaz List, como por ejemplo, ArrayList.</p>"},{"location":"bloque_iii/tema_11/page-2/#la-clase-arraylist","title":"La clase ArrayList","text":"<p>Se basa en un array redimensionable que aumenta su tama\u00f1o seg\u00fan crece la colecci\u00f3n de elementos. Lo bueno es que el tiempo de acceso a un elemento en particular es \u00ednfimo. Lo malo es que si queremos eliminar un elemento del principio o del medio, la clase debe mover todos los que le siguen a la posici\u00f3n anterior, para tapar el agujero que deja el elemento removido. Esto hace que sacar elementos del medio o del principio sea costoso.</p> <p>ArrayList mantiene el orden de inserci\u00f3n, es decir, si recorremos la colecci\u00f3n se nos mostrar\u00e1 en el mismo orden en que insertamos los objetos.</p> <p>Veamos un ejemplo de declaraci\u00f3n e inicializaci\u00f3n:</p> <pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n</code></pre> <p>A partir de java7, no es necesario indicar el gen\u00e9rico en la inicializaci\u00f3n:</p> <pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n</code></pre> <p>Para hacer el c\u00f3digo m\u00e1s gen\u00e9rico, se puede definir la variable de tipo interfaz, ya que dicho c\u00f3digo podr\u00eda funcionar con cualquier clase que implemente la interfaz, simplemente habr\u00eda que cambiar el new:</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n</code></pre> <p>Veamos un ejemplo de ArrayList donde utiliza m\u00e9todos tanto de Collection como de List:</p> C\u00f3digoSalida <pre><code>import java.util.ArrayList;\nimport java.util.List;\npublic class ShowArrayList{\npublic void show(){\nList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\nList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\nList&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();\nlist1.add(1);\nlist1.add(2);//Se a\u00f1aden los elementos al final de la lista\nlist1.add(6);\nlist1.add(2, 5);//Se a\u00f1ade el 5 en la posici\u00f3n 2\nfor (Integer i : list1) {//Recorremos la lista con un bucle for-each: 1 2 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist2.add(3);\nlist2.add(4);\nlist1.addAll(2, list2);//Se inserta list2 en la posici\u00f3n 2 de list1\nfor (Integer i : list1) {// 1 2 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist3.add(7);\nlist3.add(8);\nlist1.addAll(list3);//Se inserta list3 al final de list1\nfor (Integer i : list1) {// 1 2 3 4 5 6 7 8\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl elemento 3 de list1 es: %d\", list1.get(3));//4\nSystem.out.printf(\"\\nLa posici\u00f3n del 4 en list1 es: %d\", list1.indexOf(4));//3\nlist1.add(4);//Se a\u00f1ade un 4 al final de list1\nSystem.out.printf(\"\\nLa posici\u00f3n del 4 en list1 por el final es: %d\\n\", list1.lastIndexOf(4));//8\nlist1.remove(8);//Se elimina el elemento de la posici\u00f3n 8, que es el \u00faltimo 4 insertado\nfor (Integer i : list1) {// 1 2 3 4 5 6 7 8\nSystem.out.printf(\" %d \", i);\n}\nlist1.set(6, 8);//Se reemplaza el elemento que se encuentra en la posici\u00f3n 6 por un 8\nSystem.out.println();\nfor (Integer i : list1) {// 1 2 3 4 5 6 8 8\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nLa sub-lista comprendida entre las posiciones 2 y 5 es: \");\nfor (Integer i : list1.subList(2, 6)) {// 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl 4 %s se encuentra en list1\", list1.contains(4) ? \"s\u00ed\" : \"no\");//s\u00ed\nSystem.out.printf(\"\\nEl 9 %s se encuentra en list1\", list1.contains(9) ? \"s\u00ed\" : \"no\");//no\n//list1: 1 2 3 4 5 6 8 8\n//list2: 3 4\n//list3: 7 8\nSystem.out.printf(\"\\nTodos los elementos de list2 %s se encuentran en list1\", list1.containsAll(list2) ? \"s\u00ed\" : \"no\");//s\u00ed\nSystem.out.printf(\"\\nTodos los elementos de list3 %s se encuentran en list1\\n\",\nlist1.containsAll(list3) ? \"s\u00ed\" : \"no\");//no\nlist1.removeAll(list3);//Se eliminan de list1 todos los elementos de list3, es decir, el 8\nfor (Integer i : list1) {// 1 2 3 4 5 6\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist1.retainAll(list2);//Intersecci\u00f3n entre list1 y list2\nfor (Integer i : list1) {// 3 4\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.printf(\"\\nEl tama\u00f1o de list1 es: %d\", list1.size());//2\nSystem.out.printf(\"\\nlist1 %s est\u00e1 vac\u00eda\", list1.isEmpty() ? \"s\u00ed\" : \"no\");//no\nlist1.clear();//Elimina todos los elementos de list1\nSystem.out.printf(\"\\nlist1 %s est\u00e1 vac\u00eda\", list1.isEmpty() ? \"s\u00ed\" : \"no\");//s\u00ed\n}\npublic static void main(String[] args) {\nnew ShowArrayList().show();\n}\n}\n</code></pre> <pre><code>1 2 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6 7 8\nEl elemento 3 de list1 es: 4\nLa posici\u00f3n del 4 en list1 es: 3\nLa posici\u00f3n del 4 en list1 por el final es: 8\n1 2 3 4 5 6 7 8\n1 2 3 4 5 6 8 8\nLa sub-lista comprendida entre las posiciones 2 y 5 es: 3 4 5 6\nEl 4 s\u00ed se encuentra en list1\nEl 9 no se encuentra en list1\nTodos los elementos de list2 s\u00ed se encuentran en list1\nTodos los elementos de list3 no se encuentran en list1\n1 2 3 4 5 6\n3 4\nEl tama\u00f1o de list1 es: 2\nlist1 no est\u00e1 vac\u00eda\nlist1 s\u00ed est\u00e1 vac\u00eda\n</code></pre>"},{"location":"bloque_iii/tema_11/page-2/#iteradores","title":"Iteradores","text":"<p>En dise\u00f1o de software, el patr\u00f3n de dise\u00f1o Iterador (en ingl\u00e9s, Iterator) define una interfaz que declara los m\u00e9todos necesarios para acceder secuencialmente a un grupo de objetos de una colecci\u00f3n.</p> <p>Este patr\u00f3n debe ser utilizado cuando se requiera una forma est\u00e1ndar de recorrer una colecci\u00f3n, es decir, cuando no sea necesario que un cliente sepa el tipo de colecci\u00f3n que est\u00e1 recorriendo.</p> <p>La interfaz <code>Iterable&lt;T&gt;</code> contiene el m\u00e9todo iterator() que devuelve una instancia de alguno clase que implemente la interfaz <code>Iterator&lt;T&gt;</code>:</p> <ul> <li><code>Iterator&lt;T&gt; iterator()</code>: devuelve un iterador al comienzo de la colecci\u00f3n.</li> </ul> <p>La interfaz <code>Iterator&lt;E&gt;</code> permite el acceso secuencial a los elementos de una colecci\u00f3n y realizar recorridos sobre la colecci\u00f3n. Los m\u00e9todos de <code>Iterator&lt;E&gt;</code> son:</p> <ul> <li><code>boolean hasNext()</code>: comprueba si hay siguiente elemento.</li> <li><code>E next()</code>: devuelve el siguiente elemento y mueve el iterador.</li> <li><code>void remove()</code>: se invoca despu\u00e9s de next() para eliminar el \u00faltimo elemento le\u00eddo.</li> </ul> <p>La interfaz <code>Collection&lt;E&gt;</code> es una sub-interfaz o interfaz hija de <code>Iterable&lt;E&gt;</code>, as\u00ed que dispone del m\u00e9todo <code>iterator()</code>. Veamos un ejemplo de un <code>ArrayList&lt;E&gt;</code>utilizando iteradores:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class ShowIterator{\npublic void show(){\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile(it.hasNext()){\nSystem.out.println(it.next());\n}\n}\npublic static void main(String[] args){\nnew ShowIterator().show();\n}\n}\n</code></pre> <pre><code>Juan\nAntonio\nJaime\nVicente\n</code></pre> <p>Si no hay siguiente, <code>next()</code> lanza una excepci\u00f3n <code>NoSuchElementException</code>:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class NextException {\npublic void show() {\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nit = list.iterator();\nSystem.out.println(it.next());\nSystem.out.println(it.next());//(1)!\n}\npublic static void main(String[] args) {\nnew NextException().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n una excepci\u00f3n <code>NoSuchElementException</code></li> </ol> <p>Tal y como vemos en el ejemplo anterior, hay que comprobar si hay siguiente con un <code>hashNext()</code> para que el <code>next()</code> no lance la excepci\u00f3n.</p> <p>No se puede modificar la colecci\u00f3n dentro del bucle for-each porque se lanza en ejecuci\u00f3n la excepci\u00f3n <code>ConcurrentModificationException</code>, ya que estamos recorriendo y modificando la lista a la vez:</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\npublic class ModifyInsideForEach {\npublic void show() {\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nfor (String s : list) {//(1)!\nSystem.out.printf(\" %s \", s);\nif (s.equals(\"Antonio\")) {\nlist.remove(\"Antonio\");\n}\n}\n}\npublic static void main(String[] args) {\nnew ModifyInsideForEach().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n la excepci\u00f3n <code>ConcurrentModificationException</code></li> </ol> <p>Para solucionarlo, podemos utilizar el m\u00e9todo <code>remove()</code>de <code>Iterator&lt;E&gt;</code>. Si se modifica una colecci\u00f3n mientras se recorre, los iteradores quedan invalidados, a excepci\u00f3n del m\u00e9todo <code>remove()</code> de la interfaz <code>Iterator&lt;E&gt;</code>. El m\u00e9todo <code>remove()</code> permite eliminar elementos de la colecci\u00f3n siendo la \u00fanica forma adecuada para eliminar elementos durante la iteraci\u00f3n:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveIterator {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveIterator().show();\n}\n}\n</code></pre> <pre><code>Juan\nJaime\nVicente\n</code></pre> <p>Solo puede haber una invocaci\u00f3n a <code>remove()</code> por cada invocaci\u00f3n <code>next()</code>. Si no cumple, se lanza en ejecuci\u00f3n una excepci\u00f3n <code>IllegalStateException</code>. Por ejemplo, imaginemos que tenemos una lista de personas y queremos eliminar a Antonio y a la persona que venga detr\u00e1s. Si cuando encontramos a Antonio, hacemos dos <code>remove()</code> seguidos, entonces salta la excepci\u00f3n:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveNext1 {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\nit.remove();//(1)!\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveNext1().show();\n}\n}\n</code></pre> <ol> <li>Se lanza en ejecuci\u00f3n la excepci\u00f3n <code>IllegalStateException</code></li> </ol> <p>Tendr\u00edamos que hacer otro <code>next()</code> para el que venga detr\u00e1s de Antonio:</p> C\u00f3digoConsola <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class RemoveNext2 {\npublic void show() {\nString s;\nIterator&lt;String&gt; it;\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Juan\");\nlist.add(\"Antonio\");\nlist.add(\"Jaime\");\nlist.add(\"Vicente\");\nit = list.iterator();\nwhile (it.hasNext()) {\ns = it.next();\nif (s.equals(\"Antonio\")) {\nit.remove();\nit.next();\nit.remove();\n} else {\nSystem.out.println(s);\n}\n}\n}\npublic static void main(String[] args) {\nnew RemoveNext2().show();\n}\n}\n</code></pre> <pre><code>Juan\nVicente\n</code></pre> <p>La interfaz <code>ListIterator&lt;E&gt;</code> es una subinterfaz o interfaz hija de <code>Iterator&lt;E&gt;</code>. Es un iterador para listas que permite al programador recorrer la lista hacia delante y hacia atr\u00e1s, modificar la lista durante la iteraci\u00f3n y obtener la posici\u00f3n actual del iterador en la lista.</p> <p>Hereda los m\u00e9todos de <code>Iterador&lt;E&gt;</code> y adem\u00e1s aporta otros m\u00e9todos nuevos:</p> <ul> <li><code>void add(E e)</code>: inserta el elemento en la lista antes del elemento que ser\u00eda devuelto por next(), si lo hubiera, y despu\u00e9s del elemento que ser\u00eda devuelto por previous(), si lo hubiera. Una llamada posterior a next() no se ver\u00eda afectada y una llamada posterior a previous() devolver\u00eda el nuevo elemento.</li> <li><code>boolean hasPrevious()</code>: comprueba si hay un elemento anterior.</li> <li><code>int nextIndex()</code>: devuelve el \u00edndice del elemento que ser\u00eda devuelto por una llamada a next(). El \u00edndice del primer elemento es 0.</li> <li><code>E previous()</code>: devuelve el elemento anterior de la lista y mueve la posici\u00f3n del cursor hacia atr\u00e1s.</li> <li><code>int previousIndex()</code>: devuelve el \u00edndice del elemento que ser\u00eda devuelto por una llamada a previous().</li> <li><code>void set(E e)</code>: sustituye el \u00faltimo elemento devuelto por next() o previous() por elemento e.</li> </ul> <p>En la interfaz <code>List&lt;E&gt;</code>, hay dos m\u00e9todos para crear este iterador:</p> <ul> <li><code>ListIterator&lt;E&gt; listIterator()</code>: se coloca antes del primer elemento para que al hacer el primer next() se devuelva el primer elemento.</li> <li><code>ListIterator&lt;E&gt; listIterator(int index)</code>: se coloca antes del elemento que se encuentra en la posici\u00f3n index para que al hacer un next() se devuelva dicho elemento. Para recorrer la lista al rev\u00e9s, hay que crearlo con el tama\u00f1o de la lista para que el primer previous() devuelva el \u00faltimo.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\npublic class ShowListIterator {\npublic void show() {\nListIterator&lt;Integer&gt; it;\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(1);\nlist.add(2);\nlist.add(4);\nlist.add(6);\n//Recorrido de la lista hacia atr\u00e1s:\nit = list.listIterator(list.size());\nwhile (it.hasPrevious()) {\nSystem.out.printf(\" %d \", it.previous());// 6 4 2 1\n}\nit = list.listIterator(1);//Se coloca antes del elemento que se encuentra en la posici\u00f3n 1\nSystem.out.printf(\"\\n %d \", it.next());//2\nSystem.out.printf(\"\\n %d \", it.nextIndex());//2\nSystem.out.printf(\"\\n %d \", it.previousIndex());//1\nit.add(3);\nSystem.out.printf(\"\\n %d \", it.next());//4 Una llamada posterior a next() no se ve afectada\nit.add(5);\nSystem.out.printf(\"\\n %d \", it.previous());//5 Una llamada posterior a previous() devuelve el nuevo elemento\nSystem.out.printf(\"\\n %d \\n\", it.next());//5\nit.set(7);//sustituye el \u00faltimo elemento devuelto por next() por 7\nfor (Integer i : list) {\nSystem.out.printf(\" %d \", i);//1 2 3 4 7 6\n}\n}\npublic static void main(String[] args) {\nnew ShowListIterator().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/","title":"3 Conjuntos","text":""},{"location":"bloque_iii/tema_11/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Un conjunto es una lista formada por elementos que no se repiten. Para ello, la JVM usar\u00e1 los m\u00e9todos <code>equals</code> y <code>hashCode</code> heredados la clase clase Object para comprobar si dos elementos son iguales.</p> <p>Son m\u00e9todos heredados de la clase <code>Object</code>. Normalmente, hay que sobrescribirlos para adaptarlo de forma adecuada a la clase correspondiente.</p> <p>Sin embargo, debemos tener en cuenta que al sobrescribir todos estos m\u00e9todos debemos seguir cumpliendo con el comportamiento que se espera de ellos, ya que son usados internamente por muchas clases del propio lenguaje. De lo contario, las clases que dependen de ello, como <code>HashMap</code>y <code>HashSet</code> dejar\u00edan de funcionar correctamente.</p> <p>Escribir a mano los m\u00e9todos <code>equals()</code> y <code>hashCode()</code> es bastante tedioso. Para facilitarnos esta tarea tenemos librer\u00edas como la librer\u00eda AutoValue de Google que lo genera autom\u00e1ticamente para nosotros con tan s\u00f3lo usar una determinada anotaci\u00f3n. Otra opci\u00f3n es dejar que el IDE nos genere dichos m\u00e9todos, aunque esto tiene el inconveniente de que no se generan autom\u00e1ticamente de nuevo conforme a\u00f1adimos atributos a nuestro clase, por lo que debemos tener cuidado, algo que s\u00ed hace AutoValue. En todo caso, es mejor usar el IDE que hacerlo nosotros a mano, ya que el humano es m\u00e1s propenso a los errores. En el Eclipse se encuentra en <code>Men\u00fa Source \u2192 Generate hashCode() and equals()</code>.</p>"},{"location":"bloque_iii/tema_11/page-3/#metodo-equals","title":"M\u00e9todo <code>equals</code>","text":"<p>El m\u00e9todo <code>equals()</code> comprueba si dos objetos son iguales.</p> <p>En caso de que no se sobrescriba dicho m\u00e9todo, s\u00f3lo ser\u00e1 igual a s\u00ed misma, es decir, si est\u00e1 situada en la misma posici\u00f3n de memoria.</p> <p>Debemos tener en cuenta que cuando un programador usa el m\u00e9todo <code>equals()</code> sobre un objeto pas\u00e1ndole como argumento otro objeto lo que pretende es descubrir si ambos objetos son equivalentes l\u00f3gicamente(representa el mismo \"valor\"), no si est\u00e1n almacenados en la misma posici\u00f3n de memoria (tienen la misma identidad).</p> <p>No sobrescribir el m\u00e9todo <code>equals()</code> en una determinada clase es la opci\u00f3n recomendada en los siguientes casos:</p> <ul> <li>Cuando cada instancia de la clase es intr\u00ednsecamente \u00fanica, lo cual es cierto para clases como <code>Scanner</code> que representan entidades activas en lugar de valores.</li> <li>Cuando se considera que no hay necesidad de que la clase provea una prueba de equivalencia l\u00f3gica.</li> <li>Cuando una superclase de la clase ya lo ha sobrescrito y el comportamiento de la superclase es apropiado para las subclase.</li> <li>Cuando la clase es privada o friendly, y estamos completamente seguros de que su m\u00e9todo <code>equals()</code> nunca ser\u00e1 invocado, ni expl\u00edcita ni impl\u00edcitamente.</li> </ul> <p>Si nuestra clase no se encuentra en ninguno de los casos anteriores es muy recomendable que sobrescribamos el m\u00e9todo <code>equals()</code>. Un ejemplo muy caracter\u00edstico es cuando la clase corresponda a una entidad que represente un valor.</p> <p>Como hemos comentado, cuando sobrescribamos el m\u00e9todo <code>equals()</code> debemos seguir cumpliendo el comportamiento que el sistema espera de \u00e9l, que incluye las siguientes propiedades:</p> <ul> <li>Reflexiva: Para todo objeto x distinto de null se debe cumplir que <code>x.equals(x)</code> sea true.</li> <li>Sim\u00e9trica: Para todo par de objetos x e y y distintos de null se debe cumplir que <code>x.equals(y)</code> s\u00f3lo debe retornar true si <code>y.equals(x)</code> retorna true.</li> <li>Transitiva: Para todo tr\u00edo de objetos x, y, z distintos de null se debe cumplir que si <code>x.equals(y)</code> retorne true y <code>y.equals(z)</code> retorna true entonces <code>x.equals(z)</code> debe retornar true.</li> <li>Consistente: Para todo par de objetos x e y distintos de null se debe cumplir que <code>x.equals(y)</code>siempre retorne el mismo valor si no hemos cambiado los atributos que se usan para comparar en alguno de los objetos.</li> <li>Para todo objeto x distinto de null se debe cumplir que <code>x.equals(null)</code>debe retornar false.</li> </ul> <p>As\u00ed para sobrescribir el m\u00e9todo <code>equals()</code> cumpliendo con las propiedades anteriores se recomienda seguir los siguientes pasos:</p> <ol> <li>Usar el operador <code>==</code> para comprobar si el argumento corresponde a otra referencia al mismo objeto, en cuyo caso retornar true.</li> <li>Usar el operador <code>instanceof</code> para comprobar si el objeto recibido como argumento no es de la misma clase, en cuyo caso retornar false. Tambi\u00e9n nos sirve para comprobar si dichos argumento es null, ya que en este caso instanceof retornar\u00eda false.</li> <li>Hacer cast del objeto recibido como argumento convirti\u00e9ndolo a la clase correspondiente. Dado que hemos hecho antes instanceof, el cast siempre tendr\u00e1 \u00e9xito.</li> <li>Para cada atributo significativo de la clase, comprobar que dicho atributo en el objeto argumento es equivalente al atributo en el objeto this. Si no tenemos \u00e9xito en alguno de ellos, retornar false. Si todas las comprobaciones se han hecho con \u00e9xito, retornar true. Para realizar las comprobaciones de cada atributo usar:<ul> <li>El operador <code>==</code> para valores primitivos que no sean float ni double.</li> <li>Para los valores float usar <code>Float.compare(value1, value2)</code> y para valores double usar <code>Double.compare(value1, value2)</code>.</li> <li>Para valores correspondientes a objetos llamar a <code>equals()</code> recursivamente. Si es v\u00e1lido que dichos objetos contengan null, entonces debemos usar <code>Objects.equals(object1, object2)</code> para que no se produzca la excepci\u00f3n <code>NullPointerException</code>.</li> <li>Para los valores correspondientes a arrays, compara uno a uno los elementos significativos del array. Si todos los elementos son significativos, usa alguno de las versiones del m\u00e9todo est\u00e1tico <code>Arrays.equals()</code>.</li> </ul> </li> </ol> <p>Veamos un ejemplo:</p> <pre><code>public final class PhoneNumber{\nprivate final short areaCode, prefix, lineNum;\n@Override\npublic boolean equals(Object o){\nif(o == this) return true;\nif(!(o instanceof PhoneNumber)) return false;\nPhoneNumber pn = (PhoneNumber) o;\nreturn pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n}\n//...\n}\n</code></pre> <p>\u00a1CUIDADO!</p> <p>Un aspecto muy importante es que no debemos cambiar el tipo del objeto recibido como argumento, que siempre debe ser <code>Object</code>, o no estaremos sobrescribiendo el m\u00e9todo <code>equals()</code>, sino sobrecarg\u00e1ndolo, lo que puede producir falsos positivos. El compilador no se quejar\u00e1 si no usamos la anotaci\u00f3n <code>@Override</code> (por eso siempre se recomienda usarla). Por ejemplo, nunca hagas esto:</p> <pre><code>public boolean equals(MyClass o){\n//...\n}\n</code></pre> <p>Nota</p> <p>Algunas veces, para comparar que una variable de tipo String es equivalente a una determinada constante de cadena se usa la construcci\u00f3n \"Hello\".equals(message) , ya que dicho construcci\u00f3n no puede lanzar NullPointerException si message es null, sino que tan s\u00f3lo retornar\u00e1 false, mientras que message.equals(\"Hello\") lanzar\u00eda NullPointerException en ese caso.</p>"},{"location":"bloque_iii/tema_11/page-3/#metodo-hashcode","title":"M\u00e9todo <code>hashCode</code>","text":"<p>El m\u00e9todo <code>hashCode()</code> devuelve un n\u00famero entero que identifica al objeto cuando se guarda en algunas estructuras de datos.</p> <p>Un detalla muy importante que no debemos olvidar es que **si en una clase sobrescribimos el m\u00e9todo <code>equals()</code> debemos obligatoriamente sobrescribir tambi\u00e9n el m\u00e9todo <code>hashCode()</code> o de lo contrario no se estar\u00e1 cumpliendo con el comportamiento esperado de este \u00faltimo, lo que impedir\u00e1 que los objetos de dichas clase funcionen correctamente en colecciones como <code>HashMap</code> y <code>HashSet</code>.</p> <p>El comportamiento que se espera de <code>hashCode()</code> es el siguiente:</p> <ul> <li>Debe ser consistente, es decir, que repetidas llamadas al m\u00e9todo <code>hashCode()</code> deben retornar el mismo valor, siempre y cuando no se haya modificado ninguno de los atributos usados para las comparaciones.</li> <li>Si dos objetos son equivalentes, es decir, si <code>x.equals(y)</code> retorna true, entonces <code>x.hashCode()</code> e <code>y.hashCode()</code> deben retornar el mismo valor entero. \u00c9ste ees el motivo por el que siempre que sobrescribamos <code>equals()</code> debemos sobrescribir <code>hashCode()</code>, ya que la implementaci\u00f3n por defecto de <code>hashCode()</code> de la clase <code>Object</code> devuelve una representaci\u00f3n num\u00e9rica de la direcci\u00f3n de memoria en la que se encuentra ubicado el objeto.</li> <li>Si dos objetos no son equivalentes, es decir si <code>x.equals(y)</code> retorna false, no es estrictamente necesario, aunque si recomendable, que <code>x.hashCode()</code> e <code>y.hashCode()</code> retornen valores diferentes, de manera que se mejore el rendimiento de las tablas hash. Idealmente el algoritmo de la funci\u00f3n hash debe distribuir una colecci\u00f3n de instancias de un tama\u00f1o considerable de forma uniforme entre todos los valores enteros.</li> </ul> <p>La implementaci\u00f3n caracter\u00edstica al sobrescribir el m\u00e9todo <code>hashCode()</code> en la clase <code>PhoneNumber</code> es la siguiente, usando los atributos areaCode, prefix, lineNum.</p> <pre><code>public final class PhoneNumber{\nprivate final short areaCode, prefix, lineNum;\n@Override\npublic boolean equals(Object o){\nif(o == this) return true;\nif(!(o instanceof PhoneNumber)) return false;\nPhoneNumber pn = (PhoneNumber) o;\nreturn pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n}\n@Override\npublic int hashCode(){\nint result = Short.hashCode(areaCode);\nresult = 31 * result + Short.hashCode(prefix);\nresult = 31 * result + Short.hashCode(lineNum);\nreturn result;\n}\n//...\n}\n</code></pre> <p>Adem\u00e1s de escribir nosotros a mano el c\u00f3digo del m\u00e9todo <code>hashCode()</code>, podemos usar la implementaci\u00f3n proporcionada por algunas librer\u00edas, como Guava o AutoValue, o usar la implementaci\u00f3n de los IDEs.</p> <p>Por otra parte, podemos usar <code>Objects.hashCode(object...)</code> para sobrescribir el m\u00e9todo con una sola l\u00ednea. Desafortunadamente, este m\u00e9todo es bastante menos eficiente de lo esperado, debido a que recibe un array de atributos y de que realiza boxing y unboxing de los atributos que sean de un tipo primitivo. Por ejemplo:</p> <pre><code>public final class PhoneNumber{\nprivate final short areaCode, prefix, lineNum;\n@Override\npublic boolean equals(Object o){\nif(o == this) return true;\nif(!(o instanceof PhoneNumber)) return false;\nPhoneNumber pn = (PhoneNumber) o;\nreturn pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode;\n}\n@Override\npublic int hashCode(){\nreturn Objects.hash(lineNum, prefix, areaCode);\n}\n//...\n}\n</code></pre> <p>Si una clase es inmutable y el coste de calcular el valor hash es significativo, podr\u00eda considerar almacenar cacheado el c\u00f3digo hash en el propio objecto, en lugar de recalcularlo cada vez que se solicite. Si cree que la mayor\u00eda de los objetos de esta clase se usar\u00e1n como claves hash, entonces deber\u00eda calcular el c\u00f3digo hash cuando se cree la instancia. De lo contario, podr\u00eda elegir calcular perezosamente el c\u00f3digo hash la primera vez que se invoque el m\u00e9todo <code>hash()</code>.</p> <p>Dos consideraciones finales:en primer lugar no excluya atributos significativos del c\u00e1lculo de valor hash, as\u00ed lograr\u00e1 un mejor rendimiento, al no repetir tanto los valores. En segundo lugar, no proporcione a los clientes de la clase demasiada informaci\u00f3n acerca de c\u00f3mo se calcula el valor hash de esta manera el c\u00f3digo no podr\u00e1 depender de c\u00f3mo se calcula, permiti\u00e9ndonos modificar la implementaci\u00f3n del m\u00e9todo en el futuro sin afectar a los clientes.</p>"},{"location":"bloque_iii/tema_11/page-3/#colecciones-sin-duplicados","title":"Colecciones sin duplicados","text":"<p>La interfaz <code>Set</code>, que hereda de Collection, permite implementar listas de elementos sin duplicados, es decir, modela la abstracci\u00f3n matem\u00e1tica de los conjuntos.</p> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java:</p> <ul> <li>HashSet: esta implementaci\u00f3n almacena los elementos de una tabla hash. Es la implementaci\u00f3n con mejor rendimiento de todas pero no garantiza ning\u00fan orden a la hora de realizar iteraciones.</li> <li>LinkedHashSet: est\u00e1 implementaci\u00f3n almacena los elementos en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que HashSet.</li> <li>TreeSet: est\u00e1 implementaci\u00f3n utiliza una estructura de \u00e1rbol para ordenar los elementos. Es bastante m\u00e1s lenta que HashSet.</li> </ul>"},{"location":"bloque_iii/tema_11/page-3/#clase-hashset","title":"Clase HashSet","text":"<p>Implementa la interfaz <code>Set</code>. Es la clase m\u00e1s utilizada para implementar listas sin duplicados. Esta clase permite el elemento nulo. No garantiza ning\u00fan orden a la hora de realizar iteraciones.</p> <p>Utiliza internamente una tabla de tipos hash:</p> <p> Figura 1 - Hashtable</p> <p>Al querer guardar un objeto en esta estructura, se llama al m\u00e9todo hashCode() el cual devuelve un n\u00famero entero que la estructura usar\u00e1 para decidir en qu\u00e9 caj\u00f3n debe recuperar el objeto. El objetivo de guardar los datos de esta forma y de llamar al m\u00e9todo es lograr almacenar y recuperar la informaci\u00f3n en tiempo constante (lo cual no ocurre siempre, pero se acerca). El que no suceda esto depende, casi siempre, del valor que devuelva el m\u00e9todo <code>hashCode()</code> para cada objeto.</p> <p>Supongamos que guardamos 3 objetos en esta estructura y el m\u00e9todo <code>hashCode()</code> de los 3 devuelve 0, esto quiere decir que los 3 objetos se guardar\u00e1n en el caj\u00f3n 0. Cuando se necesite recuperar un objeto, hay que recorrer los objetos del caj\u00f3n 0 para determinar cu\u00e1l es el que se quiere recuperar. Por lo tanto, este m\u00e9todo <code>hashCode()</code> no es \u00fatil ya que lo que se pretende al guardar los elementos es que \u00e9stos queden dispersos de forma uniforme en toda la estructura quedando la menor cantidad de cajones vac\u00edos y que no haya cajones donde se guarden muchos m\u00e1s elementos que en otros.</p> <p>Si dos objetos tiene el mismo <code>hashCode()</code>, ambos objetos se guardar\u00e1n en el mismo caj\u00f3n. La estructura usa entonces el m\u00e9todo <code>equals()</code> dentro de ese caj\u00f3n para determinar cu\u00e1l corresponde con el solicitado y para eso depende de que el programador haya sobrescrito el m\u00e9todo, de lo contrario no garantiza un resultado correcto.</p> <p> Figura 2 - Hash</p> <p>Los objetos HashSet se construyen con un tama\u00f1o inicial de tabla (el tama\u00f1o del array) y un factor de carga que indica cu\u00e1ndo se debe redimensionar el array. Es decir, si se cre\u00f3 un array de 100 elementos y la carga se estableci\u00f3 al 80%, cuando se hayan rellanado 80 valores, se redimensiona el array. Por defecto, el tama\u00f1o del array se toma con 16 y el factor de carga con 0,75 (75%). No obstante, se puede construir una lista HashSet indicando ambos par\u00e1metros.</p> <p>Esta implementaci\u00f3n proporciona tiempos constantes en las operaciones b\u00e1sicas siempre y cuando la funci\u00f3n hash disperse de forma correcta los elementos dentro de la tabla hash. Es importante definir el tama\u00f1o inicial de la tabla ya que este tama\u00f1o marcar\u00e1 el rendimiento de esta implementaci\u00f3n.</p> <p>Veamos un ejemplo de <code>HashSet</code> con la clase <code>Vehicle</code>. Los atributos significativos a tener en cuenta para el <code>equals()</code> y el <code>hashCode()</code> son wheelCount y colour. La velocidad (speed) no se incluye ya que si comparamos el mismo coche pero con velocidades distintas, en realidad, no deja de ser el mismo coche.</p> VehicleMainConsola <pre><code>public class Vehicle {\nprivate int wheelCount;\nprivate double speed;\nprivate String colour;\npublic Vehicle(int wheelCount, String colour) {\nthis.wheelCount = wheelCount;\nthis.colour = colour;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic String getColour() {\nreturn colour;\n}\npublic void setColour(String colour) {\nthis.colour = colour;\n}\npublic void accelerate(double amount) {\nspeed += amount;\n}\npublic void brake(double amount) {\nspeed -= amount;\n}\n@Override\npublic String toString() {\nreturn \"Vehicle [wheelCount=\" + wheelCount + \", speed=\" + speed + \",colour=\" + colour + \"]\";\n}\n@Override\npublic int hashCode() {\nfinal int prime = 31;\nint result = 1;\nresult = prime * result + ((colour == null) ? 0 : colour.hashCode());\nresult = prime * result + wheelCount;\nreturn result;\n}\n@Override\npublic boolean equals(Object obj) {\nif (this == obj)\nreturn true;\nif (obj == null)\nreturn false;\nif (!(obj instanceof Vehicle other))\nreturn false;\nif (colour == null) {\nif (other.colour != null)\nreturn false;\n} else if (!colour.equals(other.colour))\nreturn false;\nreturn wheelCount == other.wheelCount;\n}\n}\n</code></pre> <pre><code>import java.util.HashSet;\nimport java.util.Set;\npublic class ShowHashSet {\npublic void show() {\nSet&lt;Vehicle&gt; set = new HashSet&lt;&gt;();\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"verde\"));\nfor (Vehicle v : set) {\nSystem.out.println(v);//Se llama al toString del objeto\n}\n}\npublic static void main(String[] args) {\nnew ShowHashSet().show();\n}\n}\n</code></pre> <pre><code>Vehicle [wheelCount=4, speed=0.0, colour=verde]\nVehicle [wheelCount=4, speed=0.0, colour=azul]\nVehicle [wheelCount=2, speed=0.0, colour=rojo]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/#clase-linkedhashset","title":"Clase LinkedHashSet","text":"<p>Almacena los elementos en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que HashSet.</p> MainConsola <pre><code>import java.util.LinkedHashSet;\nimport java.util.Set;\npublic class ShowLinkedHashSet {\npublic void show() {\nSet&lt;Vehicle&gt; set = new LinkedHashSet&lt;&gt;();\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"azul\"));\nset.add(new Vehicle(2, \"rojo\"));\nset.add(new Vehicle(4, \"verde\"));\nfor (Vehicle v : set) {\nSystem.out.println(v);//Se llama al toString del objeto\n}\n}\npublic static void main(String[] args) {\nnew ShowLinkedHashSet().show();\n}\n}\n</code></pre> <pre><code>Vehicle [wheelCount=4, speed=0.0, colour=azul]\nVehicle [wheelCount=2, speed=0.0, colour=rojo]\nVehicle [wheelCount=4, speed=0.0, colour=verde]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-3/#clase-enumset","title":"Clase EnumSet","text":"<p>Es una implementaci\u00f3n de conjuntos de alto rendimiento de tipos enumerados. Require que las constantes de enumeraci\u00f3n colocadas en \u00e9l pertenezcan al mismo tipo de enumeraci\u00f3n. Veamos algunos de sus m\u00e9todos:</p> <ul> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; allOf(Class&lt;E&gt; elementType)</code>: crea un conjunto de enumeraciones que contiene todos los valores del tipo de enumeraci\u00f3n especificado.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; complementOf(EnumSet&lt;E&gt; s)</code>: crea un conjunto de numeraciones con el mismo tipo que el conjunto de enumeraciones especificado, conteniendo inicialmente todos los elementos de este tipo que no est\u00e1n contenidos en el conjunto especificado.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; copyOf(EnumSet&lt;E&gt; s)</code>: crea un conjunto de enumeraciones a partir de otro.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType)</code>: crea un conjunto de enumeraciones vac\u00edo con el tipo de elemento especificado.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E e)</code>: crea un conjunto de enumeraciones que contiene el elemento especificado. Este m\u00e9todo tiene varias sobrecargas para admitir m\u00e1s elementos.</li> <li><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; range(E from, E to)</code>: crea un conjunto de enumeraciones que contiene inicialmente todos los elementos del rango definido por los dos elementos especificados.</li> </ul> ENUMShowEnumSet <pre><code>public enum Operation {\nPLUS(\"+\"), MINUS(\"-\"), TIMES(\"*\"), DIVIDE(\"/\");\nprivate final String symbol;\nprivate Operation(String symbol) {\nthis.symbol = symbol;\n}\npublic String getSymbol() {\nreturn symbol;\n}\n}\n</code></pre> <pre><code>public class ShowEnumSet {\npublic void show() {\nEnumSet&lt;Operation&gt; allOperations1, allOperations2, operations1, operations2, operations3, operations4;\nallOperations1 = EnumSet.allOf(Operation.class);\nSystem.out.printf(\"allOf: %s\", allOperations1);//allOf: [PLUS, MINUS,TIMES, DIVIDE]\nallOperations2 = EnumSet.copyOf(allOperations1);\nSystem.out.printf(\"\\ncopyOf: %s\", allOperations2);//copyOf: [PLUS,MINUS, TIMES, DIVIDE]\noperations1 = EnumSet.noneOf(Operation.class);\noperations1.add(Operation.PLUS);\noperations1.add(Operation.MINUS);\nSystem.out.printf(\"\\nnoneOf y add: %s\", operations1);//noneOf y add: [PLUS, MINUS]\noperations2 = EnumSet.complementOf(operations1);\nSystem.out.printf(\"\\ncomplementOf: %s\", operations2);//complementOf:[TIMES, DIVIDE]\noperations3 = EnumSet.of(Operation.DIVIDE, Operation.MINUS);\nSystem.out.printf(\"\\nof: %s\", operations3);//of: [MINUS, DIVIDE]\noperations4 = EnumSet.range(Operation.MINUS, Operation.DIVIDE);\nSystem.out.printf(\"\\nrange: %s\\n\", operations4);//range: [MINUS,TIMES, DIVIDE]\nSystem.out.println(operations4.contains(Operation.PLUS));//false\nSystem.out.println(operations4.contains(Operation.MINUS));//true\n}\npublic static void main(String[] args) {\nnew ShowEnumSet().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-4/","title":"4 Mapas","text":""},{"location":"bloque_iii/tema_11/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Las colecciones de tipo Set tienen el inconveniente de tener que almacenar una copia exacta del elemento a buscar. Sin embargo, en la pr\u00e1ctica es habitual que haya datos que se consideren clave, es decir, que identifican a cada objeto (el dni de las personas por ejemplo) de tal manera que buscan los datos en base a esa clave y por otro lado se almacenan el resto de los datos. Los mapas permiten definir colecciones de elementos que poseen pares de datos clave-valor. Esto se utiliza para localizar valores en funci\u00f3n de la clave que poseen. Son muy interesantes y r\u00e1pidos. Los mapas tambi\u00e9n son conocidos como diccionarios.</p> <p>La interfaz <code>Map&lt;K,V&gt;</code> es la ra\u00edz de todas las clases que implementan mapas. Hasta la versi\u00f3n 5, los mapas eran colecciones de pares clave-valor donde tanto la clave como el valor eran de tipo Object. Desde la versi\u00f3n versi\u00f3n 5, esta interfaz tiene dos gen\u00e9ricos: <code>K</code> para el tipo de datos de la clave y <code>V</code> para el tipo de los valores. Esta estructura de datos nos permite obtener el objeto <code>V</code> muy r\u00e1pidamente a partir de su clave <code>K</code>.</p> <p>Esta interfaz no hereda de Collection por lo que no tiene los m\u00e9todos vistos anteriormente. La raz\u00f3n es que la obtenci\u00f3n, b\u00fasqueda y borrado de elementos se hace de una manera muy distinta.</p> <p>Las claves no se pueden repetir por lo que se implementan con una tabla hash para que no haya duplicados. Por lo tanto, la clase que se utilice como clave tiene que sobrescribir sus m\u00e9todos <code>equals()</code> y <code>hashCode()</code>.</p> <p>Veamos algunos m\u00e9todos de esta interfaz:</p> <ul> <li><code>boolean containsKey(Object key)</code>: devuelve true si el mapa contiene dicha clave.</li> <li><code>boolean containsValue(Object value)</code>: devuelve true si el mapa contiene dicho valor.</li> <li><code>V get(Object key)</code>: devuelve el valor asociado a la clave o null si no existe esa clave en el mapa.</li> <li><code>V getOrDefault(Object V, defaultValue)</code>: devuelve el valor asociado a la clave o defaultValue si no existe esa clave en el mapa.</li> <li><code>V put(K key, V value)</code>: a\u00f1ade un par clave-valor al mapa. Si ya hab\u00eda un valor para esa clave, se reemplaza. Devuelve el valor que ten\u00eda antes dicha clave o null si la clave no estaba en el mapa.</li> <li><code>V putIfAbsent(K key, V value)</code>: si la clave especificada no est\u00e1 ya asociada a un valor o est\u00e1 asignada a null, se le asocia el valor dado y devuelve null, en caso contrario, devuelve el valor previamente asociado con la clave.</li> <li><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code>: a\u00f1ade los pares claves-valor del mapa m.</li> <li><code>V remove(Object key)</code>: elimina la clave y su valor asociado, el cual se devuelve. Si no existe dicha clave, devuelve null.</li> </ul> <p>Existen varios tipos de implementaciones realizadas dentro de la plataforma Java:</p> <ul> <li><code>HashMap</code>: esta implementaci\u00f3n almacena las claves en una tabla hash. Es la implementaci\u00f3n con mejor rendimiento de todas pero no garantiza ning\u00fan orden a la hora de realizar iteraciones.</li> <li><code>LinkedHashMap</code>: esta implementaci\u00f3n almacena las claves en funci\u00f3n del orden de la inserci\u00f3n. Es un poco m\u00e1s costosa que <code>HashMap</code>.</li> <li><code>TreeMap</code>: esta implementaci\u00f3n utiliza la estructura del \u00e1rbol para ordenar las claves. Es bastante m\u00e1s lenta que <code>HashMap</code>. La veremos m\u00e1s adelante en el apartado de los \u00e1rboles.</li> </ul>"},{"location":"bloque_iii/tema_11/page-4/#clase-hashmap","title":"Clase HashMap","text":"<p>Esta implementaci\u00f3n proporciona tiempos constantes en las operaciones b\u00e1sicas siempre y cuando la funci\u00f3n hash disperse de forma correcta las claves dentro de la tabla hash. Es importante definir el tama\u00f1o inicial de la tabla ya que este tama\u00f1o marcar\u00e1 el rendimiento de esta implementaci\u00f3n. No garantiza ning\u00fan orden a la hora de recorrer el mapa.</p> <p>Veamos un ejemplo de un mapa de veh\u00edculos donde la clave es la matr\u00edcula. A\u00f1adimos la matr\u00edcula como atributo por lo que hay generar de nuevo los m\u00e9todos <code>toString()</code>, <code>hashCode()</code>y <code>equals()</code>:</p> VehicleShowHashMapConsola <pre><code>public class Vehicle{\nprivate final String registration; // Atributo para almacenar la matr\u00edcula del coche\nprivate final int wheelCount;\nprivate double speed;\nprivate String colour;\npublic Vehicle(String registration, int wheelCount, String colour){\nthis.registration = registration;\nthis.wheelCount = wheelCount;\nthis.colour = colour;\nspeed = 0;\n}\npublic int getWheelCount(){\nreturn wheelCount;\n}\npublic double getSpeed(){\nreturn speed;\n}\npublic String getColour(){\nreturn colour;\n}\npublic void setColour(String colour){\nthis.colour = colour;\n}\npublic String getRegistration(){\nreturn registration;\n}\npublic void accelerate(double amount){\nspeed += amount;\n}\npublic void brake(double amount){\nspeed -= amount;\n}\n@Override\npublic String toString(){\nreturn \"Vehicle [registration=\" + registration + \", wheelCount=\" + wheelCount + \", speed=\" + speed + \", colour=\" + colour + \"]\";\n}\n@Override\npublic int hashCode(){\nfinal int prime = 31;\nint result = 1;\nresult = prime * result + ((colour == null) ? 0 : colour.hashCode());\nresult = prime * result + ((registration == null) ? 0 : registration.hashCode());\nresult = prime * result + wheelCount;\nreturn result;\n}\n@Override\npublic boolean equals(Object obj){\nif(this == obj) return true;\nif(obj == null) return false;\nif(!(obj instanceof Vehicle other)) return false;\nif(colour == null){\nif(other.colour != null){\nreturn false;\n}\n} else if(!colour.equals(other.colour)){\nreturn false;\n}\nif(registration == null){\nif(other.registration != null){\nreturn false;\n}\n} else if(!registration.equals(other.registration)){\nreturn false;\n}\nreturn wheelCount == other.wheelCount;\n}\n}\n</code></pre> <pre><code>public class ShowHashMap {\npublic void show() {\nMap&lt;String, Vehicle&gt; map = new HashMap&lt;&gt;();\nMap&lt;String, Vehicle&gt; map2 = new HashMap&lt;&gt;();\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nfor (int i = 0; i &lt; vehicles.length; i++) {\nmap.put(vehicles[i].getRegistration(), vehicles[i]);\n}\nSystem.out.println(map.containsKey(\"1005SAW\"));//false\nSystem.out.println(map.containsKey(\"1705UBG\"));//true\nSystem.out.println(map.containsValue(new Vehicle(\"5930POI\", 4,\"negro\")));//false\nSystem.out.println(map.containsValue(new Vehicle(\"5930POI\", 2,\"negro\")));//true\nSystem.out.println(map.get(\"4554ASD\"));//null\nSystem.out.println(map.get(\"1705UBG\"));//Vehicle[registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nSystem.out.println(map.getOrDefault(\"8080SAS\", new Vehicle(\"4554ASD\", 4, \"negro\")));//Vehicle [registration=4554ASD, wheelCount=4, speed=0.0,colour=negro]\nSystem.out.println(map.getOrDefault(\"1705UBG\", new Vehicle(\"4554ASD\", 4, \"negro\")));//Vehicle [registration=1705UBG, wheelCount=4, speed=0.0,colour=blanco]\nSystem.out.println(map.put(\"6320LPL\", new Vehicle(\"6320LPL\", 2,\n\"verde\")));//null\nSystem.out.println(map.put(\"6320LPL\", new Vehicle(\"6320LPL\", 4,\n\"beis\")));//Vehicle [registration=6320LPL, wheelCount=2, speed=0.0,colour=verde]\nSystem.out.println(map.putIfAbsent(\"4687RTB\", new Vehicle(\"4687RTB\", 2, \"blanco\")));//null\nSystem.out.println(map.putIfAbsent(\"4687RTB\", new Vehicle(\"4687RTB\", 4, \"naranja\")));//Vehicle [registration=4687RTB, wheelCount=2, speed=0.0,colour=blanco]\nSystem.out.println(map.remove(\"1234ABC\"));//null\nSystem.out.println(map.remove(\"4687RTB\"));//Vehicle[registration=4687RTB, wheelCount=2, speed=0.0, colour=blanco]\nSystem.out.printf(\"El mapa tiene %d veh\u00edculos\", map.size());\nmap2.put(\"7410HJH\", new Vehicle(\"7410HJH\", 4, \"rojo\"));\nmap2.put(\"8520FGF\", new Vehicle(\"8520FGF\", 2, \"verde\"));\nmap.putAll(map2);//a\u00f1ade a map los pares clave-valor del mapa map2\nSystem.out.printf(\"\\nDespu\u00e9s de a\u00f1adirle map2, el mapa tiene %d veh\u00edculos\", map.size());\n}\npublic static void main(String[] args) {\nnew ShowHashMap().show();\n}\n}\n</code></pre> <pre><code>false\ntrue\nfalse\ntrue\nnull\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0 colour=blanco]\nVehicle [registration=4554ASD, wheelCount=4, speed=0.0, colour=negro]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nnull\nVehicle [registration=6320LPL, wheelCount=2, speed=0.0, colour=verde]\nnull\nVehicle [registration=4687RTB, wheelCount=2, speed=0.0, colour=blanco]\nnull\nVehicle [registration=4687RTB, wheelCount=2, speed=0.0, colour=blanco]\nEl mapa tiene 7 veh\u00edculos\nDespu\u00e9s de a\u00f1adirle map2, el mapa tiene 9 veh\u00edculos\n</code></pre> <p>Veamos las distintas maneras de recorrer un mapa:</p> <ul> <li><code>Set&lt;K&gt; keySet()</code>: devuelve un conjunto con todas las claves. como entre las claves no puede haber elementos duplicados, las claves forman un conjunto (Set).</li> <li><code>Collection&lt;V&gt; values()</code>: devuelve una colecci\u00f3n con todos los valores. Los valores s\u00ed pueden estar duplicados, por lo tanto, este m\u00e9todo devuelve un Collection.</li> <li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet</code>: devuelve un conjunto de objetos Map.Entry. Los pares de elementos (tambi\u00e9n llamados entradas) de los que est\u00e1 compuesto un Map son de un tipo que viene implementado por la interfaz Map.Entry. La interfaz Map.Entry se define de forma interna a la interfaz Map y representa un objeto de par clave-valor, es decir, mediante esta interfaz podemos trabajar con una entrada del mapa. Veamos algunos m\u00e9todos de la interfaz Map.Entry. <li><code>K getKey()</code>: retorna la clave.</li> <li><code>V getValue()</code>: retorna el valor.</li> <li><code>V setValue(V value)</code>: reemplaza el valor por value y devuelve el valor anterior.</li> TraverseHashMapConsola <pre><code>public class TraverseHashMap {\npublic void show() {\nMap&lt;String, Vehicle&gt; map = new HashMap&lt;&gt;();\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nfor (int i = 0; i &lt; vehicles.length; i++) {\nmap.put(vehicles[i].getRegistration(), vehicles[i]);\n}\nSystem.out.println(\"Claves del mapa:\\n\");\nfor (String s : map.keySet()) {//keySet() devuelve un conjunto con todas las claves\nSystem.out.println(s);\n}\nSystem.out.println(\"\\nValores del mapa:\\n\");\nfor (Vehicle v : map.values()) {//values() devuelve una colecci\u00f3n con todos los veh\u00edculos\nSystem.out.println(v);\n}\nSystem.out.println(\"\\nPares clave-valor del mapa usando un foreach:\\n\");\nfor (Map.Entry&lt;String, Vehicle&gt; entry : map.entrySet()) {\nSystem.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\",entry.getKey(), entry.getValue());\n}\nSystem.out.println(\"\\nPares clave-valor del mapa usando iteradores:\\n\");\nSet&lt;Map.Entry&lt;String, Vehicle&gt;&gt; entrySet = map.entrySet();\nIterator&lt;Map.Entry&lt;String, Vehicle&gt;&gt; it = entrySet.iterator();\nMap.Entry&lt;String, Vehicle&gt; entry;\nwhile (it.hasNext()) {\nentry = it.next();\nSystem.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\",\nentry.getKey(), entry.getValue());\n}\n}\npublic static void main(String[] args) {\nnew TraverseHashMap().show();\n}\n}\n</code></pre> <pre><code>Claves del mapa:\n\n3495JZA\n1705UBG\n1235GTR\n7314QWE\n9685KMX\n5930POI\n\nValores del mapa:\n\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nPares clave-valor del mapa usando un foreach:\n\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nMatr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nPares clave-valor del mapa usando iteradores:\n\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nMatr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-4/#clase-linkedhashmap","title":"Clase LinkedHashMap","text":"<p>Almacena las claves en funci\u00f3n del orden de inserci\u00f3n. Es un poco m\u00e1s costosa que <code>HashMap</code>.</p> MainConsola <pre><code>public class ShowLinkedHashMap {\npublic void show() {\nMap&lt;String, Vehicle&gt; map = new LinkedHashMap&lt;&gt;();\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nfor (int i = 0; i &lt; vehicles.length; i++) {\nmap.put(vehicles[i].getRegistration(), vehicles[i]);\n}\nfor (Map.Entry&lt;String, Vehicle&gt; entry : map.entrySet()) {\nSystem.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\",entry.getKey(), entry.getValue());\n}\n}\npublic static void main(String[] args) {\nnew ShowLinkedHashMap().show();\n}\n}\n</code></pre> <pre><code>Matr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nMatr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\n</code></pre> <p>Podemos observar que los datos se muestran en el mismo orden en el que se insertaron.</p>"},{"location":"bloque_iii/tema_11/page-4/#ejemplo-de-uso-de-un-mapa-en-un-enum","title":"Ejemplo de uso de un mapa en un enum","text":"<p>Si hemos sobrescrito el m\u00e9todo <code>toString()</code> o las instancias del enum tienen alguna forma adicional de referirnos a ellas, tiene bastante sentido que creemos un m\u00e9todo est\u00e1tico parecido a <code>valueOf()</code>, pero que reciba dicha forma adicional de referirnos a las instancias.</p> EnumMainConsola <pre><code>public enum Operation {\nPLUS(\"+\") {\n@Override\npublic double apply(double x, double y) {\nreturn x + y;\n}\n},\nMINUS(\"-\") {\n@Override\npublic double apply(double x, double y) {\nreturn x - y;\n}\n},\nTIMES(\"*\") {\n@Override\npublic double apply(double x, double y) {\nreturn x * y;\n}\n},\nDIVIDE(\"/\") {\n@Override\npublic double apply(double x, double y) {\nreturn x / y;\n}\n};\nprivate final String symbol;\nprivate static final Map&lt;String, Operation&gt; symbolToOperation = Map.of(Operation.PLUS.getSymbol(), Operation.PLUS, Operation.MINUS.getSymbol(), Operation.MINUS, Operation.TIMES.getSymbol(), Operation.TIMES,Operation.DIVIDE.getSymbol(), Operation.DIVIDE);\nprivate Operation(String symbol) {\nthis.symbol = symbol;\n}\npublic String getSymbol() {\nreturn symbol;\n}\npublic abstract double apply(double x, double y);\npublic static Operation fromSymbol(String symbol) {\nreturn symbolToOperation.get(symbol);\n}\n}\n</code></pre> <pre><code>public class ExampleUseMapEnum {\npublic void show() {\nOperation operation;\noperation = Operation.fromSymbol(\"+\");//operation se asigna con la instancia correspondiente al s\u00edmbolo +\nSystem.out.printf(\"La variable operation es de tipo enum %s y su s\u00edmbolo es %s\", operation, operation.getSymbol());\n}\npublic static void main(String[] args) {\nnew ExampleUseMapEnum().show();\n}\n}\n</code></pre> <pre><code>La variable operation es de tipo enum PLUS y su s\u00edmbolo es +\n</code></pre> <p>Como vemos en el c\u00f3digo anterior, creamos un mapa est\u00e1tico que relaciona cada s\u00edmbolo con cada instancia, de manera que podamos obtener la instancia adecuada a partir del s\u00edmbolo. Debemos tener en cuenta que no est\u00e1 permitido que los constructores de las instancias de un enum accedan a los atributos est\u00e1ticos del enum, con la excepci\u00f3n de las constantes de las instancias, dado que los atributos est\u00e1ticos a\u00fan no han sido inicializados cuando se est\u00e1n ejecutando los constructores de las instancias. Un caso especial de esta restricci\u00f3n es que en los constructores de las instancias tampoco se puede acceder a otras instancias del enum.</p>"},{"location":"bloque_iii/tema_11/page-4/#clases-enummap","title":"Clases EnumMap","text":"<p>Es una implementaci\u00f3n de mapa muy eficiente donde las claves son elementos de una enumeraci\u00f3n:</p> EnumMainConsola <pre><code>public enum Operation {\nPLUS(\"+\"), MINUS(\"-\"), TIMES(\"*\"), DIVIDE(\"/\");\nprivate final String symbol;\nprivate Operation(String symbol) {\nthis.symbol = symbol;\n}\npublic String getSymbol() {\nreturn symbol;\n}\n}\n</code></pre> <pre><code>public class ShowEnumMap {\npublic void show() {\nEnumMap&lt;Operation, String&gt; operationsMap = new EnumMap&lt;&gt;(Operation.class);\noperationsMap.put(Operation.PLUS, \"Esta operaci\u00f3n se utiliza para sumar\");\noperationsMap.put(Operation.MINUS, \"Esta operaci\u00f3n se utiliza para restar\");\noperationsMap.put(Operation.TIMES, \"Esta operaci\u00f3n se utiliza para multiplicar\");\noperationsMap.put(Operation.DIVIDE, \"Esta operaci\u00f3n se utiliza para dividir\");\nfor (Map.Entry&lt;Operation, String&gt; entry : operationsMap.entrySet()) {\nSystem.out.printf(\"%-6s: %s\\n\", entry.getKey(), entry.getValue());\n}\n}\npublic static void main(String[] args) {\nnew ShowEnumMap().show();\n}\n}\n</code></pre> <pre><code>PLUS : Esta operaci\u00f3n se utiliza para sumar\nMINUS : Esta operaci\u00f3n se utiliza para restar\nTIMES : Esta operaci\u00f3n se utiliza para multiplicar\nDIVIDE: Esta operaci\u00f3n se utiliza para dividir\n</code></pre>"},{"location":"bloque_iii/tema_11/page-5/","title":"5 \u00c1rboles","text":""},{"location":"bloque_iii/tema_11/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Los \u00e1rboles se caracterizan por almacenar sus nodos en forma jer\u00e1rquica y no en forma lineal como las listas</p> <p> Figura 1 - \u00c1rboles</p> <p>Un \u00e1rbol es una estructura en la que los datos se organizan en nodos. Los \u00e1rboles binarios son aquellos en los que un nodo solamente puede tener dos hijos como m\u00e1ximo. Se utilizan para ordenar datos, de tal manera que a la izquierda se colocan los valores menores y a la derecha los valores mayores. Un \u00e1rbol binario se puede recorrer de varias formas, siendo el recorrido inorden el que muestra los datos ordenados: sub\u00e1rbol izquierdo, ra\u00edz, sub\u00e1rbol derecho. Veamos un ejemplo.</p> <p> Figura 2 - Ejemplo \u00e1rbol</p> <p>Nos posicionamos en el 9. Mientras tenga sub\u00e1rbol izquierdo vamos avanzando hasta llegar al 1. Como es una hoja, la mostramos: el 1. Luego mostramos la ra\u00edz: el 3. Despu\u00e9s, continuamos con el sub\u00e1rbol derecho. Nos encontramos con el 6, pero tiene sub\u00e1rbol izquierdo, as\u00ed avanzamos hasta el 4. Como es una hoja, los mostramos: el 4. Luego, continuamos con la ra\u00edz: el 6. Despu\u00e9s, continuamos con el sub\u00e1rbol derecho, avanzando hasta el 7. Como es hoja, lo mostramos: el 7. Ya hemos tratado todo el sub\u00e1rbol izquierdo del 8, que es la ra\u00edz. Ahora mostramos la ra\u00edz: el 8 y a continuaci\u00f3n comenzamos con el sub\u00e1rbol derecho del 8. Y as\u00ed sucesivamente. El resultado final es: 1,3,4,6,7,8,10,13 y 14, es decir, los elementos ordenador de menor a mayor.</p> <p>Si queremos introducir un nuevo nodo en el \u00e1rbol, hay que tener en cuidado de no romper la estructura ni el orden del \u00e1rbol. Hay que tener en cuenta que cada nodo nunca se podr\u00e1 insertar como su hijo. Con esta restricci\u00f3n nos aseguramos de mantener la estructura del \u00e1rbol, pero a\u00fan nos falta mantener el orden. Para localizar el lugar adecuado del \u00e1rbol donde insertar el nuevo nodo se realizan comparaciones entre los nodos del \u00e1rbol y el elemento a insertar. El primer nodo que se compara es el nodo ra\u00edz, si el nuevo nodo es menor que el ra\u00edz, la b\u00fasqueda prosigue por el lado izquierdo de \u00e9ste. Si el nuevo nodo fuese mayor, la b\u00fasqueda seguir\u00eda por el hijo derecho. Y as\u00ed, sucesivamente hasta llegar a un nodo que no tenga hijo en la rama por la que la b\u00fasqueda deber\u00eda seguir. En este caso, el nuevo nodo se inserta en ese hueco, como su nuevo hijo.</p> <p>Por ejemplo, queremos insertar el elemento 9. Lo primero es comparar el nuevo elemento con el nodo ra\u00edz. Como 9 &gt; 8, entonces la b\u00fasqueda prosigue por el lado derecho. Ahora el nuevo nodo se compara con el elemento 10. En este caso 9 &lt; 10, por lo que hay que continuar la b\u00fasqueda por la rama izquierda. Como la rama izquierda de 10 no tiene ning\u00fan nodo, se inserta en ese lugar el nuevo nodo.</p> <p>La interfaz <code>SortedSet&lt;E&gt;</code> es la encargada de definir esta estructura. Esta interfaz es hija de <code>Set&lt;E&gt;</code>, que a su vez es hija de <code>Collection&lt;E&gt;</code>, que a su vez es hija de `Iterable. Por lo tanto, tiene los m\u00e9todos de todas y adem\u00e1s a\u00f1ade sus propios m\u00e9todos. <ul> <li><code>E first()</code>: devuelve el elemento m\u00e1s peque\u00f1o.</li> <li><code>E last()</code>: devuelve el elemento m\u00e1s grande.</li> <li><code>SortedSet&lt;E&gt; headSet(E toElement)</code>: devuelve un SortedSet que contendr\u00e1 todos los elementos menores que toElement.</li> <li><code>SortedSet&lt;E&gt; tailSet(E fromElement)</code>: devuelve un SortedSet que contendr\u00e1 todos los elementos mayores que fromElement.</li> <li><code>SortedSet&lt;E&gt; subSet(E fromElement, E toElement)</code>: devuelve un SortedSet que contendr\u00e1 los elementos que van desde fromElement incluido haste toElement excluido.</li> </ul> <p>Pero, \u00bfc\u00f3mo ordenamos los elementos por ejemplo veh\u00edculos? Para ello, Java nos proporciona dos interfaces: <code>Comparable&lt;T&gt;</code> y <code>Comparator&lt;T&gt;</code>. La diferencia entre ambas es que Comparable se implementa desde la propia clase que se quiere ordenar y Comparator^ no.</p>"},{"location":"bloque_iii/tema_11/page-5/#interfaz-comparable","title":"Interfaz Comparable","text":"<p>La interfaz <code>Comparable</code> contiene un \u00fanico m\u00e9todo, el m\u00e9todo <code>compareTo</code>, que recibe un objeto de la misma clase y que debe realizar una comparaci\u00f3n entre ambos objetos, retornando un valor entero negativo, cero o positivo, dependiendo de si el objeto sobre el que se ejecuta es respectivamente, menor, igual o mayor que el objeto recibido.</p> <p>La definici\u00f3n de la interfaz es la siguiente:</p> <pre><code>public interface Comparable&lt;T&gt;{\nint compareTo(T o);\n}\n</code></pre> <p>Por ejemplo, si quisi\u00e9ramos crear un \u00e1rbol para ordenar los veh\u00edculos lo primero que tendr\u00edamos que hacer es que la clase Vehicle implemente la interfaz Comparable y que el m\u00e9todo compareTo ordene por el atributo que deseemos. Por ejemplo, vamos a ordenar veh\u00edculos alfab\u00e9ticamente por el color. Como el color es de tipo String, debemos utilizar el compareTo de la clase String:</p> VehicleMain <pre><code>public class Vehicle implements Comparable&lt;Vehicle&gt; {\nprivate String registration;\nprivate int wheelCount;\nprivate double speed;\nprivate String colour;\npublic Vehicle(String registration, int wheelCount, String colour) {\nthis.registration = registration;\nthis.wheelCount = wheelCount;\nthis.colour = colour;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic String getColour() {\nreturn colour;\n}\npublic void setColour(String colour) {\nthis.colour = colour;\n}\npublic String getRegistration() {\nreturn registration;\n}\npublic void accelerate(double amount) {\nspeed += amount;\n}\npublic void brake(double amount) {\nspeed -= amount;\n}\n@Override\npublic String toString() {\nreturn \"Vehicle [registration=\" + registration + \", wheelCount=\" +  wheelCount + \", speed=\" + speed + \", colour=\"\n+ colour + \"]\";\n}\n@Override\npublic int compareTo(Vehicle o) {\nreturn colour.compareTo(o.colour);\n}\n}\n</code></pre> <pre><code>public class Compare{\npublic void show(){\nVehicle v1 = new Vehicle(\"9685KMX\", 4, \"azul\");\nVehicle v2 = new Vehicle(\"1235GTR\", 2, \"rojo\");\nVehicle v3 = new Vehicle(\"7314QWE\", 4, \"rojo\");\nSystem.out.println(v1.compareTo(v2)); // positivo -&gt; v1 &gt; v2\nSystem.out.println(v2.compareTo(v1)); // negativo -&gt; v2 &lt; v1\nSystem.out.println(v1.compareTo(v3)); // 0 -&gt; v1 == v3\n}\npublic static void main(String[] args){\nnew Compare().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_11/page-5/#interfaz-comparator","title":"Interfaz Comparator","text":"<p>La interfaz <code>Comparator&lt;T&gt;</code> es una interfaz que define el m\u00e9todo <code>compare</code>al que se le pasan los dos objetos a comparar y cuyo resultado es como el del compareTo (0 si son iguales, positivo si el primero es mayor y negativo si el segundo es mayor). Para definir un comparador de este forma, hay que crear una clase que implemente esta interfaz y definir el m\u00e9todo compare, despu\u00e9s crear un objeto de ese tipo y usarlo.</p> VehicleComparatorMain <pre><code>public class VehicleComparator implements Comparator&lt;Vehicle&gt;{\n@Override\npublic int compare(Vehicle o1, Vehicle o2){\nreturn o1.getColour().compareTo(o2.getColour());\n}\n}\n</code></pre> <pre><code>public class Comparator{\npublic void show(){\nVehicle v1 = new Vehicle(\"9685KMX\", 4, \"azul\");\nVehicle v2 = new Vehicle(\"1235GTR\", 2, \"rojo\");\nVehicle v3 = new Vehicle(\"7314QWE\", 4, \"rojo\");\nVehicleComparator comparator = new VehicleComparator();\nSystem.out.println(comparator.compare(v1, v2)); // positivo -&gt; v1 &gt; v2\nSystem.out.println(comparator.compare(v2, v1)); // negativo -&gt; v2 &lt; v1\nSystem.out.println(comparator.compare(v1, v3)); // 0 -&gt; v1 == v3\n}\npublic static void main(String[] args){\nnew Comparator().show();\n}\n}\n</code></pre> <p>Si dicha clase, solo va a ser utilizada una \u00fanica vez, se recomienda usar una clase an\u00f3nima en l\u00ednea:</p> <pre><code>public class ComparatorAnonymous{\npublic void show(){\nVehicle v1 = new Vehicle(\"9685KMX\", 4, \"azul\");\nVehicle v2 = new Vehicle(\"1235GTR\", 2, \"rojo\");\nVehicle v3 = new Vehicle(\"7314QWE\", 4, \"rojo\");\nComparator comparator = new Comparator&lt;Vehicle&gt;(){\n@Override\npublic int compare(Vehicle o1, Vehicle o2){\nreturn o1.getColour().compareTo(o2.getColour());\n}\n};\nSystem.out.println(comparator.compare(v1, v2)); // positivo -&gt; v1 &gt; v2\nSystem.out.println(comparator.compare(v2, v1)); // negativo -&gt; v2 &lt; v1\nSystem.out.println(comparator.compare(v1, v3)); // 0 -&gt; v1 == v3\n}\npublic static void main(String[] args){\nnew ComparatorAnonymous().show();\n}\n}\n</code></pre> <p>Para ordenar descendientemente se cambiar\u00eda el orden de <code>o1</code> por el de <code>o2</code>.</p>"},{"location":"bloque_iii/tema_11/page-5/#usos-de-comparable-y-comparator","title":"Usos de comparable y comparator","text":"<p>Cuando creemos clases que representen valores que posean un determinado orden natural, como por ejemplo un orden alfab\u00e9tico, num\u00e9rico o cronol\u00f3gico, deberemos hacer que dicha clase implemente la interfaz  Comparable, permitiendo as\u00ed que los objetos de dicha clase puedan trabajar con mucho algoritmos gen\u00e9ricos e implementaciones de colecciones que dependen de dicha interfaz.</p> <p>La mayor\u00eda de las clases est\u00e1ndar que representan valores y de las clases enums incorporadas a Java,  implementan  la  interfaz  Comparable,  como  por  ejemplo  la  clase  String.  Las  clases  que definamos nosotros que representen valores tambi\u00e9n deber\u00edan implementarla.</p> <p>A la hora de realizar la implementaci\u00f3n debemos respetar una serie de reglas:</p> <ul> <li><code>x.compareTo(y) == -y.compareTo(x)</code>  para todo valor de  x  e  y .</li> <li>La relaci\u00f3n es transitiva, es decir, que si  <code>(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt;0)</code> entonces  <code>x.compareTo(z) &gt; 0</code>.</li> <li>Si  <code>x.compareTo(y) == 0</code>  entonces  <code>x.compareTo(z) == y.compareTo(z)</code> para cualquier valor de  z.</li> <li>Aunque  no  es  obligatorio  se  recomienda  que  <code>(x.compareTo(y) == 0)</code> == <code>(x.equals(y))</code>.</li> </ul> <p>Si para comparar los objetos debemos comparar un atributo de un tipo primitivo, se recomienda usar los m\u00e9todos est\u00e1ticos de comparaci\u00f3n  compare   de  las  clases  boxed  correspondientes, como <code>Long.compare()</code>,  <code>Float.compare()</code>, etc., disponibles a partir de Java 7, en vez de usar los operadores <code>&lt;</code>  o <code>&gt;</code>, ya que son menos verbosos y propensos al error:</p>"},{"location":"bloque_iii/tema_11/page-5/#clase-treeset","title":"Clase TreeSet","text":"<p>La clase <code>TreeSet&lt;E&gt;</code> es la que se utiliza prioritariamente para trabajar con \u00e1rboles ordenados ya que implementa la interfaz <code>SortedSet&lt;E&gt;</code>.</p> <p>Los objetos a incluir en un TreeSet deben implementar Comparable o bien crear el \u00e1rbol con un constructor que reciba un Comparator</p> <p>Ejemplo:</p> VehicleMainConsola <pre><code>public class Vehicle implements Comparable&lt;Vehicle&gt; {\nprivate String registration;\nprivate int wheelCount;\nprivate double speed;\nprivate String colour;\npublic Vehicle(String registration, int wheelCount, String colour) {\nthis.registration = registration;\nthis.wheelCount = wheelCount;\nthis.colour = colour;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic double getSpeed() {\nreturn speed;\n}\npublic String getColour() {\nreturn colour;\n}\npublic void setColour(String colour) {\nthis.colour = colour;\n}\npublic String getRegistration() {\nreturn registration;\n}\npublic void accelerate(double amount) {\nspeed += amount;\n}\npublic void brake(double amount) {\nspeed -= amount;\n}\n@Override\npublic String toString() {\nreturn \"Vehicle [registration=\" + registration + \", wheelCount=\" +  wheelCount + \", speed=\" + speed + \", colour=\"\n+ colour + \"]\";\n}\n@Override\npublic int compareTo(Vehicle o) {\nreturn colour.compareTo(o.colour);\n}\n}\n</code></pre> <pre><code>public class TreeSet1{\npublic void show(){\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;();\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"negro\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"naranja\"));\nfor(Vehicle v: tree){\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args){\nnew TreeSet1().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=naranja]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Pero, \u00bfqu\u00e9 ocurrir\u00eda si tuvi\u00e9ramos colores repetidos?:</p> MainConsola <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\npublic class TreeSet2 {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;();\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew TreeSet2().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Los tres primero veh\u00edculos se introducen en el \u00e1rbol. Cuando se va a introducir el cuarto que es de color azul, el \u00e1rbol lo va comparando con compareTo con los veh\u00edculos que ya existen el \u00e1rbol para encontrar la posici\u00f3n ordenada donde incluirlo. Pero cuando lo compara con el que es azul, el compareTo, devuelve 0, por lo que el \u00e1rbol interpreta que ese objeto ya existe en el \u00e1rbol, que es igual a otro, por lo tanto no lo incluye en el \u00e1rbol. Lo mismo ocurre con el quinto y el sexto. Por lo tanto, lo que ocurrir\u00eda es que los 3 \u00faltimos no se introducen en el \u00e1rbol porque compareTo devuelve 0 entre veh\u00edculos del mismo color, por lo que el \u00e1rbol considera que son iguales. En estos casos, lo que se hace es que se incluye un segundo criterio de comparaci\u00f3n: vamos a ordenar por el color, y en aquellos casos donde los veh\u00edculos tengan el mismo color entonces vamos a ordenar por matr\u00edcula.</p> VehicleMainConsola <pre><code>public class Vehicle implements Comparable&lt;Vehicle&gt;{\n//...\n@Override\npublic int compareTo(Vehicle o){\nint result = colour.compareTo(o.colour);\nif(result == 0){\nresult = registration.compareTo(o,registration);\n}\nreturn result;\n}\n}\n</code></pre> <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\npublic class ShowTreeSet {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;();\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew ShowTreeSet().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Pero, \u00bfqu\u00e9 ocurrir\u00eda si la clase Vehicle no implementase la interfaz Comparable? Pues que no contendr\u00eda el m\u00e9todo compareTo, entonces el \u00e1rbol no tendr\u00eda la informaci\u00f3n de c\u00f3mo ordenar los veh\u00edculos. En este caso, se lanzar\u00eda una excepci\u00f3n <code>ClassCastException</code>.</p> VehicleMainConsola <pre><code>public class Vehicle{\n//...\n// No contiene el m\u00e9todo compareTo\n}\n</code></pre> <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\npublic class ShowException{\npublic void show(){\nSortedSet&lt;Vehicle&gt; = new TreeSet&lt;&gt;();\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"negro\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"naranja\"));\nfor(Vehicle v: tree){\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args){\nnew ShowException().show();\n}\n}\n</code></pre> <pre><code>Exception in thread \"main\" java.lang.ClassCastException: class \ntema11_Colecciones.arboles3.Vehicle cannot be cast to class\njava.lang.Comparable (tema11_Colecciones.arboles3.Vehicle is in unnamed module\nof loader 'app'; java.lang.Comparable is in module java.base of loader\n'bootstrap')\nat java.base/java.util.TreeMap.compare(TreeMap.java:1291)\nat java.base/java.util.TreeMap.put(TreeMap.java:536)\nat java.base/java.util.TreeSet.add(TreeSet.java:255)\nat tema11_Colecciones.arboles3.ShowException.show(ShowException.java:11)\nat tema11_Colecciones.arboles3.ShowException.main(ShowException.java:25)\n</code></pre> <p>Otra posibilidad es utilizar un objeto <code>Comparator&lt;E&gt;</code>. Para ello, se crea la clase que implementa dicha interfaz y se usar\u00eda en la construcci\u00f3n del \u00e1rbol mediante un constructor que recibe un Comparator: <code>TreeSet(Comparator&lt;? super E&gt; comparator)</code>. En este caso, \u00e9sa ser\u00e1 la forma prioritaria para ordenar la lista, por encima del m\u00e9todo compareTo de la interfaz Comparable. Como ya dijimos anteriormente, la diferencia entre Comparable y Comparator es que Comparable se implementa desde la propia clase que se quiere ordenar y Comparator no, ya que Comparator se implementa desde otra clase distinta a la que se quiere ordenar:</p> VehicleComparatorMainConsola <pre><code>import java.util.comparator;\npublic class VehicleComparator implements Comparator&lt;Vehicle&gt;{\n@Override\npublic int compare(Vehicle o1, Vehicle o2){\nint result = o1.getColour().compareTo(o2.getColour());\nif(result == 0){\nresult = o1.getRegistration().compareTo(o2.getRegistration());\n}\nreturn result;\n}\n}\n</code></pre> <pre><code>import java.util.SortedSet;\nimport java.util.TreeSet;\npublic class ShowComparator {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new VehicleComparator());\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew ShowComparator().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Pero si esta comparaci\u00f3n la vamos a utilizar solamente una vez, tenemos que crear una clase solamente para su uso. Y si necesitamos ordenar los veh\u00edculos de varias maneras, tenemos que tener una clase por cada criterio de ordenaci\u00f3n. En estos casos, podemos utilizar una clase inline an\u00f3nima:</p> MainConsola <pre><code>import java.util.Comparator;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\npublic class AnonymousComparator {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new Comparator&lt;Vehicle&gt;(){\n@Override\npublic int compare(Vehicle o1, Vehicle o2){\nint result = o1.getColour().compareTo(o2.getColour());\nif(result == 0){\nresult = o1.getRegistration().compareTo(o2.getRegistration());\n}\nreturn result;\n}\n});\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew AnonymousComparator().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Si quisi\u00e9ramos ordenar de manera descendente, cambiamos el orden entre o1 y o2, es decir, hacemos que sea o2 el que ejecute el compareTo</p> MainConsola <pre><code>import java.util.Comparator;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\npublic class DescendingOrder {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new Comparator&lt;Vehicle&gt;(){\n/*\n             * Si quisi\u00e9ramos ordenar de manera descendente,\n             * cambiamos el orden entre o1 y o2, es decir,\n             * hacemos que sea o2 el que ejecute el compareTo\n             */\n@Override\npublic int compare(Vehicle o1, Vehicle o2){\nint result = o2.getColour().compareTo(o1.getColour());\nif(result == 0){\nresult = o2.getRegistration().compareTo(o1.getRegistration());\n}\nreturn result;\n}\n});\ntree.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ntree.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ntree.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\ntree.add(new Vehicle(\"5930POI\", 2, \"azul\"));\ntree.add(new Vehicle(\"1705UBG\", 4, \"rojo\"));\ntree.add(new Vehicle(\"3495JZA\", 2, \"verde\"));\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew DescendingOrder().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Los comparadores de tipo Comparator permiten ordenar de diferentes formas, por eso en la pr\u00e1ctica se utilizan mucho. Por ejemplo, el m\u00e9todo sort de la clase Arrays tambi\u00e9n admite indicar un comparador para saber de qu\u00e9 forma deseamos ordenar el array.</p> CompareBoxedClassesConsola <pre><code>import java.util.Comparator;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\npublic class CompareBoxedClasses {\npublic void show() {\nSortedSet&lt;Vehicle&gt; tree = new TreeSet&lt;&gt;(new Comparator&lt;Vehicle&gt;() {\n@Override\npublic int compare(Vehicle o1, Vehicle o2) {\nint result = Integer.compare(o1.getWheelCount(), o2.getWheelCount());\nif (result == 0) {\nresult = Double.compare(o1.getSpeed(), o2.getSpeed());\n}\nreturn result;\n}\n});\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[0].accelerate(100);\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[1].accelerate(150);\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[2].accelerate(200);\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[3].accelerate(80);\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[4].accelerate(75);\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nvehicles[5].accelerate(170);\nfor (int i = 0; i &lt; vehicles.length; i++) {\ntree.add(vehicles[i]);\n}\nfor (Vehicle v : tree) {\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args) {\nnew CompareBoxedClasses().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=5930POI, wheelCount=2, speed=80.0, colour=negro]\nVehicle [registration=1235GTR, wheelCount=2, speed=150.0, colour=rojo]\nVehicle [registration=3495JZA, wheelCount=2, speed=170.0, colour=naranja]\nVehicle [registration=1705UBG, wheelCount=4, speed=75.0, colour=blanco]\nVehicle [registration=9685KMX, wheelCount=4, speed=100.0, colour=azul]\nVehicle [registration=7314QWE, wheelCount=4, speed=200.0, colour=verde]\n</code></pre>"},{"location":"bloque_iii/tema_11/page-5/#clase-treemap","title":"Clase TreeMap","text":"<p>Esta implementaci\u00f3n utiliza una estructura de \u00e1rbol que permite que los elementos del mapa se ordenen en sentido ascendente seg\u00fan la clave, por lo tanto, la clase de las claves tiene que implementar la interfaz Comparable o bien indicar un objeto Comparator durante la creaci\u00f3n del TreeMap.</p> <p>TreeMap implementa la interfaz  <code>SortedMap</code>  que, a su vez, es heredera de  <code>Map</code> , por lo que todo lo dicho sobre los mapas funciona con las colecciones de tipo TreeMap.</p> MainConsola <pre><code>import java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\npublic class ShowTreeMap {\npublic void show() {\nSortedMap&lt;String, Vehicle&gt; sortedMap = new TreeMap&lt;&gt;();\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nfor (int i = 0; i &lt; vehicles.length; i++) {\nsortedMap.put(vehicles[i].getRegistration(), vehicles[i]);\n}\nfor (Map.Entry&lt;String, Vehicle&gt; entry : sortedMap.entrySet()) {\nSystem.out.printf(\"Matr\u00edcula -&gt; %s Veh\u00edculo -&gt; %s\\n\", entry.getKey(), entry.getValue());\n}\n}\npublic static void main(String[] args) {\nnew ShowTreeMap().show();\n}\n</code></pre> <pre><code>Matr\u00edcula -&gt; 1235GTR Veh\u00edculo -&gt; Vehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nMatr\u00edcula -&gt; 1705UBG Veh\u00edculo -&gt; Vehicle [registration=1705UBG, wheelCount=4,\nspeed=0.0, colour=blanco]\nMatr\u00edcula -&gt; 3495JZA Veh\u00edculo -&gt; Vehicle [registration=3495JZA, wheelCount=2,\nspeed=0.0, colour=naranja]\nMatr\u00edcula -&gt; 5930POI Veh\u00edculo -&gt; Vehicle [registration=5930POI, wheelCount=2,\nspeed=0.0, colour=negro]\nMatr\u00edcula -&gt; 7314QWE Veh\u00edculo -&gt; Vehicle [registration=7314QWE, wheelCount=4,\nspeed=0.0, colour=verde]\nMatr\u00edcula -&gt; 9685KMX Veh\u00edculo -&gt; Vehicle [registration=9685KMX, wheelCount=4,\nspeed=0.0, colour=azul]\n</code></pre> <p>Como podemos observar, est\u00e1 ordenado ascendentemente por la matr\u00edcula ya que la matr\u00edcula es de tipo <code>String</code> que implementa la interfaz  <code>Comparable</code>. Si la clave fuera una clase hecha por nosotros, tendr\u00edamos que hacer que implementara Comparable o bien indicar un Comparator en la creaci\u00f3n del TreeMap.</p>"},{"location":"bloque_iii/tema_11/page-6/","title":"6 Pilas y colas","text":""},{"location":"bloque_iii/tema_11/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Una cola es un tipo de dato que sigue el principio FIFO (first in, first out) que implica que el primer elemento en ser insertado en la cola es tambi\u00e9n el primero en ser eliminado de la misma.</p> <p>En el mundo real podemos encontrar este ejemplo en las colas de un banco, la cadena de impresi\u00f3n de documentos, etc. En el caso de la cola en el banco, la primera persona en llegar es tambi\u00e9n la primera en irse (suponiendo una \u00fanica ventanilla) y en los documentos a imprimir, la impresora imprime seg\u00fan el orden de llegada.</p> <p><code>Queue&lt;E&gt;</code> es una interfaz que hereda de Collection que proporciona operaciones para trabajar con una cola. Veamos alguna de ellas:</p> <ul> <li><code>boolean add(E e)</code>: inserta el elemento al final de la cola.</li> <li><code>E  element()</code>: Devuelve, pero no elimina,  el principio de la cola. Lanza la excepci\u00f3n <code>NoSuchElementException</code> si la cola est\u00e1 vac\u00eda.</li> <li><code>E peek()</code>:Devuelve, pero no elimina, el principio de la cola. Devuelve null si la cola est\u00e1 vac\u00eda.</li> <li><code>E poll()</code>: Devuelve y elimina el principio de la cola. Devuelve null si la cola est\u00e1 vac\u00eda.</li> <li><code>E  remove()</code>: Devuelve y elimina el principio de la cola. Lanza la excepci\u00f3n <code>NoSuchElementException</code> si la cola est\u00e1 vac\u00eda.</li> </ul> <p><code>Deque&lt;E&gt;</code> representa  una  cola  de  doble  extremo,  lo  que  significa  que  se  puede  insertar  y eliminar elementos desde ambos extremos de la cola. El nombre Deque es una abreviatura de Double Ended Queue. Admite,  por  lo  tanto, la  implementaci\u00f3n  de  la  cola  FIFO  como  la implementaci\u00f3n de la pila LIFO, que implica que el \u00faltimo elemento que se ha insertado, es el primero en ser eliminado: LIFO (last in, first out).</p> <p>Deque hereda de Queue, por lo que tiene todos sus m\u00e9todos y adem\u00e1s a\u00f1ade los suyos propios.Veamos algunos de ellos:</p> <ul> <li><code>void addFirst(E e)</code>: inserta el elemento al principio.</li> <li><code>void addLast(E e)</code>: inserta el elemento al final.</li> <li><code>E  getFirst()</code>: Devuelve, pero no  elimina,  el  primer  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code>  si el Deque est\u00e1 vac\u00edo.</li> <li><code>E  getLast()</code>: Devuelve, pero no elimina,  el  \u00faltimo  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code> si el Deque est\u00e1 vac\u00edo.</li> <li><code>E peekFirst()</code>: Devuelve, pero no elimina, el primer elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E peekLast()</code>: Devuelve, pero no elimina, el \u00faltimo elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E pollFirst()</code>: Devuelve y elimina el primer elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E pollLast()</code>: Devuelve y elimina el \u00faltimo elemento. Devuelve null si el Deque est\u00e1 vac\u00edo.</li> <li><code>E  removeFirst()</code>: Devuelve  y  elimina  el  primer  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code> si el Deque est\u00e1 vac\u00edo.</li> <li><code>E  removeLast()</code>: Devuelve y elimina el \u00faltimo  elemento.  Lanza  la  excepci\u00f3n <code>NoSuchElementException</code> si el Deque est\u00e1 vac\u00edo.</li> </ul>"},{"location":"bloque_iii/tema_11/page-6/#clase-arraydeque","title":"Clase ArrayDeque","text":"<p>La clase <code>ArrayDeque&lt;E&gt;</code> implementa la interfaz Deque y por lo tanto, tambi\u00e9n Queue, ya que Deque hereda de Queue.</p> ColaConsola ColaPilaConsola Pila <p><pre><code>import java.util.ArrayDeque;\nimport java.util.Queue;\npublic class ShowQueue{\npublic void show(){\nQueue&lt;Vehicle&gt; queue = new ArrayDeque();\nqueue.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\nqueue.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\nqueue.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\nSystem.out.println(queue.element()); //(1)!\nSystem.out.println(queue.peek());//(2)!\nSystem.out.println(queue.poll());//(3)!\nSystem.out.println(queue.remove());//(4)!\nSystem.out.println(queue.remove());//(5)!\nSystem.out.println(queue.peek());//(6)!\nSystem.out.println(queue.poll());//(7)!\nSystem.out.println(queue.element());//(8)!\nSystem.out.println(queue.remove());//(9)!\n}\npublic static void main(String[] args){\nnew ShowQueue().show();\n}\n}\n</code></pre> 1. Devuelve pero no elimina 9685KMX 1. Devuelve pero no elimina: 9685KMX 1. Devuelve y elimina: 9685KMX 1. Devuelve y elimina: 1235GTR 1. Devuelve y elimina el \u00faltimo, se queda la cola vac\u00eda: 7314QWE 1. Devuelve null 1. Devuelve null 1. Lanza NoSuchElementException porque la cola est\u00e1 vac\u00eda 1. Lanza NoSuchElementException porque la cola est\u00e1 vac\u00eda</p> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nnull\nnull\nException in thread \"main\" java.util.NoSuchElementException\nat java.base/java.util.ArrayDeque.getFirst(ArrayDeque.java:402)\nat java.base/java.util.ArrayDeque.element(ArrayDeque.java:551)\nat tema11_Colecciones.pilasYColas.ShowQueue.show(ShowQueue.java:21)\nat tema11_Colecciones.pilasYColas.ShowQueue.main(ShowQueue.java:28)\n</code></pre> <pre><code>import java.util.ArrayDeque;\nimport java.util.Deque;\npublic class ShowDeque{\npublic void show(){\nQueue&lt;Vehicle&gt; deque = new ArrayDeque();\ndeque.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\ndeque.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\ndeque.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\nSystem.out.println(deque.element()); //(1)!\nSystem.out.println(deque.peek());//(2)!\nSystem.out.println(deque.poll());//(3)!\nSystem.out.println(deque.remove());//(4)!\nSystem.out.println(deque.remove());//(5)!\nSystem.out.println(deque.peek());//(6)!\nSystem.out.println(deque.poll());//(7)!\nSystem.out.println(deque.element());//(8)!\nSystem.out.println(deque.remove());//(9)!\n}\npublic static void main(String[] args){\nnew ShowDeque().show();\n}\n}\n</code></pre> <ol> <li>Devuelve pero no elimina 7314QWE</li> <li>Devuelve pero no elimina: 7314QWE</li> <li>Devuelve y elimina: 7314QWE</li> <li>Devuelve y elimina: 1235GTR</li> <li>Devuelve y elimina el \u00faltimo, se queda la pila vac\u00eda: 9685KMX</li> <li>Devuelve null</li> <li>Devuelve null</li> <li>Lanza NoSuchElementException porque la pila est\u00e1 vac\u00eda</li> <li>Lanza NoSuchElementException porque la pila est\u00e1 vac\u00eda</li> </ol> <pre><code>Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nnull\nnull\nException in thread \"main\" java.util.NoSuchElementException\nat java.base/java.util.ArrayDeque.getLast(ArrayDeque.java:413)\nat tema11_Colecciones.pilasYColas.ShowDeque.show(ShowDeque.java:21)\nat tema11_Colecciones.pilasYColas.ShowDeque.main(ShowDeque.java:28)\n</code></pre>"},{"location":"bloque_iii/tema_11/page-6/#clase-collections","title":"Clase Collections","text":"<p>La clase  Collections  contiene numerosos m\u00e9todos est\u00e1ticos para utilizar con todo tipo de colecciones,  como  por  ejemplo,  para  a\u00f1adir,  buscar,  copiar,  reemplazar,  ordenar,  obtener  el m\u00e1ximo o el m\u00ednimo, etc.</p>"},{"location":"bloque_iii/tema_11/page-7/","title":"Ejercicios","text":"Ejercicio 1 <p>Utilizando la clase gen\u00e9rica caja del bolet\u00edn de gen\u00e9ricos, haz un programa que haga lo siguiente:</p> <ul> <li>Guardar en una lista 5 cajas de cadenas. Recorrer la lista y mostrar por pantalla el contenido de todas las cajas. Mostrar una concatenaci\u00f3n de todas las cadenas.</li> <li>Guardar en otra lista 5 cajas de long. Recorrer la lista y mostrar por pantalla el contenido de las cajas. Mostrar un resultado de sumarlas todas.</li> </ul> Ejercicio 2 <p>Realiza una interfaz gen\u00e9rica que contenga dos m\u00e9todo:     T primerContenido();     T ultimoContenido();</p> <p>Realizar una clase Almacen que contenga una lista de cajas. Dicha clase debe implementar esa interfaz. Los m\u00e9todos devolver\u00e1n el contenido de la primera caja y el contenido de la \u00faltima caja respectivamente.</p> Ejercicio 3 <p>Realiza el siguiente men\u00fa para gestionar una lista simplemente enlazada de cadenas:</p> <ol> <li>Nueva lista</li> <li>N\u00famero de cadenas</li> <li>A\u00f1adir cadena</li> <li>Eliminar cadena</li> <li>Contiene cadena</li> <li>Mostrar lista entera</li> <li>Salir</li> </ol> <p>En la opci\u00f3n 1, se limpiar\u00e1 toda la lista dejando la lista vac\u00eda. En la opci\u00f3n 5, se le pedir\u00e1 una cadena al usuario y se le dir\u00e1 si est\u00e1 o no en la lista.</p> Ejercicio 4 <p>Rellena una lista simplemente enlazada circular de n\u00fameros decimales de tipo float. A continuaci\u00f3n, presentar el siguiente men\u00fa.</p> <ol> <li>Mostrar la lista</li> <li>Mostrar siguiente</li> <li>Eliminar \u00faltimo mostrado</li> <li>Salir</li> </ol> <p>En la opci\u00f3n 2, la primera vez que se ejecute saldr\u00e1 el primero de la lista. La Siguiente vez el segundo, y as\u00ed sucesivamente. Si el \u00faltimo mostrado ha sido el \u00faltimo y se le vuelve a dar esta opci\u00f3n, entonces se mostrar\u00e1 el primero. En la opci\u00f3n 3, se elimina el \u00faltimo mostrado por la opci\u00f3n 2.</p> Ejercicio 5 <p>Realiza el mismo ejercicio anterior pero con una lista doblemente enlazada circular. A\u00f1\u00e1dele una opci\u00f3n nueva al men\u00fa que sea 'Mostrar anterior'.</p> Ejercicio 6 <p>Realiza el siguiente men\u00fa para gestionar una pila de n\u00fameros de tipo byte.</p> <ol> <li>Nueva pila</li> <li>Consultar elemento</li> <li>A\u00f1adir elemento</li> <li>Eliminar elemento</li> <li>Consultar toda la pila</li> <li>Salir</li> </ol> Ejercicio 7 <p>Realiza el ejercicio anterior pero con una cola.</p> Ejercicio 8 <p>Un videoclub quiere que le hagamos una aplicaci\u00f3n para registrar sus pel\u00edculas. Los requisitos que nos exigen son los siguientes:</p> <ul> <li>Enum Genero<ul> <li>3 valores: COMEDIA, FICCION, TERROR<ul> <li>M\u00e9todo getCodigo que devuelva el siguiente car\u00e1cter para cada valor:<ul> <li>COMEDIA: C</li> <li>FICCION: F</li> <li>TERROR: T</li> </ul> </li> </ul> </li> </ul> </li> <li>Clase Clave:<ul> <li>Atributos: enum Genero y un n\u00famero entero</li> <li>Atributos privados y solamente los getters necesarios</li> <li>M\u00e9todo toString: devuelve una cadena concatenando del enum con el n\u00famero entero. Ej: C1, F2, T3</li> <li>M\u00e9todo est\u00e1tico asignarClave: recibe un g\u00e9nero y devuelve un objeto de tipo Clave. El n\u00famero de la clave ser\u00e1 1 para la primera pel\u00edcula de comedia, 1 para la primera pel\u00edcula de terror, ..., 2 para las segundas, etc.</li> </ul> </li> <li>Clase Pel\u00edcula<ul> <li>Atributos:<ul> <li>Clave: objeto de la clase Clave</li> <li>Nombre</li> <li>FechaEstreno. fecha de estreno en Espa\u00f1a</li> <li>FechaDVD: fecha de venta en DVD</li> </ul> </li> <li>Atributos privados y solamente los getters necesarios</li> <li>Constructor: <code>Pelicula(String nombre, Genero genero, LocalDate fechaEstreno, LocalDate fechaDVD)</code></li> <li>Criterio de comparaci\u00f3n de la clase: descendientemente por d\u00edas que ha tardado la pel\u00edcula en salir en DVD desde que se estren\u00f3. Si dos pel\u00edculas tienen el mismo n\u00famero de d\u00edas, ordenarlas ascendentemente por orden alfab\u00e9tico del nombre.</li> </ul> </li> <li> <ul> <li>Se crear\u00e1n pel\u00edculas de la siguiente tabla:</li> </ul> <p>Clase Videoclub: esta clase contendr\u00e1 la l\u00f3gica con varias colecciones para hacer lo siguiente:</p> Orden de la inserci\u00f3n en la colecciones Nombre G\u00e9nero Clave Fecha Estreno Fecha DVD 1 Poltergeist, juegos diab\u00f3licos Terror T1 22/05/2015 22/09/2015 2 La cumbre escarlata Terror T2 09/10/2015 12/02/2016 3 Ocho apellidos catalanes Comedia C1 20/112015 18/03/2016 4 Padres por desigual Comedia C2 01/01/2016 11/05/2016 5 Star Wars: El despertar de la Fuerza Ficci\u00f3n F1 18/12/2015 20/04/2016 6 Mad Max: Furia en la carretera Ficci\u00f3n F2 15/05/2015 01/09/2015 7 Clon de Poltergeist, juegos diab\u00f3licos 8 Clon de Star Wars: El despertar de la fuerza <ul> <li>Utilizar las colecciones oportunas para crear la siguiente salida por consola exactamente igual. Insertar las pel\u00edculas en las colecciones en el orden indicado en la primera columna de la tabla. Tener en cuenta lo siguiente:<ul> <li>En el 3, utiliza un Comparator de manera an\u00f3nima</li> <li>En el 4, el criterio de comparaci\u00f3n de la clave es primera las de ficci\u00f3n, luego las de terror y por \u00faltimo las de comedia. A igualdad de g\u00e9nero, se ordena ascendentemente por el n\u00famero de la clave. Es decir, el orden ser\u00eda: F1, F2, T1, T2, C1, C2.</li> <li>En el 5, utilizar ListIterator.</li> </ul> </li> </ul> </li> </ul> <p>Salidas por consola:  </p> Ejercicio 9 <p>Realiza una aplicaci\u00f3n para gestionar los ex\u00e1menes de junio de 1\u00baCFGS de Aplicaciones Multiplataforma. Se crear\u00e1n los ex\u00e1menes que aparecen en la siguiente tabla y se insertar\u00e1n en todas las colecciones en el orden indicado en la primera columna de la tabla. La clave estar\u00e1 formada por el d\u00eda del examen, un guion y la hora de inicio y ser\u00e1 autogenerada por la clase. La fecha tiene que ser mostrada con el formato d\u00eda/mes/a\u00f1o, tal y como est\u00e1 en la tabla.</p> Orden de inserci\u00f3n en las colecciones Asignatura Descripci\u00f3n Fecha Hora de Inicio Hora de Fin Clave 1 Programaci\u00f3n Herencia y colecciones 16/06/2017 08:15 13:30 16-08:15 2 Base de datos Disparadores y SQL 15/06/2017 11:45 14:30 15-11:45 3 Sistemas Inform\u00e1ticos Sistemas en red 20/06/2017 10:15 11:35 20-10:15 4 Entornos de Desarrollo Diagramas de clases 19/06/2017 09:15 11:15 19-09:15 5 Lenguaje de Marcas Hojas de estilo 14/06/2017 08:15 11:15 13-10:15 6 FOL Derechos del trabajador 13/06/2017 10:15 11:15 13-10:15 7 Base de datos Entidad-Relaci\u00f3n 15/06/2017 08:15 11:30 15-08:15 8 Clon de Programaci\u00f3n 9 Clon de Lenguaje de Marcas <p>Realizar con dichos ex\u00e1menes lo siguiente, teniendo en cuenta que las salidas en consola est\u00e9n bien alineadas y que las horas tienen que salir con dos d\u00edgitos. Ejemplo 08:15</p> <ol> <li>Insertarlos en un ArrayList. Muestra el contenido del ArrayList.</li> <li>Inserta los ex\u00e1menes en una colecci\u00f3n sin duplicados que mantenga el orden de inserci\u00f3n. Muestra la colecci\u00f3n sin duplicados.</li> <li>Muestra el contenido de la colecci\u00f3n sin duplicados del apartado 2 al rev\u00e9s.</li> <li>Utilizando la interfaz List, solic\u00edtale al usuario los valores necesarios para mostrar una sublista de la colecci\u00f3n sin duplicados del apartado 2. Ejemplo: si el usuario introduce 3 y 5, se muestran los ex\u00e1menes de Sistemas Inform\u00e1ticos, Entornos de Desarrollo y Lenguaje de Marcas.</li> <li>Inserta los ex\u00e1menes en un \u00e1rbol. Utilizando la interfaz Comparable, ordena los ex\u00e1menes en el \u00e1rbol ascendente de asignatura, fecha y hora de inicio en este orden. Es decir, si la asignatura es la misma, entonces ordena por fecha, y si la fecha tambi\u00e9n es la misma, entonces ordena por hora. El primer examen ser\u00e1 el de Base de Datos que empieza a las 08:15 y el \u00faltimo ser\u00e1 el de Sistemas Inform\u00e1ticos.</li> <li>Inserta los ex\u00e1menes en otro \u00e1rbol pero esta vez utilizando la interfaz Comparator de manera an\u00f3nima. En dicha \u00e1rbol, el orden ser\u00e1 por orden descendente de fecha y hora de inicio en ese orden. El primer examen ser\u00e1 el de Sistemas Inform\u00e1ticos y el \u00faltimo ser\u00e1 el de FOL.</li> <li>Inserta los ex\u00e1menes en un mapa ordenado utilizando como clave del mapa el campo clave de los ex\u00e1menes. Mostrar el contenido del mapa ordenado.</li> </ol> Ejercicio 10 <p>Una empresa nos ha contratado para hacer una aplicaci\u00f3n en Java para registrar a sus empleados. Pertenecemos a un equipo de trabajo de programadores dirigidos por un analista. El analista quiere que cumplamos una serie de requisitos ya que luego habr\u00e1 que unir todo el c\u00f3digo hecho por los programadores. Los requisitos son los siguientes:</p> <ul> <li>Enum Categoria<ul> <li>3 valores: JEFE, ENCARGADO y EMPLEADO</li> <li>M\u00e9todo getCodigo que devuelva el siguiente car\u00e1cter para cada valor:<ul> <li>JEFE: J</li> <li>ENCARGADO: E</li> <li>EMPLEADO: D</li> </ul> </li> </ul> </li> <li>Clase Clave<ul> <li>Atributos: enum Categoria y un n\u00famero entero.</li> <li>Atributos privados y solamente los getters necesarios.</li> <li>M\u00e9todo toString: devuelve una cadena concatenando el c\u00f3digo del enum con el n\u00famero entero. Ej: J1</li> <li>M\u00e9todo est\u00e1tico asignarClave: recibe una categor\u00eda y devuelve un objeto de tipo Clave. El n\u00famero de la clave ser\u00e1 1 para el primer jefe, primer encargado y primer empleado, 2 para los segundos, etc.</li> </ul> </li> <li>Clase Empleado<ul> <li>Atributos:<ul> <li>Clave: objeto de la clase Clave</li> <li>Nombre</li> <li>FechaAlta: fecha de alta en la empresa</li> <li>FechaBaja: fecha de baja en la empresa. Si contin\u00faan trabajando en la empresa, este atributo se rellena con null  </li> </ul> </li> <li>Atributos privados y solamente los getters necesarios.</li> <li>Constructor: Empleado(String nombre, Categoria categoria, LocalDate fechaAlta, LocalDate fechaBaja)</li> <li>Criterio de comparaci\u00f3n de la clase: descendentemente por d\u00edas trabajados.</li> </ul> </li> <li> <ul> <li> <p>En los 3 \u00e1rboles se a\u00f1adir\u00e1n los siguientes empleados y en este mismo orden:</p> Orden de inserci\u00f3n en los \u00e1rboles Nombre Categor\u00eda Fecha Alta Fecha Baja 1 Pepe Empleado 21/03/2011 22/04/2013 2 Juan Encargado 29/02/2012 No tiene 3 Mar\u00eda Jefe 30/04/2010 No tiene 4 Laura Empleado 30/12/2010 No tiene 5 Esteban Encargado 05/11/2010 11/02/2015 6 Pedro Jefe 16/08/2009 No tiene 7 Yolanda Empleado 27/07/2012 01/10/2013 8 Nuria Jefe 31/08/2009 No tiene 9 Antonio Encargado 28/01/2011 14/05/2014 10 Clone de Pepe 11 Clone de Esteban 12 Clone de Pedro </li> </ul> <p>Clase Arboles: esta clase contendr\u00e1 el main con 3 \u00e1rboles de empleados:</p> <ul> <li>Los tres \u00e1rboles son los siguientes:<ul> <li>\u00c1rbol con los empleados ordenados descendentemente por d\u00edas trabajados.</li> <li>\u00c1rbol con los empleados ordenados ascendentemente por orden alfab\u00e9tico de los nombres de los empleados. Utiliza l interfaz Comparator de manera an\u00f3nima.</li> <li>TreeMap con los empleados ordenador descendentemente por categor\u00eda profesional y a misma categor\u00eda, se ordena ascendentemente por n\u00famero. Utilizar como clave del TreeMap el atributo clave del empleado. </li> </ul> </li> <li>De todos los \u00e1rboles hay que mostrar los datos. La salida por consola debe ser exactamente igual a la siguiente:</li> </ul> <p> </p> </li> </ul>"},{"location":"bloque_iii/tema_11/page-8/","title":"Proyecto","text":"<p>En una empresa quieren guardar informaci\u00f3n sobre los clientes, y de \u00e9stos se desea almacena:</p> <ul> <li>Clave del cliente, que estar\u00e1 formada por las dos primeras letras del nombre del cliente, las tres primeras letras de cada apellido, los tres n\u00fameros de su DNI y su letra. Por ejemplo, si un cliente se llama Rosa Vel\u00e1zquez Mart\u00ednez, con DNI 32050698G, su clave ser\u00eda **rovema698G*.</li> <li>Nombre del cliente</li> <li>Apellidos del cliente</li> <li>DNI</li> <li>Direcci\u00f3n, compuesta por la el tipo de v\u00eda (calle, avenida, pasaje, km, otro), el nombre de la v\u00eda, n\u00famero de la v\u00eda, c\u00f3digo postal, municipio, provincia y otra informaci\u00f3n relevante.</li> <li>Importe total comprado.</li> <li>Lista de fechas de compra.</li> </ul> <p>Crea aun aplicaci\u00f3n Java que le permita al usuario realizar las siguientes operaciones:</p> <ol> <li>A\u00f1adir clientes</li> <li>Consultar clientes por nombre</li> <li>Consultar clientes por DNI</li> <li>Eliminar clientes</li> <li>Mostrar todos los clientes</li> <li>Filtrar por fecha de compra</li> <li>Top 5 de clientes que m\u00e1s dinero han comprado</li> </ol> <p>Realizar la misma aplicaci\u00f3n con diferentes versiones.</p> <ul> <li>La primera versi\u00f3n se har\u00e1 uso de la interfaz List.</li> <li>La segunda versi\u00f3n se har\u00e1 uso de la interfaz Set.</li> <li>La tercera versi\u00f3n se har\u00e1 uso de la interfaz SortedSet.</li> <li>La cuarta versi\u00f3n se har\u00e1 uso de la interfaz Map.</li> <li>La quinta versi\u00f3n se har\u00e1 uso de la interfaz SortedMap.</li> </ul> <p>Ten en cuenta que el orden de natural de los clientes es ordenado primero por su apellido de forma ascendente, en caso de ser repetido, seguir\u00e1 ordenado por nombre de forma ascendente, en caso de que haya dos personas que se llamen igual, se ordenar\u00e1 por las veces que ha realizado un comprar de forma descendente, y por \u00faltimo lugar, el DNI de forma descendiente.</p> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>Se deber\u00e1 entregar un diagrama de clase que represente las relaciones entre las clases y las interfaces.</li> <li>Se valorar\u00e1 la complejidad de un Main que ponga aprueba los m\u00e9todos y clases creadas, as\u00ed como la complejidad de la estructura de la aplicaci\u00f3n.</li> <li>Se podr\u00e1 usar la librer\u00eda common realiza en proyectos anteriores, haciendo uso de JARs.</li> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre <code>pr11java-NOMBRE-collections</code> siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"bloque_iii/tema_12/page-1/","title":"1 Interfaces funcionales","text":""},{"location":"bloque_iii/tema_12/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La programaci\u00f3n  imperativa  es  uno  de  los  paradigmas  de  programaci\u00f3n  de computadoras m\u00e1s utilizados. Bajo este paradigma, la programaci\u00f3n se describe en t\u00e9rminos del estado del programa y de sentencias que cambian dicho estado. Java es un lenguaje imperativo, lo que implica que un programa Java est\u00e1 compuesto por una secuencia de instrucciones, que son ejecutadas en el mismo orden en el que se escriben, de manera que al ejecutarla se produce cambios en el estado del programa.</p> <p>Por  su  parte,  la  programaci\u00f3n  funcional  es  un  paradigma  de  programaci\u00f3n alternativo, en el que el resultado de un programa deriva de la aplicaci\u00f3n de distintas funciones a la entrada, sin cambiar el estado interno del programa. En la programaci\u00f3n funcional los bloques principales de construcci\u00f3n de nuestros programas son las funciones y no los objetos.</p> <p>Al aplicar programaci\u00f3n funcional se produce normalmente un c\u00f3digo m\u00e1s corto y m\u00e1s sencillo de entender que aplicando programaci\u00f3n imperativa, ya que es m\u00e1s f\u00e1cil crear abstracciones a trav\u00e9s de funciones que a trav\u00e9s de interfaces.</p> <p>Java siempre fue un lenguaje para programaci\u00f3n imperativa y de hecho las funciones en Java NO son objetos, por lo que una funci\u00f3n no puede pasarse directamente como argumento de otra funci\u00f3n para que se ejecute su c\u00f3digo. Sin embargo, gracias a las interfaces funcionales y a las clases inline an\u00f3nimas pod\u00edamos superar esta limitaci\u00f3n. Pero \u00bfqu\u00e9 es una interfaz funcional?</p>"},{"location":"bloque_iii/tema_12/page-1/#interfaces-funcionales","title":"Interfaces funcionales","text":"<p>Una interfaz funcional es una interfaz que contiene un \u00fanico m\u00e9todo abstracto. Esto no quiere decir que no pueda contener otros m\u00e9todos. De hecho, puede contener:</p> <ul> <li>Otros m\u00e9todos <code>static</code> (Java 8+).</li> <li>Otros m\u00e9todos <code>default</code>  (Java 8+).</li> <li>Otros m\u00e9todos <code>private</code> (Java 9+)</li> <li>M\u00e9todos que sobrescriban m\u00e9todos de la clase <code>Object</code> .</li> </ul> <p>A  la  hora  de  definir  una  interfaz  funcional,  Java  8  proporciona  la  anotaci\u00f3n <code>@FunctionInterface</code>, que informa al compilador de que dicha interfaz es funcional y por tanto tiene un \u00fanico m\u00e9todo abstracto. El objetivo de esta anotaci\u00f3n es que se produzca un error de compilaci\u00f3n si le a\u00f1adimos un segundo m\u00e9todo abstracto a la interfaz. El uso de esta anotaci\u00f3n no se ha establecido como obligatoria para mantener la compatibilidad con el c\u00f3digo ya existente, pero s\u00ed que est\u00e1 recomendada.</p> <p>Una interfaz funcional pura es aquella en la que las clases que la implementan no almacenan ning\u00fan estado, como por ejemplo <code>Comparator</code>. Veamos el m\u00e9todo <code>sort</code> de la interfaz <code>List&lt;E&gt;</code> que recibe un objeto de una clase que implementa la interfaz <code>Comparator</code>: <code>default void sort(Comparator&lt;? super E&gt; c)</code>. El m\u00e9todo utiliza el <code>Comparator</code> para ordenar la lista llamando al m\u00e9todo <code>compare</code> de dicho objeto cada vez que debe comparar dos objetos de la lista. Por lo tanto, debemos crear una clase que implemente <code>Comparator</code> para determinar c\u00f3mo se comparan dos elementos:</p> <pre><code>import java.util.Comparator;\npublic class ListOrder implements Comparator&lt;Integer&gt;{\n@Override\npublic int compare(Integer o1, Integer o2){\nreturn Integer.compare(o1, o2);\n}\n}\n</code></pre> <p>As\u00ed, cuando queramos ordenar una lista de enteros har\u00edamos:</p> <pre><code>import java.util.Arrays;\nimport java.util.List;\npublic class Main{\npublic void show(){\nList&lt;Integer&gt; list = Arrays.asList(3, 2, 6, 1, 5, 4);\nlist.sort(new ListOrder());\nfor(Integer i : list){\nSystem.out.printf(\" %d \", i);\n}\n}\npublic static void main(String[] args){\nnew Main().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-1/#implementacion-de-interfaces-funcionales-mediante-clases-inline-anonimas","title":"Implementaci\u00f3n de interfaces funcionales mediante clases inline an\u00f3nimas","text":"<p>El problema del c\u00f3digo anterior es que si esta ordenaci\u00f3n se hace solamente en dicha ocasi\u00f3n, se ha creado la clase <code>ListOrder</code> para un \u00fanico uso. En ese caso, es m\u00e1s conveniente utilizar una clase inline an\u00f3nima:</p> <pre><code>import java.util.Arrays;\nimport java.util.List;\npublic class InlineAnonymousClass{\npublic void show(){\nList&lt;Integer&gt; list = Arrays.asList(3, 2, 6, 1, 5, 4);\nlist.sort(new Comparator&lt;Integer&gt;(){\n@Override\npublic int compare(Integer o1, Integer o2){\nreturn Integer.compare(o1, o2);\n}\n});\nfor(Integer i : list){\nSystem.out.printf(\" %d \", i);\n}\n}\npublic static void main(String[] args){\nnew InlineAnonymousClass().show();\n}\n}\n</code></pre> <p>Lo que estamos haciendo es indicarle al m\u00e9todo <code>sort()</code> el c\u00f3digo que debe ejecutar para comparar dos objetos. Entonces, \u00bfno ser\u00eda m\u00e1s f\u00e1cil que al m\u00e9todo <code>sort()</code> le pudi\u00e9ramos pasar directamente el c\u00f3digo que debe ejecutar? El problema es que en Java las funciones no son objetos, por lo que no pueden ser referenciadas mediante una variable o pasadas directamente como argumento.</p> <p>En realidad, lo que nos interesa es poder establecer tipos funci\u00f3n, es decir, tipos que representen una funci\u00f3n que reciba unos determinados par\u00e1metros de alg\u00fan tipo y que devuelva un valor de retorno de alg\u00fan tipo. Si existieran los tipos funci\u00f3n, podr\u00edamos definir variables o par\u00e1metros de dichos tipos. De hecho hay lenguajes de programaci\u00f3n que tienen tipos funci\u00f3n. En Java, debido a la necesidad de mantener la compatibilidad con versiones anteriores, no existe ninguna sintaxis especial para definir tipos funci\u00f3n sino que se utilizan las interfaces funcionales para representarlos. Dado que una interfaz funcional solo puede tener un \u00fanico m\u00e9todo abstracto, la firma de dicho m\u00e9todo puede ser usado como tipo funci\u00f3n.</p>"},{"location":"bloque_iii/tema_12/page-1/#interfaces-funcionales-puras-predefinidas","title":"Interfaces funcionales puras predefinidas","text":"<p>Java incorpora, a partir de la versi\u00f3n 8, una serie de interfaces funcionales puras predefinidas en el paquete <code>java.util.function</code> para permitir la programaci\u00f3n funcional en Java:</p> <ul> <li><code>Function&lt;T,R&gt;</code>: su m\u00e9todo abstracto es <code>R apply(T t)</code>.</li> <li><code>UnaryOperator&lt;T&gt;</code>: es un caso espec\u00edfico de la interfaz funcional Function, es decir, coinciden el tipo del argumento y el tipo de retorno, por lo que est\u00e1 parametrizada con un \u00fanico tipo. <li><code>BiFunction&lt;T,U,R&gt;</code>: su m\u00e9todo abstracto es <code>R apply(T t,U u)</code>.</li> <li><code>BinaryOperator&lt;T&gt;</code>:es un caso espec\u00edfico  de  la  interfaz  funcional BiFunction en el que coinciden el tipo de los dos argumentos recibidos por el m\u00e9todo apply y el tipo de retorno del mismo. Es por tanto similar a BiFunction. La interfaz funcional  BinaryOperator est\u00e1,  por  tanto, parametrizada con un \u00fanico tipo. <li><code>Predicate&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>boolean test(T t)</code>.</li> <li><code>BiPredicate&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>boolean test(T t,U u)</code>.</li> <li><code>Consumer&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>void accept(T t)</code>.</li> <li><code>BiConsumer&lt;T,U&gt;</code>: su m\u00e9todo abstracto es <code>void accept(T t,U u)</code>.</li> <li><code>Supplier&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>T get()</code>.</li> <p>Veamos un ejemplo utilizando la interfaz funcional <code>BinaryOperator&lt;T&gt;</code></p> ShowBinaryOperatorMainConsola <pre><code>import java.util.function.BinaryOperator;\npublic class ShowBinaryOperator{\npublic Integer calculate(Integer value1, Integer value2, BinaryOperator&lt;Integer&gt; binaryOperator){\nreturn binaryOperation.apply(value1, value2);\n}\n}\n</code></pre> <pre><code>public class Main2 {\npublic void show(){\nShowBinaryOperator binOper = new ShowBinaryOperator();\nSystem.out.printf(\"12 + 6 = %d\\n\", binOper.calculate(12, 6, new BinaryOperator&lt;Integer&gt;(){\n@Override\npublic Integer apply(Integer t, Integer u){\nreturn t + u;\n}\n}));\nSystem.out.printf(\"12 - 6 = %d\\n\", binOper.calculate(12, 6, new BinaryOperator&lt;Integer&gt;(){\n@Override\npublic Integer apply(Integer t, Integer u){\nreturn t - u;\n}\n}));\nSystem.out.printf(\"12 / 6 = %d\\n\", binOper.calculate(12, 6, new BinaryOperator&lt;Integer&gt;(){\n@Override\npublic Integer apply(Integer t, Integer u){\nreturn t / u;\n}\n}));\nSystem.out.printf(\"12 * 6 = %d\\n\", binOper.calculate(12, 6, new BinaryOperator&lt;Integer&gt;(){\n@Override\npublic Integer apply(Integer t, Integer u){\nreturn t * u;\n}\n}));\n}\npublic static void main(String[] args){\nnew Main2().show();\n}\n}\n</code></pre> <pre><code>12 + 6 = 18\n12 - 6 = 6\n12 / 6 = 2\n12 * 6 = 72\n</code></pre>"},{"location":"bloque_iii/tema_12/page-1/#interfaces-funcionales-para-tipos-primitivos","title":"Interfaces funcionales para tipos primitivos","text":"<p>Como no podemos usar la parametrizaci\u00f3n de clases e interfaces con los tipos primitivos (limitaci\u00f3n de generics), el paquete <code>java.util.function</code> define tambi\u00e9n una serie de interfaces funcionales similares a las explicadas anteriormente pero espec\u00edficas para los tipos primitivos:</p> <ul> <li>Para el tipo primitivo boolean: <code>BooleanSupplier</code></li> <li>Para  el  tipo  primitivo  double:  <code>DoubleBinaryOperator</code> , <code>DoubleConsumer</code>, <code>DoubleFunction</code>, <code>DoublePredicate</code>, <code>DoubleSupplier</code>, <code>DoubleToIntFunction</code>, <code>DoubleToLongFunction</code>, <code>DoubleUnaryOperator</code>, <code>ToDoubleBiFunction</code>, <code>ToDoubleFunction</code>, <code>ObjDoubleConsumer</code>.</li> <li>Para el tipo primitivo int:  <code>IntBinaryOperator</code>, <code>IntConsumer</code>,  <code>IntFunction</code>, <code>IntPredicate</code>, <code>IntSupplier</code>,  <code>IntToDoubleFunction</code>, <code>IntToLongFunction</code>, <code>IntUnaryOperator</code>, <code>ToIntBiFunction</code>, <code>ToIntFunction</code>, <code>ObjIntConsumer</code>.</li> <li>Para  el  tipo  primitivo  long:  <code>LongBinaryOperator</code> , <code>LongConsumer</code>, <code>LongFunction</code>, <code>LongPredicate</code>,  <code>LongSupplier</code>, <code>LongToDoubleFunction</code>, <code>LongToIntFunction</code>, <code>LongUnaryOperator</code>,  <code>ToLongBiFunction</code>, <code>ToLongFunction</code>, <code>ObjLongConsumer</code>.</li> </ul> <p>Adem\u00e1s, la mayor\u00eda de las interfaces vistas hasta ahora incluyen m\u00e9todos cuyo nombre incluye <code>ToTipo</code> que retornan objetos de interfaces funcionales para tipos primitivos.</p>"},{"location":"bloque_iii/tema_12/page-2/","title":"2 Expresiones lambda","text":""},{"location":"bloque_iii/tema_12/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Con objeto de incorporar a Java funcionalidades propias de la programaci\u00f3n funcional, Java 8 trajo consigo dos nuevas sintaxis para representar interfaces funcionales: expresiones lambda (lambda expressions) y referencias a m\u00e9todo (method references).</p> <p>Una  expresi\u00f3n  lambda  es  una  nueva  sintaxis  con  la  que  representar  la implementaci\u00f3n del m\u00e9todo abstracto de interfaces funcionales indicando adem\u00e1s la lista de par\u00e1metros con sus tipos y el tipo de retorno. De esta manera, podemos escribir el c\u00f3digo de apartados anteriores mediante una expresi\u00f3n lambda, haci\u00e9ndolo mucho m\u00e1s legible.</p> <p>El nuevo operador para las expresiones lambda se denomina operador lambda y tiene la forma de flecha <code>-&gt;</code>. Divide la expresi\u00f3n lambda en dos partes: la parte izquierda especifica los par\u00e1metros necesarios y la parte derecha contiene el cuerpo de la expresi\u00f3n. Este cuerpo puede estar compuesto por una \u00fanica expresi\u00f3n o puede ser un bloque de c\u00f3digo. Cuando es una \u00fanica expresi\u00f3n se denomina lambda de expresi\u00f3n y cuando es un bloque de c\u00f3digo se denomina lambda de bloque.</p> <p>Debemos tener en cuenta que cuando se especifica una expresi\u00f3n lambda, no indicamos  nada  sobre  la  interfaz  funcional  a  la  queremos  aplicarla,  es  decir, dependiendo de donde se est\u00e9 usando la expresi\u00f3n lambda, el compilador deber\u00e1 determinar si la firma de la expresi\u00f3n lambda coincide con la firma del m\u00e9todo abstracto de la correspondiente interfaz funcional. Si la expresi\u00f3n lambda no incluye los tipos de los par\u00e1metros, el compilador tratar\u00e1 de inferirlos a partir de los tipos de los par\u00e1metros del m\u00e9todo abstracto de la interfaz funcional.</p> <p>El ejemplo anterior de la interfaz <code>BinaryOperator&lt;Integer&gt;</code>, si lo realizamos con una expresi\u00f3n lambda, resultar\u00eda de la siguiente manera:</p> <pre><code>public class BinaryOperatorWithLambda{\npublic void show(){\nShowBinaryOperator binOper = new ShowBinaryOperator();\nSystem.out.printf(\"12 + 6 = %d\\n\", binOper.calculate(12, 6, (t,u) -&gt; t + u));\nSystem.out.printf(\"12 - 6 = %d\\n\", binOper.calculate(12, 6, (t,u) -&gt; t - u));\nSystem.out.printf(\"12 / 6 = %d\\n\", binOper.calculate(12, 6, (t,u) -&gt; t / u));\nSystem.out.printf(\"12 * 6 = %d\\n\", binOper.calculate(12, 6, (t,u) -&gt; t * u));\n}\npublic static void main(String[] args){\nnew BinaryOperatorWithLambda().show();\n}\n}\n</code></pre> <p>Veamos el ejemplo de ordenaci\u00f3n de la lista hecho de las dos maneras, con una clase inline an\u00f3nima y con una expresi\u00f3n lambda:</p> <pre><code>import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\npublic class LambdaExpression{\npublic void show(){\nList&lt;Integer&gt; list = Arrays.asList(3, 2, 6, 1, 5, 4);\nlist.sort(new Comparator&lt;Integer&gt;(){\n@Override\npublic int compare(Integer o1, Integer o2){\nreturn Integer.compare(o1, o2);\n}\n});\nfor(Integer i : list){\nSystem.out.printf(\" %d \", i);\n}\nSystem.out.println();\nlist.sort((o1, o2) -&gt; Integer.compare(o1, o2)); for(Integer i : list){\nSystem.out.printf(\" %d \", i);\n}\n}\npublic static void main(String[] args){\nnew LambdaExpression().show();\n}\n}\n</code></pre> <p>A\u00fan as\u00ed, debemos tener en cuenta que un objeto de una clase inline an\u00f3nima y una expresi\u00f3n lambda no son lo mismo, porque una expresi\u00f3n lambda no crea ninguna clase adicional y adem\u00e1s en una expresi\u00f3n lambda no se puede almacenar ning\u00fan estado, mientras que en una clase an\u00f3nima inline s\u00ed. Un objeto de una clase an\u00f3nima inline genera un archivo de clase independiente durante la compilaci\u00f3n que aumenta el tama\u00f1o del archivo jar. Sin embargo, una expresi\u00f3n lambda se convierte en un simple m\u00e9todo privado. En una lambda, this representa la clase actual desde la que se est\u00e1 usando la lambda. En el caso de una clase an\u00f3nima, this representa ese objeto de la clase an\u00f3nima en particular.</p> <p>Como vemos, las expresiones lambda son muy \u00fatiles para simplificar el c\u00f3digo, pero presentan un problema: para que podamos usar esta nueva sintaxis de expresi\u00f3n lambda es necesario que la interfaz contra la que la usemos sea una interfaz funcional, es decir, que s\u00f3lo contenga un \u00fanico m\u00e9todo abstracto, porque si tuviera por ejemplo dos m\u00e9todos, \u00bfel c\u00f3digo proporcionado mediante la expresi\u00f3n lambda cu\u00e1ndo se deber\u00eda ejecutar, cuando se ejecute uno o cuando se ejecute el otro? Por este motivo las expresiones lambda solo se pueden usar con interfaces funcionales.</p> <p>Se puede almacenar una expresi\u00f3n lambda en una variable cuyo tipo corresponda a una interfaz funcional compatible con dicha lambda, es decir, cuya firma del m\u00e9todo abstracto de la interfaz sea compatible con la expresi\u00f3n lambda. Por ejemplo:</p> <pre><code>Comparator&lt;Integer&gt; comparador = (o1, o2) -&gt; Integer.compare(o1, o2);\nBinaryOperator&lt;Integer&gt; operacionBinaria = (o1, o2) -&gt; o1 + o2;\n</code></pre>"},{"location":"bloque_iii/tema_12/page-2/#sintaxis-de-la-expresion-lambda","title":"Sintaxis de la expresi\u00f3n lambda","text":"<p>Veamos la sintaxis de la expresi\u00f3n lambda:</p> <pre><code>(tipo param1, tipo param2, ...) -&gt; {\n// instrucciones\nreturn valorRetorno;\n}\n</code></pre> <p>Podemos omitir el tipo de dato de cada par\u00e1metro siempre y cuando el compilador pueda inferirlos (deducirlos) a partir del context, es decir, a partir de los tipos de los par\u00e1metros del m\u00e9todo abstracto de la interfaz funcional para la que se est\u00e1 usando.</p> <p>El cuerpo de las expresiones lambda puede contener los mismos tipos de sentencias que cualquier otra funci\u00f3n, como sentencias condicionales, iterativas o <code>try catch</code>.</p> <p>Si se espec\u00edfica un \u00fanico par\u00e1metro y no se espec\u00edfica el tipo de \u00e9ste sino que es inferido, podemos omitir los par\u00e9ntesis. Por ejemplo:</p> <pre><code>x -&gt; x + x;\n</code></pre> <p>Si no se espec\u00edfica ning\u00fan par\u00e1metro, es obligatorio poner los par\u00e9ntesis. Por ejemplo:</p> <pre><code>() -&gt; System.out.println(\"Hola mundo\");\n</code></pre> <p>En el cuerpo podemos omitir las las llaves si \u00e9ste contiene una \u00fanica expresi\u00f3n o una \u00fanica sentencia que no retorna valor. Si el cuerpo contiene una \u00fanica expresi\u00f3n, \u00e9sta ser\u00e1 evaluada y la expresi\u00f3n lambda retornar\u00e1 el valor obtenido.</p> <p>Si el cuerpo contiene m\u00e1s de una sentencia y la expresi\u00f3n lambda debe retornar un valor, entonces debemos usar una sentencia <code>return valor</code>.</p> <p>Si el cuerpo contiene una sentencia <code>return valor</code>, forzosamente debemos poner las llaves, incluso si el cuerpo contiene una \u00fanica sentencia, ya que <code>return</code>no es un expresi\u00f3n.</p> <p>Un expresi\u00f3n lambda se puede usar como argumento de un par\u00e1metro de tipo interfaz funcional y como valor de retorno de una funci\u00f3n cuyo tipo de retorno sea una interfaz funcional. sin embargo habr\u00e1 ocasiones donde debamos realizar un cast expl\u00edcitamente para indicar la interfaz funcional a la que queremos aplicar una determinada expresi\u00f3n lambda.</p>"},{"location":"bloque_iii/tema_12/page-2/#ambito-de-una-expresion-lambda","title":"\u00c1mbito de una expresi\u00f3n lambda","text":"<p>Una expresi\u00f3n lambda puede acceder a las variables <code>static</code> definidas en el \u00e1mbito en el que la expresi\u00f3n lambda es usada. Tambi\u00e9n puede acceder a las variables locales pero que sean eficazmente finales, es decir, variables cuyo valor no cambia una vez asignado. Estas variables no tienen necesariamente que estar definidas como <code>final</code>. Una expresi\u00f3n lambda tambi\u00e9n tiene acceso a <code>this</code>, lo que hace referencia a la instancia de invocaci\u00f3n de la clase contenedora de la expresi\u00f3n lambda.</p> <p>Si en el cuerpo de una expresi\u00f3n lambda con m\u00e1s de una sentencia definimos una variable local, debemos tener en cuenta que dicha variable tendr\u00e1 como \u00e1mbito el correspondiente a donde se ha definido la expresi\u00f3n lambda, ya que la expresi\u00f3n lambda no define su propio \u00e1mbito independiente. Si ya existiera una variable con el mismo nombre en dicho \u00e1mbito se producir\u00eda un error de compilaci\u00f3n. Por ejemplo:</p> <pre><code>int z = 2;\nBinaryOperator&lt;Integer&gt; operacion = (x, y) -&gt; {\nint z = 4; //(1)!\nSystem.out.println(x + z);\n}\n</code></pre> <ol> <li>\u00a1ERROR! z ya est\u00e1 definida en el \u00e1mbito</li> </ol> <p>Una expresi\u00f3n lambda puede generar una excepci\u00f3n. No obstante, si genera una excepci\u00f3n comprobada, esta tendr\u00e1 que ser compatible con la excepci\u00f3n (o excepciones) indicadas en la cl\u00e1usula <code>throws</code> del m\u00e9todo abstracto de la interfaz funcional. Veamos un ejemplo:</p> InterfazMain <pre><code>public interface FunctionalInterface{\nint ioAction() throws Exception;\n}\n</code></pre> <pre><code>public class LambdaException{\npublic void show(){\nFunctionalInterface fi = () -&gt; {\nScanner keyboard = new Scanner(System.in);\nint num = keyboard.nextInt();\nreturn num;\n};\ntry{\nSystem.out.printf(\"Introduce un n\u00famero: \");\nSystem.out.println(method(fi));\n} catch (Exception e){\nSystem.out.println(\"Error en la lectura\");\n}\n}\npublic int method(FunctionalInterface fi) throws Exception{\nreturn fi.ioAction();\n}\npublic static void main(String[] args){\nnew LambdaException().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-2/#limitaciones-de-las-expresiones-lambda","title":"Limitaciones de las expresiones lambda","text":"<p>El c\u00f3digo de una expresi\u00f3n lambda se convierte en el c\u00f3digo del m\u00e9todo abstracto de la interfaz funcional que implementa. or tanto, las expresiones lambda no sirven para sobrescribir la implementaci\u00f3n por defecto de un m\u00e9todo default de la interfaz, sino que debe tratarse de un m\u00e9todo abstracto. De hecho si la interfaz solo tiene un m\u00e9todo default, no ser\u00e1 considerada una interfaz funcional. Si nos vemos en la obligaci\u00f3n de sobrescribir un m\u00e9todo default de una interfaz, entonces tendremos que usar una clase an\u00f3nima inline.</p> <p>Por otro lado, una expresi\u00f3n j*lambda* no es consciente de qu\u00e9 interfaz funcional concreta est\u00e1 implementando, por lo que no puede llamar a su vez a m\u00e9todos privados ni default de la interfaz.</p> <p>Finalmente, las expresiones lambda no pueden usarse con clases abstractas que tengan un \u00fanico m\u00e9todo abstracto, solo se pueden usar con interfaces funcionales.</p>"},{"location":"bloque_iii/tema_12/page-2/#referencias-a-metodo","title":"Referencias a m\u00e9todo","text":"<p>Una referencia de m\u00e9todo (method reference) es una abreviaci\u00f3n de la lambda y se da siempre y cuando es una expresi\u00f3n de una \u00fanica l\u00ednea y los par\u00e1metros que se le pasa a la lambda son utilizados en la expresi\u00f3n.</p> <p>Una referencia de m\u00e9todo permite hacer referencia a un m\u00e9todo sin ejecutarlo. Al evaluar una referencia de m\u00e9todo, tambi\u00e9n se crea una instancia de una interfaz funcional.</p> <ul> <li>Sintaxis para m\u00e9todos est\u00e1ticos: <code>NombreClase::nombreM\u00e9todo</code><ul> <li><code>v -&gt; Math.sqrt(v)</code> equivaldr\u00eda a <code>Math::sqrt</code></li> <li><code>(o1, o2) -&gt; Integer.compare(o1, o2)</code> equivaldr\u00eda a <code>Integer::compare</code></li> </ul> </li> <li>Sintaxis para m\u00e9todos de instancia: <code>refObj::nombreM\u00e9todo</code><ul> <li><code>persona -&gt; persona.getNombre()</code> equivaldr\u00eda a <code>Persona::getNombre</code></li> <li><code>n -&gt; System.out.println(n)</code> equivaldr\u00eda <code>System.out::println</code></li> <li><code>(cadena1, cadena2) -&gt; cadena1.compareToIgnoreCase(cadena2)</code> equivaldr\u00eda a <code>String::compareToIgnoreCase</code>: en este caso, el primer par\u00e1metro de la expresi\u00f3n lambda es quien ejecuta el m\u00e9todo y el resto de par\u00e1metros se pasan como argumentos en la llamada.</li> <li><code>empleado -&gt; jefe.comparaSalarioCon(empleado)</code> equivaldr\u00eda a <code>jefe::comparaSalarioCon</code>: en este caso, un objeto ajeno a la expresi\u00f3n lambda es quien ejecuta el m\u00e9todo y dicho m\u00e9todo recibe como argumento el (o los) par\u00e1metro(s) de la expresi\u00f3n lambda.</li> <li><code>() -&gt; new TreeMap&lt;&gt;()</code> equivaldr\u00eda a <code>TreeMap::new</code>: este tipo se conoce como referencia a constructor, que emplearemos cuando queramos que se llame al m\u00e9todo constructor de una clase.</li> <li><code>i -&gt; new int[i]</code> equivaldr\u00eda a <code>int[]::new</code>: en este caso, lo que queremos es que se llame al constructor de un array.</li> </ul> </li> <li>Sintaxis para m\u00e9todos gen\u00e9ricos:<ul> <li>Est\u00e1ticos: <code>NombreClase::&lt;T&gt;nombreM\u00e9todo</code></li> <li>M\u00e9todos de instancia: <code>refObj::&lt;T&gt;nombreM\u00e9todo</code></li> </ul> </li> </ul>"},{"location":"bloque_iii/tema_12/page-3/","title":"3 Alguna interfaces funcionales","text":""},{"location":"bloque_iii/tema_12/page-3/#consumer-y-biconsumer","title":"Consumer y BiConsumer","text":"<ul> <li><code>Consumer&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>void accept(T t)</code>.</li> <li><code>BiConsumer&lt;T, U&gt;</code>: su m\u00e9todo abstracto es <code>void accept(T t, U u)</code>.</li> </ul> <p>La interfaz <code>Consumer</code>  es empleada por el m\u00e9todo <code>forEach(Consumer&lt;T&gt; action)</code> de la interfaz <code>Iterable</code>, que ejecuta la acci\u00f3n indicada sobre cada elemento del iterable.</p> <pre><code>import java.util.List; public class InterfaceConsumer {\npublic void show() {\nList&lt;Integer&gt; list = List.of(3, 2, 6, 1, 5, 4);\nlist.forEach(System.out::println); // num -&gt; System.out.println(num)\n}     public static void main(String[] args) { new InterfaceConsumer().show();     } }\n</code></pre> <p>En este ejemplo, se ejecuta la acci\u00f3n de mostrar por consola una l\u00ednea con cada elemento de la lista.</p> <p>La interfaz funcional <code>BiConsumer</code> es similar a <code>Consumer</code> pero su m\u00e9todo recibe dos argumentos, uno de tipo <code>T</code>  y otro de tipo <code>U</code> y no retorna nada: <code>void accept(T t, U u)</code></p> <pre><code>import java.util.HashMap;\nimport java.util.Map; public class InterfaceBiConsumer {     public void show() {         Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\nfor (int i = 0; i &lt; 5; i++) {\nmap.put(i, i * i);\n}\nmap.forEach((k, v) -&gt; System.out.printf(\"Clave:%d Valor:%d\\n\", k, v));\n}     public static void main(String[] args) {         new InterfaceBiConsumer().show();\n}\n}\n</code></pre> <p>La  interfaz  funcional  <code>Consumer</code>   posee  un  m\u00e9todo  default  llamado <code>andThen(Consumer&lt;T&gt; after)</code> que llama al m\u00e9todo <code>accept</code> del consumidor recibido despu\u00e9s de haber llamado a su propio <code>accept</code>. Gracias a este m\u00e9todo, podemos tener una serie de objetos <code>Consumer</code> predefinidos y encadenarlos de la forma que nos interese.Veamos un ejemplo:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Consumer;\npublic class ConsumerAndThen{\npublic void show(){\nList&lt;Integer&gt; list = List.of(3, 2, 6, 1, 5, 4);\nList&lt;Integer&gt; listCopy = new ArrayList&lt;&gt;();\nConsumer&lt;Integer&gt; copy = listCopy::add; // (value) -&gt; listCopy.add(value);\nConsumer&lt;Integer&gt; show = System.out::println; // (value) -&gt; System.out.println(value);\nlist.forEach(copy.andThen(show));\nlistCopy.foreach(show);\n}\npublic static void main(String[] args){\nnew ConsumerAndThen().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-3/#predicate-y-bipredicate","title":"Predicate y BiPredicate","text":"<ul> <li><code>Predicate&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>boolean test(T t)</code>.</li> <li><code>BiPredicate&lt;T&gt;</code>: su m\u00e9todo abstracto es <code>boolean test(T t, U u)</code>.</li> </ul> <p>Las interfaces funcionales  <code>Predicate</code>  y  <code>BiPredicate</code>  poseen m\u00e9todos default que retornan un nuevo objeto que implementa la misma interfaz y que permiten componer predicados  mediante  operaciones  l\u00f3gicas,  como  <code>or(otherPredicate)</code>, <code>and(otherPredicate)</code> o <code>negate(otherPredicate)</code>. El orden en el que se ejecutar\u00e1n ser\u00e1n el orden en el que aparecen en la composici\u00f3n, es decir, no existe una prioridad preestablecida como con los operadores l\u00f3gicos.</p> <p>Veamos un ejemplo utilizando el m\u00e9todo <code>removeIf</code> de la interfaz <code>Collection</code> que recibe un Predicate por par\u00e1metro:  <code>default  boolean  removeIf(Predicate&lt;?  super  E&gt; filter)</code>. Dicho m\u00e9todo elimina de la colecci\u00f3n aquellos elementos que cumplan el Predicate:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\npublic class PredicateComposition{\npublic void show(){\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(3, 2, 6, 1, 5, 4));\nPredicate&lt;Integer&gt; esPar = n -&gt; n % 2 == 0;\nPredicate&lt;Integer&gt; mayorQue3 = n -&gt; n &gt; 3;\nlist.removeIf(esPar.and(mayorQue3));\nlist.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew PredicateComposition().show();\n}\n}\n</code></pre> <p>La interfaz <code>Predicate</code> tiene tambi\u00e9n un m\u00e9todo est\u00e1tico factor\u00eda <code>PredicateIsEqual(Object o)</code> que retorna el predicado correspondiente a comprobar si un elemento es igual que otro objeto. Internamente simplemente se llamar\u00e1 al m\u00e9todo <code>equals</code>:</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\npublic class PredicateIsEqual{\npublic void show(){\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;(List.of(3, 2, 6, 1, 5, 4));\nlist.removeIf(Predicate.isEqual(5));\nlist.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew PredicateIsEqual().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-3/#function","title":"Function","text":"<p><code>Function&lt;T,R&gt;</code>: su m\u00e9todo abstracto es <code>R apply(T t)</code>. Veamos un ejemplo de utilizaci\u00f3n en el m\u00e9todo<code>computeIfAbsent</code>de los mapas:</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\npublic class InterfaceFunction{\npublic void show(){\nFunction&lt;Integer, Integer&gt; elevarAlCuadrado = n -&gt; n * n;\nMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\nfor(int i = 0; i &lt; 10; i++){\nmap.computeIfAbsent(i, elevarAlCuadrado);\n}\nmap.forEach((k,v) -&gt; System.out.printf(\"Clave:%d Valor:%d\\n\", k, v));\n}\npublic static void main(String[] args){\nnew InterfaceFunction().show();\n}\n}\n</code></pre> <p>La interfaz funcional <code>Function</code> posee un m\u00e9todo default llamado <code>andThen(afterFunction)</code> que permite que despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo <code>apply</code> de la function original, su resultado se pase como valor de entrada del m\u00e9todo <code>apply</code> del objeto <code>Function</code> pasado como argumento, retornado el objeto <code>Function</code> correspondiente a la cadena de operaciones de transformaci\u00f3n. Veamos un ejemplo:</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\npublic class FunctionAndThen{\npublic void show(){\nFunction&lt;Integer, Integer&gt; elevarAlCuadrado = n -&gt; n * n;\nFunction&lt;Integer, String&gt; aCadena = String::valueOf; // value -&gt; String.valueOf(value)\nMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\nfor(int i = 0; i &lt; 10; i++){\nmap.computeIfAbsent(i, elevarAlCuadrado.andThen(aCadena));\n}\nmap.forEach((k,v) -&gt; System.out.printf(\"Clave:%d Valor:%d\\n\", k, v));\n}\npublic static void main(String[] args){\nnew FunctionAndThen().show();\n}\n}\n</code></pre> <p>Muy parecido al anterior es el m\u00e9todo default <code>compose(beforeFunction)</code> que primero ejecuta el m\u00e9todo <code>apply</code> del objeto <code>Function</code> recibe y despu\u00e9s el m\u00e9todo <code>apply</code> del objeto <code>Function</code> original, es decir, se ejecutan en orden inverso al de <code>andThen</code>. Gracias a estos dos m\u00e9todos, podemos tener una serie de objetos <code>Function</code>predefinidos y encadenarlos de la forma que nos interese.</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\npublic class FunctionCompose{\npublic void show(){\nFunction&lt;Integer, Integer&gt; elevarAlCuadrado = n -&gt; n * n;\nFunction&lt;Integer, String&gt; aCadena = String::valueOf; // value -&gt; String.valueOf(value)\nMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\nfor(int i = 0; i &lt; 10; i++){\nmap.computeIfAbsent(i, aCadena.compose(elevarAlCuadrado));\n}\nmap.forEach((k,v) -&gt; System.out.printf(\"Clave:%d Valor:%d\\n\", k, v));\n}\npublic static void main(String[] args){\nnew FunctionCompose().show();\n}\n}\n</code></pre>"},{"location":"bloque_iii/tema_12/page-3/#comparator","title":"Comparator","text":"<p>La interfaz funcional <code>Comparator</code> (comparador) contiene el m\u00e9todo abstracto <code>int compare(T o1, T o2)</code> que recibe dos valores de tipo <code>T</code> y retorna un entero que vale:</p> <ul> <li>0 si o1 es igual a o2.</li> <li>Menor que 0 si o1 es menor que o2.</li> <li>Mayor que 0 si o1 es mayor que o2.</li> </ul> <p>La interfaz <code>Comparator</code> ya exist\u00eda en Java 7 y de hecho no se encuentra en el paquete <code>java.util.function</code>, sino directamente en <code>java.util</code>. Esta interfaz posee una serie de m\u00e9todos est\u00e1ticos factor\u00eda que retornan objetos <code>Comparator</code> correspondientes a los casos m\u00e1s habituales de comparaci\u00f3n:</p> <ul> <li> <p><code>static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalOrder()</code>: devuelve un objeto <code>Comparator</code> para ordenar por el orden natural. Pero, \u00bfqu\u00e9 considera Java como orden natural? El orden indicado en la implementaci\u00f3n de <code>Comparable</code>.</p> <pre><code>import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\npublic class NaturalOrder{\npublic void show(){\nList&lt;Integer&gt; list = Arrays.asList(3, 2, 6, 1, 5, 4);\nlist.sort(Comparator.naturalOrder());\nlist.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew NaturalOrder().show();\n}\n}\n</code></pre> </li> <li> <p><code>static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder()</code>: ordena por el orden natural inverso:</p> <pre><code>import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\npublic class ReverseOrder{\npublic void show(){\nList&lt;Integer&gt; list = Arrays.asList(3, 2, 6, 1, 5, 4);\nlist.sort(Comparator.reverseOrder());\nlist.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew ReverseOrder().show();\n}\n}\n</code></pre> </li> <li> <p><code>static &lt;T&gt; Comparator&lt;T&gt; nullsFirst(Comparator&lt;? super T&gt; comparator)</code>: recibe un comparador y retorna un nuevo comparador seg\u00fan el cual los elementos <code>null</code> preceder\u00e1n a los que no lo sean, que ser\u00e1n ordenados atendiendo al comparador recibido. Tambi\u00e9n tenemos <code>nullsLast</code>, similar al anterior pero los elementos que sean <code>null</code>se sit\u00faan al final.</p> <pre><code>import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\npublic class NullsFirst{\npublic void show(){\nList&lt;Integer&gt; list = Arrays.asList(3, 2, null, 6, 1, 5, 4, null);\nlist.sort(Comparator.nullsFirst(Comparator.naturalOrder()));\nSystem.out.println(\"nullsFirst: \");\nlist.forEach(System.out::println);\nlist.sort(Comparator.nullsLast(Comparator.naturalOrder()));\nSystem.out.println(\"nullsLast: \");\nlist.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew ReverseOrder().show();\n}\n}\n</code></pre> </li> <li> <p><code>static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T, ? extends U&gt; keyExtractor)</code>: recibe una funci\u00f3n que debe retornar el valor por el que debe comparar el comparador retornado. Este m\u00e9todo es muy \u00fatil si queremos ordenar una lista de objetos por un determinado campo.</p> VehicleMainConsola <pre><code>public class Vehicle {     private String registration;\nprivate int wheelCount;\nprivate double speed;\nprivate String colour;\npublic Vehicle(String registration, int wheelCount, String colour) {\nthis.registration = registration;\nthis.wheelCount = wheelCount;\nthis.colour = colour;\nspeed = 0;\n}\npublic int getWheelCount() {\nreturn wheelCount;\n}\npublic double getSpeed() {\nreturn speed;\n}     public String getColour() {\nreturn colour;\n}     public void setColour(String colour) {\nthis.colour = colour;\n}     public String getRegistration() {\nreturn registration;\n}     public void accelerate(double amount) {\nspeed += amount;\n}     public void brake(double amount) {\nspeed -= amount;\n}     @Override\npublic String toString() {\nreturn \"Vehicle [registration=\" + registration + \", wheelCount=\" + wheelCount + \", speed=\" + speed + \", colour=\" + colour + \"]\";\n} }\n</code></pre> <pre><code>public class Comparing{\npublic void show(){\nList&lt;Vehicle&gt; list = new ArrayList&lt;&gt;();\nlist.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\nlist.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\nlist.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\nlist.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\nlist.add(new Vehicle(\"3495JZA\", 2, \"blanco\"));\nlist.add(new Vehicle(\"5930POI\", 2, \"negro\"));\nlist.sort(Comparator.comparing(Vehicle::getColour));\nlist.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew Comparing().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=blanco]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> <p>Hay versiones de este m\u00e9todo est\u00e1tico factor\u00eda para cuando el valor por que se debe ordenar es de un tipo primitivo, como <code>comparingInt</code>, <code>comparingLong</code> o <code>comparingDouble</code></p> </li> </ul> <p>La interfaz funcional <code>Comparator</code> tambi\u00e9n incorpora una serie de m\u00e9todos default que nos permiten encadenar comparadores:</p> <ul> <li> <p><code>default Comparator&lt;T&gt; reversed()</code>: sirve para obtener el orden inverso al del comparador original.</p> MainConsola <pre><code>public class Reversed{\npublic void show(){\nList&lt;Vehicle&gt; list = new ArrayList&lt;&gt;();\nlist.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\nlist.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\nlist.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\nlist.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\nlist.add(new Vehicle(\"3495JZA\", 2, \"blanco\"));\nlist.add(new Vehicle(\"5930POI\", 2, \"negro\"));\nlist.sort(Comparator.comparing(Vehicle::getColour).reversed());\nlist.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew Reversed().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=blanco]\nVehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\n</code></pre> <ul> <li><code>default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing(Function&lt;? super T, ? extends U&gt; keyExtractor)</code>: recibe una funci\u00f3n con la que indica el valor por el que comparar si con el comparador original los elementos son iguales:</li> </ul> MainConsola <pre><code>public class ThenComparingFunction{\npublic void show(){\nList&lt;Vehicle&gt; list = new ArrayList&lt;&gt;();\nlist.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\nlist.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\nlist.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\nlist.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\nlist.add(new Vehicle(\"3495JZA\", 2, \"blanco\"));\nlist.add(new Vehicle(\"5930POI\", 2, \"negro\"));\nlist.sort(Comparator.comparing(Vehicle::getColour).thenComparing(Vehicle::getWheelCount));\nlist.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew Reversed().show();\n}\n}\n</code></pre> <pre><code>Vehicle [registration=9685KMX, wheelCount=4, speed=0.0, colour=azul]\nVehicle [registration=3495JZA, wheelCount=2, speed=0.0, colour=blanco]\nVehicle [registration=1705UBG, wheelCount=4, speed=0.0, colour=blanco]\nVehicle [registration=5930POI, wheelCount=2, speed=0.0, colour=negro]\nVehicle [registration=1235GTR, wheelCount=2, speed=0.0, colour=rojo]\nVehicle [registration=7314QWE, wheelCount=4, speed=0.0, colour=verde]\n</code></pre> </li> </ul> <p>Existen versiones espec\u00edficas de este m\u00e9todo para cunado la funci\u00f3n retorna un tipo primitivo, como <code>thenComparingInt</code>, <code>thenComparingLong</code> y <code>thenComparingDouble</code>.</p>"},{"location":"bloque_iii/tema_12/page-4/","title":"4 Optional","text":""},{"location":"bloque_iii/tema_12/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>La clase <code>Optional&lt;T&gt;</code> es un wrapper alrededor de un valor que puede estar presente o no. El objetivo de esta clase es servir b\u00e1sicamente como tipo de retorno de aquellos m\u00e9todos que pueden retornar una valor o no.</p> <p>Por ejemplo, supongamos que queremos realizar un m\u00e9todo que retorne la posici\u00f3n en la que se encuentra un determinado elemento de una lista de enteros. La pregunta que inmediatamente nos har\u00edamos como desarrolladores ser\u00eda, \u00bfqu\u00e9 debo hacer si el elemento a buscar, que ha sido pasado como argumento del m\u00e9todo, no se encuentra en la lista? Debo lanzar una excepci\u00f3n? No puedo retornar <code>false</code> porque el m\u00e9todo retorna un entero. \u00bfDebo retornar un valor especial como por ejemplo <code>-1</code>?\u00bfRetorno como valor especial del valor <code>null</code>?</p> <p>Tradicionalmente los desarrolladores han resulto esta situaci\u00f3n de distintas maneras y todas tienen sus inconvenientes. Por un lado, lanzar una excepci\u00f3n parece excesivo porque no es un error del programa y al cliente del m\u00e9todo simplemente hay que informarle de alguna manera de que no se ha encontrado el elemento.</p> <p>Por otra parte, retornar un valor especial tiene el inconveniente que de que obliga a que el cliente conozca dicho valor especial y adem\u00e1s debe acordarse de comprobar que el valor retornada no es el valor especial si quiere usarlo. En cierta manera estamos d\u00e1ndolo al cliente la responsabilidad de la comprobaci\u00f3n pero no estamos oblig\u00e1ndola a ello. La consecuencia es que si el desarrollador del c\u00f3digo cliente olvida realizar la comprobaci\u00f3n, estar\u00e1 usando un valor no v\u00e1lido. Este hecho se convierte en m\u00e1s peligroso a\u00fan si el valor retornado es <code>null</code>, porque si olvida realizar la comprobaci\u00f3n y m\u00e1s adelante en el c\u00f3digo se trata de acceder a una propiedad del objeto retornado por el m\u00e9todo, se producir\u00eda una excepci\u00f3n <code>NullPointerException</code>.</p> <p>Entonces, \u00bfcu\u00e1l es la soluci\u00f3n? La soluci\u00f3n propuesta por Java 8 es que el m\u00e9todo no retorne directamente un objeto de clase <code>T</code>, sino un <code>Optional&lt;T&gt;</code>. La ventaja de esta soluci\u00f3n es que si el c\u00f3digo cliente quiere acceder al objeto real debe forzosamente comprobar si el Optional tiene un valor presente o no, de manera que pueda extraerse.</p> <p>Es muy importante resaltar que no es posible tener un Optional cuyo valor contenido sea null.</p>"},{"location":"bloque_iii/tema_12/page-4/#construccion","title":"Construcci\u00f3n","text":"<p>La clase <code>Optional&lt;T&gt;</code> es una clase inmutable, por lo que no proporciona m\u00e9todos setter que permitan cambiar el valor que contiene. Adem\u00e1s el proceso de construcci\u00f3n de un Optional no se realizar a trav\u00e9s de un constructor, sino usando alguno de los m\u00e9todos est\u00e1ticos factor\u00eda que se indican a continuaci\u00f3n.</p> <ul> <li><code>static &lt;T&gt; Optional&lt;T&gt; empty()</code>: retorna un Optional que no contiene valor.</li> <li><code>static &lt;T&gt; Optional&lt;T&gt; of(T value)</code>: retorna un Optional que contiene un valor pasado como argumento. Si tratamos de pasar el valor <code>null</code> a dicho m\u00e9todo se producir\u00e1 una excepci\u00f3n.</li> <li><code>static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code>: retorna un Optional que contiene el valor pasado como argumento. A diferencia del m\u00e9todo anterior, si tratamos de pasar el valor <code>null</code>, el m\u00e9todo retorna un Optional vac\u00edo.</li> </ul> <pre><code>import java.util.Optional;\npublic class Construction{\npublic void show(){\nOptional&lt;Integer&gt; optional1 = Optional.empty(); //(1)!\nSystem.out.println(optional1);\nOptional&lt;Integer&gt; optional2 = Optional.of(1000); //(2)!\nSystem.out.println(optional2);\nOptional&lt;Integer&gt; optional3 = Optional.ofNullable(methodWhichCanReturnNull(5)); //(3)!\nSystem.out.println(optional3);\nOptional&lt;Integer&gt; optional4 = Optional.ofNullable(methodWhichCanReturnNull(2));\nSystem.out.println(optional4); Optional&lt;Integer&gt; optional5;\ntry {\noptional5 = Optional.of(null);\nSystem.out.println(optional5);\n} catch (NullPointerException e) {\nSystem.out.println(\"Se ha lanzado la excepci\u00f3n NullPointerException\");\n}       }\npublic static Integer methodWhichCanReturnNull(int num){        if (num &gt;= 5) {\nreturn num;\n} else {\nreturn null;\n}     }\npublic static void main(String[] args) {\nnew Construction().show();     }\n}\n</code></pre> <ol> <li>Crea un optional sin valor.</li> <li>Crea un optional con valor 1000</li> <li>Retorna un Optional vac\u00edo si el valor pasado como argumento es null:</li> </ol>"},{"location":"bloque_iii/tema_12/page-4/#igualdad","title":"Igualdad","text":"<p>Podemos comparar los valores de dos Optional con el m\u00e9todo <code>boolean equals(Object obj)</code>: compara los valores de los dos Optional. Dos Optional vac\u00edos de distinto tipo son considerados iguales:</p> <pre><code>import java.util.Optional; public class Equality {     public void show() {         Optional&lt;Integer&gt; optional1 = Optional.of(1000); //Crea un optional con valor 1000\nOptional&lt;Integer&gt; optional2 = Optional.of(1000);\nOptional&lt;Integer&gt; optional3 = Optional.empty();\nOptional&lt;String&gt; optional4 = Optional.empty();         System.out.println(optional1.equals(optional2)); //Comprueba  si tienen el mismo valor: true\nSystem.out.println(optional1 == optional2); //Comprueba si son  el mismo objeto: false\nSystem.out.println(optional3.equals(optional4));//Dos Optional  vac\u00edos de distinto tipo son considerados iguales: true\nSystem.out.println(optional3.equals(null));//False     \n}     public static void main(String[] args) { new Equality().show();     } }\n</code></pre>"},{"location":"bloque_iii/tema_12/page-4/#procesamiento","title":"Procesamiento","text":"<p>Supongamos que queremos usar el m\u00e9todo est\u00e1tico <code>Collections.max(collection)</code> que retorna el valor m\u00e1ximo contenido en una colecci\u00f3n:</p> <pre><code>// Suponiendo que list es una colecci\u00f3n de enteros\nInteger max = Collections.max(list);\n</code></pre> <p>Pero \u00bfqu\u00e9 ocurre si la colecci\u00f3n est\u00e1 vac\u00eda? En este caso el m\u00e9todo <code>max()</code> lanzar\u00e1 la excepci\u00f3n <code>NoSuchElementException</code>. \u00bfCu\u00e1l es el problema? Que el cliente debe mirar la documentaci\u00f3n para enterarse de ello y capturar la excepci\u00f3n o de lo contrario producir\u00e1 un error en tiempo de ejecuci\u00f3n. Est\u00e1 obligando a darse cuenta de que debe hacer:</p> <pre><code>try{\nInteger max = Collections.max(list);\n} catch(NoSuchElementException e){\n// ...\n}\n</code></pre> <p>\u00bfY si existiera una forma de indicar que el valor de retorno de una funci\u00f3n es opcional? Pues bien, Java 8 introdujo para este problema la clase <code>Optional&lt;T&gt;</code>.</p> <p>La clase <code>Optional&lt;T&gt;</code> es una clase parametrizada que representa la abstracci\u00f3n de un valor de retorno opcional. As\u00ed, podr\u00edamos codificar nuestro m\u00e9todo anterior haciendo que retorno un <code>Optional&lt;T&gt;</code> en vez de lanzar una excepci\u00f3n en el caso de que la colecci\u00f3n est\u00e9 vac\u00eda:</p> <pre><code>public static &lt;T extends Comparable&lt;T&gt;&gt; Optional&lt;T&gt; max(Collection &lt;? extends T&gt; coll){\ntry{\nreturn Optional.of(Collections.max(coll));\n} catch(NoSuchElementException){\nreturn Optional.empty();\n}\n}\n</code></pre> <p>En ese caso, cuando el cliente llame a este m\u00e9todo estar\u00e1 obligado a tratar el hecho de que puede que no se retorne un valor. No tiene que mirar la documentaci\u00f3n ni recordar hacer ning\u00fan tipo de comprobaci\u00f3n porque el tipo de terno es <code>Optional&lt;T&gt;</code>, de manera que si de verdad quiere obtener el valor, va a tener que comprobar si el Optional tiene o no valor.</p> <pre><code>Optional&lt;Integer&gt; maxOpt = max(list);\n</code></pre> <p>Veamos m\u00e1s m\u00e9todos de Optional:</p> <ul> <li><code>T get()</code>: si un valor est\u00e1 presente, devuelve el valor, de lo contrario lanza la excepci\u00f3n NoSuchElementException.</li> <li> <p><code>boolean isPresent()</code>: si un valor est\u00e1 presente, devuelve true, en caso contrario false.</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Optional; public class GetAndIsPresent {     public void show() {         List&lt;Integer&gt; list1 = List.of(3, 2, 6, 1, 5, 4);\nList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\nOptional&lt;Integer&gt; maximumOptional1 = max(list1);\nOptional&lt;Integer&gt; maximumOptional2 = max(list2);\nInteger maximum1 = 0, maximum2;    if (maximumOptional1.isPresent()) {\nmaximum1 = maximumOptional1.get();\n}\nSystem.out.println(maximumOptional1);//Optional[6]\nSystem.out.println(maximum1);//6         \nmaximum2 = maximumOptional2.isPresent() ? maximumOptional2.get() : 0;\nSystem.out.println(maximumOptional2);//Optional.empty\nSystem.out.println(maximum2);//0     \n}     public static &lt;T extends Comparable&lt;T&gt;&gt; Optional&lt;T&gt; max(Collection&lt;? extends T&gt; coll) {\ntry {\nreturn Optional.of(Collections.max(coll));\n} catch (NoSuchElementException e) {\nreturn Optional.empty();\n}\n} public static void main(String[] args) {         new GetAndIsPresent().show();     } }\n</code></pre> </li> <li> <p><code>T orElse(T other)</code>: si un valor est\u00e1 presente, devuelve el valor, de lo contrario devuelve el valor suministrado como argumento</p> </li> <li><code>T orElseGet(Supplier&lt;? extends T&gt; supplier)</code>: si hay un valor, devuelve el valor,  en  caso  contrario  devuelve  el  resultado  producido  por  la  funci\u00f3n suministradora.</li> <li><code>T orElseThrow()</code>: si un valor est\u00e1 presente, devuelve el valor, de lo contrario lanza la excepci\u00f3n NoSuchElementException.</li> <li> <p><code>&lt;X extends Throwable&gt; T orElseThrow(Suppler&lt;? extends X&gt; exceptionSupplier) throws x</code>: si hay un valor, devuelve el valor, en caso contrario, lanza una excepci\u00f3n producida por la funci\u00f3n suministradora.</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.Random;\npublic class OrElse {     public void show() {         List&lt;Integer&gt; list1 = List.of(3, 2, 6, 1, 5, 4);\nList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\nOptional&lt;Integer&gt; maximumOptional1 = max(list1);\nOptional&lt;Integer&gt; maximumOptional2 = max(list2);\nInteger maximum1, maximum2; maximum1 = maximumOptional1.orElse(0);\nmaximum2 = maximumOptional2.orElse(0);\nSystem.out.println(maximum1);//6\nSystem.out.println(maximum2);//0         \nmaximum1 = maximumOptional1.orElseGet(() -&gt; obtainRandomNumber());\nmaximum2 = maximumOptional2.orElseGet(() -&gt; obtainRandomNumber());\nSystem.out.println(maximum1);//6\nSystem.out.println(maximum2);//N\u00famero aleatorio entre 1 y  10\nmaximum1 = maximumOptional1.orElseThrow();\nSystem.out.println(maximum1);//6\ntry {\nmaximum2 = maximumOptional2.orElseThrow();\n} catch (NoSuchElementException e) {\nSystem.out.println(\"Valor no presente\");\n}\nmaximum1 = maximumOptional1.orElseThrow(IllegalStateException::new);\nSystem.out.println(maximum1);//6\ntry {\nmaximum2 = maximumOptional2.orElseThrow(IllegalStateException::new);\n} catch (IllegalStateException e) {\nSystem.out.println(\"Valor no presente\");\n}     }     public Integer obtainRandomNumber() {\nreturn new Random().nextInt(10) + 1;//Devuelve un n\u00famero aleatorio entre 1 y 10\n}     public static &lt;T extends Comparable&lt;T&gt;&gt; Optional&lt;T&gt; max(Collection&lt;? extends T&gt; coll){\ntry {\nreturn Optional.of(Collections.max(coll));\n} catch (NoSuchElementException e) {\nreturn Optional.empty();\n}\n}     public static void main(String[] args) {\nnew OrElse().show();     } </code></pre> </li> <li> <p><code>Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</code>: se introdujo en Java 9 para encadenar Optionals. Si el Optional original contiene un valor, el m\u00e9todo retorna un nuevo Optional con dicho valor. Si el Optional original no contiene el valor, el m\u00e9todo retornar\u00e1 el Optional producido por la funci\u00f3n suministradora.</p> </li> <li><code>&lt;U&gt; Optional&lt;U&gt; map(Function &lt;? super T, ? extends U&gt; mapper)</code>: sirve para transformar el valor contenido en un Optional. Si el Optional original est\u00e1 vac\u00edo, devuelve un nuevo Optional vac\u00edo y si tiene valor, devolver\u00e1 el Optional que contendr\u00e1 como valor el resultado de aplicar la funci\u00f3n de transformaci\u00f3n al valor contenido en el Optional original. Si dicha funci\u00f3n devuelve un resultado nulo, entonces se devuelve un Optional vac\u00edo.</li> <li> <p><code>Optional&lt;T&gt; filter(Predicate &lt;? super T&gt; predicate)</code>: retorna un nuevo Optional que estar\u00e1 vac\u00edo si el Optional original estaba vac\u00edo o si no se cumple el predicado recibido como argumento (su m\u00e9todo <code>test()</code> retorna <code>false</code>). Si el Optional original conten\u00eda un valor y dicho valor cumple con el predicado, el nuevo Optional retornado contendr\u00e1 el valor del Optional original.</p> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.Random;\npublic class OrMapFilter {     public void show() {         List&lt;Integer&gt; list1 = List.of(3, 2, 6, 1, 5, 4);\nList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\nOptional&lt;Integer&gt; maximumOptional1 = max(list1);\nOptional&lt;Integer&gt; maximumOptional2 = max(list2);\nOptional&lt;Integer&gt; maximumOptional3, maximumOptional4, maximumOptional5;         maximumOptional3 = maximumOptional1.or(() -&gt; Optional.of(obtainRandomNumber()));\nmaximumOptional4 = maximumOptional2.or(() -&gt; Optional.of(obtainRandomNumber()));\nSystem.out.println(maximumOptional3);//Optional[6]\nSystem.out.println(maximumOptional4);//Optional de un n\u00famero aleatorio\nmaximumOptional3 = maximumOptional1.map(n -&gt; n * 2);\nmaximumOptional4 = maximumOptional2.map(n -&gt; n * 2);\nSystem.out.println(maximumOptional3);//Optional[12]\nSystem.out.println(maximumOptional4);//Optional.empty  \nmaximumOptional3 = maximumOptional1.filter(n -&gt; n % 2 == 0);\nmaximumOptional4 = maximumOptional1.filter(n -&gt; n % 2 != 0);\nmaximumOptional5 = maximumOptional2.filter(n -&gt; n % 2 == 0);\nSystem.out.println(maximumOptional3);//Optional[6]\nSystem.out.println(maximumOptional4);//Optional.empty\nSystem.out.println(maximumOptional5);//Optional.empty\n}     public Integer obtainRandomNumber() {\nreturn new Random().nextInt(10) + 1;//Devuelve un n\u00famero aleatorio entre 1 y 10\n}     public static &lt;T extends Comparable&lt;T&gt;&gt; Optional&lt;T&gt; max(Collection&lt;? extends T&gt; coll)     {\ntry {\nreturn Optional.of(Collections.max(coll));\n} catch (NoSuchElementException e) {\nreturn Optional.empty();\n}\n}     public static void main(String[] args) {         new OrMapFilter().show();     } }\n</code></pre> </li> <li> <p><code>void ifPresent(Consumer &lt;? super T&gt; action)</code>: permite consumir (usar) directamente el valor contenido en Optional si es que \u00e9ste contiene un valor. Si el Optional est\u00e1 vac\u00edo, no hace nada.</p> </li> <li><code>void ifPresentOrElse(Consumer &lt;? super T&gt; action, Runnable emptyAction)</code>: se incorpor\u00f3 este m\u00e9todo en Java 9. Ejecuta el consumidor pasado como argumento si el Optional posee un valor o ejecuta el Runnable pasado como argumento si el Optional no contiene ning\u00fan valor.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\npublic class IfPresent {     public void show() {         List&lt;Integer&gt; list1 = List.of(3, 2, 6, 1, 5, 4);\nList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\nOptional&lt;Integer&gt; maximumOptional1 = max(list1);\nOptional&lt;Integer&gt; maximumOptional2 = max(list2);\nmaximumOptional1.ifPresent(System.out::println);//6\nmaximumOptional2.ifPresent(System.out::println);//No hace nada         \nmaximumOptional1.ifPresentOrElse(System.out::println,() -&gt; System.out.println(\"No hay m\u00e1ximo porque la lista est\u00e1 vac\u00eda\"));//6\nmaximumOptional2.ifPresentOrElse(System.out::println,() -&gt; System.out.println(\"No hay m\u00e1ximo porque la  lista est\u00e1 vac\u00eda\"));//No hay m\u00e1ximo porque la lista est\u00e1 vac\u00eda     \n}     public static &lt;T extends Comparable&lt;T&gt;&gt; Optional&lt;T&gt; max(Collection&lt;? extends T&gt; coll){\ntry {\nreturn Optional.of(Collections.max(coll));\n} catch (NoSuchElementException e) {\nreturn Optional.empty();\n}\n}     public static void main(String[] args) {         new IfPresent().show();     } }\n</code></pre> <p>Desafortunadamente, no podemos garantizar que la referencia al objeto Optional en s\u00ed no sea <code>null</code>. De hecho, en todos los ejemplos anteriores estamos confiando en que el m\u00e9todo <code>max()</code> nunca va a retornar un <code>null</code>. Otros lenguajes de programaci\u00f3n m\u00e1s modernos, como Kotlin o Swift, incorporan el concepto de Optional al sistema de tipos, de manera que existir\u00e1n dos tipos distintos, uno que incorpora la posibilidad de tener el valor <code>null</code> y otro tipo que no lo permite. Por ejemplo, en Kotlin existe el tipo <code>String</code>, que no puede contener el valor <code>null</code> y el tipo <code>String?</code>, que s\u00ed puede contenerlo. Al establecer el tipo de retorno de una funci\u00f3n tendremos que decidir si el tipo de retorno del m\u00e9todo es <code>String?</code>, el cliente deber\u00e1 comprobar si realmente se ha retornado un valor o no, pero siempre podr\u00e1 realizar la comprobaci\u00f3n. El problema de Java es que al encapsular un valor en un objeto Optional, el propio objeto Optional podr\u00eda ser <code>null</code> y deber\u00edamos fiarnos de que eso nunca puede suceder o realizar la comprobaci\u00f3n cada vez. Evidentemente, cualquier desarrollador que realiza un m\u00e9todo que retorna un Optional deber\u00eda asegurarse y documentar que dicho m\u00e9todo nunca retornar\u00e1 <code>null</code>, sino siempre un Optional.</p>"},{"location":"bloque_iii/tema_12/page-4/#donde-no-usar-optional","title":"D\u00f3nde no usar Optional","text":"<p>Debemos tener en cuenta que la clase <code>Optional&lt;T&gt;</code> ha sido dise\u00f1ada espec\u00edficamente para ser usada como tipo de retorno de los m\u00e9todos. No se recomienda su uso en los siguientes casos:</p> <ul> <li>No se recomienda usar Optional como tipo de los atributos de una clase.</li> <li>No se recomienda usar Optional como tipo de los par\u00e1metros de un m\u00e9todo porque ensucian mucho el c\u00f3digo y realmente no hacen que el par\u00e1metro sea opcional.</li> <li>No se recomienda usar Optional como tipo de una colecci\u00f3n, como por ejemplo en una lista.</li> </ul>"},{"location":"bloque_iii/tema_12/page-5/","title":"Proyecto y ejercicios","text":"<p>En este proyecto se llevar\u00e1 acabo una serie de ejercicios sobre la programaci\u00f3n funcional.</p> <p>IMPORTANTE</p> <p>S\u00f3lo se crear\u00e1 un \u00fanico proyecto, para cada ejercicio se deber\u00e1 crear una nueva versi\u00f3n del mismo a trav\u00e9s de GitHub, teniendo que usar tags para cada versi\u00f3n cuyo nombre sea vX.0 d\u00f3nde X es el n\u00famero de ejercicio</p> Ejercicio 1 <p>Crear una interfaz <code>Predicate</code>, que tenga un \u00fanico m\u00e9todo llamado <code>test(entero)</code> que reciba un entero y retorne un booleano.</p> <p>Crea una clase llamada <code>IsPrime</code> que implemente la interfaz <code>Predicate</code> y cuyo m\u00e9todo <code>test(entero)</code> retorne true si el entero recibido es un n\u00famero primo.</p> <p>Crea una clase <code>SuperFunctions</code>, que posea los siguientes m\u00e9todos est\u00e1ticos:</p> <ol> <li><code>count(list, predicate)</code>: Retorna el n\u00famero de elementos de la lista que cumplen con el predicado recibido. En el <code>main</code> llama a dicho m\u00e9todo est\u00e1tico para obtener cu\u00e1ntos n\u00fameros hay que sean primos en una lista pasada como argumento. As\u00ed, si la lista es <code>[5, 7, 2, 4, 9, 5, 15, 3]</code>, el m\u00e9todo est\u00e1tico debe retornar <code>5</code>, ya que contiene los siguientes n\u00fameros primos <code>5, 7, 2, 5, 3</code>.</li> <li><code>allMatch(list, predicate)</code>: Retorna true si todos los elementos de la lista cumplen con el predicado recibido. En el <code>main</code> llama a dicho m\u00e9todo est\u00e1tico para obtener si todos los n\u00fameros de la lista son primos.</li> <li><code>noneMatch(list, predicate)</code>: Retorna true si ning\u00fan elemento de la lista cumple con el predicado  recibido.  En  el main   llama  a  dicho  m\u00e9todo  est\u00e1tico  para  obtener  si  ninguno  de  los n\u00fameros de la lista es primo.</li> <li><code>anyMatch(list,  predicate)</code>:  Retorna true si  alg\u00fan  elemento  de  la  lista  cumple  con  el predicado recibido. En el <code>main</code>  llama a dicho m\u00e9todo est\u00e1tico para obtener si alguno de los n\u00fameros de la lista es primo.</li> <li><code>takeWhile(list, predicate)</code>: Retorna una nueva lista creada a partir de los elementos de la lista recibida como argumento, de manera que va tomando valores de la lista original mientras \u00e9stos cumplan con el predicado recibido. En cuanto un elemento no cumple el predicado se dejan de incluir elementos en la lista resultante. Por ejemplo, si le pasamos la lista <code>[5, 7, 2, 4, 9, 5, 15, 3]</code> y el predicado de que el n\u00famero sea primo, la funci\u00f3n deber\u00e1 retornar la lista <code>[5, 7, 2]</code>, ya que el <code>4</code> ya no es primo. Prueba el ejemplo anterior desde el <code>main</code>.</li> <li><code>dropWhile(list, predicate)</code>: Retorna una nueva lista creada a partir de los elementos de la lista recibida como argumento, de manera que el primer elemento que es incluido en la lista resultante es  aquel  que  no  cumple  con  el  predicado  recibido  como  argumento,  y  a  partir  de  dicho  elemento  el resto de elementos de la lista original son incluidos sin realizar ninguna comprobaci\u00f3n. Por ejemplo, si le pasamos la lista <code>[5, 7, 2, 4, 9, 5, 15, 3]</code> y el predicado de que el n\u00famero sea primo, la funci\u00f3n  deber\u00e1  retornar  la  lista <code>[4, 9, 5, 15, 3]</code>, porque  el  primer  n\u00famero  no  primo  de  la  lista original es <code>4</code>. Prueba el ejemplo anterior desde el  main .</li> </ol> Ejercicio 2 <p>Crea una interfaz <code>Function</code>, que tenga un \u00fanico m\u00e9todo llamado <code>apply(entero)</code>que reciba un entero y retorne un entero.</p> <p>Crea una clase llamada <code>Triple</code> que implemente la interfaz <code>Function</code> y cuyo m\u00e9todo <code>apply(entero)</code>retorne el triple del entero recibido.</p> <p>Crea  una  clase  llamada <code>LessThan100</code>   que  implemente  la  interfaz <code>Predicate</code>  y cuyo m\u00e9todo <code>test(entero)</code> retorne  true si el entero recibido es &gt;= 0 y menor que 100.</p> <p>En la clase  SuperFunctions  agrega los siguientes m\u00e9todos est\u00e1ticos:</p> <ol> <li><code>iterate(integerSeed,  count,  function)</code>: Retorna  una  lista  con <code>count</code>  elementos  (se debe lanzar una excepci\u00f3n si <code>count  &lt;=  0</code>), donde el primer elemento corresponde a <code>integerSeed</code> y  el  resto  de  elementos  se  calcula  aplicando  la  funci\u00f3n  recibida  al  elemento anterior.  Por  ejemplo,  si <code>integerSeed</code> es 1, <code>count</code> es 4 y la funci\u00f3n es calcular el triple,  el m\u00e9todo debe retornar la lista  <code>[1, 3, 9, 27]</code></li> <li><code>iterate(integerSeed, max, predicate,  function)</code>:  Retorna  una  lista  donde  el  primer elemento  corresponde  a <code>integerSeed</code> y  el  resto  de  elementos  se  calcula  aplicando  la  funci\u00f3n recibida  al  elemento  anterior.  En  cuanto  un  elemento  generado  no  cumple  con  el  predicado  dicho elemento no es incluido en la lista resultante y \u00e9sta se da por concluida. Si la lista resultante alcanza el n\u00famero m\u00e1ximo de elementos <code>max</code> la lista se da por concluida. Por ejemplo, si <code>integerSeed</code> es 1, <code>max</code> es 10, el predicado es que el n\u00famero sea menor que 100 y la funci\u00f3n es calcular  el triple, el m\u00e9todo debe retornar la lista <code>[1, 3, 9, 27, 81]</code>, ya que  243 (81 * 3)  ya no es menor que 100. Si el predicado se cumple siempre, como por ejemplo si en el caso anterior <code>integerSeed</code> es 0 , se retornar\u00e1 una lista cuyo tama\u00f1o corresponder\u00e1 a <code>max</code>, en nuestro caso <code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</code>.</li> </ol> Ejercicio 3 <p>Crea una interfaz <code>ConsumerBinary</code>, que tenga un \u00fanico m\u00e9todo <code>accept(entero1,entero2)</code>  que reciba dos enteros y no retorne nada.</p> <p>Crea  una  clase <code>PrinterWithIndex</code> que  implemente  la  interfaz <code>ConsumerBinary</code> y cuyo m\u00e9todo <code>accept(entero1, entero2)</code> muestre por consola el mensaje \"El valor {entero2} tiene el \u00edndice {entero1}\"  sustituyendo <code>{entero2}</code> por  el  valor  de entero2 y {entero1}   por  el  valor  de{entero1} </p> <p>Crear una interfaz <code>FunctionBinary</code>, que tenga un \u00fanico m\u00e9todo <code>apply(entero1, entero2)</code> que reciba dos enteros y retorne un entero.</p> <p>Crea una clase <code>Subtractor</code> que implemente dicha interfaz y cuyo m\u00e9todo <code>apply()</code> retorne el resultado de restarle entero1 a entero2.</p> <p>En la clase <code>SuperFunctions</code> agrega los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>actWithIndex(list, consumerBinary)</code>: Para cada elemento de la lista llama al m\u00e9todo <code>accept</code> del consumidor binario pas\u00e1ndole como primer argumento el \u00edndice del elemento y como segundo argumento el elemento en s\u00ed. La funci\u00f3n debe retornar una nueva lista con los elementos de la lista original. Por ejemplo, si la lista es <code>[10, 20, 30]</code> y el <code>consumerBinary</code> es un objeto de la clase <code>PrinterWithIndex</code>, se debe mostrar por consola:</li> </ul> <p><pre><code>El valor 10 tiene el \u00edndice 0\nEl valor 20 tiene el \u00edndice 1\nEl valor 30 tiene el \u00edndice 2\n</code></pre> La funci\u00f3n debe retornar <code>[10, 20, 30]</code>.</p> <ul> <li><code>consumeWithIndex(list, consumerBinary)</code>: Para cada elemento de la lista llama al m\u00e9todo <code>accept</code> del consumidor binario pas\u00e1ndole como primer argumento el \u00edndice del elemento y como segundo argumento el m\u00e9todo en s\u00ed. La funci\u00f3n no debe retornar nada.</li> <li><code>reduceFromEnd(list, functionBinary)</code>: Retorna un valor entero con el resultado de aplicar la operaci\u00f3n de reducci\u00f3n indicada por la <code>functionBinary</code> pero tomando como primer elemento el \u00faltimo de la lista original. Si la lista original estuviera vac\u00eda retornar\u00e1 <code>null</code>. Por ejemplo, si la lista es <code>[1, 3, 9, 27]</code> y la funci\u00f3n binaria corresponde a un objeto de la clase <code>Subtractor</code>, la funci\u00f3n debe retornar 14, que corresponde a la operaci\u00f3n 27 - 9 - 3 - 1.</li> <li><code>reduceFromEnd(list, identity, functionBinary)</code>: Retorna un valor entero con el resultado de aplicar la operaci\u00f3n de reducci\u00f3n indicada por la <code>functionBinary</code> pero tomado como primer elemento el \u00faltimo de la lista original. El valor inicial de acumulador corresponder\u00e1 a <code>identity</code>. Por ejemplo, si la lista es <code>[1, 3, 9, 27]</code>, identidad corresponde <code>0</code> y la funci\u00f3n binaria corresponde a un objeto de la clase <code>Subtractor</code>, la funci\u00f3n debe retornar -40, que corresponde a la operaci\u00f3n 0 - 27 - 9 - 3 - 1.</li> </ul> Ejercicio 4 <p>Realiza las siguientes modificaciones:</p> <ul> <li>En el main(), realiza las llamadas anteriores a las funciones haciendo uso de las clases an\u00f3nimas inline, en vez de usar las clases <code>IsPrime</code>, <code>Triple</code>, <code>NaturalLessThan100</code>, <code>PrinterWithIndex</code> o <code>Subtractor</code>, que puedes eliminar tranquilamente.</li> <li>Modifica las interfaces para que en vez de trabajar con enteros, sean interfaces gen\u00e9ricas parametrizadas que funcionen con tipos gen\u00e9ricos.</li> <li>Modifica los m\u00e9todos de la clase <code>SuperFunction</code> para que se adapten a los cambios descritos anteriormente.</li> <li>Vuelve a cambiar en el main(), las llamadas a las funciones, haciendo uso de las clases an\u00f3nimas inline, pero en esta ocasi\u00f3n haciendo uso de los parametrizadas con el tipo adecuado.</li> </ul> Ejercicio 5 <p>Crea la clase <code>Stream&lt;T&gt;</code>, que representa un flujo, y a\u00f1\u00e1dele los m\u00e9todos de la clase <code>SuperFunctions</code>, sin que sean est\u00e1ticos (excepto el m\u00e9todo <code>iterate</code>). (La clase <code>SuperFunctions</code> podr\u00e1 ser eliminada).</p> <p>Haz que los m\u00e9todos de la clase retornen un nuevo flujo en vez de una lista.</p> <p>Agrega a la clase <code>Stream&lt;T&gt;</code> los m\u00e9todos:</p> <ul> <li><code>filter(predicate)</code>: retorna un nuevo flujo con los elementos de la lista original que cumplan el predicado.</li> <li><code>map(function)</code>: retorna un nuevo flujo con los elementos \"transformados\" del flujo original. Por ejemplo, si la flujo inicial est\u00e1 formado por los n\u00fameros del 1 al 10 y se quiere transformar al cuadrado de dichos n\u00fameros (el valor de <code>function</code> ser\u00eda una clase an\u00f3nima inline, que la implementaci\u00f3n de su m\u00e9todo <code>apply</code>retorne el cuadrado de un n\u00famero).</li> <li><code>of(vararg)</code>: m\u00e9todo est\u00e1tico que recibe un vararg de elementos, que retornar\u00e1 un flujo con los elementos recibidos.</li> <li><code>from(collection)</code>: m\u00e9todo est\u00e1tico que recibe una colecci\u00f3n de elementos y retornar\u00e1 un nuevo flujo con los elementos recibidos.</li> <li><code>recolectar()</code>: retorna una lista con los elementos gestionados por el flujo.</li> </ul> <p>Realiza un main que cree un flujo usando el m\u00e9todo est\u00e1tico <code>iterate(integerSeed, count, function)</code>, donde <code>integerSeed</code>, sea 1, <code>count</code>sea 5 y <code>function</code> sea una <code>Function&lt;Integer&gt;</code> cuyo m\u00e9todo <code>apply()</code> retorna el valor recibido multiplicado por 5 y se le sume 1. Despu\u00e9s el flujo generado ser\u00e1 filtrado de manera que se obtenga un nuevo flujo con s\u00f3lo los valores del anterior que sean pares. Despu\u00e9s se deber\u00e1 obtener un nuevo flujo con los valores del anterior convertidos a cadena con el formato <code>-valor-</code> y finalmente dicho flujo se reduzca haciendo uso del m\u00e9todo <code>reduceFromEnd()</code>, de manera que se obtenga una \u00fanica cadena de caracteres. Por ejemplo <code>-156--6-</code>.</p> Ejercicio 6 <p>Realiza la versi\u00f3n anterior modificando lo siguiente:</p> <ul> <li>A\u00f1ade la anotaci\u00f3n <code>@FunctionalInterface</code> a todas las interfaces definidas.</li> <li>Reemplaza las clases an\u00f3nimas con expresiones lambdas.</li> </ul> Ejercicio 7 <p>En esta versi\u00f3n elimina las interfaces funcionales y reempl\u00e1zalas en la clase <code>Stream&lt;T&gt;</code>  por las interfaces funcionales predefinidas en Java 8.</p> Ejercicio 8 <p>Crea una clase <code>MyAppUtils</code> con los siguientes m\u00e9todos est\u00e1ticos:</p> <ul> <li><code>quintupleMoreOne(value)</code>: recibe un entero y retorna dicho valor multiplicado por 5 y despu\u00e9s sum\u00e1ndole 1.</li> <li><code>isEven(value)</code>: recibe un entero y retorna true si el n\u00famero es par.</li> <li><code>withDashes(value)</code>: recibe un entero y retorna la cadena <code>-value-</code>.</li> <li><code>concat(str1, str2)</code>: retorna la concatenaci\u00f3n de ambas cadenas recibidas.</li> </ul> <p>Haciendo uso de la referencias a m\u00e9todos, sustituye las expresiones lambda por la llamada a estos m\u00e9todos.</p> Ejercicio 9 <p>Realiza los m\u00e9todos anteriores dentro de la misma clase Main sin definirlos de forma est\u00e1tica y eliminado la clase <code>MyAppUtils</code>. Adem\u00e1s en vez de usar el m\u00e9todo <code>concat</code> (que puede ser eliminado) se usar\u00e1 el m\u00e9todo <code>concat</code> de la clase <code>String</code>.</p> Ejercicio 10 <p>Agrega a la clase <code>Stream&lt;T&gt;</code> un m\u00e9todo <code>find(predicate)</code> que encuentre el primer elemento que cumple con el predicado y lo retorne en un <code>Optional&lt;T&gt;</code>.</p> <p>Agrega tambi\u00e9n, un m\u00e9todo llamada <code>findLast(predicate)</code> que encuentre el \u00faltimo elemento que cumple con el predicado y lo retorne en un <code>Optional&lt;T&gt;</code>.</p>"},{"location":"bloque_iii/tema_13/page-1/","title":"1 Introducci\u00f3n a los Streams","text":""},{"location":"bloque_iii/tema_13/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Un stream (flujo) en Java es una secuencia de elementos que se pueden procesar (mapear, filtrar, transformar, reducir y recolectar), de forma secuencial o paralela, mediante una cadena de operaciones especificadas a trav\u00e9s de expresiones lambda. Introducidos en Java 8, los streams permiten optimizar la forma de procesar grandes colecciones de datos.</p> <p>La interfaz <code>Stream&lt;T&gt;</code> representa un flujo de elementos de tipo <code>T</code> aunque tambi\u00e9n se definen interfaces concretas para los tipos primitivos, como <code>IntStream</code>, <code>LongStream</code>, etc.</p> <p>Un stream es una abstracci\u00f3n que representa un flujo de datos pero no una estructura de datos, ya que los elementos no son almacenados en el stream, sino tan solo procesador por \u00e9l. De hecho, no se puede acceder individualmente a un determinado elemento del stream, sino que se define la fuente de datos origen del stream y la secuencia de operaciones que se deben aplicar sobre sus elementos, especificadas de forma funcional mediante expresiones lambda.</p> <p>M\u00e1s a\u00fan, la fuente de datos de origen del stream no se ve afectada por las operaciones realizadas dentro del stream. Por ejemplo, si se filtran algunos elementos de datos del stream, no se eliminan realmente de la fuente de datos origen, simplemente se omiten en el stream a partir de ese momento y ya no se tienen en cuenta la siguiente operaci\u00f3n incluida en la secuencia de operaciones del stream. Por tanto, los datos con los que trabajamos no se ven afectados por el stream.</p> <p>Los streams solo gestionan datos transitorios en memoria, lo que implica que si la aplicaci\u00f3n falla dichos datos se perder\u00e1n.</p> <p>Un stream puede ser finito, es decir, tener un n\u00famero finito de elementos, o infinito, si genera un n\u00famero infinito de elementos. Algunas operaciones permiten restringir el n\u00famero de elementos procesados, como <code>limit()</code> o <code>findFirst()</code>.</p>"},{"location":"bloque_iii/tema_13/page-1/#pipeline","title":"Pipeline","text":"<p>Una vez hayamos creado un stream a partir de una fuentes de datos, podemos ejecutar sobre \u00e9l cero o m\u00e1s operaciones intermedias, y forzosamente, una operaci\u00f3n final. A esta cadena de operaciones se le conoce como pipeline. Un pipeline tiene los siguientes elementos en el siguiente orden:</p> <ol> <li>Una funci\u00f3n generadora del stream.</li> <li>Cero o m\u00e1s operaciones intermedias.</li> <li>Un operaci\u00f3n terminal.</li> </ol> <p>Debemos tener en cuenta que cada operaci\u00f3n intermedia del pipeline genera un nuevo stream resultante de aplicar la operaci\u00f3n indicada al stream anterior de la cadena.</p> <ul> <li>Operaciones intermedias (aggregate operations): producen como resultado un nuevo stream. Se usan para transformar, filtrar y clasificar los elementos del stream. Puede ser:<ul> <li>Operaciones sin estado: al aplicarlas, el procesamiento de un elemento del stream es independiente de cualquier otro elemento del mismo. Por ejemplo, la operaci\u00f3n de filtrado es sin estado, ya que el filtro de cada elemento s\u00f3lo depende de una condici\u00f3n, no de ning\u00fan otro elemento del stream.</li> <li>Operaciones con estado: al aplicarlas, el procesamiento de un elemento del stream depende de alg\u00fan otro elemento del mismo. Por ejemplo, la operaci\u00f3n de ordenaci\u00f3n es con estado, ya que para posicionar un elemento es necesario compararlo con el resto.</li> </ul> </li> <li>Operaciones terminales (terminal operations): procesan todos los elementos del stream para generar un resultado o un efecto secundario. De hecho, no retornan un stream. Despu\u00e9s de su ejecuci\u00f3n, el stream original no puede ser usado de nuevo, produciendo una excepci\u00f3n si se intenta. De ah\u00ed que se denominen operaciones terminales. Por tanto, un determinado stream puede ser usado una sola vez; si necesitamos procesar la misma fuente de datos, deberemos crear un nuevo stream con ella como origen.</li> </ul> <p>Otra caracter\u00edstica important\u00edsima del pipeline es que es perezoso (lazy), lo que quiere decir que las operaciones intermedias s\u00f3lo son ejecutadas cuando las requiere la operaci\u00f3n terminal que se est\u00e9 ejecutando.</p> <p>Por defecto, los elementos de un stream son procesados secuencialmente de uno en uno en el mismo hilo de ejecuci\u00f3n. Es lo que se conoce como stream secuencial. Sin embargo, podemos convertir un stream secuencial en un stream paralelo con tan s\u00f3lo llamar a su m\u00e9todo <code>parallel()</code>. Los elementos de los streams paralelos son agrupados en conjuntos y se usa un grupo de hilos en ejecuci\u00f3n, denominados common fork-join pool, para procesar estos conjuntos de elementos en hilos de ejecuci\u00f3n independientes.</p> <p>Debemos tener en cuenta que al llamar al m\u00e9todo <code>parallel()</code> se convierte el stream completo en paralelo, no solo desde el punto en el que se llama al m\u00e9todo.</p> <p>Debemos tener en cuenta que las operaciones intermedias con estado no utilizar\u00e1n todas las posibilidades de paralelismo existentes, dada su naturaleza en lo relativo a lo dependencia entre elementos.</p>"},{"location":"bloque_iii/tema_13/page-1/#modelo-mapreduce","title":"Modelo MapReduce","text":"<p>En Java, los streams utilizan el modelo MapReduce, que es un modelo de programaci\u00f3n utilizado para procesar conjuntos de datos muy grandes y que ha sido adoptado por la programaci\u00f3n funcional. Este modelo se basa en los siguientes tipos de operaciones:</p> <ul> <li>Transformaci\u00f3n (map): filtra o crea copias modificadas de los elementos originales. Todas las operaciones intermedias de los streams corresponden a operaciones de transformaci\u00f3n.</li> <li> <p>Reducci\u00f3n (reduce): genera un resultado resumen de todos los elementos, por ejemplo, la suma o la media aritm\u00e9tica. Las operaciones terminales de la clase <code>Stream</code> corresponde a operaciones de reducci\u00f3n. De hecho, la clase <code>Stream</code> implementa dos operaciones de reducci\u00f3n diferentes:</p> <ul> <li>De reducci\u00f3n pura: implementada en las diferentes versiones del m\u00e9todo <code>reduce</code>, que procesa un flujo de elementos para obtener un \u00fanico valor.</li> <li>De reducci\u00f3n mutable: implementada en las diferentes versiones del m\u00e9todo <code>collect</code>, que procesa un flujo de elementos para generar una estructura de datos mutable, como por ejemplo, una colecci\u00f3n.</li> </ul> </li> </ul>"},{"location":"bloque_iii/tema_13/page-1/#creacion-de-un-stream-a-partir-de-una-fuente-de-datos","title":"Creaci\u00f3n de un stream a partir de una fuente de datos","text":"<p>Java permite muchas maneras de crear un stream, dependiendo de la fuente de datos origen deseada. Veamos algunas de estas fuentes:</p> <ul> <li> <p>Colecci\u00f3n: se ejecuta el m\u00e9todo <code>stream()</code> sobre una colecci\u00f3n para crear un stream que tenga como fuente de datos de origen dicha colecci\u00f3n. Tambi\u00e9n tenemos disponible el m\u00e9todo <code>parallelStream()</code> para que los elementos sean procesados en modo paralelo.</p> <p>Podemos crear un stream a partir del cualquier interfaz que extienda de <code>Collection</code>, como <code>List</code>, <code>Set</code> o <code>Queue</code> y cualquiera de las clases que implementen dichas interfaces. Por ejemplo, desde una lista:</p> <pre><code>List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4);\nStream&lt;Integer&gt; stream = list.stream();\n</code></pre> <p>o desde el <code>Set</code> correspondiente a las entradas de un <code>Map</code>:</p> <pre><code>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\nStream&lt;Map.Entry&lt;Integer, String&gt;&gt; stream = map.entrySet().stream();\n</code></pre> </li> <li> <p>Array: el m\u00e9todo est\u00e1tico <code>Arrays.stream(array)</code> recibe un array, que actuar\u00e1 como fuente de datos origen del stream. Ejemplo:</p> <pre><code>Integer array[] = {1, 2, 3, 4};\nStream&lt;Integer&gt; stream = Arrays.stream(array);\n</code></pre> </li> <li> <p>Conjunto predeterminado de elementos: el m\u00e9todo est\u00e1tico <code>Stream.of()</code> recibe un n\u00famero variable de elementos que actuar\u00e1n como fuente de datos origen del stream. Ejemplo</p> <pre><code>Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4);\n</code></pre> </li> <li> <p>Funci\u00f3n suministradora de objetos (interfaz funcional <code>Supplier</code>): el m\u00e9todo est\u00e1tico <code>Stream.generate()</code> recibe un <code>Supplier</code>, es decir, una funci\u00f3n suministradora de elementos, que actuar\u00e1 como fuente de datos origen infinita para el stream. Ejemplo:</p> <pre><code>Stream&lt;Integer&gt; stream = Stream.generate(new Random()::nextInt);\n</code></pre> </li> <li> <p>Un valor inicial y una funci\u00f3n que obtiene el siguiente elemento a partir del anterior: el m\u00e9todo est\u00e1tico <code>Stream.iterate(seed, unaryOperator)</code> recibe un valor inicial y una funci\u00f3n que recibe el elemento anterior y retorna el valor del nuevo elemento, que debe ser del mismo tipo. Se tratar\u00e1 de un stream infinito.</p> <p>Ejemplo:</p> <pre><code>Stream&lt;Integer&gt; stream = Stream.iterate(0, x -&gt; x + 5);\n</code></pre> <p>Java 9 introdujo una nueva versi\u00f3n de este m\u00e9todo <code>Stream.iterate(seed, predicate, unaryOperator)</code> que recibe un par\u00e1metro intermedia adicional correspondiente a un predicate que al dejar de cumplir hace que el stream no emita m\u00e1s valores, convirti\u00e9ndose en un stream finito. Ejemplo:</p> <pre><code>Stream&lt;Integer&gt; stream = Stream.iterate(0, x -&gt; x &lt; 100, x -&gt; x + 5);\n</code></pre> </li> <li> <p>Detectando patrones en una cadena: el m\u00e9todo <code>splitAsStream(cadena)</code> de la clase <code>Pattern</code> permite dividir una cadena en base a un patr\u00f3n y retornar un stream de subcadenas. Por ejemplo:</p> <pre><code>Stream&lt;String&gt; stream = Pattern.compile(\",\".splitAsStream(\"Luis,Paco,Ricardo\"));\n</code></pre> <p>retorna un stream cuyos elementos ser\u00e1n Luis, Paco y Ricardo.</p> </li> <li> <p>Generador de n\u00fameros aleatorios: el m\u00e9todo <code>ints(limiteInf, limiteSup)</code> de la clase <code>Random</code> retorna un stream (un <code>IntStream</code>) cuya fuente de datos origen es el generador de n\u00fameros aleatorios contenidos entre <code>limiteInf</code> y <code>limiteSup</code>. Es especialmente \u00fatil para hacer pruebas. Ejemple:</p> <pre><code>IntStream stream = new Random().ints(1, 100);\n</code></pre> </li> <li> <p>M\u00e9todos est\u00e1ticos de la clase IntStream:</p> <ul> <li> <p><code>IntStream.range(start, end)</code>: retorna un <code>IntStream</code> ordenado cuyos elementos corresponden a los enteros que van desde <code>start</code> hasta <code>end - 1</code>, es decir, <code>end</code> est\u00e1 excluido. Ejemplo:</p> <pre><code>IntStream stream = IntStream.range(1,8);\n</code></pre> </li> <li> <p><code>IntStream.rangeClosed(start, end)</code>: retorna un <code>IntStream</code> ordenado cuyos elementos corresponden a los enteros que van desde <code>start</code> hasta <code>end</code> incluido. Ejemplo:</p> <pre><code>IntStream stream = IntStream.rangeClosed(1, 8);\n</code></pre> </li> </ul> </li> <li> <p>M\u00e9todo chars() de String: retorna un <code>IntStream</code> cuyos elementos corresponden a los caracteres de la cadena. Ejemplo:</p> <pre><code>IntStream stream = \"Programaci\u00f3n\".chars();\n</code></pre> </li> <li> <p>Un valor inicial: Java 9 incorpora el m\u00e9todo est\u00e1tico <code>Stream.ofNullable(T value)</code> que retorna un <code>Stream&lt;T&gt;</code> con el valor indicado o vac\u00edo si el valor proporcionado es <code>null</code>.</p> </li> <li>Un Optional: Java 9 incorpora el m\u00e9todo <code>stream()</code> que retorna un <code>Stream&lt;T&gt;</code> con un \u00fanico valor correspondiente al valor contenido en el optional o un stream vac\u00edo si el optional no tiene valor presente.</li> <li>Un stream vac\u00edo: podemos crear un stream vac\u00edo mediante el m\u00e9todo est\u00e1tico <code>empty()</code> de la interfaz <code>Stream&lt;T&gt;</code>.</li> <li>Un stream builder: podemos crear un stream a partir de un objeto <code>Stream.Builder&lt;T&gt;</code> al que podamos agregar elementos mediante el m\u00e9todo <code>add(item)</code> y posteriormente usar el m\u00e9todo <code>build()</code> del mismo para obtener el objeto <code>Stream&lt;T&gt;</code>.</li> <li> <p>La concatenaci\u00f3n de dos streams: El m\u00e9todo est\u00e1tico <code>Stream.concat(stream1, stream2)</code> retorna un stream resultante de la concatenaci\u00f3n de los dos streams recibidos. Ejemplo:</p> <pre><code>Stream&lt;String&gt; stream1 = Stream.of(\"Luis\", \"Paco\", \"Ricardo\");\nStream&lt;String&gt; stream2 = Stream.of(\"Ana\", \"Lidia\", \"Esther\");\nStream&lt;String&gt; stream = Stream.concat(stream1, stream2);\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-1/#tratamiento-individual-de-los-elementos","title":"Tratamiento individual de los elementos","text":"<p>En algunas ocasiones necesitamos realizar alg\u00fan tratamiento sobre cada uno de los elementos del stream. En dicho caso debemos diferenciar entre operaciones terminales y no terminales. Las operaciones terminales no producir\u00e1n un nuevo stream mientras que las operaciones intermedias s\u00ed que lo producir\u00e1n.</p> <ul> <li><code>void forEach(Consumer&lt;? super T&gt; action)</code>: operaci\u00f3n terminal para tratar cada uno de los elementos del stream. Aplica la acci\u00f3n recibida en forma de Consumer a cada uno de los elementos del stream.</li> <li><code>Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)</code>: tambi\u00e9n se aplica la acci\u00f3n recibida en forma de Consumer a cada uno de los elementos del stream pero retorna un nuevo stream con los mismos elementos que el original, por lo que se trata de una operaci\u00f3n intermedia. Este m\u00e9todo se utiliza para tratar individualmente cada uno de los elementos del stream sin tener por ello que terminar la cadena de operaciones.</li> </ul>"},{"location":"bloque_iii/tema_13/page-2/","title":"2 Operaciones intermedias","text":""},{"location":"bloque_iii/tema_13/page-2/#filtrado","title":"Filtrado","text":"<p>Otra de las operaciones intermedias que se pueden realizar sobre un stream es el filtrado de sus elementos, es decir, la generaci\u00f3n de un nuevo stream que s\u00f3lo contenga algunos de los elementos del stream original. Java nos proporciona distintos m\u00e9todos:</p> <ul> <li> <p><code>Stream&lt;T&gt; distinct()</code>: retorna un nuevo stream con los elementos del stream original, excepto aquellos que estuvieran repetidos. Para determinar que dos elementos son iguales se usar\u00e1 al m\u00e9todo <code>equals()</code> del elemento. Ejemplo:</p> MainSalida <pre><code>import java.util.stream.Stream;\npublic class Distinct{\npublic void show(){\nStream.of(1, 3, 2, 3, 1)\n.distinct()\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew Distinct().show();\n}\n}\n</code></pre> <pre><code>1\n3\n2\n</code></pre> <ul> <li><code>Stream&lt;T&gt; limit(long maxSize)</code>: retorna un nuevo stream con tan s\u00f3lo maxSize elementos del stream original, atendiendo al orden intr\u00ednseco del mismo. Tiene un mal rendimiento en streams paralelos ordenados. Ejemplo:</li> </ul> MainSalida <pre><code>public class Limit{\npublic void show(){\nStream.of(\"Ricardo\", \"Luis\", \"Paco\")\n.limit(2)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew Limit().show();\n}\n}\n</code></pre> <pre><code>Ricardo\nLuis\n</code></pre> <ul> <li><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>: retorna un nuevo stream que s\u00f3lo incorpora los elementos del stream original que cumplan el predicado recibido. Ejemplo:</li> </ul> MainSalidas <pre><code>public class Filter{\npublic void show(){\nStream.of(9, 12, 15, 24, 37, 6)\n.filter(n -&gt; n % 2 == 0)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew Filter().show();\n}\n}\n</code></pre> <pre><code>12\n24\n6\n</code></pre> <ul> <li><code>Stream&lt;T&gt; skip(long n)</code>: retorna un nuevo stream en el que no se incluyen los primeros n elementos del stream original pero s\u00ed se incluye el resto. No proporciona un buen rendimiento en streams paralelos ordenados. Ejemplo:</li> </ul> MainSalida <pre><code>public class Skip{\npublic void show(){\nStream.of(9, 12, 15, 24, 27, 6)\n.skip(3)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew Skip().show();\n}\n}\n</code></pre> <pre><code>24\n37\n6\n</code></pre> <ul> <li><code>default Stream&lt;T&gt; dropWhile(Predicate &lt;? super T&gt; predicate)</code>: retorna un nuevo stream con el primer elemento que no cumpla el predicado y el resto de elementos, independientemente de si cumplen el predicado o no. Proporciona un mal rendimiento con streams paralelos ordenados:</li> </ul> MainSalida <pre><code>public class DropWhile{\npublic void show(){\nStream.of(9, 13, 15, 24, 37, 6)\n.dropWhile(n -&gt; n % 2 != 0)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew DropWhile().show();\n}\n}\n</code></pre> <pre><code>24\n37\n6\n</code></pre> <ul> <li><code>default Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</code>: mientras los elementos cumplan el predicado se van incluyendo en el stream, pero en cuanto se encuentra un elemento que no cumple el predicado se deja de incluir el resto de elementos, incluso aunque cumplan el predicado. Ejemplo:</li> </ul> MainSalida <pre><code>public class TakeWhile{\npublic void show(){\nStream.of(9, 13, 15, 24, 37, 6)\n.takeWhile(n -&gt; n % 2 != 0)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew TakeWhile().show();\n}\n}\n</code></pre> <pre><code>9\n13\n15\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-2/#ordenacion","title":"Ordenaci\u00f3n","text":"<p>Algunos streams son ordenados, es decir, que sus elementos poseen un determinado orden intr\u00ednseco significativo, conocido como encounter order. Por ejemplo, un stream cuya fuente de datos corresponda a una lista crear\u00e1 un stream ordenado, cuyo encounter order ser\u00e1 el orden en el que los elementos est\u00e1n situados en la lista. Sin embargo, otros streams no son ordenados, en el sentido de que sus elementos no tienen un orden intr\u00ednseco significativo. Por ejemplo, un stream cuya fuente de datos sea un conjunto (Set) ser\u00e1 un stream sin encounter order, ya que un conjunto los elementos no tienen un orden preestablecido.</p> <p>El hecho de que un stream sea ordenado o no depender\u00e1 del tipo de fuente de datos asociada y de las operaciones intermedias anteriores que hayamos realizado mediante las que se ha obtenido el stream.</p> <p>Algunas operaciones trabajan por defecto en base a este encounter order, imponiendo una restricci\u00f3n acerca del orden en el que los elementos deben ser procesados, como por ejemplo las operaciones intermedias limit o skip.</p> <p>Sin embargo, existen otras operaciones que no tienen en cuenta el encounter order, como por ejemplo forEach. Si se ejecuta sobre un stream paralelo, no hay ninguna garant\u00eda sobre en que orden se aplica la acci\u00f3n a los elementos. Si queremos que s\u00ed se tenga en cuenta el orden, entonces tendr\u00edamos que usar el m\u00e9todo <code>void forEachOrdered(Consumer&lt;? super T&gt; action)</code>. Normalmente se usa encadenado despu\u00e9s de llamar a un m\u00e9todo de ordenaci\u00f3n que habr\u00e1 ordenado el stream. La ventaja de este m\u00e9todo es que se garantiza que la acci\u00f3n se aplica a los elementos en el orden intr\u00ednseco del stream, incluso aunque \u00e9ste se trate de un stream paralelo, aunque conlleve un peor rendimiento.</p> <p>Al trabajar con streams secuenciales, el encounter order no afecta al rendimiento de la aplicaci\u00f3n, pero si trabajamos con streams paralelos, el empleo del encounter order por parte de algunos operadores pueden afectar en gran medida al rendimiento general de la aplicaci\u00f3n. Dependiendo de la operaci\u00f3n de la que se trate, ser\u00e1 necesario procesar a la vez m\u00e1s de un elemento del stream a partir del anterior, en el que no se tenga en cuenta el encounter order. Al ejecutar el m\u00e9todo <code>unordered()</code>, tan solo se est\u00e1 creando un nuevo stream en el que se ha borrado el indicador de que el encounter order debe tenerse en cuenta. Normalmente, esta operaci\u00f3n de desactivaci\u00f3n del encounter order se realiza con el objetivo de mejorar el rendimiento en streams paralelos.</p> <p>Por otra parte, si queremos obtener un stream ordenado a partir de otro desordenado o a partir de otro stream ordenado pero por un orden distinto, podemos usar el m\u00e9todo <code>sorted()</code>, en cuyo caso los elementos del stream deben implementar la interfaz <code>Comparable</code> para determinar el orden en el que deben ser ordenados. Otra posibilidad es usar una versi\u00f3n sobrecargada de dicho m\u00e9todo que recibe un objeto <code>Comparator</code> como argumento. Ejemplo:</p> MainSalida <pre><code>public class Sorted{\npublic void show(){\nStream.of(\"Ricardo\", \"Luis\", \"Paco\")\n.sorted()\n.limit(2)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew Sorted().show();\n}\n}\n</code></pre> <pre><code>Luis\nPaco\n</code></pre> <p>Ejemplo utilizando <code>Comparator</code>:</p> MainSalida <pre><code>public class SortedReverseOrder{\npublic void show(){\nStream.of(\"Ricardo\", \"Luis\", \"Paco\")\n.sorted(Comparator.reverseOrder())\n.limit(2)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew SortedReverseOrder().show();\n}\n}\n</code></pre> <pre><code>Ricardo\nPaco\n</code></pre>"},{"location":"bloque_iii/tema_13/page-2/#transformacion","title":"Transformaci\u00f3n","text":"<p>Java nos proporciona distintos m\u00e9todos:</p> <ul> <li> <p><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code>: retorna un nuevo stream obtenido a partir de aplicar la funci\u00f3n de transformaci\u00f3n indicada a cada uno de los elementos del stream original. El tipo del stream resultante corresponder\u00e1 al tipo de retorno de la funci\u00f3n de transformaci\u00f3n, que puede ser distinto al tipo del stream original, pero contendr\u00e1 tantos elementos como \u00e9ste.</p> MainSalida <pre><code>public class Map{\npublic void show(){\nStream.of(20, 27, 31)\n.map(n -&gt; \"N\u00famero \" + n)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew Map().show();\n}\n}\n</code></pre> <pre><code>N\u00famero 20\nN\u00famero 27\nN\u00famero 31\n</code></pre> </li> <li> <p>M\u00e9todos que permiten obtener un stream de un tipo primitivo a partir de uno que no lo sea:</p> <ul> <li> <p><code>DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code>: retorna un <code>DoubleStream</code> correspondiente de aplicar a cada elemento del stream original la funci\u00f3n a double recibida:</p> MainSalida <pre><code>public class MapToDouble{\npublic void show(){\nStream.of(20, 27, 31)\n.mapToDouble(n -&gt; n * 0.5)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew MapToDouble().show();\n}\n}\n</code></pre> <pre><code>10.0\n13.5\n15.5\n</code></pre> </li> <li> <p><code>IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper)</code>: retorna un <code>IntStream</code> correspondiente de aplicar a cada elemento del stream original la funci\u00f3n de conversi\u00f3n a int recibida. Ejemplo:</p> MainSalida <pre><code>public class MapToInt{\npublic void show(){\nStream.of(\"Ricardo\", \"Luis Miguel\", \"Paco\")\n.mapToInt(n -&gt; n.length)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew MapToInt().show();\n}\n}\n</code></pre> <pre><code>7\n11\n4\n</code></pre> </li> <li> <p><code>LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper)</code>: retorna un <code>LongStream</code> correspondiente de aplicar a cada elemento del stream original la funci\u00f3n de conversi\u00f3n a long recibida.</p> MainSalida <pre><code>public class MapToLong{\npublic void show(){\nStream.of(55000, 60000, 72500)\n.mapToLong(n -&gt; (long)n * n)\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew MapToLong().show();\n}\n}\n</code></pre> <pre><code>3025000000\n3600000000\n5256250000\n</code></pre> </li> </ul> </li> <li> <p><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code>: cuando una funci\u00f3n de transformaci\u00f3n retorna un stream y se aplica esta funci\u00f3n con el m\u00e9todo map, el stream resultante es un <code>Stream&lt;Stream&lt;Tipo&gt;&gt;</code>. En estos casos, es m\u00e1s \u00f3ptimo obtener un \u00fanico <code>Stream&lt;Tipo&gt;</code> que contuviera concatenados todos los elementos de todos los substreams. A este proceso se le conoce como aplanado (flat) de substreams.</p> MainSalida <pre><code>public class FlatMap{\npublic void show(){\nStream.of(1, 2, 3)\n.flatMap(n -&gt; IntStream.rangeClosed(1, n).boxed())\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew FlatMap().show();\n}\n}\n</code></pre> <pre><code>1\n1\n2\n1\n2\n3\n</code></pre> <p>En el ejemplo, muestra los valores <code>1</code> (proveniente del primer substream), <code>1</code>, <code>2</code> (provenientes del segundo substream) y <code>1</code>, <code>2</code> y <code>3</code>, provenientes del tercer substream, en este orden.</p> <p>Si nos interesa que el tipo del stream resultante fuera primitivo, podemos usar los m\u00e9todos <code>flatMapToDouble</code>, <code>flatMapToInt</code> o <code>flatMapToLong</code>.</p> MainSalida <pre><code>public class FlatMapToInt{\npublic void show(){\nStream.of(1, 2, 3)\n.flatMapToInt(n -&gt; IntStream.rangeClosed(1, n))\n.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew FlatMapToInt().show();\n}\n}\n</code></pre> <pre><code>1\n1\n2\n1\n2\n3\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-3/","title":"3 Operaciones terminales","text":""},{"location":"bloque_iii/tema_13/page-3/#reduccion-pura","title":"Reducci\u00f3n pura","text":""},{"location":"bloque_iii/tema_13/page-3/#metodos-estandar-de-reduccion","title":"M\u00e9todos est\u00e1ndar de reducci\u00f3n","text":"<ul> <li> <p><code>long count()</code>: retorna el n\u00famero de elementos de un stream. Ejemplo:</p> <pre><code>public class Count{\npublic void show(){\nlong howManyAreEven;\nhowManyAreEven = Stream.of(30, 23, 24, 57, 8, 15)\n.filter(n -&gt; n % 2 == 0)\n.count();\nSystem.out.println(howManyAreEven); // 3\n}\npublic static void main(String[] args){\nnew Count().show();\n}\n}\n</code></pre> </li> <li> <p>Las clases <code>IntStream</code>, <code>LongStream</code> y <code>DoubleStream</code>, correspondientes a streams de elementos de tipos primitivos num\u00e9ricos, disponen del m\u00e9todo <code>sum()</code> para calcular la suma de los elementos del stream:</p> <pre><code>public class Sum{\npublic void show(){\nint sumEvenNumbers;\nsumEvenNumbers = IntStream.of(30, 23, 24, 57, 8, 15)\n.filter(n -&gt; n % 2 == 0)\n.sum();\nSystem.out.println(sumEvenNumbers); // 62\n}\npublic static void main(String[] args){\nnew Sum().show();\n}\n}\n</code></pre> <p>Si disponemos de un stream gen\u00e9rico de elementos y no de un stream y no de un stream de alguna de las clases mencionadas anteriormente, podemos usar alguno de los m\u00e9todos <code>mapToInt()</code>, <code>mapToLong()</code>, <code>mapToDouble()</code>, <code>flatMapToInt()</code>, etc., para obtener un stream de un tipo espec\u00edfico. Ejemplo:</p> <pre><code>public class SumMapToInt{\npublic void show(){\nint sumEvenNumbers = Stream.of(30, 23, 24, 47, 8, 15)\n.filter(n -&gt; n % 2 == 0)\n.mapToInt(n -&gt; n)\n.sum();\nSystem.out.println(sumEvenNumbers); // 62\n}\npublic static void main(String[] args){\nnew SumMapToInt().show();\n}\n}\n</code></pre> </li> <li> <p>Estas clases de streams de elementos de tipo primitivo num\u00e9rico tambi\u00e9n disponen de m\u00e9todos para obtener el valor m\u00e1xima, <code>max()</code>, el valor m\u00ednimo, <code>min()</code> y la media aritm\u00e9tica, <code>average()</code>, de los elementos num\u00e9ricos del stream. Dado que el stream sobre el que se apliquen puede estar vac\u00edo, estos m\u00e9todos retornan un Optional.</p> <pre><code>public class MaxMinAverage{\npublic void show(){\nOptionalInt minEvenNumbers, maxEvenNumbers;\nOptionalDouble averageEvenNumbers;\nminEvenNumbers = IntStream.of(30, 23, 24, 57, 8, 15)\n.filter(n -&gt; n % 2 == 0)\n.min();\nminEvenNumbers.ifPresent(System.out::println); // 8\nmaxEvenNumbers = IntStream.of(30, 23, 24, 57, 8, 15)\n.filter(n -&gt; n % 2 == 0)\n.max();\nmaxEvenNumbers.ifPresent(System.out::println); // 30\naverageEvenNumbers = IntStream.of(30, 23, 24, 57, 8, 15)\n.filter(n -&gt; n % 2 == 0)\n.average();\naverageEvenNumbers.ifPresent(n -&gt; System.out.printf(\"%.2f\", n)); //20,67\n}\npublic static void main(String[] args){\nnew MaxMinAverage().show();\n}\n}\n</code></pre> <p>Si se trata de un stream gen\u00e9rico, tenemos disponibles m\u00e9todos para calcular el m\u00e1ximo y el m\u00ednimo que reciben un Comparator para comparar los elementos del stream y as\u00ed obtener en cada caso el valor m\u00ednimo o el m\u00e1ximo:</p> <ul> <li><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></li> <li><code>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)</code></li> </ul> <pre><code>public class MaxMinComparator{\npublic void show(){\nOptional&lt;Vehicle&gt; minVehicle;\nOptional&lt;Vehicle&gt; maxVehicle;\nList&lt;Vehicle&gt; list = new ArrayList&lt;&gt;();\nlist.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\nlist.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\nSystem.out.println(\"Veh\u00edculo con menor n\u00famero de ruedas: \");\nminVehicle = list.stream()\n.min(Comparator.comparingInt(Vehicle::getWheelCount));\nminVehicle.ifPresent(System.out::println);\nSystem.out.println(\"Veh\u00edculo con mayor matr\u00edcula alfab\u00e9ticamente\");\nmaxVehicle = list.stream()\n.max(Comparator.comparing(Vehicle::getRegistration));\nmaxVehicle.ifPresent(System.out::println);\n}\npublic static void main(String[] args){\nnew MaxMinComparator().show();\n}\n}\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-3/#metodos-reduce","title":"M\u00e9todos reduce","text":"<p>\u00bfY si queremos realizar una operaci\u00f3n de reducci\u00f3n distinta a las anteriores? Para casos m\u00e1s gen\u00e9ricos usaremos el m\u00e9todo <code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code> que recibe una funci\u00f3n acumuladora. La funci\u00f3n acumuladora debe ser una funci\u00f3n asociativa, es decir, da igual en qu\u00e9 orden se opere con los elementos porque siempre se va a obtener el mismo resultado. Se trata de una regla que se cumple en la suma y en la multiplicaci\u00f3n. Por ejemplo, <code>1+2+3</code> da el mismo resultado que <code>2+3+1</code>.</p> <p>En este caso, el proceso de reducci\u00f3n comienza cuando se obtiene el segundo elemento, ya que necesitamos al menos dos elementos para hacer la primera reducci\u00f3n. Por este motivo, el m\u00e9todo retorna un <code>Optional</code>, dado que si el stream no tiene elementos suficientes no se puede realizar la reducci\u00f3n ni producir ning\u00fan valor.</p> <pre><code>public class Reduce{\npublic void show(){\nOptionalInt integerSum = IntStream.of(30, 23, 24, 57, 8, 15)\n.reduce((subtotal, element) -&gt; subtotal + element);\nintegerSum.ifPresent(System.out::println); // 157\nintegerSum = IntStream.of(30, 23, 24, 57, 8, 15)\n.reduce(Integer::sum);\nintegerSum.ifPresent(System.out::println); // 157\nintegerSum = IntStream.empty()\n.reduce(Integer::sum);\nSystem.out.println(integerSum); // OptionalInt.empty\nintegerSum.ifPresent(System.out::println); // No hace nada\n}\npublic static void main(String[] args){\nnew Reduce().show();\n}\n}\n</code></pre> <p>Este m\u00e9todo est\u00e1 sobrecargado para pasarle como primer par\u00e1metro un valor conocido como identidad (identity), que es usado como valor inicial de la operaci\u00f3n de reducci\u00f3n y el resultado por defecto si el stream est\u00e1 vac\u00edo: <code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code>.</p> <p>Debemos elegir cuidadosamente el valor de identity atendiendo a la operaci\u00f3n que se lleve a cada en la funci\u00f3n binaryOperator. El valor de identity debe ser una identidad para la funci\u00f3n acumuladora, es decir, si se aplica la funci\u00f3n acumuladora a cualquier elemento con la identidad, debe devolver el mismo elemento. Por ejemplo, si utilizamos como operaci\u00f3n una suma, la identidad debe ser 0 ya que cualquier n\u00famero al que le sumemos 0, nos devuelve el mismo n\u00famero. Por el mismo razonamiento, si la operaci\u00f3n es una multiplicaci\u00f3n, la identidad sobre ser 1.</p> <pre><code>public class ReduceIdentity{\npublic void show(){\nInteger sum, mult;\nsum = IntStream.of(30, 23, 24, 57, 8, 15)\n.reduce(0, Integer::sum);\nSystem.out.println(sum); // 157\nsum = IntStream.empty()\n.reduce(0, Integer::sum);\nSystem.out.println(sum); // 0\nmult = IntStream.of(2, 3, 4)\n.reduce(1, (subtotal, element) -&gt; subtotal * element);\nSystem.out.println(mult); // 24\nmult = IntStream.of(2, 3, 4)\n.reduce(1, Math::multiplyExact);\nSystem.out.println(mult); // 24\nmult = IntStream.empty()\n.reduce(1, Math::multiplyExact);\nSystem.out.println(mult); // 1\n}\npublic static void main(String[] args){\nnew ReduceIdentity().show();\n}\n}\n</code></pre> <p>Tenemos disponible una tercera versi\u00f3n del m\u00e9todo, <code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, u&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code>, especialmente \u00fatil para streams paralelos, que se usa cuando queremos que el m\u00e9todo retorne un valor de tipo diferente al del stream original. La funci\u00f3n combiner es necesaria para indicar c\u00f3mo se deben combinar acumuladores parciales realizadas en distintos hilos en streams paralelos.</p> <pre><code>public class ReduceCombiner{\npublic void show(){\nint count = Stream.of(\"Juan\", \"Pepe\", \"Luis\", \"Ricardo\", \"Laura\")\n.reduce(0, (subtotal, element) -&gt; {\nif(element.length() % 2 == 0){\nreturn subtotal + 1;\n} else {\nreturn subtotal;\n}\n}, Integer::sum);\nSystem.out.printf(\"Cu\u00e1ntos nombres con n\u00famero de caracteres pares: %d\", count); // 3\n}\npublic static void main(String[] args){\nnew ReduceCombiner().show();\n}\n}\n</code></pre> <p>Debemos tener encuentra que la funci\u00f3n <code>reduce()</code> en cualquiera de sus versiones respeta el orden del stream a la hora de combinar los c\u00e1lculos intermedios.</p>"},{"location":"bloque_iii/tema_13/page-3/#operaciones-terminales-de-consulta","title":"Operaciones terminales de consulta","text":"<p>La clase <code>Stream</code> tambi\u00e9n proporciona una serie de m\u00e9todos de consulta sobre los elementos de un stream, denominadas operaciones de cortocircuito (short-circuit terminal operators). Se llaman as\u00ed porque se deja de procesar el resto de elementos si con los elementos que ya han sido procesados se es capaz de determinar el resultado.</p> <p>Tenemos un conjunto de m\u00e9todos que permiten consultar, respectivamente, si todos, ninguno o algunos de los elementos del stream cumplen con un determinado predicado, retornado un valor booleano:</p> <ul> <li><code>boolean allMatch(Predicate&lt;? super T&gt; predicate)</code></li> <li><code>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</code></li> <li><code>boolean anyMatch(Predicate&lt;? super T&gt; predicate)</code></li> </ul> <pre><code>public class Match{\npublic void show(){\nboolean match;\nmatch = IntStream.of(1, 2, 4).allMatch(n -&gt; n % 2 == 0);\nSystem.out.println(match); // false\nmatch = IntStream.of(2, 4, 6).allMatch(n -&gt; n % 2 == 0);\nSystem.out.println(match); // true\nmatch = IntStream.of(1, 2, 4).noneMatch(n -&gt; n % 2 == 0);\nSystem.out.println(match); // false\nmatch = IntStream.of(1, 3, 5).noneMatch(n -&gt; n % 2 == 0);\nSystem.out.println(match); // true\nmatch = IntStream.of(1, 3, 5).anyMatch(n -&gt; n % 2 == 0);\nSystem.out.println(match); // false\nmatch = IntStream.of(2, 3, 5).anyMatch(n -&gt; n % 2 == 0);\nSystem.out.println(match); // true\n}\npublic static void main(String[] args){\nnew Match().show();\n}\n}\n</code></pre> <p>Por otro lado tenemos los m\u00e9todos <code>findFirst()</code> y <code>findAny()</code>, que retornan un <code>Optional&lt;T&gt;</code> con, respectivamente, el primer elemento del stream, o alg\u00fan elemento del stream (no est\u00e1 indicado cu\u00e1l), si es que existe. Un aspecto curioso es que estos m\u00e9todos no reciben ning\u00fan predicado con el que indicar la condici\u00f3n de b\u00fasqueda por lo que normalmente se usan despu\u00e9s de haber ejecutarlo el m\u00e9todo <code>filter</code> sobre el stream.</p> <pre><code>public class Find{\npublic void show(){\nOptional&lt;Integer&gt; find;\nfind = Stream.of(1, 2, 4)\n.filter(n -&gt; n % 2 == 0)\n.findFirst();\nfind.ifPresent(System.out::println); // 2\nfind = Stream.of(6, 2, 4)\n.filter(n -&gt; n % 2 == 0)\n.findAny();\nfind.ifPresent(System.out::println); // 6\n}\npublic static void main(String[] args){\nnew Find().show();\n}\n}\n</code></pre> <p>Un aspecto curioso es que no se proporciona ning\u00fan m\u00e9todo para obtener el \u00faltimo elemento de un stream. sin embargo, podemos obtenerlo usando el m\u00e9todo <code>skip</code> (siempre y cuando se trate de un stream finito):</p> <pre><code>public class LastElement{\npublic void show(){\nList&lt;Integer&gt; list = List.of(30, 23, 24, 57, 8, 15);\nlong count = list.stream().count();\nOptional&lt;Integer&gt; last = list.stream()\n.skip(count - 1)\n.findFirst();\nlast.ifPresent(System.out::println); // 15\n}\npublic static void main(String[] args){\nnew LastElement().show();\n}\n}\n</code></pre> <p>Otra manera de hacerlo es mediante la reducci\u00f3n en la que siempre nos quedemos con el segundo elemento:</p> <pre><code>public class LastReduce{\npublic void show(){\nOptionalInt last;\nlast = IntStream.of(30, 23, 24, 57, 8, 15)\n.reduce((first, second) -&gt; second);\nlast.ifPresent(System.out::println); // 15\n}\npublic static void main(String[] args){\nnew LastElement().show();\n}\n}\n</code></pre> <p>Debemos tener en cuenta que si ejecutamos estos m\u00e9todos sobre streams paralelos el resultado puede ser distinto entre distintas llamadas.</p>"},{"location":"bloque_iii/tema_13/page-4/","title":"4 Reducci\u00f3n mutable","text":""},{"location":"bloque_iii/tema_13/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>La operaci\u00f3n de recolecci\u00f3n es una operaci\u00f3n terminal que permite crear una estructura de datos con los resultados del procesamiento de datos asociado a un stream. La operaci\u00f3n de recolecci\u00f3n tambi\u00e9n recibe el nombre de operaci\u00f3n de reducci\u00f3n mutable. Para llevarla a cabo usaremos el m\u00e9todo <code>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</code></p> <p>El m\u00e9todo recibe un objeto de una clase que implemente la interfaz <code>Collector</code>. Aunque podemos crear nuestras propias clases que implementen dicha interfaz, en la mayor\u00eda de las ocasiones podremos utilizar alguno de los recolectores est\u00e1ndar proporcionados por Java a trav\u00e9s de la clase auxiliar <code>Collectors</code>, que contiene m\u00e9todos est\u00e1ticos que retornan objetos <code>Collector</code> correspondientes a los recolectores m\u00e1s habituales. Todos estos m\u00e9todos est\u00e1n dise\u00f1ados para funcionar de manera \u00f3ptima incluso con streams paralelos.</p>"},{"location":"bloque_iii/tema_13/page-4/#recolectores-a-estructuras-de-datos-clasicas","title":"Recolectores a estructuras de datos cl\u00e1sicas","text":"<p>La clase <code>Collectors</code> tiene un conjunto de m\u00e9todos est\u00e1ticos que nos permiten recolectar los elementos de un stream y almacenarlos en una estructura de datos:</p> <ul> <li><code>public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</code>: retorna una lista con los elementos del stream. En Java 16, se ha incorporada tambi\u00e9n un m\u00e9todo <code>toList()</code> a la interfaz <code>Stream&lt;T&gt;</code>.</li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toUnmodifiableList()</code>: retorna una lista inmutable de los elementos del stream en el orden en que son producidos (encounter order).</li> <li> <p><code>public static &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</code>: el problema de <code>toList()</code> y <code>toSet()</code> es que no podemos especificar la implementaci\u00f3n concreta que queremos que se use. Por ejemplo, no podemos indicar que se use un <code>LinkedList</code>, en el caso de <code>toList()</code>, o un <code>TreeSet</code>, en el caso de <code>toSet()</code>.</p> <p>Para solucionar este problema, el m\u00e9todo recibe un supplier que retorna la estructura de datos concreta en la que queremos que se recolecte el stream.</p> <pre><code>public class CollectorsClassicDataStructures{\npublic void show(){\nList&lt;Integer&gt; list = List.of(3, 6, 1, 2, 4, 5);\nList&lt;Integer&gt; listEvenNumbers = list.stream()\n.filter(n -&gt; n % 2 == 0)\n.collect(Collectors.toList());\nlistEvenNumbers.forEach(System.out::println);\nSortedSet&lt;Integer&gt; tree = list.stream()\n.filter(n -&gt; n % 2 == 0)\n.collect(Collectors.toCollection(TreeSet::new));\ntree.forEach(System.out::println);\n}\npublic static void main(String[] args){\nnew CollectorsClassicDataStructures().show();\n}\n}\n</code></pre> </li> <li> <p><code>public static &lt;T, K, V&gt; Collector&lt;T, ?, Map&lt;K, U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper)</code>: retorna un mapa obtenido de la siguiente manera:</p> <ul> <li>Con el <code>Function</code> keyMapper obtiene la clave, de manera que su valor de retorno ser\u00e1 usado como clave del elemento en el mapa resultante. Como el mapa resultante no puede tener claves repetidas, si retoma el mismo valor para dos elementos distintos del stream, se lanzar\u00e1 la excepci\u00f3n <code>IllegalStateException</code></li> <li>Con el <code>Function</code> valueMapper se obtiene el valor del elemento en el mapa resultante.</li> </ul> <pre><code>public class CollectorsToMap{\npublic void show(){\nMap&lt;String, Vehicle&gt; map;\nVehicle[] vehicles = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nmap = Arrays.stream(vehicles)\n.collect(Collectors.toMap(Vehicle::getRegistration, vehicle-&gt; vehicle));\nmap.forEach((k, v) -&gt; System.out.printf(\"Clave:%s Valor:%s\\n\", k, v));\n}\npublic static void main(String[] args){\nnew CollectorsToMap().show();\n}\n}\n</code></pre> <p>Si nos fijamos en el <code>Function</code> valueMapper (vehicle -&gt; vehicle), tambi\u00e9n podemos usar el m\u00e9todo est\u00e1tico <code>static &lt;T&gt; Function&lt;T,T&gt; identity()</code>, que es una funci\u00f3n que siempre devuelve su argumento de entrada:</p> <pre><code>public class FunctionIdentity{\npublic void show(){\nMap&lt;String, Vehicle&gt; map;\nVehicle[] vehicles = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nmap = Arrays.stream(vehicles)\n.collect(Collectors.toMap(Vehicle::getRegistration, Function.identity()));\nmap.forEach((k, v) -&gt; System.out.printf(\"Clave:%s Valor:%s\\n\", k, v));\n}\npublic static void main(String[] args){\nnew FunctionIdentity().show();\n}\n}\n</code></pre> <p>Tenemos disponible una segunda versi\u00f3n del m\u00e9todo para que en lugar de lanzar una excepci\u00f3n, proporcionemos una funci\u00f3n de combinaci\u00f3n de elementos con la misma clave:</p> </li> <li> <p><code>public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K, U&gt;&gt; yoMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)</code>: el tercer par\u00e1metro indica c\u00f3mo de deben combinar dos elementos con la misma clave.</p> MainSALIDA <pre><code>public class CombinationRepeatedKeys{\npublic void show(){\nMap&lt;String, String&gt; map;\nVehicle[] vehicles = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"rojo\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"azul\");\nmap = Arrays.stream(vehicles)\n.collect(Collectors.toMap(\nVehicle::getColour, Vehicle::getRegistration,\n(r1, r2) -&gt; String.format(\"Clave:%-7s Valor: %s\\n\", r1, r2)\n)\n);\nmap.forEach((k, v) -&gt; System.out.printf(\"Clave:%-7s Valor:%s\\n\", k, v));\n}\npublic static void main(String[] args){\nnew CombinationRepeatedKeys().show();\n}\n}\n</code></pre> <pre><code>Clave:rojo Valor:1235GTR-5930POI\nClave:blanco Valor:1705UBG\nClave:verde Valor:7314QWE\nClave:azul Valor:9685KMX-3495JZA\n</code></pre> <p>Estas dos versiones del m\u00e9todo <code>toMap</code> retornan por defecto un <code>HashMap</code>, por lo que existe una tercera versi\u00f3n para obtener una implementaci\u00f3n distinta de la interfaz <code>Map</code>, como por ejemplo <code>LinkedHashMap</code> o <code>TreeMap</code>:</p> </li> <li> <p><code>public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt; Collector &lt;T, ?, M&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapFactory)</code>: recibe un <code>Supplier</code> como cuarto par\u00e1metro para indicar el tipo de mapa que se quiere obtener:</p> <pre><code>public class CombinationRepeatedKeysSupplier{\npublic void show(){\nMap&lt;String, Vehicle&gt; map;\nVehicle[] vehicles = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"rojo\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"azul\");\nmap = Arrays.stream(vehicles)\n.collect(Collectors.toMap(Vehicle::getColour, Vehicle::getRegistration,\n(r1, r2) -&gt; String.format(\"%s-%s\", r1, r2), TreeMap::new));\nmap.forEach((k, v) -&gt; System.out.printf(\"Clave:%-7s Valor:%s\\n\", k,v));\n}\npublic static void main(String[] args){\nnew CombinationRepeatedKeys().show();\n}\n}\n</code></pre> </li> <li> <p>Recolecci\u00f3n de un stream hacia un array: no se realizar\u00e1 a trav\u00e9s de ning\u00fan recolector, ni del m\u00e9todo <code>collect</code>, sino directamente a trav\u00e9s del m\u00e9todo <code>toArray()</code>de la clase <code>Stream</code>, que retorna un <code>Object[]</code>, es decir un array de elementos de la clase <code>Objecto</code>, debido a que los arrays no usan gen\u00e9ricos.</p> <pre><code>public class ToArray{\npublic void show(){\nList&lt;Vehicle&gt; list = new ArrayList&lt;&gt;();\nlist.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\nlist.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\nlist.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\nlist.add(new Vehicle(\"5930POI\", 2, \"negro\"));\nlist.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\nlist.add(new Vehicle(\"3495JZA\", 2, \"naranja\"));\nObject vehiclesArray[] = list.stream().toArray();\nfor(Object v: vehiclesArray){\nSystem.out.println(v);\n}\n}\npublic static void main(String[] args){\nnew ToArray().show();\n}\n}\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-4/#recolectores-de-operaciones-de-reduccion-basicas","title":"Recolectores de operaciones de reducci\u00f3n b\u00e1sicas","text":"<p>La clase <code>Collectors</code> dispone adem\u00e1s de una serie de m\u00e9todos est\u00e1ticos que retornan recolectores parecidos a las operaciones de reducci\u00f3n:</p> <ul> <li> <p><code>counting()</code>: Para obtener el n\u00fameros de elementos.</p> <pre><code>public class CollectorsCounting{\npublic void show(){\nlong howManyAreEven = Stream.of(30, 23, 24, 57, 8, 15)\n.filter(n -&gt; n % 2 == 0)\n.collect(Collectors.counting());\n}\npublic static void main(String[] args){\nnew CollectorsCounting().show();\n}\n}\n</code></pre> </li> <li> <p>Para obtener la sumar de los elementos que son convertidos al tipo indicado mediante la funci\u00f3n suministrada:</p> <ul> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code></li> </ul> <pre><code>public class CollectorsSumming{\npublic void show(){\nList&lt;Vehicles&gt; list = new ArrayList&lt;&gt;();\nlist.add(new Vehicle(\"9685KMX\", 4, \"azul\"));\nlist.add(new Vehicle(\"1235GTR\", 2, \"rojo\"));\nlist.add(new Vehicle(\"7314QWE\", 4, \"verde\"));\nlist.add(new Vehicle(\"5930POI\", 2, \"negro\"));\nlist.add(new Vehicle(\"1705UBG\", 4, \"blanco\"));\nlist.add(new Vehicle(\"3495JZA\", 2, \"naranja\"));\nint sumWheels = list.stream()\n.collect(Collectors.summingInt(Vehicle::getWheelCount));\nSystem.out.println(sumWheels); // 18\n}\npublic static void main(String[] args){\nnew CollectorsSumming().show();\n}\n}\n</code></pre> </li> <li> <p>Para obtener el valor m\u00ednimo y el m\u00e1ximo atendiendo a un comparador pasado como argumento.</p> <ul> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator)</code></li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator)</code></li> </ul> <pre><code>public class CollectorsMinMax{\npublic void show(){\nOptional&lt;Integer&gt; min, max;\nList&lt;Integer&gt; list = List.of(30, 23, 24, 57, 8, 15);\nmin = list.stream()\n.collect(Collectors.minBy(Comparator.naturalOrder()));\nmin.ifPresent(System.out::println); // 8\nmax = list.stream()\n.collect(Collectors.maxBy(Comparator.naturalOrder()));\nmax.ifPresent(System.out::println); // 57\n}\npublic static void main(String[] args){\nnew CollectorsMinMax().show();\n}\n}\n</code></pre> </li> <li> <p>Para obtener la media aritm\u00e9tica de los valores (que son convertidos al tipo indicado mediante la funci\u00f3n suministrada). Si el stream no tiene elementos retorna cero:</p> <ul> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code></li> </ul> <pre><code>public class CollectorsAveraging{\npublic void show(){\ndouble average;\nList&lt;Integer&gt; list = List.of(30, 23, 24, 57, 8, 15);\naverage = list.stream()\n.collect(Collectors.averagingInt(Integer::intValue));\nSystem.out.printf(\"%.2f\", average); //26,17\n}\npublic static void main(String[] args){\nnew CollectorsAveraging().show();\n}\n}\n</code></pre> </li> <li> <p>Para obtener todo lo anterior (n\u00famero de elementos, suma, m\u00ednimo, m\u00e1ximo y la media) de una sola vez:</p> <ul> <li><code>public static&lt;T&gt; Collector(T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static&lt;T&gt; Collector(T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper)</code></li> <li><code>public static&lt;T&gt; Collector(T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code></li> </ul> MainSALIDA <pre><code>    public class Summarizing{\npublic void show(){\nIntSummaryStatistics oddStatistics = Stream.of(30, 23, 24, 57, 8, 15)\n.filter(n -&gt; n % 2 != 0)\n.collect(Collectors.summarizingInt(Integer::intValue));\nSystem.out.println(oddStatistics);\n}\npublic static void main(String[] args){\nnew Summarizing().show();\n}\n}\n</code></pre> <pre><code>IntSummaryStatistics{count=3, sum=95, min=15, average=31,666667,max=57}\n</code></pre> </li> <li> <p>Para recolectar con una operaci\u00f3n de reducci\u00f3n distinta de las anteriores: <code>public static &lt;T&gt; Collector&lt;T,?,Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)</code></p> <pre><code>public class CollectorsReducing {\npublic void show() {\nOptional&lt;Integer&gt; integerSum = Stream.of(30, 23, 24, 57, 8, 15)\n.collect(Collectors.reducing((subtotal,element) -&gt; subtotal + element));//Con lambda\nintegerSum.ifPresent(System.out::println);//157\nintegerSum = Stream.of(30, 23, 24, 57, 8, 15)\n.collect(Collectors.reducing(Integer::sum));//Con referencia a m\u00e9todo\nintegerSum = Stream.&lt;Integer&gt;empty().collect(Collectors.reducing(Integer::sum));//Optional.empty\nintegerSum.ifPresent(System.out::println);//No hace nada\n}\npublic static void main(String[] args) {\nnew CollectorsReducing().show();\n}\n}\n</code></pre> </li> </ul> <p>Tambi\u00e9n tenemos otra versi\u00f3n del m\u00e9todo que recibe como primer par\u00e1metro el valor correspondiente a la identidad: <code>public static &lt;T&gt; Collector&lt;T,?,T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)</code></p> <pre><code>public class CollectorsReducingIdentity {\npublic void show() {\nInteger sum,mult;\nsum = Stream.of(30, 23, 24, 57, 8, 15).collect(Collectors.reducing(0, Integer::sum));\nSystem.out.println(sum);//157\nsum = Stream.&lt;Integer&gt;empty().collect(Collectors.reducing(0, Integer::sum));\nSystem.out.println(sum);//0\nmult = Stream.of(2,3,4).collect(Collectors.reducing(1, Math::multiplyExact));\nSystem.out.println(mult);//24\nmult = Stream.&lt;Integer&gt;empty().collect(Collectors.reducing(1,Math::multiplyExact));\nSystem.out.println(mult);//1\n}\npublic static void main(String[] args) {\nnew CollectorsReducingIdentity().show();\n}\n}\n</code></pre> <p>Existe adem\u00e1s una tercera versi\u00f3n del m\u00e9todo que recibe como segundo par\u00e1metro una funci\u00f3n de transformaci\u00f3n que ser\u00e1 ejecutada sobre cada elemento antes de realizar la recolecci\u00f3n: <code>public static &lt;T, U&gt; Collector&lt;T,?,U&gt; reducing(U identity, Function&lt;? super T,? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</code>:</p> <pre><code>public class CollectorsReducingCombiner {\npublic void show() {\nint count = Stream.of(\"Juan\", \"Pepe\", \"Luis\", \"Ricardo\", \"Laura\").collect(Collectors.reducing(0, element -&gt; {\nif(element.length() % 2 == 0) {\nreturn 1;\n}\nelse {\nreturn 0;\n}\n}, Integer::sum));\nSystem.out.printf(\"Cu\u00e1ntos nombres con n\u00famero de caracteres pares: %d\", count);//3\n}\npublic static void main(String[] args) {\nnew CollectorsReducingCombiner().show();\n}\n}\n</code></pre> <p>Como podemos apreciar, todos los recolectores vistos en este apartado son muy similares (casi iguales) a los m\u00e9todos est\u00e1ndar de reducci\u00f3n que vimos en un apartado anterior. Entonces, \u00bfpor qu\u00e9 existen estos recolectores? El motivo es que, como veremos m\u00e1s adelante, Java nos va a ofrecer la oportunidad de encadenar varios recolectores, de manera que usaremos los recolectores vistos en este apartado normalmente como acompa\u00f1ante de alg\u00fan otro recolector. De hecho, no se recomienda usar estos recolectores si no es en conjunci\u00f3n con otro recolector. Si se va a emplear de forma aislada, es m\u00e1s \u00f3ptimo emplear los m\u00e9todos est\u00e1ndar de recolecci\u00f3n que vimos en un apartado anterior.</p>"},{"location":"bloque_iii/tema_13/page-4/#recolectores-de-transformacion","title":"Recolectores de transformaci\u00f3n","text":"<ul> <li> <p><code>public  static  Collector&lt;CharSequence,?,String&gt;  joining()</code>:  permite obtener un  <code>String</code>  correspondiente a la concatenaci\u00f3n de los elementos del stream. Solo podremos usar este recolector sobre un stream de elementos de tipo <code>CharSequence</code> , por lo que es posible que antes hayamos tenido que aplicar una operaci\u00f3n de transformaci\u00f3n mediante el m\u00e9todo map  para obtener un stream adecuado.  <code>CharSequence</code>  es una interfaz que representa una secuencia de caracteres. Esta interfaz no impone la mutabilidad, por lo tanto, nos podemos encontrar con clases inmutables y mutables que implementen esta interfaz. Por ejemplo, <code>String</code>  es inmutable y <code>StringBuilder</code>  y <code>StringBuffer</code>  son mutables</p> <pre><code>public class CollectorsJoining {          public void show() {\nString result = Stream.of(\"Juan\", \"Pepe\", \"Luis\",\"Ricardo\", \"Laura\")\n.collect(Collectors.joining());\nSystem.out.println(result);     }\npublic static void main(String[] args) {         new CollectorsJoining().show();     } }\n</code></pre> <p>Existe una segunda versi\u00f3n para concatenar los elementos de entrada separados por  un  delimitador  que  se  pasa  por  par\u00e1metro: <code>public  static Collector&lt;CharSequence,?,String&gt; joining(CharSequence delimiter)</code></p> <pre><code>public class CollectorsJoiningDelimiter {     public void show() {\nString result = Stream.of(\"Juan\", \"Pepe\", \"Luis\",\"Ricardo\", \"Laura\")\n.collect(Collectors.joining(\" - \"));\nSystem.out.println(result);\n}\npublic static void main(String[] args) {         new CollectorsJoiningDelimiter().show();     } }\n</code></pre> <p>Existe una tercera versi\u00f3n del m\u00e9todo que permite indicar el prefijo y el sufijo que queremos poner a la cadena resultante de la concatenaci\u00f3n: <code>public  static Collector&lt;CharSequence,?,String&gt; joining(CharSequence  delimiter, CharSequence prefix,  CharSequence suffix)</code></p> <pre><code>public class CollectorsJoiningPrefixSuffix{\npublic void show(){\nString result = Stream.of(\"Juan\", \"Pepe\", \"Luis\", \"Ricardo\", \"Laura\")\n.collect(Collectors.joining(\" - \", \"Lista de nombres: \", \".\"));\nSystem.out.println(result);\n}\npublic static void main(String[] args){\nnew CollectorsJoiningPrefixSuffix().show();\n}\n}\n</code></pre> </li> <li> <p><code>public static &lt;T, U, A, R&gt; Collector&lt;T,?,R&gt; mapping(Function&lt;? super T,?  extends  U&gt;  mapper,    Collector&lt;?  super  U,A,R&gt;  downstream)</code>: realiza alguna operaci\u00f3n de transformaci\u00f3n sobre los elementos justo antes de aplicarles un recolector que se pasa por par\u00e1metro.</p> <pre><code>public class CollectorsMapping{\npublic void show(){\nVehicle vehicles[] = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nString result = Arrays.stream(vehicles)\n.collect(Collectors.mapping(Vehicle::getRegistration, Collectors.joining(\", \")));\nSystem.out.println(result);\n}\npublic static void main(String[] args){\nnew CollectorsMapping().show();\n}\n}\n</code></pre> </li> </ul>"},{"location":"bloque_iii/tema_13/page-4/#recolectores-de-agrupacion","title":"Recolectores de agrupaci\u00f3n","text":"<p><code>public  static  &lt;T,  K&gt;  Collector&lt;T,?,Map&lt;K,List&lt;T&gt;&gt;&gt;  groupingBy(Function&lt;? super T,? extends K&gt; classifier)</code>: permite obtener un mapa  <code>Map&lt;K, List&lt;T&gt;&gt;</code> donde las claves son los valores resultantes de aplicar la funci\u00f3n de clasificaci\u00f3n a los elementos de entrada y los valores son listas que contienen los elementos de entrada que al aplicarles la funci\u00f3n de clasificaci\u00f3n se obtiene la clave correspondiente, es decir, todos aquellos elementos del stream original que al aplicarles la funci\u00f3n clasificadora retornen el mismo valor, dicho valor ser\u00e1 la clave y los elementos ser\u00e1n agrupados en la misma lista con dicha clave. Veamos un ejemplo: vamos a crear un mapa donde la clave ser\u00e1 el n\u00famero de ruedas del veh\u00edculo. El mapa tendr\u00e1 dos entradas, una para los veh\u00edculos de 2 ruedas y otra para los veh\u00edculos de 4 ruedas. Cada clave tendr\u00e1 una lista con los veh\u00edculos que correspondan con dicho n\u00famero de ruedas:</p> <pre><code>public class CollectorsGroupingBy{\npublic void show(){\nMap&lt;Integer, List&lt;Vehicle&gt;&gt; map;\nVehicle[] vehicles = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nmap = Arrays.stream(vehicles)\n.collect(Collectors.groupingBy(Vehicle::getWheelCount));\nmap.forEach((k, v) -&gt; {\nSystem.out.printf(\"Veh\u00edculos con %d ruedas: \\n\", k);\nv.forEach(vehicle -&gt; System.out.printf(\"%s\\n\", vehicle));\n})\n}\npublic static void main(String[] args){\nnew CollectorsGroupingBy().show();\n}\n}\n</code></pre> <p>Sin embargo, ser\u00e1 muy habitual que queramos realizar alg\u00fan c\u00e1lculo sobre la lista de elementos de cada grupo. Para hacernos m\u00e1s sencilla dicha tarea, tenemos disponible otra versi\u00f3n del m\u00e9todo: <code>public  static  &lt;T, K,  A,  D&gt;  Collector&lt;T,?,Map&lt;K,D&gt;&gt; groupingBy(Function&lt;?  super  T,?  extends  K&gt;  classifier,  Collector&lt;?  super T,A,D&gt; downstream)</code>, que recibe un recolector que queremos que se le aplique a la lista de elementos de cada grupo. Para este cometido, podemos usar los recolectores de operaciones de reducci\u00f3n b\u00e1sicas que vimos en el apartado anterior. Si lo aplicamos al ejemplo anterior, podemos obtener cu\u00e1ntos veh\u00edculos hay con 2 ruedas y cu\u00e1ntos hay con 4 ruedas:</p> <pre><code>public class CollectorsGroupingByDownstream{\npublic void show(){\nMap&lt;Integer, Long&gt; map;\nVehicle[] vehicles = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nmap = Arrays.stream(vehicles)\n.collect(Collectors.groupingBy(Vehicle::getWheelCount, Collectors.counting()));\nmap.forEach((k, v) -&gt; System.out.printf(\"N\u00famero de veh\u00edculos con %d ruedas: %d\\n\", k, v));\n}\npublic static void main(String[] args){\nnew CollectorsGroupingByDownstream().show();\n}\n}\n</code></pre> <p>Estas dos versiones del m\u00e9todo <code>groupingBy</code>  retornan por defecto un <code>HashMap</code>, por lo que existe una tercera versi\u00f3n para obtener una implementaci\u00f3n distinta de la interfaz <code>Map</code>, como por ejemplo <code>LinkedHashMap</code> o <code>TreeMap</code> : <code>public static &lt;T, K, D, A, M  extends  Map&lt;K,  D&gt;&gt;  Collector&lt;T,?,M&gt;  groupingBy(Function&lt;?  super  T,? extends K&gt; classifier,  Supplier&lt;M&gt; mapFactory,  Collector&lt;? super T,A,D&gt; downstream)</code>:</p> <pre><code>public class CollectorsGroupingBySupplier{\npublic void show(){\nMap&lt;Integer, Long&gt; map;\nVehicle[] vehicles = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nmap = Arrays.stream(vehicles)\n.collect(Collectors.groupingBy(Vehicle::getWheelCount, LinkedHashMap::new,\nCollectors.counting()));\nmap.forEach((k, v) -&gt; System.out.printf(\"N\u00famero de veh\u00edculos con %d ruedas: %d\\n\", k, v));\n}\npublic static void main(String[] args){\nnew CollectorsGroupingBySupplier().show();\n}\n}\n</code></pre> <p>\u00bfY si queremos realizar alguna operaci\u00f3n de conversi\u00f3n sobre los elementos de la lista de cada grupo antes de aplicarle el recolector downstream? Podemos usar el m\u00e9todo <code>Collectors.mapping</code> que ya conocemos:</p> <pre><code>public class CollectorsGroupingByMapping{\npublic void show(){\nMap&lt;Integer, String&gt; map;\nVehicle[] vehicles = new Vehicle[6];\nvehicles[0] = new Vehicle(\"9685KMX\", 4, \"azul\");\nvehicles[1] = new Vehicle(\"1235GTR\", 2, \"rojo\");\nvehicles[2] = new Vehicle(\"7314QWE\", 4, \"verde\");\nvehicles[3] = new Vehicle(\"5930POI\", 2, \"negro\");\nvehicles[4] = new Vehicle(\"1705UBG\", 4, \"blanco\");\nvehicles[5] = new Vehicle(\"3495JZA\", 2, \"naranja\");\nmap = Arrays.stream(vehicles)\n.collect(Collectors.groupingBy(Vehicle::getWheelCount, TreeMap::new,\nCollectors.mapping(Vehicle::getRegistration, Collectors.joining(\" - \"))));\nmap.forEach((k, v) -&gt; System.out.printf(\"Matr\u00edculas con %d ruedas: %s\\n\", k, v));\n}\npublic static void main(String[] args){\nnew CollectorsGroupingByMapping().show();\n}\n}\n</code></pre> <p>Si la funci\u00f3n de transformaci\u00f3n retorna un stream, podemos usar <code>public static &lt;T, U, A, R&gt; Collector&lt;T,?,R&gt; flatMapping(Function&lt;? super T,? extends Stream&lt;? extends U&gt;&gt; mapper,  Collector&lt;? super U,A,R&gt; downstream)</code> disponible a partir de Java 9.</p> <p>Por ejemplo, vamos a cambiar la clase Vehicle para registrar modelos de coches con un determinado n\u00famero de ruedas y una lista de todos los colores en los que est\u00e1 disponible dicho modelo, y si quisi\u00e9ramos obtener de cada n\u00famero de ruedas cu\u00e1ntos colores hay disponible podr\u00edamos hacer lo siguiente:</p> VehicleMainSalida <pre><code>public class Vehicle{\nprivate String model;\nprivate int wheelCount;\nprivate List&lt;String&gt; colors;\npublic Vehicle(String model, int wheelCount, List&lt;String&gt; colors){\nthis.model = model;\nthis.wheelCount = wheelCount;\nthis.colors = colors;\n}\npublic String getModel(){\nreturn model;\n}\npublic int getWheelCount(){\nreturn wheelCount;\n}\npublic List&lt;String&gt; getColors(){\nreturn colors;\n}\n}\n</code></pre> <pre><code>public class CollectorsGroupingByMapping{\npublic void show(){\nMap&lt;Integer, List&lt;Object&gt;&gt; map;\nVehicle[] vehicles = new Vehicle[4];\nvehicles[0] = new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\", \"blanco\"));\nvehicles[1] = new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\"));\nvehicles[2] = new Vehicle(\"Audi\", 2, List.of(\"negro\", \"verde\"));\nvehicles[3] = new Vehicle(\"Ford\", 2, List.of(\"negro\", \"blanco\"));\nmap = Arrays.stream(vehicles)\n.collect(Collectors.groupingBy(Vehicle::getWheelCount, TreeMap::new,\nCollectors.mapping(v -&gt; v.getColors(), Collectors.toList())));\nmap.forEach((k,v) -&gt; System.out.printf(\"N\u00famero de ruedas: %d Colores: %s\\n\", k, v));\n}\npublic static void main(String[] args){\nnew CollectorsGroupingByMapping().show();\n}\n}\n</code></pre> <pre><code>N\u00famero de ruedas: 2 Colores: [[negro, verde], [negro, blanco]]\nN\u00famero de ruedas: 4 Colores: [[azul, rojo, blanco], [naranja, blanco]]\n</code></pre> <p>Si nos fijamos en la salida de consola, salen las sublistas. Para quitarlas, podemos pasar estas listas a streams y luego utilizar el m\u00e9todo flatMapping  para aplanarlas:</p> MainSalida <pre><code>public class CollectorsGroupingByFlatMapping{\npublic void show(){\nMap&lt;Integer, String&gt; map;\nVehicle[] vehicles = new Vehicle[4];\nvehicles[0] = new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\", \"blanco\"));\nvehicles[1] = new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\"));\nvehicles[2] = new Vehicle(\"Audi\", 2, List.of(\"negro\", \"verde\"));\nvehicles[3] = new Vehicle(\"Ford\", 2, List.of(\"negro\", \"blanco\"));\nmap = Arrays.stream(vehicles)\n.collect(Collectors.groupingBy(Vehicle::getWheelCount, TreeMap::new,\nCollectors.flatMapping(v -&gt; v.getColors().stream(), Collectors.joining(\"-\"))));\nmap.forEach((k,v) -&gt; System.out.printf(\"N\u00famero de ruedas: %d Colores: %s\\n\", k, v));\n}\npublic static void main(String[] args){\nnew CollectorsGroupingByFlatMapping().show();\n}\n}\n</code></pre> <pre><code>N\u00famero de ruedas: 2 Colores: negro-verde-negro-blanco\nN\u00famero de ruedas: 4 Colores: azul-rojo-blanco-naranja-blanco\n</code></pre> <p>Ahora nos encontramos con colores repetidos. Para quitarlos, podemos hacer uso del m\u00e9todo  <code>public  static  &lt;T,  A,  R,  RR&gt;  Collector&lt;T,A,RR&gt; collectingAndThen(Collector&lt;T,A,R&gt;  downstream,  Function&lt;R,RR&gt;  finisher)</code>.Este  m\u00e9todo recolecta y despu\u00e9s se puede realizar un Function sobre el resultado de la recolecci\u00f3n.</p> MainSalida <pre><code>public class CollectorsGroupingByCollectingAndThen{\npublic void show(){\nMap&lt;Integer, String&gt; map;\nVehicle[] vehicles = new Vehicle[4];\nvehicles[0] = new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\", \"blanco\"));\nvehicles[1] = new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\"));\nvehicles[2] = new Vehicle(\"Audi\", 2, List.of(\"negro\", \"verde\"));\nvehicles[3] = new Vehicle(\"Ford\", 2, List.of(\"negro\", \"blanco\"));\nmap = Arrays.stream(vehicles)\n.collect(Collectors.groupingBy(Vehicle::getWheelCount, TreeMap::new,\nCollectors.collectingAndThen(Collectors.flatMapping(v -&gt;\nv.getColors().stream(), Collectors.toList()),\nlist -&gt; list.stream().distinct().collect(Collectors.joining(\"-\")))));\nmap.forEach((k,v) -&gt; System.out.printf(\"N\u00famero de ruedas: %d Colores: %s\\n\", k, v));\n}\npublic static void main(String[] args){\nnew CollectorsGroupingByCollectingAndThen().show();\n}\n}\n</code></pre> <pre><code>N\u00famero de ruedas: 2 Colores: negro-verde-blanco\nN\u00famero de ruedas: 4 Colores: azul-rojo-blanco-naranja\n</code></pre> <p>En otras ocasiones, lo que queremos es filtrar los elementos de cada lista en base a alg\u00fan criterio, antes de aplicarle el recolector downstream. Para ello, Java 9 incorpor\u00f3 el m\u00e9todo <code>public  static  &lt;T,  A,  R&gt;  Collector&lt;T,?,R&gt;  filtering(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T,A,R&gt; downstream)</code>:</p> MainSalida <pre><code>public class CollectorsGroupingByFiltering{\npublic void show(){\nMap&lt;String, List&lt;Vehicle&gt;&gt; map;\nList&lt;Vehicle&gt; vehicles = new ArrayList&lt;&gt;();\nvehicles.add(new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\")));\nvehicles.add(new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\")));\nvehicles.add(new Vehicle(\"Audi\", 2, List.of(\"negro\", \"verde\")));\nvehicles.add(new Vehicle(\"Ford\", 2, List.of(\"amarillo\", \"blanco\")));\nmap = vehicles.stream()\n.collect(Collectors.groupingBy(Vehicle::getModel,\nCollectors.filtering(v -&gt; v.getWheelCount() == 4, Collectors.toList())));\nmap.forEach((k,v) -&gt; System.out.printf(\"Modelo: %s Veh\u00edculos de 4 ruedas: %s\\n\", k, v));\n}\npublic static void main(String[] args){\nnew CollectorsGroupingByFiltering().show();\n}\n}\n</code></pre> <pre><code>Modelo:Audi Veh\u00edculos de 4 ruedas: [Vehicle [model=Audi, wheelCount=4,\nspeed=0.0, colors=[azul, rojo]]]\nModelo:Ford Veh\u00edculos de 4 ruedas: [Vehicle [model=Ford, wheelCount=4,\nspeed=0.0, colors=[naranja, blanco]]]\n</code></pre> <p>Se pueden crear varios niveles de agrupamiento, aplicando  groupingBy  como recolector downstream de los elementos de cada grupo:</p> MainSalida <pre><code>public class CollectorsVariousLevelsOfGroupingBy{\npublic void show(){\nMap&lt;String, Map&lt;Integer, Long&gt;&gt; map;\nList&lt;Vehicle&gt; vehicles = new ArrayList();\nvehicles.add(new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\")));\nvehicles.add(new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\", \"verde\")));\nvehicles.add(new Vehicle(\"Seat\", 4, List.of(\"amarillo\", \"verde\")));\nvehicles.add(new Vehicle(\"Audi\", 2, List.of(\"negro\")));\nvehicles.add(new Vehicle(\"Ford\", 2, List.of(\"rojo\", \"blanco\")));\nvehicles.add(new Vehicle(\"Seat\", 2, List.of(\"amarillo\", \"morado\")));\nmap = vehicles.stream()\n.collect(Collectors.groupingBy(Vehicle::getModel,\nCollectors.groupingBy(Vehicle::getWheelCount,\nCollectors.flatMapping(v -&gt; v.getColors().stream(),\nCollectors.counting()))));\nmap.forEach((k,v) -&gt; {\nv.forEach((k2, v2) -&gt; {\nSystem.out.printf(\"Modelo %s con %d ruedas est\u00e1 disponible en %d %s\\n\", k, k2, v2,\nv2 == 1 ? \"color\" : \"colores\");\n});\n});\n}\npublic static void main(String[] args){\nnew CollectorsVariousLevelsOfGroupingBy().show();\n}\n}\n</code></pre> <pre><code>Modelo Seat con 2 ruedas est\u00e1 disponible en 2 colores\nModelo Seat con 4 ruedas est\u00e1 disponible en 2 colores\nModelo Audi con 2 ruedas est\u00e1 disponible en 1 color\nModelo Audi con 4 ruedas est\u00e1 disponible en 2 colores\nModelo Ford con 2 ruedas est\u00e1 disponible en 2 colores\nModelo Ford con 4 ruedas est\u00e1 disponible en 3 colore\n</code></pre>"},{"location":"bloque_iii/tema_13/page-4/#recolectores-de-particionado","title":"Recolectores de particionado","text":"<p><code>public  static  &lt;T&gt;  Collector&lt;T,?,Map&lt;Boolean,List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;?  super  T&gt;  predicate)</code>: aplica  el  predicado proporcionado a cada uno de los elementos del stream y crea dos grupos, uno con los que cumplen el predicado y otro con los que no lo cumplen:</p> MainSALIDA <pre><code>public class CollectorsPartitionBy{\npublic void show(){\nMap&lt;Boolean, Long&gt; map;\nList&lt;Vehicle&gt; vehicles = new ArrayList&lt;&gt;();\nvehicles.add(new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\")));\nvehicles.add(new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\", \"verde\")));\nvehicles.add(new Vehicle(\"Seat\", 4, List.of(\"amarillo\", \"verde\")));\nvehicles.add(new Vehicle(\"Audi\", 2, List.of(\"negro\")));\nvehicles.add(new Vehicle(\"Ford\", 2, List.of(\"rojo\", \"blanco\")));\nmap = vehicles.stream()\n.collect(Collectors.partitioningBy(vehicle -&gt; vehicle.getWheelCount() == 4, Collectors.counting()));\nmap.forEach((k, v) -&gt; {\nSystem.out.printf(\"%s hay en %d modelos\\n\", k ? \"Veh\u00edculos de 4 ruedas\" : \"Veh\u00edculos que no son de 4 ruedas: \", v);\n});\n}\npublic static void main(String[] args){\nnew CollectorsPartitionBy().show();\n}\n}\n</code></pre> <pre><code>Veh\u00edculos que no son de 4 ruedas:\nVehicle [model=Audi, wheelCount=2, colours=[negro, verde]]\nVehicle [model=Ford, wheelCount=2, colours=[amarillo, blanco]]\nVeh\u00edculos de 4 ruedas:\nVehicle [model=Audi, wheelCount=4, colours=[azul, rojo]]\nVehicle [model=Ford, wheelCount=4, colours=[naranja, blanco]\n</code></pre> <p>Existe otra versi\u00f3n del m\u00e9todo que recibe como segundo argumento un recolector para que sea ejecutado sobre la lista de cada grupo:</p> MainSALIDA <pre><code>public class CollectorsPartitioningByDownstream{\npublic void show(){\nMap&lt;Boolean, List&lt;Vehicle&gt;&gt; map;\nList&lt;Vehicle&gt; vehicles = new ArrayList&lt;&gt;();\nvehicles.add(new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\")));\nvehicles.add(new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\")));\nvehicles.add(new Vehicle(\"Audi\", 2, List.of(\"negro\", \"verde\")));\nvehicles.add(new Vehicle(\"Ford\", 2, List.of(\"amarillo\", \"blanco\")));\nmap = vehicles.stream()\n.collect(Collectors.partitioningBy(v -&gt; v.getWheelCount() == 4));\nmap.forEach((k, v) -&gt; {\nSystem.out.printf(\"%s\\n\", k ? \"Veh\u00edculos de 4 ruedas\" : \"Veh\u00edculos que no son de 4 ruedas: \");\nv.forEach(System.out::println);\n});\n}\npublic static void main(String[] args){\nnew CollectorsPartitioningByDownstream().show();\n}\n}\n</code></pre> <pre><code>Veh\u00edculos que no son de 4 ruedas:\nVehicle [model=Audi, wheelCount=2, colours=[negro, verde]]\nVehicle [model=Ford, wheelCount=2, colours=[amarillo, blanco]]\nVeh\u00edculos de 4 ruedas:\nVehicle [model=Audi, wheelCount=4, colours=[azul, rojo]]\nVehicle [model=Ford, wheelCount=4, colours=[naranja, blanco]\n</code></pre>"},{"location":"bloque_iii/tema_13/page-4/#combinacion-de-dos-recolectores","title":"Combinaci\u00f3n de dos recolectores","text":"<p><code>public  static  &lt;T,  R1,  R2,  R&gt;  Collector&lt;T,?,R&gt;  teeing(Collector&lt;?  super T,?,R1&gt; downstream1,  Collector&lt;? super T,?,R2&gt; downstream2,  BiFunction&lt;? super R1,? super R2,R&gt; merger)</code>: ejecuta ambos recolectores sobre los elementos y despu\u00e9s ejecuta sobre los resultados la <code>BiFunction</code> proporcionada, que combinar\u00e1 ambos resultados, de manera que la combinaci\u00f3n ser\u00e1 el producto final de la recolecci\u00f3n</p> ResultMainSALIDA <pre><code>public class Result{\nprivate Optional&lt;Vehicle&gt; min;\nprivate Optional&lt;Vehicle&gt; max;\npublic Result(Optional&lt;Vehicle&gt; min, Optional&lt;Vehicle&gt; max){\nthis.min = min;\nthis.max = max;\n}\npublic Optional&lt;Vehicle&gt; getMin(){\nreturn min;\n}\npublic Optional&lt;Vehicle&gt; getMax(){\nreturn max;\n}\n@Override\npublic String toString(){\nreturn String.format(\"El veh\u00edculo que tiene el m\u00ednimo n\u00famero de colores es %s\\nEl veh\u00edculo que tiene el m\u00e1ximo n\u00famero de colores es %s\\n\", min, max);\n}\n}\n</code></pre> <pre><code>public class CollectorsTeeing{\npublic void show(){\nResult result;\nList&lt;Vehicle&gt; vehicles = new ArrayList&lt;&gt;();\nvehicles.add(new Vehicle(\"Audi\", 4, List.of(\"azul\", \"rojo\")));\nvehicles.add(new Vehicle(\"Ford\", 4, List.of(\"naranja\", \"blanco\", \"verde\")));\nvehicles.add(new Vehicle(\"Seat\", 4, List.of(\"amarillo\", \"verde\")));\nvehicles.add(new Vehicle(\"Audi\", 2, List.of(\"negro\")));\nvehicles.add(new Vehicle(\"Ford\", 2, List.of(\"rojo\", \"blanco\")));\nvehicles.add(new Vehicle(\"Seat\", 2, List.of(\"amarillo\", \"morado\")));\nresult = vehicles.stream()\n.collect(Collectors.teeing(Collectors.minBy(Comparator.comparing(v -&gt; v.getColors().size())),\nCollectors.maxBy(Comparator.comparing(v -&gt; v.getColors().size())),\nResult::new));\nSystem.out.println(result);\n}\npublic static void main(String[] args){\nnew CollectorsTeeing().show();\n}\n}\n</code></pre> <pre><code>El veh\u00edculo que tiene el m\u00ednimo n\u00famero de colores es Vehicle [model=Audi, wheelCount=2, colours=[negro]]\nEl veh\u00edculo que tiene el m\u00e1ximo n\u00famero de colores es Vehicle [model=Ford, wheelCount=4, colours=[naranja, blanco, verde]]\n</code></pre> <p>Este m\u00e9todo es de la versi\u00f3n 12 de Java. En versiones anteriores, ser\u00eda necesario operar dos  veces  sobre  el  stream,  almacenar  los  resultados  intermedios  en  variables temporales y despu\u00e9s combinar las variables temporales.</p>"},{"location":"bloque_iii/tema_13/page-4/#streams-y-checked-exceptions","title":"Streams y checked exceptions","text":"<p>Las checked exceptions de Java no congenian demasiado bien con la programaci\u00f3n funcional y los stream. En el siguiente  ejemplo  vemos  como  nuestro  c\u00f3digo  queda  m\u00e1s  ofuscado  debido  a  que  estamos  obligados  a capturar la checked exception generada por el constructor de la clase <code>URL</code>:</p> <pre><code>List&lt;URL&gt; urls = Stream.of(\"www.iessaladillo.com/api\", \"www.iessaladillo.com/css\")\n.map(s -&gt; s.replace(\"iessaladillo.com\", \"iessaladillo.es\"))\n.map(url -&gt; {\ntry{\nreturn new URL(url);\n} catch(Exception e){\n// ...\n}\n}).collect(toList());\n</code></pre> <p>Con el objeto de mejorar la claridad de nuestro c\u00f3digo, podemos crear m\u00e9todos que capturen la checked exception y la relancen como una runtime exception, tal y como hace la siguiente librer\u00eda https://gist.github.com/jomoespe/ea5c21722b693c09c38bf6286226cd92</p> <pre><code>List&lt;URL&gt; urls = Stream.of(\"www.iessaladillo.com/api\", \"www.iessaladillo.com/css\")\n.map(s -&gt; s.replace(\"iessaladillo.com\", \"iessaladillo.es\"))\n.map(rethrowFunction(URL::new))\n.collect(toList());\n</code></pre>"},{"location":"bloque_iii/tema_13/page-5/","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza una nueva versi\u00f3n del proyecto del tema anterior eliminando la clase <code>Stream&lt;T&gt;</code> y haciendo uso de los streams</p> Ejercicio 2 <p>En un Udemy se desea guardar informaci\u00f3n referente a los cursos que se tienen almacenado:</p> <ul> <li>El t\u00edtulo del curso</li> <li>La duraci\u00f3n expresada en horas. Si un curso dura una hora y 15 minutos se representar\u00e1 como 1,25.</li> <li>Cantidad de videos que contiene el curso</li> <li>Cantidad de alumnos subscritos al curso</li> </ul> <p>Teniendo en cuenta la siguiente informaci\u00f3n de los cursos:</p> T\u00edtulo Duraci\u00f3n Vides Alumnos Curso profesional de Java 6,5 50 200 Curso profesional de Python 8,5 60 800 Curso profesional de DB 4,5 700 700 Curso profesional de Android 7,5 10 400 Curso profesional de Escritura 1,5 10 300 <ul> <li>Obtener la cantidad de cursos con una duraci\u00f3n mayor a 5 horas.</li> <li>Obtener la cantidad de cursos con una duraci\u00f3n menor a 2 horas.</li> <li>Listar t\u00edtulo de todos aquellos cursos con una cantidad de v\u00eddeos mayor a 50.</li> <li>Mostrar en consola el t\u00edtulo de los 3 primeros cursos con mayor duraci\u00f3n.</li> <li>Mostrar en consola la duraci\u00f3n total de todos los cursos.</li> <li>Mostrar en consola todos aquellos libros que superen el promedio en cuanto a duraci\u00f3n se refiere.</li> <li>Mostrar en consola la duraci\u00f3n de todos aquellos cursos que tengan una cantidad de alumnos inscritos menor a 500.</li> <li>Obtener el curso con mayor duraci\u00f3n.</li> <li>Crear una lista con todos los t\u00edtulos de los cursos.</li> </ul> Ejercicio 3 <p>Crea una aplicaci\u00f3n Java que defina las siguientes clases:</p> <ul> <li>Student: Representa a un alumno. Dispone de los campos:<ul> <li>id: identificador de tipo long</li> <li>name: nombre del alumno de tipo String</li> <li>age: edad del alumno de tipo int</li> <li>group: grupo del alumno de tipo String</li> <li>grant: cantidad de la beca concedida de tipo Integer</li> <li>grades: notas del alumno de tipo List <li>Grade: Representa una nota. Dispone de los campos:<ul> <li>subject: nombre de la asignatura de tipo String</li> <li>mark: nota de dicha asignatura de tipo float</li> </ul> </li> <li>Database: Representa la base de datos con la que trabajaremos. Dispondr\u00e1 de un campo privado correspondiente a la lista de estudiantes. Adem\u00e1s tendr\u00e1 un m\u00e9todo p\u00fablico denominado queryAllStudents() que retornar\u00e1 la lista de alumnos.</li> <p>Inicializa la base de datos con los siguientes datos de los alumnos (en este orden):</p> ID Name Age Group Grant Grades 1 Germ\u00e1n Gin\u00e9s 23 1\u00ba CFGS DAM 2000 [PROGR, 8], [LM, 3] 2 Baldomero 21 1\u00ba CFGS DAM 0 [PROGR, 5], [LM, 4] 3 Ana Guerra 17 1\u00ba CFGS DAM 4000 [PROGR, 8] <p>Realiza en Java los m\u00e9todos necesarios para mostrar por pantalla el resto de las siguientes consultas, usando streams (y optionals cuando sea necesario).</p> <ul> <li> <p>showLegalAgeStudentCount(): Debe mostrar los alumnos que sean mayores de edad. La salida ser\u00eda:</p> <pre><code>N\u00famero de alumnos mayores de edad: 2\n</code></pre> </li> <li> <p>showStudentNamesOrderAlphabetically(): Debe mostrar los nombre de los alumnos ordenados alfab\u00e9ticamente. La salida ser\u00eda:</p> <pre><code>Nombre los alumnos (orden alfab\u00e9tico):\nAna Guerra\nBaldomero\nGerm\u00e1n Gin\u00e9s\n</code></pre> </li> <li> <p>showFirstTwoStudentsNames(): Debe mostrar los nombres de los dos primeros alumnos. La salida ser\u00eda:</p> <pre><code>Nombre de los dos primeros alumnos:\nGerm\u00e1n Gin\u00e9s\nBaldomero\n</code></pre> </li> <li> <p>showStudentsNamesExceptTheFirstOne(): Debe mostrar los nombres de todos los alumnos menos del primero, La salida ser\u00eda:</p> <pre><code>Nombres de alumnos (excepto el primero):\nBaldomero\nAna Guerra\n</code></pre> </li> <li> <p>showStudentsNamesUntilFirstNotLegalAgeOne(): Debe mostrar los nombres de todos los alumnos hasta que encuentre uno menor de edad. \u00c9ste ya no lo mostrar\u00e1. La salida ser\u00eda:</p> <pre><code>Nombres de alumnos (hasta que encontramos uno menor de edad):\nGerm\u00e1n Gin\u00e9s\nBaldomero\n</code></pre> </li> <li> <p>showStudentsSinceFirstNotLegalAgeOne(): Debe mostrar los nombres de todos los alumnos desde que encontremos uno menor de edad. \u00c9ste si lo mostrar\u00e1. La salida ser\u00eda:</p> <pre><code>Nombres de alumnos (desde que encontramos uno menor de edad):\nAna Guerra\n</code></pre> </li> <li> <p>showDifferentSubjectsOrderedAlphabetically(): Debe mostrar las asignaturas de las que hay alg\u00fan alumno matriculado, ordenadas alfab\u00e9ticamente. La salida ser\u00eda:</p> <pre><code>Asignaturas:\nLM\nPROGR\n</code></pre> </li> <li> <p>showStudentsGrantsAndSum(): Debe mostrar la beca de cada alumno y adem\u00e1s la suma de todas las becas. La salida ser\u00eda:</p> <pre><code>Becas:\nGerm\u00e1n Gin\u00e9s: 2000\nBaldomero: 0\nAna Guerra: 4000\nSuma de becas: 6000\n</code></pre> </li> <li> <p>getStudentsOlderThan20(): Debe retornar una lista con los nombres de los alumnos mayores de 20 a\u00f1os. El retorno deber\u00eda la lista:</p> <pre><code>[Germ\u00e1n Gin\u00e9s, Baldomero]\n</code></pre> </li> <li> <p>showYoungestStudentName(): Debe mostrar el nombre de alumna m\u00e1s joven. La salida ser\u00eda:</p> <pre><code>Alumno m\u00e1s joven: Ana Guerra\n</code></pre> </li> <li> <p>showOldestStudentOlderThan23(): Debe mostrar el nombre del alumnos m\u00e1s veterano de entre los que tengan m\u00e1s de 23 a\u00f1os. La salida ser\u00eda:</p> <pre><code>Alumno m\u00e1s veterano mayor de 23: No encontrado\n</code></pre> </li> <li> <p>showStudentNamesWithCommasOrderedByAge(): Debe mostrar una cadena con los nombres de los alumnos separados por coma, ordenados por su edad. La salida ser\u00eda:</p> <pre><code>Alumnos: Ana Guerra, Baldomero, Germ\u00e1n Gin\u00e9s\n</code></pre> </li> <li> <p>showStudentCountInEachGroup(): Debe mostrar el n\u00famero de alumnos de cada grupo-clase, ordenados por nombre del grupo. La salida ser\u00eda:</p> <pre><code>N\u00famero de alumnos en cada grupo:\n1\u00ba CFGS DAM: 2 alumnos\n1\u00ba CFGM SMR: 1 alumno\n</code></pre> <p>Intenta hacer que el listado salga ordenado por el nombre del grupo-clase, a ver si lo consigues.</p> </li> <li> <p>showGrantSummary(): Debe mostrar la estad\u00edstica de becas de los alumnos, es decir, la beca m\u00e1xima, la m\u00ednima y la media (haciendo todos los c\u00e1lculos de una sola vez). La salida ser\u00eda:</p> <pre><code>Estad\u00edstica de becas:\nM\u00e1xima: 4000, M\u00ednima: 0, Media: 2000,00\n</code></pre> </li> <li> <p>showAreAnyStudentUnderLegalAge(): Debe mostrar si hay alg\u00fan alumno menor de edad. La salida ser\u00eda:</p> <pre><code>\u00bfAlg\u00fan alumno menor de edad? S\u00ed\n</code></pre> </li> <li> <p>showAllStudentHaveGrant(): Debe mostrar si todos los alumnos tienen beca. La salida ser\u00eda:</p> <pre><code>\u00bfTodos los alumnos tienen beca?: No\n</code></pre> </li> <li> <p>showFirstStudentWithoutGrant(): Debe mostrar el nombre del primer alumno que no tenga beca. La salida ser\u00eda:</p> <pre><code>Nombre del primer alumno sin beca: Baldomero\n</code></pre> </li> <li> <p>showHowManyStudentWithOrWithoutGrant(): Debe mostrar cu\u00e1ntos alumnos hay con beca y cu\u00e1ntos sin beca. La salida ser\u00eda:</p> <pre><code>Alumnos con o sin beca\nSin beca: 1\nCon beca: 2\n</code></pre> </li> <li> <p>showNumberOfSubjectsOfEachStudent(): Debe mostrar el n\u00famero de asignaturas de las que est\u00e1 matriculado cada alumnos. La salida ser\u00eda:</p> <pre><code>N\u00famero de asignaturas de cada alumno:\nBaldomero: 2\nAna Guerra: 1\nGerm\u00e1n Gin\u00e9s: 2\n</code></pre> </li> <li> <p>showNumberOfPassersStudentsOfEachSubject() (NIVEL PRO): Debe mostrar el n\u00famero de alumnos aprobados en cada asignatura (mark &gt;= 5). La salida ser\u00eda:</p> <pre><code>N\u00famero de aprobados por asignatura:\nPROGR - 3 aprobados\nLM - 0 aprobados\n</code></pre> <p>Intenta hacer que el listado salga ordenado por nombre de la asignatura.</p> </li> </ul>"},{"location":"bloque_iii/tema_13/page-6/","title":"Proyecto","text":"<p>En una tienda se desea almacenar la siguiente informaci\u00f3n sobre los productos:</p> <ul> <li>Un identificador</li> <li>El nombre del producto</li> <li>La marca del producto</li> <li>El modelo del producto, si \u00e9ste tuviese</li> <li>Precio individual del producto</li> <li>Cantidad de stock</li> <li>Fecha de caducidad, si el producto lo require</li> <li>Peso del producto en gramos</li> </ul> <p>El identificador se forma con las dos primeras letras del nombre del producto, seguido de las 3 siguientes de la marca, seguido del hashCode de ambas.</p> <p>La cesta de la compra estar\u00e1 formada por una colecci\u00f3n de productos y la cantidad de \u00e9stos que contiene. Cada vez que se a\u00f1ade un producto, se deber\u00e1 comprobar si \u00e9ste ya existe en la cesta. Si es as\u00ed, aumentar\u00e1 la cantidad de producto que hay en la cesta, por el contrario a\u00f1adir\u00e1 el producto a la cesta con la cantidad de 1.</p> <p>Una vez que se realice la compra se guardar\u00e1 la informaci\u00f3n en las Facturas, de cada factura se desea conocer:</p> <ul> <li>El identificador de la factura (ser\u00e1 una hash de la fecha de la factura)</li> <li>Fecha de la factura</li> <li>Detalle de la factura (compuesta por el producto, cantidad y precio)</li> <li>Descuentos</li> <li>Precio total</li> </ul> <p>Realiza una aplicaci\u00f3n Java teniendo en cuenta lo siguiente:</p> <ul> <li>Cuando un usuario va a comprar el contenido de la cesta, \u00e9sta se quedar\u00e1 vac\u00eda, adem\u00e1s se deber\u00e1 decrementar la cantidad de stock del producto comprado.</li> <li>Se realizar\u00e1 un descuento del 5% si supera un precio total de 100\u20ac en la factura o si tiene m\u00e1s de 10 productos diferentes</li> </ul> <p>La aplicaci\u00f3n tendr\u00e1 las siguientes opciones:</p> <ul> <li>Mostrar lista de productos</li> <li>Localizar producto por marca, nombre o identificador.</li> <li>A\u00f1adir producto a la cesta (solo haciendo uso del identificador, en caso de que no encuentre dicho producto mostrar\u00e1 un mensaje de error)</li> <li>Mostrar la cesta</li> <li>Eliminar producto de la cesta</li> <li>Realizar compra (si la cesta est\u00e1 vac\u00eda mostrar\u00e1 un mensaje de error)</li> <li>Mostrar facturas</li> <li>Filtrar factura por fechas (mes, a\u00f1o y d\u00eda) o por nombre.</li> </ul> <p>Para realizar este proyecto se tendr\u00e1 en cuenta:</p> <ul> <li>Se deber\u00e1 entregar un diagrama de clase que represente las relaciones entre las clases y las interfaces.</li> <li>Todo las operaciones posibles se har\u00e1 haciendo uso de streams</li> <li>Se podr\u00e1 usar la librer\u00eda common realiza en proyectos anteriores, haciendo uso de JARs.</li> <li>El nombre de las funciones ser\u00e1 en ingl\u00e9s y deber\u00e1n ser lo suficiente claras para poder identificarlas con facilidad.</li> <li>El c\u00f3digo se comentar\u00e1 haciendo uso de los comentarios JavaDoc adem\u00e1s, de comentarios normales para dar una explicaci\u00f3n a la parte del c\u00f3digo m\u00e1s importante.</li> <li>El repositorio de GitHub tendr\u00e1 el siguiente nombre pr13java-NOMBRE-streams siendo NOMBRE el nombre del alumno.</li> <li>Se declarar\u00e1 aquellas variables que sean necesarias inicializ\u00e1ndolas si es necesario, indicando el tipo correspondiente.</li> <li>Se har\u00e1 uso de funciones y procedimientos donde sea oportuno.</li> <li>La entrega de este proyecto se realizar\u00e1 a trav\u00e9s de un enlace a un repositorio de GitHub, realizando siempre m\u00e1s de un commit.</li> <li>Se valorar\u00e1 la limpieza, la claridad, y la estructura del proyecto.</li> </ul>"},{"location":"proyects/cinema/proyecto_v1/","title":"Proyecto V1","text":"<p>Se quiere realizar una aplicaci\u00f3n para realizar la compra de entradas de cine. En este primera parte, se llevar\u00e1 a cabo el inicio de sesi\u00f3n.</p> <p>Se debe tener en cuenta que existen 4 tipos de usuarios diferentes, cliente, administrador, encargado y empleado. De todos los usuarios se desea almacenar las credenciales, que constar\u00e1 de correo, contrase\u00f1a y estado. Pero adem\u00e1s de los clientes se desea almacenar la direcci\u00f3n (compuesta de Nombre de la v\u00eda, n\u00famero, municipio, localidad y c\u00f3digo postal), su nombre completo y una breve biograf\u00eda de 160 caracteres. De los empleados se desea almacenar el a\u00f1o en el que empezaron ser empleados y de los encargados el a\u00f1o en el que se hicieron encargados. De los administradores no se desea conocer nada diferente. </p> <p>Al ejecutar la aplicaci\u00f3n le pedir\u00e1 las credenciales necesarias a un usuario para poder acceder a la aplicaci\u00f3n. Si las credenciales son err\u00f3neas, se las volver\u00e1 a solicitar hasta 3 veces, luego mostrar\u00e1 un mensaje de error y terminar\u00e1 la aplicaci\u00f3n. En caso de las credenciales sean correctas, mostrar\u00e1 un mensaje de bienvenida con el tipo de usuario que ha entrado en la aplicaci\u00f3n.</p> <p>Debes tener en cuenta:</p> <ul> <li>El estado de una credencial puede ser, activo, inactivo, dado de baja, email por confirmar.</li> <li>Al realizarse la petici\u00f3n de iniciar sesi\u00f3n, se deber\u00e1 comprobar si el usuario acreditado es de correo prueba@test.com y de contrase\u00f1a 1234. Este tipo de usuario es administrador</li> <li>La aplicaci\u00f3n se har\u00e1 por completo en INGL\u00c9S, incluyendo los mensajes al usuario.</li> <li>Se deber\u00e1 realizar la entrega a trav\u00e9s de GitHub.</li> <li>Se realizar\u00e1n tantos commits, como se considere, pero siempre m\u00e1s de uno.</li> <li>Se valorar\u00e1 la organizaci\u00f3n de paquetes.</li> <li>Se podr\u00e1 usar la librer\u00eda creada en el proyecto anterior llamada Help, pero ninguna librer\u00eda m\u00e1s. En caso de usarla, se deber\u00e1 hacer la importaci\u00f3n de forma correcta.</li> </ul>"},{"location":"proyects/cinema/proyecto_v2/","title":"Proyecto V2","text":"<p>Los primeros cambios a realizar sobre la aplicaci\u00f3n son los siguientes:</p> <p>Sobre las credenciales de usuarios debes validas:</p> <ul> <li>El email sea correcto, en caso de no serlo, se lanzar\u00e1 una excepci\u00f3n llama <code>EmailMalFormedEXception</code>.</li> <li>La constrase\u00f1a contenga de 8 a 16 caracteres, y como m\u00ednimo una letra min\u00fascula, una may\u00fascula, un d\u00edgito y un car\u00e1cter especial.</li> <li>Si la credencial no es v\u00e1lida, o no es ning\u00fana de las indicadas en la versi\u00f3n anterior, deber\u00e1 obtener por defecto el estado inactivo.</li> </ul> <p>Sobre los clientes se debe tener en cuenta que la bibliograf\u00eda no supere los 160 caracteres, y en caso de superarlo obtener solo los 160 primeros caracteres de la bibliograf\u00eda. Tambi\u00e9n hay que tener en cuenta que los campos num\u00e9ricos de la direcci\u00f3n, no pueden ser negativos, y en caso de serlos, se lanzar\u00e1 un excepci\u00f3n de tipo <code>IllegalArgumentException</code>.</p> <p>Sobre los encargados y los empleados, hay que tener en cuenta, que el a\u00f1o en el que comenzar\u00f3n sus puestos deben ser n\u00fameros positivos y a\u00f1os l\u00f3gicos y v\u00e1lidos, (no ser\u00eda l\u00f3gico que el empleado empezase a trabajar en la empresa en el a\u00f1o 2 a.C)</p> <p>Debe crear una aplicaci\u00f3n llamada SignUpCliente.java, SignUpEmpleado.java, SignUpEmcargado.java, donde se solicite los datos de registro, y en caso de que alguno sea err\u00f3neo debe volver a solicitarselo. Se debe tener en cuenta que el estado de un usuario debe ser EMAIL POR CONFIRMAR, durante su registro, y que no se debe soliciar al usuario.</p> <p>Una vez que el tipo de usuario haya sido creado\u00a1, se mostrar\u00e1 por pantalla con la siguiente estructura:</p> CLIENTEEMPLEADOENCARGADO <pre><code>Cliente Sa\u00fal Benitez\n - Email: saul@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - Direcci\u00f3n: Calle Inventida, n\u00ba 7 - 11300 - La L\u00ednea de la concepci\u00f3n (C\u00e1diz)\n- Bibliograf\u00eda: Soy cin\u00e9filo, en busca de las mejores ofertas para ir al cine.\n   Me gusta mucho las pel\u00edculas de Marvel y DC, aun que a veces tambi\u00e9n me pongo\n   sensibl\u00f3n y me pongo una comedia rom\u00e1ntica.\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> <pre><code>Cliente Rosa Soria\n - Email: rosa@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - A\u00f1o de contrataci\u00f3n: 2015\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> <pre><code>Cliente Marta Dominguez\n - Email: marta@gmail.com\n - Password: ********** # (1)!\n- Estado: EMAIL POR CONFIRMAR\n - A\u00f1o de contrataci\u00f3n: 2012\n- A\u00f1o de subida: 2018\n</code></pre> <ol> <li>Debe coincidir con el n\u00famero de caracteres de la contrase\u00f1a</li> </ol> Pregunta para pensar <p>\u00bfPor que no fue un error en la primera versi\u00f3n crear una clase exactamente Admin que heredase de la clase base User? Justifica tu respuesta</p>"}]}