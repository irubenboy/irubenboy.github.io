{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"bloque_i/tema_1/page-1/","title":"1 Instalaci\u00f3n del entorno de desarrollo","text":""},{"location":"bloque_i/tema_1/page-1/#que-es-android","title":"\u00bfQu\u00e9 es Android?","text":"<p>Android es un sistema operativo m\u00f3vil basado en Linux, dise\u00f1ado para ser utilizado en dispositivos m\u00f3viles como tel\u00e9fonos inteligentes (smart phones), tabletas (tablets), Google TV, relojes de pulsera (smart watch) y otros dispositivos.</p> <p>Acompa\u00f1ando al n\u00facleo Linux del sistema operativo, Android incorpora una serie de capas de software (middleware) que hacen de intermediarias entre el n\u00facleo y otras aplicaciones, hardware, redes, etc, aportando distintas funcionalidades al dispositivo f\u00edsico.</p> <p>Android, al contrario que el sistema operativo para dispositivos m\u00f3viles iOS, se desarrolla de forma abierta y se puede acceder a su c\u00f3digo fuente. El que se tenga acceso al c\u00f3digo fuente no significa que se pueda tener siempre la \u00faltima versi\u00f3n de Android en un determinado m\u00f3vil, ya que el c\u00f3digo para soportar el hardware (controladores) de cada fabricante normalmente no es p\u00fablico, por lo que no dispondr\u00edamos del firmware para poder hacerlo funcionar en dicho terminal. Por otro lado, las nuevas versiones de Android suelen requerir m\u00e1s recursos, por lo que los modelos de dispositivos m\u00e1s antiguos pueden quedar descartados por razones de memoria (RAM), velocidad de procesador, etc.</p> <p>Las aplicaciones Android se desarrollan habitualmente en los lenguajes de programaci\u00f3n Java o Kotlin, haciendo uso del Android Software Development Kit (Android SDK), el kit de desarrollo de software proporcionado por Google, y cuya descarga es gratuita. Tambi\u00e9n tenemos disponible un kit de desarrollo nativo para aplicaciones o extensiones en C o C++, aunque s\u00f3lo se usa en casos muy espec\u00edficos.</p> <p>Google ha desarrollado su propia tienda online de aplicaciones para dispositivos Android, denominada Google Play. Esta web permite a los usuarios navegar y adquirir aplicaciones publicadas por los desarrolladores, ya sean de pago o gratuitas, de manera que Google retribuye a los desarrolladores con un porcentaje del precio de las aplicaciones.</p> <p>Por otra parte, los usuarios pueden instalar aplicaciones desde otras tiendas virtuales (tales como Amazon AppStore) o directamente en el dispositivo, si se dispone del archivo APK (paquete de instalaci\u00f3n) de la aplicaci\u00f3n.</p> <p>Un archivo con extensi\u00f3n .apk es un paquete para el sistema operativo Android. Este formato es una variante del formato JAR de Java y se usa para distribuir e instalar componentes empaquetados para la plataforma Android para smartphones y tablets.</p>"},{"location":"bloque_i/tema_1/page-1/#historia","title":"Historia","text":"<p>El nombre Android (androide en castellano) hace referencia a la novela de Philip K. Dick llamada \"\u00bfSue\u00f1an los androides con ovejas el\u00e9ctricas?\", que posteriormente fue adaptada al cine como \"Blade Runner\".</p> <p>En julio de 2005, Google adquiri\u00f3 Android Inc., una peque\u00f1a compa\u00f1\u00eda de Palo Alto, California fundada en 2003. Entre los cofundadores de Android que se fueron a trabajar a Google est\u00e1n Andy Rubin, Rich Miner, Nick Sears, y Chris White.</p> <p>En Google, el equipo liderado por Rubin desarroll\u00f3 una plataforma para dispositivos m\u00f3viles basada en el kernel de Linux que fue promocionado a fabricantes de dispositivos y operadores con la promesa de proveer un sistema flexible y actualizable. Google pretend\u00eda crear una alianza con fabricantes de hardware y software para que cooperaran entre s\u00ed en el desarrollo de dispositivos m\u00f3viles.</p> <p>El 5 de noviembre de 2007 la Open Handset Alliance (OHA, Alianza de Dispositivos m\u00f3viles Abiertos), un consorcio de varias compa\u00f1\u00edas, vio la luz con el fin de desarrollar est\u00e1ndares abiertos para dispositivos m\u00f3viles.</p> <p>El primer producto de la OHA fue Android, una plataforma para dispositivos m\u00f3viles construida sobre la versi\u00f3n 2.6 del kernel de Linux.</p> <p>El primer tel\u00e9fono disponible en el mercado para ejecutar Android fue el HTC Dream, dado a conocer al p\u00fablico el 22 de octubre de 2008.</p> <p>A principios de 2010 Google colabor\u00f3 con HTC para lanzar su producto estrella en dispositivos Android, el Nexus One (cuyo nombre es un gui\u00f1o a la pel\u00edcula Blade Runner), como primer dispositivo Android \"puro\".</p> <p>Web oficial para desarrolladores Android</p> <p>La web oficial para desarrolladores Android es https://developer.android.com/index.php, en la que podemos encontrar toda la documentaci\u00f3n oficial.</p>"},{"location":"bloque_i/tema_1/page-1/#versiones-y-distribucion-de-usos","title":"Versiones y Distribuci\u00f3n de Usos","text":"<p>Android ha visto numerosas actualizaciones desde su liberaci\u00f3n inicial. Estas actualizaciones al sistema operativo base t\u00edpicamente arreglan bugs y agregan nuevas funciones. Generalmente cada actualizaci\u00f3n del sistema operativo Android es desarrollada bajo un nombre en c\u00f3digo de un elemento relacionado con postres o dulces. En cada versi\u00f3n el postre elegido empieza por una letra distinta siguiendo el orden alfab\u00e9tico.</p> <p>A continuaci\u00f3n se muestran todas las versiones, con su nombre, su n\u00famero de API y su fecha de liberaci\u00f3n.</p> Versi\u00f3n Nombre n\u00ba API Fecha 1.0 Apple pie (pastel de manzana) 1 09/2008 1.1 Banana bread (pan de pl\u00e1tano) 2 02/2009 1.5 Cupcake (magdalena glaseada) 3 04/2009 1.6 Donut (rosquilla) 4 09/2009 2.0 Eclair (pepito o bilbaino) 5 10/2009 2.0.1 Eclair 0.1 6 12/2009 2.1 Eclair MR1 7 01/2010 2.2 Froyo (frozen yogurt, yogur helado) 8 05/2010 2.3 Gingerbread (pan de jengibre) 9 12/2010 2.3.3 Gingerbread MR1 10 02/2011 3.0 Honeycomb (panal de miel) 11 02/2011 3.1 Honeycomb MR1 12 05/2011 3.2 Honeycomb MR2 13 07/2011 4.0 Ice cream sandwich, ICS (sandwich de helado) 14 10/2011 4.0.3 ICS MR1 15 12/2011 4.1 Jelly Bean (gragea) 16 07/2012 4.2 Jelly Bean MR1 17 10/2012 4.3 Jelly Bean MR2 18 07/2013 4.4 KitKat (barrita de chocolate) 19 10/2013 L Android L Preview 20 06/2014 5.0 Lollypop (piruleta) 21 11/2014 5.1 Lollipop MR1 22 03/2015 6.0 Marshmellow (nube, esponjita) 23 10/2015 7.0 Nougat (turr\u00f3n) 24 08/2016 7.1 Nougat 25 12/2016 8 Oreo (galleta) 26 08/2017 8.1 Oreo 27 12/2017 9 Pie (pastel) 28 08/2018 10 Android 10 29 09/2019 11 Android 11 30 09/2020 <p>Cuando creemos un nuevo proyecto en Android Studio, \u00e9ste nos permitir\u00e1 acceder a una estad\u00edstica sobre la distribuci\u00f3n de uso de las distintas versiones de Android entre los usuario de Google Play.</p> <p>Google publica con cierta frecuencia la distribuci\u00f3n de uso de las distintas versiones de Android.</p> <p> Figura 1 - Distribuci\u00f3n de las distintas versiones de Android</p> <p>Esta informaci\u00f3n de distribuci\u00f3n es muy importante para nosotros como desarrolladores porque nos permite conocer, entre otras cosas, con qu\u00e9 versiones de la API de Android nos merece la pena que sean compatibles nuestras aplicaciones, esto es, la versi\u00f3n m\u00ednima de la API Android para la que deber\u00edamos desarrollar nuestras aplicaciones.</p> <p>Android ha sido criticado muchas veces por la fragmentaci\u00f3n que sufren sus terminales. La fragmentaci\u00f3n hace referencia a las distintas versiones de Android que hoy en d\u00eda se pueden encontrar en el mercado. Las causas principales de esta fragmentaci\u00f3n son las siguientes:</p> <ul> <li>Android es un sistema abierto, y como tal, los fabricantes pueden personalizar la versi\u00f3n oficial de Android a los dispositivos que desarrollan, lo que implica que la misma versi\u00f3n del sistema operativo no luzca exactamente igual en distintos dispositivos.</li> <li>El hecho de que muchos fabricantes instalan en sus dispositivos versiones personalizadas de Android, significa en la pr\u00e1ctica, que las actualizaciones que realiza Google en la versi\u00f3n oficial de Android no son trasladadas inmediatamente a los dispositivos de los usuarios, ya que antes debe pasar por el proceso de personalizaci\u00f3n o adaptaci\u00f3n que hacen los fabricantes. En algunos casos, dichas actualizaciones nunca llegan a producirse.</li> <li>En el mercado actual conviven dispositivos provenientes de diferentes versiones oficiales de Android, como podemos apreciar en el gr\u00e1fico anterior.</li> </ul> <p>Todo ello hace que la fragmentaci\u00f3n sea un problema real para los desarrolladores de aplicaciones para Android, ya que tienen que desarrollar sus aplicaciones para multitud de dispositivos diferentes, con hardware diferente y con versiones del sistema operativo diferentes, lo que puede no ser rentable.</p> <p>Sin embargo, la fragmentaci\u00f3n, como toda diversidad, tambi\u00e9n tiene su lado positivo para los desarrolladores, como la aparici\u00f3n de tiendas online (markets) alternativos que crean competencia a Google Play de Google y provocan variedad y abarcamiento de mercado, por lo que m\u00e1s personas descargan aplicaciones.</p> <p>Con objeto de mejorar los problemas de fragmentaci\u00f3n, Google lleva a cabo distintas estrategias:</p> <ul> <li>Algunas de las novedades son incorporadas a la Google Play Services, una librer\u00eda propietaria de Google, que se incluye en todos los dispositivos certificados por Google, y que es compatible con versiones de Android a partir de la API 8.</li> <li>Proporciona a los desarrolladores la librer\u00eda de soporte Android Support Library, de manera que puedan utilizar las novedades de las nuevas versiones de Android al desarrollar sus aplicaciones manteniendo la compatibilidad con dispositivos con versiones de Android antiguas.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#entorno-de-desarrollo","title":"Entorno de Desarrollo","text":"<p>Para poder desarrollar aplicaciones Android es necesario que configuremos nuestro equipo de desarrollo con los siguientes elementos:</p> <ul> <li>Sistema operativo: Podemos usar sistemas operativos Windows (XP o superior), en Linux (de 32 bits) y en Mac OS X (10.5.8 o superior sobre plataforma x86).</li> <li>Lenguaje: Como se va a programar usando Java o Kotlin, es imprescindible tener instalado el JDK (Java Development Kit) de Oracle. Se recomienda usar la versi\u00f3n 1.8 de la JDK (Java 8).</li> <li>Entorno integrado de desarrollo (IDE): Con objeto de hacer m\u00e1s asequible la programaci\u00f3n para esta plataforma, utilizaremos el IDE Android Studio.</li> <li>Kit de desarrollo en Android: Deberemos tener tambi\u00e9n una copia del Android SDK. Este paquete es un conjunto de herramientas que nos har\u00e1n m\u00e1s f\u00e1cil programar para Android y gestionar nuestros dispositivos virtuales. Se instala autom\u00e1ticamente al instalar Android Studio y podemos actualizarlo directamente desde el propio IDE.</li> <li>Dispositivos de prueba: Podremos crear distintos dispositivos virtuales (emuladores), sobre los que simular el comportamiento de las aplicaciones que estamos desarrollando en diferentes tipos de dispositivos, con distintos tama\u00f1o y resoluciones de pantalla. Podremos crear dichos dispositivos virtuales desde el propio IDE Android Studio. Adem\u00e1s, en vez de usar dispositivos virtuales, podemos usar dispositivos f\u00edsicos reales Android en los que probar nuestras aplicaciones.</li> </ul>"},{"location":"bloque_i/tema_1/page-1/#android-studio","title":"Android Studio","text":"<p>IntelliJ IDEA, tambi\u00e9n conocido como IntelliJ o IDEA, es un entorno de desarrollo de aplicaciones basadas en Java creado por la empresa JetBrains. Incluye plugins para Java y otros lenguajes y frameworks, entre ellos Android.</p> <p>Web oficial de IntelliJ IDEA</p> <p>https://www.jetbrains.com/es-es/idea/</p> <p>Dispone de las algunas caracter\u00edsticas muy interesantes para nosotros como desarrolladores:</p> <ul> <li>Editor de c\u00f3digo con coloreado de sintaxis, auto-completado inteligente y refactorizaci\u00f3n de clases, dise\u00f1os y estilos.</li> <li>Dise\u00f1o de interfaces de usuario mediante drag-and-drop.</li> <li>Acceso al log del sistema (logcat), ejecuci\u00f3n en modo debug</li> </ul> <p>Aunque se trata de un producto comercial, existe una versi\u00f3n community, de c\u00f3digo abierto, que puede usarse de forma gratuita, pero que no incluye todas las funcionalidades de la versi\u00f3n comercial.</p> <p>En mayo de 2013, Google presenta Android Studio, un nuevo entorno de desarrollo gratuito basado en la versi\u00f3n community de IntelliJ IDEA, en el que se integran todas las herramientas espec\u00edficas necesarias para el desarrollo y depuraci\u00f3n de aplicaciones Android. Adem\u00e1s de las funcionalidad aportadas por el propio IntelliJ, Android Studio proporciona:</p> <ul> <li>Soporte para la generaci\u00f3n de aplicaciones basadas en Gradle.</li> <li>Refactorizaci\u00f3n y correcci\u00f3n r\u00e1pida espec\u00edficos para Android.</li> <li>Herramienta Lint para mejorar el rendimiento, la usabilidad y la compatibilidad de nuestras aplicaciones.</li> <li>Funcionalidad de firma de aplicaciones.</li> <li>Asistentes basados en plantillas para crear dise\u00f1os y componentes habituales.</li> <li>Editor de layouts enriquecido, con funcionalidades avanzadas, como la posibilidad de a\u00f1adir componentes a la interfaz de usuario simplemente arrastrando y soltando sobre ella, vista previa del layout en distintas configuraciones de pantalla, etc.</li> <li>Herramientas de monitorizaci\u00f3n de uso de memoria, red, etc., por parte de nuestras aplicaciones.</li> </ul> <p>Con la instalaci\u00f3n de Android Studio se instalan tambi\u00e9n autom\u00e1ticamente varios componentes importantes del Android SDK, permiti\u00e9ndonos a\u00f1adir componentes o actualizarlos m\u00e1s adelante a trav\u00e9s del propio IDE. Existen versiones para Windows, Mac y Linux.</p> <p>Web oficial de Android Studio</p> <p>https://developer.android.com/studio</p>"},{"location":"bloque_i/tema_1/page-1/#emulador","title":"Emulador","text":"<p>El SDK de Android incluye un emulador de dispositivos virtuales m\u00f3viles que puede ser ejecutado en nuestro propio ordenador, lo que nos permite hacer prototipos, desarrollar y probar las aplicaciones Android que desarrollemos sin tener que usar un dispositivo m\u00f3vil real.</p> <p>El emulador proporciona una copia virtual de las caracter\u00edsticas hardware y software de un dispositivo m\u00f3vil real, excepto por el hecho de que no puede realizar llamadas telef\u00f3nicas reales. Utiliza una ventana de nuestro sistema operativo para simular la pantalla del dispositivo m\u00f3vil. Para manejar el emulador y su dispositivo m\u00f3vil virtual dispondremos de una serie de teclas de navegaci\u00f3n y de controles que podremos usar a trav\u00e9s del rat\u00f3n o del teclado de nuestro ordenador, que nos permitir\u00e1n generar distintos eventos en nuestro dispositivo virtual para comprobar c\u00f3mo se comporta ante ellos la aplicaci\u00f3n que estamos desarrollando.</p> <p>Con objeto de permitirnos modelar y probar nuestra aplicaci\u00f3n de una manera sencilla, el emulador utiliza las configuraciones pre-dise\u00f1adas en uno o m\u00e1s AVDs (Android Virtual Devices, Dispositivos Virtuales Android), que nos permiten definir caracter\u00edsticas hardware espec\u00edficas del dispositivo m\u00f3vil que queremos emular y sobre el que queremos realizar las pruebas. Podemos crear tantos AVDs como estimemos oportuno.</p> <p> Figura 2 - Gestor de dispositivos virtuales</p> <p>Con la instalaci\u00f3n de Android Studio se nos instala tambi\u00e9n un dispositivo virtual por defecto, que podemos usar para probar nuestras aplicaciones, aunque a trav\u00e9s del AVD Manager podemos crear tantos dispositivos virtuales como creemos oportuno.</p> <p>Cada AVD que definamos puede tener las caracter\u00edsticas de alg\u00fan dispositivo Android real existente en el mercado, o caracter\u00edsticas completamente personalizadas por nosotros.</p> <p>Adem\u00e1s, cuando creemos un AVD debemos indicar la imagen del sistema operativo Android que queremos cargar en el dispositivo virtual. De esta manera, podremos crear dispositivos virtuales con distintas caracter\u00edsticas, como por ejemplo distintos tama\u00f1os de pantalla, y con distintas versiones de del sistema operativo Android, para poder comprobar c\u00f3mo se comportan nuestras aplicaciones.</p> <p>Cuando queramos ejecutar la aplicaci\u00f3n que estemos desarrollando en ese momento, tan solo bastar\u00e1 con tener un dispositivo virtual o real seleccionado en el combo box correspondiente, y pulsar sobre el icono correspondiente en la barra de herramientas de Android Studio.</p> <p> Figura 3 - Ejecuci\u00f3n de la aplicaci\u00f3n en desarrollo</p> <p>Si queremos ejecutar la aplicaci\u00f3n en varios dispositivos a la vez, debemos desplegar la combo box de dispositivos y elegir la opci\u00f3n <code>Select multiple devices...</code>, tras lo que nos aparecer\u00e1 una ventana de selecci\u00f3n de dispositivos, tal y como se muestra en la imagen, donde podemos seleccionar uno o varios:</p> <p> Figura 4 - Selecci\u00f3n de dispositivos para ejecuci\u00f3n</p> <p>El emulador puede ejecutarse como una aplicaci\u00f3n independiente o embebido dentro de Android Studio. Para que esta \u00faltima opci\u00f3n est\u00e9 disponible es necesario que la activemos expl\u00edcitamente a trav\u00e9s de <code>Preferences -&gt; Tools -&gt; Emulator -&gt; Launch in a tool window</code>.</p> <p>En la siguiente imagen se muestra la ventana del emulador embebida dentro de Android Studio:</p> <p> Figura 5 - Emulador embebido en Android Studio</p> <p>Una vez que nuestra aplicaci\u00f3n est\u00e1 ejecut\u00e1ndose en el emulador, puede usar los servicios de la plataforma Android para invocar otras aplicaciones, acceder a la red, ejecutar audio o v\u00eddeo, almacenar y recuperar datos, notificar al usuario y mostrar transformaciones gr\u00e1ficas, estilos y temas. Es decir se trata de un dispositivo Android totalmente funcional. En algunos casos tendremos incluso acceso a la Play store.</p> <p>El emulador tambi\u00e9n incluye distintas funcionalidades para la depuraci\u00f3n, como la consola en la que podemos comprobar el log del kernel, simulaci\u00f3n de interrupciones que se producen sobre nuestra aplicaci\u00f3n, como el hecho de que ha llegado un mensaje SMS o una llamada telef\u00f3nica, e incluso simular efectos de latencia y ca\u00eddas en la red de datos, o movilidad de GPS.</p> <p>Para acceder a dichos controles extendidos tendremos que pulsar sobre los tres puntitos verticales en la barra del emulador de la imagen anterior. Como resultado veremos una ventana de configuraci\u00f3n de herramientas para el emulador como la siguiente, en la que tendremos distintas secciones de controles:</p> <p> Figura 6 - Herramientas del emulador <p>Los desarrolladores de Intel han creado una imagen del sistema Android que se ejecuta de manera nativa en CPUs x86, que es el tipo de procesador que poseen la mayor\u00eda de nuestros equipos de desarrollo. Esto es especialmente importante si tenemos en cuenta que hasta ahora tan solo dispon\u00edamos de im\u00e1genes para sistemas ARM, lo que implicaba un proceso de traducci\u00f3n durante la ejecuci\u00f3n de nuestras aplicaciones en el emulador, ralentiz\u00e1ndose.</p> <p>Normalmente, durante la instalaci\u00f3n de Android Studio, se instala tambi\u00e9n esta herramientas. Si no es as\u00ed, podemos instalarla directamente desde el SDK Manager, accesible desde el men\u00fa Tools -&gt; SDK Manager, y en concreto en la pesta\u00f1a SDK Tools, seleccionado el elemento Intel x86 Emulator Accelerator (HAXM Installer), tal y como se muestra en la siguiente imagen:</p> <p> Figura 7 - Instalar Intel x86 Emulator Accelerator (HAXM) <p>Una vez descargado, comenzar\u00e1 su instalaci\u00f3n desde la carpeta <code>&lt;sdk folder&gt;/sdk/extras/intel/Hardware_Accelerated_Execution_Manager/</code>.</p> <p>Instrucciones de instalaci\u00f3n en Windows</p> <p>https://software.intel.com/en-us/android/articles/installation-instructions-for-intel-hardware-accelerated-execution-manager-windows.</p> <p>Intel ha publicado las im\u00e1genes correspondientes a distintas versiones de Android. Para poder utilizarlas deberemos descargarlas desde el AVD manager integrado en Android Studio, algo que podremos hacer cuando estemos creando un nuevo dispositivo virtual.</p> <p>Para crear un nuevo AVD pulsaremos el bot\u00f3n <code>Create Virtual Device...</code> del AVD Manager, y seleccionaremos el tipo y modelo de dispositivo deseado. Se recomienda seleccionar un dispositivo que disponga de la Google Play, como el que se muestra en la siguiente imagen</p> <p> Figura 8 - Crear nuevo AVD</p> <p>En el siguiente paso de la creaci\u00f3n del AVD seleccionaremos exactamente qu\u00e9 imagen de Android queremos usar en el AVD, permiti\u00e9ndonos, si no la tenemos descargada, descargar la imagen mediante el enlace <code>Download</code>.</p> <p> Figura 9 - Seleccionar imagen para AVD</p>"},{"location":"bloque_i/tema_1/page-1/#ejecucion-en-dispositivo-fisico","title":"Ejecuci\u00f3n en dispositivo f\u00edsico","text":"<p>Aunque podemos usar el emulador proporcionado por el Android SDK para probar y depurar nuestras aplicaciones, siempre ser\u00e1 recomendable realizar nuestras pruebas en distintos dispositivos f\u00edsicos para poder comprobar c\u00f3mo se comporta nuestra aplicaci\u00f3n en realidad. De esta manera podremos analizar su velocidad de ejecuci\u00f3n, su comportamiento sobre distinto hardware, c\u00f3mo reacciona ante diferentes eventos que acontezcan en el dispositivos, etc.</p> <p>De hecho, algunas funcionalidad de nuestras aplicaciones s\u00f3lo podremos probarlas en dispositivos f\u00edsicos, ya que el emulador no dispone de ellas, como por ejemplo el aceler\u00f3metro.</p> <p>Para poder probar nuestras aplicaciones en un dispositivo f\u00edsico debemos cumplir con los siguientes requisitos:</p> <ul> <li>Tener instalado en el equipo de desarrollo el driver correspondiente a nuestro dispositivo f\u00edsico para el sistema operativo del equipo de desarrollo. Este driver es suministrado por el fabricante del dispositivo, normalmente dentro de un pack de software del dispositivo para PC.</li> <li>Habilitar la opci\u00f3n de depuraci\u00f3n en el dispositivo f\u00edsico. Para ello abrir la aplicaci\u00f3n de configuraci\u00f3n en nuestro dispositivo Android llamada \"Ajustes\" y seleccionar el men\u00fa \"Opciones de Desarrollo\", activando la opci\u00f3n \"Depuraci\u00f3n USB\". A partir de la versi\u00f3n Kit Kat de Android el men\u00fa \"Opciones de Desarrollo\" viene deshabilitado por defecto. Para habilitarlo bastar\u00e1 con entrar en el men\u00fa \"Informaci\u00f3n del dispositivo\" y pulsar siete veces sobre el campo \"N\u00famero de Compilaci\u00f3n\".</li> <li>Tener conectado nuestro dispositivo al PC mediante un cable USB.</li> </ul> <p>Tambi\u00e9n tenemos disponible un asistente de conexi\u00f3n, accesible desde Tools &gt; Connection Assistant. Tan s\u00f3lo deberemos seguir las instrucciones de conexi\u00f3n.</p> <p>Drivers USB</p> <p>En la web oficial para desarrolladores Android puede encontrar m\u00e1s informaci\u00f3n sobre los drivers USB y una lista con las p\u00e1ginas de descarga de los drivers de los principales fabricantes (https://developer.android.com/studio/run/oem-usb.php#Drivers).</p> <p>Existen aplicaciones para nuestro equipo de desarrollo que permiten mostrar en \u00e9l la pantalla de nuestro dispositivo f\u00edsico en el que estamos probando la aplicaci\u00f3n que estamos desarrollando, permiti\u00e9ndonos interactuar con \u00e9l. De esta manera no es necesario manipular directamente el dispositivo al realizar las pruebas, adem\u00e1s de poder introducir los datos directamente desde el teclado del equipo de desarrollo. Estas aplicaciones tambi\u00e9n suelen ser utilizadas para realizar demostraciones.</p> <p>Aplicaciones de visualizaci\u00f3n de dispositivos</p> <ul> <li>scrcpy: https://github.com/Genymobile/scrcpy (recomendada)</li> <li>Mobizen: https://www.mobizen.com/</li> <li>Airdroid: http://web.airdroid.com/</li> <li>Vysor: http://www.vysor.io/</li> </ul>"},{"location":"bloque_i/tema_1/page-2/","title":"2 Primera Aplicaci\u00f3n","text":""},{"location":"bloque_i/tema_1/page-2/#proyecto-helloworld","title":"Proyecto HelloWorld","text":"<p>Para estudiar la creaci\u00f3n de nuestra primera aplicaci\u00f3n Android, vamos a desarrollar un proyecto muy b\u00e1sico que simplemente mostrar\u00e1 el mensaje \"Hello world!\" cuando la ejecutemos.</p> <p>Para crear un proyecto haremos uso del asistente proporcionado por Android Studio. El primer paso es abrir la aplicaci\u00f3n Android Studio y pulsar la opci\u00f3n Start a new Android Studio project, tal y como se muestra en la figura</p> <p> Figura 10 - Asistente de creaci\u00f3n de nuevo proyecto</p> <p>Despu\u00e9s seleccionaremos la plantilla Empty Activity dentro de la pesta\u00f1a Phone and Tablet, para indicar que queremos generar una actividad vac\u00eda, tal y como se muestra en la figura</p> <p> Figura 11 - Selecci\u00f3n de plantilla en el asistente</p> <p>Como consecuencia se nos mostrar\u00e1 la pantalla de configuraci\u00f3n del proyecto:</p> <p> Figura 12 - Configuraci\u00f3n del proyecto en el asistente</p> <p>En la pantalla de configuraci\u00f3n del proyecto indicaremos:</p> <ul> <li>El nombre de la aplicaci\u00f3n: Corresponde al nombre que se mostrar\u00e1 para la aplicaci\u00f3n en el caj\u00f3n de aplicaciones del dispositivo cuando \u00e9sta se instale. Podremos cambiarla posteriormente. Por ejemplo <code>HelloWorld</code></li> <li>El nombre del paquete de la aplicaci\u00f3n: Debe ser \u00fanico entre todas la aplicaciones instaladas en el dispositivo. Por este motivo se suele usar como nombre de paquete la URL inversa de la compa\u00f1\u00eda que desarrolla la aplicaci\u00f3n m\u00e1s el nombre de la misma. Por ejemplo: <code>es.iessaladillo.irudev.hellowold</code></li> <li>La carpeta en la que va a generarse el proyecto: Debemos indicar una carpeta vac\u00eda (aunque no exista a\u00fan) en la que se deben crear todo el \u00e1rbol de archivos y carpetas del proyecto.</li> <li>Idioma del c\u00f3digo fuente: Puede ser Java o Kotlin</li> <li>El nivel m\u00ednimo de API con el que debe funcionar la aplicaci\u00f3n: Determina qu\u00e9 dispositivos podr\u00e1n instalar nuestra aplicaci\u00f3n. Por ejemplo <code>API 21: Android 5.0 (Lollipop)</code>.</li> <li>Se recomienda marcar tambi\u00e9n <code>Use androidx.* artifacts</code> para que el asistente use la nueva librer\u00eda de soporte <code>androidx</code>.</li> </ul> <p>Al pulsar el bot\u00f3n <code>Finish</code> Android Studio generar\u00e1 el proyecto para nosotros con una serie de elementos que vamos a ir conociendo a continuaci\u00f3n.</p>"},{"location":"bloque_i/tema_1/page-2/#estructura-de-un-proyecto","title":"Estructura de un proyecto","text":"<p>Cuando creamos un nuevo proyecto en Android Studio se genera autom\u00e1ticamente la estructura b\u00e1sica de archivos y carpetas necesaria para la aplicaci\u00f3n, como vemos en la imagen.</p> <p>Dicha imagen corresponde a la vista de Android Studio conocida como <code>Project</code>. Normalmente la vista habitual es <code>Android</code> que nos simplifica la visi\u00f3n para acceder m\u00e1s r\u00e1pidamente a los elementos.</p> <p> Figura 12 - Estructura de archivos y directorios de un proyecto</p> <p>Un proyecto Android estar\u00e1 compuesto de uno o m\u00e1s m\u00f3dulos.</p> <p>M\u00f3dulo</p> <p>Un m\u00f3dulo es un elemento de nuestro proyecto que puede representar una aplicaci\u00f3n distinta, una versi\u00f3n diferente de una misma aplicaci\u00f3n, o un componente adicional del sistema (aplicaci\u00f3n servidor, librer\u00eda, \u2026).</p> <p>Nuestro proyecto contendr\u00e1 fuera de cualquier m\u00f3dulo un fichero de configuraci\u00f3n de la generaci\u00f3n de la aplicaci\u00f3n, llamado <code>/build.gradle</code>, escrito en el lenguaje Groovy, que ser\u00e1 usado por el generador <code>Gradle</code> a la hora de generar el ejecutable de nuestra aplicaci\u00f3n.</p> <pre><code>buildscript {\nrepositories {\ngoogle()\njcenter()\n}\ndependencies {\nclasspath 'com.android.tools.build:gradle:3.4.2'\n}\n}\nallprojects {\nrepositories {\ngoogle()\njcenter()     }\n}\ntask clean(type: Delete) {\ndelete rootProject.buildDir\n}\n</code></pre> <p>Al crear un proyecto el asistente de Android Studio crea autom\u00e1ticamente un m\u00f3dulo correspondiente a nuestra aplicaci\u00f3n principal, que toma el nombre de <code>app</code>, como vemos en la imagen anterior, y se crea una carpeta para \u00e9l, llamada <code>app</code>.</p> <p>Dentro del m\u00f3dulo <code>app</code> se crea una subcarpeta llamada <code>src</code>, que contendr\u00e1 el c\u00f3digo fuente del m\u00f3dulo correspondiente.</p> <p>Dentro de la carpeta <code>src</code> se crean tres subcarpetas que organizan el distinto c\u00f3digo fuente:</p> <ul> <li><code>main</code>: Contendr\u00e1 el c\u00f3digo fuente de desarrollo del m\u00f3dulo. Por ahora nos centraremos en esta carpeta.</li> <li><code>test</code>: Contendr\u00e1 el c\u00f3digo fuente correspondiente a los tests unitarios de las distintas clases (por ejemplo, JUnit).</li> <li><code>androidTest</code>: Contendr\u00e1 el c\u00f3digo fuente correspondiente a los tests instrumentales que se ejecutan sobre un dispositivo.</li> </ul> <p>Dentro de la carpeta <code>app/src/main</code> se crean una serie de sub-carpetas muy importantes:</p> <ul> <li><code>app/src/main/java</code>: Contiene el c\u00f3digo fuente de la aplicaci\u00f3n, incluyendo el c\u00f3digo de las actividades (pantallas de la aplicaci\u00f3n) y dem\u00e1s componentes, clases auxiliares, modelos de datos, etc. El asistente de creaci\u00f3n de proyecto de Android Studio crear\u00e1 de manera autom\u00e1tica el c\u00f3digo b\u00e1sico de la actividad principal de la aplicaci\u00f3n dentro del paquete java que hayamos especificado en el asistente, nombr\u00e1ndola <code>MainActivity</code>.</li> <li><code>app/src/main/res/</code>: Contiene todos los archivos de recursos que va a utilizar el proyecto. Un archivo de recurso puede ser una imagen, un v\u00eddeo, un fichero con constantes de cadenas de texto, una especificaci\u00f3n XML para un men\u00fa, etc.</li> </ul> <p>Los diferentes archivos de recursos de organizan en subcarpetas de la carpeta <code>res</code>, atendiendo al tipo de recurso del que se trate. Entre las subcarpetas posibles destacamos las siguientes:</p> <ul> <li><code>drawable</code>: Contiene las im\u00e1genes y archivos de gr\u00e1ficos de la aplicaci\u00f3n.</li> <li><code>layout</code>: Contiene los ficheros de definici\u00f3n del dise\u00f1o (layout) de las diferentes pantallas de la interfaz gr\u00e1fica.</li> <li><code>mipmap</code>: Contiene el archivo gr\u00e1fico correspondiente al icono de la aplicaci\u00f3n.</li> <li><code>values</code>: Contiene los archivos de recursos en los que se definen constantes que son usadas como valores de propiedades de elementos de la aplicaci\u00f3n. Dispondremos de distintos ficheros dependiendo del tipo de constantes que contengan. Por ejemplo, las constantes de cadenas de caracteres se almacenar\u00e1n en el archivo <code>strings.xml</code>, los estilos visuales de los elementos en <code>styles.xml</code>, las constantes de colores en <code>colors.xml</code>, etc.</li> </ul> <p>Como vemos, tambi\u00e9n se crean subcarpetas de recursos espec\u00edficos para casos concretos, que usan unos determinados sufijos, como por ejemplo <code>res/drawable-v24</code> para lo archivos gr\u00e1ficos para la versi\u00f3n 24 de la API de Android, o <code>res/mipmap-hdpi</code> para los iconos de aplicaci\u00f3n el alta resoluci\u00f3n, etc. Estudiaremos los distintos sufijos para las carpetas de recursos m\u00e1s adelante.</p> <p>Adem\u00e1s, dentro de la carpeta <code>app/src/main</code> se crea el archivo <code>AndroidManifest.xml</code>, conocido como manifiesto de la aplicaci\u00f3n, que corresponde al fichero de configuraci\u00f3n principal de nuestra aplicaci\u00f3n.</p> <p>Manifiesto</p> <p>El archivo AndroidManifest.xml corresponde a un fichero XML que contiene la definici\u00f3n de los aspectos principales de la aplicaci\u00f3n, como por ejemplo los datos relativos a su identificaci\u00f3n, como el paquete (<code>package</code>), el nombre con el que se mostrar\u00e1 en el launcher (<code>label</code>) o el icono con el que se mostrar\u00e1 en el launcher (<code>icon</code>), as\u00ed como los componentes que la forman (actividades, servicios, etc.), o los permisos necesarios para su ejecuci\u00f3n.</p> <p>M\u00e1s adelante hablaremos con detenimiento del manifiesto. Por ahora vemos el manifiesto de nuestro proyecto:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest package=\"es.iessaladillo.pedrojoya.helloworld\"\nxmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n&lt;application\nandroid:allowBackup=\"true\"\nandroid:icon=\"@mipmap/ic_launcher\"\nandroid:label=\"@string/app_name\"\nandroid:roundIcon=\"@mipmap/ic_launcher_round\"\nandroid:supportsRtl=\"true\"\nandroid:theme=\"@style/AppTheme\"&gt;\n&lt;activity android:name=\".MainActivity\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"android.intent.action.MAIN\"/&gt;\n&lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;\n&lt;/intent-filter&gt;\n&lt;/activity&gt;\n&lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <p>En el manifiesto anterior, se indica que la aplicaci\u00f3n tiene un \u00fanico componente, una actividad representada por la clase <code>MainActivity</code>, que se encuentra en el paquete base de la aplicaci\u00f3n, y que dicha actividad es la que debe ser ejecutada inicialmente cuando se lance la aplicaci\u00f3n desde el launcher, gracias a la <code>&lt;action&gt;</code> y <code>&lt;category&gt;</code> indicadas.</p> <p>Finalmente, nuestro m\u00f3dulo <code>app</code> contendr\u00e1 el archivo <code>app/build.gradle</code>, que es un fichero de configuraci\u00f3n de la generaci\u00f3n (compilaci\u00f3n) de dicho m\u00f3dulo. El archivo, escrito en el lenguaje de programaci\u00f3n Groovy, es le\u00eddo por el software de generaci\u00f3n Gradle a la hora de generar la parte del ejecutable de nuestra aplicaci\u00f3n correspondiente a dicho m\u00f3dulo. El archivo contendr\u00e1 informaci\u00f3n necesaria para la compilaci\u00f3n del m\u00f3dulo, como por ejemplo:</p> <ul> <li><code>applicationId</code>: id de la aplicaci\u00f3n. Cadena que representa a la aplicaci\u00f3n y que debe ser \u00fanica en el dispositivo.</li> <li><code>compileSdkVersion</code>: versi\u00f3n del SDK de Android utilizada para compilar. Normalmente corresponder\u00e1 a la \u00faltima versi\u00f3n de la API disponible.</li> <li><code>minSdkVersion</code>: versi\u00f3n m\u00ednima de Android que soportar\u00e1 la aplicaci\u00f3n. Los dispositivos con versi\u00f3n inferior no podr\u00e1n instalar la aplicaci\u00f3n. Normalmente se intenta que sea lo m\u00e1s baja posible, sin que ello suponga una carga de trabajo de compatibilidad demasiado grande para el desarrollador</li> <li><code>targetSdkVersion</code>: versi\u00f3n m\u00e1xima del SDK de Android con la que se ha probado la aplicaci\u00f3n. Normalmente corresponder\u00e1 a la \u00faltima versi\u00f3n de la API disponible.</li> <li><code>versionCode</code>: versi\u00f3n num\u00e9rica de la aplicaci\u00f3n</li> <li><code>versionName</code>: descripci\u00f3n textual de la versi\u00f3n de la aplicaci\u00f3n</li> <li><code>dependencies</code>: dependencias a librer\u00edas externas utilizadas por el m\u00f3dulo</li> </ul> <pre><code>apply plugin: 'com.android.application'\nandroid {\ncompileSdkVersion 28\nbuildToolsVersion \"29.0.0\"\ndefaultConfig {\napplicationId \"es.iessaladillo.pedrojoya.helloworld\"\nminSdkVersion 21\ntargetSdkVersion 28\nversionCode 1\nversionName \"1.0\"\ntestInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n}\nbuildTypes {\nrelease {\nminifyEnabled false\nproguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n}\n}\n}\ndependencies {\nimplementation fileTree(dir: 'libs', include: ['*.jar'])\nimplementation 'androidx.appcompat:appcompat:1.1.0'\n}\n</code></pre> <p>Android Studio posee una perspectiva resumida de nuestro proyecto, que nos omite aquellos archivos con los que probablemente no vayamos a interactuar. Dicha vista se conoce como perspectiva Android, y es la perspectiva recomendada, por facilitarnos bastante el acceso a los archivos con los que realmente vamos a trabajar.</p> <p> Figura 13 - Perspectiva Android</p>"},{"location":"bloque_i/tema_1/page-2/#activity","title":"Activity","text":"<p>Las aplicaciones Android se construyen mediante bloques esenciales conocidos como componentes, cada uno de los cuales existe como una entidad propia y desempe\u00f1a un papel espec\u00edfico; cada componente es una pieza \u00fanica que ayuda a definir el comportamiento general de la aplicaci\u00f3n. Es importante mencionar que algunos de estos elementos son el punto de entrada para que los usuarios interact\u00faen con la aplicaci\u00f3n y en muchos casos veremos que unos componentes dependen de otros.</p> <p>Hay cuatro tipos de componentes en una aplicaci\u00f3n Android: activity (actividad), service (servicio), broadcast receiver (receptor de mensajes de multidifusi\u00f3n) y content provider (proveedor de contenidos). Nosotros empezaremos estudiando las actividades.</p> <p>Activity</p> <p>Una activity (actividad) es un tipo de componente encargado de mostrar una pantalla con la que el usuario puede interactuar.</p> <p>El sistema proporciona a cada actividad una ventana en la que poder dibujar su interfaz de usuario. Normalmente, dicha ventana ocupa toda la pantalla, aunque su tama\u00f1o puede ser menor. Por tanto, se puede pensar en una actividad como el an\u00e1logo de una ventana en una aplicaci\u00f3n de escritorio. En las actividades recae la responsabilidad de presentar los elementos visuales y reaccionar a la interacci\u00f3n del usuario.</p> <p>Una aplicaci\u00f3n generalmente se compone de varias actividades que se llaman entre s\u00ed. Normalmente una de dichas actividades se designa como la actividad principal, siendo \u00e9sta la que se inicia cuando la aplicaci\u00f3n comienza su ejecuci\u00f3n. Una actividad puede iniciar la ejecuci\u00f3n de otra actividad con el fin de mostrar una nueva pantalla con la que el usuario pueda interactuar.</p> <p>Warning</p> <p>Todos los componentes de una aplicaci\u00f3n deben estar registrados (declarados) en el manifiesto de la misma, es decir en el archivo <code>AndroidManifest.xml</code>, o de lo contrario no podr\u00e1n ser usados.</p> <p>As\u00ed, en el siguiente manifiesto se declara que la aplicaci\u00f3n dispone de una actividad, representada por la clase <code>MainActivity</code> situada en el paquete base de la aplicaci\u00f3n (de ah\u00ed el <code>.MainActivity</code>. Adem\u00e1s, mediante la etiqueta <code>&lt;intent-filter&gt;</code> se indica que dicha actividad ser\u00e1 la que ser\u00e1 lanzada autom\u00e1ticamente cuando el usuario pulse sobre el icono de la aplicaci\u00f3n en el launcher (caj\u00f3n de aplicaciones):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest package=\"es.iessaladillo.pedrojoya.helloworld\"\nxmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n&lt;application\nandroid:allowBackup=\"true\"\nandroid:icon=\"@mipmap/ic_launcher\"\nandroid:label=\"@string/app_name\"\nandroid:roundIcon=\"@mipmap/ic_launcher_round\"\nandroid:supportsRtl=\"true\"\nandroid:theme=\"@style/AppTheme\"&gt;\n&lt;activity android:name=\".MainActivity\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"android.intent.action.MAIN\"/&gt;\n&lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;\n&lt;/intent-filter&gt;\n&lt;/activity&gt;\n&lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <p>Para crear una actividad deberemos desarrollar una clase que extienda de la clase <code>Activity</code> y sobrescribir los m\u00e9todos adecuados para personalizar su aspecto y funcionamiento.</p> <p>Hoy en d\u00eda normalmente haremos que nuestra actividad extienda de la clase <code>AppCompatActivity</code>, proporcionada por la librer\u00eda de soporte Android Support Library, que a su vez hereda de <code>Activity</code>.</p> <p> Figura 14 - Diagrama de clases de AppCompatActivity</p> <p>Uno de los aspectos que deberemos indicar es la interfaz de usuario que debe mostrar la actividad. Dicha interfaz estar\u00e1 representada por un \u00e1rbol de elementos conocidos como vistas (views). El \u00e1rbol contendr\u00e1 una vista ra\u00edz que a su vez podr\u00e1 contener otras vistas en su interior y \u00e9stas otras en su interior y as\u00ed sucesivamente.</p> <p>En el siguiente ejemplo vemos la definici\u00f3n de una actividad llamada <code>MainActivity</code> personalizada para que muestre como interfaz de usuario el \u00e1rbol de vistas correspondiente a la especificaci\u00f3n XML declarada en el archivo <code>res/layout/activity_main.xml</code>.</p> <pre><code>package es.iessaladillo.pedrojoya.helloworld;\nimport android.os.Bundle;\nimport androidx.appcompat.app.AppCompatActivity;\npublic class MainActivity extends AppCompatActivity {\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nsetContentView(R.layout.activity_main);\n}\n}\n</code></pre> <p>Como vemos en el c\u00f3digo anterior, sobrescribimos el m\u00e9todo <code>onCreate()</code> de la clase <code>AppCompatActivity</code>. Este m\u00e9todo es lo que se conoce tradicionalmente como un hook method, esto es, un m\u00e9todo que es llamado internamente por el framework en alg\u00fan momento de la creaci\u00f3n de la actividad para que nosotros podamos personalizarla. En concreto el m\u00e9todo <code>onCreate()</code> es llamado por el sistema justo despu\u00e9s de crear el objeto actividad, pero antes de que sea mostrada por pantalla (hablaremos m\u00e1s sobre esto en el apartado sobre el ciclo de vida de las actividades).</p> <p>Dentro del m\u00e9todo <code>onCreate()</code> llamamos al m\u00e9todo <code>setContentView(layoutResId)</code>, heredado de <code>Activity</code>, que recibe el resId de la especificaci\u00f3n XML de layout que representa la interfaz de usuario. Este m\u00e9todo es el encargado de realizar un proceso de generaci\u00f3n del \u00e1rbol de vistas de la interfaz a partir de lo indicado en la especificaci\u00f3n, a lo que se conoce como inflado (inflate) y de establecer el elemento ra\u00edz del \u00e1rbol resultante como vista principal de la actividad.</p> <p>El m\u00e9todo <code>setContentView(view)</code> est\u00e1 sobrecargado para recibir directamente la vista correspondiente al elemento ra\u00edz del \u00e1rbol de vistas de la interfaz de usuario, en cuyo caso deberemos haber inflado previamente la especificaci\u00f3n XML obteniendo dicha vista.</p>"},{"location":"bloque_i/tema_1/page-2/#especificacion-xml-de-layout","title":"Especificaci\u00f3n XML de layout","text":"<p>Como hemos visto en el c\u00f3digo anterior, debemos indicar a la actividad la vista que debe mostrar como interfaz de usuario. Una primera opci\u00f3n ser\u00eda usar c\u00f3digo Java o Kotlin para crear en tiempo de ejecuci\u00f3n instancias de las clases correspondientes a los elementos de la interfaz (vistas) y usarlos desde c\u00f3digo. Sin embargo esta opci\u00f3n resultar\u00eda enormemente tediosa en cuanto la interfaz de usuario fuera un poco compleja.</p> <p>Para facilitarnos la tarea de la definici\u00f3n e la interfaz de usuario de una actividad, Android nos permite definir lo que se conoce como layouts.</p> <p>Layout</p> <p>Un layout (dise\u00f1o, disposici\u00f3n de elementos) es un archivo XML en el que especificamos el \u00e1rbol de vistas que debe contener nuestra interfaz de usuario juntos con las propiedades de cada una de ellas.</p> <p>Este mecanismo tiene la ventaja de que permite separar, por un lado, el dise\u00f1o de la interfaz (la capa de presentaci\u00f3n) y, por otro, el c\u00f3digo correspondiente a la implementaci\u00f3n de la l\u00f3gica de funcionamiento de la actividad, a diferencia del caso en que el dise\u00f1o de la interfaz se realizara mediante c\u00f3digo de programaci\u00f3n, en cuyo caso estar\u00edan mezclados. De hecho, los archivos de layout codificados en XML son considerados recursos y, como tales, se ubicar\u00e1n dentro de la carpeta <code>res</code> de nuestro proyecto, en concreto en la subcarpeta <code>res/layout</code>.</p> <p>El hecho de que la descripci\u00f3n de la interfaz de usuario sea externa al propio c\u00f3digo de la aplicaci\u00f3n, implica que se pueda modificar o adaptar la interfaz sin tener que necesariamente modificar y recompilar el c\u00f3digo fuente de nuestra aplicaci\u00f3n. Por ejemplo, podremos crear archivos XML de layout para diferentes orientaciones o para diferentes tama\u00f1os de pantalla. Por otro lado, la especificaci\u00f3n de nuestra interfaz en XML permite visualizar su estructura de una manera mucho m\u00e1s sencilla, lo que redundar\u00e1 en una mayor facilidad a la hora de depurar posibles problemas.</p> <p>Un archivo de layout en XML es una especificaci\u00f3n jer\u00e1rquica con forma de \u00e1rbol de etiquetas XML en el que se declaran los componentes de la interfaz, algunos de los cuales act\u00faan como contenedores de otros componentes, existiendo siempre una vista (view) que act\u00faa como ra\u00edz del \u00e1rbol.</p> <p>Warning</p> <p>La especificaci\u00f3n de layout debe contener un \u00fanico elemento ra\u00edz, al tratarse de un \u00e1rbol.</p> <p>Los atributos de cada etiqueta en XML se llaman propiedades y describen c\u00f3mo debe mostrarse y c\u00f3mo debe comportarse el componente de la interfaz correspondiente a dicha etiqueta. Cada tipo de elemento tiene su propio conjunto de propiedades, algunas de las cuales ser\u00e1n obligatorias (tendremos que darles valor forzosamente) y otras optativas. Algunas propiedades existir\u00e1n solamente para un tipo de elemento (vista) concreto y otras estar\u00e1n disponibles para distintos tipos de elementos (vistas).</p> <p>En el siguiente ejemplo se define un elemento del tipo <code>TextView</code> que mostrar\u00e1 el texto <code>Hello World!</code> en negrita:</p> <pre><code>&lt;TextView\nandroid:id=\"@+id/lblHello\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"Hello World!\" /&gt;\n</code></pre> <p>En general, los t\u00e9rminos que incluiremos en la declaraci\u00f3n en XML de los elementos de la interfaz de usuario son iguales o parecidos a los nombres de las clases y de los m\u00e9todos correspondientes, donde los nombres de las etiquetas XML corresponden a los nombres de las clases y los nombres de los atributos XML corresponden con m\u00e9todos get y set de las clases (tambi\u00e9n llamados getters y setters). De hecho, la correspondencia es tal que a menudo podemos adivinar qu\u00e9 atributo XML corresponde a qu\u00e9 m\u00e9todo de la clase y viceversa. Por ejemplo, la etiqueta <code>&lt;TextView&gt;</code> corresponde a la clase <code>TextView</code> y su atributo XML <code>text</code> corresponde al par de m\u00e9todos <code>getText()</code> y <code>setText()</code>. En algunos casos, sin embargo hay peque\u00f1as diferencias en los nombres.</p> <p>Veamos un ejemplo de especificaci\u00f3n de layout definida en el archivo <code>res/layout/activity_main.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/llRoot\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:orientation=\"vertical\" &gt;\n&lt;TextView\nandroid:id=\"@+id/lblHello\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"Hello World!\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Nuestra especificaci\u00f3n de layout no deja de ser un fichero XML, lo que no es lo m\u00e1s conveniente para trabajar desde Java o Kotlin, por lo que en alg\u00fan momento deber\u00e1 generar el \u00e1rbol de objetos vista a partir de dicha especificaci\u00f3n XML. Por ejemplo, seg\u00fan la especificaci\u00f3n anterior, se deber\u00e1 crear un objeto de la clase <code>LinearLayout</code> que contenga en su interior un objeto de la clase <code>TextView</code>.</p> <p>Inflater</p> <p>A la acci\u00f3n de obtener un \u00e1rbol de objetos de programaci\u00f3n a partir de una especificaci\u00f3n XML se le conoce como inflar (inflate), y es realizado por un objeto especializada en ello, conocida como inflador (inflater).</p> <p>En el caso de la interfaz de usuario, la generaci\u00f3n del \u00e1rbol de vistas a partir de la especificaci\u00f3n XML de layout, se realiza a trav\u00e9s de un objeto de la clase <code>LayoutInflater</code>.</p> <p> Figura 15 - LayoutInflater</p> <p>As\u00ed, podr\u00edamos realizar el inflado obteniendo un objeto de la clase <code>LayoutInflater</code> y llamando a su m\u00e9todo <code>inflate()</code>, la clase <code>Activity</code> nos proporciona una manera de hacerlo directamente, a trav\u00e9s de su m\u00e9todo <code>setContentView(resId)</code>, que recibe el <code>resId</code> del layout que queremos que sea inflado, de manera que la vista ra\u00edz resultante del inflado sea establecida como interfaz de usuario de la actividad.</p>"},{"location":"bloque_i/tema_1/page-3/","title":"3 View","text":""},{"location":"bloque_i/tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Los elementos de los que est\u00e1n compuestos los layouts se denominan vistas (views). Una vista es el bloque b\u00e1sico de construcci\u00f3n de los componentes de la interfaz de usuario.</p> <p>View</p> <p>Una vista (view) es un rect\u00e1ngulo en la pantalla que es capaz de dibujarse a s\u00ed mismo y de manejar eventos producido en dicho rect\u00e1ngulo.</p> <p>A partir de la clase <code>View</code> podemos implementar cualquier componente que aparezca en pantalla y que interact\u00fae con el usuario. Todas las clases que representen objetos de la interfaz de usuario heredar\u00e1n directa o indirectamente de la clase <code>View</code>.</p> <p>Las vistas se pueden clasificar en dos grandes tipos: las que pueden contener otras vistas en su interior, que se conocen como ViewGroups , y, por otra parte, aquellas que no pueden contener otras vistas, a las que se conoce tradicionalmente como controles (widgets).</p> <p>ViewGroup</p> <p>Un ViewGroup (grupo de vistas) es un subtipo de View, que puede contener en su interior otras View, y, por consiguiente, otros ViewGroup.</p> <p>La clase <code>ViewGroup</code> contiene la funcionalidad necesaria para que la vista act\u00fae como contenedor y, por tanto, sea capaz de contener otras vistas. Un <code>ViewGroup</code> puede contener en su interior, no solo varias <code>View</code> hijas, sino que tambi\u00e9n puede contener otros <code>ViewGroup</code> hijos, dado que un <code>ViewGroup</code> es tambi\u00e9n una <code>View</code>, al heredar de dicha clase, y \u00e9stos a su vez pueden contener otras <code>View</code>y <code>ViewGroup</code>. Como consecuencia, podremos crear una estructura jer\u00e1rquica en forma de \u00e1rbol de vistas, con un <code>ViewGroup</code> como vista ra\u00edz.</p> <p>Android define distintos subtipos de ViewGroup con caracter\u00edsticas distintas, representados por clases que heredan directa o indirectamente de la clase <code>ViewGroup</code>, como <code>LinearLayout</code>, <code>FrameLayout</code>, <code>ConstraintLayout</code>, etc., y que estudiaremos con detenimiento m\u00e1s adelante.</p> <p>Por otra parte, los controles son elementos visuales que descienden directamente o indirectamente de la clase <code>View</code>, pero no de <code>ViewGroup</code>, por lo que no pueden contener otras vistas. Su cometido es mostrar informaci\u00f3n al usuario y permitir al usuario interactuar con la aplicaci\u00f3n.</p>"},{"location":"bloque_i/tema_1/page-3/#propiedades-metodos-y-atributos-xml-principales-de-view","title":"Propiedades, m\u00e9todos y atributos XML principales de View","text":"<p>Como hemos visto, tanto contenedores como controles extienden de la clase <code>View</code>, por lo que los atributos y m\u00e9todos definidos en dicha clase son heredados por todas las vistas que utilizaremos en nuestra interfaz de usuario.</p> <p>Para la mayor\u00eda de atributos de nuestras vistas existe un atributo XML para poder establecer su valor desde una especificaci\u00f3n XML. Normalmente, el nombre del atributo XML es el mismo que el nombre del atributo. Por ejemplo, para el atributo que es establecido mediante el m\u00e9todo <code>setVisibility()</code>, disponemos de un atributo XML <code>android:visibility</code>.</p> <p>Sin embargo, hay ocasiones en las que para un determinado setter no existe un atributo XML, y otras veces en las que para un determinado atributo XML no existe un setter con exactamente el mismo nombre. Por ejemplo, para la clase <code>View</code> existe un atributo XML <code>android:padding</code> que permite establecer de una vez el padding de los cuatro lados de la vista, y en realidad no existe un m\u00e9todo <code>setPadding(valor)</code>, sino que el m\u00e9todo tiene la firma <code>setPadding(left, top, right, bottom)</code>.</p> <p>Normalmente, a cada m\u00e9todo setter le corresponde un m\u00e9todo getter, pero no es obligatorio que as\u00ed sea.</p> <p>Veamos los atributos XML y los m\u00e9todos principales de la clase <code>View</code>:</p> <p> Figura 16 - Atributos XML y m\u00e9todos de la clase View</p> <p>Estudiemos sus atributos XML y su relaci\u00f3n con los setters:</p> <ul> <li><code>android:id</code>: N\u00famero identificador de la vista. Ser\u00e1 utilizado posteriormente para obtener una referencia a dicho objeto.</li> <li><code>android:background</code>: Fondo de la vista. Tenemos disponible tambi\u00e9n el m\u00e9todo<code>setBackgroundResource(drawableResId)</code> para establecer como fundo un recurso <code>Drawable</code>, y el m\u00e9todo <code>setBackgroundColor(color: Int)</code></li> <li><code>android:padding</code>: Relleno de los cuatro lados. El relleno es el espacio existente entre el borde imaginario de la vista y su contenido. Tenemos las propiedades <code>android:paddingBottom</code> (inferior), <code>android:paddingLeft</code> (izquierdo), <code>android:paddingRight</code> (derecho) y <code>android:paddingTop</code> (superior) para indicar el relleno espec\u00edfico de un lado concreto.</li> <li><code>android:visibility</code>: Visibilidad de la vista. Puede ser <code>visible</code> (visible), <code>invisible</code> (no se muestra pero se tiene en cuenta su espacio en la construcci\u00f3n del layout) o <code>gone</code> (no se muestra y no se tiene en cuenta su espacio en la construcci\u00f3n del layout, como si no hubiera sido a\u00f1adido al layout).</li> <li><code>android:enabled</code>: Estado de disponibilidad de la vista (habilitado / deshabilitado). Recibe un valor booleano.</li> <li><code>android:focusable</code>: Indica si la vista puede obtener o no el foco.</li> <li><code>android:tag</code>: Propiedad comod\u00edn para poder almacenar un objeto cualquiera dentro de la vista.</li> </ul> <p>Sugerencia</p> <p>Se recomienda que todas las vistas de nuestra interfaz de usuario tengan un id. El motivo lo explicaremos m\u00e1s adelante cuando hablemos de los cambios de configuraci\u00f3n.</p>"},{"location":"bloque_i/tema_1/page-3/#atributos-especificos-para-el-editor-visual-de-layouts","title":"Atributos espec\u00edficos para el editor visual de layouts","text":"<p>Android Studio proporciona una serie de atributos XML definidos en el namespace <code>tools</code> que ayudan al editor gr\u00e1fico en la representaci\u00f3n de los layouts. Estos atributos son eliminados cuando se genera la aplicaci\u00f3n y no tienen efecto sobre la funcionalidad de la misma ni sobre su tama\u00f1o, pero son \u00fatiles a lo hora de visualizar nuestros layouts mientras los estamos dise\u00f1ando.</p> <p>Para poder usar estos atributos es necesario que el elemento ra\u00edz de nuestro layout incluya la definici\u00f3n del namespace correspondiente. Por ejemplo, en el archivo <code>res/layout/main_activity.xml</code> puede contener:</p> <pre><code>&lt;LinearLayout\n...\nxmlns:tools=\"http://schemas.android.com/tools\"\ntools:context=\".MainActivity\"&gt;\n&lt;!-- ... --&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Entre estos atributos se encuentra <code>tools:context</code>, que se aplica al elemento ra\u00edz de un layout para indicar con qu\u00e9 actividad est\u00e1 asociado dicho layout. Esta informaci\u00f3n le ayuda al IDE a renderizar la actividad en el editor visual de layouts.</p> <p>En relaci\u00f3n a las vistas, tenemos el atributo <code>tools:visibility</code>: Se aplica a cualquier vista para indicar el estado de visibilidad de la vista a la hora de ser visualizado en el editor, independientemente del valor especificado para la propiedad <code>android:visibility</code>.</p>"},{"location":"bloque_i/tema_1/page-3/#propiedades-principales-de-viewgroup","title":"Propiedades principales de ViewGroup","text":"<p>Como hemos comentado, un <code>ViewGroup</code> es un tipo especial de vista (hereda de <code>View</code>) que puede contener otras vistas, llamadas vistas hijas. La clase <code>ViewGroup</code> es la clase base para todas las clases que representan distintos tipos de contenedores, como <code>FrameLayout</code>, <code>LinearLayout</code>, <code>RelativeLayout</code>, etc. Hablaremos detenidamente de ellos m\u00e1s adelante.</p> <p> Figura 16 - Atributos XML y m\u00e9todos de la clase View</p> <p> Figura 17 - Jerarqu\u00eda de clases de ViewGroup</p> <p>Dentro de la clase <code>ViewGroup</code> se define tambi\u00e9n la clase <code>ViewGroup.LayoutParams</code> que sirve de clase base para los par\u00e1metros espec\u00edficos que tendr\u00e1n los distintos tipos de contenedores y cuyas vistas hijas deber\u00e1n obligatoriamente usar para especificar su posicionamiento dentro de su contenedor padre.</p> <p>Las propiedades principales de <code>ViewGroup.LayoutParams</code> son:</p> <ul> <li><code>android:layout_height</code>: Para especificar la altura de la vista hija.</li> <li><code>android:layout_width</code>: Para especificar la anchura de la vista hija.</li> </ul> <p>Para asignar valor a estas propiedades podemos especificar una cantidad fija, pero lo habitual ser\u00e1 usar alguna de las siguientes constantes que tenemos definidas:</p> <ul> <li><code>match_parent</code>: La vista debe ser tan grande como su padre (menos el relleno).</li> <li><code>wrap_content</code>: La vista debe ser lo suficientemente grande como para envolver su contenido (adem\u00e1s del relleno).</li> </ul> <p>Por ejemplo, la siguiente especificaci\u00f3n XML de layout define un <code>LinearLayout</code>, que es una subclase de <code>ViewGroup</code>, que estudiaremos con detenimiento m\u00e1s adelante, que contiene un \u00fanico hijo consistente en una vista (control, widget) del tipo <code>TextView</code>. Eel <code>TextView</code> est\u00e1 obligado a especificar su anchura y altura mediante los atributos descritos anteriormente:</p> <pre><code>&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/llRoot\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:orientation=\"vertical\" &gt;\n&lt;TextView\nandroid:id=\"@+id/lblHello\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"Hello World!\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p> Figura 18 - Atributos XML de LayoutParams y MarginLayoutParams</p> <p>Por su parte, la clase <code>ViewGroup.MarginLayoutParams</code>, que hereda de <code>ViewGroup.LayoutParams</code> incluye las propiedades relacionadas con el margen, que son <code>android:layout_marginBottom</code> (margen inferior), <code>android:layout_marginLeft</code> (margen izquierdo), <code>android:layout_marginRight</code> (margen derecho) y <code>android:layout_marginTop</code> (margen superior). Gracias a estas propiedades podemos establecer un margen entre nuestra vista y las vistas que la rodean.</p> <pre><code>&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/llRoot\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:orientation=\"vertical\" &gt;\n&lt;TextView\nandroid:id=\"@+id/lblHello\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:layout_margin=\"16dp\"\nandroid:text=\"Hello World!\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Modificaremos el archivo <code>res/layout/activity_main</code> para que contenga la especificaci\u00f3n anterior.</p>"},{"location":"bloque_i/tema_1/page-4/","title":"4 Recursos y la Clase R","text":""},{"location":"bloque_i/tema_1/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>El dise\u00f1o de una aplicaci\u00f3n Android incorpora muchos elementos que no cambian a lo largo de su vida, como im\u00e1genes, constantes de cadena, etc. Estos elementos reciben el nombre de recursos. Cuando desarrollamos aplicaciones en Android debemos siempre tratar de mantener la separaci\u00f3n entre, por un lado, el c\u00f3digo de la aplicaci\u00f3n, y por otro lado, los recursos que utiliza, porque esto nos va a permitir proporcionar recursos alternativos para las distintas configuraciones de dispositivos, como por ejemplo diferentes idiomas o tama\u00f1os de pantalla, lo que es especialmente relevante dada la variedad de dispositivos Android existentes en el mercado.</p> <p>Los recursos de un proyecto deben almacenarse en la carpeta <code>src/main/res/</code> del m\u00f3dulo correspondiente, y ser\u00e1n empaquetados en el fichero <code>.apk</code> cuando generemos el instalable de nuestra aplicaci\u00f3n. Como vimos cuando hablamos de la estructura de un proyecto Android, los ficheros de recursos deben estar organizados en una serie de subcarpetas atendiendo al tipo de recurso del que se trate. Por ejemplo: en la carpeta <code>src/main/res/layout/</code> se colocar\u00e1n los recursos por defecto correspondientes a especificaciones XML de layouts, en <code>src/main/res/menu/</code> los recursos por defecto correspondientes a especificaciones XML de men\u00fas, etc.</p> <p>Para referenciar a estos recursos desde c\u00f3digo XML utilizaremos la siguiente sintaxis:</p> <p><code>@[paquete:]tipo_recurso/nombre_recurso_sin_extensi\u00f3n</code>. Por ejemplo:</p> <ul> <li>Archivo de layout <code>activity_main.xml</code> almacenado en la carpeta <code>res/layout</code>: usaremos <code>@layout/activity_main</code>.</li> <li>Identificador <code>txtHello</code>: usaremos <code>@id/txtHello</code> o <code>@+id/txtHello</code> si queremos que se cree el id si no existe.</li> <li>Recurso de constante de cadena de caracteres con nombre <code>hello</code>: usaremos <code>@string/hello</code></li> <li>Archivo de imagen <code>ic_launcher.png</code> almacenada en la carpeta <code>res/drawable</code>: usaremos <code>@drawable/ic_launcher</code></li> </ul> <p>El empleo del nombre de paquete es opcional, tanto en el acceso desde c\u00f3digo Java como desde c\u00f3digo XML, ya que no es necesario usarlo cuando el recurso se encuentre en el mismo paquete en el que se encuentre el c\u00f3digo desde el que se quiere acceder.</p> <p>Si, por el contrario, lo que queremos es referenciar dichos recursos desde c\u00f3digo Java o Kotlin, el entorno de desarrollo y el framework nos facilita mucho la tarea. As\u00ed, el sistema identificar\u00e1 cada recurso con un valor entero conocido como <code>resId</code> que podremos usar para hacer referencia a \u00e9l.</p> <p>resId</p> <p>Un resId (resource id, identificador de recurso) es un valor entero que el sistema asigna autom\u00e1ticamente a un recurso para que podamos referenciarlo tanto desde c\u00f3digo XML como desde c\u00f3digo Java o Kotlin.</p> <p>De hecho, muchos m\u00e9todos del framework que reciben recursos como par\u00e1metro est\u00e1n dise\u00f1ados para que reciban su <code>resId</code>. Por ejemplo, el m\u00e9todo <code>setContentView(layoutResId)</code> de la clase <code>AppCompatActivity</code> est\u00e1 dise\u00f1ado para que reciba un entero correspondiente al <code>resId</code> del recurso de especificaci\u00f3n XML de layout que se quiere establecer como interfaz de usuario de la actividad.</p> <p>Sin embargo, ello nos obligar\u00eda a recordar qu\u00e9 valor entero corresponde a cada recurso, lo que realmente parece imposible. Para solucionar este problema, cada vez que se compila nuestra aplicaci\u00f3n o cada vez que a\u00f1adimos, modificamos o eliminar un recurso, se autogenerar\u00e1 una clase Java llamada <code>R</code>.</p> <p>La clase R</p> <p>La clase <code>R</code> es una clase Java generada autom\u00e1ticamente por el entorno de desarrollo cada vez que agregamos, modificamos o eliminamos un recuso de nuestro proyecto. Dicha clase contendr\u00e1 una constante para cada recurso de nuestro proyecto, cuyo nombre corresponder\u00e1 al nombre del recurso y cuyo valor corresponder\u00e1 al <code>resId</code> que le ha asignado el sistema.</p> <p>En concreto, la clase <code>R</code> contendr\u00e1 una subclase est\u00e1tica para cada tipo de recurso existente (por ejemplo <code>R.drawable</code>, <code>R.layout</code>, <code>R.string</code>), que, a su vez, contendr\u00e1 una constante entera est\u00e1tica cuyo nombre corresponder\u00e1 al nombre del recurso y su valor ser\u00e1 el <code>resId</code> que el sistema le haya asignado autom\u00e1ticamente.</p> <p>El nombre del recurso depende del tipo de recurso del que se trate. Si se trata de un recurso representado por un archivo, como por ejemplo una imagen <code>icono.png</code> el nombre del recuso corresponder\u00e1 al nombre del archivo sin extensi\u00f3n, en este caso <code>icono</code>. Para otros tipos de recursos el nombre del recurso se indica expl\u00edcitamente en su declaraci\u00f3n, como en el caso de los recursos de constantes de cadena que veremos m\u00e1s adelante.</p> <pre><code>public final class R {\npublic static final class drawable {\npublic static final int ic_launcher=0x7f020000;\n}\npublic static final class id {\npublic static final int textView1=0x7f050000;\n}\npublic static final class layout {\npublic static final int activity_main=0x7f030000;\n}\npublic static final class string {\npublic static final int app_name=0x7f040001;\npublic static final int hello=0x7f040000;\n}\n// ...\n}\n</code></pre> <p>Gracias a esta clase autogenerada de constantes, podemos referenciar f\u00e1cilmente el <code>resId</code> asociado a un determinado recurso desde c\u00f3digo Java o Kotlin. Bastar\u00e1 con usar la sintaxis <code>[paquete.]R.tipo_recurso.nombre_recurso</code>, ya que simplemente estaremos accediendo a una constante Java (<code>public static final</code>) definida dentro de una subclase est\u00e1tica de la clase <code>R</code>. Por ejemplo:</p> <ul> <li>Archivo de layout <code>activity_main.xml</code> almacenado en la carpeta <code>res/layout</code>: usaremos <code>R.layout.activity_main</code></li> <li>Identificador <code>txtHello</code>: usaremos <code>R.id.txtHello</code></li> <li>Recurso de constante de cadena de caracteres con nombre <code>hello</code>: usaremos <code>R.string.hello</code></li> <li>Archivo de imagen <code>ic_launcher.png</code> almacenada en la carpeta <code>res/drawable</code>: usaremos <code>R.drawable.ic_launcher</code></li> </ul> <p>La clase <code>R</code> ser\u00e1 generada en el archivo <code>/app/build/generated/not_namespaced_r_class_sources/debug/processDebugResources/r/&lt;paquete&gt;/R.java</code>.</p> <p>Danger</p> <p>Dado que la clase R es generada autom\u00e1ticamente en el proceso de compilaci\u00f3n, nunca debemos editarla manualmente.</p> <p>Warning</p> <p>En las versiones m\u00e1s recientes del plugin de Gradle para Android Studio la clase <code>R</code> ser\u00e1 generada directamente en bytecode, sin crear un fichero <code>R.java</code> intermedio. Si quisi\u00e9ramos ver su contenido tendr\u00edamos que descompilar el bytecode correspondiente.</p>"},{"location":"bloque_i/tema_1/page-4/#recursos-id","title":"Recursos ID","text":"<p>En Android, los id con los que vamos a identificar las vistas son considerados recursos, ya que su valor no cambia a lo largo del tiempo.</p> <p>Sin embargo, y a diferencia de lo que sucede con el resto de tipos de recursos, para los id no es necesario crear ning\u00fan fichero ni subcarpeta especial dentro de la carpeta <code>app/src/main/res/</code>, ni a\u00f1adir ninguna declaraci\u00f3n en un archivo de recursos. Simplemente, cuando en una especificaci\u00f3n de layout XML en la que queramos referenciar a un nuevo recurso de id deberemos usar la sintaxis</p> <pre><code>&lt;TextView\nandroid:id=\"@+id/txtHello\"\n... /&gt;      </code></pre> <p>El car\u00e1cter <code>+</code> le indica al entorno de desarrollo que debe generar autom\u00e1ticamente un nuevo recurso de id con el nombre <code>txtHello</code>, siempre y cuando dicho recurso no exista ya. Posteriormente, se obtiene el valor entero generado autom\u00e1ticamente para dicho recurso (su resId) y se establece como valor de la propiedad id de la vista correspondiente.</p> <p>Como ya sabemos, cuando se genere la clase Java llamada <code>R</code>, se crear\u00e1 autom\u00e1ticamente una subclase est\u00e1tica, llamada <code>id</code>, que contendr\u00e1 una constante entera est\u00e1tica para cada uno de los id que hayamos creado.</p> <pre><code>public final class R {\npublic static final class id {\npublic static final int llRoot=0x7f07008c;\npublic static final int txtHello=0x7f07008d;\n}\n// ...\n}\n</code></pre> <p>Esto nos permitir\u00e1 acceder desde c\u00f3digo Java o Kotlin al <code>resId</code> del recurso de id.</p> <p>Warning</p> <p>Un recurso de id NO es lo mismo que un <code>resId</code>. Un recurso de id es un tipo de recurso, similar a un recurso de cadena o un recurso de layout, mientras que el <code>resId</code> es el n\u00famero entero que el sistema asigna como valor a cada una de las constantes definidas en la clase <code>R</code> que representan recursos.</p>"},{"location":"bloque_i/tema_1/page-4/#referencia-a-vistas-de-codigo-java-o-kotlin","title":"Referencia a vistas de c\u00f3digo Java o Kotlin","text":"<p>Como hemos comentado, una de las tareas que llevamos a cabo durante la creaci\u00f3n de la actividad es generar el \u00e1rbol de vistas a partir de la especificaci\u00f3n XML del layout de la interfaz de usuario. Como resultado del proceso de inflado realizado por <code>setContentView(layoutResId)</code> se obtiene el elemento ra\u00edz de dicho \u00e1rbol, que es establecido como interfaz de usuario de la actividad.</p> <p>Sin embargo, habitualmente necesitaremos obtener una referencia a vistas concretas dentro del \u00e1rbol de vistas, para por ejemplo establecer alguna de sus propiedades o detectar la interacciones del usuario con ellas.</p> <p>Para obtener la referencia a una vista concreta deberemos realizar una operaci\u00f3n de b\u00fasqueda dentro del \u00e1rbol correspondiente a partir de su vista ra\u00edz. Para poder llevar a cabo dicha operaci\u00f3n, la clase <code>AppCompatActivity</code> proporciona el m\u00e9todo <code>findViewById(viewIdResId)</code>, que recibe el <code>resId</code> del recurso de id asignado a la vista que queremos buscar dentro del \u00e1rbol de vistas correspondiente a la interfaz de usuario de la actividad. Como resultado obtendremos un objeto de la clase correspondiente (que deber\u00e1 heredar de <code>View</code>), dependiendo del tipo de la variable a la que asignemos la referencia.</p> <p>De hecho, ser\u00e1 muy habitual que tengamos que obtener la referencia a varias vistas de la interfaz de usuario, por lo que se suele crear un m\u00e9todo para tal fin, llamado por ejemplo <code>setupViews()</code>, en el que se lleven a cabo las operaciones de b\u00fasqueda y de configuraci\u00f3n de las vistas. El proceso de b\u00fasqueda de una vista dentro del \u00e1rbol puede resultar bastante costoso en tiempo, por lo que se recomienda realizarlo un \u00fanica vez, as\u00ed que llamaremos al m\u00e9todo <code>setupViews()</code> durante la creaci\u00f3n de la actividad, normalmente en el m\u00e9todo <code>onCreate()</code>.</p> <p>Como es bastante probable que debamos acceder a los objetos que representan a las vistas desde distintos m\u00e9todos de nuestra clase actividad, es habitual definir la variables que referencian vistas como fields (campos) de la clase actividad.</p> <pre><code>public class MainActivity extends AppCompatActivity {\nprivate TextView txtHello;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nsetContentView(R.layout.activity_main);\nsetupViews();\n}\nprivate void setupViews() {\ntxtHello = findViewById(R.id.txtHello);\ntxtHello.setText(\"Hello. What a wonderful world!\");\n}\n}\n</code></pre> <p>Nunca hagas esto</p> <p>No podemos realizar el proceso de b\u00fasqueda en la propia declaraci\u00f3n del field correspondiente a la vista, dado que en ese momento a la actividad a\u00fan no se le ha establecido su interfaz de usuario.</p> <pre><code>public class MainActivity extends AppCompatActivity {\n// \u00a1\u00a1\u00a1 NUNCA HAGAS ESTO. DA ERROR DE EJECUCI\u00d3N NullPointerException !!!\nprivate TextView txtHello = findViewById(R.id.txtHello);\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nsetContentView(R.layout.activity_main);\n}\n}\n</code></pre> <p>Otro aspecto que debemos tener en cuenta es qu\u00e9 ocurre si la vista cuyo id es proporcionado al m\u00e9todo <code>findViewById(viewIdResId)</code> no existe en el layout de la actividad, por ejemplo porque se trate de un id v\u00e1lido de una vista de la interfaz de usuario de otra actividad.</p> <p>Warning</p> <p>Si la vista cuyo id es proporcionado al m\u00e9todo <code>findViewById(viewIdResId)</code> no existe en el layout de la actividad el m\u00e9todo <code>findViewById()</code> retornar\u00e1 <code>null</code>, ya que no podr\u00e1 encontrar la vista en el \u00e1rbol de vistas correspondiente a la interfaz de usuario de la actividad. Esto puede resultar peligroso si no lo controlamos, dado que m\u00e1s adelante cuando queramos acceder a una propiedad de dicha vista se producir\u00e1 una excepci\u00f3n <code>NullPointerException</code>.</p> <p>Para solventar este inconveniente, la librer\u00eda de soporte proporciona el m\u00e9todo est\u00e1tico <code>ActivityCompat.requireViewById(activity, viewIdResId)</code>, que a diferencia de <code>findViewById(viewIdResId)</code> no retornar\u00e1 nunca <code>null</code>, sino que lanzar\u00e1 la excepci\u00f3n <code>IllegalArgumentException</code> si no existe una vista con dicho id en el layout de la actividad.</p> <p>Esto tiene dos ventajas: la variable destinataria no puede recibir <code>null</code> como consecuencia de la llamada y la excepci\u00f3n se lanza justo en la l\u00ednea que es err\u00f3nea, lo que nos permite depurar el error m\u00e1s r\u00e1pidamente.</p> <pre><code>public class MainActivity extends AppCompatActivity {\nprivate TextView txtHello;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nsetContentView(R.layout.activity_main);\nsetupViews();\n}\nprivate void setupViews() {\ntxtHello = ActivityCompat.requireViewById(this, R.id.txtHello);\ntxtHello.setText(\"Hello. What a wonderful world!\");\n}\n}\n</code></pre> <p>Ten en cuenta</p> <p>Como veremos cuando empecemos a estudiar Kotlin, el empleo de <code>ActivityCompat.requireViewById(activity, viewIdResId)</code> no tiene sentido ya que si definimos la variable como de un tipo no nullable, si <code>findViewById(viewIdResId)</code> retorna <code>null</code> se producir\u00e1 un error en la ejecuci\u00f3n, ya que la variable no puede tomar el valor <code>null</code>.</p> <p>Por otra parte, debemos tener en cuenta que se puede producir un error de conversi\u00f3n por tipo incompatible con respecto al tipo de la variable destinataria.</p> <p>Warning</p> <p>Tanto al hacer <code>findViewById()</code> como <code>ActivityCompat.requireViewById()</code> se puede producir un error de conversi\u00f3n de tipo si el tipo especificado para la variable no es compatible con el tipo de la vista del layout que posee el id pasado como argumento.</p> <p>Por ejemplo, si en el layout que estamos viendo hacemos</p> <pre><code>// Da ERROR en tiempo de ejecuci\u00f3n\nLinearLayout txtHello = ActivityCompat.requireViewById(this, R.id.txtHello);\n</code></pre> <p>Se producir\u00e1 un error en tiempo de ejecuci\u00f3n, ya que la vista con id <code>txtHello</code> corresponde a un <code>TextView</code>, que ni es ni hereda de <code>LinearLayout</code>.</p> <p>Desde el punto de vista del desarrollo, la codificaci\u00f3n de todas estas llamadas a <code>findViewById()</code> o <code>ActivityCompat.requireViewById()</code> es un proceso bastante tedioso, por lo que a lo largo del tiempo han ido apareciendo distintas opciones para automatizarlo. La mejor de ellas es la proporcionada por la funcionalidad conocida como ViewBinding.</p>"},{"location":"bloque_i/tema_1/page-5/","title":"5 ViewBinding","text":""},{"location":"bloque_i/tema_1/page-5/#viewbinding","title":"ViewBinding","text":"<p>ViewBinding es una funcionalidad, disponible a partir de Android Studio 3.6, que permite escribir m\u00e1s f\u00e1cilmente el c\u00f3digo que interact\u00faa con las vistas.</p> <p>El primer paso es activar ViewBinding en nuestro m\u00f3dulo, para lo que deberemos realizar la siguiente modificaci\u00f3n en su archivo <code>app/build.gradle</code>:</p> <pre><code>android {\n    // ...\n    buildFeatures {\n        viewBinding true\n    }\n}\n</code></pre> <p>La librer\u00eda de ViewBinding generar\u00e1, para cada especificaci\u00f3n XML de layout presente en ese m\u00f3dulo, una clase especializada en la vinculaci\u00f3n de las vistas definidas en la especificaci\u00f3n.</p> <p>El nombre de la clase generada se crea a partir del nombre del layout, al que se le agrega el sufijo <code>Binding</code>. As\u00ed, si nuestro layout se llamada <code>activity_main</code>, la clase generada para el binding ser\u00e1 <code>ActivityMainBinding</code>.</p> <p>\u00a1Cuidado!</p> <p>El nombre de la clase generada por ViewBinding no se crea a partir del nombre de la clase actividad, sino a partir del nombre del layout.</p> <p>Por este motivo, recomendamos renombrar los layout de manera que se llamen de forma similar a la clase correspondiente, con el objetivo de que la clase generada por ViewBinding tenga el mismo nombre pero con el sufijo <code>Binding</code>.</p> <p>As\u00ed, renombraremos el archivo XML de especificaci\u00f3n de layout de nuestra actividad <code>activity_main</code>, para que pase de llamarse <code>main_activity</code>, de manera que la clase binding generada sea <code>MainActivityBinding</code>.</p> <p>Para cada vista del layout en la que se le haya indicado un id se incluir\u00e1 en la clase generada por ViewBinding una propiedad del mismo tipo de la vista, y que, cuando se produzca el proceso de vinculaci\u00f3n, apuntar\u00e1 al objeto vista correspondiente.</p> <p>Warning</p> <p>Si en el layout no especificamos un id para una determinada vista, ViewBinding no incluir\u00e1 una propiedad para dicha vista en la clase generada.</p> <p>Por ejemplo, a partir del contenido del archivo <code>res/layout/main_activity.xml</code> siguiente:</p> <pre><code>&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/llRoot\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:orientation=\"vertical\" &gt;\n&lt;TextView\nandroid:id=\"@+id/lblHello\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:layout_margin=\"16dp\"\nandroid:text=\"Hello World!\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>se generar\u00e1 un clase denominada <code>MainActivityBinding</code>, localizada en <code>app/build/generated/data_binding_base_class_source_out/debug/out/[paquete]/databinding/MainActivityBinding.java</code>, con las siguientes propiedades y m\u00e9todos:</p> <p> Figura 19 - Propiedades y m\u00e9todos de MainActivityBinding</p> <p>Para crear una instancia de la clase generada en la que dichas propiedades contengan una referencia a los objetos vista correspondientes, deberemos llevar a cabo el proceso de inflado y vinculaci\u00f3n, que se puede realizar directamente a trav\u00e9s del m\u00e9todo est\u00e1tico <code>inflate(layoutInflater)</code> de la clase generada, que debe recibir un objeto de la clase <code>LayoutInflater</code>.</p> <p>Para obtener un <code>LayoutInflater</code> podemos usar el m\u00e9todo <code>getLayoutInflater()</code> de la actividad o el m\u00e9todo est\u00e1tico <code>LayoutInflater.from(context)</code>.</p> <p>Como resultado obtendremos un objeto binding de la clase generada, con todas las referencias a las vistas correspondientes.</p> <p>Pero a\u00fan nos queda un \u00faltimo paso muy importante. Si recordamos, para establecer la interfaz de usuario que deb\u00eda mostrar la actividad us\u00e1bamos el m\u00e9todo <code>setContent(layoutResId)</code>, que, como dijimos, realizaba el proceso de inflado del \u00e1rbol de vistas y establec\u00eda la vista ra\u00edz de dicho \u00e1rbol como interfaz de usuario de la actividad.</p> <p>Sin embargo, al usar el m\u00e9todo <code>inflate(layoutInflater)</code>de la clase generada por ViewBinding nosotros ya estamos realizando el proceso de inflado y obteniendo el \u00e1rbol de vistas correspondiente al layout.</p> <p>As\u00ed, una vez obtenido el objeto de binding debemos llamar al m\u00e9todo <code>setContentView(view)</code> de la actividad, que no realiza el inflado, sino que tan solo establece la vista recibida como vista ra\u00edz como interfaz de usuario de la actividad. Para obtener la vista ra\u00edz del binding podemos usar su m\u00e9todo <code>getRoot()</code>.</p> <pre><code>public class MainActivity extends AppCompatActivity {\nprivate MainActivityBinding binding;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nbinding = MainActivityBinding.inflate(getLayoutInflater());\n// CAMBIAMOS EL TRADICIONAL setContentView(R.layout.main_activity)\nsetContentView(binding.getRoot());\n// ...\n}\n// ...\n}\n</code></pre> <p>\u00a1Cuidado!</p> <p>Si inflamos el binding con <code>MainActivityBinding.inflate(getLayoutInflater())</code> y seguimos usando el tradicional <code>setContentView(R.layout.main_activity)</code> estaremos inflando el layout dos veces, y lo que es peor, las vistas referenciadas en el binding no ser\u00e1n las que se est\u00e9n mostrando en pantalla, por lo que, no seremos capaces de actualizar la interfaz de usuario o responder a los eventos de interacci\u00f3n del usuario.</p> <p>A partir de ese momento podemos hacer referencia a cualquier vista de la interfaz de usuario de la actividad a trav\u00e9s del objeto binding. Por ejemplo, si queremos acceder al objeto cuyo id es <code>txtHello</code>, podemos hacerlo a trav\u00e9s de <code>binding.txtHello</code>.</p> <p>Veamos c\u00f3mo quedar\u00eda el c\u00f3digo de nuestra actividad haciendo uso de ViewBinding.</p> <pre><code>public class MainActivity extends AppCompatActivity {\nprivate MainActivityBinding binding;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nbinding = MainActivityBinding.inflate(getLayoutInflater());\nsetContentView(binding.getRoot());\nsetupViews();\n}\nprivate void setupViews() {\nbinding.txtHello.setText(\"Hello. What a wonderful world!\");\n}    }\n</code></pre> <p>ViewBinding presenta importantes ventajas sobre el uso de <code>findViewById()</code>. La primera de ellas es lo que se conoce como null safety (seguridad contra nulos). Dado que ViewBinding crea referencias directas a las vistas, no hay riesgo de una excepci\u00f3n <code>NullPointerException</code> debido a un id de vista no v\u00e1lido para dicho layout, ya que en el proceso de inflado se habr\u00e1 establecido como valor de cada propiedad el objeto correspondiente.</p> <p>Solo en el caso en el que para la misma actividad tengamos layouts distintos para distintas configuraciones (lo estudiaremos m\u00e1s adelante), y una determinada vista no est\u00e1 presente en todos esos layouts, la propiedad correspondiente en la clase generada por ViewBinding es marcada con la anotaci\u00f3n <code>@Nullable</code> para indicar que puede ser <code>null</code>.</p> <p>Por otra parte, ViewBinding proporciona lo que se conoce como type safety (seguridad de tipo), ya que los tipos de las propiedades de la clase generada coinciden con los tipos de las vistas correspondiente en la especificaci\u00f3n XML de layout, por lo que no hay riesgo de una excepci\u00f3n por conversi\u00f3n incorrecta de tipo, como vimos anteriormente.</p> <p>En resumen, ViewBinding consigue que las incompatibilidades entre el layout y el c\u00f3digo Java o Kotlin produzcan fallos en tiempo de compilaci\u00f3n, en lugar de en tiempo de ejecuci\u00f3n.</p>"},{"location":"bloque_i/tema_1/page-6/","title":"6 Recursos de valores","text":""},{"location":"bloque_i/tema_1/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Como hemos dicho antes, algunos de los recursos de nuestro programa son nombrados expl\u00edcitamente y no se toma para ello el nombre del archivo en el que se encuentran. Este es el caso de los conocidos como recursos de valores, que son almacenados en distintos ficheros XML dentro de la carpeta <code>res/values/</code> de nuestro m\u00f3dulo.</p> <p>Recurso de valor</p> <p>Un recurso de valor corresponde a un nombre que asociamos a un determinado literal, ya sea de cadena, entero, de dimensi\u00f3n, etc.</p> <p>Estos ficheros XML incluir\u00e1n en su interior la definici\u00f3n de recursos de valores. A diferencia del resto de carpetas, en las que cada fichero corresponde a un recurso, los ficheros contenidos en esta carpeta describen varios recursos, que son nombrados expl\u00edcitamente.</p> <p>El contenido de cada fichero deber\u00e1 comenzar con la etiqueta <code>&lt;resources&gt;</code> (y terminar con <code>&lt;/resources&gt;</code>), y cada hijo de dicha etiqueta ser\u00e1 considerado un recurso de constante. As\u00ed en un mismo archivo podemos definir m\u00faltiples recursos correspondientes, por ejemplo, a constantes de cadena.</p> <p>De hecho, podemos crear tantos ficheros de recursos de valores constantes como queramos, nombrarlos a nuestro gusto e incluso mezclar recursos de valores constantes de diferentes tipos en el mismo fichero.</p> <p>Sin embargo, para una mayor claridad es recomendable colocar todos los recursos de valores del mismo tipo en un mismo fichero.</p> <p>Normalmente se usan nombres est\u00e1ndar a la hora de nombrar los ficheros de recursos de constantes, aunque no es obligatorio usarlos:</p> <p>Nombres est\u00e1ndar de ficheros de recursos de valor</p> <ul> <li>res/values/strings.xml<code>: Recursos de cadena y de arrays de de cadena.</code></li> <li><code>res/values/integers.xml</code>: Recursos de entero.</li> <li>res/values/colors.xml<code>: Recursos de color.</code></li> <li><code>res/values/dimens.xml</code>: Recursos de dimensi\u00f3n.</li> <li>res/values/styles.xml`: Recursos de estilo y de tema.</li> </ul> <p>Como ejemplo, veamos un posible contenido del archivo <code>strings.xml</code>:</p> <pre><code>&lt;resources&gt;\n&lt;string name=\"app_name\"&gt;HelloWorld&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre> <p>En este caso estamos definiendo un recurso de contante de cadena cuyo nombre ser\u00e1 <code>app_name</code> y cuyo valor ser\u00e1 <code>HelloWorld</code>.</p> <p>Todas estas etiquetas XML usan el atributo <code>name</code> para que indiquemos el nombre que queremos darle al recurso.</p> <p>Podemos definir distintos tipos de recursos de valores, entre los que destacamos:</p> <ul> <li>Recursos de cadena</li> <li>Recursos de enteros</li> <li>Recursos de color</li> <li>Recursos de dimensi\u00f3n</li> <li>Recursos de estilo</li> </ul>"},{"location":"bloque_i/tema_1/page-6/#recursos-de-cadena","title":"Recursos de cadena","text":"<pre><code>&lt;string name=\"titulo\"&gt;Mi Aplicaci\u00f3n&lt;/string&gt;\n</code></pre> <p>El valor puede contener las etiquetas HTML <code>&lt;b&gt;</code> (negrita), <code>&lt;i&gt;</code> (cursiva), o <code>&lt;u&gt;</code> (subrayado). Si el valor debe contener los caracteres <code>&lt;</code>, <code>&gt;</code>, o <code>&amp;</code>, el valor debe incluirse dentro de <code>&lt;![CDATA[valor]]&gt;</code></p> <p>C\u00f3mo hacer referencia a ellos</p> <ul> <li>Desde c\u00f3digo Java o Kotlin: <code>R.string.titulo</code></li> <li>Desde c\u00f3digo XML: <code>@string/titulo</code></li> </ul>"},{"location":"bloque_i/tema_1/page-6/#recurso-de-entero","title":"Recurso de Entero","text":"<pre><code>&lt;integer name=\"columns\"&gt;2&lt;/string&gt;\n</code></pre> <p>C\u00f3mo hacer referencia a ellos</p> <ul> <li>Desde c\u00f3digo Java o Kotlin: <code>R.integer.titulo</code></li> <li>Desde c\u00f3digo XML: <code>@integer/titulo</code></li> </ul>"},{"location":"bloque_i/tema_1/page-6/#recurso-de-color","title":"Recurso de color","text":"<pre><code>&lt;color name=\"fondo\"&gt;#AA8862&lt;/color&gt;\n</code></pre> <p>C\u00f3mo hacer referencia a ellos</p> <ul> <li>Desde c\u00f3digo Java o Kotlin: <code>R.color.fondo</code></li> <li>Desde c\u00f3digo XML: <code>@color/fondo</code></li> </ul>"},{"location":"bloque_i/tema_1/page-6/#recurso-de-dimension","title":"Recurso de dimensi\u00f3n","text":"<pre><code>&lt;dimen name=\"margen_arriba\"&gt;10dp&lt;/dimen&gt;\n</code></pre> <p>Contiene un valor junto con su unidad.</p> <p>C\u00f3mo hacer referencia a ellos</p> <ul> <li>Desde c\u00f3digo Java o Kotlin: <code>R.dimen.margen_arriba</code></li> <li>Desde c\u00f3digo XML: <code>@dimen/margen_arriba</code></li> </ul> <p>Warning</p> <p>Debemos evitar usar la unidad <code>px</code> (p\u00edxeles) para establecer distancias o tama\u00f1os en nuestros layouts. El motivo es que existen pantallas con el mismo tama\u00f1o pero que tienen distintas densidades de p\u00edxeles, por lo que en este caso, un determinado tama\u00f1o en p\u00edxeles corresponde a diferentes tama\u00f1os f\u00edsicos reales dependiendo de la densidad de la pantalla en cuesti\u00f3n.</p> <p>Por lo tanto, a la hora de especificar dimensiones debemos emplear siempre la unidad <code>dp</code> (o <code>dip</code>).</p> <p>dp</p> <p>Un <code>dp</code> es un pixel independiente de la densidad (density independent pixel), y corresponde al tama\u00f1o f\u00edsico de un pixel en una resoluci\u00f3n de 160 puntos por pulgada.</p> <p>Para el tama\u00f1o del texto, a la hora de especificar una dimensi\u00f3n, usaremos la unidad <code>sp</code>, en vez de <code>dp</code>.</p> <p>sp</p> <p>Un <code>sp</code> es un pixel escalado (scaled pixel), y corresponde al valor de un <code>dp</code> pero escalado atendiendo al tama\u00f1o de texto especificado en las preferencias del dispositivo</p>"},{"location":"bloque_i/tema_1/page-6/#recurso-de-estilo","title":"Recurso de Estilo","text":"<pre><code>&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt;\n&lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt;\n&lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt;\n&lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;\n&lt;/style&gt;\n</code></pre> <p>Los veremos m\u00e1s adelante en un apartado espec\u00edfico.</p> <p>C\u00f3mo hacer referencia a ellos</p> <ul> <li>Desde c\u00f3digo Java o Kotlin: <code>R.style.mi_estilo</code></li> <li>Desde c\u00f3digo XML: <code>@style/mi_estilo</code></li> </ul>"},{"location":"bloque_i/tema_1/page-6/#recursos-de-valor-en-nuestro-proyecto","title":"Recursos de valor en nuestro proyecto","text":"<p>Para practicar el uso de los recursos de valor, vamos a modificar la especificaci\u00f3n XML de layout de la interfaz de usuario de nuestra actividad, <code>main_activity.xml</code> para que en vez de usar el literal de cadena <code>\"Hello World!\"</code>, dicho literal sea definido como un recurso de constante de cadena de caracteres</p> <pre><code>&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/llRoot\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:orientation=\"vertical\" &gt;\n&lt;TextView\nandroid:id=\"@+id/txtHello\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:layout_margin=\"16dp\"\nandroid:text=\"Hello World!\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>El primer paso consiste en incluir en el archivo <code>res/values/strings.xml</code> la definici\u00f3n de un nuevo recurso de cadena al que le asignaremos el nombre de <code>main_txtHello</code>, con lo que quedar\u00eda</p> <pre><code>&lt;resources&gt;\n&lt;string name=\"app_name\"&gt;HelloWorld&lt;/string&gt;\n&lt;string name=\"main_txtHello\"&gt;Hello World!&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre> <p>Para indicar el valor del margen con el que el <code>TextView</code> se separa de los bordes de su padre, definiremos y usaremos un recurso de valor de dimensi\u00f3n. El primer paso ser\u00e1 definir dicho recurso en alg\u00fan archivo de recursos de valor, en este caso crearemos el archivo <code>res/values/dimens.xml</code>:</p> <pre><code>&lt;resources&gt;\n&lt;dimen name=\"main_margin\"&gt;16dp&lt;/dimen&gt;\n&lt;/resources&gt;\n</code></pre> <p>Despu\u00e9s deberemos modificar la propiedad <code>android:text</code> del <code>TextView</code> para que su valor haga referencia al recurso de cadena, usando el formato de referencia que hemos visto anteriormente. Por otra parte, modificaremos el atributo <code>android:layout_margin</code> del <code>TextView</code>, cuyo valor estableceremos al valor del recurso de valor de dimensi\u00f3n que hemos definido:</p> <pre><code>&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/llRoot\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:orientation=\"vertical\" &gt;\n&lt;TextView\nandroid:id=\"@+id/txtHello\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:layout_margin=\"@dimen/main_margin\"\nandroid:text=\"@string/main_txtHello\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Sugerencia</p> <p>Se recomienda siempre definir recursos de valor en vez de usar literales, ya que esto nos va a permitir usar diferentes valores para distintas configuraciones del dispositivo, como veremos m\u00e1s adelante.</p>"},{"location":"bloque_i/tema_1/page-7/","title":"7 Clase Resources","text":""},{"location":"bloque_i/tema_1/page-7/#la-clase-resources","title":"La Clase Resources","text":"<p>En el apartado anterior hemos visto como definir un recurso de constante de cadena y c\u00f3mo usarlo desde nuestro c\u00f3digo XML. Sin embargo no hemos visto c\u00f3mo usar un recurso de valor desde c\u00f3digo Java o Kotlin.</p> <p>Vamos a modificar el c\u00f3digo de nuestra actividad para que en vez de usar el literal <code>\"Hello. What a wonderful world!\"</code>, emplee un recurso de constante de cadena</p> <pre><code>public class MainActivity extends AppCompatActivity {\n// ... \nprivate void setupViews() {\nb.txtHello.setText(\"Hello. What a wonderful world!\");\n}\n}\n</code></pre> <p>El primer paso es definir el recurso de cadena en el archivo <code>res/strings.xml</code>, al que le vamos a dar el nombre <code>main_wonderful</code>.</p> <pre><code>&lt;resources&gt;\n&lt;string name=\"app_name\"&gt;HelloWorld&lt;/string&gt;\n&lt;string name=\"main_txtHello\"&gt;Hello World!&lt;/string&gt;\n&lt;string name=\"main_wonderful\"&gt;Hello. What a wonderful world!&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre> <p>Despu\u00e9s, en la actividad, deberemos poder obtener el recurso correspondiente a partir su <code>resId</code>. Para ello es necesario que accedamos al objeto de la clase <code>Resources</code> asociado al contexto de ejecuci\u00f3n del proyecto.</p> <p>La clase <code>Resources</code> es una clase que nos va a permitir acceder desde c\u00f3digo Java o Kotlin a todos los recursos de nuestro proyecto, a trav\u00e9s de una serie de m\u00e9todos que reciben el resId del recurso a obtener.</p> <p>Para poder acceder al objeto <code>Resources</code> desde la actividad debemos usar su m\u00e9todo <code>getResources()</code>. Una vez obtenido el objeto <code>Resources</code> podremos usar, por ejemplo, su m\u00e9todo <code>getString(resId)</code> para obtener la cadena correspondiente al valor del recurso de cadena representado por dicho resId.</p> <pre><code>public class MainActivity extends AppCompatActivity {\n// ...\nprivate void setupViews() {\nString message = getResources().getString(R.string.main_wonderful);\nb.txtHello.setText(message);\n}\n}\n</code></pre> <p>La clase <code>Resources</code> nos proporciona m\u00e9todos para acceder a todos los tipos de recursos: <code>getColor(resId)</code>, <code>getStringArray(resId)</code>, <code>getInteger(resId)</code>, etc.</p> <p>Sugerencia</p> <p>La clase <code>Activity</code> dispone de un m\u00e9todo <code>getString()</code> que internamente llama a <code>getResources().getString()</code>, por lo que tendremos que escribir menos c\u00f3digo. Sin embargo, el resto de m\u00e9todos de <code>Resources</code> no est\u00e1n disponibles en <code>Activity</code></p> <p>As\u00ed, el c\u00f3digo anterior puede quedar m\u00e1s corto, de la siguiente manera:</p> <pre><code>public class MainActivity extends AppCompatActivity {\n// ...\nprivate void setupViews() {\nbinding.txtHello.setText(getString(R.string.main_wonderful));\n}\n}\n</code></pre> <p>Como este proceso de obtenci\u00f3n del valor de un recurso desde el objeto <code>Resources</code> a partir de su resId puede resultar tedioso, en muchos casos los m\u00e9todos que reciben valores que pueden provenir de recursos est\u00e1n sobrecargados para recibir el resId del recurso, e internamente hacer por nosotros el trabajo sucio de obtener el objeto <code>Resources</code> y de usar el m\u00e9todo adecuado para obtener el valor del recurso a partir del resId recibido.</p> <p>Por ejemplo, el m\u00e9todo <code>setText(resId)</code> de la clase <code>TextView</code> est\u00e1 sobrecargado para recibir como argumento, en vez de una cadena de caracteres, el resId del recurso de cadena que se quiere establecer como texto del <code>TextView</code>. As\u00ed, el c\u00f3digo anterior podr\u00eda acortarse de la siguiente manera:</p> <pre><code>public class MainActivity extends AppCompatActivity {\n// ...\nprivate void setupViews() {\nbinding.txtHello.setText(R.string.main_wonderful);\n}\n}\n</code></pre> <p>\u00a1Cuidado!</p> <p>Debido a que el m\u00e9todo <code>setText(stringResId)</code> est\u00e1 sobrecargado para recibir un entero correspondiente al <code>resId</code> del recurso de cadena, si, por error le pasamos un valor entero cualquiera, por ejemplo la edad del usuario, no se producir\u00e1 un error de compilaci\u00f3n, sino un error en ejecuci\u00f3n indicando que no se ha encontrado un recurso de cadena con dicho <code>resId</code>.</p>"},{"location":"bloque_i/tema_1/page-7/#ejecucion-del-proyecto-helloworld","title":"Ejecuci\u00f3n del proyecto HelloWorld","text":"<p>Para ejecutar el proyecto bastar\u00e1 con que pulsemos la opci\u00f3n de men\u00fa <code>Run -&gt; Run app</code>. El resultado que se mostrar\u00e1 en el emulador ser\u00e1 el que se muestra a continuaci\u00f3n.</p> <p> Figura 20 - Proyecto HelloWorld en ejecuci\u00f3n</p>"},{"location":"bloque_i/tema_2/page-1/","title":"1 Introducci\u00f3n a las vistas b\u00e1sicas","text":""},{"location":"bloque_i/tema_2/page-1/#text-view","title":"Text View","text":"<p>El vista m\u00e1s simple que existe en Android es la etiqueta (label en ingl\u00e9s), que recibe el nombre de <code>TextView</code>. Una etiqueta es un fragmento de texto que, por defecto, NO puede ser editado directamente por el usuario. Se utilizan generalmente para dar informaci\u00f3n al usuario sobre un widget adyacente situado a su lado. Por ejemplo, es muy habitual encontrar una etiqueta seguida de un cuadro de texto, de manera que mediante la etiqueta se informa al usuario sobre el dato que debe introducir en el mismo (por ejemplo el nombre del cliente).</p> <p> Figura 1 - Esquema TextView</p> <p>Clase TextView</p> <p>Si queremos incluir un <code>TextView</code> en nuestro archivo de layout e indicar en tiempo de compilaci\u00f3n algunas de sus propiedades, tendremos que incluir en \u00e9l una especificaci\u00f3n como la que sigue:</p> <pre><code>&lt;TextView\nandroid:id=\"@+id/lblName\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"@string/main_lblName\"\nandroid:textColor=\"@color/primaryText\"\nandroid:textStyle=\"bold\" /&gt;\n</code></pre> <p>Los atributos XML m\u00e1s utilizados de los TextView son:</p> <ul> <li><code>android:gravity</code>: Alineaci\u00f3n del texto dentro del rect\u00e1ngulo correspondiente a la vista. Los valores m\u00e1s habituales son <code>start</code>, <code>center</code> y <code>end</code>. No tiene sentido definirlo si la anchura de la vista es <code>wrap_content</code>.</li> <li><code>android:text</code>: Texto que muestra.</li> <li><code>android:textColor</code>: Color del texto.</li> <li><code>android:textAllCaps</code>: Texto todo en may\u00fasculas.</li> <li><code>android:capitalize</code>: Pone en may\u00fasculas de manera autom\u00e1tica el texto, ya sea la primera letra de la frase, la primera letra de cada palabra o todos los caracteres.</li> <li><code>android:hint</code>: Consejo (tooltip o hint) cuando no se tiene ning\u00fan texto.</li> <li><code>android:textSize</code>: Tama\u00f1o de la letra.</li> <li><code>android:textStyle</code>: Formato del texto, ya sea negrita (bold), cursiva (italic) o ambas (bold_italic).</li> <li><code>android:ellipsize</code>: Posici\u00f3n por la que se trunca el texto cuando no cabe en la vista, a\u00f1adiendo <code>...</code> (<code>start</code>, <code>end</code>, <code>middle</code>)</li> <li><code>android:selectAllOnFocus</code>: Recibe un booleano para indicar si queremos que se seleccione autom\u00e1ticamente el texto de la vista cuando \u00e9ste gane el foco. Esta propiedad se usara sobre todo en los <code>EditText</code> que veremos a continuaci\u00f3n.</li> </ul> <p>Tambi\u00e9n disponemos de un atributo espec\u00edfico para el editor visual de layouts llamado <code>tools:text</code>, que se aplica a cualquier vista que pueda mostrar texto, para indicar el texto que debe mostrar el editor visual de layouts, aunque no se haya especificado la propiedad <code>android:text</code> para la vista.</p> <p>Sugerencia</p> <p>A la hora de mostrar un texto, podemos usar las colecciones de datos de ejemplo proporcionados por Android Studio. Por ejemplo para mostrar como texto un p\u00e1rrafo de lorem ipsum podemos usar <code>tools:text=\"@tools:sample/lorem\"</code> o para mostrar un nombre <code>tools:text=\"@tools:sample/full_name\"</code>.</p> <p>Por otra parte, tenemos la posibilidad de asociar un determinado drawable (por ejemplo un peque\u00f1o icono a un <code>TextView</code>, de manera que se muestre a su lado (a su izquierda, derecha, arriba o abajo) a una determinada distancia. Para ello usaremos los siguientes atributos XML:</p> <ul> <li><code>android:drawableLeft</code>, <code>android:drawableRight</code>, <code>android:drawableTop</code> y <code>android:drawableBottom</code>: Drawable que debe mostrarse a su izquierda, derecha, arriba y abajo, respectivamente.</li> <li><code>android:drawablePadding</code>: Espacio (distancia) entre el texto y el drawable.</li> </ul> <p>Sugerencia</p> <p>No existe ninguna propiedad para establecer el tama\u00f1o del drawable, por lo que se recomienda que el tama\u00f1o de \u00e9ste sea acorde al del texto contenido en el <code>TextView</code>.</p> <p>Desde c\u00f3digo Java o Kotlin los m\u00e9todos m\u00e1s usados de <code>TextView</code> ser\u00e1n <code>setText(charSequence)</code> para establecer el texto que debe mostrar y <code>getText()</code>, que retorna un objeto <code>CharSequence</code> con el texto mostrado. <code>CharSequence</code> es una interfaz implementada por <code>String</code>. Si queremos convertirlo a cadena podemos usar el m\u00e9todo <code>toString()</code> del objeto <code>CharSequence</code>.</p> <pre><code>String name = binding.lblName.getText().toString();\nbinding.lblName.setText(name.toUpperCase());\n</code></pre> <p>Por otro lado, la gu\u00eda de dise\u00f1o material design establece una serie de dise\u00f1os tipogr\u00e1ficos est\u00e1ndar para el texto:</p> <p> Figura 2 - Estilos tipogr\u00e1ficos, by Google</p> <p>Los tama\u00f1os de dichos dise\u00f1os tipogr\u00e1ficos est\u00e1n incluidos en la librer\u00eda de compatibilidad support library en forma de recursos de dimensi\u00f3n, as\u00ed que podemos establecer el atributo <code>android:textSize=\"@dimen/text_size_display_4_material\"</code> (el resto de recursos son similares sustituyendo <code>display_4</code> por el nombre del dise\u00f1o correspondiente en la imagen anterior).</p> <p>El problema es que los dise\u00f1os anteriores no s\u00f3lo modifican el tama\u00f1o del texto, sino otros elementos, como si el texto debe aparecer todo en may\u00fasculas. Por tanto lo m\u00e1s sencillo es establecer a la vez varias propiedades del texto a trav\u00e9s del atributo <code>style</code>, asign\u00e1ndole como valor alguno de los recursos de estilo definidos en la librer\u00eda de compatibilidad. Por ejemplo: <code>style=\"@style/Base.TextAppearance.AppCompat.Display4\"</code> (el resto de recursos son similares sustituyendo <code>Display4</code> por el nombre del dise\u00f1o correspondiente en la imagen anterior).</p> <p>Warning</p> <p>El atributo <code>style</code> se usa sin el namespace <code>android:</code>. El motivo es que se trata de un atributo gen\u00e9rico, t\u00edpico de los lenguajes de marcas, como por ejemplo HTML, y no algo espec\u00edfico de Android, por lo que los desarrolladores del framework decidieron no incluirlo en el namespace <code>android:</code>.</p> <pre><code>&lt;TextView\nandroid:id=\"@+id/lblName\"       android:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"@string/main_lblName\"\nstyle=\"@style/Base.TextAppearance.AppCompat.Headline\" /&gt;\n</code></pre>"},{"location":"bloque_i/tema_2/page-1/#button","title":"Button","text":"<p>Un bot\u00f3n (button) es un zona de pantalla que puede ser pulsada por el usuario para indicar que se empiece a llevar a cabo una acci\u00f3n. Android proporciona distintos tipos de vistas con funcionalidad de bot\u00f3n. El tipo m\u00e1s simple y gen\u00e9rico es la clase <code>Button</code>, que es una subclase de <code>TextView</code>, por lo que hereda sus propiedades y m\u00e9todos.</p> <p> Figura 3 - Esquema Button</p> <p>La gu\u00eda de dise\u00f1o material design establece distintos estilos visuales para los botones. El estilo por defecto es el conocido como raised button (bot\u00f3n elevado):</p> <p> Figura 4 - Estilos est\u00e1ndar para botones, by Google</p> <p>En el siguiente ejemplo se incluye un objeto <code>Button</code> en un fichero de layout XML para el que se usa el estilo por defecto raised button:</p> <pre><code>&lt;Button android:id=\"@+id/btnAccept\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\" android:text=\"@string/main_btnAccept\"/&gt;\n</code></pre> <p>Tambi\u00e9n podemos hacer que el bot\u00f3n incluya un icono, haciendo uso de los atributos <code>android:drawableLeft</code> y <code>android:drawablePadding</code>, heredados de la clase <code>TextView</code>.</p>"},{"location":"bloque_i/tema_2/page-2/","title":"2 Oyentes y cadenas","text":""},{"location":"bloque_i/tema_2/page-2/#proyecto-countingclicks","title":"Proyecto CountingClicks","text":"<p>En este proyecto desarrollaremos una aplicaci\u00f3n que muestra el pantalla el n\u00famero de veces que se ha hecho click sobre un bot\u00f3n.</p> <p> Figura 5 - Proyecto CountingClicks</p> <p>Crea un proyecto mediante el asistente, tal y como vimos anteriormente. Despu\u00e9s modifica la especificaci\u00f3n XML de layout de la actividad, de manera que el archivo pase a llamarse <code>res/layout/main_activity.xml</code> y que contenga:</p> <pre><code>&lt;LinearLayout\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"\nandroid:id=\"@+id/llRoot\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:orientation=\"vertical\"\nandroid:padding=\"@dimen/main_margin\"&gt;\n&lt;TextView\nandroid:id=\"@+id/lblTimes\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\ntools:text=\"0\"\nandroid:textAppearance=\"@style/TextAppearance.AppCompat.Display3\"/&gt;\n&lt;Button\nandroid:id=\"@+id/btnClickMe\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:layout_marginTop=\"@dimen/main_margin\"\nandroid:text=\"@string/main_btnClickMe\"/&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Algo de lo que no hemos hablado a\u00fan es que el contenedor <code>LinearLayout</code> se caracteriza porque apila sus vistas hijas de forma horizontal (de izquierda a derecha) o de forma vertical (de arriba a abajo) dependiendo del valor de su atributo <code>android:orientation</code>, como estudiaremos con m\u00e1s detenimiento m\u00e1s adelante. As\u00ed que en nuestro dise\u00f1o el bot\u00f3n aparecer\u00e1 debajo del <code>TextView</code>.</p> <p>Como vemos, en el layout anterior hemos establecido que el ViewGroup ra\u00edz tenga un relleno (padding) para que los elementos no se peguen al borde. Adem\u00e1s, se le ha aplicado un estilo predefinido al <code>TextView</code> que va a mostrar el n\u00famero de veces que se ha hecho click, de manera que se vea bastante grande. Finalmente, se ha establecido un margen superior en el bot\u00f3n para que \u00e9ste no quede pegado justo debajo del <code>TextView</code>.</p> <p>Un aspecto curioso es que no se ha establecido texto al <code>TextView</code>, ya que el texto inicial se establecer\u00e1 en tiempo de ejecuci\u00f3n desde c\u00f3digo Java o Kotlin, e ir\u00e1 cambiando conforme el usuario haga click en el bot\u00f3n. Sin embargo hemos especificado mediante el atributo <code>tools:text</code> que el editor visual muestre el un texto para poder comprobar el dise\u00f1o correctamente.</p> <p>Hemos definido los siguientes recursos de valor en el archivo <code>res/values/strings.xml</code>:</p> <pre><code>&lt;resources&gt;\n&lt;string name=\"app_name\"&gt;CountingClicks&lt;/string&gt;\n&lt;string name=\"main_btnClickMe\"&gt;Click me!&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre> <p>y en el archivo <code>res/values/dimens.xml</code>:</p> <pre><code>&lt;resources&gt;\n&lt;dimen name=\"main_margin\"&gt;16dp&lt;/dimen&gt;\n&lt;/resources&gt;\n</code></pre>"},{"location":"bloque_i/tema_2/page-2/#listeners","title":"Listeners","text":"<p>En la programaci\u00f3n de aplicaciones con interfaces de usuario gr\u00e1ficas es muy usual que las acciones realizadas por el usuarios, conocidos como eventos, sean notificados al c\u00f3digo de programaci\u00f3n a trav\u00e9s de lo que se conoce como callbacks o listeners.</p> <p>Un listener no es m\u00e1s que una interfaz que contiene uno o m\u00e1s m\u00e9todos de callback que ser\u00e1n ejecutados por el sistema cuando se produzca el evento correspondiente en una determinada vista.</p> <p>Nuestra misi\u00f3n como programadores ser\u00e1 crear un objeto de una clase que implemente dicha interfaz listener para que el o los m\u00e9todos correspondientes contengan el c\u00f3digo de respuesta al evento producido por el usuario. Por ejemplo, la interfaz <code>View.OnClickListener</code> define un m\u00e9todo de callback llamado <code>onClick(view)</code> que ser\u00e1 llamado por el sistema cuando el usuario haga click sobre una vista, que ser\u00e1 pasada como argumento al m\u00e9todo.</p> <p>Una vez creado dicho objeto listener, deberemos asociarlo a la vista correspondiente, para que el sistema sepa sobre qu\u00e9 objeto debe ejecutar el m\u00e9todo de callback cuando el usuario produzca el evento en la vista. Por ejemplo, llamaremos al m\u00e9todo <code>setOnClickListener(onClickListener)</code> de una determinada vista para establecer el listener <code>OnClickListener</code> a cuyo m\u00e9todo <code>onClick(view)</code> queremos que el sistema llame cuando el usuario haga click sobre dicha vista.</p> <p>Como podemos intuir, los listener son los candidatos perfectos para usar la sintaxis Java de clases inline an\u00f3nimas, ya que debemos crear un objeto espec\u00edfico para la ocasi\u00f3n y en realidad nos da igual c\u00f3mo se llame la clase porque s\u00f3lo vamos a crear un \u00fanico objeto de ella.</p> <p>Por ejemplo, podemos crear un un objeto de una clase an\u00f3nima que implementa la interfaz <code>OnClickListener</code> de manera inline, justo cuando se est\u00e1 estableciendo como listener para una determinada vista a trav\u00e9s de su m\u00e9todo <code>setOnClickListener(onClickListener)</code>. El c\u00f3digo de nuestra actividad quedar\u00eda:</p> <pre><code>public class MainActivity extends Activity {\nprivate MainActivityBinding binding;\nprivate int times;\n@Override\npublic void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nbinding = MainActivityBinding.inflate(getLayoutInflater());\nsetContentView(binding.getRoot());\nsetupViews();\n}\nprivate void setupViews() {\nbinding.btnClickMe.setOnClickListener(new OnClickListener() {\npublic void onClick(View v) {\nincrementAndShow();\n}\n});\n}\nprivate void incrementAndShow() {\ntimes++;\nshowTimes();\n}\nprivate void showTimes() {\nbinding.lblTimes.setText(String.valueOf(times));\n}\n}\n</code></pre> <p>Como desventaja podr\u00edamos indicar que utiliza una sintaxis algo compleja y que el c\u00f3digo queda poco limpio, y no permite recibir datos adicionales, ya que en la sintaxis de clase an\u00f3nima inline no podemos definir el constructor de la clase.</p> <p>Las expresiones lambda de Java 8 nos proporcionan una sintaxis m\u00e1s sencilla que permite aumentar la legibilidad de nuestro c\u00f3digo en relaci\u00f3n al empleo de clases inline an\u00f3nimas que implementan una determinada interfaz funcional, que usamos habitualmente al especificar los listener de nuestras vistas.</p> <p>Interfaz funcional</p> <p>Una interfaz funcional es aquella que dispone de un \u00fanico m\u00e9todo abstracto, de ah\u00ed que tambi\u00e9n reciban el nombre de SAM (single abstract method, \u00fanico m\u00e9todo abstracto).</p> <p>En el caso de un listener contenga m\u00e1s de un m\u00e9todo abstracto, no podremos usar expresiones lambda, y deberemos seguir usando clases an\u00f3nimas inline.</p> <p>Por ejemplo, si queremos establecer el listener para el c\u00f3digo anterior haciendo uso de una expresi\u00f3n lambda har\u00edamos:</p> <pre><code>public class MainActivity extends Activity {\n// ...\nprivate void setupViews() {\nbinding.btnClickMe.setOnClickListener(v -&gt; incrementAndShow());       }\n}\n</code></pre> <p>Una expresi\u00f3n lambda tiene la sintaxis <code>(param1, param2) -&gt; { cuerpo }</code>, con las siguientes caracter\u00edsticas:</p> <ul> <li>Podemos omitir el tipo de dato de cada par\u00e1metro, ya que el compilador puede deducirlos.</li> <li>Si se especifica un \u00fanico par\u00e1metro, podemos omitir los par\u00e9ntesis. Si no se especifica ning\u00fan par\u00e1metro es obligatorio poner los par\u00e9ntesis.</li> <li>En el cuerpo podemos omitir las llaves si contiene una \u00fanica expresi\u00f3n o una \u00fanica sentencia que no retorna valor.</li> <li>Si el cuerpo contiene una \u00fanica expresi\u00f3n, \u00e9sta ser\u00e1 evaluada y la expresi\u00f3n lambda retornar\u00e1 el valor obtenido. Ojo, debemos tener en cuenta que <code>return</code> no es una expresi\u00f3n, por lo que si es la \u00fanica sentencia del cuerpo deberemos usar llaves.</li> <li>Si el cuerpo contiene una \u00fanica sentencia <code>return valor</code>, forzosamente debemos poner las llaves, ya que <code>return</code> no es una expresi\u00f3n. En este caso la expresi\u00f3n lambda retornar\u00e1 el valor retornado por <code>return</code>.</li> </ul> <p>Sugerencia</p> <p>Si el cuerpo de nuestra lambda contiene varias sentencias, se recomienda extraer dichas sentencias hacia un m\u00e9todo y hacer que la lambda contenga una \u00fanica instrucci\u00f3n correspondiente a la llamada a dicho m\u00e9todo. De esta manera se incrementa notablemente la legibilidad de nuestro c\u00f3digo, ya que no ser\u00e1 necesario usar llaves.</p> <p>En el caso de que el cuerpo de la expresi\u00f3n lambda sea una llamada a un m\u00e9todo que recibe los mismos par\u00e1metros de la expresi\u00f3n lambda, podemos usar incluso una sintaxis a\u00fan m\u00e1s simple, a trav\u00e9s de una method reference (referencia a un m\u00e9todo). Las method reference se expresan con la siguiente sintaxis <code>objeto::nombreMetodo</code> o <code>clase::nombreMetodo</code> (si se trata de un m\u00e9todo est\u00e1tico, o de un objeto no expresado expl\u00edcitamente).</p> <p>As\u00ed, el ejemplo anterior podr\u00eda ser modificado de la siguiente forma para usar method reference:</p> <pre><code>public class MainActivity extends Activity {\n// ...\nprivate void setupViews() {\nbinding.btnClickMe.setOnClickListener(this::incrementAndShow);\n}\nprivate void incrementAndShow(View v) {\ntimes++;\nshowTimes();\n}\n}\n</code></pre> <p>Warning</p> <p>Para poder usar las expresiones lambda o las method references en nuestra aplicaci\u00f3n debemos hacer que nuestro proyecto use la versi\u00f3n JDK 8 de Java.</p> <p>Para asegurarnos de que nuestro m\u00f3dulo trabaja con la versi\u00f3n 8 de Java debemos comprobar que el archivo <code>build.gradle</code> de nuestro m\u00f3dulo <code>app</code> contiene la siguiente configuraci\u00f3n:</p> <pre><code>android {\n// ...\ncompileOptions {\nsourceCompatibility = JavaVersion.VERSION_1_8\ntargetCompatibility = JavaVersion.VERSION_1_8\n}\n}\n</code></pre> <p>Warning</p> <p>Debemos tener en cuenta que si la API m\u00ednima de nuestro proyecto no es la versi\u00f3n 24, no podremos usar todas las funcionalidades de Java 8, incluso aunque lo hayamos indicado en el archivo <code>build.gradle</code> de nuestro m\u00f3dulo. Para saber m\u00e1s sobre las funcionalidad de Java 8 disponibles dependiendo de la API m\u00ednima especificada visite la web oficial de desarrollo Android</p> <p>Si tratamos de usar expresiones lambda si haber a\u00f1adido las l\u00edneas anteriores en el archivo <code>build.gradle</code> Android Studio nos mostrar\u00e1 un error y nos indicar\u00e1 si queremos que a\u00f1ada dichas l\u00edneas autom\u00e1ticamente.</p>"},{"location":"bloque_i/tema_2/page-2/#recursos-de-cadenas-con-parametros","title":"Recursos de cadenas con par\u00e1metros","text":"<p>Suele ser muy habitual que tengamos que introducir valores calculados por nuestro programa dentro de un mensaje que se le quiera mostrar al usuario. Por ejemplo, supongamos que queremos mostrar el mensaje <code>3 times</code>, donde 3 corresponde al valor de una determinada variable.</p> <p>La primera posibilidad es simplemente construir el mensaje total concatenando sus distintas partes, esto es</p> <pre><code>public class MainActivity extends Activity {\n// ...\nprivate void showTimes() {\nbinding.lblTimes.setText(times + \" \" + getString(R.string.main_times));\n}\n}\n</code></pre> <p>habiendo definido en el archivo <code>res/values/strings.xml</code> el recurso de cadena</p> <pre><code>&lt;string name=\"main_times\"&gt;times&lt;/string&gt;\n</code></pre> <p>Afortunadamente, Android nos proporciona un m\u00e9todo m\u00e1s adecuado para tratar este tipo de situaciones. As\u00ed, podemos especificar que un determinado recurso de cadena contenga una serie de par\u00e1metros, de manera que al obtener el recurso podamos indicar los argumentos correspondientes a los valores de los par\u00e1metros.</p> <p>Sugerencia</p> <p>Siempre es preferible que definas recursos de cadena con par\u00e1metros frente a concatenar valores y cadenas, incluso en el caso de Kotlin, y sus template string (que estudiaremos m\u00e1s tarde), ya que la definici\u00f3n de recursos de cadena nos ayuda a la internacionalizaci\u00f3n de nuestra aplicaci\u00f3n, de manera que la cadena se pueda mostrar en el idioma del usuario.</p> <p>Estos recursos siguen siendo recursos de cadena normales, por lo que normalmente se definen en el archivo <code>/res/values/strings.xml</code>. As\u00ed en el ejemplo anterior crear\u00edamos el recurso de cadena:</p> <pre><code>&lt;string name=\"main_times\"&gt;%1$d times&lt;/string&gt;\n</code></pre> <p>donde el <code>1$</code>indica que el valor asignado a dicho par\u00e1metro corresponder\u00e1 al valor proporcionado como primer argumento adicional y el <code>%d</code> indica que el valor del argumento deber\u00e1 ser un valor entero (si fuera una cadena ser\u00eda <code>%s</code> y si fuera un valor real <code>%f</code>). Si tuvi\u00e9ramos m\u00e1s de un par\u00e1metro es segundo ser\u00eda <code>2$</code>, el tercero <code>3$</code> y as\u00ed sucesivamente.</p> <p>Sugerencia</p> <p>El uso de <code>1$</code>, <code>2$</code> no es obligatorio, es decir, podemos indicar simplemente <code>%d</code>, <code>%s</code>, etc., pero se recomienda especificar el n\u00famero de argumento por si en un idioma diferente tenemos que cambiar el orden en el que usan los argumentos en la cadena de formato.</p> <p>Para poder especificar los argumentos correspondientes a los valores que deben tomar los par\u00e1metros, a la hora de obtener el recurso usaremos el m\u00e9todo <code>getString(resId, arg\u2026)</code> de la clase <code>Resources</code>, que est\u00e1 sobrecargado para recibir, adem\u00e1s del <code>resId</code> de la cadena, los valores que queremos que tomen los par\u00e1metros (que deberemos pasar en el orden adecuado). Esta versi\u00f3n de <code>getString()</code> tambi\u00e9n existe directamente en nuestra actividad, sin tener ni siquiera que obtener el objeto <code>Resources</code>. Por ejemplo:</p> <pre><code>public class MainActivity extends Activity {\n// ...\nprivate void showTimes() {\nbinding.lblTimes.setText(getString(R.string.main_times, times));\n}\n}\n</code></pre> <p>Ten en cuenta</p> <p>Internamente el m\u00e9todo <code>getString()</code> usa el m\u00e9todo <code>format</code> de la clase <code>String</code> de Java, y por este motivo la especificaci\u00f3n de los valores es exactamente el mismo que este \u00faltimo.</p>"},{"location":"bloque_i/tema_2/page-2/#plurals","title":"Plurals","text":"<p>En algunas ocasiones el texto de un recurso de cadena depende de una cierta cantidad num\u00e9rica. Supongamos que queremos mostrar un texto con el n\u00famero de veces que se ha hecho click; en este caso el texto podr\u00eda ser \"1 time\", \"2 time**s**\". Como vemos, dependiendo de si es m\u00e1s de una vez debemos usar el plural en vez del singular.</p> <p>Aunque podr\u00edamos definir dos recursos de cadena distintos y decidir cu\u00e1l usar dependiendo del valor de la variable, Android nos proporciona una funcionalidad muy interesante consistente en definir un \u00fanico recurso de cadena que contenga en su interior la especificaci\u00f3n de las distintas cadenas que deben usarse dependiendo de una determinada cantidad. Estos recursos reciben el nombre de recursos de plural (plurals). Veamos un ejemplo:</p> <pre><code>&lt;plurals name=\"main_times\"&gt;\n&lt;item quantity=\"one\"&gt;%1$d time&lt;/item&gt;\n&lt;item quantity=\"other\"&gt;%1$d times&lt;/item&gt;\n&lt;/plurals&gt;\n</code></pre> <p>Sugerencia</p> <p>Los recursos de plural suelen definirse dentro de su propio fichero <code>/res/values/plurals.xml</code>, aunque al ser recursos de valor no es estrictamente necesario, por lo que podr\u00edamos definirlos, por ejemplo, dentro del archivo <code>string.xml</code>.</p> <p>El atributo <code>quantity</code> puede tomar uno de los siguientes valores: <code>zero</code> (cero), <code>one</code> (uno), <code>two</code> (dos), <code>few</code> (pocos, tres o cuatro), <code>many</code> (muchos, m\u00e1s de 10), <code>other</code> (resto de casos).</p> <p>Warning</p> <p>Algunos de estos valores pueden no tener efecto dependiendo del idioma del que se trate. Por ejemplo, en el idioma espa\u00f1ol, sint\u00e1cticamente hablando, el uso del singular/plural para la cantidad cero no difiere del uso del singular/plural de cualquier valor distinto de 1, como por ejemplo \"0 veces\" y \"4 veces\". Por este motivo si usamos los valores <code>zero</code> y <code>other</code> a la vez en la definici\u00f3n de un plural y el idioma del dispositivo corresponde al espa\u00f1ol, la cadena asignada a <code>zero</code> nunca es usada, aunque el valor de la variable sea 0, sino que en su lugar se usa la cadena asignada a <code>other</code>. En espa\u00f1ol sucede exactamente igual con los valores <code>two</code>, <code>few</code> o <code>many</code>.</p> <p>Para poder obtener un recurso de plurales desde nuestro c\u00f3digo Java o Kotlin debemos usar el m\u00e9todo <code>getQuantityString(resId, quantity)</code> de la clase <code>Resources</code>, al que le pasaremos el <code>resId</code> del plural y la cantidad a usar para determinar cu\u00e1l de las cadenas debe mostrarse.</p> <p>Ten en cuenta</p> <p>A diferencia de <code>getString()</code>, el m\u00e9todo <code>getQuantityString()</code> no se encuentra definido en la clase <code>Activity</code>, sino tan s\u00f3lo en la clase <code>Resources</code>, por lo que tendremos forzosamente que obtener desde objeto desde la actividad.</p> <p>Si adem\u00e1s las cadenas incluidas dentro del recurso plural contienen par\u00e1metros, entonces podemos usar una versi\u00f3n sobrecargada del m\u00e9todo <code>getQuantityString(resId, quantity, arg\u2026)</code>, que recibe el <code>resId</code> del plural, la cantidad a usar para determinar cu\u00e1l de las cadenas debe usarse, y adem\u00e1s otra serie de argumentos correspondientes a los valores para los par\u00e1metros de la cadena elegida.</p> <p>As\u00ed, en nuestro proyecto har\u00edamos:</p> <pre><code>public class MainActivity extends Activity {\n// ...\nprivate void showTimes() {\nbinding.lblTimes.setText(\ngetResources().getQuantityString(R.plurals.main_times, times, times));\n}\n}\n</code></pre> <p>en cuyo caso, el primer <code>times</code> es usado para determinar qu\u00e9 cadena escoger de entre las pertenecientes al recurso de plural, y el segundo <code>times</code> se usa como argumento del par\u00e1metro de la cadena seleccionada.</p> <p>Ten en cuenta</p> <p>En los sistemas operativos m\u00f3viles no existe el concepto de click con bot\u00f3n derecho del rat\u00f3n, ya que normalmente no se usa ning\u00fan dispositivo apuntador, sino que la pantalla del dispositivo es t\u00e1ctil. Sin embargo existe una acci\u00f3n similar conocida como hacer click largo, consistente en dejar pulsada la vista durante m\u00e1s tiempo del habitual.</p> <p>Para saber m\u00e1s sobre esta acci\u00f3n investiga en la documentaci\u00f3n oficial https://developer.android.com/index.html acerca de la interfaz <code>OnLongClickListener</code>.</p>"},{"location":"bloque_i/tema_2/page-3/","title":"3 Botones compuestos","text":""},{"location":"bloque_i/tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Los botones compuestos son botones que tiene un funcionalidad diferente a los botones comunes. Existen varios tipos de botones compuestos:</p> <ul> <li>CheckBox</li> <li>SwitchCompat</li> <li>RadioButton</li> </ul>"},{"location":"bloque_i/tema_2/page-3/#checkbox","title":"CheckBox","text":"<p>Un <code>Checkbox</code> o casilla de verificaci\u00f3n es una vista que puede encontrarse en dos estados: checked (marcado) o unchecked (desmarcado), pasando de un estado al otro cuando se hace click sobre \u00e9l (toggle).</p> <p> Figura 6 - Estilos est\u00e1ndar de checkbox</p> <p>La clase <code>CheckBox</code> es una subclase de <code>CompoundButton</code>, <code>Button</code>, <code>TextView</code> y <code>View</code>, por lo que hereda sus propiedades y m\u00e9todos.</p> <p> Figura 7 - Clase CompoundButton</p> <p>Sus atributos XML m\u00e1s importantes son:</p> <ul> <li><code>android:text</code>: Texto mostrado.</li> <li><code>android:checked</code>: Indica si el bot\u00f3n se encuentra inicialmente en estado checked. Por defecto es <code>false</code></li> </ul> <p>En el siguiente c\u00f3digo se define un <code>CheckBox</code>:</p> <pre><code>&lt;CheckBox\nandroid:id=\"@+id/chkPolitely\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"@string/main_chkPolitely\"\nandroid:checked=\"true\" /&gt;\n</code></pre> <p>Los m\u00e9todos m\u00e1s usados de la clase <code>CheckBox</code> son:</p> <ul> <li><code>isChecked()</code>: Retorna <code>true</code> si el bot\u00f3n se encuentra en el estado checked.</li> <li><code>setChecked(boolean)</code>: Recibe <code>true</code> para hacer que el bot\u00f3n pase a estado checked y <code>false</code> para el estado unchecked.</li> <li><code>toggle()</code>: Cambia el estado del bot\u00f3n desde checked a unchecked o viceversa.</li> <li><code>setOnCheckedChangeListener(onCheckedChangeListener)</code>: Establecemos para el checkbox el objeto listener de una clase que implemente la interfaz <code>OnCheckedChangeListener</code> cuyo m\u00e9todo de callback ser\u00e1 llamado cuando el estado del checkbox cambie, ya sea por interacci\u00f3n del usuario o desde c\u00f3digo Java o Kotlin. Como se trata de una interfaz funcional podemos usar una expresi\u00f3n lambda.</li> </ul> <p>Por ejemplo:</p> <pre><code>binding.chkPoliltely.setOnCheckedChangeListener((buttonView, isChecked) -&gt; // ...\n);\nif (binding.chkPolitely.isChecked()) {\nbinding.chkPolitely.setChecked(false);\n}\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#switchcompat","title":"SwitchCompat","text":"<p>Esta vista corresponde a la representaci\u00f3n visual de un interruptor o conmutador, que puede encontrarse en dos estados posibles: pulsado/activado (on o checked) o no pulsado/desactivado (off o unchecked), similar a un checkbox. Sin embargo, a diferencia de este \u00faltimo, aparte de haciendo click, en una vista <code>SwitchCompat</code> para pasar de un estado a otro el usuario tambi\u00e9n podr\u00e1 deslizar el interruptor a derecha o izquierda.</p> <p> Figura 8 - Estilos est\u00e1ndar para Switch, by Google</p> <p>La vista<code>SwitchCompat</code> hereda de <code>CompoundButton</code>, <code>Button</code>, <code>TextView</code> y <code>View</code>, por lo que heredan sus propiedades y m\u00e9todos.</p> <p>Sus atributos XML m\u00e1s importantes son:</p> <ul> <li><code>android:text</code>: Texto que acompa\u00f1a al interruptor.</li> <li><code>android:checked</code>: Indica si el bot\u00f3n se encuentra inicialmente en estado on. Por defecto es <code>false</code>.</li> </ul> <p>En el siguiente c\u00f3digo se define una vista <code>SwitchCompat</code> de ejemplo. Debemos fijarnos en que al pertenecer a la librer\u00eda de soporte a la hora de especificar el nombre de la clase debemos indicar el nombre completo:</p> <pre><code>&lt;androidx.appcompat.widget.SwitchCompat  android:id=\"@+id/swtPolitely\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:checked=\"true\"/&gt;\n</code></pre> <p>Los m\u00e9todos m\u00e1s usados de la clase <code>SwitchCompat</code> son los mismos que los de la clase <code>CheckBox</code>.</p> <p>Sugerencia</p> <p>Existe otro tipo de vista m\u00e1s antigua, llamada <code>Switch</code> que no es compatible con las nuevas versiones de Android, de ah\u00ed que nuestra vista se llame <code>SwitchCompat</code> y sea la que debes usar.</p>"},{"location":"bloque_i/tema_2/page-3/#radiobutton-y-radiogroup","title":"RadioButton y RadioGroup","text":"<p>Al igual que un <code>CheckBox</code>, un bot\u00f3n de opci\u00f3n (radio button) puede encontrarse en dos estados posibles: checked (marcado) o unchecked (desmarcado). Sin embargo, una vez que un radio button ha sido seleccionado, no puede ser desmarcado individualmente. De hecho, los radio buttons casi siempre van a ser agrupados de manera que, en un momento dado, s\u00f3lo uno de los del grupo pueda estar en estado checked, permaneciendo el resto en estado unchecked. Al igual que <code>CheckBox</code> y <code>Switch</code>, la clase <code>RadioButton</code> extiende de <code>CompoundButton</code>, <code>Button,</code> <code>TextView</code> y <code>View</code>, por lo hereda sus propiedades y m\u00e9todos.</p> <p> Figura 9 - Estilos est\u00e1ndar para RadioButton, by Google</p> <p>Para poder agrupar varios radio buttons usaremos un tipo de contenedor denominado <code>RadioGroup</code>, que es una subclase de <code>LinearLayout</code> (que veremos con detenimiento dentro de muy poco), <code>ViewGroup</code> y <code>View</code>. <code>RadioGroup</code> crea un \u00e1mbito de multiexclusi\u00f3n para un conjunto de radio buttons, de manera que al marcar un radio button del grupo, se desmarcan el resto de radio buttons del mismo. Inicialmente todos los radio buttons del grupo aparecen desmarcados.</p> <p>Para conocer en un momento dado qu\u00e9 radio button del grupo est\u00e1 marcado se utilizar\u00e1 su atributo <code>id</code>, por lo que deberemos especificar siempre dicho atributo para cada radio button.</p> <p> Figura 9 - Clase RadioGroup</p> <p>Sus atributos XML m\u00e1s importantes son:</p> <ul> <li><code>android:orientation</code>: Establece como se sit\u00faan los radio buttons en el contenedor, <code>vertical</code> (verticalmente) o <code>horizontal</code> (horizontalmente). Este atributo es heredado de <code>LinearLayout</code>.</li> <li><code>android:checkedButton</code>: Recibe el <code>id</code> del radio button hijo del radiogroup que debe estar seleccionado inicialmente.</li> </ul> <p>Los m\u00e9todos m\u00e1s interesantes de la clase <code>RadioGroup</code> son:</p> <ul> <li><code>check(radioButtonIdResId)</code>: Selecciona (marca) el radio button cuyo <code>id</code> corresponde con el valor recibido como par\u00e1metro.</li> <li><code>clearCheck()</code>: Desmarca el radio button seleccionado, de manera que todos los radio buttons del grupo permanecen desmarcados.</li> <li><code>getCheckedRadioButtonId()</code>: Retorna el identificador (<code>id</code>) del radio button seleccionado del grupo. Si no hay ninguno seleccionado, retorna <code>-1</code>.</li> <li><code>setOnCheckedChangeListener(onCheckedChangeListener)</code>: Registramos el objeto listener de una clase que implementa la interfaz <code>OnCheckedChangeListener</code> cuyo m\u00e9todo de callback ser\u00e1 llamado por el sistema cuando se cambie, ya sea el usuario o desde c\u00f3digo, el radio button seleccionado dentro del grupo.</li> </ul> <p>En nuestro fichero de layout XML incluiremos una etiqueta <code>&lt;RadioGroup&gt;</code> y dentro de la que insertaremos las distintas etiquetas <code>&lt;RadioButton&gt;</code> correspondientes a los radio button que conforman el grupo. Es muy importante que asignemos a cada radio button un identificador para poder saber en un momento dado de nuestra ejecuci\u00f3n qu\u00e9 radio button del grupo est\u00e1 en estado checked:</p> <pre><code>&lt;RadioGroup\nandroid:id=\"@+id/rdgColor\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:orientation=\"vertical\"&gt;\n&lt;RadioButton\nandroid:id=\"@+id/rdbRed\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"@string/main_rdbRed\" /&gt;\n&lt;RadioButton\nandroid:id=\"@+id/rdbBlue\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"@string/main_rdbBlue\" /&gt;\n&lt;/RadioGroup&gt;\n</code></pre> <p>En el siguiente c\u00f3digo se muestra el uso en tiempo de ejecuci\u00f3n de algunos de los m\u00e9todos m\u00e1s importantes de <code>RadioGroup</code>:</p> <pre><code>binding.rdgColor.clearCheck();\nbinding.rdgColor.check(R.id.rdbColorAzul);\nint selectedColorRadioButtonId = binding.rdg.getCheckedRadioButtonId();\n</code></pre> <p>Respecto a la clase <code>RadioButton</code>, sus m\u00e9todos principales son los mismos que los de la clase <code>CheckBox</code>, aunque normalmente no se trabaja con ellos individualmente, sino con el <code>RadioGroup</code>, como acabamos de ver.</p>"},{"location":"bloque_i/tema_2/page-4/","title":"4 Otras Vistas","text":""},{"location":"bloque_i/tema_2/page-4/#imageview","title":"ImageView","text":"<p>La clase <code>ImageView</code> permite mostrar una imagen en pantalla. Es una subclase directa de <code>View</code>, por lo que hereda sus m\u00e9todos y propiedades. A diferencia de la clase <code>Button</code>, <code>ImageView</code> no es subclase de <code>TextView</code>, por lo que no hereda de ella, y por tanto, tampoco hereda todos sus atributos.</p> <p> Figura 9 - Clases ImageView</p> <p>Sus atributos XML m\u00e1s importantes son:</p> <ul> <li><code>android:src</code>: Imagen a mostrar en el <code>ImageView</code>. Normalmente esta propiedad recibir\u00e1 el resId de un recurso de imagen (drawable) contenido en la carpeta <code>res/drawable</code> del proyecto, como por ejemplo <code>android:src=\"@drawable/photo\"</code>. Para establecerlo desde c\u00f3digo utilizaremos el m\u00e9todo <code>setImageResource(drawableResId)</code>.</li> <li><code>android:maxWidth</code>: Anchura m\u00e1xima de la imagen.</li> <li><code>android:maxHeight</code>: Altura m\u00e1xima de la imagen.</li> <li><code>android:scaleType</code>: Controla como se posicionar\u00e1 y redimensionar\u00e1 la imagen para adaptarse al tama\u00f1o del ImageView. El valor m\u00e1s usado es <code>centerCrop</code>, que redimensiona la imagen manteniendo la relaci\u00f3n de aspecto para que su alto y ancho sea igual o mayor, respectivamente, que el alto y ancho del <code>ImageView</code>, de manera que coloca la imagen en el centro del <code>ImageView</code> y recorta la parte de la imagen que queda fuera de los l\u00edmites del <code>ImageView</code>, por lo que puede que la imagen no se vea completa, aunque s\u00ed ocupar\u00e1 todo el espacio proporcionado por el <code>ImageView</code>.</li> <li><code>android:contentDescription</code>: Descripci\u00f3n textual de la imagen, para mejorar la accesibilidad. Es heredada de <code>View</code>, pero con <code>ImageView</code> tiene mucho m\u00e1s sentido su uso.</li> </ul> <p>Propiedad scaleType</p> <p>Podemos ver un ejemplo de los distintos valores posibles para la propiedad <code>android:scaleType</code> en el enlace http://etcodehome.blogspot.com.es/2011/05/android-imageview-scaletype-samples.php.</p> <pre><code>&lt;ImageView\nandroid:id=\"@+id/imgPhoto\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:src=\"@drawable/photo\"\nandroid:scaleType=\"centerCrop\"\nandroid:contentDescription=\"@string/main_imgPhoto\"/&gt;\n</code></pre> <p>Tenemos disponible tambi\u00e9n un atributo espec\u00edfico para el editor visual de layouts llamado <code>tools:src</code>, que se aplica a una vista ImageView para indicar la imagen que debe mostrar el editor visual, aunque no hayamos especificado el atributo <code>android:src</code>. Podemos usar alguna imagen proporcionada por Android Studio, mediante <code>@tools:sample/avatars</code>.</p> <p>Cabe destacar entre los m\u00e9todos de esta clase la familia de m\u00e9todos <code>setImage...()</code> que permiten establecer en tiempo de ejecuci\u00f3n la imagen que mostrar\u00e1 el <code>ImageView</code> pas\u00e1ndole como argumento el objeto correspondiente a la imagen. As\u00ed tenemos <code>setImageBitmap(bitmap)</code>, <code>setImageDrawable(drawable)</code>, <code>setImageResource(drawableREsId)</code>, <code>setImageURI(uri)</code>.</p> <p>En el siguiente c\u00f3digo se muestra el uso de uno de estos m\u00e9todos:</p> <pre><code>binding.imgPhoto.setImageResource(R.drawable.photo);\n</code></pre> <p>Warning</p> <p>La vista <code>ImageView</code> no proporciona ning\u00fan m\u00e9todo para mostrar una imagen disponible en la red a trav\u00e9s de una determinada URL. Como veremos m\u00e1s adelante, para tal fin haremos uso de alguna librer\u00eda externa, como Coil, Glide o Picasso.</p>"},{"location":"bloque_i/tema_2/page-4/#edittext","title":"EditText","text":"<p>Una caja de texto es una zona rectangular de pantalla que puede recibir el foco y en el que el usuario puede introducir y editar un texto. En Android, las cajas de texto se implementan gracias a la clase <code>EditText</code>, que es, una subclase de <code>TextView</code>, por lo que hereda sus propiedades y m\u00e9todos.</p> <p> Figura 10 - Clases EditText</p> <p>En la imagen podemos ver el aspecto visual de un <code>EditText</code> dependiendo del estado en el que se encuentre:</p> <p> Figura 11 - Estilos est\u00e1ndar para EditText, by Google</p> <p>A continuaci\u00f3n destacamos algunos atributos XML de los <code>EditText</code>:</p> <ul> <li><code>android:capitalize</code>: Pone en may\u00fasculas de manera autom\u00e1tica el texto, ya sea la primera letra de la frase, la primera letra de cada palabra o todos los caracteres. Es un atributo de <code>TextView</code>. - <code>android:hint</code>: Consejo (tooltip o hint) que se muestra al usuario cuando no se ha introducido ning\u00fan texto a\u00fan. Es un atributo de <code>TextView</code>.</li> <li><code>android:hint</code>: Consejo (tooltip o hint) que se muestra al usuario cuando no se ha introducido ning\u00fan texto a\u00fan. Es un atributo de <code>TextView</code>.</li> <li><code>android:inputType</code>: Indica el tipo de dato que va a ser introducido en el cuadro de texto, limitando los caracteres que pueden ser introducidos e incluso las teclas que aparecen en el teclado virtual del dispositivo. Podemos incluir un \u00fanico valor o varias posibilidades combinadas con el car\u00e1cter <code>|</code>. Algunos de los valores que podemos especificar son: <code>text</code> (texto gen\u00e9rico), <code>textEmailAddress</code> (direcci\u00f3n de email), <code>textPersonName</code> (nombre de una persona), <code>textPassword</code> (contrase\u00f1a), <code>textVisiblePassword</code> (contrase\u00f1a visible), <code>number</code> (n\u00famero), <code>numberDecimal</code> (n\u00famero real), <code>phone</code> (n\u00famero de tel\u00e9fono), <code>datetime</code> (fecha y hora), <code>date</code> (fecha), <code>time</code> (hora), <code>textMultiLine</code> (varias l\u00edneas de alto).</li> <li><code>android:digits</code>: Cadena de caracteres que contiene los \u00fanicos caracteres v\u00e1lidos que pueden ser introducidos en el <code>EditText</code>. Por ejemplo, <code>android:digits=\"0123456789\"</code> s\u00f3lo permite introducir d\u00edgitos, ni siquiera <code>.</code> ni <code>,</code> La mayor\u00eda de las veces no se usa esta propiedad porque con <code>android:inputType</code> tenemos suficiente.</li> <li><code>android:maxLength</code>: N\u00famero m\u00e1ximo de caracteres que podr\u00e1n introducirse en el <code>EditText</code>. Muy \u00fatil cuando, por ejemplo, dicho dato va a ser almacenado en una base de datos estructurada donde la columna de la tabla correspondiente tiene un tama\u00f1o fijo.</li> <li><code>android:ems</code>: Anchura del <code>EditText</code> en n\u00famero de caracteres. S\u00f3lo tiene sentido cuando la propiedad <code>android:width</code> tiene el valor <code>wrap_content</code>.</li> <li><code>android:lines</code>: N\u00famero de l\u00edneas de alto que ocupa visualmente la vista. S\u00f3lo tiene sentido si <code>android:inputType</code> incluye entre sus valores <code>textMultiLine</code>.</li> <li><code>android:maxLines</code>: N\u00famero de l\u00edneas de alto que como m\u00e1ximo ocupar\u00e1 visualmente la vista. S\u00f3lo tiene sentido si <code>android:inputType</code> incluye entre sus valores <code>textMultiLine</code>. Si el valor de <code>android:lines</code> es menor al de <code>android:maxLines</code> el <code>EditText</code> podr\u00e1 crecer conforme agreguemos l\u00edneas.</li> </ul> <p>En el siguiente c\u00f3digo definimos un <code>EditText</code> en el fichero de layout XML:</p> <pre><code>&lt;EditText\nandroid:id=\"@+id/txtName\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:inputType=\"textPersonName\" /&gt;\n</code></pre> <p>Sin duda la propiedad m\u00e1s importante de <code>EditText</code> es su texto, que podemos obtener o establecer mediante el par de m\u00e9todos <code>getText()</code> y <code>setText()</code>, heredados de <code>TextView</code>.</p> <p>Warning</p> <p>Debemos tener en cuenta que el m\u00e9todo <code>getText()</code> de un <code>EditText</code> retorna un objeto de la clase <code>Editable</code>, y no una cadena, por lo que si queremos pasarlo a cadena deberemos usar el m\u00e9todo <code>toString()</code> del objeto <code>Editable</code>.</p> <p>Sin embargo <code>setText()</code> recibe un <code>CharSequence</code>, por lo que podemos pasarle directamente una cadena de caracteres.</p> <p>En el siguiente c\u00f3digo se muestra el uso de algunos de los m\u00e9todos m\u00e1s importantes de <code>EditText</code>:</p> <pre><code>String name = binding.txtName.getText().toString();\nbinding.txtName.setText(name.toUpperCase());\n</code></pre> <p>Otra propiedad muy interesante es la posibilidad de mostrar un mensaje de error en el <code>EditText</code> cuando su contenido no sea v\u00e1lido. Para ello usaremos el m\u00e9todo <code>setError(message)</code>. Si queremos que desaparezca el error debemos asignarle <code>setError(null)</code>.</p>"},{"location":"bloque_i/tema_2/page-4/#progress-bar","title":"Progress Bar","text":"<p>Se trata de una vista que sirve de indicador visual del progreso que se est\u00e1 llevando a cabo en una determinada operaci\u00f3n.</p> <p> Figura 12 - Clase ProgressBar</p> <p>El progreso puede ser:</p> <ul> <li>determinado: Conocemos de antemano el \"valor\" final del progreso. La animaci\u00f3n va desde el valor inicial hasta el valor final. La barra puede mostrar un segundo progreso secundario, como por ejemplo el nivel de buffer durante un streaming.</li> <li>indeterminado: No conocemos o no existe un \"valor\" final del progreso, sino que simplemente la operaci\u00f3n se inicia y finaliza en alg\u00fan momento. Por tanto se muestra una animaci\u00f3n c\u00edclica para indicar el progreso.</li> <li>indeterminado y luego determinado: Inicialmente no conocemos el \"valor\" final del progreso, pero posteriormente se obtiene y se comienza el progreso. Inicialmente se muestra una animaci\u00f3n c\u00edclica representativa de progreso indeterminado y una vez obtenido el valor final se muestra como progreso determinado.</li> </ul> <p> Figura 13 - Estilos est\u00e1ndar para ProgressBar, by Google</p> <p> Figura 14 - Estilos est\u00e1ndar para ProgressBar circulares, by Google</p> <p>La librer\u00eda de soporte support library incluye una serie de estilos para las progress bar, que podremos aplicar a la vista mediante el atributo <code>style</code>:</p> <ul> <li><code>@style/Widget.AppCompat.ProgressBar.Horizontal</code>: Barra de progreso.</li> <li><code>@style/Widget.AppCompat.ProgressBar</code>: C\u00edrculo de progreso.</li> </ul> <p>Warning</p> <p>Recuerda que el atributo style se usa sin el namespace <code>android:</code>.</p> <p>Los atributos m\u00e1s importantes de esta vista son:</p> <ul> <li><code>android:indeterminate=\"false\"</code>: para indicar que se trata de progreso determinado. Por defecto es <code>true</code> (indeterminado).</li> <li><code>android:max</code>: Valor final (m\u00e1ximo) de progreso. Para progreso determinado.</li> <li><code>android:progress</code>: Valor de progreso actual. Para progreso determinado.</li> <li><code>android:secondaryProgress</code>: Valor de progreso secundario actual. Para progreso determinado con progreso secundario.</li> </ul> <p>Los m\u00e9todos m\u00e1s importantes de esta vista son:</p> <ul> <li><code>setProgress()</code>: Permite establecer el valor actual de progreso. Para progreso determinado.</li> <li><code>setSecondaryProgress()</code>: Permite establecer el valor actual de progreso secundario. Para progreso determinado con progreso secundario.</li> <li><code>setIndeterminate(false)</code>: Permite establecer el progreso como indeterminado. Especialmente \u00fatil en el caso del progreso indeterminado y luego determinado, ya que al obtener el valor final de progreso se llama a este m\u00e9todo para convertir el progreso indeterminado en determinado.</li> </ul>"},{"location":"bloque_i/tema_2/page-5/","title":"5 Entorno de Android","text":""},{"location":"bloque_i/tema_2/page-5/#proyecto-login","title":"Proyecto Login","text":"<p>En este proyecto desarrollaremos la t\u00edpica pantalla de login en la que el usuario introduce el nombre de usuario y la contrase\u00f1a y pulsa un bot\u00f3n para hacer login.</p> <p> Figura 15 - Proyecto Login en ejecuci\u00f3n</p> <p>Crea un nuevo proyecto usando el asistente.</p> <p>Primero, activa ViewBinding en el archivo <code>build.gradle</code> de tu m\u00f3dulo:</p> <pre><code>android {\n// ... \nviewBinding {\nenabled=true\n}\n}\n</code></pre> <p>Luego, modifica el layout generado por el asistente para la actividad de manera que pase a llamar <code>res/layout/main_activity.xml</code> y su contenido sea el siguiente:</p> <pre><code>&lt;LinearLayout\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/llRoot\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:orientation=\"vertical\"\nandroid:padding=\"@dimen/main_margin\"&gt;\n&lt;ImageView\nandroid:id=\"@+id/imgLogo\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"200dp\"\nandroid:src=\"@drawable/logo_transparent\"\nandroid:scaleType=\"centerInside\"\nandroid:contentDescription=\"@string/main_imgLogo\"/&gt;\n&lt;TextView\nandroid:id=\"@+id/lblUsername\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"@string/main_lblUsername\"/&gt;\n&lt;EditText\nandroid:id=\"@+id/txtUsername\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:hint=\"@string/main_txtUsername\"\nandroid:inputType=\"text\"/&gt;\n&lt;TextView\nandroid:id=\"@+id/lblPassword\"\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"@string/main_lblPassword\"\nandroid:layout_marginTop=\"@dimen/main_margin\"/&gt;\n&lt;EditText\nandroid:id=\"@+id/txtPassword\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:hint=\"@string/main_txtPassword\"\nandroid:inputType=\"textPassword\"/&gt;\n&lt;Button\nandroid:id=\"@+id/btnLogin\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:text=\"@string/main_btnLogin\"\nandroid:layout_marginTop=\"@dimen/main_margin\"/&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Creamos tambi\u00e9n los siguientes recursos de cadena en el archivo <code>res/values/strings.xml</code>:</p> <pre><code>&lt;resources&gt;\n&lt;string name=\"app_name\"&gt;Login&lt;/string&gt;\n&lt;string name=\"main_lblUsername\"&gt;Username&lt;/string&gt;\n&lt;string name=\"main_txtUsername\"&gt;(username)&lt;/string&gt;\n&lt;string name=\"main_lblPassword\"&gt;Password&lt;/string&gt;\n&lt;string name=\"main_btnLogin\"&gt;Login&lt;/string&gt;\n&lt;string name=\"main_txtPassword\"&gt;(password)&lt;/string&gt;\n&lt;string name=\"main_imgLogo\"&gt;Logo&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre> <p>y los siguientes recursos de dimensi\u00f3n en el archivo <code>res/values/dimens.xml</code>:</p> <pre><code>&lt;resources&gt;\n&lt;dimen name=\"main_margin\"&gt;16dp&lt;/dimen&gt;\n&lt;/resources&gt;\n</code></pre> <p>Nuestra clase <code>MainActivity</code> contendr\u00e1 inicialmente el siguiente c\u00f3digo:</p> <pre><code>public class MainActivity extends AppCompatActivity {\nprivate MainActivityBinding binding;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nbinding = MainActivityBinding.inflate(getLayoutInflater());\nsetContentView(binding.getRoot());\nsetupViews();\n}\nprivate void setupViews() {\nbinding.btnLogin.setOnClickListener(v -&gt; btnLoginOnClick());\n}\nprivate void btnLoginOnClick() {\nString username = binding.txtUsername.getText().toString();\nString password = binding.txtPassword.getText().toString();\nif (isValidForm(username, password)) {\nlogin(username, password);\n}\n}\nprivate boolean isValidForm(String username, String password) {\nreturn isValidUserName(username) &amp;&amp; isValidPassword(password);\n}\nprivate boolean isValidUserName(String username) {\nreturn !TextUtils.isEmpty(username);\n}\nprivate boolean isValidPassword(String password) {\nreturn !TextUtils.isEmpty(password);\n}\nprivate void login(String username, String password) {\n// TODO: Code to do login\n// ...\n}\n}\n</code></pre> <p>Como vemos, s\u00f3lo se llama al m\u00e9todo <code>login(username, password)</code> si el formulario es v\u00e1lido, es decir si se han introducido los dos datos, ya que ambos son obligatorios.</p> <p>Otro aspecto curiosos es que hemos usado el m\u00e9todo est\u00e1tico <code>TextUtils.isEmpty(string)</code> en vez de simplemente usar el m\u00e9todo <code>string.isEmpty()</code>. El motivo de ello es que en el primer caso si la cadena es <code>null</code> se retornar\u00e1 <code>true</code>, mientras que en el segundo caso se producir\u00e1 un error en ejecuci\u00f3n <code>NullPointerException</code>.</p> <p>Nos queda pendiente de hacer el c\u00f3digo que simule el establecimiento del login. En nuestro caso consistir\u00e1 en mostrar un mensaje informativo temporal al usuario, como veremos en el siguiente apartado.</p>"},{"location":"bloque_i/tema_2/page-5/#toast","title":"Toast","text":"<p>Toda aplicaci\u00f3n interactiva requiere de alg\u00fan mecanismo para notificar al usuario cualquier tipo de informaci\u00f3n o evento que sea relevante. Android nos proporciona varias maneras de llevar a cabo esta notificaci\u00f3n. En este apartado estudiaremos los llamados toasts.</p> <p>Un toast (brindis en espa\u00f1ol) es un mensaje emergente que se muestra en pantalla durante unos segundos y desaparece autom\u00e1ticamente transcurrido dicho tiempo, sin ser necesario ning\u00fan tipo de actuaci\u00f3n por parte del usuario. La principal ventaja de los toast es que no interfieren en las acciones que est\u00e9 realizando el usuario, ya que no requieren de su intervenci\u00f3n, de manera que no debe dejar de hacer lo que estaba haciendo para atender al mensaje. De hecho, los toasts ni siquiera reciben el foco mientras son mostrados.</p> <p> Figura 16 - Toast</p> <p>La principal ventaja de los toast es que no interfieren en las acciones que est\u00e9 realizando el usuario, ya que no requieren de su intervenci\u00f3n, de manera que no debe dejar de hacer lo que estaba haciendo para atender al mensaje. De hecho, los toasts ni siquiera reciben el foco mientras son mostrados.</p> <p>Sugerencia</p> <p>Los toasts son muy adecuados para mostrar mensajes r\u00e1pidos y sencillos al usuario, ya que no son molestos, pero no deber\u00edan ser usados para hacer notificaciones importantes, ya que puede que el usuario no les preste demasiada atenci\u00f3n antes de que dejen de mostrarse.</p> <p>Para crear los toast haremos uso de la clase <code>Toast</code> y, en concreto, de su m\u00e9todo est\u00e1tico <code>makeText()</code>, que recibir\u00e1 como par\u00e1metros el contexto en el que se debe mostrar, el texto del mensaje y su duraci\u00f3n, para la que emplearemos las constantes definidas en la clase <code>Toast</code> denominadas <code>LENGTH_SHORT</code> (duraci\u00f3n corta) y <code>LENGTH_LONG</code> (duraci\u00f3n larga). El m\u00e9todo <code>makeText()</code> retorna el objeto <code>Toast</code> correspondiente, que podremos mostrar en pantalla mediante su m\u00e9todo <code>show()</code>. Ve\u00e1moslo en un ejemplo:</p> <pre><code>Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n</code></pre> <p>Por defecto los toast aparecen en la parte inferior de la pantalla en un rect\u00e1ngulo gris semitransparente.</p> <p>Warning</p> <p>Debemos tener cuidado de no olvidar llamar al m\u00e9todo <code>show()</code> del objeto <code>Toast</code> que hayamos creado, o de lo contrario el mensaje no se mostrar\u00e1.</p> <p>Como vemos para poder crear un toast debemos pasar como argumento el contexto. Pero \u00bfqu\u00e9 es eso del contexto? Lo estudiamos a continuaci\u00f3n.</p>"},{"location":"bloque_i/tema_2/page-5/#context","title":"Context","text":"<p>La clase <code>Context</code> corresponde a una clase abstracta, cuya implementaci\u00f3n es proporcionada por el sistema operativo Android.</p> <p>Context</p> <p>El contexto (context) corresponde a un objeto que proporciona informaci\u00f3n global acerca del entorno en el que se est\u00e1 ejecutando la aplicaci\u00f3n.</p> <p>A trav\u00e9s del contexto tendremos acceso a recursos y clases espec\u00edficas de la aplicaci\u00f3n, as\u00ed como a m\u00e9todos para realizar operaciones a nivel global, como iniciar componentes de la misma, ya sean actividades, servicios, etc.</p> <p>De esta manera, los componentes pueden determinar en qu\u00e9 aplicaci\u00f3n se encuentran, acceder a los elementos globales, como los recursos o los servicios del sistema, y comunicarse con el resto de componentes de la aplicaci\u00f3n.</p> <p>Sin embargo, no todas las implementaciones de <code>Context</code> proporcionadas por el sistema son iguales. Dependiendo del componente del que se trate, el contexto al que tendremos acceso variar\u00e1 ligeramente.</p> <p>Por ahora nos basta con saber que cada actividad tiene su propio contexto. De hecho, la clase <code>Activity</code> extiende de <code>Context</code>, por los que cualquier actividad es de por s\u00ed un contexto.</p> <p> Figura 17 - Clase Context</p> <p>M\u00e1s adelante veremos que hay un contexto global a la aplicaci\u00f3n, conocido como contexto de aplicaci\u00f3n, que ser\u00e1 m\u00e1s adecuado en algunas circunstancias que ya estudiaremos.</p> <p>Warning</p> <p>Debemos usar el contexto de la actividad s\u00f3lo en aquellos casos en las que la operaci\u00f3n correspondiente est\u00e9 relacionada con la interfaz de usuario. Para el resto de operaciones se recomienda usa el contexto global de la aplicaci\u00f3n, o de lo contrario se pueden producir memory leaks (memoria desperdiciada).</p> <p>Una vez que sabemos lo que es el contexto podemos modificar nuestro Proyecto Login para que muestre un toast con los datos de conexi\u00f3n cuando el usuario pulse sobre el bot\u00f3n de login. Usaremos <code>this</code> como contexto, porque en este caso <code>this</code> hace referencia a la actividad, que implementa <code>Context</code>.</p> <pre><code>public class MainActivity extends AppCompatActivity {\n// ...\nprivate void login(String username, String password) {\nToast.makeText(this, getString(R.string.main_connecting, username, password),\nToast.LENGTH_SHORT).show();\n}\n}\n</code></pre> <p>Tambi\u00e9n tendremos que a\u00f1adir el siguiente recurso de cadena al archivo <code>res/values/strings.xml</code>:</p> <pre><code>&lt;string name=\"main_connecting\"&gt;%1$s - %2$s Connecting&lt;/string&gt;\n</code></pre>"},{"location":"bloque_i/tema_2/page-6/","title":"6 Gesti\u00f3n en Android","text":""},{"location":"bloque_i/tema_2/page-6/#gestion-del-foco","title":"Gesti\u00f3n del foco","text":"<p>Android nos da la posibilidad de gestionar el foco en la interfaz de usuario de nuestra actividad.</p> <p>Foco</p> <p>El foco hace referencia cu\u00e1l de las vistas de la interfaz de usuario presente en pantalla recibir\u00e1 en ese momento los eventos de entrada de datos ventanas que produzca el usuario desde un dispositivo de entrada, normalmente el teclado. En un momento dado s\u00f3lo una vista puede tener el foco.</p> <p>Para que el usuario tenga una referencia visual de qu\u00e9 vista tiene el foco en cada momento, \u00e9sta suele mostrar alg\u00fan tipo de clave visual, dependiendo del tipo de vista de la que se trate. Por ejemplo, en el caso de la vista <code>EditText</code>, la l\u00ednea inferior se muestra de diferente color y aparece el cursor dentro de ella.</p> <p>Por defecto cualquier vista puede recibir el foco. Sin embargo, podemos cambiar este comportamiento estableciendo en la vista correspondiente el atributo <code>android:focusable=\"false\"</code>. Algunos subtipos de vistas definen este valor directamente a <code>false</code>, por lo que en la mayor\u00eda de las ocasiones no es necesario establecerlo expl\u00edcitamente.</p> <p>La clase <code>View</code> proporciona una serie de atributos XML y m\u00e9todos para gestionar el foco:</p> <p> Figura 18 - Clase View</p> <p>En un layout con distintas vistas el foco ir\u00e1 pasando de una vista a otra conforme el usuario introduzca los datos o interact\u00fae con las mismas. El sistema asignar\u00e1 por defecto un determinado orden de foco entre las vistas del layout, atendiendo a su posici\u00f3n en el mismo, siguiendo una estrategia de izquierda a derecha y, posteriormente, de arriba a abajo.</p> <p>La mayor\u00eda de las veces dicho orden ser\u00e1 el esperado, por lo que no tendremos que preocuparnos por ello. Sin embargo, en algunas ocasiones es necesario establecer un orden distinto al predefinido por el sistema. En ese caso Android nos permite establecer para las vistas los atributos <code>android:nextFocusDown</code>, <code>android:nextFocusLeft</code>, <code>android:nextFocusRight</code> y <code>android:nextFocusUp</code>, que recibir\u00e1n el <code>id</code> de la vista a la que se debe dirigir el foco, dependiendo de la direcci\u00f3n que se pretenda seguir.</p> <p>Otro aspecto interesante es qu\u00e9 vista debe obtener el foco inicialmente cuando se muestra un layout. Para indicarla, podemos hacerlo en la propia especificaci\u00f3n XML de layout, incluyendo dentro de dicha vista la etiqueta <code>&lt;requestFocus /&gt;</code>, como vemos en el siguiente ejemplo:</p> <pre><code>&lt;EditText\nandroid:id=\"@+id/txtUsername\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:hint=\"@string/main_txtUsername\"&gt;\n&lt;requestFocus/&gt;\n&lt;/EditText&gt;\n</code></pre> <p>Por otra parte, si lo queremos es forzar a que una determinada vista obtenga en foco en base a alg\u00fan evento que se ha producido, entonces desde c\u00f3digo Java o Kotlin deberemos llamar al m\u00e9todo <code>requestFocus()</code> de dicha vista.</p> <p>Modifiquemos entonces nuestro Proyecto Login para establecer el cuadro de texto correspondiente al nombre de usuario como vista que debe obtener inicialmente el foco. As\u00ed, el layout de nuestra actividad <code>res/layout/activity_main.xml</code> quedar\u00eda:</p> <pre><code>&lt;LinearLayout\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/llRoot\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:orientation=\"vertical\"\nandroid:padding=\"@dimen/main_margin\"&gt;\n&lt;!-- ... --&gt;\n&lt;EditText\nandroid:id=\"@+id/txtUsername\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:hint=\"@string/main_txtUsername\"\nandroid:inputType=\"text\"&gt;\n&lt;requestFocus /&gt;\n&lt;/EditText&gt;\n&lt;!-- ... --&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Por otro lado, en algunas ocasiones queremos realizar alg\u00fan tipo de tarea cuando una determinada vista obtiene o pierde el foco. Para estos casos deberemos crear un objeto listener que implemente la interfaz <code>View.OnFocusChangeListener</code> y asign\u00e1rselo a la vista correspondiente mediante el m\u00e9todo <code>setOnFocusChangeListener(onFocusChangeListener)</code>. Cuando la vista gane o pierda el foco el sistema llamar\u00e1 al m\u00e9todo <code>onFocusChange(view, hasFocus)</code>, pas\u00e1ndole, adem\u00e1s de la vista, si la vista ha quedado en posesi\u00f3n del foco o no. Veamos un ejemplo:</p> <pre><code>// Al perder o ganar el foco.\nbinding.txtUsername.setOnFocusChangeListener(new OnFocusChangeListener() {\n@Override\npublic void onFocusChange(View v, boolean hasFocus) {\n// ...\n}\n});\n</code></pre> <p>Al tratarse de una interfaz funcional (SAM, single abstract method), podemos usar tambi\u00e9n expresiones lambda, en vez de un objeto de una clase an\u00f3nima inline.</p> <p>Debemos tener en cuenta que este listener, se dispara no s\u00f3lo cuando el usuario interact\u00faa con la aplicaci\u00f3n, sino tambi\u00e9n cuando desde c\u00f3digo se hace que la vista tome el foco.</p> <p>Warning</p> <p>Cuando se produce un cambio de configuraci\u00f3n (como estudiaremos m\u00e1s adelante), el sistema preserva autom\u00e1ticamente una referencia a qu\u00e9 vista ten\u00eda el foco en ese momento, de manera que cuando la actividad vuelve a estar disponible, el sistema hace que dicha vista vuelva a tener el foco llamando a <code>requestFocus()</code>. Como consecuencia si para ese momento ya hemos establecido un <code>OnFocusChangeListener</code> para la vista, su c\u00f3digo ser\u00e1 ejecutado.</p> <p>Por este motivo los listener que reaccionan a la entrada de datos, como <code>OnFocusChangeListener</code>, <code>TextWatcher</code> en los EditText, <code>OnCheckChangedListener</code> de CheckBox, o similares, deben ser asociados a la vista correspondiente en el m\u00e9todo <code>onStart()</code> de la actividad, y no en el m\u00e9todo <code>onCreate()</code> para que su c\u00f3digo no sea ejecutado autom\u00e1ticamente cuando se restaure el estado. Despu\u00e9s, en el m\u00e9todo <code>onStop()</code> deberemos quitar la asociaci\u00f3n del listener con la vista.</p> <p>Sin embargo, los listeners que tan s\u00f3lo reaccionan a la interacci\u00f3n del usuario, como por ejemplo <code>OnClickListener</code>no tienen este problema, por lo que podremos asign\u00e1rselos a la vista en el m\u00e9todo <code>onCreate()</code> de la actividad</p> <p>As\u00ed, modifiquemos el c\u00f3digo de nuestro Proyecto Login para que cuando un <code>EditText</code> coja el foco, el texto de su <code>TextView</code> acompa\u00f1ante cambie de color, tomando el color representado por el recurso de color <code>colorAccent</code>.</p> <pre><code>public class MainActivity extends AppCompatActivity {\n// ...\nprivate void setupViews() {\n// ...\nchangeColor(binding.lblUsername, true);\n}\nprotected void onStart() {\nsuper.onStart();\nbinding.txtUsername.setOnFocusChangeListener((v, hasFocus) -&gt;\nchangeColor(binding.lblUsername, hasFocus));\nbinding.txtPassword.setOnFocusChangeListener((v, hasFocus) -&gt;\nchangeColor(binding.lblPassword, hasFocus));\n}\n@Override\nprotected void onStop() {\nsuper.onStop();\nbinding.txtUsername.setOnFocusChangeListener(null);\nbinding.txtPassword.setOnFocusChangeListener(null);\n}\nprivate void changeColor(TextView textView, boolean hasFocus) {\nint colorResId = hasFocus ? R.color.colorAccent : R.color.colorPrimaryText;\ntextView.setTextColor(ContextCompat.getColor(this, colorResId));\n}\nprivate boolean isValidForm(String username, String password) {\nif (!isValidUserName(username)) {\nbinding.txtUsername.requestFocus();\nreturn false;\n}\nif (!isValidPassword(password)) {\nbinding.txtPassword.requestFocus();\nreturn false;\n}\nreturn true;\n}\n}\n</code></pre> <p>En el c\u00f3digo anterior usamos el m\u00e9todo est\u00e1tico <code>ContextCompat.getColor(context, colorResId)</code> para obtener el color correspondiente. Esta es la forma recomendada para obtener el color correspondiente a un recurso de color, frente al empleo del m\u00e9todo <code>getResources().getColor(colorResId)</code>, que ha sido marcado como deprecated (obsoleto).</p> <p>Otro ajuste que hemos tenido que hacer en el c\u00f3digo anterior es establecer inicialmente el color adecuado para la vista <code>lblUsername</code>, ya que inicialmente <code>txtUsername</code> coger\u00e1 el foco, antes de que se haya establecido el listener.</p> <p>Finalmente, hemos modificado el proceso de validaci\u00f3n de manera que si no es posible hacer login porque no se han introducido todos los valores obligatorios la primera vista correspondiente vuelva a obtener el foco, perdi\u00e9ndolo el bot\u00f3n sobre el que hab\u00eda pulsado el usuario.</p>"},{"location":"bloque_i/tema_2/page-6/#gestion-del-teclado-virtual","title":"Gesti\u00f3n del teclado Virtual","text":"<p>Cuando un <code>EditText</code> toma el foco por interacci\u00f3n del usuario, el sistema muestra el teclado virtual para que se introduzcan los datos.</p> <p>El framework no proporciona ning\u00fan m\u00e9todo sencillo para forzar que se muestre o se oculte el teclado virtual, aunque podemos crearlo nosotros. Para ello se recomienda crear una clase de utilidad, llamada <code>SoftInputUtils</code>, que contenga los siguientes m\u00e9todos est\u00e1ticos:</p> <pre><code>public class SoftInputUtils {\nprivate SoftInputUtils() {\n}\npublic static boolean showSoftInput(@NonNull View view) {\nif (view.requestFocus()) {\nInputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(\n(Context.INPUT_METHOD_SERVICE));\nif (imm != null) {\nreturn imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);\n}\n}\nreturn false;\n}\npublic static boolean hideSoftKeyboard(@NonNull View view) {\nInputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(\nContext.INPUT_METHOD_SERVICE);\nif (imm != null) {\nreturn imm.hideSoftInputFromWindow(view.getWindowToken(), 0);\n}\nreturn false;\n}\n}\n</code></pre> <p>Por ejemplo, en nuestro Proyecto Login vamos a hacer que cuando el usuario pulsa el bot\u00f3n se oculte el teclado virtual, para que el toast de conexi\u00f3n no se muestre encima de \u00e9l. As\u00ed modificaremos el c\u00f3digo de nuestra actividad de la siguiente manera:</p> <pre><code>public class MainActivity extends AppCompatActivity {\n// ...\nprivate void btnLoginOnClick() {\nString username = binding.txtUsername.getText().toString();\nString password = binding.txtPassword.getText().toString();\nif (isValidForm(username, password)) {\nSoftInputUtils.hideSoftKeyboard(binding.txtUsername);\nlogin(username, password);\n}\n}\n}\n</code></pre> <p>Al iniciar una actividad, el sistema pasa autom\u00e1ticamente el foco al primer <code>EditText</code> del layout o a aquel para el que se ha establecido la etiqueta <code>requestFocus</code>. Sin embargo, aunque le pase el foco, NO se mostrar\u00e1 el teclado virtual directamente.</p> <p>Si queremos que ya inicialmente se muestre el teclado virtual, tendremos que indicarlo expl\u00edcitamente en el archivo de manifiesto <code>AndroidManfiest.xml</code>, a trav\u00e9s del atributo <code>android:windowSoftInputMode=\"stateVisible\"</code> de la etiqueta <code>activity</code> correspondiente a la actividad en cuesti\u00f3n.</p> <p>Por otra parte, debemos tener en cuenta que es posible que al mostrar el teclado virtual se oculte la vista sobre la que estamos escribiedo, atendiendo a su posici\u00f3n dentro de la interfaz de usuario.</p> <p>Para solucionarlo, Android nos proporciona una manera de indicar c\u00f3mo debe adaptarse la interfaz de la actividad cuando la vista que ha hecho que se muestre el teclado virtual va a quedar oculta tras \u00e9ste.</p> <p>As\u00ed, estableceremos en el mismo atributo anterior <code>android:windowSoftInputMode</code> a alguno de los siguientes valores:</p> <ul> <li><code>adjustResize</code>: El layout de la actividad se redimensiona al mostrar el teclado virtual.</li> <li><code>adjustPan</code>: El layout de la actividad es desplazado de manera que la vista que tiene el foco y que ha mostrado el teclado virtual no quede oculto tras \u00e9ste.</li> </ul> <p>Si adem\u00e1s de alguno de los valores anteriores queremos indicar el valor <code>stateVisible</code> deberemos usar el operador <code>or</code> de bits <code>|</code> para indicar varios valores. As\u00ed, en el siguiente ejemplo, se indican los valores <code>stateVisible</code> y <code>adjustPan</code>:</p> <pre><code>&lt;activity\n&lt;!-- ... --&gt;\nandroid:windowSoftInputMode=\"stateVisible|adjustPan\" /&gt;\n</code></pre> <p>Modifiquemos nuestro Proyecto Login de manera que en nuestra actividad se muestre directamente el teclado virtual cuando la vista <code>txtUsername</code> coja inicialmente el foco, y adem\u00e1s la actividad sea desplazada hacia arriba autom\u00e1ticamente si el teclado virtual tapa al elemento que tiene el foco, aunque en realidad no haga falta con el dise\u00f1o creado. Para ello actualizaremos el manifiesto de la aplicaci\u00f3n, el archivo <code>AndroidManifest.xml</code> para incluir lo indicado anteriormente:</p> <pre><code>&lt;manifest package=\"es.iessaladillo.pedrojoya.login\"\nxmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n&lt;application\nandroid:allowBackup=\"true\"\nandroid:icon=\"@mipmap/ic_launcher\"\nandroid:label=\"@string/app_name\"\nandroid:roundIcon=\"@mipmap/ic_launcher_round\"\nandroid:supportsRtl=\"true\"\nandroid:theme=\"@style/AppTheme\"&gt;\n&lt;activity\nandroid:name=\".MainActivity\"\nandroid:windowSoftInputMode=\"stateVisible|adjustPan\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"android.intent.action.MAIN\"/&gt;\n&lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;\n&lt;/intent-filter&gt;\n&lt;/activity&gt;\n&lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre>"},{"location":"bloque_i/tema_2/page-6/#imeoptions","title":"ImeOptions","text":"<p>Como hemos comentado en otra entrada, el valor del atributo <code>android:inputType</code> de un <code>EditText</code> determina qu\u00e9 teclas aparecer\u00e1n en el teclado virtual cuando \u00e9ste se muestre como consecuencia de que dicha vista haya obtenido el foco.</p> <p> Figura 19 - Teclado virtual</p> <p>Pues bien, Android a\u00f1ade al teclado una tecla adicional con la acci\u00f3n que normalmente el usuario llevar\u00e1 a cabo cuando haya terminado de escribir su texto en el <code>EditText</code>. Dicha acci\u00f3n recibe el nombre de IME (Input Method Editor, editor de m\u00e9todos de entrada) y por defecto es proporcionada por el sistema autom\u00e1ticamente, mostrando un icono distinto dependiendo de la acci\u00f3n de la que se trate.</p> <p>Sin embargo, podemos personalizar la acci\u00f3n a mostrar, estableciendo el atributo <code>android:imeOptions</code> de la vista a alguno de los siguientes valores:</p> <ul> <li><code>actionNext</code>: Ir a la siguiente vista en la que se pueden introducir datos. Si queremos configurar a qu\u00e9 vista podemos usar el atributo <code>android:nextFocusDown</code>.</li> <li><code>actionPrevious</code>: Ir a la anterior vista en la que se pueden introducir datos. </li> <li><code>actionGo</code>: Ejecutar tarea que mostrar\u00e1 al usuario resultados. </li> <li><code>actionSearch</code>: Buscar con el texto introducido. </li> <li><code>actionSend</code>: Enviar contenido que incluye el texto introducido. </li> <li><code>actionDone</code>: Completar edici\u00f3n cerrando el teclado virtual. </li> </ul> <p>Warning</p> <p>Independientemente de que hayamos establecido una acci\u00f3n mediante el atributo <code>android:imeOptions</code>, si el <code>EditText</code> permite la introducci\u00f3n de varias l\u00edneas, la tecla IME siempre mostrar\u00e1 la acci\u00f3n de salto de l\u00ednea, para permitir la introducci\u00f3n de varias l\u00edneas.</p> <p>Podemos hacer la tecla IME en vez de mostrar un icono,muestre un texto personalizado, usando el atributo <code>android:imeActionLabel=\"texto\"</code>.</p> <p> Figura 20 - Atributos XML y m\u00e9todos IME de EditText</p> <p>Otro aspecto importante es que tenemos la posibilidad de establecer un objeto listener para cuando el usuario pulse la tecla IME, de manera que podamos ejecutar una tarea asociada.</p> <p>Para tal fin asignaremos a la vista mediante el m\u00e9todo <code>setOnEditorActionListener()</code> un objeto listener que implemente la interfaz <code>TextView.OnEditorActionListener</code>, de manera que cuando el usuario pulse la tecla IME se llamar\u00e1 al m\u00e9todo <code>onEditorAction()</code> del listener, pas\u00e1ndole entre otros par\u00e1metros el <code>id</code> de la acci\u00f3n, que, si lo necesitamos, podremos comparar con alguna de las constantes de la clase <code>EditorInfo</code>, como por ejemplo <code>EditorInfo.IME_ACTION_DONE</code>. El m\u00e9todo <code>onEditorAction()</code> debe retornar un booleano indicando si el evento ha sido consumido o no.</p> <pre><code>binding.txtUsername.setOnEditorActionListener(new TextView.OnEditorActionListener() {\n@Override\npublic boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n// ...\n// Retornamos true para indicar que el evento ha sido procesado \nreturn true;\n}\n});\n</code></pre> <p>As\u00ed, vamos a modificar nuestro Proyecto Login para que cuando se pulse sobre la tecla IME del teclado virtual cuando la vista <code>txtPassword</code> tenga el foco, directamente se trate de hacer login, como si se hubiera pulsado el bot\u00f3n <code>btnLogin</code>.</p> <p>As\u00ed, en la vista <code>txtPassword</code> de nuestro layout estableceremos el atributo <code>android:imeOptions</code></p> <pre><code>&lt;LinearLayout\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/llRoot\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:orientation=\"vertical\"\nandroid:padding=\"@dimen/main_margin\"&gt;\n&lt;!-- ... --&gt;\n&lt;EditText\nandroid:id=\"@+id/txtPassword\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:hint=\"@string/main_txtPassword\"\nandroid:imeOptions=\"actionDone\"\nandroid:inputType=\"textPassword\" /&gt;\n&lt;!-- ... --&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Nuestra actividad incorporar\u00eda el siguiente c\u00f3digo:</p> <pre><code>public class MainActivity extends AppCompatActivity {\n// ...\nprivate void setupViews() {\n// ...\nbinding.txtPassword.setOnEditorActionListener((v, actionId, event) -&gt;\ntxtPasswordOnEditorAction());\n}\nprivate boolean txtPasswordOnEditorAction() {\nbtnLoginOnClick();\nreturn true;\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_2/page-6/#gestion-de-la-escritura","title":"Gesti\u00f3n de la escritura","text":"<p>En algunas ocasiones es necesario realizar alguna tarea justo en el momento en el que el usuario cambia el texto de un <code>EditText</code>, como por ejemplo para validar los datos en tiempo real conforme se escriben, o habilitar / deshabilitar alg\u00fan bot\u00f3n dependiendo de si se ha escrito o no algo de texto en el <code>EditText</code>.</p> <p>Para tal fin deberemos crear un objeto listener de una clase que implemente la interfaz <code>TextWatcher</code> y asign\u00e1rselo al <code>EditText</code> mediante el m\u00e9todo <code>addTextChangedListener(textWatcher)</code>.</p> <p> Figura 21 - M\u00e9todos de EditText relacionados con al escritura</p> <p>De esta manera, cada vez que el usuario modifique el texto del <code>EditText</code>, se llamar\u00e1 a alguno los siguientes m\u00e9todos del listener:</p> <ul> <li><code>afterTextChanged()</code>: Se llama cuando el cambio ya ha sido realizado. Recibe el texto despu\u00e9s del cambio.</li> <li><code>beforeTextChanged()</code>: Se llama antes de que se escriba el texto. Esto te permite saber el estado del texto actual y de la secci\u00f3n que ser\u00e1 reemplazada.</li> <li><code>onTextChanged()</code>: Se llama cuando se ha reemplazado la secci\u00f3n del texto. Recibe qu\u00e9 porci\u00f3n del texto viejo se reemplaz\u00f3 y cuantos caracteres nuevos se agregaron.</li> </ul> <pre><code>binding.txtUsername.addTextChangedListener(new TextWatcher() {\n@Override\npublic void onTextChanged(CharSequence s, int start, int before, int count) {\n// ...\n}\n@Override\npublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n// ...\n}\n@Override\npublic void afterTextChanged(Editable s) {\n// ...\n}\n});\n</code></pre> <p>Ten en cuenta</p> <p>La interfaz <code>TextWatcher</code> no es una interfaz funcional, ya que posee m\u00e1s de un m\u00e9todo abstracto. Por este motivo, no podemos usar directamente una expresi\u00f3n lambda en vez de un objeto de una clase an\u00f3nima inline.</p> <p>Otro aspecto curioso es que el m\u00e9todo para establecer el listener se llama <code>addTextChangedListener(textWatcher)</code>, y no <code>setTextChangedListener(textWatcher)</code>, lo cual es indicativo de que podemos tener m\u00e1s de un listener que sea notificado cuando cambie el texto del EditText.</p> <p>Warning</p> <p>Cuando se produce un cambio de configuraci\u00f3n (como estudiaremos m\u00e1s adelante), el sistema preserva autom\u00e1ticamente el texto de los EditText, de manera que cuando la actividad vuelve a estar disponible, el sistema restaura autom\u00e1ticamente el texto de los EditText en el m\u00e9todo <code>onRestoreInstanceState()</code>, que es ejecutado despu\u00e9s del <code>onStart()</code> pero antes que el <code>onResume()</code>. Como consecuencia, si para ese momento ya hemos establecido un <code>TextWatcher</code> para la vista, su c\u00f3digo ser\u00e1 ejecutado.</p> <p>Por este motivo, a la hora de asociar a la vista correspondiente los listener que reaccionan a la entrada de datos, como <code>OnFocusChangeListener</code>, <code>TextWatcher</code> en los EditText, <code>OnCheckChangedListener</code> de CheckBox, o similares, debemos decidir si hacerlo en el m\u00e9todo <code>onCreate()</code>, es decir, antes de que se restaure el estado autom\u00e1ticamente, o en el <code>onResume()</code>, es decir, despu\u00e9s de que se restaure el estado autom\u00e1ticamente, dependiendo de si queramos que el evento correspondiente sea ejecutado tras la restauraci\u00f3n o no. Si lo hacemos en el <code>onResume()</code>, entonces en el m\u00e9todo <code>onPause()</code> deberemos quitar la asociaci\u00f3n del listener con la vista, para lo que emplearemos el m\u00e9todo <code>removeTextChangedListener(listener)</code> de la vista.</p> <p>Sin embargo, para los listeners cuyos eventos no pueden ser disparados durante la restauraci\u00f3n autom\u00e1tica, como por ejemplo <code>OnClickListener</code>, es seguro asign\u00e1rselos a la vista en el m\u00e9todo <code>onCreate()</code> de la actividad.</p> <p>Modifiquemos el Proyecto Login para que se muestre un mensaje de error debajo de cada EditText obligatorio que no se haya introducido correctamente, en este caso si se deja vac\u00edo. En cuanto se introduzca texto el mensaje debe desaparecer. El c\u00f3digo de la actividad quedar\u00eda de la siguiente manera:</p> <pre><code>public class MainActivity extends AppCompatActivity {\n// ...\nprivate TextWatcher txtUsernameTextWatcher;\nprivate TextWatcher txtPasswordTextWatcher;\nprotected void onStart() {\nsuper.onStart();\nbinding.txtUsername.setOnFocusChangeListener(\n(v, hasFocus) -&gt; changeColor(binding.lblUsername, hasFocus));\nbinding.txtPassword.setOnFocusChangeListener(\n(v, hasFocus) -&gt; changeColor(binding.lblPassword, hasFocus));\ntxtUsernameTextWatcher = new TextWatcher() {\n@Override\npublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n}\n@Override\npublic void onTextChanged(CharSequence s, int start, int before, int count) {\n}\n@Override\npublic void afterTextChanged(Editable s) {\nvalidateUsername(s.toString());\n}\n};\nbinding.txtUsername.addTextChangedListener(txtUsernameTextWatcher);\ntxtPasswordTextWatcher = new TextWatcher() {\n@Override\npublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n}\n@Override\npublic void onTextChanged(CharSequence s, int start, int before, int count) {\n}\n@Override\npublic void afterTextChanged(Editable s) {\nvalidatePassword(s.toString());\n}\n};\nbinding.txtPassword.addTextChangedListener(txtPasswordTextWatcher);\n}\n@Override\nprotected void onStop() {\nsuper.onStop();\nbinding.txtUsername.setOnFocusChangeListener(null);\nbinding.txtPassword.setOnFocusChangeListener(null);\nbinding.txtUsername.removeTextChangedListener(txtUsernameTextWatcher);\nbinding.txtPassword.removeTextChangedListener(txtPasswordTextWatcher);\n}\nprivate boolean validateUsername(String username) {\nif (isValidUserName(username)) {\nbinding.txtUsername.setError(null);\nreturn true;\n} else {\nbinding.txtUsername.setError(getString(R.string.main_required));\nreturn false;\n}\n}\nprivate boolean validatePassword(String password) {\nif (isValidPassword(password)) {\nbinding.txtPassword.setError(null);\nreturn true;\n} else {\nbinding.txtPassword.setError(getString(R.string.main_required));\nreturn false;\n}\n}\nprivate boolean isValidForm(String username, String password) {\nif (!validateUsername(username)) {\nbinding.txtUsername.requestFocus();\nreturn false;\n}\nif (!validatePassword(password)) {\nbinding.txtPassword.requestFocus();\nreturn false;\n}\nreturn true;\n}\n}\n</code></pre> <p>Tambi\u00e9n tendremos que a\u00f1adir el siguiente recurso de cadena al archivo <code>res/values/strings.xml</code>:</p> <pre><code>&lt;string name=\"main_required\"&gt;Required&lt;/string&gt;\n</code></pre>"},{"location":"bloque_i/tema_2/page-6/#fijar-la-orientacion-de-la-actividad","title":"Fijar la orientaci\u00f3n de la actividad","text":"<p>En este proyecto (y en los anteriores) ni siquiera nos hemos preguntado qu\u00e9 pasar\u00eda si gir\u00e1ramos la pantalla del dispositivo. Para empezar, nuestro layout no se ver\u00eda correctamente en una orientaci\u00f3n apaisada (landscape). Por este motivo, y hasta que sepamos c\u00f3mo gestionar correctamente los cambios de configuraci\u00f3n, vamos a optar por fijar la orientaci\u00f3n de la actividad en el modo retrato (portrait).</p> <p>Para ello en la declaraci\u00f3n de la actividad en el manifiesto de la aplicaci\u00f3n, esto es, en el archivo <code>AndroidManifest.xml</code>, estableceremos el atributo <code>android:screenOrientation</code> al valor <code>portrait</code>. Para el modo apaisado el valor es <code>landscape</code>.</p> <p>As\u00ed, el manifiesto de nuestro Proyecto Login quedar\u00eda:</p> <pre><code>&lt;manifest package=\"es.iessaladillo.pedrojoya.login\"\nxmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n&lt;application\nandroid:allowBackup=\"true\"\nandroid:icon=\"@mipmap/ic_launcher\"\nandroid:label=\"@string/app_name\"\nandroid:roundIcon=\"@mipmap/ic_launcher_round\"\nandroid:supportsRtl=\"true\"\nandroid:theme=\"@style/AppTheme\"&gt;\n&lt;activity\nandroid:name=\".MainActivity\"\nandroid:windowSoftInputMode=\"stateVisible|adjustPan\"\nandroid:screenOrientation=\"portrait\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"android.intent.action.MAIN\"/&gt;\n&lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;\n&lt;/intent-filter&gt;\n&lt;/activity&gt;\n&lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre>"},{"location":"bloque_i/tema_2/page-7/","title":"Proyecto TIME","text":"<p>Realiza una aplicaci\u00f3n Android que muestre la fecha y la hora actual. Haciendo uso de los commits de Git, realiza dos versiones: haciendo uso del <code>requiereViewById</code> y haciendo uso del <code>viewBinding</code>. El resultado debe ser similar a:</p> <p> Figura 22 - Soluci\u00f3n del proyecto Time</p>"}]}