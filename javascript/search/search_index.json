{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to Javascript World</p> <pre><code>console.log('Hello World')\n</code></pre>"},{"location":"bloque_i/tema_1/page-1/","title":"1 Introducci\u00f3n a Javascript","text":""},{"location":"bloque_i/tema_1/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Javascript es un lenguaje de programaci\u00f3n utilizado para crear p\u00e1ginas web din\u00e1micas e interactivas. Es el lenguaje de scripting m\u00e1s utilizado en la web y lo emplean los desarrolladores para a\u00f1adir funcionalidad a sitios web y aplicaciones.</p> <p>Puede utilizarse para crear interfaces de usuario interactivas, crear aplicaciones del lado del servidor, conectar bases de datos y mucho m\u00e1s. Su c\u00f3digo de programaci\u00f3n se ha convertido en una parte esencial del desarrollo web moderno y puede encontrarse en pr\u00e1cticamente todas las aplicaciones web.</p> <p>Javascript fue creado en 1995 como una forma de a\u00f1adir programaci\u00f3n a las p\u00e1ginas web. El lenguaje ha sido adoptado por la gran mayor\u00eda de los navegadores web. Una de sus aplicaciones m\u00e1s modernas es dirigirse a otras p\u00e1ginas web sin necesidad de realizar una recarga en el navegador. Adem\u00e1s permite interactuar de varias formas diferentes con la p\u00e1gina web.</p> <p>As\u00ed mismo, es compatible con todos los navegadores modernos, lo cual lo hace un lenguaje esencial por su versatilidad con diferentes plataformas.</p> <p>En general, con este lenguaje se incluye dinamismo al navegar un sitio web, cuando antes se caracterizaban por ser est\u00e1ticos. Es decir, un mejoramiento de la experiencia del usuario y al mismo tiempo, una optimizaci\u00f3n de procesos debido a su facilidad de uso tanto del lado del cliente, como del servidor.</p> <p>Entre sus tareas m\u00e1s comunes podemos encontrar el uso de bases de datos, optimizaci\u00f3n de las funciones de una plataforma y el desarrollo tanto de web apps como aplicaciones m\u00f3viles.</p>"},{"location":"bloque_i/tema_1/page-1/#historia","title":"Historia","text":"<p>JavaScript se introdujo en 1995 como una forma de agregar programas a p\u00e1ginas web en el navegador Netscape Navigator. En su momento fue una idea novedosa. En los primeros d\u00edas de la World Wide Web, HTML era bastante simple, y bastante f\u00e1cil de aprender casi todo lo que se necesitaba saber para agrupar p\u00e1ginas web. Cualquiera pod\u00eda hacer una Web juntando tablas, texto y a\u00f1adiendo alguna imagen.</p> <p>A principios de los a\u00f1os 90, la mayor\u00eda de usuarios que se conectaban a Internet lo hac\u00edan con m\u00f3dems a una velocidad m\u00e1xima de 28.8 kbps. Esa velocidad era m\u00e1s que suficiente para la \u00e9poca salvo que quisieras descargar imagenes de cierto tama\u00f1o. Lo cierto era que la web en aquel entonces no ofrec\u00eda gran cosa m\u00e1s que servir como una inmensa biblioteca donde los usuarios consultaban mayormente contenido basado en texto pero la evoluci\u00f3n que conocemos hoy estaba por llegar y pod\u00edan verse los primeros pasos.</p> <p>En esa \u00e9poca, empezaban a desarrollarse las primeras aplicaciones web y por tanto, las p\u00e1ginas web comenzaban a incluir formularios complejos. Con unas aplicaciones web cada vez m\u00e1s complejas y una velocidad de navegaci\u00f3n tan lenta, surgi\u00f3 la necesidad de un lenguaje de programaci\u00f3n que se ejecutara en el navegador del usuario. De esta forma, si el usuario no rellenaba correctamente un formulario, no se le hac\u00eda esperar mucho tiempo hasta que el servidor volviera a mostrar el formulario indicando los errores existentes.</p> <p>Desde entonces, el lenguaje ha sido adoptado por todos los dem\u00e1s navegadores gr\u00e1ficos principales. Ha hecho posibles las aplicaciones web modernas, aplicaciones con las que puede interactuar directamente sin hacer una recarga de p\u00e1gina para cada acci\u00f3n.</p> <p>En la actualidad los navegadores web no son las \u00fanicas plataformas en las que se utiliza JavaScript. Tambi\u00e9n es posible ejecutar c\u00f3digo JavaScript en un entorno servidor. De hecho las bases de datos, como MongoDB y CouchDB, usan JavaScript como su lenguaje de scripting y consulta. Varias plataformas para la programaci\u00f3n de escritorio y servidor, en particular el proyecto Node.js proporcionan un entorno para la programaci\u00f3n de JavaScript fuera del navegador.</p> <p>Warning</p> <p>Es importante recalcar que el lenguaje de programaci\u00f3n Javascript no tiene casi nada que ver con el lenguaje de programaci\u00f3n Java. La similitud entre ambos nombres se debe a una estrategia de marketing. Java ya era un lenguaje introducido fuertemente en el mercado cuando Javascript aterriz\u00f3 y dispon\u00eda de una amplia popularidad.</p>"},{"location":"bloque_i/tema_1/page-1/#evolucion","title":"Evoluci\u00f3n","text":"<p>Aunque JavaScript surgi\u00f3 como un lenguaje de script para mejorar las capacidades de la web de la \u00e9poca all\u00e1 por 1995 por la extinta Netscape, JavaScript no ha dejado de evolucionar desde entonces. Originalmente el lenguaje se basaba a su vez basaba en CEnvi desarrollado a su vez por Nombas.</p> <p>Brendan Eich, un programador que trabajaba en Netscape, pens\u00f3 que podr\u00eda solucionar las limitaciones de la web de entonces, adaptando otras tecnolog\u00edas existentes (como ScriptEase) al navegador Netscape Navigator 2.0, que iba a lanzarse en aquel a\u00f1o. Inicialmente, Eich denomin\u00f3 a su lenguaje LiveScript y fue un \u00e9xito.</p> <p>Fue entonces cuando, justo antes del lanzamiento, Netscape decidi\u00f3 cambiar el nombre por el de JavaScript y firm\u00f3 una alianza con Sun Microsystems para continuar el desarrollo del nuevo lenguaje de programaci\u00f3n.</p> <p>Microsoft, al ver el movimiento de uno de sus principales competidores, tambi\u00e9n decidi\u00f3 incorporar su propia implementaci\u00f3n de este lenguaje, llamada JScript, en la versi\u00f3n 3 de su navegador Internet Explorer.</p> <p>Esto contribuy\u00f3 todav\u00eda m\u00e1s al empuje y popularizaci\u00f3n del lenguaje, pero comenzaron a presentarse peque\u00f1os problemas por las diferencias entre implementaciones. A partir de estos hechos un documento est\u00e1ndar fue creado para describir la manera en que el lenguaje deber\u00eda funcionar. Dicho documento es conocido como ECMAScript standard. En la pr\u00e1ctica, los t\u00e9rminos ECMAScript y Javascript pueden ser intercambiados, por lo que habr\u00eda dos nombres identificativos para el mismo lenguaje.</p>"},{"location":"bloque_i/tema_1/page-1/#funciones-y-caracteristicas","title":"Funciones y caracter\u00edsticas","text":"<p>Entre las funciones que podemos encontrar en Javascript est\u00e1n:</p> <ul> <li>Agregar efectos visuales y de interacci\u00f3n a una p\u00e1gina web.</li> <li>Validaci\u00f3n de formularios.</li> <li>Automatizaci\u00f3n de tareas.</li> <li>Crear aplicaciones del lado del servidor.</li> <li>Crear chatbots.</li> <li>Desarrollo de aplicaciones m\u00f3viles y juegos.</li> <li>Crear mapas interactivos.</li> <li>Crear gr\u00e1ficos y visualizaciones de datos.</li> <li>Crear aplicaciones web progresivas (PWA)</li> </ul> <p>Adem\u00e1s, cuenta con las siguientes caracter\u00edsticas:</p> <ul> <li>Lenguaje multiplataforma: Puede ser utilizado en muchos marcos y plataformas, as\u00ed como puede ejecutarse en cualquier m\u00e1quina independientemente del sistema operativo de \u00e9sta.</li> <li>Lenguaje interpretado: Tiene un int\u00e9rprete que se encarga de traducir el c\u00f3digo Javascript a c\u00f3digo m\u00e1quina.</li> <li>Lenguaje orientado a objetos: Se basa en usar estructuras de datos orientados a objetos.</li> <li>Lenguaje de alto nivel: Puede ser comprendido de forma sencilla, sin complicaciones.</li> <li>Lenguaje tipado d\u00e9bil: No permite definir al desarrollador el tipo de los datos, as\u00ed como el tipo de dato puede ser cambiado en tiempo de ejecuci\u00f3n.</li> </ul> <p>Manuales</p> <p>MDN (Mozilla) JavaScript Reference es el manual principal, con ejemplos y otras informaciones. Es fant\u00e1stico para obtener informaci\u00f3n exhaustiva sobre funciones individuales del lenguaje, m\u00e9todos, etc.</p> <p>Adem\u00e1s, Javascript es un lenguaje en evoluci\u00f3n, y normalmente se a\u00f1aden nuevas caracter\u00edsticas. Para ver la compatibilidad por navegador y otros motores, consultar:</p> <ul> <li>https://caniuse.com \u2013 tablas de compatibilidad por caracter\u00edstica. Por ejemplo, para comprobar qu\u00e9 motores soportan funciones modernas de criptograf\u00eda: https://caniuse.com/#feat=cryptography. </li> <li>https://kangax.github.io/compat-table \u2013 tabla que muestra la compatibilidad o no de las prestaciones del lenguaje por motor.</li> </ul>"},{"location":"bloque_i/tema_1/page-2/","title":"2 Consola de desarrollador","text":""},{"location":"bloque_i/tema_1/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Un script es un fichero con c\u00f3digo Javascript que contiene las instrucciones que deseemos que se ejecuten en el entorno que queramos que sean ejecutadas. Un entorno de ejecuci\u00f3n es el lugar donde se va a ejecutar el c\u00f3digo incrustado en nuestro script.</p> <p>El entorno de ejecuci\u00f3n por defecto y m\u00e1s \u00fatil de Javascript es el navegador. Sin embargo, existen otros tipos de entornos de ejecuci\u00f3n como un dispositivo m\u00f3vil o la consola de nuestro ordenador.</p>"},{"location":"bloque_i/tema_1/page-2/#consola-del-navegador","title":"Consola del navegador","text":"<p>Una consola es un entorno en el que se puede ejecutar comandos y scripts. Todos los ordenadores tienen un consola instalada por defecto, pero hay ciertos programas que tienen sus propias consolas instaladas.</p> <p>El navegador tiene un integrado una consola para ver mensajes de error o de informaci\u00f3n, pero adem\u00e1s tambi\u00e9n poder ejecutar comandos. Dicha consola est\u00e1 basada y entiende el lenguaje de Javascript, por lo que es muy usada para el desarrollo de aplicaciones web con Javascript.</p> <p>Para poder acceder a ella, se deber\u00e1 acceder a las DevTools de nuestro navegador, y desde ah\u00ed acceder a la pesta\u00f1a Console. En algunos navegadores, existe el shortcut Ctrl+Shift+I para poder abrir las herramientas de desarrollador.</p>"},{"location":"bloque_i/tema_1/page-2/#console","title":"Console","text":"<p>El objeto <code>console</code> es el objeto predeterminado de Javascript para poder interactuar con la consola. Este objeto tiene diferentes m\u00e9todos que podemos usar para trabajar en la consola de formas diferentes:</p> <ul> <li> <p><code>log</code>. Se utiliza para mostrar mensajes de informaci\u00f3n en la consola. Es uno de los m\u00e1s usados. Tambi\u00e9n se puede usar <code>info</code>.</p> <pre><code>console.log('Hello world')\n</code></pre> </li> <li> <p><code>debug</code>. Muestra informaci\u00f3n con todo tipo de detalles.</p> <pre><code>console.debug('This is a debug message')\n</code></pre> </li> <li> <p><code>warn</code>. Se utiliza para mostrar una advertencia. Suele ir destacado en amarillo.</p> <pre><code>console.warn('This is a warn message')\n</code></pre> </li> <li> <p><code>error</code>. Se utiliza para mostrar mensajes de error. Suele ir destacado en rojo.</p> <pre><code>console.error('This is an error message')\n</code></pre> </li> <li> <p><code>clear</code>. Sirve para limpiar la consola, es decir, elimina los mensajes e instrucciones mostrados.</p> </li> </ul> <p>A la derecha de la consola de las DevTools hay un men\u00fa de opciones para poder filtrar los mensajes de la consola por el tipo de mensaje que sea seg\u00fan el m\u00e9todo utilizado.</p> <p>Se puede pasar diferentes mensajes en una misma llamada de la funci\u00f3n, separando cada mensaje por una coma. Esto producir\u00e1 que los mensajes se muestre uno al lado del otro.</p> <pre><code>console.log('This is a', 'message')\n</code></pre>"},{"location":"bloque_i/tema_1/page-2/#estilizar-mensajes","title":"Estilizar mensajes","text":"<p>Se puede estilizar los mensajes de consola, haciendo uso de instrucciones CSS. Para ello, las funciones usadas anteriormente pueden recibir un segundo argumento con una cadena que contenga el estilo CSS a aplicar. Para que no confunda la segunda cadena como un texto a mostrar, es importante que la primera cadena empiece con <code>%c</code>, de esta forma la consola entender\u00e1 que la siguiente instrucci\u00f3n es un estilo y no un mensaje a mostrar:</p> <pre><code>console.log('%cThis is a styled message', 'color: blue')\n</code></pre>"},{"location":"bloque_i/tema_1/page-2/#agrupar-mensajes","title":"Agrupar mensajes","text":"<p>Para mostrar los mensajes en un grupo, podemos usar los siguientes m\u00e9todo del objeto <code>console</code>:</p> <ul> <li><code>group</code>. Sirve para inicializar el grupo de mensajes. Puede recibir el nombre del grupo. Con <code>groupCollapsed</code> inicializa el grupo de mensajes, pero lo muestra colapsado.</li> <li><code>groupEnd</code>. Sirve para finalizar el grupo.</li> </ul> <p>Entre ambos m\u00e9todos se puede escribir diferentes tipos de mensajes, y en la consola de mostrar\u00e1 agrupados.</p>"},{"location":"bloque_i/tema_1/page-2/#tablas","title":"Tablas","text":"<p>Se puede mostrar los arrays y los objetos, que veremos m\u00e1s adelante, en forma de tabla haciendo uso del m\u00e9todo <code>table</code> del objecto <code>console</code>.</p> <pre><code>console.table(users);\n</code></pre>"},{"location":"bloque_i/tema_1/page-2/#assert","title":"Assert","text":"<p>El m\u00e9todo <code>assert</code> sirve para mostrar un mensaje en consola siempre y cuando se cumpla una condici\u00f3n.</p> <pre><code>console.assert(5 &lt; 10, \"5 es menor que 10\"); // No ocurre nada\nconsole.assert(5 &lt; 0, \"5 es menor que 0\"); // Muestra el mensaje indicado con un aviso de error\n</code></pre>"},{"location":"bloque_i/tema_1/page-3/","title":"3 C\u00f3digo Javascript","text":""},{"location":"bloque_i/tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos dicho, un script es un conjunto de instrucciones para ser ejecutadas. Para ejecutar un script de Javascript en el navegador, se pueden hacer de formas diferentes:</p> <ul> <li>Haciendo uso de la etiqueta HTML <code>script</code>.</li> <li>Creando un fichero Javascript e importando dicho fichero a un fichero HTML.</li> </ul> <p>Cada vez que usamos una de esta formas el c\u00f3digo Javascript se ejecutar\u00e1 cada vez que accedamos a la p\u00e1gina HTML d\u00f3nde se ha incrustado dicho c\u00f3digo.</p>"},{"location":"bloque_i/tema_1/page-3/#etiqueta-script","title":"Etiqueta script","text":"<p>La etiqueta <code>script</code> es una etiqueta HTML que permite introducir c\u00f3digo Javascript para que el navegador puede utilizar dicho c\u00f3digo. En dicha etiqueta podemos indicar las diferentes instrucciones a ejecutar. Normalmente la etiqueta puede ser utilizada en cualquier parte del documento, pero se recomienda su uso dentro de la etiqueta <code>head</code> o al final de la etiqueta <code>body</code>, antes de su cierre.</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;!--... --&gt;\n&lt;script&gt;\nconsole.log('This is a Javascript script')\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script&gt;\nconsole.log('This is a Javascript script')\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Podemos crear un fichero Javascript (de extension <code>.js</code>) con las instrucciones e insertar dicho fichero en un documento HTML, haciendo uso del atributo <code>src</code> de la etiqueta <code>script</code>:</p> JavascriptHTML <pre><code>console.log('This is a Javascript script')\n</code></pre> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;!--... --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script src=\"fichero.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Otra atributo que puede recibir dicha etiqueta es el atributo <code>type</code> para indicar el tipo script que se va a insertar. Para los archivos Javascript, el tipo es <code>type=\"text/javascript\"</code>.</p> <p>Tips</p> <p>En la mayor\u00eda de los casos se recomienda crear un fichero a parte e insertarlo en nuestro documento HTML. La ventaja de un archivo separado es que el navegador lo descargar\u00e1 y lo almacenar\u00e1 en cach\u00e9.</p> <p>Otras p\u00e1ginas que hacen referencia al mismo script lo tomar\u00e1n del cach\u00e9 en lugar de descargarlo, por lo que el archivo solo se descarga una vez.</p> <p>Eso reduce el tr\u00e1fico y hace que las p\u00e1ginas sean m\u00e1s r\u00e1pidas.</p> <p>Warning</p> <p>Una sola etiqueta <code>&lt;script&gt;</code> no puede tener el atributo <code>src</code> y c\u00f3digo dentro.</p> <pre><code>&lt;script src=\"file.js\"&gt;\nalert(1); // el contenido se ignora porque se estableci\u00f3 src\n&lt;/script&gt;\n</code></pre> <p>Debemos elegir un <code>&lt;script src=\"\u2026\"&gt;</code> externo o un <code>&lt;script&gt;</code> normal con c\u00f3digo.</p> <p>El ejemplo anterior se puede dividir en dos scripts para que funcione:</p> <pre><code>&lt;script src=\"file.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nalert(1);\n&lt;/script&gt;\n</code></pre>"},{"location":"bloque_i/tema_1/page-3/#orden-de-insercion","title":"Orden de inserci\u00f3n","text":"<p>En un mismo documento HTML, podemos tener diferentes etiquetas Javascript, en la parte del documento que m\u00e1s nos interesa. Es importante recalcar que el orden de utilizaci\u00f3n de esta etiqueta, ya que HTML se ejecuta de forma secuencial, es decir, l\u00ednea a l\u00ednea. Por ejemplo, si tenemos un documento HTML con un elemento <code>h1</code> y un script que trabaje con dicho <code>h1</code>, no es recomendable que el script se ejecute antes del <code>h1</code> ya que no puede tener acceso a dicho elemento, porque cuando se ejecute la l\u00ednea, este elemento a\u00fan no existe.</p> <p>Por este motivo, se recomienda insertar las librer\u00edas JAvascript en el <code>head</code> del documento, y las instrucciones que trabajen con el DOM como \u00faltima instrucci\u00f3n dentro de la etiqueta <code>body</code>.</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;!--...--&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Hello world&lt;/h1&gt;\n&lt;script&gt;\nconsole.log('Hello world')\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>En el ejemplo anterior, primero se mostrar\u00e1 el <code>h1</code> y luego se ejecutar\u00e1 y se mostrar\u00e1 el mensaje del <code>console.log()</code>.</p>"},{"location":"bloque_i/tema_1/page-3/#etiqueta-noscript","title":"Etiqueta noscript","text":"<p>En ciertas ocasiones, el navegador no es compatible con Javascript (cosa poco probable) o tiene desactivada la opci\u00f3n de Javascript en el navegador.</p> <p>La etiqueta <code>&lt;noscript&gt;</code> muestra un contenido alternativo para los usuarios que tiene desactivada la opci\u00f3n en su navegador o no es compatible.</p> <pre><code>&lt;script&gt;\nconsole.log(\"Hello World!\")\n&lt;/script&gt;\n&lt;noscript&gt;Your browser does not support JavaScript!&lt;/noscript&gt;\n</code></pre>"},{"location":"bloque_i/tema_2/page-1/","title":"1 Estructura del c\u00f3digo","text":""},{"location":"bloque_i/tema_2/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Las instrucciones de Javascript se pueden a\u00f1adir a un fichero de extensi\u00f3n <code>.js</code> e importarlo o directamente escribirlo en el documento a trav\u00e9s de la etiqueta <code>&lt;script&gt;&lt;/script&gt;</code>.</p> <p>Es importante destacar que el c\u00f3digo son las l\u00edneas del fichero que emiten ordenes para ser ejecutadas.</p>"},{"location":"bloque_i/tema_2/page-1/#sentencia","title":"Sentencia","text":"<p>Las sentencias son construcciones sint\u00e1cticas y comando que realiza acciones. Una sentencia es la unidad m\u00ednima de ejecuci\u00f3n de un programa. Un programa se compone de conjunto de sentencias que acaban resolviendo un problema.</p> <p>En nuestro c\u00f3digo, puede haber tantas sentencias como sea necesarias separadas por un punto y coma <code>;</code> o un salto de l\u00ednea.</p> <p>Tips</p> <p>Se aconseja que las sentencias se escriban separadas en l\u00ednea, para as\u00ed tener una mayor legibilidad del c\u00f3digo y facilitar as\u00ed su entendimiento.</p> <p>Veamos ejemplos de sentencias:</p> <pre><code>console.log('Mi primera sentencia');\nconsole.log('Mi segunda sentencia, pero no termina en punto y coma')\nconsole.log('\u00daltima sentencia de este script')\n</code></pre> <p>\u00a1CUIDADO!</p> <p>En la mayor\u00eda de los casos, un salto de l\u00ednea implica un punto y coma de forma impl\u00edcita, pero en NO siempre es as\u00ed. Podemos tener una sentencia y querer escribirla en diferentes l\u00edneas, el int\u00e9rprete sobre entiende que dicho salto de l\u00ednea no es un punto y como impl\u00edcito, si no una separaci\u00f3n normal, por lo que se ejecutar\u00eda la sentencia tal y como se desea:</p> <pre><code>console.log(3\n+\n2);\n</code></pre> <p>En el ejemplo anterior la salida es <code>5</code>, que es el resultado de sumar <code>3 + 2</code></p> <p>Hay que tener cuidado, porque en cierta ocasiones un salto de l\u00ednea no implica un punto y coma impl\u00edcito, sino que por el contrario se entiende como una separaci\u00f3n de c\u00f3digo y es algo que no el desarrollador no ha contemplado. Para dicho caso, se recomienda separar las l\u00edneas de c\u00f3digo con un punto y coma expl\u00edcito <code>;</code>. Veamos un ejemplo:</p> <pre><code>console.log('Hola mundo')\n[1, 2].forEach(console.log) // (1)!\n</code></pre> <ol> <li>\u274cEsto da error, porque se intenta ejecutar de la siguiente manera <code>console.log('Hola mundo')[1, 2].forEach(console.log)</code>, es decir, como una \u00fanica sentencia en lugar de dos.\u274c</li> </ol> <p>Para evitar el error anterior, se debe colocar punto y coma en la l\u00ednea que da problemas, y as\u00ed indicar que se trata de m\u00e1s de una sentencia:</p> <pre><code>console.log('Hola mundo');\n[1, 2].forEach(console.log)\n</code></pre> <p>Tips</p> <p>Es cierto que en la comunidad existen dos tipos de personas, los que utilizan el punto y coma en cada sentencia, o los que usa un salto de l\u00ednea en su lugar. Cada uno debe usar la t\u00e9cnica que mejor le parezca, pero siempre y cuando se intente evitar los errores mencionados anteriormente,</p>"},{"location":"bloque_i/tema_2/page-1/#comentarios","title":"Comentarios","text":"<p>Los comentarios son parte del c\u00f3digo que NO van a ser ejecutadas y se utilizan para dar informaci\u00f3n extra del c\u00f3digo que se esta desarrollando. Pueden ir escritos en cualquier lugar del script y son ignoradas por el motor (int\u00e9rprete) del navegador, por lo que el usuario no podr\u00e1 visualizarlos. Existen dos tipos de comentarios:</p> <ul> <li> <p>Comentarios en l\u00ednea: Solo ocupan un l\u00ednea y suelen usarse para comentarios puntuales y breves. Comienzan con dos barras diagonales <code>//</code>:</p> <pre><code>// Este es mi primer comentario en l\u00ednea\nconsole.log('Hey!')\n</code></pre> </li> <li> <p>Comentarios en bloque: Ocupan varias l\u00edneas y suelen usarse para comentarios m\u00e1s extensos. Comienzan con una barra inclinada y un asterisco <code>/*</code> y terminan con un asterisco y una barra inclinada <code>*/</code>:</p> <pre><code>/*\nEste es \nmi primer\ncomentario en \nbloque.\n*/\nconsole.log('Hey!')\n</code></pre> </li> </ul> <p>Los comentarios son una parte esencial del c\u00f3digo ya que proveen informaci\u00f3n sobre el mismo y ayudan a recordarnos a nosotros mismos porque decimos escribir dicho c\u00f3digo, adem\u00e1s de que si el c\u00f3digo es creado en grupo, ayuda a que todo el equipo entienda cual es nuestro objetivo con \u00e9l.</p> <p>Sin embargo, no se recomienda usar los comentarios para informaci\u00f3n personal, como contrase\u00f1as, ya que desde DevTools se puede acceder al script completo incluyendo los comentarios. Existen ciertas herramientas que para evitar eso, minimizan los scripts, eliminando los comentarios, que es lo recomendados antes de la publicaci\u00f3n de nuestra aplicaci\u00f3n.</p> <p>Warning</p> <p>No se permite escribir comentarios anidados, y en caso de intentarlo, ser\u00eda lanzado un error:</p> <pre><code>/*\n  /* comentario anidado ?!? */\n*/\nconsole.log( 'Mundo' );\n</code></pre>"},{"location":"bloque_i/tema_2/page-1/#expresiones","title":"Expresiones","text":"<p>Una expresi\u00f3n es una combinaci\u00f3n de operadores y operandos que se eval\u00faa gener\u00e1ndose un \u00fanico resultado de un tipo determinado.</p> <pre><code>console.log(3 + 2);\n</code></pre> <p>La diferencia entre las sentencias y las expresiones es que las expresiones devuelven un valor y las sentencias no devuelven nada.</p>"},{"location":"bloque_i/tema_2/page-1/#bloque","title":"Bloque","text":"<p>Un bloque es un conjunto de sentencias las cuales est\u00e1n delimitadas por llaves:</p> <pre><code>{\n// sentencias\n}\n</code></pre>"},{"location":"bloque_i/tema_2/page-2/","title":"2 Modo estricto","text":""},{"location":"bloque_i/tema_2/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Durante mucho tiempo, JavaScript evolucion\u00f3 sin problemas de compatibilidad. Se a\u00f1ad\u00edan nuevas caracter\u00edsticas al lenguaje sin que la funcionalidad existente cambiase.</p> <p>Esto ten\u00eda el beneficio de nunca romper c\u00f3digo existente, pero lo malo era que cualquier error o decisi\u00f3n incorrecta tomada por los creadores de JavaScript se quedaba para siempre en el lenguaje.</p> <p>Esto fue as\u00ed hasta 2009, cuando ECMAScript 5 (ES5) apareci\u00f3. Esta versi\u00f3n a\u00f1adi\u00f3 nuevas caracter\u00edsticas al lenguaje y modific\u00f3 algunas de las ya existentes. Entre ellas el uso estricto.</p>"},{"location":"bloque_i/tema_2/page-2/#use-strict","title":"use-strict","text":"<p>El use-strict es una nueva directiva del ES5 que indica que el c\u00f3digo debe ejecutarse en modo estricto. Todos los navegadores modernos admiten el use-strict, excepto Internet Explorer 9 y versiones anteriores.</p> <p>Para poder declarar el modo estricto, se puede realizar de dos formas:</p> <ul> <li> <p>Alcance global. Se usa el modo estricto en todo el script. Para ello, debe ser declarado como la primera sentencia de nuestro script.</p> <pre><code>\"use strict\"\nconsole.log('Hello world')\n</code></pre> </li> <li> <p>Alcance local. Se usa el modo estricto \u00fanicamente en la funci\u00f3n indicada. Para ello, debe ser declarado como la primera sentencia de nuestra funci\u00f3n.</p> <pre><code>console.log('Hello world')\nfunction con(){\n'use strict'\nconsole.log('This is a function')\n}\n</code></pre> </li> </ul> <p>!!! danger '!OJO!'</p> <pre><code>Si se desea un alcance global y se declara el modo estricto en una l\u00ednea diferente a la primera, el modo estricto es completamente ignorado:\n\n```javascript\nconsole.log('Hello world')\n\n'use strict' // \u274c No funciona\n```\n</code></pre> <p>El uso del modo estricto permite la escritura de c\u00f3digo Javascript de forma segura. Javascript es un lenguaje ampliamente flexible, lo que en ciertas ocasiones puede resultar peligroso. Al hacer uso del modo estricto podemos evitar que algunos de esos error se lleguen a cometer. Por ejemplo, en Javascript se puede usar una variable sin ser declarada previamente, lo que por defecto no se mostrar\u00e1 como un error al programador. Sin embargo, con el modo estricto dicha mala pr\u00e1ctica ser\u00e1 marcada como un error.</p>"},{"location":"bloque_i/tema_2/page-2/#prohibiciones-del-modo-estricto","title":"Prohibiciones del modo estricto","text":"<p>El modo estricto tiene cierta prohibiciones, es decir, cosas que con Javascript normal no se lanzar\u00eda un error, pero con el modo estricto s\u00ed. Varios de los conceptos descritos a continuaci\u00f3n, a\u00fan no han sido tratados, por lo que se recomienda visitar este apartado con cierta regularidad.</p> <p>Entre sus prohibiciones podemos encontrar:</p> <ul> <li> <p>No permite usar ni una variable ni un objeto sin declararlo.</p> <pre><code>x = 3.14 //\u274c\n</code></pre> </li> <li> <p>No permite eliminar ni una variable ni un objeto ni una funci\u00f3n.</p> <pre><code>let x = 3.14\ndelete x // \u274c\n</code></pre> </li> <li> <p>No se permite duplicar el nombre de un par\u00e1metro de una funci\u00f3n.</p> <pre><code>function myFunction(x1, x1){} //\u274c\n</code></pre> </li> <li> <p>No se permite literales num\u00e9ricos octales, ni caracteres de escape octal.</p> <pre><code>let x = 010 // \u274c\nlet x = \"\\010\" // \u274c\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_2/page-2/#se-deberia-usar","title":"\u00bfSe deber\u00eda usar?","text":"<p>Aunque la pregunta parece obvia, ciertamente no lo es. Se recomienda el uso de <code>use strict</code>, pero es cierto que las librer\u00edas actuales de Javascript tienen habilitada autom\u00e1ticamente esta opci\u00f3n, por lo que no ser\u00eda necesario que fuera usado expl\u00edcitamente por nosotros. Adem\u00e1s, las clases y m\u00f3dulos de Javascript tambi\u00e9n tienen activada dicha opci\u00f3n por defecto, por lo que tampoco ser\u00eda necesario.</p> <p>Tips</p> <p>Se recomienda que durante el desarrollo de Javascript b\u00e1sico si exista la posibilidad de usar el modo estricto, y una vez avanzado a las clases y m\u00f3dulos, dejar de usarlo.</p>"},{"location":"bloque_i/tema_2/page-3/","title":"3 Variables y constantes","text":""},{"location":"bloque_i/tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>A la largo del desarrollo de un script es necesario utilizar cierta informaci\u00f3n de forma repetida, por lo que es \u00fatil poder almacenar dicha informaci\u00f3n y poder usarlo en las partes del c\u00f3digo en las que sean necesarias.</p> <p>En programaci\u00f3n, existen las variables y las constantes para desempe\u00f1ar dicha funci\u00f3n.</p>"},{"location":"bloque_i/tema_2/page-3/#variables","title":"Variables","text":"<p>Las variables son contenedores que sirven para almacenar los datos que utiliza un programa. Dicho m\u00e1s sencillamente, son nombres que asociamos a determinados datos. La realidad es que cada variable ocupa un espacio en la memoria RAM del ordenador para almacenar el dato al que se refiere. Es decir, cuando utilizamos el nombre de la variable realmente estamos haciendo referencia a un dato que est\u00e1 en memoria.</p> <p>En Javascript existen dos limitaciones para nombrar a una variable:</p> <ol> <li>El nombre \u00fanicamente puede incluir letras, d\u00edgitos o los s\u00edmbolos <code>$</code> y <code>_</code>. Ejemplo: <code>$var</code>, <code>_var</code>, <code>var123</code>.</li> <li>El primer car\u00e1cter no puede ser un d\u00edgito. Ejemplo err\u00f3neos: <code>1var</code>.</li> </ol> <p>Se recomienda hacer uso de nombres descriptivos pero breves. La elecci\u00f3n de un nombre de variable debe ser mnem\u00f3nico, es decir, dise\u00f1ado para indicar al observador casual la intenci\u00f3n de su uso. Por ejemplo, si queremos usar una variable para almacenar una edad, la llamaremos <code>edad</code>. Adem\u00e1s se deber\u00eda evitar los nombres de variables de un solo car\u00e1cter excepto para las variables temporales usar y tirar. Los nombres comunes de las variables temporales son <code>i</code>, <code>j</code>, <code>k</code>, <code>m</code>, y <code>n</code> para enteros; <code>c</code>, <code>d</code>, y <code>e</code> para los caracteres.</p> <p>El estilo del nombre de las variables suele camelCase (o lowerCamelCase), es decir, las palabras van seguidas una detr\u00e1s de otra, con cada inicial en may\u00fascula, excepto la primera que va en min\u00fascula: <code>miPrimeraVariable</code>.</p> <p>Warning</p> <p>Es importante tener en cuenta la capitalizaci\u00f3n, ya que el mismo nombre escrito de formas diferentes da a lugar a dos variables distintas. <code>manzana</code> y <code>MANZANA</code> son dos variables distintas a pesar de tener el mismo nombre.</p> <p>Javascript permite escribir letras de cualquier alfabeto incluyendo letras del cir\u00edlico, logogramas chinos, etc., incluso nuestra letra <code>\u00f1</code>, pero no se recomienda su uso ya que existe una tradici\u00f3n internacional de utilizar ingl\u00e9s en el nombramiento de variables. Incluso si estamos escribiendo un script peque\u00f1o, este puede tener una larga vida por delante. Puede ser necesario que gente de otros pa\u00edses deba leerlo en alg\u00fan momento.</p> <p>Otra prohibici\u00f3n a tener en cuenta a la hora de nombra variables es que no se pueden utilizar palabras que usa el mismo lenguaje. Estas palabras son denominadas como palabras reservadas. Por ejemplo, no se puede usar la palabra <code>let</code> como nombre de variable. En la siguiente web, puedes conocer el listado oficial de este tipo de palabras: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords</p>"},{"location":"bloque_i/tema_2/page-3/#declaracion-de-una-variable","title":"Declaraci\u00f3n de una variable","text":"<p>Para declarar una variable es necesario usar la palabra <code>let</code> seguida del nombre de la variable:</p> <pre><code>let miPrimeraVariable\n</code></pre> <p>Se puede inicializar una variable, o cambiar el valor de la misma haciendo uso del operador <code>=</code>:</p> <pre><code>miPrimeraVariable = 10\n</code></pre> <p>Adem\u00e1s, se puede acceder a dicha variable usando su nombre:</p> <pre><code>let message message = 'Hello world'\nconsole.log(message)\n</code></pre> <p>Javascript permite definir una variable, es decir, declarar e inicializar una variable en una \u00fanica l\u00ednea:</p> <pre><code>let message = \"hello world\"\n</code></pre> <p>Tambi\u00e9n se puede definir y declarar varias variables en una sola l\u00ednea, separadas por coma <code>,</code>:</p> <pre><code>let name = 'John Doe', age = 25, message = 'Hello world'\n</code></pre> <p>Lo anterior, se podr\u00eda hacer en m\u00faltiples l\u00ednea, aunque no se recomienda:</p> <pre><code>let name = 'John Doe', age = 25, message = 'Hello world'\n</code></pre> <p>Tips</p> <p>Por norma general, se recomienda definir o declarar las variables en l\u00edneas diferentes con diferentes <code>let</code>. Aunque, es cierto que si son pocas variables y con informaci\u00f3n f\u00e1cil de leer, se podr\u00eda usar la forma m\u00faltiple lineal sin problema.</p> <p>Warning</p> <p>Declarar dos veces la misma variable produce un error de ejecuci\u00f3n.</p> <pre><code>let message = \"This\";\nlet message = \"That\"; // SyntaxError: 'message' ya fue declarado\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#funcionamiento-de-una-variable","title":"Funcionamiento de una variable","text":"<p>Podemos entender una variable como una caja que se encarga de almacenar informaci\u00f3n relevante para nuestro c\u00f3digo. Cuando una variable es declarada (no inicializada), estamos creando dicha caja, y una vez inicializada, almacenamos en la caja el valor correspondiente. Cuando una variable es modificada, su valor actual es eliminado de la caja y se inserta el nuevo valor en ella. Veamos un ejemplo:</p> <pre><code>let message //(1)!\nmessage = 'Hello world' //(2)!\nmessage = 'Goodbye' //(3)!\n</code></pre> <ol> <li>Se crea la caja para almacenar informaci\u00f3n.</li> <li>Se almacena el valor Hello World por primera vez en la caja.</li> <li>Se elimina el valor Hello World y se a\u00f1ade el nuevo valor Goodbye.</li> </ol> <p>Esto en realizar se refiere a que cuando creamos una variable, se reserva un espacio de memoria y al inicializarla se escribe el dato deseado en su interior. Cuando se modifica, ese dato se elimina y se sobreescribe el nuevo valor.</p>"},{"location":"bloque_i/tema_2/page-3/#ambito-de-vida-de-las-variables","title":"\u00c1mbito de vida de las variables","text":"<p>Toda variable tiene un \u00e1mbito de vida. Esto es la parte del c\u00f3digo en la que una variable se puede utilizar, que es en el bloque donde se ha declarado. De hecho las variables tienen un ciclo de vida:</p> <ol> <li>En la declaraci\u00f3n se reserva el espacio necesario para que se puedan comenzar a utilizar (digamos que se avisa de su futura existencia)</li> <li>Se la asigna su primer valor (la variable nace)</li> <li>Se la utiliza en diversas sentencias. Cuando finaliza el bloque en el que fue declarada, la variable muere. Es decir, se libera el espacio que ocupa esa variable en memoria.</li> <li>Una vez que la variable ha sido eliminada, no se puede utilizar. Dicho de otro modo, no se puede utilizar una variable m\u00e1s all\u00e1 del bloque en el que ha sido definida. Ejemplo:</li> </ol> <p>Podemos entender que una variable puede tener un \u00e1mbito de vida local o global. Podemos entender como una variable global, como aquella variable que puede ser accedida desde cualquier parte de nuestro script, es decir, la variable es declarada en el script y puede ser usada tanto dentro como fuera de cualquier bloque.</p> <pre><code>let number = 10\nconsole.log(number)\n</code></pre> <p>Por el contrario, una variable local es una variable que se declara dentro de un bloque y solo puede ser usada en dicho bloque y nunca fuera de \u00e9l:</p> <pre><code>{\nlet number = 10\nconsole.log(number)\n}\nconsole.log(number) // \u274c ReferenceError: number is not defined\n</code></pre> <p>Warning</p> <p>Normalmente, debemos definir una variable antes de utilizarla. Pero, en los viejos tiempos, era t\u00e9cnicamente posible crear una variable simplemente asignando un valor sin utilizar <code>let</code>. Esto a\u00fan funciona si no hacemos uso de <code>use strict</code> en nuestros scripts para mantener la compatibilidad con scripts antiguos.</p> <pre><code>num = 5; // se crea la variable \"num\" si no existe antes\nalert(num); // 5\n</code></pre> <p>Esto ser\u00eda una mala pr\u00e1ctica que se puede evitar haciendo del modo estricto:</p> <pre><code>\"use strict\";\nnum = 5; // \u274c error: num no est\u00e1 definida\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#constantes","title":"Constantes","text":"<p>Una constante es un valor que no puede ser modificado durante la ejecuci\u00f3n de un programa, \u00fanicamente puede ser le\u00eddo. Para crear una constante en Javascript se usa la palabra reservada <code>const</code> seguida del nombre de la variable y su inicializaci\u00f3n:</p> <pre><code>const miPrimeraConstante = 10\n</code></pre> <p>Al intentar modificar el valor de una variable producir\u00eda un error:</p> <pre><code>const miPrimeraConstante = 10\nmiPrimeraConstante = 20 // \u274c ERROR\n</code></pre> <p>Tips</p> <p>Existe una buena pr\u00e1ctica de escribir en may\u00fasculas y con guiones <code>_</code>, aquellas constantes que hacen referencia a ciertos datos que son dif\u00edciles de recordar, como por ejemplo el c\u00f3digo hexadecimal de un color:</p> <pre><code>const COLOR_RED = \"#F00\";\nconst COLOR_GREEN = \"#0F0\";\nconst COLOR_BLUE = \"#00F\";\nconst COLOR_ORANGE = \"#FF7F00\";\n</code></pre> <p>De esta forma podemos acceder al color rojo de una manera m\u00e1s sencilla usando su nombre de constante.</p> <p>Se aconseja escribir en may\u00fasculas aquellas constantes cuyo valor se conocen antes la ejecuci\u00f3n del programa y en min\u00fasculas aquellas cuyo valor se deben calcular u obtener durante la ejecuci\u00f3n:</p> <pre><code>const NAME = 'Server name'\nconst div = /*...*/\n</code></pre> <p>En el ejemplo anterior, la variable <code>NAME</code> se escribe en may\u00fasculas ya que es un valor que se conoce antes de ejecutar el script. Sin embargo, la variable <code>div</code> representa un elemento div del HTML por lo que no es un valor que se obtiene antes de la ejecuci\u00f3n del programa, sino que, por el contrario debe ser obtenido una vez se haya ejecutado el programa.</p>"},{"location":"bloque_i/tema_2/page-3/#var","title":"var","text":"<p>\u00a1OJO!</p> <p>La informaci\u00f3n transcrita en el siguiente punto tiene como objetivo \u00fanico INFORMAR sobre ciertos conocimientos antiguos de Javascript, por lo que NO se deber\u00edan llevar a la pr\u00e1ctica.</p> <p>La palabra reservada <code>var</code> se utilizaba en versiones anteriores de Javascript y tiene una utilizaci\u00f3n bastante similar a la palabra reservada <code>let</code>. Sin embargo, declarar una variable con <code>var</code> tiene ciertos usos peligrosos que fueren limitados con la incorporaci\u00f3n de <code>let</code>.</p> <p>Cuando declaramos una variable con <code>let</code> de forma global en nuestro script, dicha variable puede ser usada en cualquier parte de nuestro script, por lo que no se puede acceder a ella desde otros script (en caso de tener m\u00e1s de una etiqueta script en nuestro HTML, o diferentes m\u00f3dulos).</p> <pre><code>&lt;script&gt;\nlet number = 10\n&lt;/script&gt;\n&lt;script&gt;\n'use strict'\nconsole.log(number) // \u274c ERROR\n&lt;/script&gt;\n</code></pre> <p>Sin embargo, haciendo uso de la palabra <code>var</code>, esto si puede suceder, de forma que se puede declarar una variable en un script y poder usarlo en cualquier cualquier otro script, y en cualquier parte de nuestro c\u00f3digo, incluso si se declara dentro de un bloque:</p> <pre><code>&lt;script&gt;\n{\nvar number = 10\n}\n&lt;/script&gt;\n&lt;script&gt;\n'use strict'\nconsole.log(number)\n&lt;/script&gt;\n</code></pre> <p>Lo que ocurre en el ejemplo, no es una buena pr\u00e1ctica ya que exponemos a que nuestras variables sean modificadas desde cualquier parte, dentro o fuera de nuestro script.</p> <p>Otra de las malas pr\u00e1cticas que tiene el uso de <code>var</code>, es que permite redeclarar una variable, cosa que con el uso de <code>let</code> se ve limitado ya que lanza un error:</p> <pre><code>let number = 10\nlet number = 20 // \u274c ERROR\nvar number = 10\nvar number = 20\n</code></pre> <p>En este caso, se ignora la declaraci\u00f3n y \u00fanicamente se cambia su valor.</p> <p>Otra de las malas pr\u00e1cticas que tiene su uso es el hoisting (elevamiento). Permite inicializar la variable incluso antes de su declaraci\u00f3n, ya que no importa en el lugar que se declare porque siempre va a ser elevada al principio. Veamos un ejemplo:</p> <pre><code>phrase = \"Hello\";\nconsole.log(phrase);\nvar phrase;\n</code></pre> <p>En el c\u00f3digo anterior, permite inicializar la variable, y luego se declarar, aunque en realizar lo primero que se ejecuta es la declaraci\u00f3n debido al elevamiento. Esto puede provocar una dif\u00edcil legibilidad. El c\u00f3digo anterior, se ejecutar\u00eda de esta forma:</p> <pre><code>var phrase;\nphrase = \"Hello\";\nconsole.log(phrase);\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Crea un script que realice los siguientes pasos:</p> <ol> <li>Declara dos variables: <code>admin</code> y <code>name</code>.</li> <li>Asigna el valor John a la variable <code>name</code>.</li> <li>Copia el valor de <code>name</code> en <code>admin</code>.</li> <li>Muestra por consola el valor de la variable <code>admin</code>, en color verde.</li> </ol> Ejercicio 2 <p>\u00bfC\u00f3mo nombrar\u00edas las siguientes variables?:</p> <ul> <li>Nombre actual del usuario que ha iniciado sesi\u00f3n en nuestra web.</li> <li>Nombre de nuestro planeta.</li> <li>Tiempo transcurrido desde el comienzo de una tarea, hasta su finalizaci\u00f3n.</li> <li>Fecha de nacimiento de un empleado.</li> <li>Capacidad m\u00e1xima de un disco duro.</li> <li>Capacidad ocupada de un disco duro.</li> <li>Capacidad sobrante de un disco duro.</li> </ul> Ejercicio 3 <p>Dado el siguiente c\u00f3digo, \u00bfcu\u00e1l dir\u00edas que deber\u00eda ir en may\u00fasculas? Justifica tu respuesta:</p> <pre><code>const birthday = '18.04.1982';\nconst age = calculateAgeFromDate(birthday);\n</code></pre>"},{"location":"bloque_i/tema_2/page-4/","title":"4 Tipos de datos b\u00e1sicos","text":""},{"location":"bloque_i/tema_2/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Javascript es un lenguaje tipado d\u00e9bil, es decir, no te obliga a indicar el tipo de las variables a la hora de declararlas. Sin embargo, esto no quiere decir que una variable no sea de un tipo especificado y que es bueno conocer los tipos de datos con los que se va a trabajar.</p> <p>Javascript tambi\u00e9n es un lenguaje din\u00e1micamente tipado. Esto quiere decir, que una variable puede ser declarada como un tipo, por ejemplo una cadena, y durante la ejecuci\u00f3n del programa puede pasar a ser un n\u00famero.</p> <pre><code>let variable = \"Hello\"\nvariable = 123\n</code></pre> <p>Aunque esto pueda parecer un gran acierto en Javascript, es cierto, que en ciertas ocasiones puede ser un problema, dependiendo de la utilidad que se le quiera dar a dicha variable. Por ejemplo, si queremos hacer una divisi\u00f3n, debemos disponer de dos n\u00fameros, si ahora bien, uno de esos n\u00fameros son introducidos por el usuario y \u00e9ste introduce una cadena, la operaci\u00f3n no ser\u00eda v\u00e1lida. Por ello, es recomendable realizar comprobaciones de tipo cuando sea necesario</p> <p>Existen ocho tipos de datos b\u00e1sicos diferentes en Javascript: <code>Number</code>, <code>BigInt</code>, <code>String</code>, <code>Boolean</code>, <code>null</code>, <code>undefined</code>, <code>Object</code> y <code>Symbol</code>. Adem\u00e1s, tambi\u00e9n existen otras estructuras de datos como las clases y los arrays.</p>"},{"location":"bloque_i/tema_2/page-4/#number","title":"Number","text":"<p>El tipo <code>number</code> representa los n\u00fameros en Javascript, tanto los n\u00fameros enteros, como los n\u00fameros de punto flotantes (decimales). El tipo <code>number</code> representa los n\u00fameros <code>+(2\u2075\u00b3+1)</code> y <code>-(2\u2075\u00b3-1)</code>.</p> <pre><code>let number = 2\nlet decimal = 1.60\n</code></pre> <p>Adem\u00e1s de los n\u00fameros comunes, existen los denominados valores num\u00e9ricos especiales que pertenecen a este tipo y representan un valor matem\u00e1tico especial:</p> <ul> <li><code>Infinity</code>. Representa el infinito matem\u00e1tico (<code>\u267e\ufe0f</code>). Es un n\u00famero especial que es mayor que cualquier otro n\u00famero. Haciendo uso del operador <code>-</code>, existir\u00e1 el <code>-Infinity</code> que representa el infinito negativo, siendo un n\u00famero m\u00e1s peque\u00f1o que cualquier otro. Este n\u00famero puede ser obtenido al dividir un n\u00famero entre 0.</li> <li> <p><code>NaN</code>. Representa un error de c\u00e1lculo. Es el resultado de un operaci\u00f3n matem\u00e1tica incorrecta o indefinida. Por ejemplo, es el resultado de dividir una cadena a un n\u00famero. Las siglas NaN significan Not a Number (No es n\u00famero), por lo que indica que el resultado de un operaci\u00f3n matem\u00e1tica que espera un n\u00famero no retorna el tipo esperado. Cualquier operaci\u00f3n que se haga con un operando de valor <code>NaN</code>, tambi\u00e9n devuelve un <code>NaN</code>, excepto <code>NaN ** 0 = 1</code>.</p> <p>Info</p> <p>Las operaciones matem\u00e1ticas, en Javascript, son operaciones seguras. A diferencia de otros lenguajes, como en Java, cuando se realizan operaciones vulnerables (dividir por cero, dividir una cadena por un n\u00famero) no lanza un error fatal, si no que por el contrario, si no que retorna un valor especial matem\u00e1tico como <code>NaN</code> o <code>Infinity</code>, salvaguardando as\u00ed el flujo de la aplicaci\u00f3n.</p> </li> </ul>"},{"location":"bloque_i/tema_2/page-4/#bigint","title":"BigInt","text":"<p>EL tipo <code>BigInt</code> representan n\u00fameros enteros de tama\u00f1o superior a <code>\u00b1(2\u2075\u00b3-1)</code>. Este tipo de n\u00famero existe, porque cuando se intenta realizar una operaci\u00f3n con <code>number</code> cuyo resultado quede fuera de dicho rango, habr\u00e1 un error de precisi\u00f3n:</p> <pre><code>console.log(9007199254740991 + 1); // 9007199254740992\nconsole.log(9007199254740991 + 2); // 9007199254740992\n</code></pre> <p>Para la mayor\u00eda de los prop\u00f3sitos, el rango de tipo <code>number</code> es suficiente, sin embargo a veces es necesario n\u00fameros realmente grandes, como para la criptograf\u00eda o estudios cient\u00edficos.</p> <p><code>BigInt</code> fue agregado recientemente a Javascript para solventar dicho problema de precisi\u00f3n. Para indicar que un n\u00famero es de tipo <code>BigInt</code> o no de tipo <code>number</code> se debe agregar una <code>n</code> al final de n\u00famero:</p> <pre><code>const bigInt = 1234567890123456789012345678901234567890n\n</code></pre>"},{"location":"bloque_i/tema_2/page-4/#string","title":"String","text":"<p>El tipo de dato <code>String</code> representa una cadena de caracteres y debe colocarse entre comillas:</p> <pre><code>const str = \"Soy una cadena\"\n</code></pre> <p>En Javascript se puede inicializar una cadena haciendo uso de tres tipos de comillas diferentes:</p> <ul> <li>Comillas dobles: <code>\"Hola\"</code>.</li> <li>Comillas simples: <code>'Hola'</code></li> <li>Comillas invertidas (backticks): <code>`Hola`</code></li> </ul> <p>Entre las comillas dobles y las comillas simples no existen diferencias entres ellas, simplemente sirven para mostrar literalmente el contenido de la cadena. Por ejemplo, si tengo la variable <code>sum = \"2+3\"</code> el valor de la variable es literalmente <code>2+3</code> y no <code>5</code>, que es el resultado de la suma.</p> <p>Por otro lado, las comillas backticks son comillas de funcionalidad extendida, es decir, nos permiten incrustar variables y expresiones de tal formal que el valor de la cadena sea el valor de la variable o expresi\u00f3n. Para ello, la variable o la expresi\u00f3n debe estar envuelta en <code>${...}</code>:</p> <pre><code>let name = \"John\"\nlet lastName = \"Doe\"\nlet fullName = `${name} ${lastName}`\nconsole.log(fullName) // \"John Doe\"\nlet number1 = 2\nlet number2 = 3\nlet result = `Result is ${number1 + number2}`\nconsole.log(result) // \"Result is 5\"\n</code></pre> <p>La expresi\u00f3n dentro de <code>${...}</code> se eval\u00faa y el resultado pasa a formar parte de la cadena. Podemos poner cualquier cosa ah\u00ed dentro: una variable como <code>name</code>, una expresi\u00f3n aritm\u00e9tica como <code>1 + 2</code>, o algo m\u00e1s complejo.</p> <p>Warning</p> <p>El uso de <code>${...}</code> solo se puede realizar con las backticks para el resto de comillas no funcionaria, ya que solo muestra el resultado literal:</p> <pre><code>const name = \"John\"\nconst lastName = \"Doe\"\nconst fullName = \"${name} ${lastName}\"\nconsole.log(fullName) // \"${name} ${lastName}\"\n</code></pre> <p>Info</p> <p>En algunos lenguajes, hay un tipo especial car\u00e1cter para un solo car\u00e1cter. Por ejemplo, en el lenguaje C y en Java es char.</p> <p>En JavaScript no existe tal tipo. S\u00f3lo hay un tipo: <code>string</code>. Un string puede estar formado por un solo car\u00e1cter, por ninguno, o por varios de ellos. </p> <p>Es importante conocer este dato, porque en ocasiones es necesario obtener solo un car\u00e1cter y el usuario es libre de introducir una cadena m\u00e1s ampl\u00eda, por lo que debe ser validado correctamente.</p>"},{"location":"bloque_i/tema_2/page-4/#boolean","title":"Boolean","text":"<p>El tipo <code>boolean</code> hace referencia a los valores <code>true</code> y <code>false</code>. Este tipo es usado com\u00fanmente para almacenar valores afirmativos (true) o negativos (false). Por ejemplo, s\u00ed, correcto, verdadero ser\u00edan formas de representar el valor <code>true</code>, mientras que no, incorrecto y falso para representar el valor <code>false</code>.</p> <pre><code>const isLegalAge = true\nconst isUserLogged = false\n</code></pre> <p>Los valores booleanos tambi\u00e9n son los resultados de realizar comparaciones, como veremos m\u00e1s adelante. Por ejemplo, <code>3 &gt; 4</code> ser\u00eda false ya que el n\u00famero 3 no es mayor que el n\u00famero 4.</p>"},{"location":"bloque_i/tema_2/page-4/#null","title":"null","text":"<p>En Javascript, el valor <code>null</code> hace referencia a un objeto inexistente. S\u00f3lo es un valor especial que representa nada, vac\u00edo o valor desconocido.</p> <pre><code>const age = null;\n</code></pre> <p>En el c\u00f3digo anterior, la variable <code>age</code> tiene un valor vac\u00edo o desconocido por que a\u00fan no ha sido calculado o est\u00e1 en espera de ser introducido.</p>"},{"location":"bloque_i/tema_2/page-4/#undefined","title":"undefined","text":"<p>En Javascript, cuando una variable es declarada pero no definida se dice que es de tipo <code>undefined</code> que literalmente significa no definida.</p> <p>La diferencia con <code>null</code>, es que el tipo <code>undefined</code> quiere decir que la caja que va a contener el valor a\u00fan no ha sido definida como tal, mientras que con <code>null</code>, la caja ha sido definida pero est\u00e1 completamente vac\u00eda.</p> <p>Aunque se puede asignar a una variable el valor <code>undefined</code> es algo que por legibilidad de c\u00f3digo no se recomienda. Para ello, se recomienda hacer uso del tipo <code>null</code>.</p> <p>Tanto <code>undefined</code> y <code>null</code> son tipos propios de Javascript.</p>"},{"location":"bloque_i/tema_2/page-4/#ejercicios","title":"Ejercicios","text":"Ejercicio 4 <p>\u00bfCu\u00e1l es la salida del siguiente script?</p> <pre><code>let name = \"Ilya\"\nconsole.log( `Hola ${1}` )    console.log( `Hola ${\"name\"}` )    console.log( `Hola ${name}` )\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/","title":"5 Operadores","text":""},{"location":"bloque_i/tema_2/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Los operadores son s\u00edmbolos que se utilizan para evaluar un expresi\u00f3n y as\u00ed devuelva un resultado. Por ejemplo, el operador <code>+</code> sirve para evaluar una suma y que as\u00ed devuelva un n\u00famero. Los operandos son los valores que interact\u00faan en la evaluaci\u00f3n, es decir, las partes de la operaci\u00f3n.</p> <p>Existen diferentes tipos de operadores, entre ellos:</p> <ul> <li>Operadores unarios. Son operadores que solo necesitan un \u00fanico operando.</li> <li>Operadores binarios. Son operadores que necesitan dos operandos, como la suma.</li> <li>Operadores ternarios. Son operadores que necesitan tres operandos.</li> </ul>"},{"location":"bloque_i/tema_2/page-5/#operadores-unarios","title":"Operadores unarios","text":"<p>En Javascript, los s\u00edmbolos positivo <code>+</code> y negativos <code>-</code> son operadores unarios que eval\u00faan el signo el operador. De esta forma podemos usar <code>-</code> para pasar un n\u00famero positivo a negativo:</p> <pre><code>console.log(+2) // positive number\nconsole.log(-2) // negative number\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operadores-matematicos","title":"Operadores matem\u00e1ticos","text":"<p>En Javascript tenemos los siguientes operadores para poder realizar operaciones matem\u00e1ticas:</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo + Suma 2.5 + 7.1 9.6 - Resta 235.6 - 103.5 132.1 * Multiplicaci\u00f3n 1.2 * 1.1 1.32 / Divisi\u00f3n 0.050 / 0.027 / 2 0.253 % Resto Divisi\u00f3n entera 20 % 714.5 % 2 60.5 ** Exponenciaci\u00f3n 2 ** 2 4 <p>El operador exponenciaci\u00f3n sirve para realizar potencias o ra\u00edces. Para realizar ra\u00edces es necesario que el exponente de la potencia sea una fracci\u00f3n. Por ejemplo, para calcular la ra\u00edz cuadrada de 4: <code>2 ** (1/2)</code></p>"},{"location":"bloque_i/tema_2/page-5/#concatenar-cadenas","title":"Concatenar cadenas","text":"<p>El operador binario <code>+</code> tiene un tercer uso, concatenar cadenas. Une una o m\u00e1s cadenas obteniendo como resultado una nueva cadena completa.</p> <pre><code>const name = 'Jane'\nconst lastName = 'Doe'\nconst fullName = name + ' ' + lastName\nconsole.log(fullName) // Jane Doe\n</code></pre> <p>Hay que tener en cuenta que cuando se usa el operador de concatenaci\u00f3n con n\u00fameros, estar\u00edamos realizando una suma. Sin embargo, si uno de los dos operandos es de tipo cadena, aunque el otro sea un n\u00famero o un booleano, siempre concatenar\u00e1, incluso si la cadena es de un d\u00edgito:</p> <pre><code>console.log(1 + \"1\") //11\nconsole.log(\"1\" + 2) //12\n</code></pre> <p>En Javascript, si hay m\u00e1s de un operando y el operador es binario se va realizando la operaci\u00f3n de dos en dos, seg\u00fan un orden que veremos posteriormente. De esta manera:</p> <pre><code>console.log(2 + 2 + \"2\") // 4 + \"2\" = \"42\"\nconsole.log(\"2\" + 2 + 4) // \"22\" + 4 = \"224\"\n</code></pre> <p>Warning</p> <p>El operador binario <code>+</code> es el \u00fanico operador binario que trata a las cadenas d\u00edgitos (las cadenas que son num\u00e9ricas) como cadenas y no los tratan como n\u00famero. El resto de operadores matem\u00e1ticos realizan la conversi\u00f3n de la cadena a n\u00famero, y en caso de no ser posible el resultado de la operaci\u00f3n ser\u00eda <code>NaN</code>.</p> <pre><code>console.log(2 - '1') // 1\nconsole.log('6' / '2') // 3\nconsole.log('hola mundo' / 2) //NaN\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operador-asignacion","title":"Operador Asignaci\u00f3n","text":"<p>El operador de asignaci\u00f3n <code>=</code> es un operador binario que sirve para asignar a una variable un valor, por lo que los operandos ser\u00eda la variable el valor.</p> <pre><code>let a = 10\n</code></pre> <p>En Javascript, se permite encadenar varias asignaciones, de forma que se eval\u00faen de derecha a izquierda:</p> <pre><code>let a, b, c\na = b = c = 4\n</code></pre> <p>En el ejemplo anterior, se realiza una asignaci\u00f3n encadenada, de forma que primero se realiza la que est\u00e9 m\u00e1s a la derecha (<code>c = 4</code>) y luego las restantes (<code>b = c</code> y <code>c = a</code>).</p> <p>Aqu\u00ed una demostraci\u00f3n de una asignaci\u00f3n encadenada m\u00e1s compleja:</p> <pre><code>let a = 1;\nlet b = 2;\nlet c = 3 - (a = b + 1);\nconsole.log(a); // 3\nconsole.log(c); // 0\n</code></pre> <p>En el ejemplo anterior, primero se eval\u00faa la asignaci\u00f3n <code>a = b + 1</code> y su resultado de utiliza en la siguiente asignaci\u00f3n <code>c = 3 - 3</code>, por lo que el valor de la variable <code>c</code> acaba siendo 0.</p> <p>Aunque es cierto que Javascript te permite encadenar las asignaciones, no es algo que se recomienda fervientemente, por lo que es m\u00e1s legible hacerlo secuencialmente. As\u00ed el ejemplo anterior, ser\u00eda m\u00e1s legible de esta forma:</p> <pre><code>let a = 1;\nlet b = 2;\na = b + 1;\nlet c = 3 - a;\nconsole.log(a); // 3\nconsole.log(c); // 0\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operadores-combinados","title":"Operadores combinados","text":"<p>En ciertas ocasiones queremos asignarle a una variable un nuevo valor que depende de su valor anterior, por ejemplo, podemos incrementar 2 unidades.</p> <pre><code>let number = 2\nnumber = number + 2\nconsole.log(number) // 4\n</code></pre> <p>En Javascript (como en otros lenguajes), existe la posibilidad de combinar la operaci\u00f3n y asignaci\u00f3n en un solo operando, por ejemplo <code>+=</code>. De esta forma, el ejemplo anterior quedar\u00eda:</p> <pre><code>let number = 2\nnumber += 2\nconsole.log(number) // 4\n</code></pre> <p>Primero se indicar\u00eda el operador matem\u00e1tico y luego el de asignaci\u00f3n, de est\u00e1 forma se eval\u00faa primero la expresi\u00f3n (<code>number + 2</code>) y luego se realiza la asignaci\u00f3n (<code>number = 4</code>).</p> <p>Tambi\u00e9n se puede hacer uso de m\u00e1s de una operaci\u00f3n matem\u00e1tica, prevaleciendo \u00e9sta siempre primero antes de la asignaci\u00f3n. De esta forma:</p> <pre><code>let n = 2;\nn *= 3 + 5;\nconsole.log(n); // 16\n</code></pre> <p>En el ejemplo anterior, primero se eval\u00faa la operaci\u00f3n de suma (<code>3 + 5</code>) y luego se realiza la operaci\u00f3n de multiplicaci\u00f3n (<code>2 * 8</code>), y por \u00faltimo la asignaci\u00f3n (<code>16</code>).</p>"},{"location":"bloque_i/tema_2/page-5/#operadores-incrementodecremento","title":"Operadores incremento/decremento","text":"<p>Los operadores incrementales y decrementales sirven para modificar el valor de las variables en un unidad. El operador incremento <code>++</code> modificar el valor de la variable en una unidad de forma incremental, mientras que el de decremento <code>--</code> lo decrementa en una unidad.</p> <pre><code>let count = 2;\ncount++; // 3\ncount--; // 2\n</code></pre> <p>Importante</p> <p>Incremento/decremento s\u00f3lo puede ser aplicado a variables. Intentar utilizarlo en un valor como 5++ dar\u00e1 un error.</p> <p>Estos operadores puede ser colocados antes o despu\u00e9s de una variable, teniendo un comportamiento diferente. Esta diferente es notable durante la evaluaci\u00f3n de una expresi\u00f3n. Si se colocan como sufijo (antes de la variable), el valor se ver\u00e1 incrementado/decrementado despu\u00e9s de usar la variable en la expresi\u00f3n evaluada, mientras que si es usado como prefijo (despu\u00e9s de la variable), el valor se vera incrementado/decrementado antes de usar la variable en la expresi\u00f3n.</p> <pre><code>let number = 1\nconsole.log(number++) // 1\nconsole.log(number) //\n</code></pre> <p>En el ejemplo anterior, tenemos una variable con un valor inicial a <code>1</code>. Al hacer el incremento como sufijo, primero se usa el valor de la variable antes de incrementarse para mostrarla por pantalla, por lo que se mostrar\u00e1 1, y luego se incrementar\u00e1 a <code>2</code>.</p> <p>Ahora veamos una demostraci\u00f3n, con un incremento como prefijo:</p> <pre><code>let number = 1\nconsole.log(++number) //2\nconsole.log(number)\n</code></pre> <p>En esta ocasi\u00f3n, primero se incrementa el valor y luego se muestra por pantalla.</p> <p>Veamos un ejemplo m\u00e1s complejo:</p> <pre><code>let counter = 1\nlet expr = 2 ** counter++ // 2\nlet other = 2 ** ++otherCounter //8\n</code></pre> <p>El valor de la variable <code>expr</code> es dos, ya que utiliza un incremento de sufijo, por lo que primero se usa el valor anterior <code>1</code> para realizar la operaci\u00f3n <code>2 ** 1</code> y luego se incrementa a <code>2</code>. Mientras que, la variable <code>other</code> tiene resultado <code>8</code> al usar un incremento de prefijo, por lo que primero se ha incrementado el valor (de <code>2</code> a <code>3</code>) y luego se ha usado \u00e9ste para la operaci\u00f3n <code>2 ** 3</code>.</p>"},{"location":"bloque_i/tema_2/page-5/#operadores-a-nivel-de-bits","title":"Operadores a nivel de bits","text":"<p>Los operados a nivel de bits son operadores que tratan a los n\u00fameros como n\u00fameros enteros de 32 bits, trabajando con su representaci\u00f3n binaria. Este tipo de operadores no es exclusivo de Javascript, sino que tambi\u00e9n son utilizados en otros lenguajes.</p> <p>Estos operadores se usan de forma muy puntual, simplemente cuando es necesario el uso de la representaci\u00f3n de los n\u00fameros a un bajo nivel, pero a\u00fan as\u00ed es bueno tener conocimientos de ellos.</p> <p>Podemos encontrar los siguientes operadores:</p> <ul> <li> <p>AND (<code>&amp;</code>). Devuelve un 1 en las posiciones de bit d\u00f3nde las posiciones de los operadores tienen un 1, por el contrario devuelven un 0.</p> <pre><code>let x = 9 // 1001\nlet y = 12 // 1100\nconsole.log(x &amp; y) // 8 (1000)\n</code></pre> </li> <li> <p>OR (<code>|</code>). Devuelve un cero en las posiciones de bit d\u00f3nde las posiciones de los dos operadores tienen un 0, por el contrario devuelven un 1.</p> <pre><code>let x = 9 // 1001\nlet y = 12 // 1100\nconsole.log(x | y) // 13 (1101)\n</code></pre> </li> <li> <p>XOR (<code>^</code>). Devuelve un cero en las posiciones d\u00f3nde el bit es el mismo y un 1 d\u00f3nde las posiciones son diferentes.</p> <pre><code>let x = 9 // 1001\nlet y = 12 // 1100\nconsole.log(x ^ y) // 5 (0101)\n</code></pre> </li> <li> <p>NOT (<code>~</code>). Es un operador unario que intercambia el valor, es decir si la posici\u00f3n tiene un valor de cero es cambiado por uno y viceversa.</p> <pre><code>let x = 9 // 1001\nconsole.log(~x) // 5 (0110)\n</code></pre> </li> <li> <p>LEFT SHIFT (<code>&lt;&lt;</code>). Es un operador binaria cuyo segundo operado indica el n\u00famero de bits que se desplazar\u00e1n del primer operado hacia la izquierda. En otras palabras, se a\u00f1ade tantos 0 como se indica al final del binario.</p> <pre><code>let x = 2 // 0000010\nconsole.log(x &lt;&lt; 1) // 4 (00000100)\n</code></pre> </li> <li> <p>RIGHT SHIFT (<code>&gt;&gt;</code>). Es un operador binario cuyo segundo operado indica el n\u00famero de bits que se desplazar\u00e1n del primer operado hacia la derecha. En otras palabras, desaparece la cantidad de binarios indicada.</p> <pre><code>let x = 2 // 0000010\nconsole.log(x &gt;&gt; 1) // 1 (000001)\n</code></pre> </li> <li> <p>ZERO-FILL RIGHT SHIFT (<code>&gt;&gt;&gt;</code>). Es un operador binario cuyo segundo operado indica el n\u00famero de bits que se desplazar\u00e1n del primer operado hacia la derecha, pero a\u00f1adiendo 0 a la parte izquierda. En otras palabras, desaparece la cantidad de binarios indicada.</p> <pre><code>let x = 2 // 0000010\nconsole.log(x &gt;&gt;&gt; 1) // 1 (0000001)\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_2/page-5/#operador-coma","title":"Operador coma","text":"<p>El operador coma <code>,</code> es uno de los operadores m\u00e1s raros e inusuales. A veces, es utilizado para escribir c\u00f3digo m\u00e1s corto, entonces tenemos que saberlo para poder entender qu\u00e9 est\u00e1 pasando.</p> <p>El operador coma nos permite evaluar varias expresiones, dividi\u00e9ndolas con una coma <code>,</code>. Cada una de ellas es evaluada, pero s\u00f3lo el resultado de la \u00faltima es devuelto.</p> <p>Por ejemplo:</p> <pre><code>let a = (1 + 2, 3 + 4);\nconsole.log(a); // 7 (el resultado de 3 + 4)\n</code></pre> <p>Aqu\u00ed, se eval\u00faa la primera expresi\u00f3n 1 + 2 y se desecha su resultado. Luego, se eval\u00faa 3 + 4 y se devuelve como resultado.</p> <p>Info</p> <p>Tenga en cuenta que el operador coma tiene una precedencia muy baja, inferior a <code>=</code>, por lo que los par\u00e9ntesis son importantes en el ejemplo anterior.</p> <p>Sin ellos: <code>a = 1 + 2, 3 + 4</code> se eval\u00faa primero el <code>+</code>, sumando los n\u00fameros a <code>a = 3, 7</code>, luego el operador de asignaci\u00f3n <code>=</code> asigna <code>a = 3</code>, y el resto es ignorado. Es igual que <code>(a = 1 + 2), 3 + 4</code>.</p> <p>A veces, las personas lo usan en construcciones m\u00e1s complejas para poner varias acciones en una l\u00ednea.</p> <p>Por ejemplo:</p> <pre><code>for (a = 1, b = 3, c = a * b; a &lt; 10; a++) {\n...\n}\n</code></pre> <p>Tales trucos se usan en muchos frameworks de JavaScript. Por eso los estamos mencionando. Pero generalmente no mejoran la legibilidad del c\u00f3digo, por lo que debemos pensar bien antes de usarlos.</p>"},{"location":"bloque_i/tema_2/page-5/#operadores-relaciones","title":"Operadores relaciones","text":"<p>Los operados relaciones realizan comparaciones entre los datos obteniendo siempre un resultado booleano (<code>true</code> o <code>false</code>). Entre ellos, podemos encontrar:</p> Operador Significado Ejemplo &lt; Menor que 3 &lt; 5 &gt; Mayor que 3 &gt; 5 &lt;= Menor o igual que 3 &lt;= 5 &gt;= Mayor o igual que 3 &gt;= 5 == Igual que 3 == 5 != Distinto que 3 != 5 <p>Se pueden comparar n\u00fameros, o cadenas, siendo el algoritmo de comparaci\u00f3n el siguiente:</p> <ol> <li>Compare el primer car\u00e1cter de ambas cadenas.</li> <li>Si el primer car\u00e1cter de la primera cadena es mayor (o menor) que el de la otra cadena, entonces la primera cadena es mayor (o menor) que la segunda. Hemos terminado.</li> <li>De lo contrario, si los primeros caracteres de ambas cadenas son los mismos, compare los segundos caracteres de la misma manera.</li> <li>Repita hasta el final de cada cadena.</li> <li>Si ambas cadenas tienen la misma longitud, entonces son iguales. De lo contrario, la cadena m\u00e1s larga es mayor.</li> </ol> <p>Por ejemplo, al comparar <code>Z &gt; A</code>, solo es necesario hacer el primer paso. Sin embargo, al comparar <code>Glow &gt; Glee</code>, es necesario m\u00e1s pasos:</p> <ol> <li><code>G</code> es igual a <code>G</code>.</li> <li><code>l</code> es igual a <code>l</code>.</li> <li><code>o</code> es mayor que <code>e</code>, por lo que la primera cadena es mayor.</li> </ol> <p>\u00a1OJO!</p> <p>El algoritmo de comparaci\u00f3n dado arriba es aproximadamente equivalente al utilizado de forma alfab\u00e9tica, pero no es exactamente el mismo.</p> <p>Por ejemplo, las may\u00fasculas importan. Una letra may\u00fascula <code>A</code> no es igual a la min\u00fascula <code>a</code>. La <code>a</code> min\u00fascula es mayor porque el car\u00e1cter en min\u00fascula tiene un \u00edndice mayor en la tabla de codificaci\u00f3n interna que utiliza Javascript (Unicode)</p> <p>Para comparar entre distintos tipos, Javascript intenta realizar una parseo a n\u00fameros, en caso de que sea posible, si no lo transforma en <code>NaN</code>. Un <code>NaN</code> nunca es ni mayor, ni menor, ni igual a un n\u00famero, por lo que una comparaci\u00f3n con dicho tipo num\u00e9rico dar\u00eda siempre false. Un booleano se puede entender como un n\u00famero binario, siendo <code>true</code> equivalente a <code>1</code>y <code>false</code> a <code>0</code>:</p> <pre><code>console.log('3' &gt; 4) // false\nconsole.log('Hola' == 2) // false\nconsole.log('Hola' != 2) // true\nconsole.log(true &gt; 0) // true\n</code></pre> <p>Warning</p> <p>En Javascript el n\u00famero <code>0</code> se puede entender en booleano como <code>false</code>, pero la cadena <code>\"0\"</code> se entiende como <code>true</code>, por lo que a la hora de compararlas hay que tenerlo en cuenta.</p> <p>Veamos otro ejemplo:</p> <pre><code>console.log(0 == false) //true\nconsole.log('' == false) // true\n</code></pre> <p>Ambas comparaciones son <code>true</code> porque al pasar los datos no num\u00e9ricos a n\u00fameros, se entienden como <code>0</code>. Esto puede suponer un problema, porque a veces es conveniente comprobar si el contenido de dos variables es exactamente igual, y en este caso siempre dar\u00eda <code>true</code>. Para ello hay un comparador de igualdad estricto que retornar\u00e1 <code>true</code> si y solo si los datos comparados son iguales en tipo y contenido:</p> <pre><code>console.log(3 === '3') // false\nconsole.log(0 === false) // false\n</code></pre> <p>En los ejemplos anteriores, vemos que los datos son iguales en contenido (recuerda que <code>false</code> equivale a <code>0</code>), pero no tienen el mismo tipo de dato, por lo que no ser\u00edan iguales estrictos. Existe, por ende, el comparador de desigualdad estricto <code>!==</code>.</p> <p>El uso del operador de igual estricto es un mejor pr\u00e1ctica que el uso del operador de igual b\u00e1sico, ya que el estricto es propenso a tener menos errores. Uno de los errores t\u00edpicos es que al comparar <code>null</code> y <code>undefined</code> con el operador <code>==</code> \u00e9ste devuelve <code>true</code>, pero con el operador <code>===</code> devuelve <code>false</code>.</p> <p>Warning</p> <p>Al hacer una comparaci\u00f3n de cualquier tipo de dato con <code>null</code> o <code>undefined</code> \u00e9sta dar\u00e1 <code>false</code>, ya que su valor \"num\u00e9rico\" es <code>NaN</code>:</p> <pre><code>console.log(3 &lt; null) // false\nconsole.log(undefined &gt; 5) // false\n</code></pre> <p>Solo puede ser <code>true</code> si su valor es <code>undefined</code> o <code>null</code> y se compara de igualdad:</p> <pre><code>let num\nconsole.log(num === undefined)\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Los operadores l\u00f3gicos son operadores binarios aplicados a cualquier tipo y que pueden devolver cualquier tipo:</p>"},{"location":"bloque_i/tema_2/page-5/#operador-or","title":"Operador OR (||)","text":"<p>El operador OR (<code>||</code>) es un operador que en la programaci\u00f3n cl\u00e1sica, retornar\u00e1 <code>true</code> si cualquiera de sus dos operandos es <code>true</code>:</p> <pre><code>console.log(true || false) // true\nconsole.log(false || true) // true\nconsole.log(true || true) // true\nconsole.log(false || false) // false\n</code></pre> <p>En el ejemplo anterior, solo retorna <code>false</code> cuando se compara dos <code>false</code>. Si se intenta utilizar como operador otro tipo de dato, se parsear\u00e1 a booleano. En el \u00e1mbito de los n\u00fameros se entiende que <code>0</code> es <code>false</code> y que <code>1</code> es <code>true</code>. En el caso de las cadenas, se entiende como <code>false</code> una cadena vac\u00eda, y como <code>true</code> una no vac\u00eda. Tambi\u00e9n se puede entender como <code>true</code> una variable distinta de <code>null</code> y <code>undefined</code>.</p> <pre><code>console.log(1 || 0) // true\nconsole.log('Hola' || '') // true\n</code></pre> <p>Adem\u00e1s de la funcionalidad cl\u00e1sica, en Javascript dicho operador, tiene una funci\u00f3n extra. Se puede usar dicho operador para la asignaci\u00f3n de una variable, de la siguiente forma: <code>const result = value1 || value2 || value3</code>. Su funcionamiento es simple:</p> <ul> <li>Eval\u00faa la expresi\u00f3n de izquierda a derecha.</li> <li>Transforma cada operando en un valor booleano. Si el resultado de alguno es <code>true</code>, se detiene en el primer operando que da <code>true</code>, retornando el valor original del operando.</li> <li>Si todos los operandos son <code>false</code> retorna el \u00faltimo operando.</li> </ul> <p>En otras palabras, una cadena de OR devuelve el primer valor verdadero o el \u00faltimo si ning\u00fan verdadero es encontrado.</p> <pre><code>const result1 = 0 || '' || 7 // 7\nconst result2 = 3 || undefined || false // 3\nconst result1 = null || 'Hola' || 9 // 'Hola'\nconst result4 = null || undefined || '' || 0 // 0\n</code></pre> <p>Uno de los usos m\u00e1s comunes de esta funcionalidad es poder definir una variable que depende de otros valores, pero en caso de los otros valores no est\u00e9n definidos (ya sea porque sean <code>null</code> o <code>undefined</code> o cadena vac\u00eda, o incluso cero) podemos indicarle un valor por defecto.</p> <pre><code>let name = ''\nlet firstName = null\nconst userName = name || firstName || 'Nombre de usuario'\n</code></pre> <p>En el ejemplo anterior se eval\u00faa las dos variables, en caso de que den <code>false</code>, se utiliza como valor de la variable <code>userName</code> la cadena <code>Nombre de usuario</code>.</p>"},{"location":"bloque_i/tema_2/page-5/#operador-and","title":"Operador AND (&amp;&amp;)","text":"<p>El operador AND (<code>&amp;&amp;</code>) es un operador que en la programaci\u00f3n cl\u00e1sica retornar\u00e1 <code>true</code> siempre y cuando todos los operandos devuelvan <code>true</code> y <code>false</code> si hay uno o m\u00e1s de uno que devuelve <code>false</code>.</p> <pre><code>console.log(true &amp;&amp; true); // true\nconsole.log(false &amp;&amp; true); // false\nconsole.log(true &amp;&amp; false); // false\nconsole.log(false &amp;&amp; false); // false\n</code></pre> <p>Al igual que operador OR, en Javascript, se puede usar el operador AND para la asignaci\u00f3n <code>const result = value1 &amp;&amp; value2 &amp;&amp; value3</code>. En este caso, el procedimiento es un ligeramente diferente:</p> <ul> <li>Eval\u00faa la expresi\u00f3n de izquierda a derecha.</li> <li>Transforma cada operando en un valor booleano. Si el resultado de alguno es <code>false</code>, se detiene en el primer operando que da <code>false</code>, retornando el valor original del operando.</li> <li>Si todos los operandos son <code>true</code> retorna el \u00faltimo operando.</li> </ul> <p>En otras palabras, AND retorna el primer valor falso o el \u00faltimo valor si ninguno fue encontrado. Las reglas anteriores son similares a las de OR. La diferencia es que AND retorna el primer valor falso mientras que OR retorna el primer valor verdadero.</p> <pre><code>const result1 = 0 &amp;&amp; '' &amp;&amp; 7 // 0\nconst result2 = 3 &amp;&amp; undefined &amp;&amp; false // undefined\nconst result1 = null &amp;&amp; 'Hola' &amp;&amp; 9 // null\nconst result4 = 1 &amp;&amp; 2 &amp;&amp; true &amp;&amp; 3 // 3\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operador-not","title":"Operador NOT (!)","text":"<p>El operador NOT (<code>!</code>) es un operador unario que se encarga de convertir dicho operando en un booleano (en caso de que no lo sea) y devuelve su valor booleano contrario.</p> <pre><code>console.log(!false) // true\nconsole.log(!2) // false\nconsole.log(!0) // true\nconsole.log(!'Hola') // false\nconsole.log(!'') // true\nconsole.log(!undefined) // true\n</code></pre> <p>Warning</p> <p>En Javascript los operadores AND, OR, NOT y NULLISH COALESCING son operadores corto-circuitos, es decir, van evaluando expresiones hasta que una de ellas obtiene un valor claro, dejando a las dem\u00e1s sin evaluar. Por ejemplo:</p> <pre><code>const result = 10 || 0 || false\n</code></pre> <p>En este ejemplo, el valor de la variable <code>result</code> es <code>10</code>, pero el tiempo de ejecuci\u00f3n es menor si se hubiese cambiado el orden, ya que al evaluar primero el 10, como se obtiene lo que se desea (una valor distinto de <code>false</code>) el resto de expresiones se dejan sin evaluar. Por eso, es importante el orden en el que se eval\u00faan dichas expresiones. Veamos otro ejemplo:</p> <pre><code>console.log(3 &gt; 5 &amp;&amp; 4 &gt; 2)\n</code></pre> <p>Ahora, se mostrar\u00e1 <code>false</code>, porque <code>3&gt;5</code> retorna <code>false</code> por lo que no es necesario evaluar la siguiente expresi\u00f3n, ya que siendo la primera <code>false</code> el operando <code>&amp;&amp;</code> retornar\u00e1 <code>false</code> s\u00ed o s\u00ed.</p>"},{"location":"bloque_i/tema_2/page-5/#operador-typeof","title":"Operador typeof","text":"<p>El operador <code>typeof</code> es un operador unario de Javascript que devuelve el tipo de dato del operando. Tambi\u00e9n se puede utilizar de la siguiente forma <code>typeof(x)</code> pero hay que tener en cuenta que <code>typeof</code> es un operando y no una funci\u00f3n.</p> <pre><code>console.log(typeof 'Hola') // string\nconsole.log(typeof 4) // number\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operador-ternario","title":"Operador ternario","text":"<p>El operador ternario es un operador con tres operando. El primer operando hace referencia a una condici\u00f3n que debe ser evaluada. Si esta condici\u00f3n es verdadera el operador retorna el segundo operando, mientras que si la condici\u00f3n es falsa el operador retorna el tercer operando. Su sintaxis es la siguiente:</p> <pre><code>condition ? trueValue : falseValue\n</code></pre> <p>Veamos un ejemplo:</p> <pre><code>const result = age &gt; 18 ? 'Mayor' : 'Menor'\n</code></pre> <p>Podemos tener una secuencia de operadores ternario si queremos evaluar m\u00e1s de una posibilidad:</p> <pre><code>let message = age &lt; 3 ? '\u00a1Hola, beb\u00e9!' : age &lt; 18 ? '\u00a1Hola!' : age &lt; 100 ? '\u00a1Felicidades!' : '\u00a1Qu\u00e9 edad tan inusual!';\nconsole.log(message)\n</code></pre> <p>La ejecuci\u00f3n del ejemplo anterior es la siguiente.</p> <ol> <li>Se comprueba si la expresi\u00f3n <code>age &lt; 3</code> es verdadera. En caso de serlo, retornar\u00e1 el valor <code>'Hola, beb\u00e9'</code>, y no comprobar\u00e1 el resto de condiciones.</li> <li>Si es falsa, comprobar\u00e1 la siguiente condici\u00f3n <code>age &lt; 18</code>. En este caso si es verdadera retornar\u00e1 <code>'\u00a1Hola!'</code>.</li> <li>Si es falsa, comprobar\u00e1 la \u00faltima condici\u00f3n, que de ser verdadera retornar\u00e1 <code>\u00a1Felicidades!</code>, por el contrario <code>\u00a1Qu\u00e9 edad tan inusual!</code>.</li> </ol>"},{"location":"bloque_i/tema_2/page-5/#operador-nullish-coalescing","title":"Operador Nullish Coalescing","text":"<p>El operador nullish coalescing (fusi\u00f3n de null) es un operador binario en el que retorna el primer operando si es distinto de <code>null</code> o <code>undefined</code>, o por el contario retorna el segundo:</p> <pre><code>let number\nconsole.log(number ?? 0) // 0\n</code></pre> <p>En el ejemplo anterior, se mostrar\u00e1 0, ya que la variable <code>number</code> es una variable <code>undefined</code> y por lo tanto la expresi\u00f3n <code>number ?? 0</code> retorna el segundo operado (<code>0</code>). En el siguiente ejemplo, retornar\u00e1 el valor de la variable <code>number</code> ya que no es <code>undefined</code>:</p> <pre><code>let number = 10\nconsole.log(number ?? 0) // 10\n</code></pre> <p>El operador nullish coalescing no es m\u00e1s que una sintaxis reducida del uso de un operador ternario con dicho prop\u00f3sito:</p> <pre><code>let number\nconsole.log(number !== undefined || number !== null ?  null : 0)\n</code></pre> <p>Tambi\u00e9n se puede usar una secuencia de dicho operador para seleccionar el primer valor que no sea <code>null</code>/<code>undefined</code>:</p> <pre><code>let firstName = null;\nlet lastName = null;\nlet nickName = \"MyNick\";\nconsole.log(firstName ?? lastName ?? nickName ?? \"Anonymous\"); // MyNick\n</code></pre> <p>El ejemplo anterior, tambi\u00e9n pod\u00eda haberse realizado con el operador OR (<code>||</code>). Hist\u00f3ricamente, el operador OR estuvo primero y existe desde el origen de JavaScript, as\u00ed que los desarrolladores lo estuvieron usando para tal prop\u00f3sito durante mucho tiempo.</p> <p>Por otro lado, el operador nullish coalescing es una adici\u00f3n reciente, y la raz\u00f3n es que la gente no estaba del todo satisfecha con <code>||</code>.</p> <p>La gran diferencia es que OR devuelve el primer valor verdadero  y nullish coalescing devuelve el primer valor definido. El <code>||</code> no distingue entre <code>false</code>, <code>0</code>, un string vac\u00edo <code>\"\"</code>, y <code>null</code>/<code>undefined</code>. Todos son lo mismo: valores falsos. Si cualquiera de ellos es el primer argumento de <code>||</code>, obtendremos el segundo argumento como resultado. Pero cierto es, que en la pr\u00e1ctica querremos usar dicho valor solo cuando no est\u00e9 definido o sea <code>null</code>. En el ejemplo siguiente, me interesa seguir usando el valor <code>0</code>, por eso no es conveniente usar el operador OR:</p> <pre><code>const height = 0\nconsole.log('La altura es', height ?? 'No hay altura')\n</code></pre> <p>Si hubi\u00e9semos usado el operador OR, hubiese devuelto la cadena, pero eso no ser\u00eda coherente ya que el valor de una altura si puede ser 0.</p> <p>Tips</p> <p>Por este motivo, se recomienda usar siempre el operador nullish coalescing en lugar del operador OR, y dejar dicho operador solo en situaciones concretas.</p> <p>Warning</p> <p>Por motivos de seguridad, JavaScript proh\u00edbe el uso de <code>??</code> junto con los operadores <code>&amp;&amp;</code> y <code>||</code>, salvo que la precedencia sea expl\u00edcitamente especificada con par\u00e9ntesis.</p> <pre><code>let x = 1 &amp;&amp; 2 ?? 3; // \u274c Syntax error\nlet y = (1 &amp;&amp; 2) ?? 3; // \u2705 2\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#precedencias","title":"Precedencias","text":"<p>En Javascript, como en cualquier otro lenguaje, existen demasiados operadores y a veces al usar varios de ellos a la vez es necesario tener en cuenta un precedencia a la hora de ejecutarse. Por ejemplo, en la expresi\u00f3n <code>3 + 5 * 2</code>, aunque primero vaya la suma, seg\u00fan la precedencia de operaciones, la multiplicaci\u00f3n tiene mayor precedencia que la suma por lo que primero se ejecutar\u00e1 <code>5 * 2</code> y luego el resultado se sumar\u00e1 a 3. En la siguiente tabla se recoge el orden de precedencia de los operadores de Javascript.</p> Precedencia Tipo de operador Asociatividad Operadores individuales 19 Agrupamiento - <code>()</code> 18 Acceso a propiedades (notaci\u00f3n por punto) A la izquierda <code>.</code> Acceso a propiedades (notaci\u00f3n por corchetes) A la izquierda <code>[]</code> Creaci\u00f3n de objetos (con argumentos) - <code>new</code> Llamada a funci\u00f3n A la izquierda <code>()</code> Encadenamiento opcional A la izquierda <code>?.</code> 17 Creaci\u00f3n de objetos (sin argumentos) A la derecha <code>new</code> 16 Incremento sufijo - <code>...++</code> Decremento sufijo <code>...--</code> 15 NOT l\u00f3gico A la derecha <code>!</code> NOT a nivel de bits <code>~</code> Suma unaria <code>+</code> Negaci\u00f3n unaria <code>-</code> Incremento prefijo <code>++...</code> Decremento prefijo <code>--...</code> <code>typeof</code> <code>typeof</code> <code>void</code> <code>void</code> <code>delete</code> <code>delete</code> <code>await</code> <code>await</code> 14 Potenciaci\u00f3n A la derecha <code>**</code> 13 Multiplicaci\u00f3n A la izquierda <code>*</code> Divisi\u00f3n <code>/</code> Resto <code>%</code> 12 Adici\u00f3n A la izquierda <code>+</code> Sustracci\u00f3n <code>-</code> 11 Desplazamiento de bits a la izquierda A la izquierda <code>&lt;&lt;</code> Desplazamiento de bits a la derecha <code>&gt;&gt;</code> Desplazamiento de bits a la derecha sin signo &gt;&gt;&gt; 10 Menor a A la izquierda <code>&lt;</code> Menor o igual a &lt;= Mayor a &gt; Mayor o igual a &gt;= <code>in</code> <code>in</code> <code>instanceof</code> <code>instanceof</code> 9 Igualdad A la izquierda <code>=</code> Desigualdad <code>!=</code> Igualdad estricta <code>===</code> Desigualdad estricta <code>!==</code> 8 AND nivel de bits A la izquierda <code>&amp;</code> 7 XOR nivel de bits A la izquierda <code>^</code> 6 OR nivel de bits A la izquierda <code>|</code> 5 AND l\u00f3gico A la izquierda <code>&amp;&amp;</code> 4 OR l\u00f3gico A la izquierda <code>||</code> Nullish coalescing <code>??</code> Condicional <code>...? ... : ...</code> 2 Asignaci\u00f3n A la derecha <code>=</code> <code>+=</code> <code>-=</code> <code>**=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&gt;&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code> <code>&amp;&amp;=</code> <code>||=</code> <code>??=</code> <code>yield</code> <code>yield</code> <code>yield*</code> <code>yield*</code> 1 Operador coma A la izquierda     <code>,</code> <p>La asociatividad hace referencia a la situaci\u00f3n en la cual dos operandos tenga la misma precedencia. En ese caso, se ejecutar\u00e1 primero seg\u00fan la asociatividad. Por ejemplo, en el caso de <code>3 * 3 / 3</code>, la multiplicaci\u00f3n y la divisi\u00f3n tiene la misma precedencia, y como su asociatividad es de izquierda, primero se ejecuta la operaci\u00f3n que est\u00e9 m\u00e1s a la izquierda, en este caso la multiplicaci\u00f3n.</p> <p>A veces, en ocasiones queremos realizar una operaci\u00f3n de baja precedencia antes que una de mayor procedencia, para ello se puede usar el operador con mayor precedencia los par\u00e9ntesis <code>()</code>. Por ejemplo, si en la operaci\u00f3n <code>2 + 3 * 5</code>, donde la multiplicaci\u00f3n tiene mayor precedencia que la suma, pero se desea hacer la suma antes, se debe colocar un par\u00e9ntesis en la expresi\u00f3n que se desea hacer primero: <code>(2 + 3) * 5</code>.</p>"},{"location":"bloque_i/tema_2/page-5/#ejercicios","title":"Ejercicios","text":"Ejercicio 5 <p>\u00bfCu\u00e1les son los valores finales de todas las variables <code>a</code>, <code>b</code>, <code>c</code> y <code>d</code> despu\u00e9s del c\u00f3digo a continuaci\u00f3n?</p> <pre><code>let a = 1, b = 1 let c = ++a let d = b++ </code></pre> Ejercicio 6 <p>\u00bfCu\u00e1les son los valores de <code>a</code> y <code>x</code> despu\u00e9s del c\u00f3digo de a continuaci\u00f3n:</p> <pre><code>let a = 2\nlet x = 1 + (a *= 2)\n</code></pre> Ejercicio 7 <p>\u00bfCu\u00e1les es el resultado de las siguientes expresiones?</p> <ol> <li>\"\" + 1 + 0</li> <li>\"\" - 1 + 0</li> <li>true + false</li> <li>6 / \"3\"</li> <li>\"2\" * \"3\"</li> <li>4 + 5 + \"px\"</li> <li>\"$\" + 4 + 5</li> <li>\"4\" - 2</li> <li>\"4px\" - 2</li> <li>\"  -9  \" + 5</li> <li>\"  -9  \" - 5</li> <li>null + 1</li> <li>undefined + 1</li> <li>\" \\t \\n\" - 2</li> <li>5 &gt; 4</li> <li>\"apple\" &gt; \"pineapple\"</li> <li>\"2\" &gt; \"12\"</li> <li>undefined == null</li> <li>undefined === null</li> <li>null == \"\\n0\\n\"</li> <li>null === +\"\\n0\\n\"</li> <li>null || 2 || undefined</li> <li>1 &amp;&amp; null &amp;&amp; 2</li> <li>null || 2 &amp;&amp; 3 || 4</li> </ol> Ejercicio 8 <p>Dado los siguientes valores de las variables <code>x</code>, <code>y</code>, <code>j</code> y <code>k</code>, a\u00f1adir los par\u00e9ntesis que sean necesarios para que las expresiones que las siguen eval\u00faen a verdadero: <code>x = 10</code>; <code>y = 19</code>; <code>j = true</code>; <code>k = undefined</code>.</p> <ol> <li>x == y || j</li> <li>x &gt;= y || x &lt;=y &amp;&amp; j</li> <li>!j || j</li> <li>!k &amp;&amp; k</li> </ol> Ejercicio 9 <p>Indica cual es la salida de las siguientes asignaciones:</p> <ol> <li>const result1 = 10 || 0 || null</li> <li>const result2 = null || undefined || 10</li> <li>const result3 = 0 || 'Sin valor'</li> <li>const result4 = 0 ?? 'Sin valor'</li> <li>const result5 = 10 &amp;&amp; 0 &amp;&amp; 'Mi valor'</li> <li>const result6 = 10 &amp;&amp; 'Mi Valor' &amp;&amp; '\u00daltima'</li> <li>const result7 = 10 &amp;&amp; 8 &amp;&amp; 0 || 20</li> <li>const result8 = 10 &amp;&amp; 10 || undefined &amp;&amp; value</li> </ol>"},{"location":"bloque_i/tema_2/page-6/","title":"6 Introducci\u00f3n a las funciones","text":""},{"location":"bloque_i/tema_2/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>A veces, es necesario repetir c\u00f3digo a lo largo de nuestro script. Por lo que a veces es necesario tener un bloque que recoja el c\u00f3digo a repetir y se ejecuten en diferentes partes.</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ul> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ul>"},{"location":"bloque_i/tema_2/page-6/#declaracion","title":"Declaraci\u00f3n","text":"<p>Para declarar una funci\u00f3n podemos usar la siguiente estructura:</p> <pre><code>function functionName(parameter1, parameter2, parameter3, ..., parameterN){\n// code\n}\n</code></pre> <p>Para hacer uso de esas funciones, se usa el nombre de la funci\u00f3n seguido de un par\u00e9ntesis <code>()</code>. Dentro del par\u00e9ntesis, los par\u00e1metros necesarios para ejecutar la funci\u00f3n.</p> <pre><code>functionName(parameter1, parameter2,..., parameterN)\n</code></pre> <p>Los par\u00e1metros son los datos que son necesarios para ejecutar una funci\u00f3n. Por ejemplo, si tenemos una funci\u00f3n llamada <code>suma</code>, \u00e9sta debe recibir los n\u00fameros que desea realizar la suma.</p> <p>En Javascript existen funciones nativas, es decir, funciones que fueron creadas para por y para el lenguaje y se pueden acceder a ellas gracias al motor del navegador. Entre ellas, podemos destacar: <code>alert</code>, <code>prompt</code> y <code>confirm</code>. Estas funciones son funciones para los navegadores webs. Son funciones del objeto <code>windows</code>.</p>"},{"location":"bloque_i/tema_2/page-6/#alert","title":"alert","text":"<p>La funci\u00f3n <code>alert(message)</code> es una funci\u00f3n de Javascript que ejecuta un cuadro de di\u00e1logo en el navegador, mostrando el <code>message</code> que se le pasa por par\u00e1metro. Este cuadro de di\u00e1logo se muestra de forma modal, es decir, se muestra de forma que no se puede interactuar con el resto de la p\u00e1gina hasta que el cuadro de di\u00e1logo no sea cerrado. Para poder cerrarlo, el cuadro de di\u00e1logo tiene un bot\u00f3n de Aceptar.</p> <pre><code>alert('Hola mundo')\n</code></pre> <p>Con HTML, CSS podemos crear nuestros propios modales, y a trav\u00e9s de Javascript podemos crearle nuestra propia interactividad. Pero de momento, usaremos los m\u00e9todos predeterminados por el lenguaje.</p>"},{"location":"bloque_i/tema_2/page-6/#prompt","title":"prompt","text":"<p>La funci\u00f3n <code>prompt(title, [default])</code> es una funci\u00f3n que muestra en el navegador un cuadro de di\u00e1logo para que el usuario introduzca un dato. Con el par\u00e1metro <code>title</code> indicamos el mensaje que mostramos en el cuadro de di\u00e1logo. Con el par\u00e1metro <code>default</code> es un par\u00e1metro opcional (no es necesario indicarlo) y representa un valor por defecto, en caso de que el usuario no introduzca ning\u00fan valor.</p> <pre><code>const age = prompt('\u00bfCu\u00e1l es tu edad?', 10)\nconst name = prompt('\u00bfCu\u00e1l es tu nombre?')\nconsole.log(`Hola ${name}, eres ${age &gt; 18 ? 'mayor' : 'menor'} de edad`)\n</code></pre> <p>El usuario introducir\u00e1 un dato en el campo de entrada y presionar el bot\u00f3n OK y el valor introducido por el usuario se le asignar\u00e1 a la variable indicada. En caso de presionar el bot\u00f3n cancelar o presiona la tecla Esc, se asignar\u00e1 a la variable el valor por defecto indicado, o <code>null</code> en caso de que no se haya indicado ninguna.</p> <p>Warning</p> <p>Es importante tener en cuenta que todo lo que el usuario introduzca haciendo uso de la funci\u00f3n <code>prompt</code> es considerado como texto. Si se desea otro tipo de dato es necesario realizar un control previo antes de su uso, as\u00ed como una conversi\u00f3n de datos.</p>"},{"location":"bloque_i/tema_2/page-6/#confirm","title":"confirm","text":"<p>La funci\u00f3n <code>confirm(message)</code> muestra un cuadro de di\u00e1logo con un <code>message</code> y dos botones: OK y CANCELAR. Si el usuario presiona el bot\u00f3n OK la funci\u00f3n retornar\u00e1 <code>true</code> y <code>false</code> en el caso contrario.</p> <pre><code>const isBoss = confirm('\u00bfEres el jefe?')\nalert(isBoss ? 'Es el jefe' : 'No es el jefe')\n</code></pre>"},{"location":"bloque_i/tema_2/page-6/#ejercicios","title":"Ejercicios","text":"Ejercicio 10 <p>Crea una p\u00e1gina web, realizando las siguientes opciones.</p> <ul> <li>Solicitar al usuario su nombre y su edad.</li> <li>Solicitar al usuario si est\u00e1 o no abonado a nuestra web.</li> <li>Mostrar en un cuadro de di\u00e1logo la siguiente informaci\u00f3n: <code>Hola Pedro, eres mayor de edad. No eres abonado a nuestra web</code>, o por el contrario <code>Hola Pedro, eres menor de edad. Eres abonado en nuestra web. Enhorabuena.</code></li> </ul>"},{"location":"bloque_i/tema_2/page-7/","title":"7 Conversi\u00f3n de tipos","text":""},{"location":"bloque_i/tema_2/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>La mayor\u00eda de las veces, los operados y las funciones realizan conversiones autom\u00e1ticas de los tipos que reciben por el tipo que requieren. Por ejemplo, cualquier valor pasado al m\u00e9todo <code>log</code> del <code>console</code> es convertido a cadena.</p> <p>Tambi\u00e9n, en ciertas ocasiones, es necesario realizar dicha conversi\u00f3n de forma expl\u00edcita. Existen diferentes funciones para realizar dicha conversi\u00f3n.</p>"},{"location":"bloque_i/tema_2/page-7/#conversion-explicita-a-cadena","title":"Conversi\u00f3n expl\u00edcita a cadena","text":"<p>Vamos a convertir un valor a cadena cuando necesitamos que dicho valor sea usado como tal. Es una de las conversiones m\u00e1s sencillas, ya que sea obtiene el mismo valor pero con comillas. Por ejemplo, <code>2</code> ser\u00eda <code>\"2\"</code>, <code>undefined</code> <code>\"undefined\"</code>, <code>false</code> <code>\"false\"</code>.</p> <p>Para convertir un valor a una cadena podemos hacer uso de la funci\u00f3n <code>String(value)</code></p> <pre><code>const number = 3\nconst numberString = String(number)\n</code></pre> <p>Tambi\u00e9n podemos usar las backticks introduciendo el valor a convertir dentro del <code>${...}</code>:</p> <pre><code>const number = 3\nconst numberString = `${number}`\nconsole.log(typeof numberString) // string\n</code></pre>"},{"location":"bloque_i/tema_2/page-7/#conversion-explicita-a-numero","title":"Conversi\u00f3n expl\u00edcita a n\u00famero","text":"<p>La conversi\u00f3n num\u00e9rica ocurre en funciones matem\u00e1ticas y expresiones. Por ejemplo, al hacer <code>\"3\" / \"3\"</code>, las cadenas se convierten autom\u00e1ticamente en n\u00famero. Sin embargo, si se desea hacer una conversi\u00f3n expl\u00edcita, es necesario hacer uso de la funci\u00f3n <code>Number(value)</code>.</p> <p>Warning</p> <p>El \u00fanico operador matem\u00e1tico que no realiza la conversi\u00f3n de cadenas autom\u00e1tica a n\u00famero es el operador de adici\u00f3n <code>+</code>. Este operador se entiende en dicho caso, como un operador de concatenaci\u00f3n de cadenas. Para poder hacer una operaci\u00f3n de adici\u00f3n de una cadena y un n\u00famero, es necesario hacer la conversi\u00f3n expl\u00edcita de la cadena a n\u00famero:</p> <pre><code>console.log(3 + \"3\") // 33\nconsole.log(3 + Number(\"3\")) // 6\n</code></pre> <p>Para pasar una cadena a n\u00famero se sigue los siguientes pasos:</p> <ol> <li>Se eliminan los espacios de las cadenas. Por lo que, si tenemos una cadena `\"  233  \", los espacios no afectar\u00edan a la conversi\u00f3n.</li> <li>Si la cadena resultante es vac\u00eda, se convierte al n\u00famero 0.</li> <li>Si la cadena resultante es una cadena de d\u00edgitos (solo contiene n\u00fameros), se convierte a n\u00famero.</li> <li>Si la cadena resultante es una cadena que contiene alg\u00fan car\u00e1cter distinto a un d\u00edgito, la conversi\u00f3n ser\u00eda err\u00f3nea y retornar\u00eda <code>NaN</code>.</li> </ol> <p>Existen cadenas especiales que pueden ser convertidos a n\u00fameros de base de decimal (base 10). Por ejemplo, para indicar que una cadena es una representaci\u00f3n num\u00e9rica octal, se debe usar <code>0o</code>. <code>0x</code> y <code>0b</code> representan una cadena hexadecimal y binaria, respectivamente:</p> <pre><code>console.log(Number(\"0o10\")) // 8 (octal)\nconsole.log(Number(\"2e1\")) // 20 (notaci\u00f3n exponencial)\nconsole.log(Number(\"0b10100\")) // 20 (binaria)\nconsole.log(Number(\"0xF\")) // 15 (hexadecimal)\n</code></pre> <p>Por desgracia, el m\u00e9todo <code>Number</code> no puede parsear unidades de medida a n\u00famero:</p> <pre><code>console.log('20px') // NaN\n</code></pre> <p>Si se desea parsear una valor booleano a un n\u00famero, ser\u00e1 convertido a 0 si el valor del booleano es <code>false</code>, y a 1 si es <code>true</code>.</p> <pre><code>console.log(Number(true)) // 1\nconsole.log(Number(false)) // 0 \n</code></pre> <p>De la misma manera, el tipo <code>undefined</code> se convierte como <code>NaN</code> y el tipo <code>null</code> se convierte a 0.</p> <pre><code>console.log(Number(null)) // 0\nconsole.log(Number(undefined)) // 1\n</code></pre> <p>Existen otros m\u00e9todos para parsear un valor a n\u00famero, <code>parseInt(value)</code> y <code>parseDouble(value)</code>. Su funcionamiento es similar, pero en el primer caso realiza la conversi\u00f3n a n\u00famero entero, y en el segundo a n\u00famero decimal.</p> <p>Warning</p> <p>Los m\u00e9todos <code>parseInt</code> y <code>parseDouble</code> solo sirven para pasar cadenas con d\u00edgitos. Cualquier otro tipo de valor (incluso las cadenas especiales para representar n\u00fameros de otras bases) retornar\u00eda <code>NaN</code> como resultado.</p> <pre><code>console.log(parseInt(false)) // NaN\nconsole.log(parseInt(\"0b1000\")) // NaN\n</code></pre> <p>Las funciones pueden recibir un segundo par\u00e1metro que indique la base a la que se desea convertir la cadena, sin necesidad de hacer el uso de cadenas especiales, como en el caso de <code>Number()</code>. Si no lo recibe, se usar\u00eda la base diez (decimal) por defecto.</p> <pre><code>console.log(parseInt(\"101000\", 2)) // 20\nconsole.log(parseInt(\"010\"), 8) // 8\nconsole.log(parseInt(\"0xF\"), 16) // 15\n</code></pre> <p>Al usar este n\u00famero con una cadena que comience con un n\u00famero, convierte la cadena en dicho n\u00famero ignorando el resto de la cadena. Por ello, este m\u00e9todo, si permite parsear unidades:</p> <pre><code>console.log(parseInt(\"2000 hola mundo\")) // 2000\nconsole.log(parseInt(\"20 hola 50\")) //20\nconsole.log(parseInt(\"0b10100\")) // 0\nconsole.log(parseInt(\"20em\")) // 20\n</code></pre> <p>Existe una manera m\u00e1s sencilla de realizar la conversi\u00f3n de manera expl\u00edcita, haciendo uso del operador unario <code>+</code>. Al usar dicho operador delante del valor a convertir, se convierte de forma autom\u00e1tica. Aunque si se usa en operaciones con varios operando, hay que tener en cuenta la precedencia, aunque dicho operador tiene mayor precedencia que los operadores matem\u00e1ticos.</p> <pre><code>console.log(+\"3\") //3\nconsole.log(+false) //0\nconsole.log(+true) // 1\nconsole.log(+null) // 0\nconsole.log(+undefined) //NaN\nconsole.log(+\"Hola\") // NaN\nconsole.log(+\"0b10100\") // 20\nconsole.log(+\"2e1\") // 20\nconsole.log(3 + +\"4\") // 7\n</code></pre>"},{"location":"bloque_i/tema_2/page-7/#conversion-explicita-a-boolean","title":"Conversi\u00f3n expl\u00edcita a boolean","text":"<p>Convertir a booleano es una de las operaciones de conversi\u00f3n m\u00e1s simples. Siguiendo las siguientes reglas:</p> <ul> <li>Los valores vac\u00edos, como <code>undefined</code>, <code>0</code>, <code>null</code>, <code>''</code>, <code>NaN</code> se convierten a <code>false</code>.</li> <li>El resto de valores se convierten a <code>true</code>.</li> </ul> <p>Para realizar la conversi\u00f3n expl\u00edcita de los valores, se hace uso de la funci\u00f3n <code>Boolean(value)</code>:</p> <pre><code>console.log(Boolean(1)) // true\nconsole.log(Boolean(0)) // false\nconsole.log(\"\") // false\nconsole.log(\"Hola\") // true\n</code></pre> <p>Warning</p> <p>Algunos lenguajes, como PHP, entiende la cadena <code>\"0\"</code> como <code>false</code>. Pero, en Javascript, cualquier cadena no vac\u00eda es siempre <code>true</code>. Al igual que ocurre con una cadena con solo espacios <code>\" \"</code></p> <pre><code>console.log(Boolean(\"0\")) // true\nconsole.log(Boolean(\" \")) // true\n</code></pre> <p>Existen otras formas de conversi\u00f3n impl\u00edcitas a booleanos, como los operadores l\u00f3gicos, las estructura <code>if</code>, etc.</p>"},{"location":"bloque_i/tema_3/page-1/","title":"1 Condicionales","text":""},{"location":"bloque_i/tema_3/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Los programas se construyen para procesar datos, manipul\u00e1ndolos de formas diferentes dependiendo de los valores que tengan. Los lenguajes de programaci\u00f3n deben proveer estructuras que les permitan a los programadores controlar el flujo de ejecuci\u00f3n de un programa dependiendo de los datos que procesan. Para ello, se incluyen las sentencias de control de flujo, que alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</p> <p>La programaci\u00f3n estructurada es un paradigma de programaci\u00f3n orientado a mejorar la claridad, calidad y tiempo de desarrollo de un programa de computadora recurriendo \u00fanicamente a subrutinas y tres estructuras b\u00e1sicas: secuencia, sentencias condicionales y bucles.</p>"},{"location":"bloque_i/tema_3/page-1/#secuencia-condicional","title":"Secuencia condicional","text":"<p>La ejecuci\u00f3n secuencial es el m\u00e1s b\u00e1sico de los mecanismos de control de flujo y consiste en la ejecuci\u00f3n de instrucciones en el orden en que se encuentran en el c\u00f3digo fuente del programa.</p> <p>Hasta ahora las instrucciones que hemos visto, son instrucciones que se ejecutan secuencialmente; es decir, podemos saber lo que hace el programa leyendo las l\u00edneas de izquierda a derecha y de arriba abajo.</p> <p>La sentencia condicional consiste en ejecutar instrucciones diferentes dependiendo del resultado de evaluar una expresi\u00f3n l\u00f3gica. Una expresi\u00f3n l\u00f3gica es cualquier tipo de expresi\u00f3n que devuelva un resultado booleano (<code>true</code> o <code>false</code>).</p>"},{"location":"bloque_i/tema_3/page-1/#condicional-simple","title":"Condicional Simple","text":"<p>El condicional simple es la estructura que ejecuta una serie de condiciones si cumple una condici\u00f3n:</p> <pre><code>if(condici\u00f3n){\n// instrucciones\n}\n</code></pre> <p>Por ejemplo:</p> <pre><code>const number = 10\nif(number &gt; 5){\nconsole.log(\"The number is greater than 5\")\n}\n</code></pre> <p>En caso de que no se cumpla la condici\u00f3n, no se ejecutar\u00e1 nada:</p> <pre><code>const number = 4\nif(number &gt; 5){\nconsole.log(\"The number is greater than 5\")\n}\n</code></pre> <p>Warning</p> <p>La sentencia <code>if(...)</code> se encarga de evaluar la expresi\u00f3n de dentro del par\u00e9ntesis y convertir su resultado en booleano, en caso de no serlo. Para ello, sigue las reglas de conversi\u00f3n vistas en el tema anterior.</p>"},{"location":"bloque_i/tema_3/page-1/#condicional-doble","title":"Condicional doble","text":"<p>Es igual que la anterior, s\u00f3lo que se a\u00f1ade un apartado <code>else</code> que contiene instrucciones que se ejecutar\u00e1n si la expresi\u00f3n evaluada por el <code>if</code> es falsa.</p> <pre><code>if(condici\u00f3n){\n// instrucciones si es verdadera\n} else {\n// instrucciones si es falsa\n}\n</code></pre> <p>En este caso, se comprueba si la condici\u00f3n del <code>if</code> es verdadera y en caso de serlo se ejecuta las instrucciones. Por el contrario, se ejecuta el conjunto de instrucciones del <code>else</code>.</p> <pre><code>if(number){\nconsole.log('La variable number existe y su valor es', number)\n} else {\nconsole.log('La variable number no existe')\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#condicional-multiple","title":"Condicional m\u00faltiple","text":""},{"location":"bloque_i/tema_3/page-1/#anidacion","title":"Anidaci\u00f3n","text":"<p>Dentro de una sentencia <code>if</code> se puede colocar otra sentencia <code>if</code>. A esto se le llama anidaci\u00f3n y permite crear programas donde se valoren expresiones complejas. La nueva sentencia puede ir tanto en la parte if como en la parte else.</p> <p>Las anidaciones se utilizan much\u00edsimo al programar. Solo hay que tener en cuenta que siempre se debe cerrar primero el \u00faltimo <code>if</code> que se abri\u00f3. Es muy importante tambi\u00e9n tabular el c\u00f3digo correctamente para que las anidaciones sean legibles.</p> <p>Ejemplo:</p> <pre><code>if(x == 1){\n// instrucciones\n} else {\nif(x == 2){\n// instrucciones\n} else {\nif(x == 3){\n// instrucciones\n}\n}\n}\n</code></pre> <p>Una forma m\u00e1s legible de escribir ese mismo c\u00f3digo dando lugar a la llamada estructura <code>if-else-if</code> ser\u00eda:</p> <pre><code>if(x == 1){\n// instrucciones\n} else if(x == 2){\n// instrucciones\n} else if(x == 3){\n// instrucciones\n}\n</code></pre> <p>Cuando se cumpla alguna de las condiciones, se ejecutan sus instrucciones correspondientes y despu\u00e9s ya se sale de la estructura if-else-if ya que las condiciones son autoexcluyentes, es decir, solamente se va a cumplir una. Por eso, no estar\u00eda bien hacer lo siguiente:</p> <pre><code>if(x == 1){ // Forma incorrecta de programar\n// instrucciones\n}\nif(x == 2){\n// instrucciones\n}\nif(x == 3){\n// instrucciones\n}\n</code></pre> <p>El motivo de que no sea adecuado es porque se pierde tiempo en comprobar todas las condiciones. Por ejemplo, si x vale 1, se ejecutan sus instrucciones correspondientes y luego se comprobar\u00eda si x vale 2, si x vale 3, etc. cuando no se va a cumplir ninguna m\u00e1s ya que si x vale 1 no puede valer ni 2 ni 3.</p> <pre><code>const age = parseInt(prompt(\"Introduzca su edad: \"))\nif (age &gt;= 18) {\nconsole.log(\"Eres mayor de edad\");\n} else if (age &gt;= 16 &amp;&amp; age &lt; 18) {\nconsole.log(\"Eres menor de edad pero tienes ciertos privilegios\");\n} else if (age &gt;= 14 &amp;&amp; age &lt; 16) {\nconsole.log(\"Eres menor de edad y adem\u00e1s no tienes privilegios\");\n} else {\nconsole.log(\"Eres menor de edad\");\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#switch","title":"Switch","text":"<p>El cuerpo de una sentencia <code>switch</code> se conoce como bloque switch. Esta sentencia eval\u00faa una expresi\u00f3n y cada <code>case</code> contiene un posible valor del resultado de dicha expresi\u00f3n; si efectivamente el resultado equivale a ese valor, se ejecutan las instrucciones de ese <code>case</code> y de los siguientes.</p> <pre><code>switch(expresi\u00f3n) {\ncase valor1 :\ninstrucciones\nbreak; // opcional\ncase valor2 :\ninstrucciones\nbreak; // opcional\n//....\n//....\ndefault : // opcional\ninstrucciones\nbreak; // opcional\n}\n</code></pre> <p>La instrucci\u00f3n <code>break</code> se utiliza para salir del <code>switch</code>. De tal modo que si queremos que para un determinado valor se ejecuten las instrucciones de un apartado <code>case</code> y solo las de ese apartado, entonces habr\u00e1 que finalizar ese <code>case</code> con un <code>break</code>. Cuando se alcanza una sentencia <code>break</code>, el <code>switch</code> termina y el flujo de control salta a la siguiente l\u00ednea que sigue a la sentencia <code>switch</code>.</p> <p>Fall through condition (condici\u00f3n de ca\u00edda): esta condici\u00f3n se produce en la sentencia <code>switch</code> cuando no se utiliza <code>break</code> en un <code>case</code> y causa la ejecuci\u00f3n de los siguientes <code>case</code> hasta que no se produce un break o se sale de la sentencia switch.</p> <p>El bloque <code>default</code> sirve para ejecutar instrucciones para los casos en los que la expresi\u00f3n no se ajuste a ning\u00fan case. T\u00e9cnicamente, el <code>break</code> del <code>default</code> no es necesario porque el flujo se sale de la sentencia <code>switch</code>, pero se recomienda utilizarlo para que la modificaci\u00f3n del c\u00f3digo sea m\u00e1s f\u00e1cil y menos propensa a errores.</p> <p>En ciertas ocasiones, se puede usar la sentencia <code>return</code> en lugar de la sentencia <code>break</code>, sobretodo cuando queremos que la estructura <code>switch</code> devuelva un valor, por ejemplo, dentro de una funci\u00f3n.</p> <pre><code>let a = 2 + 2;\nswitch (a) {\ncase 3:\nconsole.log('Muy peque\u00f1o');\nbreak;\ncase 4:\nconsole.log('\u00a1Exacto!');\nbreak;\ncase 5:\nconsole.log('Muy grande');\nbreak;\ndefault:\nconsole.log(\"Desconozco estos valores\");\n}\n</code></pre> <p>Expresiones</p> <p>Ambos <code>switch</code> y <code>case</code> permiten expresiones arbitrarias.</p> <pre><code>let a = \"1\";\nlet b = 0;\nswitch (+a) {\ncase b + 1:\nalert(\"esto se ejecuta, porque +a es 1, exactamente igual b+1\");\nbreak;\ndefault:\nalert(\"esto no se ejecuta\");\n}\n</code></pre> <p>Se pueden agrupar varias sentencias <code>case</code> en caso de que se desee que hagan las mismas instrucciones:</p> <pre><code>let a = 2 + 2;\nswitch (a) {\ncase 4:\nconsole.log('\u00a1Correcto!');\nbreak;\ncase 3:\ncase 5:\nconsole.log('\u00a1Incorrecto!');\nconsole.log(\"\u00bfPor qu\u00e9 no tomas una clase de matem\u00e1ticas?\");\nbreak;\ndefault:\nconsole.log('El resultado es extra\u00f1o. Realmente.');\n}\n</code></pre> <p>\u00a1Cuidado!</p> <p>Hay que tener en cuenta, que el tipo de dato a evaluar en las expresiones IMPORTAN, por lo que no es lo mismo evaluar el valor <code>\"3\"</code> que el valor <code>3</code>:</p> <pre><code>let arg = prompt(\"Ingrese un valor\");\nswitch (arg) {\ncase '0':\ncase '1':\nconsole.log('Uno o cero');\nbreak;\ncase '2':\nconsole.log('Dos');\nbreak;\ncase 3:\nconsole.log('\u00a1Nunca ejecuta!');\nbreak;\ndefault:\nconsole.log('Un valor desconocido');\n}\n</code></pre> <p>En el caso anterior, si el usuario introduce un valor entre 0 y 2, se ejecutar\u00e1 las instrucciones pertinentes. Pero, si introduce un 3, se ejecutar\u00e1 las instrucciones <code>default</code>, ya que el 3 introducido por el usuario es de tipo <code>string</code> y el que se esta evaluando en el <code>case</code> es de tipo <code>number</code> y las sentencias <code>case</code> hacen comparaciones estrictas, es decir, como si usar\u00e1n el comparador <code>===</code></p>"},{"location":"bloque_i/tema_3/page-1/#operador-ternario","title":"Operador Ternario","text":"<p>Como ya vimos en el tema anterior, el operador ternario realiza una funci\u00f3n id\u00e9ntica a la estructura condicional. La diferencia entre ambas es que el operador ternario es una expresi\u00f3n, que dependiendo de su valor devuelve un valor u otro, mientras que la estructura condicional, es una estructura que eval\u00faa una expresi\u00f3n y ejecuta una serie de instrucciones, seg\u00fan el valor de esa expresi\u00f3n.</p> <p>Se recomienda el uso de operador ternario, siempre que se desea devolver un valor dependiendo de una condici\u00f3n y no para la ejecuci\u00f3n de instrucciones. Por lo que, NO se recomienda hacer lo siguiente:</p> <pre><code>(company == 'Netscape') ?\nalert('\u00a1Correcto!') : alert('Equivocado.');\n</code></pre> <p>Para eso se recomienda el uso de la estructura condicional:</p> <pre><code>if (company == 'Netscape') {\nalert('\u00a1Correcto!');\n} else {\nalert('Equivocado.');\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>\u00bfSe ejecutar\u00e1 la siguiente instrucci\u00f3n? Justifica tu respuesta.</p> <pre><code>if(\"0\"){\nconsole.log('Hello')\n}\n</code></pre> Ejercicio 2 <p>Realizar un programa que le pregunte al usuario el nombre oficial de Javascript. Si el usuario introduce ECMAScript se mostrar\u00e1 por consola y de color verde una frase exitosa. Por el contrario, se mostrar\u00e1 en rojo, que la respuesta es incorrecta y se mostrar\u00e1 la respuesta correcta.</p> Ejercicio 3 <p>Realiza un programa que compruebe si un n\u00famero introducido por el usuario es un n\u00famero positivo, negativo o 0.</p> Ejercicio 4 <p>Reescribe el siguiente ejemplo, haciendo uso del operador ternario:</p> <pre><code>let result;\nif (a + b &lt; 4) {\nresult = 'Debajo';\n} else {\nresult = 'Encima';\n}\n</code></pre> Ejercicio 5 <p>Reescribe el siguiente ejemplo, haciendo uso de la estructura condicional:</p> <pre><code>let message = (login == 'Empleado') ? 'Hola' :\n(login == 'Director') ? 'Felicidades' :\n(login == '') ? 'Sin sesi\u00f3n' :\n'';\n</code></pre> Ejercicio 6 <p>Realiza un programa que lea tres n\u00fameros positivos y compruebe si son iguales. Por ejemplo: Si la entrada fuese 5 5 5, la salida deber\u00eda ser \u201chay tres n\u00fameros iguales a 5\u201d. Si la entrada fuese 4 6 4, la salida deber\u00eda ser \u201chay dos n\u00fameros iguales a 4\u201d. Si la entrada fuese 0 1 2, la salida deber\u00eda ser \u201cno hay n\u00fameros iguales\u201d.</p> Ejercicio 7 <p>Haciendo uso de la estructura condicional <code>if-else-if</code>, realiza un programa que solicite al usuario una nota y la eval\u00fae de la siguiente forma:</p> <ul> <li>0, 1, 2: Muy deficiente</li> <li>3, 4: Insuficiente</li> <li>5: Suficiente</li> <li>6: Bien</li> <li>7, 8: Notable</li> <li>9, 10: Sobresaliente</li> </ul> <p>Si introduce un n\u00famero diferente a los indicados anteriormente, mostrar\u00e1 un mensaje de error.</p> Ejercicio 8 <p>Realiza el mismo ejercicio anterior, haciendo uso de la estructura <code>switch</code>.</p> Ejercicio 9 <p>Realiza un programa que calcule el precio de un billete de ida y vuelta por avi\u00f3n, conociendo la distancia a recorrer, el n\u00famero de d\u00edas de estancia y sabiendo que si la distancia es superior a 1.000 Km y el n\u00famero de d\u00edas de estancia es superior a 7, la l\u00ednea a\u00e9rea le hace un descuento del 30 %. (Precio por kil\u00f3metro = 0,35 \u20ac).</p> Ejercicio 10 <p>Los empleados de una f\u00e1brica trabajan en dos turnos: diurno y nocturno. Se desea calcular el jornal diario de acuerdo con los siguientes tarifas: la tarifa de las horas diurnas es de 3 \u20ac por hora, mientras que el de las nocturnas es de 4,80 \u20ac po hora. Cuando se trata de un d\u00eda festivo, la tarifa se incrementa en 1,20 \u20ac por hora en el turno diurno y 1,80 \u20ac por hora en el nocturno.</p> Ejercicio 11 <p>Realiza un programa que dados tres n\u00fameros, los devuelva en orden ascendente.</p>"},{"location":"bloque_i/tema_3/page-2/","title":"2 Bucles","text":""},{"location":"bloque_i/tema_3/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>En programaci\u00f3n, un bucle o instrucci\u00f3n de control repetitiva (o iterativa) permite ejecutar una o m\u00e1s instrucciones varias veces, es decir, permite ejecutar un bloque de instrucciones repetidamente, escribi\u00e9ndolas una sola vez en el programa, reduciendo de este modo el c\u00f3digo del mismo. Cada vuelta que da el bucle se conoce como iteraci\u00f3n.</p> <p>Las variables que se utilizan en los bucles pueden tener distintas funciones:</p> <ul> <li>\u00edndice: es una variable que apunta a un recurso concreto. En los bucles, apunta al n\u00famero de iteraci\u00f3n. Se suelen utilizar por convenio los identificadores de variables <code>i</code>, <code>j</code> y <code>k</code>.</li> <li>contador: cuenta cu\u00e1ntas veces ocurre algo.</li> <li>acumulador: acumula operaciones parciales.</li> </ul> <p>Las instrucciones b\u00e1sicas que permiten construir este tipo de estructuras son <code>while</code>, <code>do-while</code> y <code>for</code>.</p>"},{"location":"bloque_i/tema_3/page-2/#while","title":"While","text":"<p>El bucle <code>while</code> agrupa instrucciones las cuales se ejecutan continuamente mientras una condici\u00f3n que se eval\u00faa sea verdadera. La condici\u00f3n se eval\u00faa antes de entrar dentro del <code>while</code> y cada vez que se termina de ejecutar las instrucciones del <code>while</code>.</p> <p>El programa se ejecuta siguiendo estos pasos:</p> <ol> <li>Se eval\u00faa la expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera ejecuta las instrucciones, sino el programa abandona la sentencia <code>while</code>.</li> <li>Tras ejecutar las instrucciones, volvemos al paso 1.</li> </ol> <pre><code>while(expresi\u00f3nL\u00f3gica){\n//instrucciones\n}\n</code></pre> <p>Por ejemplo, se quiere mostrar los n\u00fameros del 1 al 10:</p> <pre><code>let number = 0\nwhile(number &lt; 10){\nconsole.log(++number)\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#do-while","title":"Do-while","text":"<p>La \u00fanica diferencia respecto al <code>while</code> est\u00e1 en que la expresi\u00f3n l\u00f3gica se eval\u00faa despu\u00e9s de haber ejecutado las instrucciones. Es decir, el bucle al menos se ejecuta una vez. Los pasos son los siguientes:</p> <ol> <li>Ejecutar instrucciones.</li> <li>Evaluar expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera, volver al paso 1. Si es falsa, salir del do-while.</li> </ol> <p>El ejemplo anterior se har\u00eda de la siguiente manera:</p> <pre><code>let number = 0\ndo{\nconsole.log(++number)\n} while(number &lt; 10)\n</code></pre> <p>Se recomienda hacer uso de la estructura <code>do-while</code> cuando se desea que independientemente de la condici\u00f3n se ejecute las instrucciones al menos una vez. Uno de sus usos m\u00e1s comunes, es para pedir al usuario alg\u00fan dato, y en caso de que no se cumpla lo introducido se vuelva a introducir:</p> <pre><code>let number\ndo{\nnumber = parseInt(prompt('Introduce un n\u00famero entre 0 y 10'))\n} while(number &lt; 0 || number &gt; 10)\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#for","title":"For","text":"<p>El bucle <code>for</code> es una estructura de iteraci\u00f3n donde se utiliza una variable local que controle la iteraci\u00f3n. El funcionamiento es el siguiente:</p> <ol> <li>Se ejecuta la instrucci\u00f3n de inicializaci\u00f3n.</li> <li>Se comprueba la condici\u00f3n.</li> <li>Si la condici\u00f3n es cierta, entonces se ejecutan las instrucciones. Si la condici\u00f3n es falsa, se abandona el bloque for.</li> <li>Tras ejecutar las instrucciones, se ejecuta la instrucci\u00f3n de incremento y se vuelve al paso</li> </ol> <pre><code>for(inicializaci\u00f3n;condici\u00f3n;incremento){\n// instrucciones\n}\n</code></pre> <p>As\u00ed el ejemplo anterior:</p> <pre><code>for(let number = 1; number &lt;= 10; number++){\nconsole.log(number)\n}\n</code></pre> <p>La inicializaci\u00f3n se puede hacer tanto como dentro como fuera del bucle, aunque se recomienda hacer uso de ella dentro.</p> <p>Tambi\u00e9n se admite m\u00e1s de una variable, en cuyo caso, en las partes de inicializaci\u00f3n e incremento, se utiliza como separador la coma <code>,</code>:</p> <pre><code>for(int i = 0, j = 10; i &lt;= j; i++, j--){\nconsole.log(`i: ${i} j: ${j}`);\n}\n</code></pre> <p>Danger</p> <p>Por motivos de legibilidad de c\u00f3digo, es muy importante que las variables del <code>for</code> aparezcan en las 3 partes del <code>for</code>, es decir, en la inicializaci\u00f3n, en la condici\u00f3n y en el incremento, ya que el programador que quiera saber cu\u00e1ntas iteraciones realiza el bucle, solamente con fijarse en la l\u00ednea de c\u00f3digo donde se encuentra el <code>for</code>, pueda saberlo. Si las variables del <code>for</code> no aparecen en las 3 partes, eso nos indica que es m\u00e1s conveniente realizar un <code>while</code> o un <code>do-while</code>.</p> <p>Veamos el ejemplo que muestra n\u00fameros aleatorios entre 1 y 500 hasta que salga uno m\u00faltiplo de 7:</p> <pre><code>boolean exit = false;\nint number = 0, i;\nfor(i = 1; !exit; i++){ // Este for no es legible, se debe sustituir por un do-while\nnumber = Math.floor((Math.random() * 500) + 1);\nSystem.out.printf(\"Iteraci\u00f3n %d, n\u00famero: %d\\n\", i, number);\nexit = (number % 7 == 0);\n}\nSystem.out.printf(\"El m\u00faltiplo de 7 con valor %d se ha encontrado en la iteraci\u00f3n %d\", number, i - 1);\n</code></pre> <p>En Javascript, podemos omitir las siguientes partes:</p> <ul> <li> <p>La inicializaci\u00f3n, si se realiza fuera del bucle:</p> <pre><code>let i = 0\nfor (; i &lt; 3; i++) { alert(i)\n}\n</code></pre> </li> <li> <p>El incremento si se hace dentro del bucle:</p> <pre><code>let i = 0;\nfor (; i &lt; 3;) {\nalert( i++ );\n}\n</code></pre> </li> <li> <p>Todo, si no se desea que el bucle tenga l\u00edmite, es decir, que sea un bucle infinito.</p> <pre><code>for (;;) {\n// se repite sin limites\n}\n</code></pre> </li> </ul> <p>En cualquiera de los casos, es obligatorio el uso del punto y coma <code>;</code> para que no de un error de sintaxis.</p>"},{"location":"bloque_i/tema_3/page-2/#diferencias","title":"Diferencias","text":"<p>Todos los bucles se pueden hacer con <code>for</code>, <code>while</code> y <code>do-while</code>, entonces, \u00bfcu\u00e1l se debe usar? Es importante que le programador utilice la estructura m\u00e1s adecuada en cada caso:</p> <ul> <li>Un bucle <code>for</code> se utiliza cuando se conozca el n\u00famero de veces que se va a ejecutar el bucle, es decir, cuando se conozcan el n\u00famero de iteraciones de antemano.</li> <li>Si no se sabe de antemano el n\u00famero de iteraciones, entonces hay que utilizar <code>while</code> o <code>do-while</code>:</li> <li>Un bucle <code>do-while</code> se utiliza cuando las instrucciones del bucle se van a ejecutar al menos una vez.</li> <li>Un bucle <code>while</code> se utiliza, entonces, cuando las instrucciones del bucle pueden no ejecutarse nunca si la condici\u00f3n es falsa desde un principio.</li> </ul>"},{"location":"bloque_i/tema_3/page-2/#bucles-forin-forof","title":"Bucles for..in for..of","text":"<p>El bucle <code>for..in</code> es un bucle que sirve para recorrer un objeto en Javascript:</p> <pre><code>for (key in object) {\n// se ejecuta el cuerpo para cada clave entre las propiedades del objeto\n}\n</code></pre> <p>Por ejemplo:</p> <pre><code>let user = {\nname: \"John\",\nage: 30,\nisAdmin: true\n}\nfor (let key in user) {\nconsole.log(key, user[key])\n}\n</code></pre> <p>El bucle <code>for..of</code> se utiliza para recorrer los valores de un array:</p> <pre><code>const array = [1,2,3,4]\nfor(let a of array){\nconsole.log(a)\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Dados dos n\u00fameros <code>n1</code> y <code>n2</code>, tal que <code>n1 &lt;= n2</code>, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle <code>while</code>.</p> Ejercicio 2 <p>Realiza el ejercicio anterior haciendo uso del bucle <code>do-while</code>.</p> Ejercicio 3 <p>Realiza el ejercicio anterior haciendo uso del bucle <code>for</code>.</p> Ejercicio 4 <p>\u00bfCu\u00e1l es el \u00faltimo valor mostrado en alerta por este c\u00f3digo? \u00bfPor qu\u00e9?</p> <pre><code>let i = 3\nwhile (i) {\nconsole.log(i--)\n}\n</code></pre> Ejercicio 5 <p>Muestra los n\u00fameros pares comprendido entre 0 y 10. Usa el bucle que creas correspondiente, justificando su uso.</p> Ejercicio 6 <p>Escribe un bucle que solicite un n\u00famero mayor que 100. Si el usuario ingresa otro n\u00famero p\u00eddele que ingrese un valor de nuevo.</p> <p>El bucle debe pedir un n\u00famero hasta que el usuario ingrese un n\u00famero mayor que 100 o bien cancele la entrada o ingrese una linea vac\u00eda.</p> <p>Aqu\u00ed podemos asumir que el usuario solo ingresar\u00e1 n\u00fameros. No hay necesidad de implementar un manejo especial para entradas no num\u00e9ricas en esta tarea.</p> Ejercicio 7 <p>Escribe un programa que le solicite al usuario un n\u00famero, y muestre los n\u00fameros primos comprendidos entre 0 y dicho n\u00famero. Para <code>n = 10</code> el resultado ser\u00e1 2, 3, 5, 7. El c\u00f3digo deber\u00eda funcionar para cualquier n, no debe estar programado para valores fijos.</p> Ejercicio 8 <p>Realiza un programa que muestre la tabla de multiplicar de un n\u00famero solicitado por el usuario. El n\u00famero que debe introducir debe ser comprendido entre 1 y 10. </p>"},{"location":"bloque_i/tema_4/page-1/","title":"1 Funciones","text":""},{"location":"bloque_i/tema_4/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ul> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ul> <p>Dichas funciones se pueden utilizar desde muchos sitios diferentes, por lo que de manera general, no se suelen poner mensajes en consola en las funciones ya que puede ser que dichos mensajes no interesen en todos los sitios donde se utilice dicha funci\u00f3n. A no ser que la funci\u00f3n se haya creado espec\u00edficamente para dar mensajes informativos en consola.</p>"},{"location":"bloque_i/tema_4/page-1/#declaracion","title":"Declaraci\u00f3n","text":"<p>Existen diferentes maneras de crear una funci\u00f3n, pero la forma est\u00e1ndar y longeva es la siguiente:</p> <pre><code>function functionName([param1, param2, param3, ..., paramN]){\n// instrucciones\n[return value]\n}\n</code></pre> <p>Para declarar una funci\u00f3n de forma est\u00e1ndar es necesario hacer uso de la palabra reservada <code>function</code> seguido del nombre de la funci\u00f3n (functionName) y par\u00e9ntesis. Dentro de estos par\u00e9ntesis se pueden declarar los par\u00e1metros necesarios para usar dentro de la funci\u00f3n. Los par\u00e1metros son variables que se necesitan usar dentro de las funciones y que en cada llamada de la funci\u00f3n tiene valores diferentes. Una funci\u00f3n puede recibir ning\u00fan par\u00e1metro.</p> <p>Las funciones, adem\u00e1s, pueden retornar un valor que puede ser usada en variables o en otras funciones. Si una funci\u00f3n no retorna ning\u00fan valor, estar\u00edamos hablando t\u00e9cnicamente de un procedimiento.</p> <p>Veamos un ejemplo de una funci\u00f3n que recibe dos n\u00fameros, y retorne la suma de ambos:</p> <pre><code>function suma(sumando1, sumando2){\nreturn sumando1 + sumando2\n}\n</code></pre> <p>Ahora, veamos un ejemplo de una funci\u00f3n con dos retornos. En este caso, en el momento que retorne una de los dos valores, abandona el flujo de la funci\u00f3n. Una funci\u00f3n aunque tenga varios <code>return</code> solo puede retornar un valor:</p> <pre><code>function isPair(number){\nif(number % 2 === 0){\nreturn 'es par'\n}\nreturn 'es impar'\n}\n</code></pre> <p>En el ejemplo anterior, si el n\u00famero obtenido como par\u00e1metro es par, retorna el valor de <code>es par</code>. Por el contrario, si el n\u00famero es impar, no entra en la condici\u00f3n y obvia el primer <code>return</code>, por lo que retornar\u00eda <code>es impar</code>. Veamos un ejemplo de procedimiento:</p> <pre><code>function sayHi(){\nconsole.log('Hi')\n}\n</code></pre> <p>Recuerda</p> <p>En este punto, es bueno recordar el \u00e1mbito de vida de una variable, y recordar la diferencia entre \u00e1mbito de vida local y \u00e1mbito de vida global, tal y como lo vimos en el tema dos</p>"},{"location":"bloque_i/tema_4/page-1/#llamada","title":"Llamada","text":"<p>Para realizar la llamada de una funci\u00f3n, se usa la siguiente estructura: <code>functionName([arg1, arg2, ..., argN])</code>. Se le puede indicar los argumentos que reciba.</p> <p>La diferente entre argumento y par\u00e1metro es que un par\u00e1metro es una variable que se define a la hora de declarar la funci\u00f3n y un argumento es el valor del par\u00e1metro a la hora de la llamada de la funci\u00f3n.</p> <p>Warning</p> <p>Si una funci\u00f3n no recibe par\u00e1metros pero en su llamada le pasamos argumentos, estos ser\u00e1n omitidos y Javascript no lanzar\u00eda error. Lo mismo ocurrir\u00eda si recibe X par\u00e1metros, y se le pasa m\u00e1s argumentos de los deseados:</p> <pre><code>function sayHi(){\nconsole.log('Hi!')\n}\nsayHi('Hola mundo')\n</code></pre> <p>Lo mismo ocurre, en el caso contario, si una funci\u00f3n define un par\u00e1metro y este no es recibido como argumento, se entiende que el valor de ese par\u00e1metro es <code>undefined</code>:</p> <pre><code>function sayHi(msg){\nconsole.log(msg)\n}\nsayHi()\n</code></pre> <p>En el siguiente ejemplo, podemos comprobar mejor la diferencia entre procedimiento y funci\u00f3n:</p> <pre><code>function sum(num1, num2){\nreturn num1 + num2\n}\nfunction show(msg){\nconsole.log(msg)\n}\nlet sumValue = sum(2, 4)\nshow(sumValue)\n</code></pre> <p>Como vemos en el ejemplo, la funci\u00f3n <code>sum</code> retorna la suma de los dos par\u00e1metros que recibe, por lo que el valor retornado puede ser usado en otra variable o como argumento de otra funci\u00f3n. Mientras que, la funci\u00f3n <code>show</code> es un procedimiento, ya que no retorna nada, y no puede ser usada en ninguna variable. Sin embargo, si por error es usada, el valor de dicha variable ser\u00e1 <code>undefined</code> ya que el procedimiento no retorna ning\u00fan valor, pero podemos entender que por defecto retorna <code>undefined</code>.</p>"},{"location":"bloque_i/tema_4/page-1/#parametros-predeterminados","title":"Par\u00e1metros predeterminados","text":"<p>Como hemos dicho anteriormente, si un par\u00e1metro no es pasado como argumento en una funci\u00f3n su valor predeterminado es <code>undefined</code>. Sin embargo, algunos lenguajes como Javascript permite definir un valor predeterminado para dichos par\u00e1metros para el caso de que no sean usados:</p> <pre><code>function sayHi(msg = 'Hi'){\nconsole.log(msg)\n}\nsayHi()\n</code></pre> <p>En el ejemplo anterior, como la llamada a la funci\u00f3n no recibe par\u00e1metros, mostrara por consola el valor predeterminado <code>Hi</code>.</p> <p>Warning</p> <p>En versiones anteriores, no eran soportados los par\u00e1metros predeterminados. Entonces, se usa un condicional para comprobar si el valor era <code>undefined</code> y se indicada un valor:</p> <pre><code>function sayHi(msg){\nif(msg === undefined){\nmsg = 'Hi'\n}\nconsole.log(msg)\n}\n</code></pre> <p>O se usaba el operador <code>||</code>:</p> <pre><code>function sayHi(msg){\nmsg = msg || 'Hi'\nconsole.log(msg)\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-1/#nomenclatura","title":"Nomenclatura","text":"<p>Las funciones son acciones, por lo que se recomienda que su nombre sea un verbo. Debe ser breve, lo m\u00e1s preciso posible y describir lo que hace la funci\u00f3n, para que alguien que lea el c\u00f3digo obtenga una indicaci\u00f3n de lo que hace la funci\u00f3n.</p> <p>Es una pr\u00e1ctica generalizada comenzar una funci\u00f3n con un prefijo verbal que describe vagamente la acci\u00f3n. Debe haber un acuerdo dentro del equipo sobre el significado de los prefijos.</p> <p>Por ejemplo, funciones que comienzan con show usualmente muestran algo.</p> <p>Funciones que comienza con\u2026</p> <ul> <li>get\u2026 \u2013 devuelven un valor</li> <li>calc\u2026 \u2013 calculan algo</li> <li>create\u2026 \u2013 crean algo</li> <li>check\u2026 \u2013 revisan algo y devuelven un boolean, etc.</li> </ul> <p>Ejemplos de este tipo de nombres:</p> <pre><code>showMessage(..)     // muestra un mensaje\ngetAge(..)          // devuelve la edad (la obtiene de alguna manera)\ncalcSum(..)         // calcula una suma y devuelve el resultado\ncreateForm(..)      // crea un formulario (y usualmente lo devuelve)\ncheckPermission(..) // revisa permisos, y devuelve true/false\n</code></pre> <p>Tips</p> <p>Es altamente recomendable que una funci\u00f3n solo tenga un objeto, es decir, una acci\u00f3n. Una funci\u00f3n debe hacer exactamente lo que sugiere su nombre, no m\u00e1s.</p> <p>Dos acciones independientes por lo general merecen dos funciones, incluso si generalmente se convocan juntas (en ese caso, podemos hacer una tercera funci\u00f3n que llame a esas dos).</p> <p>Algunos ejemplos de c\u00f3mo se rompen estas reglas:</p> <ul> <li><code>getAge</code> \u2013 est\u00e1 mal que muestre una <code>alert</code> o un <code>log</code> con la edad (solo debe obtenerla).</li> <li><code>createForm</code> \u2013 est\u00e1 mal que modifique el documento agreg\u00e1ndole el form (solo debe crearlo y devolverlo).</li> <li><code>checkPermission</code> \u2013 est\u00e1 mal que muestre el mensaje acceso otorgado/denegado(solo debe realizar la verificaci\u00f3n y devolver el resultado).</li> </ul> <p>En estos ejemplos asumimos los significados comunes de los prefijos. T\u00fa y tu equipo pueden acordar significados diferentes, aunque usualmente no muy diferente. En cualquier caso, debe haber una compromiso firme de lo que significa un prefijo, de lo que una funci\u00f3n con prefijo puede y no puede hacer. Todas las funciones con el mismo prefijo deben obedecer las reglas. Y el equipo debe compartir ese conocimiento.</p> <p>Tambi\u00e9n se considera que una buena pr\u00e1ctica que una funci\u00f3n sea lo m\u00e1s breve posible. En caso de que una funci\u00f3n sea demasiado larga, se deber\u00eda revisar y comprobar que el c\u00f3digo no se puede dividir en m\u00e1s funciones. De esta forma, se obtiene una serie de ventajas, como una mayor legibilidad, m\u00e1s facilidad a la hora de probar y depurar.</p>"},{"location":"bloque_i/tema_4/page-1/#recursividad","title":"Recursividad","text":"<p>La recursividad es un patr\u00f3n de programaci\u00f3n que es \u00fatil en situaciones en las que una tarea puede dividirse naturalmente en varias tareas del mismo tipo, pero m\u00e1s simples. O cuando una tarea se puede simplificar en una acci\u00f3n f\u00e1cil m\u00e1s una variante m\u00e1s simple de la misma tarea. O, como veremos pronto, tratar con ciertas estructuras de datos.</p> <p>Sabemos que cuando una funci\u00f3n resuelve una tarea, en el proceso puede llamar a muchas otras funciones. Un caso particular de esto se da cuando una funci\u00f3n se llama a s\u00ed misma. Esto es lo que se llama recursividad.</p> <p>Esta t\u00e9cnica es peligrosa ya que se pueden generar f\u00e1cilmente llamadas infinitas (la funci\u00f3n se llama a s\u00ed misma, tras la llamada se vuelve a llamar a s\u00ed misma, y as\u00ed sucesivamente sin freno ni control). Por lo tanto, es muy importante tener en cuenta cu\u00e1ndo la funci\u00f3n debe dejar de llamarse.</p> <p>Hay que ser muy cauteloso cuando se utiliza la recursividad, pero permite soluciones muy originales y abre la posibilidad de solucionar problemas muy complejos.</p> <p>Veamos un ejemplo sin recursividad:</p> <pre><code>function multiplicate(num1, num2){\nlet result = 0\nfor(let i = 1; i &lt;= num2; i++){\nresult += num1\n}\nreturn result\n}\n</code></pre> <p>En ele ejemplo anterior observamos como se realiza la multiplicaci\u00f3n de dos n\u00fameros realizando suma. En este caso, se est\u00e1 utilizando la iteraci\u00f3n. Le sumamos a la variable <code>result</code> el valor del argumento <code>num1</code> tantas veces como se indica en <code>num2</code>. Ahora bien, cuando hacemos una multiplicaci\u00f3n como ejemplo <code>2*3</code>, \u00bfno es lo mismo que <code>2+2*2</code>?, o lo que es lo mismo, <code>2 + 2 + 2 * 1</code>. En este caso, el indice que indica el n\u00famero de veces a sumar se va reduciendo. En este caso, estamos pensando haciendo uso de la recursividad, ya que cada vez que hacemos una multiplicaci\u00f3n estar\u00edamos llamando a nuestra funci\u00f3n.</p> <pre><code>function multiplicate(num1, num2){\nreturn num1 + multiplicate(num1, num2 - 1)\n}\n</code></pre> <p>Sin embargo, el ejemplo anterior da lugar a que sea infinito, ya que no se controla cual debe ser la \u00faltima recursi\u00f3n, que en este caso ser\u00eda cuando <code>num2</code> valga 1. Esta sentencia de control, se llama caso base es necesaria en la funciones recursivas, ya que indican la \u00faltima ejecuci\u00f3n de la recursividad.</p> <pre><code>function multiplicate(num1, num2){\nif(num2 === 1){\nreturn num1\n}\nreturn num1 + multiplicate(num1, num2 - 1)\n}\n</code></pre> <p>Si se desea hacer la multiplicaci\u00f3n <code>2 * 3</code>:</p> <ol> <li>En la ejecuci\u00f3n inicial no se ejecuta el bloque <code>if</code> si no que se ejecuta <code>2 + multiplicate(2, 2)</code></li> <li>En la siguiente, sigue sin entrar en el <code>if</code>, por lo que se ejecuta <code>2 + multiplicate(2, 1)</code></li> <li>En esta ejecuci\u00f3n retornar\u00eda <code>2</code>, ya que <code>num2</code> vale 1 y entrar\u00eda en el <code>if</code>.</li> <li>Una vez retornado <code>2</code>, podemos completar la ejecuci\u00f3n del paso 2, retornando <code>2 + 2</code>, que ser\u00eda 4.</li> <li>Por \u00faltimo, usar\u00edamos dicho valor, en la ejecuci\u00f3n del paso 1, <code>2 + 4</code>, dando como resultado <code>6</code>.  </li> </ol> <p>El n\u00famero m\u00e1ximo de llamadas anidadas (incluida la primera) se llama profundidad de recursividad. En nuestro caso, ser\u00e1 exactamente <code>num2</code>.</p> <p>La profundidad m\u00e1xima de recursividad est\u00e1 limitada por el motor de JavaScript. Podemos confiar en que sea 10 000; algunos motores permiten m\u00e1s, pero 100 000 probablemente est\u00e9 fuera del l\u00edmite para la mayor\u00eda de ellos. Hay optimizaciones autom\u00e1ticas que ayudan a aliviar esto (\u201coptimizaciones de llamadas de cola\u201d), pero a\u00fan no tienen soporte en todas partes y funcionan solo en casos simples.</p> <p>Eso limita la aplicaci\u00f3n de la recursividad, pero sigue siendo muy amplia. Hay muchas tareas donde la forma recursiva de pensar proporciona un c\u00f3digo m\u00e1s simple y f\u00e1cil de mantener.</p>"},{"location":"bloque_i/tema_4/page-1/#recursividad-vs-iteracion","title":"Recursividad vs iteraci\u00f3n","text":"<p>Ambas implican sentencias repetitivas hasta llegar a una determinada condici\u00f3n, por lo que ambas pueden generar programas que no finalizan si la condici\u00f3n nunca se cumple. En el caso de la iteraci\u00f3n es una condici\u00f3n la que permite determinar el final, la recursividad lo que hace es ir simplificando el problema hasta generar una llamada a la funci\u00f3n que devuelva un valor y no se vuelva a llamar. Para un ordenador es m\u00e1s costosa la recursividad ya que implicar realizar muchas llamadas a funciones, es decir, es m\u00e1s r\u00e1pida la soluci\u00f3n iterativa. Entonces, \u00bfpor qu\u00e9 elegir recursividad? La recursividad se utiliza s\u00f3lo s\u00ed:</p> <ul> <li>No encontramos la soluci\u00f3n iterativa a un problema.</li> <li>El c\u00f3digo es mucho m\u00e1s claro en su versi\u00f3n recursiva.</li> </ul>"},{"location":"bloque_i/tema_4/page-1/#pila","title":"Pila","text":"<p>Una pila (stack) es una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del ingl\u00e9s Last In, First Out, \u00faltimo en entrar, primero en salir) de supuestos en el \u00e1rea de inform\u00e1tica debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.</p> <p>Para el manejo de los datos cuenta con dos operaciones b\u00e1sicas: apilar (push), que coloca un objeto en la pila, y su operaci\u00f3n inversa, desapilar (pop), que retira el \u00faltimo elemento apilado.</p> <p>En cada momento s\u00f3lo se tiene acceso a la parte superior de la pila, es decir, al \u00faltimo objeto apilado (denominado TOS, Top of Stack). La operaci\u00f3n desapilar permite la obtenci\u00f3n de este elemento, que es retirado de la pila permitiendo el acceso al anterior (apilado con anterioridad), que pasa a ser el \u00faltimo, el nuevo TOS.</p> <p>Para las llamadas entre funciones, se utiliza una estructura de tipo pila: supongamos que se est\u00e1 procesando una funci\u00f3n y en su interior llama a otra funci\u00f3n. La funci\u00f3n se abandona para procesar la funci\u00f3n de la llamada, pero antes se almacena en una pila la direcci\u00f3n que apunta a la funci\u00f3n. Ahora supongamos que esa nueva funci\u00f3n llama a su vez a otra funci\u00f3n. Igualmente, se almacena su direcci\u00f3n, se abandona y se atiende la petici\u00f3n. As\u00ed en tantos casos como existan peticiones. La ventaja de la pila es que no requiere definir ninguna estructura de control ni conocer las veces que el programa estar\u00e1 saltando entre funciones para despu\u00e9s retomarlas, con la \u00fanica limitaci\u00f3n de la capacidad de almacenamiento de la pila. Conforme se van cerrando las funciones, se van rescatando las funciones precedentes mediante sus direcciones almacenadas en la pila y se va concluyendo su proceso, esto hasta llegar a la primera.</p> <p>En el caso de una funci\u00f3n recursiva, esto es posible implementarlo con sencillez mediante una pila. La funci\u00f3n se llama a s\u00ed misma tantas veces como sea necesario hasta que el resultado de la funci\u00f3n cumpla la condici\u00f3n de retorno; entonces, todas las funciones abiertas van completando su proceso en cascada. No se necesita saber cuantas veces se anidar\u00e1 y, por tanto, tampoco cuando se cumplir\u00e1 la condici\u00f3n, con la \u00fanica limitaci\u00f3n de la capacidad de la pila. De sobrepasarse ese l\u00edmite, normalmente porque se entra en un bucle sin final, se produce el error de desbordamiento de la pila (stack overflow).</p> <p>Supongamos que tenemos la funci\u00f3n <code>multiplicate(2, 3)</code>, en la primera llamada, volvemos a llamar el valor <code>multiplicate(2, 2)</code> poniendo esta llamada en la primera posici\u00f3n de la pila. La llamada de <code>multiplicate(2, 2)</code> se ejecuta y pasa a llamar <code>multiplicate(2, 1)</code>, apilando esta llamada al comienzo de la pila. Al ejecutar <code>multiplicate(2, 1)</code> retorna 1, por lo que se desapila de la pila y con el valor retornado va operando las llamadas de la pila <code>multiplicate(2, 2)</code> la de <code>multiplicate(2, 3)</code>.</p>"},{"location":"bloque_i/tema_4/page-1/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>La siguiente funci\u00f3n devuelve <code>true</code> si el par\u00e1metro <code>age</code> es mayor a <code>18</code>. De lo contrario, solicita confirmaci\u00f3n y devuelve su resultado. \u00bfFuncionan ambos c\u00f3digos de la misma forma? \u00bfCu\u00e1l ser\u00eda el m\u00e1s \u00f3ptimo? Justifica tu respuesta:</p> AB <pre><code>function checkAge(age) {\nif (age &gt; 18) {\nreturn true;\n} else {\n// ...\nreturn confirm('\u00bfTus padres te permitieron?');\n}\n}\n</code></pre> <pre><code>function checkAge(age) {\nif (age &gt; 18) {\nreturn true;\n}\n// ...\nreturn confirm('\u00bfTus padres te permitieron?');\n}\n</code></pre> Ejercicio 2 <p>\u00bfCu\u00e1l es la salida del siguiente programa?</p> <pre><code>function showMessages(msg){\nconsole.log('This is your message:', msg)\n}\nconsole.log(showMessages('Hola mundo'))\n</code></pre> Ejercicio 3 <p>Crea una funci\u00f3n que calcule reciba una base y un exponente y devuelva la potencia baseexponente.</p> Ejercicio 4 <p>Realiza una funci\u00f3n que devuelva el factorial de un n\u00famero que debe recibir como argumento.</p> Ejercicio 5 <p>Realiza una funci\u00f3n que reciba 3 par\u00e1metros: dos de tipo entero y uno de tipo cadena. La funci\u00f3n deber\u00e1 sumar, restar, multiplicar o dividir los valores de los dos primeros par\u00e1metros dependiendo de la operaci\u00f3n indicada en el tercer par\u00e1metro, y devolver el resultado. La operaci\u00f3n predeterminada ser\u00eda la suma.</p> Ejercicio 6 <p>Realiza una funci\u00f3n que retorne el m\u00e1ximo com\u00fan divisor de dos n\u00fameros.</p> Ejercicio 7 <p>Realiza una funci\u00f3n que retorne el m\u00ednimo com\u00fan m\u00faltiplo de dos n\u00fameros.</p> Ejercicio 8 <p>Realiza una funci\u00f3n que muestre todos los n\u00fameros primos hasta un l\u00edmite indicado. Por ejemplo, si se indica como l\u00edmite 100, se mostrar\u00e1 los n\u00fameros primeros entre 0 y 100.</p> Ejercicio 9 <p>Se dice que un n\u00famero entero es un n\u00famero perfecto si la suma de sus divisores propios (incluyendo el 1 y sin incluirse \u00e9l mismo) da como resultado el mismo n\u00famero. Por ejemplo, 6 es un n\u00famero perfecto, porque sus divisores propios son 1, 2 y 3; y 6 = 1 + 2 + 3. Los siguientes n\u00fameros perfectos son 28, 496 y 8128.</p> <p>Realiza una funci\u00f3n que muestre todos los n\u00fameros perfectos hasta un l\u00edmite indicado.</p> Ejercicio 10 <p>Realiza una funci\u00f3n que reciba un n\u00famero entero positivo de n cifras y devuelva el n\u00famero con sus cifras en orden inverso. No utilizar cadenas ni calcular previamente el n\u00famero de cifras. Ej: 24.321 debe devolver 12.345</p> Ejercicio 11 <p>La serie Fibonacci se define mediante: a0 = 0 a1 = 1 an = an-1 + an-2, es decir, la serie Fibonacci ser\u00eda la siguiente 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p> <p>Realiza una funci\u00f3n que retorne el valor en la posici\u00f3n indicada. Por ejemplo, si se indica:</p> <ul> <li>0 retorna 0</li> <li>1 retorna 1</li> <li>4 retorna 3</li> <li>7 retorna 13</li> </ul> Ejercicio 12 <p>Realiza una funci\u00f3n que retorne los X n\u00fameros primeros de la serie Fibonacci, siendo X un argumento que debe recibir.</p> Ejercicio 13 <p>Realiza una funci\u00f3n que calcule el primer elemento de la serie Fibonacci que se mayor o igual que un valor introducido por par\u00e1metro. Por ejemplo, si recibe 20, devolver\u00e1 21, ya que es el primer elemento de la serie mayor o igual que 20.</p> Ejercicio 14 <p>El m\u00e1ximo com\u00fan divisor de los enteros a y b es el entero m\u00e1s grande que es divisor exacto de a y de b. Escribe una funci\u00f3n recursiva llamada <code>gcd</code> que devuelva el m\u00e1ximo com\u00fan divisor de a y b. El m\u00e1ximo com\u00fan divisor de a y b se define recursivamente como sigue:</p> <ul> <li>si b = 0 \u2192 gcd(a, b) = a</li> <li>si b \u2260 0 \u2192 gcd(a, b) = gcd(b, a % b)</li> </ul> Ejercicio 15 <p>Realiza el ejercicio 3 haciendo uso de la recursividad</p> Ejercicio 16 <p>Realiza el ejercicio 4 haciendo uso de la recursividad</p> Ejercicio 17 <p>Realiza el ejercicio 11 haciendo uso de la recursividad</p> Ejercicio 18 <p>Realiza el ejercicio 12 haciendo uso de la recursividad</p> Ejercicio 19 <p>Realiza el ejercicio 13 haciendo uso de la recursividad</p> Ejercicio 20 <p>Escribe una funci\u00f3n recursiva <code>sumTo(n)</code> que calcule la suma de los n\u00fameros <code>1 + 2 + ... + n</code>. Por ejemplo:</p> <pre><code>sumTo(1) = 1\nsumTo(2) = 2 + 1 = 3\nsumTo(3) = 3 + 2 + 1 = 6\nsumTo(4) = 4 + 3 + 2 + 1 = 10\n...\nsumTo(100) = 100 + 99 + ... + 2 + 1 = 5050\n</code></pre> Ejercicio 21 <p>Escribe una funci\u00f3n recursiva que dada una cadena retorne la cadena invertida. Por ejemplo, si la funci\u00f3n recibe <code>\"Hola a todos\"</code>, devuelve <code>\"sodot a aloH\"</code></p>"},{"location":"bloque_i/tema_4/page-2/","title":"2 M\u00e9todos en datos primitivos","text":""},{"location":"bloque_i/tema_4/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Javascript permite tratar a los datos primitivos como si fueran objetos, por lo que podemos hacer uso de ciertos m\u00e9todos en ellos. La diferencia entre un dato primitivo y un objeto, es que los datos primitivos almacenan un dato simple (como un n\u00famero), mientras que los objetos permiten almacenar diferentes tipos de datos.</p> <p>El gran dilema de esto es que hay cosas que se desea hacer con los datos primitivos que ser\u00eda de utilidad poder hacerlo con m\u00e9todos (al igual que con los objetos). Sin embargo, los datos primitivos deben de ser tan r\u00e1pidos y livianos como sea posible.</p> <p>La soluci\u00f3n es que los primitivos siguen siendo primitivos, pero el lenguaje permite el acceso a m\u00e9todos y propiedades de \u00e9stos. Para que esto funcione, se crea una envoltura especial (object wrapper) que provee la funcionalidad extra y luego es destruido.</p> <p>Los objetos wrappers son diferentes para cada tipo y suelen llamarse igual que el tipo primitivo pero la primera letra may\u00fascula. As\u00ed como, el object wrapper para el tipo primitivo <code>string</code> es <code>String</code>.</p>"},{"location":"bloque_i/tema_4/page-3/","title":"3 N\u00fameros","text":""},{"location":"bloque_i/tema_4/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Como hemos visto hasta ahora, en Javascript tiene dos tipos de n\u00fameros primitivos, el tipo <code>number</code> y el tipo <code>bigInt</code> para n\u00fameros m\u00e1s grandes. El object wrapper para cada uno de ellos es, <code>Number</code> y <code>BigInt</code>, respectivamente.</p> <p>Los n\u00fameros pueden ser escritos de forma seguida como <code>1000</code> o usando el car\u00e1cter <code>_</code> como separador de miles <code>1_000</code>. En la pr\u00e1ctica, no hay diferencia de escribir un n\u00famero de una forma u otra. Sin embargo, al usar <code>_</code> como separador hace que el c\u00f3digo sea m\u00e1s legible.</p> <p>Tambi\u00e9n podemos escribir la sintaxis <code>NeX</code> donde <code>N</code> es el n\u00famero y donde <code>X</code> es el n\u00famero de 0 que contiene. Tambi\u00e9n es una forma de expresar la exponentiation cient\u00edfica:</p> <pre><code>let billion = 1e9 // 1.000.000.000 \u00f3 1 x 10\u2079\nlet mcs = 1e-6 // 0.000001 \u00f3 1 x 10\u207b\u2076\n</code></pre> <p>Un n\u00famero puede ser expresado tambi\u00e9n en diferente formas seg\u00fan su base:</p> <ul> <li>Binarios. Se usa el prefijo <code>0b</code>. Por ejemplo, `0b11111111' que representa 255 en base decimal.</li> <li>Octal. Se usa el prefijo <code>0o</code>. Por ejemplo, <code>0o377</code>, que representa 255.</li> <li>Hexadecimal. Se usa el prefijo <code>0x</code>. Por ejemplo, <code>0xff</code>.</li> </ul>"},{"location":"bloque_i/tema_4/page-3/#metodo-tostring","title":"M\u00e9todo toString","text":"<p>El m\u00e9todo <code>toString([base])</code> se encarga de transformar el n\u00famero a una cadena seg\u00fan la base indica (en caso de no indicarse ninguna base, se obtiene la cadena en base decimal). La base es un n\u00famero comprendido entre 2 y 36.</p> <pre><code>const number = 3\nconsole.log(number.toString()) // \"3\"\nconsole.log(number.toString(2)) // \"11\"\n</code></pre> <p>Warning</p> <p>Cuando se utiliza un m\u00e9todo de n\u00fameros con un literal num\u00e9rico, es necesario hacer uso de doble puntuaci\u00f3n para la llamada del m\u00e9todo <code>..</code>, ya que Javascript entiende con un \u00fanico punto <code>.</code> un valor decimal.  En caso de usarlo, dar\u00eda en Syntax Error</p> <pre><code>console.log(1..toString())\n</code></pre>"},{"location":"bloque_i/tema_4/page-3/#la-clase-math","title":"La clase Math","text":"<p>La clase <code>Math</code> es una clase de utilidad (solo almacena funciones y constantes) que contiene varias funciones para poder trabajar con n\u00fameros, as\u00ed como ciertas constantes. Entre las constantes podemos encontrar:</p> <ul> <li><code>Math.PI</code>: Valor de variable pi.</li> <li><code>Math.E</code>: Valor del n\u00famero de Euler.</li> </ul> <p>Entre los m\u00e9todos m\u00e1s comunes encontramos:</p> <ul> <li><code>Math.pow(a, b)</code>. Calcula la potencia, siendo <code>a</code> la base y <code>b</code> el exponente.</li> <li><code>Math.sign(number)</code>. Comprueba si el n\u00famero indicado es positivo (devuelve <code>1</code>), negativo (devuelve <code>-1</code>) o 0 (devuelve <code>-1</code>).</li> <li><code>Math.sqrt(number)</code>. Calcula la ra\u00edz cuadrada del n\u00famero indicado.</li> <li><code>Math.abs(number)</code>. Retorna el valor absoluto de un n\u00famero.</li> <li><code>Math.sin(radians)</code>. Retorna el seno de un \u00e1ngulo expresado en radianes.</li> <li><code>Math.cos(radians)</code>. Retorna el coseno de un \u00e1ngulo expresado en radianes.</li> <li><code>Math.min(values)</code>. Retorna el valor m\u00ednimo de una serie de valores.</li> <li><code>Math.max(values)</code>. Retorna el valor m\u00e1ximo de una serie de valores.</li> </ul> <p>Info</p> <p>Descubre m\u00e1s m\u00e9todos de la clase <code>Math</code>: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math</p>"},{"location":"bloque_i/tema_4/page-3/#redondeo","title":"Redondeo","text":"<p>La clase <code>Math</code> contiene, adem\u00e1s, una serie de m\u00e9todos para poder redondear n\u00fameros.</p> <ul> <li><code>Math.floor(number)</code>. Redondea hacia abajo, por lo que el n\u00famero <code>3.1</code> se convierte en <code>3</code> y <code>-1.1</code> se convierte en <code>-2</code>.</li> <li><code>Math.ceil(number)</code>. Redondea hacia arriba, as\u00ed el n\u00famero <code>3.1</code> se convierte en <code>4</code> y <code>-1.1</code> se convierte en <code>-1</code>.</li> <li><code>Math.round(number)</code>. Redondea hacia el valor m\u00e1s cercano, de esa manera <code>3.1</code> redondea a <code>3</code> y <code>3.6</code> redondea a <code>4</code>.</li> <li><code>Math.trunc(number)</code>. Elimina la parte decimal del n\u00famero, qued\u00e1ndose con la parte entera. As\u00ed, el n\u00famero <code>3.6</code> es <code>3</code>, y <code>-1.1</code> es 1.</li> </ul> <p>Estos m\u00e9todos sirven para redondear hasta la parte entera, no sirven para redondear en posiciones decimales. Para poder redondear a una d\u00e9cima espec\u00edfica podemos seguir dos formas:</p> <ul> <li> <p>Multiplicando y dividiendo. Para redondear un n\u00famero a una d\u00e9cima <code>n</code> espec\u00edfica, se multiplica el n\u00famero por <code>1</code> seguido de tantos ceros como d\u00e9cimas se quiere redondear. Una vez redondeado, se vuelve a dividir por el mismo n\u00famero. Por ejemplo, si se desea redondear un n\u00famero decimal a dos d\u00e9cimas, se multiplicar\u00eda y dividir\u00eda por 100:</p> <pre><code>const number = 1.23456\nconst mult = number * 100 // 123.456\nconst round = Math.round(mult) // 123\nconst div = round / 100 // 1.23\nconsole.log(Math.round(number * 100) / 100) // 1.23\n</code></pre> </li> <li> <p>Haciendo uso del m\u00e9todo <code>toFixed(n)</code> del object wrapper <code>Number</code>, siendo <code>n</code> el n\u00famero de d\u00e9cimas a mostrar (si no se usa redondea a la parte entera). Es similar al m\u00e9todo <code>Math.round()</code>. El problema de este m\u00e9todo, es que no solo redondea el n\u00famero, si no que retorna dicho n\u00famero como una cadena. Por lo que habr\u00eda que usar alguna forma de conversi\u00f3n vista en el Tema 2 para poder ser usada como n\u00famero:</p> <pre><code>let num = 12.35\nconsole.log(+num.toFixed(1)) // 12.4\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_4/page-3/#comprobacion","title":"Comprobaci\u00f3n","text":"<p>El m\u00e9todo <code>isFinite</code> convierte su argumento a n\u00famero y comprueba si dicho n\u00famero es un n\u00famero regular, es decir, no es <code>Infinity</code>, ni <code>-Infinity</code>, ni <code>NaN</code>.</p> <pre><code>console.log(isFinite(\"15\")) // true\nconsole.log(isFinite(\"str\")) // false // (1)!\nconsole.log(isFinite(Infinity)) // false\n</code></pre> <ol> <li>La conversi\u00f3n de <code>str</code> a n\u00famero da como resultado <code>NaN</code>.</li> </ol> <p>El m\u00e9todo <code>isNaN</code> convierte su argumento a n\u00famero y comprueba si el resultado es <code>NaN</code>:</p> <pre><code>console.log(isNaN(NaN)) // true\nconsole.log(isNaN(\"str\")) // true\n</code></pre> <p>Warning</p> <p>El valor <code>NaN</code> es el \u00fanico que al comparar con cualquier otro valor, siempre devuelve <code>false</code>, incluy\u00e9ndose a \u00e9l mismo. Por eso, no se podr\u00eda hacer lo siguiente:</p> <pre><code>if(NaN === NaN) {} // false\n</code></pre>"},{"location":"bloque_i/tema_4/page-3/#numero-aleatorio","title":"N\u00famero aleatorio","text":"<p>La funci\u00f3n <code>Math.random()</code> retorna un n\u00famero aleatorio comprendido entre 0 y 1. Si se desea obtener un n\u00famero mayor, se recomienda multiplicar el valor por el l\u00edmite deseado. Por ejemplo, si se desea obtener un n\u00famero aleatorio entre 0 y 10, se recomienda multiplicar por 10.</p> <pre><code>console.log(Math.random())\nconsole.log(Math.random() * 2)\nconsole.log(Math.random() * 10)\nconsole.log(Math.random() * 100)\n</code></pre> <p>Estos m\u00e9todos devuelve un n\u00famero decimal, si se desea obtener un n\u00famero entero, se puede usar los m\u00e9todos de redondeo vistos en los apartados anteriores.</p> <p>En ciertas ocasiones se desea obtener un valor comprendido entre dos valores, como por ejemplo, entre 10 y 20. Para ello se puede multiplicar el n\u00famero aleatorio multiplicado por la resta entre el l\u00edmite m\u00e1ximo y m\u00ednimo a\u00f1adido a una unidad, posteriormente sum\u00e1ndole el valor m\u00ednimo al resultado. La formula quedar\u00eda as\u00ed:</p> <pre><code>Math.random() * (max - min + 1) + min\n</code></pre> <p>Incluso, se puede obviar los decimales:</p> <pre><code>Math.floor(Math.random() * (max - min + 1) +  min)\n</code></pre> <p>Veamos un ejemplo:</p> <pre><code>const randomNumberBetween10And20 = Math.floor(Math.random() * 11 + 10) // 20 - 10 + 1\n</code></pre>"},{"location":"bloque_i/tema_4/page-3/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Crea un programa Javascript que solicite varios n\u00fameros, hasta que cancele la petici\u00f3n. Luego muestra, el n\u00famero m\u00e1s peque\u00f1o y el n\u00famero m\u00e1s grande. Crea dos versiones, una sin usar los m\u00e9todos <code>Math.min</code> y <code>Math.max</code> creando tus propios m\u00e9todos, y otra haciendo uso de dichas funciones. Compara los resultados</p> Ejercicio 2 <p>Crea un programa Javascript que solicite al usuario una figura entre las siguientes: Cuadrado, Tri\u00e1ngulo, Rect\u00e1ngulo, C\u00edrculo. Al elegir una de ellas, se le solicitar\u00e1, adem\u00e1s, los datos necesarios para calcular el \u00e1rea de la figura deseada. Muestra en una alerta, el \u00e1rea redondeada en dos decimales. Si el usuario introduce una figura no v\u00e1lida, se le volver\u00e1 a solicitar hasta que introduzca una figura v\u00e1lida. Adem\u00e1s, realiza las comprobaciones pertinentes.</p> <p>Para estos ejercicios se va a crear un fichero llamado <code>numbers.js</code>. En ellos, se va a crear las diferentes funciones indicadas a continuaci\u00f3n. Posteriormente, se va a crear otro script para realizar las pruebas pertinentes a mano alzada.</p> Method 1 <p>Crea una funci\u00f3n que que dado dos par\u00e1metros, devuelva un n\u00famero aleatorio entre ambos.</p> Method 2 <p>Crea una funci\u00f3n que reciba un n\u00famero y devuelva el n\u00famero redondeado con el n\u00famero de d\u00e9cimas indicada. Si recibe un cero, redondea a la parte entera. El m\u00e9todo puede no recibir ning\u00fan par\u00e1metro, en dicho caso el valor del n\u00famero ha recibir ser\u00eda 0.</p> Method 3 <p>Crea una funci\u00f3n que reciba un n\u00famero y devuelva el n\u00famero truncado con el n\u00famero de d\u00e9cimas indicada. Si recibe un cero, trunca a la parte entera. El m\u00e9todo puede no recibir ning\u00fan par\u00e1metro, en dicho caso el valor del n\u00famero ha recibir ser\u00eda 0.</p> Method 4 <p>\u00bfSab\u00edas que un ra\u00edz cuadrada se puede expresar como una potencia? Por ejemplo, la ra\u00edz cuadrada de 4, se puede expresar como 4\u00bd. Al igual que la ra\u00edz cuadrada, cualquier ra\u00edz puede ser expresada como potencia, de esta forma, la ra\u00edz cuarta de 16, se puede expresar como 16\u00bc. Sabiendo esto, crea un m\u00e9todo que reciba dos n\u00fameros, la base y el tipo de ra\u00edz a calcular, y haz que devuelva la ra\u00edz en\u00e9sima a calcular.</p>"},{"location":"bloque_i/tema_4/page-4/","title":"4 Cadenas","text":""},{"location":"bloque_i/tema_4/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos visto en el tema 2 una cadena es un conjunto de caracteres que se pueden formar de tres maneras:</p> <ul> <li>Comillas simples.</li> <li>Comillas dobles.</li> <li>Comillas invertidas (backticks)</li> </ul> <p>Adem\u00e1s, las comillas invertidas nos permit\u00edan evaluar expresiones haciendo uso de la estructura <code>${}</code>:</p> <pre><code>console.log(`El resultado de 2 + 2 es ${2 + 2}`)\n</code></pre> <p>Otra de las ventajas que tiene este tipo de comillas, es que te permite crear cadenas de multiple l\u00edneas, cosa que con el otro tipo de cadenas se debe usar el car\u00e1cter <code>\\n</code>:</p> <pre><code>const stringMultiline = `Esto es un cadena\nmulti l\u00ednea`\nconst stringError = \"Esto no es una cadena multi l\u00ednea \ny adem\u00e1s da error\"\nconst string = \"Esto es una cadena multi l\u00ednea\\nsin errores usando el car\u00e1cter \\\\n\"  </code></pre>"},{"location":"bloque_i/tema_4/page-4/#caracteres-especiales","title":"Caracteres especiales","text":"<p>Existe una serie de caracteres especiales que al escribirlas en una cadena, mostrar\u00e1 algo diferente entre ellas, podemos encontrar:</p> Car\u00e1cter Descripci\u00f3n <code>\\n</code> Salto de l\u00ednea <code>\\r</code> En Windows, los archivos de texto usan una combinaci\u00f3n de dos caracteres \\r\\n para representar un corte de l\u00ednea, mientras que en otros SO es simplemente '\\n'. Esto es por razones hist\u00f3ricas, la mayor\u00eda del software para Windows tambi\u00e9n reconoce '\\n'. <code>\\'</code> <code>\\\"</code> <code>\\`</code> Comillas <code>\\\\</code> Barra invertida <code>\\t</code> Tabulaci\u00f3n <code>\\b</code>, <code>\\f</code>, <code>\\v</code> Retroceso, avance de formulario, tabulaci\u00f3n vertical \u2013 Se mencionan para ser exhaustivos. Vienen de muy viejos tiempos y no se usan actualmente. <p>Veamos un ejemplo:</p> <pre><code>console.log(\"Esto es una cadena que usa:\\n\\t- Comillas simples: \\'\\n\\t- Comillas dobles:\\\"\\n\\t- Comillas invertidas: \\`\\n\\t- Barra invertida:\\\\\") //(1)!\n</code></pre> <ol> <li>SALIDA:Esto es una cadena que usa:    - Comillas simples: '    - Comillas dobles: \"    - Comillas invertidas: `    - Barra invertida: \\ */</li> </ol> <p>Si se desea usar la forma literal de algunos de estos caracteres ser\u00e1 necesario hacer uso de un doble uso de la barra invertida <code>\\\\</code>. Veamos un ejemplo:</p> <pre><code>console.log(`\nEn Javascript, para hacer un salto de l\u00ednea es necesario usar \\\\n. Mientras que,\npara hacer una tabulaci\u00f3n es necesario hacer uso del \\\\t, al igual que con las comillas (\\\\' \\\\\")\n`)\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#tamano-de-string","title":"Tama\u00f1o de string","text":"<p>El tipo <code>string</code> tiene diferentes m\u00e9todos y propiedades que nos permite tratar con las cadenas de una forma m\u00e1s sencilla. Entre ellas, encontramos la propiedad <code>length</code> que permite obtener el tama\u00f1o de la cadena.</p> <pre><code>const string = 'Hello world'\nconst stringLength = string.length // 11\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#acceder-a-caracteres","title":"Acceder a caracteres","text":"<p>Para poder acceder a una car\u00e1cter espec\u00edfico de una cadena, es necesario conocer su posici\u00f3n. Debemos tener en cuenta, que la posici\u00f3n dentro de la cadena de caracteres empieza en 0, por lo que el primer car\u00e1cter tendr\u00e1 una posici\u00f3n 0. Al ser la primera posici\u00f3n 0, la \u00faltima posici\u00f3n ser\u00e1 un valor inferior al tama\u00f1o de la cadena <code>str.length - 1</code>.</p> <p>Para acceder a un car\u00e1cter de una cadena conociendo su posici\u00f3n, podemos usar corchetes <code>[pos]</code> o el m\u00e9todo <code>at(pos)</code>:</p> <pre><code>const string = \"Hello World\"\nconsole.log(string[0]) //H\nconsole.log(string[string.length - 1]) // d\nconsole.log(string[2]) // l\nconsole.log(string[11]) // undefined\nconsole.log(string[12]) // undefined\n</code></pre> <p>Una de las gran diferencias al usar corchetes o el m\u00e9todo <code>at</code>, es que si a los corchetes se le indica un n\u00famero negativo, siempre devuelve un <code>undefined</code>. Por el contrario, el m\u00e9todo <code>at()</code> con una posici\u00f3n negativa devuelve el car\u00e1cter empezando a leer la cadena a la inversa:</p> <pre><code>console.log(string[-1]) // undefined\nconsole.log(string.at(-1)) // d\nconsole.log(string.at(-11)) //H\nconsole.log(string.at(-12)) // undefined\n</code></pre> <p>String inmutables</p> <p>Las cadenas son INMUTABLES por lo que no se puede reasignar un nuevo valor a sus caracteres. Para cambiar el valor de un car\u00e1cter, ser\u00e1 necesario crear una nueva cadena.</p> <pre><code>const string = \"Hello World\"\nstring[0] = 'A' // \u274c\u274cERROR\nconst newString =  'A' + string[1] + string[2] + string[3] //... \n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#capitalizacion","title":"Capitalizaci\u00f3n","text":"<p>Los m\u00e9todos para trabajar con la capitalizaci\u00f3n de cadenas son:</p> <ul> <li><code>toLowerCase()</code>: Transforma la cadena en min\u00fasculas.</li> <li><code>toUpperCase()</code>: Transforma la cadena en may\u00fasculas.</li> </ul> <pre><code>const string = \"Hello World\"\nconsole.log(string.toUpperCase()) // HELLO WORLD\nconsole.log(string.toLowerCase()) // hello world\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#localizar-caracteres-en-cadenas","title":"Localizar caracteres en cadenas","text":"<p>Existen diversos m\u00e9todos para poder comprobar y localizar caracteres dentro de una cadena, como <code>indexOf</code>, <code>lastIndexOf</code>, <code>includes</code>, <code>startsWith</code>, <code>endsWith</code>.</p>"},{"location":"bloque_i/tema_4/page-4/#indexof","title":"indexOf","text":"<p>El m\u00e9todo <code>indexOf(c)</code> comprueba si el car\u00e1cter <code>c</code> se encuentra en la cadena y retorna la primera posici\u00f3n en la que se encuentra. Por el contrario, retornar\u00e1 <code>-1</code>, si el car\u00e1cter no se encuentra en la cadena. Veamos un ejemplo:</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.indexOf('e')) // 1\n</code></pre> <p>En caso de haber m\u00e1s de una coincidencia, retornar\u00e1 el valor de la primera coincidencia, ya que empieza a realizar la b\u00fasqueda desde el primer car\u00e1cter.</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.indexOf('o')) // 4\n</code></pre> <p>El m\u00e9todo <code>indexOf(c, [i])</code>, puede recibir un segundo par\u00e1metro que indica a partir de que posici\u00f3n buscar el car\u00e1cter. De esta manera, podemos localizar la siguientes referencias de un car\u00e1cter:</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.indexOf('o', 5)) // 7\n</code></pre> <p>Tambi\u00e9n podemos localizar una subcadena dentro de la cadena, retornando la primera posici\u00f3n del primer car\u00e1cter de la misma:</p> <pre><code>const string = \"This is a large string\"\nconsole.log(string.indexOf(\"string\")) // 16\n</code></pre> <p>En el ejemplo anterior, retornar\u00e1 <code>16</code> porque la subcadena string comienza en el car\u00e1cter 16 de la cadena principal. De esta manera podemos hacer comprobaciones de si una cadena contiene una subcadena:</p> <pre><code>const string = \"This is a large string\"\nif(string.indexOf(\"This\") &gt; -1){\nconsole.log(`La cadena ${string} contiene la cadena \"this\"`)\n}\n</code></pre> <p>\u00a1OJO!</p> <p>En el ejemplo anterior hay que tener mucho cuidado, si hacemos la comprobaci\u00f3n si la comparaci\u00f3n, ya que si el m\u00e9todo retorna <code>0</code>, quiere decir que la cadena si existe, pero al usarlo en el condicional se convertir\u00e1 a booleano (recuerda que 0 en booleano es <code>false</code>) por lo que no entrar\u00eda en el bloque <code>if</code>. Por el contrario, si no encuentra la cadena, el m\u00e9todo retorna un <code>-1</code>, que al pasarlo a booleano es <code>true</code>, por lo que si ejecutar\u00eda el bloque <code>if</code>:</p> <pre><code>const string = \"This is a large string\"\nif(string.indexOf(\"This\")){\nconsole.log(`La cadena ${string} contiene la cadena \"this\"`)\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#lastindexof","title":"lastIndexOf","text":"<p>El m\u00e9todo <code>lastIndexOf(c, [pos])</code> es un m\u00e9todo bastante similar a <code>indexOf</code>, con la diferencia de que en este caso, la b\u00fasqueda comienza a hacerla desde el final de la cadena, por lo que retorna el \u00faltimo valor que parece en la cadena. Veamos un ejemplo:</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.lastIndexOf(\"o\")) // 7\nconsole.log(string.lastIndexOf(\"o\", 5)) // 4\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#includes","title":"includes","text":"<p>El m\u00e9todo <code>includes(c)</code> retornar\u00e1 <code>true</code> si <code>c</code> se encuentra en la cadena. Por el contrario retornar\u00e1 <code>false</code>. Puede recibir un segundo argumento para indicar desde que posici\u00f3n realizar la comprobaci\u00f3n.</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.includes(\"Hello\")) // true\nconsole.log(string.includes(\"no\")) // false\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#startswith","title":"startsWith","text":"<p>El m\u00e9todo <code>startsWith(c)</code> comprueba si la cadena empieza con los caracteres indicados. Retorna <code>true</code> si comienza con dicho car\u00e1cter (o caracteres) y <code>false</code> al contrario.</p> <pre><code>console.log('Hello world'.startsWith('Hello')) // true\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#endswith","title":"endsWith","text":"<p>El m\u00e9todo <code>endsWith(c)</code> comprueba si la cadena termina con los caracteres indicados. Retorna <code>true</code> si termina con dicho car\u00e1cter (o caracteres) y <code>false</code> al contrario.</p> <pre><code>console.log('Hello world'.endsWith('world')) // true\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#obtener-subcadenas","title":"Obtener subcadenas","text":"<p>El tipo <code>string</code> nos ofrece varios m\u00e9todos para obtener una subcadena dada una cadena: <code>substring</code>, <code>substr</code> y <code>slice</code>.</p>"},{"location":"bloque_i/tema_4/page-4/#slice","title":"slice","text":"<p>El m\u00e9todo <code>slice(start, [end])</code> retorna una subcadena desde la posici\u00f3n indicado (<code>start</code>) hasta la posici\u00f3n final (<code>end</code>) (no incluido). Si no se indica posici\u00f3n final, recortar\u00e1 hasta el final de la cadena.</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.slice(0, 5)) // Hello\nconsole.log(string.slice(6)) // world\n</code></pre> <p>Se pueden usar valores negativos, para comenzar a cortar desde el final.:</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.slice(-11, -5)) // Hello\n</code></pre> <p>Si se intercambian las posiciones, es decir, si se indica primero la posici\u00f3n mayor que la posici\u00f3n menor, el m\u00e9todo <code>slice</code> retorna una cadena vac\u00eda.</p> <pre><code>console.log(\"Hello world\".slice(2, 1)) // \"\"\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#substring","title":"substring","text":"<p>El m\u00e9todo <code>substring(start, [end])</code> es bastante similar al m\u00e9todo <code>slice</code>, pero en este caso, si se usa una posici\u00f3n mayor y luego una menor, este m\u00e9todo lo intercambiar\u00e1. Sin embargo, no se pueden usar argumentos negativos, ya que son tratados como 0.</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.substring(0, 5)) // Hello\nconsole.log(string.substring(6)) // world\nconsole.log(string.substring(-10, -5)) // \"\"\nconsole.log(string.substring(-10, 5)) // Hello (similar a (0, 5))\nconsole.log(string.substring(2, 1)) // e\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#substr","title":"substr","text":"<p>El m\u00e9todo <code>substr(start, [length])</code> recorta una cadena desde la posici\u00f3n inicial indicada, tantos caracteres como indica el segundo argumento (<code>length</code>), a diferente de los otros m\u00e9todos que se indicaba la posici\u00f3n final. El argumento del tama\u00f1o, no puede ser negativo</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.substr(3, 5)) // lo wo\nconsole.log(string.substr(0, 5)) // Hello\nconsole.log(string.substr(6)) // world\nconsole.log(string.substr(-10, -5)) // \"\"\nconsole.log(string.substr(-10, 5)) // ello\nconsole.log(string.substr(2, 1)) //  l \n</code></pre> <p>Warning</p> <p>Este m\u00e9todo ha sido indicado como <code>deprecated</code> en las versiones recientes de Javascript, por lo que no se recomienda su uso.</p>"},{"location":"bloque_i/tema_4/page-4/#comparacion","title":"Comparaci\u00f3n","text":"<p>Para poder comparar cadenas en Javascript se realiza la comparaci\u00f3n, car\u00e1cter a car\u00e1cter. Cada car\u00e1cter tiene un representaci\u00f3n de codificaci\u00f3n (en Javascript las cadenas est\u00e1n representadas por la codificaci\u00f3n <code>UTF-16</code>), por lo que para comparar los caracteres, ser\u00e1 mayor el que mayor codificaci\u00f3n tenga. Veamos un ejemplo:</p> <pre><code>console.log('a' &gt; 'Z') // tur\n</code></pre> <p>A pesar, de que la <code>a</code> aparezca antes en el abecedario, su codificaci\u00f3n corresponde a 97, mientras que la <code>Z</code> a la 90, por lo que ciertamente <code>a</code> es mayor que <code>Z</code>. Lo mismo puede ocurrir con los acentos.</p> <p>Con el m\u00e9todo <code>codePointAt(pos)</code> retorna el valor codificado del car\u00e1cter posicionado en la cadena. Si no se indica posici\u00f3n, retornar\u00e1 el valor codificado del primer car\u00e1cter:</p> <pre><code>console.log('a'.codePointAt(0)) // 97\nconsole.log('Z'.codePointAt()) // 90\nconsole.log('Hello World'.codePointAt(5)) // 32\n</code></pre> <p>Por el contrario, podemos obtener el car\u00e1cter que representa un c\u00f3digo a trav\u00e9s del m\u00e9todo est\u00e1tico <code>String.fromCodePoint(code)</code>:</p> <pre><code>console.log(String.fromCodePoint(97)) // a\n</code></pre> <p>El algoritmo correcto para realizar comparaciones de strings es m\u00e1s complejo de lo que parece, debido a que los alfabetos son diferentes para diferentes lenguajes. Una letra que se ve igual en dos alfabetos distintos, pueden tener distintas posiciones. Para ello existe el m\u00e9todo <code>localeCompare(string, [locales, options])</code> que permite comparar cadenas teniendo en cuenta el alfabeto del idioma especificado. Sus argumentos son:</p> <ul> <li><code>string</code>. Cadena para comparar.</li> <li><code>locales</code>. Idioma al comparar. En caso de ser especificado, obtiene el idioma del entorno.</li> <li><code>options</code>. Un objeto con las configuraciones previas, como la sensibilidad a la may\u00fasculas.</li> </ul> <p>El m\u00e9todo, adem\u00e1s, retornar\u00e1:</p> <ul> <li><code>1</code> si la primera cadena es mayor que la segunda.</li> <li><code>-1</code> si la segunda cadena es mayor que la primera.</li> <li><code>0</code> si ambas son iguales.</li> </ul> <pre><code>console.log(\"Hola mundo\".localeCompare(\"Hello world\", \"es\")) // 1\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#ejercicios","title":"Ejercicios","text":"<p>Para estos ejercicios se va a crear un fichero llamado strings.js. En ellos, se va a crear las diferentes funciones indicadas a continuaci\u00f3n. Posteriormente, se va a crear otro script para realizar las pruebas pertinentes a mano alzada.</p> Method 1 <p>Crea un m\u00e9todo llamado <code>capitalize(string, [onlyFirst = true])</code>, que transforme la cadena obtenida como argumento a capitalizada. Una cadena es capitalizada, indicando la primera palabra en may\u00fasculas. Por ejemplo: <code>'Hello world'</code>. Recibir\u00e1 un segundo argumento booleano para comprobar si se hace una capitalizaci\u00f3n en cada palabra. Por ejemplo, <code>Hello World</code>. En caso de no recibir este par\u00e1metro solo capitalizar\u00e1 la primera letra.</p> Method 2 <p>Crea una funci\u00f3n <code>truncate(str, maxlength, [ellipsis = '...'])</code> que verifique la longitud de <code>str</code> y, si excede <code>maxlength</code>  reemplaza el final de <code>str</code> con el car\u00e1cter indicado como tercer argumento que por defecto ser\u00e1 puntos suspensivos, para hacer su longitud igual a <code>maxlength</code>.</p> <pre><code>truncate(\"Lo que me gustar\u00eda contar sobre este tema es:\", 20) //\"Lo que me gustar\u00eda c\u2026\"\ntruncate(\"Hola a todos!\", 20) // \"Hola a todos!\"\n</code></pre> Method 3 <p>Crea una funci\u00f3n <code>jump(string, maxLength)</code> que inserte saltos de l\u00ednea cada vez que la cadena llegue a <code>maxLength</code>.</p> <pre><code>jump(\"hola mundo esto es una cadena super larga con muchos saltos de l\u00ednea\", 5)\n/*\nhola \nmundo\n esto\nes un\na cad\nena s\nuper \nlarga\n con \nmucho\nsalto\ns de \nl\u00ednea\n*/\n</code></pre> Method 4 <p>Crea dos funciones, <code>isEmpty(string)</code> e <code>isNotEmpty(string)</code>, que compruebe si <code>string</code> es una cadena vac\u00eda o no, respectivamente.</p> Method 5 <p>Crea dos funciones, <code>isBlank(string)</code> e <code>isNotBlank(string)</code> que comprueba si <code>string</code> es una cadena vac\u00eda o con espacios en blanco; o no, respectivamente.</p> Method 6 <p>Realiza un m\u00e9todo <code>isPalindrome(string)</code> que comprueba si la cadena <code>string</code> es pal\u00edndroma, es decir, se puede leer de igual forma de izquierda a derecha que derecha a izquierda (sin tener en cuenta los espacios ni las comas o puntos.).</p>"},{"location":"bloque_i/tema_4/page-5/","title":"5 Expresiones de una funci\u00f3n","text":""},{"location":"bloque_i/tema_4/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>En muchos lenguajes de programaci\u00f3n, como Java, una funci\u00f3n no es m\u00e1s que es una estructura de c\u00f3digo reutilizable. Sin embargo, en Javascript las funciones son m\u00e1s que estructuras, son consideradas como un tipo de dato especial, al igual que los n\u00fameros o las cadenas.</p> <p>Por lo que, al igual que las cadenas o los n\u00fameros, podemos declarar una funci\u00f3n como si fuese una variable o una constante:</p> <pre><code>const sayHi = function(){\nconsole.log('hi')\n}\n</code></pre> <p>La sintaxis <code>function(){}</code> se denomina funci\u00f3n an\u00f3nima, es decir, se crea una funci\u00f3n sin nombre que luego se le asigna a una variable. Para llamar dicha funci\u00f3n, se usa el nombre de la variable a la que le ha sido asignada:</p> <pre><code>sayHi()\n</code></pre>"},{"location":"bloque_i/tema_4/page-5/#funcion-como-valor","title":"Funci\u00f3n como valor","text":"<p>En Javascript una funci\u00f3n puede funcionar como un valor. Si mostramos por consola una funci\u00f3n (sin realizar su llamada), mostrar\u00e1 el contenido de la funci\u00f3n:</p> <pre><code>const sayHi = function(){\nconsole.log('Hi')\n}\nconsole.log(sayHi)\n</code></pre> <p>Al usar una funci\u00f3n como valor, podemos reutilizarla en varias variables, de esta manera:</p> <pre><code>function myFunction(){ //(1)!\nconsole.log(\"Hi\") }\nconst sayHi = myFunction //(2)!\nmyFunction() //(3)!\nsayHi() //(4)!\n</code></pre> <ol> <li>Se crea una funci\u00f3n</li> <li>Se copia el valor de la funci\u00f3n <code>myFunction</code> en <code>sayHi</code></li> <li>Se ejecuta <code>myFunction</code></li> <li>Se ejecuta <code>sayHi</code></li> </ol>"},{"location":"bloque_i/tema_4/page-5/#callback","title":"Callback","text":"<p>En JavaScript, un callback es una funci\u00f3n que se pasa como argumento a otra funci\u00f3n y que se ejecuta despu\u00e9s de que ocurra alg\u00fan evento o proceso as\u00edncrono. Los callbacks son una forma fundamental de manejar la asincron\u00eda en JavaScript, ya que JavaScript es un lenguaje de programaci\u00f3n de un solo hilo que utiliza eventos y callbacks para manejar tareas as\u00edncronas.</p> <p>Supongamos que queremos crear una funci\u00f3n que realice una pregunta de S\u00ed/No. Si la respuesta es S\u00ed ejecutar\u00e1 una funci\u00f3n, y si la respuesta es No ejecutar\u00e1 otra. Esta funci\u00f3n puede ser m\u00e1s flexible si se le pasase que hacer en cada uno de los dos casos, y esto es posible gracias a los callbacks. Veamos un ejemplo:</p> <pre><code>function ask(question, yes, ok){\nif(confirm(question)){\nyes()\n} else {\nno()\n}\n}\nfunction ok(){\nconsole.log('Est\u00e1s de acuerdo')\n}\nfunction cancel(){\nconsole.log('Cancelaste')\n}\nask(\"\u00bfEst\u00e1s de acuerdo?\", ok, cancel)\n</code></pre> <p>En el ejemplo anterior, le pasamos al m\u00e9todo <code>ask</code> los valores de las funciones <code>ok</code> y <code>cancel</code> para que sean ejecutadas. De esta forma, la funci\u00f3n <code>ask</code> es una funci\u00f3n flexible a cualquier acci\u00f3n en caso de confirmar o cancelar la petici\u00f3n del m\u00e9todo <code>confirm</code>.</p>"},{"location":"bloque_i/tema_4/page-5/#crear-funciones-de-forma-dinamica","title":"Crear funciones de forma din\u00e1mica","text":"<p>Una funci\u00f3n al ser tratada como un valor, puede ser creada din\u00e1micamente de forma que pueda realizar una operaci\u00f3n u otra. Supongamos que dependiendo de la edad del usuario vamos a realizar un c\u00e1lculo u otro, en esa se estar\u00eda creando una funci\u00f3n de forma din\u00e1mica. Veamos un ejemplo:</p> <pre><code>const age = 18\nconst func = age &gt; 18 ? function() {\n// Code\nconsole.log('Eres mayor de edad')\n}\n: function() {\n// code\nconsole.log('Eres menor de edad')\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-5/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza un m\u00e9todo que reciba un n\u00famero y una funci\u00f3n que solo ser\u00e1 ejecuta si el n\u00famero indicado es par. </p>"},{"location":"bloque_i/tema_4/page-6/","title":"6 Funciones Flecha","text":""},{"location":"bloque_i/tema_4/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Las funciones flecha en JavaScript son una caracter\u00edstica introducida en ECMAScript 6 (tambi\u00e9n conocido como ES6 o ES2015) que proporciona una sintaxis m\u00e1s concisa y clara para definir funciones. La sintaxis de una funci\u00f3n flecha se parece a una flecha <code>=&gt;</code>, de ah\u00ed su nombre.</p>"},{"location":"bloque_i/tema_4/page-6/#expresion-de-una-funcion-flecha","title":"Expresi\u00f3n de una funci\u00f3n flecha","text":"<p>Una funci\u00f3n flecha, no es m\u00e1s que una funci\u00f3n an\u00f3nima que puede ser introducida en una variable. Por lo que si la expresi\u00f3n de una funci\u00f3n an\u00f3nima es:</p> <pre><code>const func = function(args){\n// code\nreturn value\n}\n</code></pre> <p>La funci\u00f3n flecha es muy parecida, pero m\u00e1s compacta. En primer lugar, no es necesario usar la palabra <code>function</code> y se usa una flecha (<code>=&gt;</code>) entre la declaraci\u00f3n de los par\u00e1metros y el bloque:</p> <pre><code>const func = (args) =&gt; {\n// code\nreturn value\n}\n</code></pre> <p>Veamos un ejemplo para realizar la suma de dos n\u00fameros:</p> <pre><code>const suma = (a, b) =&gt; {\nreturn a + b\n}\n</code></pre> <p>Cuando el cuerpo (bloque) de una funci\u00f3n flecha solo tiene una l\u00ednea y est\u00e1 es una expresi\u00f3n de retorno, la funci\u00f3n de flecha se puede omitir las llaves <code>{}</code> y la palabra <code>return</code>:</p> <pre><code>const func = () =&gt; value\n</code></pre> <p>De esta manera, el ejemplo anterior se podr\u00eda simplificar de la siguiente forma:</p> <pre><code>const suma (a, b) =&gt; a + b\n</code></pre> <p>De la misma manera, si una funci\u00f3n flecha solo recibe un argumento, tambi\u00e9n puede obviar los par\u00e9ntesis:</p> <pre><code>const func = onlyParam =&gt; {\n// code\nreturn something\n}\n</code></pre> <p>Por ejemplo, si tenemos un m\u00e9todo que recibe un n\u00famero para calcular si es primo o no:</p> <pre><code>const prime = number =&gt; {\nfor(let i = 2; &lt; i &lt; number; i++){\nif(number % i === 0) return false\n}\nreturn true\n}\n</code></pre> <p>Por el contrario, si no recibe ning\u00fan par\u00e1metro, si es obligatorio el uso de par\u00e9ntesis:</p> <pre><code>const sayHi = () =&gt; {\nconsole.log('Hi!')\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-6/#funciones-flechas-dinamicas","title":"Funciones flechas din\u00e1micas","text":"<p>Al igual que las funciones an\u00f3nimas, se puede pasar una funci\u00f3n flecha como valor de una variable de forma din\u00e1mica:</p> <pre><code>const age = 18\nconst func = age &gt; 18 ? () =&gt; {\n// Code\nconsole.log('Eres mayor de edad')\n}\n: () =&gt; {\n// code\nconsole.log('Eres menor de edad')\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-6/#funciones-flechas-como-callbacks","title":"Funciones flechas como callbacks","text":"<p>Las funciones flechas pueden ser usadas como argumentos en otras funciones que reciban un callback:</p> <pre><code>function connectServer(callback){\nconsole.log('creating server...')\nconst server = 'Server'\nconst success = Math.rand() * 10\nif(success !== 1){\nconsole.log('Error to connecting Server ' + server)\nreturn\n}\ncallback()\n}\nconnectServer(() =&gt; {\nconsole.log('Connected server successfully')\n})\n</code></pre> <p>Existe una sintaxis especial, que ocurre cuando el n\u00famero y tipo de par\u00e1metros necesarios por el callback y por la funci\u00f3n flecha sean los mismo, se puede omitir la estructura compacta y usar solo el nombre de la variable que referencia la funci\u00f3n flecha:</p> <pre><code>function connectServer(callback){\nconsole.log('creating server...')\nconst server = 'Server'\nconst success = Math.rand() * 10\nif(success !== 1){\nconsole.log('Error to connecting Server ' + server)\nreturn\n}\ncallback()\n}\nconst callback = () =&gt; {\nconsole.log('Connected server successfully')\n}\nconnectServer(callback)\n</code></pre>"},{"location":"bloque_i/tema_4/page-6/#ejercicios","title":"Ejercicios","text":"<p>Realiza todos los ejercicios realizados hasta ahora con funciones de flechas. Las funciones realizadas en el fichero <code>numbers.js</code> y <code>strings.js</code> no ser\u00e1n reemplazadas, si no que usando Git se crear\u00e1 una nueva versi\u00f3n del proyecto.</p>"},{"location":"bloque_i/tema_x/page-1/","title":"1 Introducci\u00f3n a las expresiones regulares","text":""},{"location":"bloque_i/tema_x/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Una expresi\u00f3n regular es una secuencia de caracteres que forma un patr\u00f3n de b\u00fasqueda proporcionando una manera muy flexible de buscar o reemplazar cadenas de texto. En Javascript se encuentran disponibles a trav\u00e9s del objeto <code>RegExp</code>, y de algunos m\u00e9todos de cadenas.</p> <p>Una expresi\u00f3n regular debe constar de un patr\u00f3n de caracteres, que se buscar\u00e1 en la cadena, ya sea para devolverla o para reemplazarla. Adem\u00e1s, se le pueden indicar diferentes tipos de configuraci\u00f3n llamadas flags (banderas).</p> <p>Un patr\u00f3n puede ser una cadena exacta, o una secuencia de caracteres que ampl\u00ede las posibilidades. Por ejemplo:</p> <ul> <li>Hola mundo es patr\u00f3n exacto, por lo que se comprobar\u00e1 si la cadena a comprobar es exactamente la indicada.</li> <li>Empezar por un n\u00famero es un patr\u00f3n flexible, nos permite comprobar si la cadena empieza o no por n\u00famero, cualquiera de ellos (0-9).</li> </ul>"},{"location":"bloque_i/tema_x/page-1/#creacion-de-un-expresion-regular","title":"Creaci\u00f3n de un expresi\u00f3n regular","text":"<p>Para crear una expresi\u00f3n regular podemos usar el constructor de objetos de la clase <code>RegEx(pattern, [flags])</code>, que recibe dos par\u00e1metros: el patr\u00f3n a comprobar y las banderas (configuraciones) a aplicar.</p> <pre><code>const regex = new RegEx(pattern, flags)\n</code></pre> <p>Existe una forma m\u00e1s corta de crear una expresi\u00f3n regular, haciendo uso de las barras <code>/pattern/flags</code>:</p> <pre><code>const regex = /pattern/\nconst regexWithFlags = /pattern/flags\n</code></pre>"},{"location":"bloque_i/tema_x/page-1/#banderas","title":"Banderas","text":"<p>Como hemos anteriormente, una bandera (flag) es una configuraci\u00f3n que se aplica a la expresi\u00f3n regular a la hora de buscar en una cadena. En Javascript, existen 6 diferentes:</p> <ul> <li>Case insensitive (<code>i</code>). No distingue entre may\u00fasculas y min\u00fasculas.</li> <li>All coincidences (<code>g</code>). Encuentra todas las coincidencias que cumplan la expresi\u00f3n regular, por el contrario solo devuelve la primera coincidencia.</li> <li>Multiline (<code>m</code>). Modo multil\u00ednea (se desarrolla m\u00e1s adelante)</li> <li>Dotall (<code>s</code>). Permite que el punto, <code>.</code>, coincida con el car\u00e1cter de l\u00ednea nueva.</li> <li>Unicode support (<code>u</code>). Permite soporte completo a Unicode.</li> <li>Adhesive (<code>y</code>). Modo adhesivo, es decir, b\u00fasqueda en la posici\u00f3n exacta del texto.</li> </ul>"},{"location":"bloque_i/tema_x/page-1/#busqueda-en-cadenas","title":"B\u00fasqueda en cadenas","text":"<p>El m\u00e9todo <code>match(regEx)</code>, es un m\u00e9todo de cadena que comprueba si la cadena cumple con la expresi\u00f3n regular indicada. Puede funcionar de formas diferentes:</p> <ul> <li> <p>Si tiene un flag <code>g</code> devuelve un arreglo con todas las coincidencias.</p> <pre><code>const str = 'We will, we will rock you'\nconsole.log(str.match(/we/gi)) // [We, we]\n</code></pre> </li> <li> <p>Si no existe dicha flag, devolver\u00e1 un array cuya primera posici\u00f3n ser\u00e1 la coincidencia. Aunque puede contener m\u00e1s \u00edndices, el resto de \u00edndices ser\u00e1 tratados posteriormente. Adem\u00e1s, tiene propiedades informativas, como <code>index</code>, que devuelve el n\u00famero del \u00edndice que contiene la coincidencia, e <code>input</code> que devuelve la cadena en la cual se hace la b\u00fasqueda.</p> <pre><code>const str = 'We will, we will rock you'\nconst result = str.match(/we/i)\nconsole.log(result[0]) // We\nconsole.log(result.length) // 1\nconsole.log(result.index) // 0\nconsole.log(result.input) // We will, we will rock you\n</code></pre> </li> <li> <p>Si no existe coincidencia, se devolver\u00e1 un null.</p> <pre><code>const str = 'Javascript'\nconsole.log(str.match(/HTML/)) // null\n</code></pre> <p>Es importante recalcar, que no devuelve un array vac\u00edo, simplemente retorna un <code>null</code>. No entender esto, puede provocar errores como el siguiente:</p> <pre><code>const result = 'Javascript'.match(/HTML/)\nif(!result.length){ // (1)!\nconsole.log('ERROR')\n}\n</code></pre> <ol> <li>\u274c\u274cNo se puede leer la propiedad <code>length</code> de un <code>null</code>\u274c\u274c</li> </ol> <p>Una forma de evitar este error, es haciendo uso del operador <code>??</code></p> <pre><code>const result = 'Javascript'.match(/HTML/) ?? []\nif(!result.length){     console.log('ERROR')\n}\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_x/page-1/#reemplazar-en-cadenas","title":"Reemplazar en cadenas","text":"<p>El m\u00e9todo <code>replace(regex, replacement)</code> reemplaza las coincidencias encontradas de la expresi\u00f3n regular, por los valores indicados <code>replacement</code>. Por ejemplo:</p> <pre><code>console.log('We will, we will'.replace(/we/i, \"I\")) // I will, we will\nconsole.log('We will, we will'.replace(/we/ig, \"I\")) // I will, I will\n</code></pre> <p>El argumento replacement puede usar combinaciones especiales para poder insertar fragmentos en la coincidencia:</p> <ul> <li><code>$&amp;</code> - Inserta toda la coincidencia.</li> <li><code>$`</code> - Inserta una parte de la cadena antes de la coincidencia.</li> <li><code>$'</code> - Inserta una parte de la cadena despu\u00e9s de la coincidencia.</li> <li><code>$n</code> - Si <code>n</code> es un n\u00famero de 1 o 2 d\u00edgitos, entonces inserta el contenido de los par\u00e9ntesis n-\u00e9simo (desarrollado m\u00e1s adelante)</li> <li><code>$&lt;name&gt;</code> - Inserta el contenido de los par\u00e9ntesis con el nombre dado.</li> <li><code>$$</code> - Inserta el car\u00e1cter <code>$</code>.</li> </ul> <pre><code>console.log('Me gusta HTML'.replace(/HTML/, \"$&amp; y Javascript\")) // Me gusta HTML y Javascript\n</code></pre>"},{"location":"bloque_i/tema_x/page-1/#metodo-test","title":"M\u00e9todo test","text":"<p>El m\u00e9todo <code>test(str)</code> es un m\u00e9todo de la clase <code>RegEx</code> que comprueba si el patr\u00f3n aparece en la cadena, al menos una vez. Devuelve <code>true</code> si encuentra coincidencia, <code>false</code> por lo contrario.</p> <pre><code>const str = 'Me gusta Javascript'\nconst regEx = /gusta/i\nconsole.log(regEx.test(str)) // true\n</code></pre>"},{"location":"bloque_i/tema_x/page-2/","title":"2 Clases de caracteres","text":""},{"location":"bloque_i/tema_x/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Una clase de caracteres es una notaci\u00f3n especial que coincide con cualquier s\u00edmbolo de un determinado conjunto</p> <p>Entre las diferentes clases de caracteres, la m\u00e1s usadas son:</p> <ul> <li><code>\\d</code>. Representa un d\u00edgito, es decir, un car\u00e1cter de <code>0</code> a <code>9</code>.</li> <li><code>\\w</code>. Representa un car\u00e1cter de palabra, es decir, letra de alfabeto latino, un d\u00edgito, o un gui\u00f3n bajo (<code>_</code>). Las letras no latina no pertenecen a este conjunto.</li> <li><code>\\s</code>. Representa un espacio en blanco, incluyendo tabulaciones, l\u00edneas nuevas, etc.</li> </ul> <pre><code>const str = '+7(903)-123-45-67'\nconst regEx = /\\d/g\nconsole.log(str.match(regEx)) // [7, 9, 0, 3, 1, 2, 3, 4, 5, 6, 7]\n</code></pre> <p>Los conjuntos pueden ser usados individualmente o seguidos. Por ejemplo, la expresi\u00f3n <code>/\\d\\s\\w/i</code> indica que buscamos un n\u00famero seguido de un espacio seguido de un car\u00e1cter de palabra.</p>"},{"location":"bloque_i/tema_x/page-2/#inversas","title":"Inversas","text":"<p>Para cada clase de caracteres que hemos visto anteriormente, existe una clase inversa, indicada con la misma letra pero en may\u00fasculas y hace que coincida con el resto de caracteres que no cumple con el conjunto original:</p> <ul> <li><code>\\D</code>. Representa cualquier car\u00e1cter que no sea un d\u00edgito.</li> <li><code>\\W</code>. Representa cualquier car\u00e1cter que no sea un car\u00e1cter de palabra, como un car\u00e1cter no latino, o un espacio.</li> <li><code>\\S</code>. Representa cualquier car\u00e1cter que no sea un espacio.</li> </ul> <pre><code>const str = '+7(903)-123-45-67'\nconst regEx = /\\D/g\nconsole.log(str.replace(regEx, str)) // 79031234567\n</code></pre>"},{"location":"bloque_i/tema_x/page-2/#punto","title":"Punto","text":"<p>El patr\u00f3n punto (<code>.</code>) es una clase de caracteres especial que representa a cualquier car\u00e1cter excepto a una nueva l\u00ednea.</p> <pre><code>console.log(/./.test('Z')) // true\n</code></pre> <p>El punto, por defecto, no contempla el salto de l\u00ednea (<code>\\n</code>), por lo que la siguiente expresi\u00f3n va a dar null:</p> <pre><code>console.log('A\\nB'.match(/A.B/)) // null\n</code></pre> <p>Sin embargo, haciendo uso de la bandera <code>\\s</code>, hace que el punto contemple el salto de l\u00ednea como cualquier car\u00e1cter. De esta forma, el ejemplo anterior, ya tiene una coincidencia:</p> <pre><code>console.log('A\\nB'.match(/A.B/s)) // [A\\nB]\n</code></pre> <p>Warning</p> <p>Por lo general, se presta poco atenci\u00f3n a los espacios, se da por hecho que las cadenas <code>1-5</code> y <code>1 - 5</code> son id\u00e9nticas, cuando en realidad no lo son. A la hora de comprobar un patr\u00f3n sobre una cadena hay que tener en cuenta los espacios, ya que si no se les tiene en cuenta la comprobaci\u00f3n podr\u00eda fallar:</p> <pre><code>console.log('1 - 5'.match(/\\d-\\d/)) // null\n</code></pre>"},{"location":"bloque_i/tema_x/page-2/#unicode","title":"Unicode","text":"<p>Cada car\u00e1cter en Unicode tiene varias propiedades, es decir, describen a que categor\u00eda pertenece el car\u00e1cter y contienen informaci\u00f3n diversa al respecto. Por ejemplo, si un car\u00e1cter tiene la propiedad <code>Letter</code>, significa que pertenece a una alfabeto de cualquier idioma, o <code>Number</code> que significa que es un d\u00edgito.</p> <p>Se puede buscar caracteres teniendo en cuenta a la propiedad Unicode a la que pertenece, haciendo uso de <code>\\p{...}</code>. Para usar dicha expresi\u00f3n, es necesario usar la flag <code>u</code>. Por ejemplo, <code>p{Letter}</code> representa una letra en cualquier idioma. Tambi\u00e9n se puede usar <code>p{L}</code>:</p> <pre><code>const str = \"A \u10d1 \u3131\"\nconsole.log(str.match(/\\p{L}/gu)) // [A, \u10d1, \u3131]\nconsole.log(str.math(/\\p{L}/g)) // null\n</code></pre> <p>Haciendo uso de <code>\\P{...}</code> estaremos excluyendo los caracteres de la propiedad Unicode indicada. Por ejemplo, con <code>\\P{L}</code>, excluimos todas las letras de cualquier idioma.</p> <p>Las categor\u00edas de letras (<code>Letter</code> o <code>L</code>), son:</p> <ul> <li>lowercase (<code>Ll</code>)</li> <li>modifier (<code>Lm</code>)</li> <li>titlecase (<code>Lt</code>)</li> <li>uppercase (<code>Lu</code>)</li> <li>other (<code>Lo</code>)</li> </ul> <p>Las categor\u00edas de n\u00fameros (<code>Number</code> o <code>N</code>), son:</p> <ul> <li>D\u00edgito decimal <code>Nd</code></li> <li>Letter number <code>Nl</code></li> <li>other <code>No</code></li> </ul> <p>Otras categor\u00edas y subcategor\u00edas importantes:</p> <ul> <li>Punctuation (puntuaci\u00f3n) <code>P</code>:<ul> <li>connector (conector) <code>Pc</code>,</li> <li>dash (gui\u00f3n) <code>Pd</code>,</li> <li>initial quote (comilla inicial) <code>Pi</code>,</li> <li>final quote (comilla final) <code>Pf</code>,</li> <li>open (abre) <code>Ps</code>,</li> <li>close (cierra) <code>Pe</code>,</li> <li>other (otro) <code>Po</code>.</li> </ul> </li> <li>Mark (marca) <code>M</code> (acentos etc):<ul> <li>spacing combining (combinaci\u00f3n de espacios) <code>Mc</code>,</li> <li>enclosing (encerrado) <code>Me</code>,</li> <li>non-spacing (sin espaciado) <code>Mn</code>.</li> </ul> </li> <li>Symbol (s\u00edmbolo) <code>S</code>:<ul> <li>currency (moneda) <code>Sc</code>,</li> <li>modifier (modificador) <code>Sk</code>,</li> <li>math (matem\u00e1tica) <code>Sm</code>,</li> <li>other (otro) <code>So</code>.</li> </ul> </li> <li>Separator (separador) <code>Z</code>:<ul> <li>line (l\u00ednea) <code>Zl</code>,</li> <li>paragraph (p\u00e1rrafo) <code>Zp</code>,</li> <li>space (espacio) <code>Zs</code>.</li> </ul> </li> <li>Other (otros) <code>C</code>:<ul> <li>control <code>Cc</code>,</li> <li>format (formato) <code>Cf</code>,</li> <li>not assigned (sin asignaci\u00f3n) <code>Cn</code>,</li> <li>private use (uso privado) <code>Co</code>,</li> <li>surrogate (sustituto) <code>Cs</code>.</li> </ul> </li> </ul> <p>Tambi\u00e9n existen categor\u00edas derivadas, como <code>Alphabetic</code> o <code>Hex_digit</code>. Veamos un ejemplo, donde busquemos n\u00fameros escritos en Hexadecimal:</p> <pre><code>const regEx = /x\\p{Hex_Digit}/u\nconsole.log('N\u00famero: xAF'.match(regEx)) // xAF\n</code></pre> <p>Existe una propiedad Unicode llamada <code>Script</code>, que permite buscar caracteres de un sistema de escritura dado. Para ello, debemos usar <code>Script=&lt;value&gt;</code> siendo value el valor del sistema de escritura:</p> <pre><code>const regexp = /\\p{sc=Han}/gu // devuelve sinogramas chinos\nconst str = `Hello \u041f\u0440\u0438\u0432\u0435\u0442 \u4f60\u597d 123_456`\nconsole.log(str.match(regexp)) // \u4f60,\u597d\n</code></pre>"},{"location":"bloque_i/tema_x/page-2/#anclas","title":"Anclas","text":"<p>Los caracteres caret <code>^</code> y d\u00f3lar <code>$</code> tienen un significado especial en una expresi\u00f3n regular, tienen una funci\u00f3n de anclas.</p> <p>El car\u00e1cter <code>^</code> representa el principio de una cadena, mientras que <code>$</code> representa el final:</p> <pre><code>const str = 'Javascript is a programming language'\nconsole.log(/^Javascript/.test(str)) // true\n</code></pre> <p>La expresi\u00f3n <code>^Javascript</code> indica que la cadena comienza con la palabra Javascript. De igual manera, funciona el car\u00e1cter <code>$</code>:</p> <pre><code>const str = 'Javascript is a programming language'\nconsole.log(/programming$/.test(str)) // true\n</code></pre> <p>Al usar ambos anclajes a la vez, nos permite probar si una cadena coincide al completo con el patr\u00f3n deseado. Por ejemplo, para comprobar si la entrada de un usuario es correcta, o si la contrase\u00f1a indicada por el usuario cumple los requisitos:</p> <pre><code>const good = '12:34'\nconst bad = '12:234'\nconst regEx = /^\\d\\d:\\d\\d$/\nconsole.log(regEx.test(good)) // true\nconsole.log(regEx.test(bad)) // false\n</code></pre> <p>Cuando el modo multilinea est\u00e1 activado (<code>m</code>) el comportamiento de las anclas se ve afectado. De esta forma, no solo ha de coincidir el principio y el final de la cadena con el patr\u00f3n, sino que cada una de las l\u00edneas de la cadena:</p> <pre><code>const str = `1er lugar: Winnie\n2do lugar: Piglet\n3er lugar: Eeyore`\nconsole.log(str.match(/^\\d/gm)) // [1, 2, 3]\n</code></pre> <p>En el ejemplo anterior, vemos como la cadena debe empezar por un d\u00edgito, y el resultado devuelve un array con los 3 valores, uno por cada l\u00ednea. Sin hacer uso de la flag <code>m</code>, solo devolver\u00eda <code>1</code>, que es el inicio de la cadena. De la misma forma funciona el <code>$</code>.</p>"},{"location":"bloque_i/tema_x/page-2/#limite-de-palabra","title":"L\u00edmite de palabra","text":"<p>Como hemos visto antes, existen dos anclas para indicar el comienzo y el final de una cadena. Pero, en ocasiones, nos interesa limitar una palabra dentro del patr\u00f3n. Para ello, se usa el car\u00e1cter <code>\\b</code>. Cuando el motor regex se encuentra con dicho car\u00e1cter, comprueba que la posici\u00f3n en la cadena es un l\u00edmite de palabra. Existen tres posiciones que se califican como limites de palabra:</p> <ul> <li>Al comienzo de la cadena, si el primer car\u00e1cter de la cadena es una car\u00e1cter de palabra (<code>\\w</code>).</li> <li>Entro dos caracteres de la cadena.</li> <li>Al final de la cadena, si el \u00faltimo car\u00e1cter es un car\u00e1cter de palabra.</li> </ul> <pre><code>console.log(\"Hello, Java!\".match(/\\bJava\\b/)) // Java\nconsole.log(\"Hello, JavaScript!\".match(/\\bJava\\b/)) // null\n</code></pre> <p>Tambi\u00e9n se puede usar el l\u00edmite de palabra con d\u00edgitos.</p>"},{"location":"bloque_i/tema_x/page-3/","title":"3 Conjuntos","text":""},{"location":"bloque_i/tema_x/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>En ciertas ocasiones, es necesario hacer uso de los caracteres especiales en el conjunto de la expresi\u00f3n regular, como por ejemplo la barra invertida <code>\\</code> o el punto <code>.</code>.</p> <p>Si se desea comprobar si la cadena tiene un punto, no podemos usar la expresi\u00f3n <code>.</code> ya que representa cualquier car\u00e1cter. Para anular cualquier car\u00e1cter especial, podemos usar el car\u00e1cter de la barra invertida <code>\\</code>:</p> <pre><code>console.log(5.1.match(/\\d\\.\\d/)) // [5.1]\n</code></pre> <p>Se puede hacer incluso con la misma barra:</p> <pre><code>console.log('1\\\\2'.match(/\\\\/)) // [\\]\n</code></pre> <p>Las barras normales <code>/</code> no son consideradas como car\u00e1cter especial en Javascript. Sin embargo, se pueden usar para delimitar una expresi\u00f3n regular, por lo que si en ella se quiere usar, tambi\u00e9n se deber\u00eda preceder el car\u00e1cter <code>\\</code>:</p> <pre><code>console.log(\"/\".match(/\\//)) // [/]\n</code></pre> <p>Otra forma de poder buscar una barra en una cadena, es haciendo uso del constructor de la clase <code>RegEx</code>:</p> <pre><code>console.log('/'.match(new RegEx('/')))\n</code></pre> <p>\u00a1Importante!</p> <p>Al usar el constructor <code>new RegEx</code> hay que tener en cuenta que las barras invertidas son consumidas como cadena, por lo que expresiones como <code>\\d</code> o <code>\\.</code> no tendr\u00edan funcionamiento:</p> <pre><code>console.log('Capitulo 5.1'.match(new RegEx(\"\\d\\.\\d\"))) //null\n</code></pre> <p>Para evitar dicho error, habr\u00eda que duplicar la cadena invertida para que obtenga <code>\\d</code> en lugar de <code>d</code>.</p> <pre><code>console.log('Capitulo 5.1'.match(new RegEx(\"\\\\d\\\\.\\\\d\"))) //[5.1]\n</code></pre>"},{"location":"bloque_i/tema_x/page-3/#conjunto-y-rangos","title":"Conjunto y rangos","text":"<p>En ciertas ocasiones, queremos buscar o reemplazar un conjunto espec\u00edfico que no es contemplado por lo que hemos visto anteriormente. Para ello, podemos especificar un conjunto espec\u00edfico haciendo uso de los corchetes <code>[...]</code>. De esta manera, denotamos que la cadena cumpla con cualquier car\u00e1cter dentro de los corchetes. Veamos un ejemplo:</p> <pre><code>const course = \"1\u00ba ESO A\"\nconsole.log(course.match(/[ABC]$/)) // [A]\n</code></pre> <p>En el ejemplo anterior, comprobamos si el curso termina en una de las letras posibles. Dado que hay tres cursos (A, B, C), para que sea un curso v\u00e1lido, debe terminar en A, B o en C. Veamos otro ejemplo:</p> <pre><code>console.log('2x-3'.match(/2[abcdefghijklmnopqrstuvwxyz]-3/)) // [x]\n</code></pre> <p>En este ejemplo, se ha intentado comprobar si la expresi\u00f3n es una ecuaci\u00f3n matem\u00e1tica. Para ello, el car\u00e1cter que va despu\u00e9s de 2 debe ser una letra.</p> <p>En ciertas ocasiones, escribir todo un conjunto contin\u00fao se puede hacer un poco pesado. Para ello, podemos hacer uso de los rangos <code>[...-...]</code>, que son un tipo de conjunto donde se indica el comienzo del rango y el final del mismo, y abarca todas las posibilidades entre ambos. Veamos el ejemplo anterior, haciendo uso de rangos:</p> <pre><code>console.log('2x-3'.match(/2[a-z]-3/)) // [x]\n</code></pre> <p>Dentro de los conjuntos, tambi\u00e9n se pueden usar clases de caracteres. En el siguiente ejemplo, vamos a comprobar si la cadena empieza con un car\u00e1cter de palabra o con un espacio.</p> <pre><code>console.log('Prueba'.match(/[\\w\\s]/))\n</code></pre> <p>Si por el contario, se desea excluir los caracteres dentro del conjunto, se debe usar el car\u00e1cter caret dentro de los corchetes que indican el conjunto <code>[^...]</code>. Veamos un ejemplo, donde queremos obtener los caracteres especiales de una cadena:</p> <pre><code>console.log('minuevoemail12@gmail.com'.match(/[^\\d\\sA-Z]/gi)) // [@, .]\n</code></pre> <p>Tal y como hemos visto en el punto anterior, al usar en una expresi\u00f3n la b\u00fasqueda de caracteres especiales (como el punto), es necesario hacer uso de la barra invertida <code>\\</code>. Dentro de los conjuntos no es necesario escapar dichos caracteres en las siguientes ocasiones:</p> <ul> <li>El punto <code>.</code>, el operador m\u00e1s <code>+</code> y los par\u00e9ntesis <code>()</code> nunca necesitan escape dentro de un conjunto.</li> <li>El gui\u00f3n <code>-</code> no es necesario realizar escape, ni al principio ni al final de la expresi\u00f3n. Es necesario realizar escape, cuando va entre dos caracteres y no indica un rango. Por ejemplo: <code>[a\\-z]</code>, en este caso queremos comprobar si hay coincidencia de la letra a o z, o un gui\u00f3n. Si el gui\u00f3n no se escapa, buscar\u00eda las coincidencias entre las letras a y z.</li> <li>El car\u00e1cter caret <code>^</code> no es necesario realizar escape en ninguna posici\u00f3n, solamente al principio de la expresi\u00f3n, que puede significar exclusi\u00f3n.</li> <li>El corchete de apertura <code>[</code> nunca se escapa, pero el corchete de cierre <code>]</code> siempre es necesario realizarle el escape.</li> </ul>"},{"location":"bloque_i/tema_x/page-4/","title":"4 Cuantificadores","text":""},{"location":"bloque_i/tema_x/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Supongamos que deseamos localizar un mismo conjunto, o una misma clase de caracteres que se repite cierta ocasi\u00f3n, o por el contrario puede o no aparecer. Para ello, podemos hacer uso de los cuantificadores para indicar el n\u00famero de veces que debe aparecer un conjunto o una clase de caracteres dentro de una cadena.</p>"},{"location":"bloque_i/tema_x/page-4/#numero-de-veces","title":"N\u00famero de veces","text":"<p>Para indicar que una expresi\u00f3n se repite n-veces, es necesario indicarlo entre corchetes <code>{n}</code>. Por ejemplo:</p> <pre><code>console.log('I am 12453 months'.match(/\\d{5}/)) // [12345]\n</code></pre> <p>En el ejemplo anterior, se realiza una b\u00fasqueda de un d\u00edgito que aparezca 5 veces.</p> <p>Cuando usamos la expresi\u00f3n <code>{n}</code>, hacemos referencia al n\u00famero exacto de veces que debe aparecer el conjunto o clase de caracteres en la cadena a evaluar. Sin embargo, en ciertas ocasiones nos interesa que el n\u00famero de veces que aparece sea comprendido entre un rango, por ejemplo entre 3 y 5 veces, para ello usamos la expresi\u00f3n <code>{n,m}</code>, siendo n el l\u00edmite inferior y m el l\u00edmite superior. Veamos un ejemplo, donde se busque la coincidencia entre 3 y 5 veces:</p> <pre><code>console.log('I am not 12 years old, I am 3456 months'.match(/\\d{3,5}/)) // [3456]\n</code></pre> <p>Incluso, a veces, solo queremos indicar el n\u00famero m\u00ednimo de veces que debe aparecer. Para ello, usamos <code>{n,}</code>, siendo n el n\u00famero m\u00ednimo de veces que debe aparecer un conjunto o clase de caracteres:</p> <pre><code>console.log('I am not 12 years old, I am 3456 months'.match(/\\d{3,}/)) // [3456]\n</code></pre>"},{"location":"bloque_i/tema_x/page-4/#abreviaciones","title":"Abreviaciones","text":"<p>Para ciertos rangos de apariciones de conjunto o clases de caracteres, se dispone de algunos caracteres especiales que abrevian a dichos rangos:</p> <ul> <li> <p><code>+</code>: indica que un conjunto o clase de caracteres debe aparecer uno o m\u00e1s veces. Es equivalente a <code>{1,}</code>. Veamos un ejemplo:</p> <p>```javascript console.log('+7(903)-123-45-67'.match(/\\d+/g)) // [7, 903, 123, 45, 67] ````</p> </li> <li> <p><code>?</code>: indica que un conjunto o clase de caracteres debe aparecer cero o una vez. Es equivalente a <code>{0,1}</code>. Veamos un ejemplo:</p> <pre><code>console.log('AA-12345-B'.match(/[A-Z]?/)) // [A, A, B]\n</code></pre> </li> <li> <p><code>*</code>: indica que un conjunto o clase de caracteres debe aparecer todas las veces posibles, incluso no aparecer. Es equivalente a <code>{0,}</code>:</p> <p>```javascript console.log('100 10 1'.match(/\\d0*/g)) // [100, 10, 1]</p> </li> </ul> <p>Veamos varios ejemplos:</p> <ul> <li> <p>Obtener n\u00fameros decimales de una cadena:</p> <pre><code>console.log(\"0 1 12.345 7890\".match(/\\d+\\.\\d+/g)) // [12.245]\n</code></pre> <p>En este ejemplo se busca una cadena que aparezca un n\u00famero al menos una vez (<code>\\d</code>) seguido de un punto seguido de otro n\u00famero (<code>\\.</code>) que aparezca tambi\u00e9n al menos una vez (<code>\\d</code>)</p> </li> <li> <p>Obtener etiquetas HTML sin atributos:</p> <pre><code>const regEx = /&lt;\\/?[a-z][a-z\\d]*&gt;/gi\nconsole.log('&lt;body&gt;This is a body&lt;/body&gt;'.match(regEx)) // [&lt;body&gt;, &lt;/body&gt;]\nconsole.log('&lt;h1&gt;This is a title&lt;/h1&gt;'.match(regEx)) // [&lt;h1&gt;, &lt;/h1&gt;]\n</code></pre> <p>En este ejemplo se busca una cadena que empiece por el signo menor <code>&lt;</code> seguido por un barra que puede aparecer entre 0 o 1 vez <code>\\/?</code> (en caso de que sea etiqueta de cierre aparecer\u00e1 una vez, y en caso de que sea etiqueta de apertura no aparecer\u00e1) una letra comprendida entre la a y la z <code>[a-z]</code>, seguido de un letra o un n\u00famero que se puede repetir varias veces, o simplemente no puede aparecer <code>[a-z\\d]*</code>, terminando por un car\u00e1cter de mayor <code>&gt;</code>.</p> </li> </ul>"},{"location":"bloque_i/tema_x/page-4/#greedy-matching","title":"Greedy matching","text":"<p>La greedy matching* (b\u00fasqueda codiciosa) se refiere a la forma en la que realiza la b\u00fasqueda de la expresi\u00f3n en la expresi\u00f3n regular a trav\u00e9s de sus cuantificadores. Se pueden realizar de dos formas: codiciosa (*greedy) o reticente (reluctant).</p> <p>La b\u00fasqueda codiciosa tiene como objetivo encontrar el mayor n\u00famero de coincidencias posibles. Adem\u00e1s, es la forma por defecto que se utiliza a la hora de utilizar los cuantificadores.</p> <pre><code>const regex = /a.*/\nconst texto = \"abc aaaa aaaa\"\nconst resultado = texto.match(regex)\nconsole.log(resultado[0]) // \"abc aaaa aaaa\"\n</code></pre>"},{"location":"bloque_i/tema_x/page-4/#reluctant-matching","title":"Reluctant matching","text":"<p>La reluctant matching (b\u00fasqueda reticente) intenta realizar la b\u00fasqueda comprobando en el n\u00famero menor de caracteres posibles, pero siempre cumpliendo el patr\u00f3n. Para indicar que los cuantificadores se usan de este modo se debe a\u00f1adir una interrogaci\u00f3n <code>?</code>:</p> <pre><code>const regex = /a.+?a/;\nconst texto = \"abc aaaa aaaa\";\nconst resultado = texto.match(regex);\nconsole.log(resultado[0]); // \"abc a\"\n</code></pre> <p>Incluso, cuando se desea buscar una o ninguna vez:</p> <pre><code>const regex /a??bc/\nconsole.log(\"abc aaaa aaaa\".match(regex)) // [abc]\n</code></pre> <p>Iteremos con el ejemplo, supongamos que tenemos una cadena <code>Hola soy Marta, pero no soy ninguna \"bruja\" como me llaman por ah\u00ed, yo me considero \"cient\u00edfica\"</code>, y se desea obtener las palabras que van entre comillas, en el caso greedy, empieza a iterar desde el primer car\u00e1cter y va avanzando hasta comprobar que el patr\u00f3n se cumpla en alguno de ellos o se termine la cadena.</p> <pre><code>const str = `Hola soy Marta, pero no soy ninguna \"bruja\" como me llaman por ah\u00ed, yo me considero \"cient\u00edfica\"`\nconst regex = /\".+\"/g\nconst result = str.match(regex)\nconsole.log(result) // [\"bruja\", \"cient\u00edfica\"]\n</code></pre> <p>En el caso reticente (reluctant) se abarcar\u00e1 la b\u00fasqueda desde la primera coincidencia con el patr\u00f3n, obviando el resto de caracteres. Una vez coincidido el patr\u00f3n, no busca en los siguientes caracteres, si no que comprueba la siguiente coincidencia.</p> <pre><code>const str = `Hola soy Marta, pero no soy ninguna \"bruja\" como me llaman por ah\u00ed, yo me considero \"cient\u00edfica\"`\nconst regex = /\".+?\"/g\nconst result = str.match(regex)\nconsole.log(result) // [\"bruja\", \"cient\u00edfica\"]\n</code></pre>"},{"location":"bloque_i/tema_x/page-5/","title":"5 Grupos","text":""},{"location":"bloque_i/tema_x/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Un grupo de captura es una parte de una expresi\u00f3n regular que se desea obtener. Para indicar dentro de un expresi\u00f3n que un parte pertenece a un grupo de captura, se envuelve entre par\u00e9ntesis <code>(...)</code></p> <p>Podemos usar, despu\u00e9s del par\u00e9ntesis de captura, un cuantificador para cuantificar el n\u00famero de veces que debe aparecer el grupo:</p> <pre><code>console.log('Gogogo now!'.match(/(go)+/ig)) //[go, go go]\n</code></pre> <p>En cambio, si se usa como grupo de captura podemos obtener una matriz independiente con los valores capturados. Supongamos que tenemos una cadena y queremos comprobar si es o no un email, y en caso de serlo obtener el nombre de dominio. Un email se compone de un nombre y un dominio unido por el car\u00e1cter <code>@</code> teniendo una estructura as\u00ed <code>name@domain</code>. Como se desea obtener el dominio, esa parte de la expresi\u00f3n regular debe de estar envuelta entre par\u00e9ntesis.</p>"},{"location":"bloque_i/tema_x/page-5/#grupos-con-match","title":"Grupos con match","text":"<p>Para obtener los grupos de las coincidencias encontradas haciendo uso de la funci\u00f3n <code>match(regex)</code> de las cadenas, si no tiene el indicador <code>g</code>, se acceder\u00e1 a la posici\u00f3n del grupo, que est\u00e1n enumeradas de izquierda a derecha. De esta manera, para el primer grupo se acceder\u00e1 al \u00edndice 1, al grupo 2 el \u00edndice 2, etc. Al acceder al \u00edndice 0, se obtiene la coincidencia completa.</p> <p>Veamos un ejemplo, donde se obtiene la primera coincidencia de las etiquetas HTML:</p> <pre><code>const str = \"&lt;h1&gt;Hello world!&lt;/h1&gt;\"\nconst tags = str.match(/&lt;(.*?)&gt;)\nconsole.log(tags[0]) // &lt;h1&gt;\nconsole.log(tags[1]) // h1\n</code></pre> <p>Tambi\u00e9n existe la posibilidad de anidar grupos. De esta manera, el acceso var\u00eda un poco, siguiendo la numeraci\u00f3n de izquierda a derecha, pero si alguno tiene alg\u00fan subgrupo se cuenta primero los de adentro.</p> <p>Supongamos, ahora, que queremos obtener la etiqueta, el atributo con su valor. Para ello, usamos la siguiente expresi\u00f3n <code>&lt;(([a-z][a-z\\d]*)\\s*(([a-z]*)=\\s*(\"[\\w\\s]*\")))&gt;</code>. Al aplic\u00e1rselo a la etiqueta <code>&lt;span class=\"my\"&gt;</code>:</p> <ul> <li>el primer grupo corresponde a la etiqueta completa: <code>span class=\"my\"</code></li> <li>el segundo grupo corresponde al nombre de la etiqueta: <code>span</code></li> <li>el tercer grupo corresponde al atributo y su valor: <code>class=\"my\"</code></li> <li>el cuarto grupo corresponde al nombre del atributo: <code>class</code></li> <li>el quinto grupo corresponde al valor del atributo: <code>\"my\"</code></li> </ul> <pre><code>const regex = /&lt;(([a-z][a-z\\d]*)\\s*(([a-z]*)=\\s*(\"[\\w\\s]*\")))&gt;/\nconst str = `&lt;span class=\"my\"&gt;This is a span&lt;/span&gt;`\nconst result = str.match(regex)\nconsole.log(result[0]) //&lt;span class=\"my\"&gt;\nconsole.log(result[1]) // span class=\"my\"\nconsole.log(result[2]) // span\nconsole.log(result[3]) // class=\"my\"\nconsole.log(result[4]) // class\nconsole.log(result[5]) // \"my\"\n</code></pre>"},{"location":"bloque_i/tema_x/page-5/#grupos-opcionales","title":"Grupos opcionales","text":"<p>A veces, usamos un grupo que puede aparecer una vez o ninguna, en ese caso, estamos tratando con un grupo opcional. Si el grupo no se encuentra, pero se ha encontrado coincidencia, el array contendr\u00e1 en la posici\u00f3n del grupo espec\u00edfico un valor <code>undefined</code>:</p> <pre><code>let match = 'a'.match(/a(z)?(c)?/);\nconsole.log(match.length) // 3\nconsole.log(match[0]) // a (coincidencia completa)\nconsole.log(match[1]) // undefined\nconsole.log(match[2]) // undefined\n</code></pre> <p>La longitud sigue siendo tres, pero el array se compone de dos posiciones con valor <code>undefined</code>.</p>"},{"location":"bloque_i/tema_x/page-5/#grupos-en-todas-las-coincidencias","title":"Grupos en todas las coincidencias","text":"<p>Al usar el indicador <code>g</code> el array devuelto, no nos devuelve los valores de los grupos que se desea obtener.</p> <pre><code>const str = `&lt;h1&gt;Title&lt;/h1&gt; &lt;h2&gt;Subtitle&lt;/h2&gt;`\nconst tags = str.match(/&lt;(.*?)&gt;/g)\nconsole.log(tags) // [&lt;h1&gt;, &lt;h2&gt;]\n</code></pre> <p>Para poder obtener el valor de los grupos, se puede hacer uso del m\u00e9todo <code>matchAll(regex)</code>. Al igual que <code>match(regex)</code> busca coincidencias pero tiene algunas diferencias:</p> <ul> <li>No devuelve un array, si no un objeto iterable</li> <li>Cuando est\u00e1 presente el indicador <code>g</code>, devuelve todas coincidencias como un array de grupos.</li> <li>Si no hay coincidencias, NO devuelve <code>null</code>, sino un objecto iterable vac\u00edo.</li> </ul> <pre><code>const results = '&lt;h1&gt; &lt;h2&gt;'.matchAll(/&lt;(.*?)&gt;/gi)\n// results - no es un array, sino un objeto iterable\nconsole.log(results) // [object RegExp String Iterator]\nresults = Array.from(results) // lo convirtamos en array\nconsole.log(results[0]) // &lt;h1&gt;,h1 (1er etiqueta)\nconsole.log(results[1]) // &lt;h2&gt;,h2 (2da etiqueta)\n</code></pre> <p>Cada coincidencia del <code>matchAll(regex)</code> tiene la misma estructura devuelta por un <code>match(regex)</code> sin el flag <code>g</code>:</p> <pre><code>const results = '&lt;h1&gt; &lt;h2&gt;'.matchAll(/&lt;(.*?)&gt;/gi)\nconst [tag1, tag2] = results\nconsole.log(tag1[0]) // &lt;h1&gt;\nconsole.log(tag1[1]) // h1\nconsole.log(tag1.index) // 0\nconsole.log(tag1.input) // &lt;h1&gt; &lt;h2&gt;\n</code></pre>"},{"location":"bloque_i/tema_x/page-5/#grupos-con-nombre","title":"Grupos con nombre","text":"<p>Cuando un patr\u00f3n es simple, es factible enumerar los grupos. Sin embargo, cuando tenemos una expresi\u00f3n compleja y se desea recordar el n\u00famero del grupo al que acceder, es dif\u00edcil de recordar. Para ello, podemos nombrar a los grupos y acceder a ellos con mayor facilidad.</p> <p>Para nombrar un grupo, se debe indicar <code>?&lt;name&gt;</code> despu\u00e9s del par\u00e9ntesis de apertura. Para acceder a un grupo por su nombre, debemos acceder al objeto <code>groups</code> del resultado:</p> <pre><code>const dateRegexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/\nconst str = \"2019-04-30\"\nconst groups = str.match(dateRegexp).groups\nconsole.log(groups.year) // 2019\nconsole.log(groups.month) // 04\nconsole.log(groups.day) // 30\n</code></pre> <p>Tambi\u00e9n, se pueden usar en <code>matchAll(regex)</code>:</p> <pre><code>const dateRegexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/g\nconst str = \"2019-10-30 2020-01-01\"\nconst results = str.matchAll(dateRegexp)\nfor(let result of results) {\nlet {year, month, day} = result.groups\nconsole.log(`${day}.${month}.${year}`)\n}\n</code></pre>"},{"location":"bloque_i/tema_x/page-5/#grupos-en-reemplazo","title":"Grupos en reemplazo","text":"<p>Como hemos visto anteriormente, el m\u00e9todo <code>replace(regex, replacement)</code> reemplaza todas las coincidencias por el valor indicado. Pero, supongamos que tenemos una cadena y lo que deseamos es cambiar el orden, gracias a <code>$n</code> podemos acceder al n\u00famero de grupo y reescribir la cadena en otro orden:</p> <pre><code>const str = \"John Bull\";\nconst regexp = /(\\w+) (\\w+)/;\nconsole.log(str.replace(regexp, '$2, $1')) // Bull, John\n</code></pre> <p>Tambi\u00e9n se puede hacer con par\u00e1metros nombrados, haciendo uso de <code>$&lt;name&gt;</code>:</p> <pre><code>const regexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/g;\nconst str = \"2019-10-30, 2020-01-01\";\nconsole.log(str.replace(regexp, '$&lt;day&gt;.$&lt;month&gt;.$&lt;year&gt;'));\n// 30.10.2019, 01.01.2020\n</code></pre>"},{"location":"bloque_i/tema_x/page-5/#grupos-no-capturados","title":"Grupos no capturados","text":"<p>Podemos no capturar un grupo, cuando queremos cuantificar un grupo pero no queremos obtener un resultado. Para excluir un grupo, se debe usar <code>?:</code> despu\u00e9s del par\u00e9ntesis de apertura:</p> <pre><code>const str = \"Gogogo John!\"\n// ?: excluye 'go' de la captura\nconst regexp = /(?:go)+ (\\w+)/i\nconst result = str.match(regexp)\nconsole.log(result[0]) // Gogogo John (coincidencia completa)\nconsole.log(result[1]) // John\nconsole.log(result.length) // 2 (no hay m\u00e1s \u00edtems en el array)\n</code></pre>"},{"location":"bloque_i/tema_x/page-5/#referencias-inversas","title":"Referencias inversas","text":"<p>Supongamos que se desea encontrar una cadena que est\u00e9 envuelta entre comillas, ya sea simple o doble, con la \u00fanica condici\u00f3n de que la de comienzo y la de final deben ser la misma. El patr\u00f3n ser\u00eda algo tal que as\u00ed <code>['\"](.*?)['\"]</code>. Sin embargo, si tenemos usamos un tipo de comillas dentro de otras, esto puede dar coincidencias incorrectas:</p> <pre><code>const str = `He said: \"She's the one!\".`\nconst regex = /['\"](.*?)['\"]/g\nconsole.log(str.match(regex)) // \"She'\n</code></pre> <p>Como se puede observar, devuelve <code>\"She'</code>, que para nada es lo que deseamos, ya que no se cumple la condici\u00f3n de que la cadena obtenida debe comenzar con el mismo tipo de comillas.</p> <p>Para solucionar dicho problema, debemos agrupar <code>['\"]</code> y hacer referencia a \u00e9l al final de la expresi\u00f3n. De esta forma, se entender\u00e1 la referencia como el mismo valor obtenido en el grupo referenciado. Para referenciar un grupo usamos la barra invertida seguida del n\u00famero de grupo a referenciar.</p> <pre><code>const str = `He said: \"She's the one!\".`\nconst regex = /(['\"])(.*?)\\1/g\nconsole.log(str.match(regex)) // \"She's the one\"\n</code></pre> <p>Ahora, el problema esta resuelto y obtenemos el valor que realmente deseamos. Tambi\u00e9n se puede hacer referencia a los grupos nombrados, <code>\\k&lt;name&gt;</code>.</p> <pre><code>const str = `He said: \"She's the one!\".`\nconst regexp = /(?&lt;quote&gt;['\"])(.*?)\\k&lt;quote&gt;/g\nconsole.log(str.match(regexp)) // \"She's the one!\"\n</code></pre> <p>Warning</p> <p>Si usamos un grupo opcional (<code>?:</code>) no podemos hacer referencia a \u00e9l dentro de una expresi\u00f3n regular, ya que no son memorizados por el motor.</p>"},{"location":"bloque_i/tema_x/page-6/","title":"6 Comprobaciones","text":""},{"location":"bloque_i/tema_x/page-6/#alternancia","title":"Alternancia","text":"<p>La alternancia es un t\u00e9rmino en un expresi\u00f3n regular que permite obtener una coincidencia entre dos valores. Para usar la alternancia se utiliza la barra vertical <code>|</code>. Por ejemplo, si queremos encontrar coincidencia de unos valores ser\u00eda: <code>html|css|javascript</code></p> <pre><code>const regexp = /html|php|css|java(script)?/gi;\nconst str = \"Primera aparici\u00f3n de HTML, luego CSS, luego JavaScript\";\nconsole.log(str.match(regexp)) // 'HTML', 'CSS', 'JavaScript'\n</code></pre> <p>Es bastante similar a los corchetes <code>[]</code>, pero con la diferencia de que los corchetes solo permite alternar caracteres, es decir, para <code>[html]</code> busca coincidencias con cada una de las letras de html y no con la palabra completa en s\u00ed.</p> <p>Para alternar una parte de la expresi\u00f3n, se puede hacer uso de los par\u00e9ntesis: <code>I love (HTML|Javascript)</code>.</p>"},{"location":"bloque_i/tema_x/page-6/#look-around","title":"Look around","text":"<p>En ciertas ocasiones, es necesario buscar \u00fanicamente las coincidencias donde un patr\u00f3n es precedido o seguido por otro patr\u00f3n. Para ello, existe una sintaxis conocidas como look around, que se puede dividir en otras dos: look ahead y look behind que realizan una b\u00fasqueda posterior y previa, respectivamente.</p> <p>Por ejemplo, supongamos que tenemos la cadena <code>1 pavo cuesta 30\u20ac</code> y deseamos obtener el precio. Para ello, necesitamos localizar el n\u00famero que sigue a una moneda.</p>"},{"location":"bloque_i/tema_x/page-6/#look-ahead","title":"Look ahead","text":"<p>Su sintaxis es <code>X(?=Y)</code>, es decir, buscar el valor de X, si y solo si es seguido por <code>Y</code>. En el ejemplo del precio anterior, la expresi\u00f3n regular ser\u00eda algo tal que as\u00ed <code>\\d+(?=\u20ac)</code>. De esta manera, devolver\u00e1 el valor de X (el precio) pero no el de Y (la moneda). El funcionamiento es el siguiente:</p> <ul> <li>Primero, localiza la parte de la cadena que coincida con el valor X.</li> <li>Posteriormente, comprueba si va precedido del valor Y y devuelve. Por el contrario, omite su valor, y pasa a buscar el siguiente.</li> </ul> <pre><code>const str = '1 pavo cuesta 30\u20ac'\nconsole.log(str.match(/\\d+(?=\u20ac)/)) // 30\n</code></pre> <p>Tambi\u00e9n posible realizar comprobaciones m\u00e1s complejas como <code>X(?=Y)(?=Z)</code>. En este caso, el funcionamiento es:</p> <ol> <li>Localiza la parte de la cadena que coincida con el valor de X.</li> <li>Verifica si va seguido de Y, sino omite su valor.</li> <li>Verifica si va seguido de Z, sino omite su valor.</li> <li>Si ambas verificaciones se cumplen, devuelve el valor de X, sino sigue realizando la b\u00fasqueda.</li> </ol> <pre><code>const str = '1 pavo cuesta 30\u20ac'\nconsole.log(str.match(/\\d+(?=\\s)(?=.*30)/) // 1\n</code></pre> <p>En el ejemplo anterior se realiza la b\u00fasqueda de un d\u00edgito (repetido uno o m\u00e1s veces), seguido de un espacio, y en alg\u00fan momento del n\u00famero 30.</p> <p>A veces, queremos realizar una b\u00fasqueda haciendo uso de la sintaxis look head pero en negativo, es decir, que no vaya seguido un patr\u00f3n espec\u00edfico. Para ello, tenemos la sintaxis <code>X(?!Y)</code>, que significa buscar el valor de X, si y solo si no va seguido de Y.</p> <pre><code>const str = '2 pavos cuesta 60\u20ac'\nconsole.log(str.match(/\\d+(?!\u20ac)/)) // 2\n</code></pre>"},{"location":"bloque_i/tema_x/page-6/#look-behind","title":"Look behind","text":"<p>Look behind usa una l\u00f3gica similar a la sintaxis de look ahead, pero en lugar de comprobar lo que le procede, comprueba lo que le precede. Su sintaxis ser\u00eda: <code>(?&lt;=Y)X</code> que significa buscar el valor de X, si y solo si va precedido del valor Y.</p> <pre><code>const str = '1 pavo cuesta $30'\nconsole.log(str.match(/(?&lt;=\u20ac)\\d+/)) // 30\n</code></pre> <p>Tambi\u00e9n existe una sintaxis negativa: <code>(?&lt;!Y)X</code> que significa buscar el valor de X, si y solo si no va precedido del valor Y.</p> <pre><code>const str = '2 pavos cuesta $60'\nconsole.log(str.match(/(?&lt;!$)\\d+/)) // 2\n</code></pre>"},{"location":"bloque_i/tema_x/page-6/#capturar-valor-de-look-around","title":"Capturar valor de look around","text":"<p>Como hemos visto anteriormente, el valor de Y de un look around no es devuelto, ni siquiera es capturado. Sin embargo, existen los escenarios donde se desea obtener el valor de X, tanto como el valor de Y. Para ello, ser\u00eda necesario envolver el valor de Y en un par\u00e9ntesis:</p> <pre><code>const str = '1 pavo cuesta 30\u20ac'\nconst regex = /\\d+(?=(\u20ac))/\nconsole.log(str.match(regex)) // [30, \u20ac]\n</code></pre> <p>Como puede ver, te devuelve un array, cuyo valor del grupo 0 (la coincidencia encontrada) es <code>30</code>, y no <code>30\u20ac</code>. Sin embargo, existe un \u00edndice 1, con el valor del grupo 1, en este caso <code>\u20ac</code></p>"},{"location":"bloque_i/tema_x/page-7/","title":"7 M\u00e1s m\u00e9todos RegEx","text":""},{"location":"bloque_i/tema_x/page-7/#metodo-exec","title":"M\u00e9todo exec","text":"<p>El indicar <code>y</code> permite realizar la b\u00fasqueda en una posici\u00f3n dada en la cadena de origen. Supongamos que tenemos la cadena <code>const varName = \"value\"</code>, y necesitamos obtener el nombre de la variable que comienza en la posici\u00f3n 4. Al usar la expresi\u00f3n <code>/\\w+/</code> solo encontrar\u00e1 la primera palabra de la cadena (<code>let</code>), que no es el valor del cual disponemos. Lo l\u00f3gico ser\u00eda empezar a buscar desde la posici\u00f3n 4, que es donde sabemos que comienza el nombre de la variable.</p> <p>Existe un m\u00e9todo de la clase <code>RegEx</code> denominado <code>exec(string)</code>, que sin los flags <code>g</code> e <code>y</code> funciona exactamente igual que <code>match(regex)</code>. Sin embargo, al usar dicho m\u00e9todo con la flag <code>g</code>, realiza la b\u00fasqueda desde la posici\u00f3n almacenada en su propiedad <code>lastIndex</code>. Al encontrar coincidencia, el valor de dicha propiedad ser\u00e1 cambiado por la posici\u00f3n anterior a la coincidencia.</p> <p>Se pueden realizar llamadas sucesivas, para ir obtener coincidencias una detr\u00e1s de otras:</p> <pre><code>const str = `let varName`\nconst regex = /\\w+/g\nconsole.log(regex.lastIndexOf) // (1)!\nconst word1 = regex.exec(str)\nconsole.log(word1[0]) // let \nconsole.log(regexp.lastIndex) // (2)!\nconst word2 = regexp.exec(str)\nconsole.log(word2[0]) // varName\nconsole.log(regexp.lastIndex) // (3)!\nconst word3 = regexp.exec(str)\nconsole.log(word3) // null\nconsole.log(regexp.lastIndex) // (4)!\n</code></pre> <ol> <li>El valor inicial es 0.</li> <li>El valor es 3, posici\u00f3n posterior a la coincidencia.</li> <li>El valor es 11, posici\u00f3n posterior a la coincidencia.</li> <li>El valor es 0, se reinicia al final de la b\u00fasqueda.</li> </ol> <p>La b\u00fasqueda tambi\u00e9n se podr\u00eda realizar en un bucle.</p> <pre><code>const str = 'let varName'\nconst regexp = /\\w+/g\nlet result\nwhile (result = regexp.exec(str)) {\nconsole.log(`Found ${result[0]} at position ${result.index}`)\n}\n</code></pre> <p>De esta manera, podemos solucionar el problema que nos ata\u00f1e, y obtener coincidencia en el \u00edndice 4.</p> <pre><code>const str = 'let varName = \"value\"';\nconst regexp = /\\w+/g\nregexp.lastIndex = 4\nconst word = regexp.exec(str)\nconsole.log(word) // varName\n</code></pre> <p>Sin embargo, si usamos la propiedad <code>lastIndex</code> y  no hay ninguna coincidencia encontrada, pero s\u00ed en un lugar posterior, \u00e9sta ser\u00e1 encontrada. Pero esto, en ciertas ocasiones, no es lo que se desea obtener, sino que se desea obtener la coincidencia en la posici\u00f3n exacta. Para ello, usamos el indicador <code>y</code> para realizar la b\u00fasqueda exactamente en la posici\u00f3n lastIndex y no comenzando en ella:</p> <pre><code>const str = 'let varName = \"value\"'\nconst regexp = /\\w+/y\nregexp.lastIndex = 3\nconsole.log(regexp.exec(str)) // null\nregexp.lastIndex = 4\nconsole.log(regexp.exec(str)) // varName\n</code></pre> <p>Como podemos observar, la expresi\u00f3n no coincide en la posici\u00f3n 3, pero s\u00ed en la posici\u00f3n 4. No solamente es lo que necesitamos, sino que tambi\u00e9n es una mejora en el rendimiento.</p>"},{"location":"bloque_i/tema_x/page-7/#metodo-split","title":"M\u00e9todo split","text":"<p>El m\u00e9todo <code>split(regex|substring, limit)</code> es un m\u00e9todo de cadena que te permite obtener un array de subcadenas. Podemos indicar una substring para indicar por que car\u00e1cter o subcadena separar la cadena original:</p> <pre><code>console.log('12-34-56'.split('-')) // [12, 34, 56]\n</code></pre> <p>En lugar de usar una subcadena, tambi\u00e9n se puede usar una expresi\u00f3n regular como separador:</p> <pre><code>console.log('12, 34, 56'.split('/,\\s*/')) // [12, 34, 56]\n</code></pre> <p>Tambi\u00e9n se puede indicar un argumento con el n\u00famero de elementos que se desea obtener como resultado en el array.</p>"},{"location":"bloque_i/tema_x/page-7/#metodo-search","title":"M\u00e9todo search","text":"<p>El m\u00e9todo <code>search(regex)</code> es un m\u00e9todo de las cadenas que retorna la posici\u00f3n de la primera coincidencia o un <code>-1</code>, si no hay coincidencias.</p> <pre><code>const str = 'A drop of ink may make a million think'\nconsole.log(str.search(/ink/i)) // 10\n</code></pre> <p>Warning</p> <p>Solo devuelve la posici\u00f3n de la primera coincidencia. En caso de que haya m\u00e1s de una, el resto de las coincidencias ser\u00e1n omitidas.</p>"},{"location":"bloque_i/tema_x/page-8/","title":"Ejercicios","text":"Ejercicio 1 <p>Crea y comprueba las siguientes expresiones regulares:</p> <ol> <li>que la cadena sea exactamente \u201ctrue\u201d.</li> <li>que la cadena sea de tres letras, may\u00fasculas o min\u00fasculas.</li> <li>que la cadena contenga 5 o m\u00e1s caracteres que no sean la \u00f1, la z ni la x.</li> <li>que la cadena no empiece con un n\u00famero.</li> <li>que la cadena tenga varios caracteres excepto la b.</li> <li>que la cadena sea un n\u00famero de tel\u00e9fono.</li> <li>que la cadena sea un DNI.</li> <li>que la cadena sea un nombre, es decir, que no tenga espacios, que no sea una cadena vac\u00eda y que empiece por may\u00fasculas.</li> <li>que la cadena empiece con vocal y luego tenga varias consonantes o ninguna.</li> <li>que la cadena tenga un n\u00famero positivo m\u00e1s peque\u00f1o que 300.</li> </ol> Ejercicio 2 <p>\u00bfQu\u00e9 cadena coincide con el patr\u00f3n <code>^$</code>?</p> Ejercicio 3 <p>Crea un funci\u00f3n que te permita encontrar los puntos suspensivos en una cadena. La funci\u00f3n debe retornar cuantos puntos suspensivos se han encontrado.</p> Ejercicio 4 <p>Crea una funci\u00f3n que te permita encontrar colores en formato hexadecimal. La funci\u00f3n debe devolver un array con los valores de los colores. Realiza una prueba con un fichero CSS.</p> Ejercicio 5 <p>Crea una funci\u00f3n que encuentre las etiquetas HTML con sus atributos. La funci\u00f3n debe devolver un objeto con la siguiente estructura: nombre de la etiqueta y lista de atributos (pares nombre y valor)</p> Ejercicio 6 <p>Crea una funci\u00f3n que encuentre en una expresi\u00f3n matem\u00e1tica, los operandos y las operaciones. Calcula el valor de la expresi\u00f3n.</p> Ejercicio 7 <p>Crea una funci\u00f3n que dado un string que simula un fichero HTML, inserte una etiqueta dada dentro del body.</p> Ejercicio 8 <p>Crea una funci\u00f3n que reciba una cadena y comprueba si tiene un formato de tiempo v\u00e1lido (Horas:minutos:segundos)</p>"}]}