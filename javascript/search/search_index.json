{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to Javascript World</p> <pre><code>console.log('Hello World')\n</code></pre>"},{"location":"bloque_i/tema_1/page-1/","title":"1 Introducci\u00f3n a Javascript","text":""},{"location":"bloque_i/tema_1/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Javascript es un lenguaje de programaci\u00f3n utilizado para crear p\u00e1ginas web din\u00e1micas e interactivas. Es el lenguaje de scripting m\u00e1s utilizado en la web y lo emplean los desarrolladores para a\u00f1adir funcionalidad a sitios web y aplicaciones.</p> <p>Puede utilizarse para crear interfaces de usuario interactivas, crear aplicaciones del lado del servidor, conectar bases de datos y mucho m\u00e1s. Su c\u00f3digo de programaci\u00f3n se ha convertido en una parte esencial del desarrollo web moderno y puede encontrarse en pr\u00e1cticamente todas las aplicaciones web.</p> <p>Javascript fue creado en 1995 como una forma de a\u00f1adir programaci\u00f3n a las p\u00e1ginas web. El lenguaje ha sido adoptado por la gran mayor\u00eda de los navegadores web. Una de sus aplicaciones m\u00e1s modernas es dirigirse a otras p\u00e1ginas web sin necesidad de realizar una recarga en el navegador. Adem\u00e1s permite interactuar de varias formas diferentes con la p\u00e1gina web.</p> <p>As\u00ed mismo, es compatible con todos los navegadores modernos, lo cual lo hace un lenguaje esencial por su versatilidad con diferentes plataformas.</p> <p>En general, con este lenguaje se incluye dinamismo al navegar un sitio web, cuando antes se caracterizaban por ser est\u00e1ticos. Es decir, un mejoramiento de la experiencia del usuario y al mismo tiempo, una optimizaci\u00f3n de procesos debido a su facilidad de uso tanto del lado del cliente, como del servidor.</p> <p>Entre sus tareas m\u00e1s comunes podemos encontrar el uso de bases de datos, optimizaci\u00f3n de las funciones de una plataforma y el desarrollo tanto de web apps como aplicaciones m\u00f3viles.</p>"},{"location":"bloque_i/tema_1/page-1/#historia","title":"Historia","text":"<p>JavaScript se introdujo en 1995 como una forma de agregar programas a p\u00e1ginas web en el navegador Netscape Navigator. En su momento fue una idea novedosa. En los primeros d\u00edas de la World Wide Web, HTML era bastante simple, y bastante f\u00e1cil de aprender casi todo lo que se necesitaba saber para agrupar p\u00e1ginas web. Cualquiera pod\u00eda hacer una Web juntando tablas, texto y a\u00f1adiendo alguna imagen.</p> <p>A principios de los a\u00f1os 90, la mayor\u00eda de usuarios que se conectaban a Internet lo hac\u00edan con m\u00f3dems a una velocidad m\u00e1xima de 28.8 kbps. Esa velocidad era m\u00e1s que suficiente para la \u00e9poca salvo que quisieras descargar imagenes de cierto tama\u00f1o. Lo cierto era que la web en aquel entonces no ofrec\u00eda gran cosa m\u00e1s que servir como una inmensa biblioteca donde los usuarios consultaban mayormente contenido basado en texto pero la evoluci\u00f3n que conocemos hoy estaba por llegar y pod\u00edan verse los primeros pasos.</p> <p>En esa \u00e9poca, empezaban a desarrollarse las primeras aplicaciones web y por tanto, las p\u00e1ginas web comenzaban a incluir formularios complejos. Con unas aplicaciones web cada vez m\u00e1s complejas y una velocidad de navegaci\u00f3n tan lenta, surgi\u00f3 la necesidad de un lenguaje de programaci\u00f3n que se ejecutara en el navegador del usuario. De esta forma, si el usuario no rellenaba correctamente un formulario, no se le hac\u00eda esperar mucho tiempo hasta que el servidor volviera a mostrar el formulario indicando los errores existentes.</p> <p>Desde entonces, el lenguaje ha sido adoptado por todos los dem\u00e1s navegadores gr\u00e1ficos principales. Ha hecho posibles las aplicaciones web modernas, aplicaciones con las que puede interactuar directamente sin hacer una recarga de p\u00e1gina para cada acci\u00f3n.</p> <p>En la actualidad los navegadores web no son las \u00fanicas plataformas en las que se utiliza JavaScript. Tambi\u00e9n es posible ejecutar c\u00f3digo JavaScript en un entorno servidor. De hecho las bases de datos, como MongoDB y CouchDB, usan JavaScript como su lenguaje de scripting y consulta. Varias plataformas para la programaci\u00f3n de escritorio y servidor, en particular el proyecto Node.js proporcionan un entorno para la programaci\u00f3n de JavaScript fuera del navegador.</p> <p>Warning</p> <p>Es importante recalcar que el lenguaje de programaci\u00f3n Javascript no tiene casi nada que ver con el lenguaje de programaci\u00f3n Java. La similitud entre ambos nombres se debe a una estrategia de marketing. Java ya era un lenguaje introducido fuertemente en el mercado cuando Javascript aterriz\u00f3 y dispon\u00eda de una amplia popularidad.</p>"},{"location":"bloque_i/tema_1/page-1/#evolucion","title":"Evoluci\u00f3n","text":"<p>Aunque JavaScript surgi\u00f3 como un lenguaje de script para mejorar las capacidades de la web de la \u00e9poca all\u00e1 por 1995 por la extinta Netscape, JavaScript no ha dejado de evolucionar desde entonces. Originalmente el lenguaje se basaba a su vez basaba en CEnvi desarrollado a su vez por Nombas.</p> <p>Brendan Eich, un programador que trabajaba en Netscape, pens\u00f3 que podr\u00eda solucionar las limitaciones de la web de entonces, adaptando otras tecnolog\u00edas existentes (como ScriptEase) al navegador Netscape Navigator 2.0, que iba a lanzarse en aquel a\u00f1o. Inicialmente, Eich denomin\u00f3 a su lenguaje LiveScript y fue un \u00e9xito.</p> <p>Fue entonces cuando, justo antes del lanzamiento, Netscape decidi\u00f3 cambiar el nombre por el de JavaScript y firm\u00f3 una alianza con Sun Microsystems para continuar el desarrollo del nuevo lenguaje de programaci\u00f3n.</p> <p>Microsoft, al ver el movimiento de uno de sus principales competidores, tambi\u00e9n decidi\u00f3 incorporar su propia implementaci\u00f3n de este lenguaje, llamada JScript, en la versi\u00f3n 3 de su navegador Internet Explorer.</p> <p>Esto contribuy\u00f3 todav\u00eda m\u00e1s al empuje y popularizaci\u00f3n del lenguaje, pero comenzaron a presentarse peque\u00f1os problemas por las diferencias entre implementaciones. A partir de estos hechos un documento est\u00e1ndar fue creado para describir la manera en que el lenguaje deber\u00eda funcionar. Dicho documento es conocido como ECMAScript standard. En la pr\u00e1ctica, los t\u00e9rminos ECMAScript y Javascript pueden ser intercambiados, por lo que habr\u00eda dos nombres identificativos para el mismo lenguaje.</p>"},{"location":"bloque_i/tema_1/page-1/#funciones-y-caracteristicas","title":"Funciones y caracter\u00edsticas","text":"<p>Entre las funciones que podemos encontrar en Javascript est\u00e1n:</p> <ul> <li>Agregar efectos visuales y de interacci\u00f3n a una p\u00e1gina web.</li> <li>Validaci\u00f3n de formularios.</li> <li>Automatizaci\u00f3n de tareas.</li> <li>Crear aplicaciones del lado del servidor.</li> <li>Crear chatbots.</li> <li>Desarrollo de aplicaciones m\u00f3viles y juegos.</li> <li>Crear mapas interactivos.</li> <li>Crear gr\u00e1ficos y visualizaciones de datos.</li> <li>Crear aplicaciones web progresivas (PWA)</li> </ul> <p>Adem\u00e1s, cuenta con las siguientes caracter\u00edsticas:</p> <ul> <li>Lenguaje multiplataforma: Puede ser utilizado en muchos marcos y plataformas, as\u00ed como puede ejecutarse en cualquier m\u00e1quina independientemente del sistema operativo de \u00e9sta.</li> <li>Lenguaje interpretado: Tiene un int\u00e9rprete que se encarga de traducir el c\u00f3digo Javascript a c\u00f3digo m\u00e1quina.</li> <li>Lenguaje orientado a objetos: Se basa en usar estructuras de datos orientados a objetos.</li> <li>Lenguaje de alto nivel: Puede ser comprendido de forma sencilla, sin complicaciones.</li> <li>Lenguaje tipado d\u00e9bil: No permite definir al desarrollador el tipo de los datos, as\u00ed como el tipo de dato puede ser cambiado en tiempo de ejecuci\u00f3n.</li> </ul> <p>Manuales</p> <p>MDN (Mozilla) JavaScript Reference es el manual principal, con ejemplos y otras informaciones. Es fant\u00e1stico para obtener informaci\u00f3n exhaustiva sobre funciones individuales del lenguaje, m\u00e9todos, etc.</p> <p>Adem\u00e1s, Javascript es un lenguaje en evoluci\u00f3n, y normalmente se a\u00f1aden nuevas caracter\u00edsticas. Para ver la compatibilidad por navegador y otros motores, consultar:</p> <ul> <li>https://caniuse.com \u2013 tablas de compatibilidad por caracter\u00edstica. Por ejemplo, para comprobar qu\u00e9 motores soportan funciones modernas de criptograf\u00eda: https://caniuse.com/#feat=cryptography. </li> <li>https://kangax.github.io/compat-table \u2013 tabla que muestra la compatibilidad o no de las prestaciones del lenguaje por motor.</li> </ul>"},{"location":"bloque_i/tema_1/page-2/","title":"2 Consola de desarrollador","text":""},{"location":"bloque_i/tema_1/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Un script es un fichero con c\u00f3digo Javascript que contiene las instrucciones que deseemos que se ejecuten en el entorno que queramos que sean ejecutadas. Un entorno de ejecuci\u00f3n es el lugar donde se va a ejecutar el c\u00f3digo incrustado en nuestro script.</p> <p>El entorno de ejecuci\u00f3n por defecto y m\u00e1s \u00fatil de Javascript es el navegador. Sin embargo, existen otros tipos de entornos de ejecuci\u00f3n como un dispositivo m\u00f3vil o la consola de nuestro ordenador.</p>"},{"location":"bloque_i/tema_1/page-2/#consola-del-navegador","title":"Consola del navegador","text":"<p>Una consola es un entorno en el que se puede ejecutar comandos y scripts. Todos los ordenadores tienen un consola instalada por defecto, pero hay ciertos programas que tienen sus propias consolas instaladas.</p> <p>El navegador tiene un integrado una consola para ver mensajes de error o de informaci\u00f3n, pero adem\u00e1s tambi\u00e9n poder ejecutar comandos. Dicha consola est\u00e1 basada y entiende el lenguaje de Javascript, por lo que es muy usada para el desarrollo de aplicaciones web con Javascript.</p> <p>Para poder acceder a ella, se deber\u00e1 acceder a las DevTools de nuestro navegador, y desde ah\u00ed acceder a la pesta\u00f1a Console. En algunos navegadores, existe el shortcut Ctrl+Shift+I para poder abrir las herramientas de desarrollador.</p>"},{"location":"bloque_i/tema_1/page-2/#console","title":"Console","text":"<p>El objeto <code>console</code> es el objeto predeterminado de Javascript para poder interactuar con la consola. Este objeto tiene diferentes m\u00e9todos que podemos usar para trabajar en la consola de formas diferentes:</p> <ul> <li> <p><code>log</code>. Se utiliza para mostrar mensajes de informaci\u00f3n en la consola. Es uno de los m\u00e1s usados. Tambi\u00e9n se puede usar <code>info</code>.</p> <pre><code>console.log('Hello world')\n</code></pre> </li> <li> <p><code>debug</code>. Muestra informaci\u00f3n con todo tipo de detalles.</p> <pre><code>console.debug('This is a debug message')\n</code></pre> </li> <li> <p><code>warn</code>. Se utiliza para mostrar una advertencia. Suele ir destacado en amarillo.</p> <pre><code>console.warn('This is a warn message')\n</code></pre> </li> <li> <p><code>error</code>. Se utiliza para mostrar mensajes de error. Suele ir destacado en rojo.</p> <pre><code>console.error('This is an error message')\n</code></pre> </li> <li> <p><code>clear</code>. Sirve para limpiar la consola, es decir, elimina los mensajes e instrucciones mostrados.</p> </li> </ul> <p>A la derecha de la consola de las DevTools hay un men\u00fa de opciones para poder filtrar los mensajes de la consola por el tipo de mensaje que sea seg\u00fan el m\u00e9todo utilizado.</p> <p>Se puede pasar diferentes mensajes en una misma llamada de la funci\u00f3n, separando cada mensaje por una coma. Esto producir\u00e1 que los mensajes se muestre uno al lado del otro.</p> <pre><code>console.log('This is a', 'message')\n</code></pre>"},{"location":"bloque_i/tema_1/page-2/#estilizar-mensajes","title":"Estilizar mensajes","text":"<p>Se puede estilizar los mensajes de consola, haciendo uso de instrucciones CSS. Para ello, las funciones usadas anteriormente pueden recibir un segundo argumento con una cadena que contenga el estilo CSS a aplicar. Para que no confunda la segunda cadena como un texto a mostrar, es importante que la primera cadena empiece con <code>%c</code>, de esta forma la consola entender\u00e1 que la siguiente instrucci\u00f3n es un estilo y no un mensaje a mostrar:</p> <pre><code>console.log('%cThis is a styled message', 'color: blue')\n</code></pre>"},{"location":"bloque_i/tema_1/page-2/#agrupar-mensajes","title":"Agrupar mensajes","text":"<p>Para mostrar los mensajes en un grupo, podemos usar los siguientes m\u00e9todo del objeto <code>console</code>:</p> <ul> <li><code>group</code>. Sirve para inicializar el grupo de mensajes. Puede recibir el nombre del grupo. Con <code>groupCollapsed</code> inicializa el grupo de mensajes, pero lo muestra colapsado.</li> <li><code>groupEnd</code>. Sirve para finalizar el grupo.</li> </ul> <p>Entre ambos m\u00e9todos se puede escribir diferentes tipos de mensajes, y en la consola de mostrar\u00e1 agrupados.</p>"},{"location":"bloque_i/tema_1/page-2/#tablas","title":"Tablas","text":"<p>Se puede mostrar los arrays y los objetos, que veremos m\u00e1s adelante, en forma de tabla haciendo uso del m\u00e9todo <code>table</code> del objecto <code>console</code>.</p> <pre><code>console.table(users);\n</code></pre>"},{"location":"bloque_i/tema_1/page-2/#assert","title":"Assert","text":"<p>El m\u00e9todo <code>assert</code> sirve para mostrar un mensaje en consola siempre y cuando se cumpla una condici\u00f3n.</p> <pre><code>console.assert(5 &lt; 10, \"5 es menor que 10\"); // No ocurre nada\nconsole.assert(5 &lt; 0, \"5 es menor que 0\"); // Muestra el mensaje indicado con un aviso de error\n</code></pre>"},{"location":"bloque_i/tema_1/page-3/","title":"3 C\u00f3digo Javascript","text":""},{"location":"bloque_i/tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos dicho, un script es un conjunto de instrucciones para ser ejecutadas. Para ejecutar un script de Javascript en el navegador, se pueden hacer de formas diferentes:</p> <ul> <li>Haciendo uso de la etiqueta HTML <code>script</code>.</li> <li>Creando un fichero Javascript e importando dicho fichero a un fichero HTML.</li> </ul> <p>Cada vez que usamos una de esta formas el c\u00f3digo Javascript se ejecutar\u00e1 cada vez que accedamos a la p\u00e1gina HTML d\u00f3nde se ha incrustado dicho c\u00f3digo.</p>"},{"location":"bloque_i/tema_1/page-3/#etiqueta-script","title":"Etiqueta script","text":"<p>La etiqueta <code>script</code> es una etiqueta HTML que permite introducir c\u00f3digo Javascript para que el navegador puede utilizar dicho c\u00f3digo. En dicha etiqueta podemos indicar las diferentes instrucciones a ejecutar. Normalmente la etiqueta puede ser utilizada en cualquier parte del documento, pero se recomienda su uso dentro de la etiqueta <code>head</code> o al final de la etiqueta <code>body</code>, antes de su cierre.</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;!--... --&gt;\n&lt;script&gt;\nconsole.log('This is a Javascript script')\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script&gt;\nconsole.log('This is a Javascript script')\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Podemos crear un fichero Javascript (de extension <code>.js</code>) con las instrucciones e insertar dicho fichero en un documento HTML, haciendo uso del atributo <code>src</code> de la etiqueta <code>script</code>:</p> JavascriptHTML <pre><code>console.log('This is a Javascript script')\n</code></pre> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;!--... --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script src=\"fichero.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Otra atributo que puede recibir dicha etiqueta es el atributo <code>type</code> para indicar el tipo script que se va a insertar. Para los archivos Javascript, el tipo es <code>type=\"text/javascript\"</code>.</p> <p>Tips</p> <p>En la mayor\u00eda de los casos se recomienda crear un fichero a parte e insertarlo en nuestro documento HTML. La ventaja de un archivo separado es que el navegador lo descargar\u00e1 y lo almacenar\u00e1 en cach\u00e9.</p> <p>Otras p\u00e1ginas que hacen referencia al mismo script lo tomar\u00e1n del cach\u00e9 en lugar de descargarlo, por lo que el archivo solo se descarga una vez.</p> <p>Eso reduce el tr\u00e1fico y hace que las p\u00e1ginas sean m\u00e1s r\u00e1pidas.</p> <p>Warning</p> <p>Una sola etiqueta <code>&lt;script&gt;</code> no puede tener el atributo <code>src</code> y c\u00f3digo dentro.</p> <pre><code>&lt;script src=\"file.js\"&gt;\nalert(1); // el contenido se ignora porque se estableci\u00f3 src\n&lt;/script&gt;\n</code></pre> <p>Debemos elegir un <code>&lt;script src=\"\u2026\"&gt;</code> externo o un <code>&lt;script&gt;</code> normal con c\u00f3digo.</p> <p>El ejemplo anterior se puede dividir en dos scripts para que funcione:</p> <pre><code>&lt;script src=\"file.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nalert(1);\n&lt;/script&gt;\n</code></pre>"},{"location":"bloque_i/tema_1/page-3/#orden-de-insercion","title":"Orden de inserci\u00f3n","text":"<p>En un mismo documento HTML, podemos tener diferentes etiquetas Javascript, en la parte del documento que m\u00e1s nos interesa. Es importante recalcar que el orden de utilizaci\u00f3n de esta etiqueta, ya que HTML se ejecuta de forma secuencial, es decir, l\u00ednea a l\u00ednea. Por ejemplo, si tenemos un documento HTML con un elemento <code>h1</code> y un script que trabaje con dicho <code>h1</code>, no es recomendable que el script se ejecute antes del <code>h1</code> ya que no puede tener acceso a dicho elemento, porque cuando se ejecute la l\u00ednea, este elemento a\u00fan no existe.</p> <p>Por este motivo, se recomienda insertar las librer\u00edas JAvascript en el <code>head</code> del documento, y las instrucciones que trabajen con el DOM como \u00faltima instrucci\u00f3n dentro de la etiqueta <code>body</code>.</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;!--...--&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Hello world&lt;/h1&gt;\n&lt;script&gt;\nconsole.log('Hello world')\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>En el ejemplo anterior, primero se mostrar\u00e1 el <code>h1</code> y luego se ejecutar\u00e1 y se mostrar\u00e1 el mensaje del <code>console.log()</code>.</p>"},{"location":"bloque_i/tema_1/page-3/#etiqueta-noscript","title":"Etiqueta noscript","text":"<p>En ciertas ocasiones, el navegador no es compatible con Javascript (cosa poco probable) o tiene desactivada la opci\u00f3n de Javascript en el navegador.</p> <p>La etiqueta <code>&lt;noscript&gt;</code> muestra un contenido alternativo para los usuarios que tiene desactivada la opci\u00f3n en su navegador o no es compatible.</p> <pre><code>&lt;script&gt;\nconsole.log(\"Hello World!\")\n&lt;/script&gt;\n&lt;noscript&gt;Your browser does not support JavaScript!&lt;/noscript&gt;\n</code></pre>"},{"location":"bloque_i/tema_2/page-1/","title":"1 Estructura del c\u00f3digo","text":""},{"location":"bloque_i/tema_2/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Las instrucciones de Javascript se pueden a\u00f1adir a un fichero de extensi\u00f3n <code>.js</code> e importarlo o directamente escribirlo en el documento a trav\u00e9s de la etiqueta <code>&lt;script&gt;&lt;/script&gt;</code>.</p> <p>Es importante destacar que el c\u00f3digo son las l\u00edneas del fichero que emiten ordenes para ser ejecutadas.</p>"},{"location":"bloque_i/tema_2/page-1/#sentencia","title":"Sentencia","text":"<p>Las sentencias son construcciones sint\u00e1cticas y comando que realiza acciones. Una sentencia es la unidad m\u00ednima de ejecuci\u00f3n de un programa. Un programa se compone de conjunto de sentencias que acaban resolviendo un problema.</p> <p>En nuestro c\u00f3digo, puede haber tantas sentencias como sea necesarias separadas por un punto y coma <code>;</code> o un salto de l\u00ednea.</p> <p>Tips</p> <p>Se aconseja que las sentencias se escriban separadas en l\u00ednea, para as\u00ed tener una mayor legibilidad del c\u00f3digo y facilitar as\u00ed su entendimiento.</p> <p>Veamos ejemplos de sentencias:</p> <pre><code>console.log('Mi primera sentencia');\nconsole.log('Mi segunda sentencia, pero no termina en punto y coma')\nconsole.log('\u00daltima sentencia de este script')\n</code></pre> <p>\u00a1CUIDADO!</p> <p>En la mayor\u00eda de los casos, un salto de l\u00ednea implica un punto y coma de forma impl\u00edcita, pero en NO siempre es as\u00ed. Podemos tener una sentencia y querer escribirla en diferentes l\u00edneas, el int\u00e9rprete sobre entiende que dicho salto de l\u00ednea no es un punto y como impl\u00edcito, si no una separaci\u00f3n normal, por lo que se ejecutar\u00eda la sentencia tal y como se desea:</p> <pre><code>console.log(3\n+\n2);\n</code></pre> <p>En el ejemplo anterior la salida es <code>5</code>, que es el resultado de sumar <code>3 + 2</code></p> <p>Hay que tener cuidado, porque en cierta ocasiones un salto de l\u00ednea no implica un punto y coma impl\u00edcito, sino que por el contrario se entiende como una separaci\u00f3n de c\u00f3digo y es algo que no el desarrollador no ha contemplado. Para dicho caso, se recomienda separar las l\u00edneas de c\u00f3digo con un punto y coma expl\u00edcito <code>;</code>. Veamos un ejemplo:</p> <pre><code>console.log('Hola mundo')\n[1, 2].forEach(console.log) // (1)!\n</code></pre> <ol> <li>\u274cEsto da error, porque se intenta ejecutar de la siguiente manera <code>console.log('Hola mundo')[1, 2].forEach(console.log)</code>, es decir, como una \u00fanica sentencia en lugar de dos.\u274c</li> </ol> <p>Para evitar el error anterior, se debe colocar punto y coma en la l\u00ednea que da problemas, y as\u00ed indicar que se trata de m\u00e1s de una sentencia:</p> <pre><code>console.log('Hola mundo');\n[1, 2].forEach(console.log)\n</code></pre> <p>Tips</p> <p>Es cierto que en la comunidad existen dos tipos de personas, los que utilizan el punto y coma en cada sentencia, o los que usa un salto de l\u00ednea en su lugar. Cada uno debe usar la t\u00e9cnica que mejor le parezca, pero siempre y cuando se intente evitar los errores mencionados anteriormente,</p>"},{"location":"bloque_i/tema_2/page-1/#comentarios","title":"Comentarios","text":"<p>Los comentarios son parte del c\u00f3digo que NO van a ser ejecutadas y se utilizan para dar informaci\u00f3n extra del c\u00f3digo que se esta desarrollando. Pueden ir escritos en cualquier lugar del script y son ignoradas por el motor (int\u00e9rprete) del navegador, por lo que el usuario no podr\u00e1 visualizarlos. Existen dos tipos de comentarios:</p> <ul> <li> <p>Comentarios en l\u00ednea: Solo ocupan un l\u00ednea y suelen usarse para comentarios puntuales y breves. Comienzan con dos barras diagonales <code>//</code>:</p> <pre><code>// Este es mi primer comentario en l\u00ednea\nconsole.log('Hey!')\n</code></pre> </li> <li> <p>Comentarios en bloque: Ocupan varias l\u00edneas y suelen usarse para comentarios m\u00e1s extensos. Comienzan con una barra inclinada y un asterisco <code>/*</code> y terminan con un asterisco y una barra inclinada <code>*/</code>:</p> <pre><code>/*\nEste es \nmi primer\ncomentario en \nbloque.\n*/\nconsole.log('Hey!')\n</code></pre> </li> </ul> <p>Los comentarios son una parte esencial del c\u00f3digo ya que proveen informaci\u00f3n sobre el mismo y ayudan a recordarnos a nosotros mismos porque decimos escribir dicho c\u00f3digo, adem\u00e1s de que si el c\u00f3digo es creado en grupo, ayuda a que todo el equipo entienda cual es nuestro objetivo con \u00e9l.</p> <p>Sin embargo, no se recomienda usar los comentarios para informaci\u00f3n personal, como contrase\u00f1as, ya que desde DevTools se puede acceder al script completo incluyendo los comentarios. Existen ciertas herramientas que para evitar eso, minimizan los scripts, eliminando los comentarios, que es lo recomendados antes de la publicaci\u00f3n de nuestra aplicaci\u00f3n.</p> <p>Warning</p> <p>No se permite escribir comentarios anidados, y en caso de intentarlo, ser\u00eda lanzado un error:</p> <pre><code>/*\n  /* comentario anidado ?!? */\n*/\nconsole.log( 'Mundo' );\n</code></pre>"},{"location":"bloque_i/tema_2/page-1/#expresiones","title":"Expresiones","text":"<p>Una expresi\u00f3n es una combinaci\u00f3n de operadores y operandos que se eval\u00faa gener\u00e1ndose un \u00fanico resultado de un tipo determinado.</p> <pre><code>console.log(3 + 2);\n</code></pre> <p>La diferencia entre las sentencias y las expresiones es que las expresiones devuelven un valor y las sentencias no devuelven nada.</p>"},{"location":"bloque_i/tema_2/page-1/#bloque","title":"Bloque","text":"<p>Un bloque es un conjunto de sentencias las cuales est\u00e1n delimitadas por llaves:</p> <pre><code>{\n// sentencias\n}\n</code></pre>"},{"location":"bloque_i/tema_2/page-2/","title":"2 Modo estricto","text":""},{"location":"bloque_i/tema_2/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Durante mucho tiempo, JavaScript evolucion\u00f3 sin problemas de compatibilidad. Se a\u00f1ad\u00edan nuevas caracter\u00edsticas al lenguaje sin que la funcionalidad existente cambiase.</p> <p>Esto ten\u00eda el beneficio de nunca romper c\u00f3digo existente, pero lo malo era que cualquier error o decisi\u00f3n incorrecta tomada por los creadores de JavaScript se quedaba para siempre en el lenguaje.</p> <p>Esto fue as\u00ed hasta 2009, cuando ECMAScript 5 (ES5) apareci\u00f3. Esta versi\u00f3n a\u00f1adi\u00f3 nuevas caracter\u00edsticas al lenguaje y modific\u00f3 algunas de las ya existentes. Entre ellas el uso estricto.</p>"},{"location":"bloque_i/tema_2/page-2/#use-strict","title":"use-strict","text":"<p>El use-strict es una nueva directiva del ES5 que indica que el c\u00f3digo debe ejecutarse en modo estricto. Todos los navegadores modernos admiten el use-strict, excepto Internet Explorer 9 y versiones anteriores.</p> <p>Para poder declarar el modo estricto, se puede realizar de dos formas:</p> <ul> <li> <p>Alcance global. Se usa el modo estricto en todo el script. Para ello, debe ser declarado como la primera sentencia de nuestro script.</p> <pre><code>\"use strict\"\nconsole.log('Hello world')\n</code></pre> </li> <li> <p>Alcance local. Se usa el modo estricto \u00fanicamente en la funci\u00f3n indicada. Para ello, debe ser declarado como la primera sentencia de nuestra funci\u00f3n.</p> <pre><code>console.log('Hello world')\nfunction con(){\n'use strict'\nconsole.log('This is a function')\n}\n</code></pre> </li> </ul> <p>!!! danger '!OJO!'</p> <pre><code>Si se desea un alcance global y se declara el modo estricto en una l\u00ednea diferente a la primera, el modo estricto es completamente ignorado:\n\n```javascript\nconsole.log('Hello world')\n\n'use strict' // \u274c No funciona\n```\n</code></pre> <p>El uso del modo estricto permite la escritura de c\u00f3digo Javascript de forma segura. Javascript es un lenguaje ampliamente flexible, lo que en ciertas ocasiones puede resultar peligroso. Al hacer uso del modo estricto podemos evitar que algunos de esos error se lleguen a cometer. Por ejemplo, en Javascript se puede usar una variable sin ser declarada previamente, lo que por defecto no se mostrar\u00e1 como un error al programador. Sin embargo, con el modo estricto dicha mala pr\u00e1ctica ser\u00e1 marcada como un error.</p>"},{"location":"bloque_i/tema_2/page-2/#prohibiciones-del-modo-estricto","title":"Prohibiciones del modo estricto","text":"<p>El modo estricto tiene cierta prohibiciones, es decir, cosas que con Javascript normal no se lanzar\u00eda un error, pero con el modo estricto s\u00ed. Varios de los conceptos descritos a continuaci\u00f3n, a\u00fan no han sido tratados, por lo que se recomienda visitar este apartado con cierta regularidad.</p> <p>Entre sus prohibiciones podemos encontrar:</p> <ul> <li> <p>No permite usar ni una variable ni un objeto sin declararlo.</p> <pre><code>x = 3.14 //\u274c\n</code></pre> </li> <li> <p>No permite eliminar ni una variable ni un objeto ni una funci\u00f3n.</p> <pre><code>let x = 3.14\ndelete x // \u274c\n</code></pre> </li> <li> <p>No se permite duplicar el nombre de un par\u00e1metro de una funci\u00f3n.</p> <pre><code>function myFunction(x1, x1){} //\u274c\n</code></pre> </li> <li> <p>No se permite literales num\u00e9ricos octales, ni caracteres de escape octal.</p> <pre><code>let x = 010 // \u274c\nlet x = \"\\010\" // \u274c\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_2/page-2/#se-deberia-usar","title":"\u00bfSe deber\u00eda usar?","text":"<p>Aunque la pregunta parece obvia, ciertamente no lo es. Se recomienda el uso de <code>use strict</code>, pero es cierto que las librer\u00edas actuales de Javascript tienen habilitada autom\u00e1ticamente esta opci\u00f3n, por lo que no ser\u00eda necesario que fuera usado expl\u00edcitamente por nosotros. Adem\u00e1s, las clases y m\u00f3dulos de Javascript tambi\u00e9n tienen activada dicha opci\u00f3n por defecto, por lo que tampoco ser\u00eda necesario.</p> <p>Tips</p> <p>Se recomienda que durante el desarrollo de Javascript b\u00e1sico si exista la posibilidad de usar el modo estricto, y una vez avanzado a las clases y m\u00f3dulos, dejar de usarlo.</p>"},{"location":"bloque_i/tema_2/page-3/","title":"3 Variables y constantes","text":""},{"location":"bloque_i/tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>A la largo del desarrollo de un script es necesario utilizar cierta informaci\u00f3n de forma repetida, por lo que es \u00fatil poder almacenar dicha informaci\u00f3n y poder usarlo en las partes del c\u00f3digo en las que sean necesarias.</p> <p>En programaci\u00f3n, existen las variables y las constantes para desempe\u00f1ar dicha funci\u00f3n.</p>"},{"location":"bloque_i/tema_2/page-3/#variables","title":"Variables","text":"<p>Las variables son contenedores que sirven para almacenar los datos que utiliza un programa. Dicho m\u00e1s sencillamente, son nombres que asociamos a determinados datos. La realidad es que cada variable ocupa un espacio en la memoria RAM del ordenador para almacenar el dato al que se refiere. Es decir, cuando utilizamos el nombre de la variable realmente estamos haciendo referencia a un dato que est\u00e1 en memoria.</p> <p>En Javascript existen dos limitaciones para nombrar a una variable:</p> <ol> <li>El nombre \u00fanicamente puede incluir letras, d\u00edgitos o los s\u00edmbolos <code>$</code> y <code>_</code>. Ejemplo: <code>$var</code>, <code>_var</code>, <code>var123</code>.</li> <li>El primer car\u00e1cter no puede ser un d\u00edgito. Ejemplo err\u00f3neos: <code>1var</code>.</li> </ol> <p>Se recomienda hacer uso de nombres descriptivos pero breves. La elecci\u00f3n de un nombre de variable debe ser mnem\u00f3nico, es decir, dise\u00f1ado para indicar al observador casual la intenci\u00f3n de su uso. Por ejemplo, si queremos usar una variable para almacenar una edad, la llamaremos <code>edad</code>. Adem\u00e1s se deber\u00eda evitar los nombres de variables de un solo car\u00e1cter excepto para las variables temporales usar y tirar. Los nombres comunes de las variables temporales son <code>i</code>, <code>j</code>, <code>k</code>, <code>m</code>, y <code>n</code> para enteros; <code>c</code>, <code>d</code>, y <code>e</code> para los caracteres.</p> <p>El estilo del nombre de las variables suele camelCase (o lowerCamelCase), es decir, las palabras van seguidas una detr\u00e1s de otra, con cada inicial en may\u00fascula, excepto la primera que va en min\u00fascula: <code>miPrimeraVariable</code>.</p> <p>Warning</p> <p>Es importante tener en cuenta la capitalizaci\u00f3n, ya que el mismo nombre escrito de formas diferentes da a lugar a dos variables distintas. <code>manzana</code> y <code>MANZANA</code> son dos variables distintas a pesar de tener el mismo nombre.</p> <p>Javascript permite escribir letras de cualquier alfabeto incluyendo letras del cir\u00edlico, logogramas chinos, etc., incluso nuestra letra <code>\u00f1</code>, pero no se recomienda su uso ya que existe una tradici\u00f3n internacional de utilizar ingl\u00e9s en el nombramiento de variables. Incluso si estamos escribiendo un script peque\u00f1o, este puede tener una larga vida por delante. Puede ser necesario que gente de otros pa\u00edses deba leerlo en alg\u00fan momento.</p> <p>Otra prohibici\u00f3n a tener en cuenta a la hora de nombra variables es que no se pueden utilizar palabras que usa el mismo lenguaje. Estas palabras son denominadas como palabras reservadas. Por ejemplo, no se puede usar la palabra <code>let</code> como nombre de variable. En la siguiente web, puedes conocer el listado oficial de este tipo de palabras: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords</p>"},{"location":"bloque_i/tema_2/page-3/#declaracion-de-una-variable","title":"Declaraci\u00f3n de una variable","text":"<p>Para declarar una variable es necesario usar la palabra <code>let</code> seguida del nombre de la variable:</p> <pre><code>let miPrimeraVariable\n</code></pre> <p>Se puede inicializar una variable, o cambiar el valor de la misma haciendo uso del operador <code>=</code>:</p> <pre><code>miPrimeraVariable = 10\n</code></pre> <p>Adem\u00e1s, se puede acceder a dicha variable usando su nombre:</p> <pre><code>let message message = 'Hello world'\nconsole.log(message)\n</code></pre> <p>Javascript permite definir una variable, es decir, declarar e inicializar una variable en una \u00fanica l\u00ednea:</p> <pre><code>let message = \"hello world\"\n</code></pre> <p>Tambi\u00e9n se puede definir y declarar varias variables en una sola l\u00ednea, separadas por coma <code>,</code>:</p> <pre><code>let name = 'John Doe', age = 25, message = 'Hello world'\n</code></pre> <p>Lo anterior, se podr\u00eda hacer en m\u00faltiples l\u00ednea, aunque no se recomienda:</p> <pre><code>let name = 'John Doe', age = 25, message = 'Hello world'\n</code></pre> <p>Tips</p> <p>Por norma general, se recomienda definir o declarar las variables en l\u00edneas diferentes con diferentes <code>let</code>. Aunque, es cierto que si son pocas variables y con informaci\u00f3n f\u00e1cil de leer, se podr\u00eda usar la forma m\u00faltiple lineal sin problema.</p> <p>Warning</p> <p>Declarar dos veces la misma variable produce un error de ejecuci\u00f3n.</p> <pre><code>let message = \"This\";\nlet message = \"That\"; // SyntaxError: 'message' ya fue declarado\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#funcionamiento-de-una-variable","title":"Funcionamiento de una variable","text":"<p>Podemos entender una variable como una caja que se encarga de almacenar informaci\u00f3n relevante para nuestro c\u00f3digo. Cuando una variable es declarada (no inicializada), estamos creando dicha caja, y una vez inicializada, almacenamos en la caja el valor correspondiente. Cuando una variable es modificada, su valor actual es eliminado de la caja y se inserta el nuevo valor en ella. Veamos un ejemplo:</p> <pre><code>let message //(1)!\nmessage = 'Hello world' //(2)!\nmessage = 'Goodbye' //(3)!\n</code></pre> <ol> <li>Se crea la caja para almacenar informaci\u00f3n.</li> <li>Se almacena el valor Hello World por primera vez en la caja.</li> <li>Se elimina el valor Hello World y se a\u00f1ade el nuevo valor Goodbye.</li> </ol> <p>Esto en realizar se refiere a que cuando creamos una variable, se reserva un espacio de memoria y al inicializarla se escribe el dato deseado en su interior. Cuando se modifica, ese dato se elimina y se sobreescribe el nuevo valor.</p>"},{"location":"bloque_i/tema_2/page-3/#ambito-de-vida-de-las-variables","title":"\u00c1mbito de vida de las variables","text":"<p>Toda variable tiene un \u00e1mbito de vida. Esto es la parte del c\u00f3digo en la que una variable se puede utilizar, que es en el bloque donde se ha declarado. De hecho las variables tienen un ciclo de vida:</p> <ol> <li>En la declaraci\u00f3n se reserva el espacio necesario para que se puedan comenzar a utilizar (digamos que se avisa de su futura existencia)</li> <li>Se la asigna su primer valor (la variable nace)</li> <li>Se la utiliza en diversas sentencias. Cuando finaliza el bloque en el que fue declarada, la variable muere. Es decir, se libera el espacio que ocupa esa variable en memoria.</li> <li>Una vez que la variable ha sido eliminada, no se puede utilizar. Dicho de otro modo, no se puede utilizar una variable m\u00e1s all\u00e1 del bloque en el que ha sido definida. Ejemplo:</li> </ol> <p>Podemos entender que una variable puede tener un \u00e1mbito de vida local o global. Podemos entender como una variable global, como aquella variable que puede ser accedida desde cualquier parte de nuestro script, es decir, la variable es declarada en el script y puede ser usada tanto dentro como fuera de cualquier bloque.</p> <pre><code>let number = 10\nconsole.log(number)\n</code></pre> <p>Por el contrario, una variable local es una variable que se declara dentro de un bloque y solo puede ser usada en dicho bloque y nunca fuera de \u00e9l:</p> <pre><code>{\nlet number = 10\nconsole.log(number)\n}\nconsole.log(number) // \u274c ReferenceError: number is not defined\n</code></pre> <p>Warning</p> <p>Normalmente, debemos definir una variable antes de utilizarla. Pero, en los viejos tiempos, era t\u00e9cnicamente posible crear una variable simplemente asignando un valor sin utilizar <code>let</code>. Esto a\u00fan funciona si no hacemos uso de <code>use strict</code> en nuestros scripts para mantener la compatibilidad con scripts antiguos.</p> <pre><code>num = 5; // se crea la variable \"num\" si no existe antes\nalert(num); // 5\n</code></pre> <p>Esto ser\u00eda una mala pr\u00e1ctica que se puede evitar haciendo del modo estricto:</p> <pre><code>\"use strict\";\nnum = 5; // \u274c error: num no est\u00e1 definida\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#constantes","title":"Constantes","text":"<p>Una constante es un valor que no puede ser modificado durante la ejecuci\u00f3n de un programa, \u00fanicamente puede ser le\u00eddo. Para crear una constante en Javascript se usa la palabra reservada <code>const</code> seguida del nombre de la variable y su inicializaci\u00f3n:</p> <pre><code>const miPrimeraConstante = 10\n</code></pre> <p>Al intentar modificar el valor de una variable producir\u00eda un error:</p> <pre><code>const miPrimeraConstante = 10\nmiPrimeraConstante = 20 // \u274c ERROR\n</code></pre> <p>Tips</p> <p>Existe una buena pr\u00e1ctica de escribir en may\u00fasculas y con guiones <code>_</code>, aquellas constantes que hacen referencia a ciertos datos que son dif\u00edciles de recordar, como por ejemplo el c\u00f3digo hexadecimal de un color:</p> <pre><code>const COLOR_RED = \"#F00\";\nconst COLOR_GREEN = \"#0F0\";\nconst COLOR_BLUE = \"#00F\";\nconst COLOR_ORANGE = \"#FF7F00\";\n</code></pre> <p>De esta forma podemos acceder al color rojo de una manera m\u00e1s sencilla usando su nombre de constante.</p> <p>Se aconseja escribir en may\u00fasculas aquellas constantes cuyo valor se conocen antes la ejecuci\u00f3n del programa y en min\u00fasculas aquellas cuyo valor se deben calcular u obtener durante la ejecuci\u00f3n:</p> <pre><code>const NAME = 'Server name'\nconst div = /*...*/\n</code></pre> <p>En el ejemplo anterior, la variable <code>NAME</code> se escribe en may\u00fasculas ya que es un valor que se conoce antes de ejecutar el script. Sin embargo, la variable <code>div</code> representa un elemento div del HTML por lo que no es un valor que se obtiene antes de la ejecuci\u00f3n del programa, sino que, por el contrario debe ser obtenido una vez se haya ejecutado el programa.</p>"},{"location":"bloque_i/tema_2/page-3/#var","title":"var","text":"<p>\u00a1OJO!</p> <p>La informaci\u00f3n transcrita en el siguiente punto tiene como objetivo \u00fanico INFORMAR sobre ciertos conocimientos antiguos de Javascript, por lo que NO se deber\u00edan llevar a la pr\u00e1ctica.</p> <p>La palabra reservada <code>var</code> se utilizaba en versiones anteriores de Javascript y tiene una utilizaci\u00f3n bastante similar a la palabra reservada <code>let</code>. Sin embargo, declarar una variable con <code>var</code> tiene ciertos usos peligrosos que fueren limitados con la incorporaci\u00f3n de <code>let</code>.</p> <p>Cuando declaramos una variable con <code>let</code> de forma global en nuestro script, dicha variable puede ser usada en cualquier parte de nuestro script, por lo que no se puede acceder a ella desde otros script (en caso de tener m\u00e1s de una etiqueta script en nuestro HTML, o diferentes m\u00f3dulos).</p> <pre><code>&lt;script&gt;\nlet number = 10\n&lt;/script&gt;\n&lt;script&gt;\n'use strict'\nconsole.log(number) // \u274c ERROR\n&lt;/script&gt;\n</code></pre> <p>Sin embargo, haciendo uso de la palabra <code>var</code>, esto si puede suceder, de forma que se puede declarar una variable en un script y poder usarlo en cualquier cualquier otro script, y en cualquier parte de nuestro c\u00f3digo, incluso si se declara dentro de un bloque:</p> <pre><code>&lt;script&gt;\n{\nvar number = 10\n}\n&lt;/script&gt;\n&lt;script&gt;\n'use strict'\nconsole.log(number)\n&lt;/script&gt;\n</code></pre> <p>Lo que ocurre en el ejemplo, no es una buena pr\u00e1ctica ya que exponemos a que nuestras variables sean modificadas desde cualquier parte, dentro o fuera de nuestro script.</p> <p>Otra de las malas pr\u00e1cticas que tiene el uso de <code>var</code>, es que permite redeclarar una variable, cosa que con el uso de <code>let</code> se ve limitado ya que lanza un error:</p> <pre><code>let number = 10\nlet number = 20 // \u274c ERROR\nvar number = 10\nvar number = 20\n</code></pre> <p>En este caso, se ignora la declaraci\u00f3n y \u00fanicamente se cambia su valor.</p> <p>Otra de las malas pr\u00e1cticas que tiene su uso es el hoisting (elevamiento). Permite inicializar la variable incluso antes de su declaraci\u00f3n, ya que no importa en el lugar que se declare porque siempre va a ser elevada al principio. Veamos un ejemplo:</p> <pre><code>phrase = \"Hello\";\nconsole.log(phrase);\nvar phrase;\n</code></pre> <p>En el c\u00f3digo anterior, permite inicializar la variable, y luego se declarar, aunque en realizar lo primero que se ejecuta es la declaraci\u00f3n debido al elevamiento. Esto puede provocar una dif\u00edcil legibilidad. El c\u00f3digo anterior, se ejecutar\u00eda de esta forma:</p> <pre><code>var phrase;\nphrase = \"Hello\";\nconsole.log(phrase);\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Crea un script que realice los siguientes pasos:</p> <ol> <li>Declara dos variables: <code>admin</code> y <code>name</code>.</li> <li>Asigna el valor John a la variable <code>name</code>.</li> <li>Copia el valor de <code>name</code> en <code>admin</code>.</li> <li>Muestra por consola el valor de la variable <code>admin</code>, en color verde.</li> </ol> Ejercicio 2 <p>\u00bfC\u00f3mo nombrar\u00edas las siguientes variables?:</p> <ul> <li>Nombre actual del usuario que ha iniciado sesi\u00f3n en nuestra web.</li> <li>Nombre de nuestro planeta.</li> <li>Tiempo transcurrido desde el comienzo de una tarea, hasta su finalizaci\u00f3n.</li> <li>Fecha de nacimiento de un empleado.</li> <li>Capacidad m\u00e1xima de un disco duro.</li> <li>Capacidad ocupada de un disco duro.</li> <li>Capacidad sobrante de un disco duro.</li> </ul> Ejercicio 3 <p>Dado el siguiente c\u00f3digo, \u00bfcu\u00e1l dir\u00edas que deber\u00eda ir en may\u00fasculas? Justifica tu respuesta:</p> <pre><code>const birthday = '18.04.1982';\nconst age = calculateAgeFromDate(birthday);\n</code></pre>"},{"location":"bloque_i/tema_2/page-4/","title":"4 Tipos de datos b\u00e1sicos","text":""},{"location":"bloque_i/tema_2/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Javascript es un lenguaje tipado d\u00e9bil, es decir, no te obliga a indicar el tipo de las variables a la hora de declararlas. Sin embargo, esto no quiere decir que una variable no sea de un tipo especificado y que es bueno conocer los tipos de datos con los que se va a trabajar.</p> <p>Javascript tambi\u00e9n es un lenguaje din\u00e1micamente tipado. Esto quiere decir, que una variable puede ser declarada como un tipo, por ejemplo una cadena, y durante la ejecuci\u00f3n del programa puede pasar a ser un n\u00famero.</p> <pre><code>let variable = \"Hello\"\nvariable = 123\n</code></pre> <p>Aunque esto pueda parecer un gran acierto en Javascript, es cierto, que en ciertas ocasiones puede ser un problema, dependiendo de la utilidad que se le quiera dar a dicha variable. Por ejemplo, si queremos hacer una divisi\u00f3n, debemos disponer de dos n\u00fameros, si ahora bien, uno de esos n\u00fameros son introducidos por el usuario y \u00e9ste introduce una cadena, la operaci\u00f3n no ser\u00eda v\u00e1lida. Por ello, es recomendable realizar comprobaciones de tipo cuando sea necesario</p> <p>Existen ocho tipos de datos b\u00e1sicos diferentes en Javascript: <code>Number</code>, <code>BigInt</code>, <code>String</code>, <code>Boolean</code>, <code>null</code>, <code>undefined</code>, <code>Object</code> y <code>Symbol</code>. Adem\u00e1s, tambi\u00e9n existen otras estructuras de datos como las clases y los arrays.</p>"},{"location":"bloque_i/tema_2/page-4/#number","title":"Number","text":"<p>El tipo <code>number</code> representa los n\u00fameros en Javascript, tanto los n\u00fameros enteros, como los n\u00fameros de punto flotantes (decimales). El tipo <code>number</code> representa los n\u00fameros <code>+(2\u2075\u00b3+1)</code> y <code>-(2\u2075\u00b3-1)</code>.</p> <pre><code>let number = 2\nlet decimal = 1.60\n</code></pre> <p>Adem\u00e1s de los n\u00fameros comunes, existen los denominados valores num\u00e9ricos especiales que pertenecen a este tipo y representan un valor matem\u00e1tico especial:</p> <ul> <li><code>Infinity</code>. Representa el infinito matem\u00e1tico (<code>\u267e\ufe0f</code>). Es un n\u00famero especial que es mayor que cualquier otro n\u00famero. Haciendo uso del operador <code>-</code>, existir\u00e1 el <code>-Infinity</code> que representa el infinito negativo, siendo un n\u00famero m\u00e1s peque\u00f1o que cualquier otro. Este n\u00famero puede ser obtenido al dividir un n\u00famero entre 0.</li> <li> <p><code>NaN</code>. Representa un error de c\u00e1lculo. Es el resultado de un operaci\u00f3n matem\u00e1tica incorrecta o indefinida. Por ejemplo, es el resultado de dividir una cadena a un n\u00famero. Las siglas NaN significan Not a Number (No es n\u00famero), por lo que indica que el resultado de un operaci\u00f3n matem\u00e1tica que espera un n\u00famero no retorna el tipo esperado. Cualquier operaci\u00f3n que se haga con un operando de valor <code>NaN</code>, tambi\u00e9n devuelve un <code>NaN</code>, excepto <code>NaN ** 0 = 1</code>.</p> <p>Info</p> <p>Las operaciones matem\u00e1ticas, en Javascript, son operaciones seguras. A diferencia de otros lenguajes, como en Java, cuando se realizan operaciones vulnerables (dividir por cero, dividir una cadena por un n\u00famero) no lanza un error fatal, si no que por el contrario, si no que retorna un valor especial matem\u00e1tico como <code>NaN</code> o <code>Infinity</code>, salvaguardando as\u00ed el flujo de la aplicaci\u00f3n.</p> </li> </ul>"},{"location":"bloque_i/tema_2/page-4/#bigint","title":"BigInt","text":"<p>EL tipo <code>BigInt</code> representan n\u00fameros enteros de tama\u00f1o superior a <code>\u00b1(2\u2075\u00b3-1)</code>. Este tipo de n\u00famero existe, porque cuando se intenta realizar una operaci\u00f3n con <code>number</code> cuyo resultado quede fuera de dicho rango, habr\u00e1 un error de precisi\u00f3n:</p> <pre><code>console.log(9007199254740991 + 1); // 9007199254740992\nconsole.log(9007199254740991 + 2); // 9007199254740992\n</code></pre> <p>Para la mayor\u00eda de los prop\u00f3sitos, el rango de tipo <code>number</code> es suficiente, sin embargo a veces es necesario n\u00fameros realmente grandes, como para la criptograf\u00eda o estudios cient\u00edficos.</p> <p><code>BigInt</code> fue agregado recientemente a Javascript para solventar dicho problema de precisi\u00f3n. Para indicar que un n\u00famero es de tipo <code>BigInt</code> o no de tipo <code>number</code> se debe agregar una <code>n</code> al final de n\u00famero:</p> <pre><code>const bigInt = 1234567890123456789012345678901234567890n\n</code></pre>"},{"location":"bloque_i/tema_2/page-4/#string","title":"String","text":"<p>El tipo de dato <code>String</code> representa una cadena de caracteres y debe colocarse entre comillas:</p> <pre><code>const str = \"Soy una cadena\"\n</code></pre> <p>En Javascript se puede inicializar una cadena haciendo uso de tres tipos de comillas diferentes:</p> <ul> <li>Comillas dobles: <code>\"Hola\"</code>.</li> <li>Comillas simples: <code>'Hola'</code></li> <li>Comillas invertidas (backticks): <code>`Hola`</code></li> </ul> <p>Entre las comillas dobles y las comillas simples no existen diferencias entres ellas, simplemente sirven para mostrar literalmente el contenido de la cadena. Por ejemplo, si tengo la variable <code>sum = \"2+3\"</code> el valor de la variable es literalmente <code>2+3</code> y no <code>5</code>, que es el resultado de la suma.</p> <p>Por otro lado, las comillas backticks son comillas de funcionalidad extendida, es decir, nos permiten incrustar variables y expresiones de tal formal que el valor de la cadena sea el valor de la variable o expresi\u00f3n. Para ello, la variable o la expresi\u00f3n debe estar envuelta en <code>${...}</code>:</p> <pre><code>let name = \"John\"\nlet lastName = \"Doe\"\nlet fullName = `${name} ${lastName}`\nconsole.log(fullName) // \"John Doe\"\nlet number1 = 2\nlet number2 = 3\nlet result = `Result is ${number1 + number2}`\nconsole.log(result) // \"Result is 5\"\n</code></pre> <p>La expresi\u00f3n dentro de <code>${...}</code> se eval\u00faa y el resultado pasa a formar parte de la cadena. Podemos poner cualquier cosa ah\u00ed dentro: una variable como <code>name</code>, una expresi\u00f3n aritm\u00e9tica como <code>1 + 2</code>, o algo m\u00e1s complejo.</p> <p>Warning</p> <p>El uso de <code>${...}</code> solo se puede realizar con las backticks para el resto de comillas no funcionaria, ya que solo muestra el resultado literal:</p> <pre><code>const name = \"John\"\nconst lastName = \"Doe\"\nconst fullName = \"${name} ${lastName}\"\nconsole.log(fullName) // \"${name} ${lastName}\"\n</code></pre> <p>Info</p> <p>En algunos lenguajes, hay un tipo especial car\u00e1cter para un solo car\u00e1cter. Por ejemplo, en el lenguaje C y en Java es char.</p> <p>En JavaScript no existe tal tipo. S\u00f3lo hay un tipo: <code>string</code>. Un string puede estar formado por un solo car\u00e1cter, por ninguno, o por varios de ellos. </p> <p>Es importante conocer este dato, porque en ocasiones es necesario obtener solo un car\u00e1cter y el usuario es libre de introducir una cadena m\u00e1s ampl\u00eda, por lo que debe ser validado correctamente.</p>"},{"location":"bloque_i/tema_2/page-4/#boolean","title":"Boolean","text":"<p>El tipo <code>boolean</code> hace referencia a los valores <code>true</code> y <code>false</code>. Este tipo es usado com\u00fanmente para almacenar valores afirmativos (true) o negativos (false). Por ejemplo, s\u00ed, correcto, verdadero ser\u00edan formas de representar el valor <code>true</code>, mientras que no, incorrecto y falso para representar el valor <code>false</code>.</p> <pre><code>const isLegalAge = true\nconst isUserLogged = false\n</code></pre> <p>Los valores booleanos tambi\u00e9n son los resultados de realizar comparaciones, como veremos m\u00e1s adelante. Por ejemplo, <code>3 &gt; 4</code> ser\u00eda false ya que el n\u00famero 3 no es mayor que el n\u00famero 4.</p>"},{"location":"bloque_i/tema_2/page-4/#null","title":"null","text":"<p>En Javascript, el valor <code>null</code> hace referencia a un objeto inexistente. S\u00f3lo es un valor especial que representa nada, vac\u00edo o valor desconocido.</p> <pre><code>const age = null;\n</code></pre> <p>En el c\u00f3digo anterior, la variable <code>age</code> tiene un valor vac\u00edo o desconocido por que a\u00fan no ha sido calculado o est\u00e1 en espera de ser introducido.</p>"},{"location":"bloque_i/tema_2/page-4/#undefined","title":"undefined","text":"<p>En Javascript, cuando una variable es declarada pero no definida se dice que es de tipo <code>undefined</code> que literalmente significa no definida.</p> <p>La diferencia con <code>null</code>, es que el tipo <code>undefined</code> quiere decir que la caja que va a contener el valor a\u00fan no ha sido definida como tal, mientras que con <code>null</code>, la caja ha sido definida pero est\u00e1 completamente vac\u00eda.</p> <p>Aunque se puede asignar a una variable el valor <code>undefined</code> es algo que por legibilidad de c\u00f3digo no se recomienda. Para ello, se recomienda hacer uso del tipo <code>null</code>.</p> <p>Tanto <code>undefined</code> y <code>null</code> son tipos propios de Javascript.</p>"},{"location":"bloque_i/tema_2/page-4/#ejercicios","title":"Ejercicios","text":"Ejercicio 4 <p>\u00bfCu\u00e1l es la salida del siguiente script?</p> <pre><code>let name = \"Ilya\"\nconsole.log( `Hola ${1}` )    console.log( `Hola ${\"name\"}` )    console.log( `Hola ${name}` )\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/","title":"5 Operadores","text":""},{"location":"bloque_i/tema_2/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Los operadores son s\u00edmbolos que se utilizan para evaluar un expresi\u00f3n y as\u00ed devuelva un resultado. Por ejemplo, el operador <code>+</code> sirve para evaluar una suma y que as\u00ed devuelva un n\u00famero. Los operandos son los valores que interact\u00faan en la evaluaci\u00f3n, es decir, las partes de la operaci\u00f3n.</p> <p>Existen diferentes tipos de operadores, entre ellos:</p> <ul> <li>Operadores unarios. Son operadores que solo necesitan un \u00fanico operando.</li> <li>Operadores binarios. Son operadores que necesitan dos operandos, como la suma.</li> <li>Operadores ternarios. Son operadores que necesitan tres operandos.</li> </ul>"},{"location":"bloque_i/tema_2/page-5/#operadores-unarios","title":"Operadores unarios","text":"<p>En Javascript, los s\u00edmbolos positivo <code>+</code> y negativos <code>-</code> son operadores unarios que eval\u00faan el signo el operador. De esta forma podemos usar <code>-</code> para pasar un n\u00famero positivo a negativo:</p> <pre><code>console.log(+2) // positive number\nconsole.log(-2) // negative number\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operadores-matematicos","title":"Operadores matem\u00e1ticos","text":"<p>En Javascript tenemos los siguientes operadores para poder realizar operaciones matem\u00e1ticas:</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo + Suma 2.5 + 7.1 9.6 - Resta 235.6 - 103.5 132.1 * Multiplicaci\u00f3n 1.2 * 1.1 1.32 / Divisi\u00f3n 0.050 / 0.027 / 2 0.253 % Resto Divisi\u00f3n entera 20 % 714.5 % 2 60.5 ** Exponenciaci\u00f3n 2 ** 2 4 <p>El operador exponenciaci\u00f3n sirve para realizar potencias o ra\u00edces. Para realizar ra\u00edces es necesario que el exponente de la potencia sea una fracci\u00f3n. Por ejemplo, para calcular la ra\u00edz cuadrada de 4: <code>2 ** (1/2)</code></p>"},{"location":"bloque_i/tema_2/page-5/#concatenar-cadenas","title":"Concatenar cadenas","text":"<p>El operador binario <code>+</code> tiene un tercer uso, concatenar cadenas. Une una o m\u00e1s cadenas obteniendo como resultado una nueva cadena completa.</p> <pre><code>const name = 'Jane'\nconst lastName = 'Doe'\nconst fullName = name + ' ' + lastName\nconsole.log(fullName) // Jane Doe\n</code></pre> <p>Hay que tener en cuenta que cuando se usa el operador de concatenaci\u00f3n con n\u00fameros, estar\u00edamos realizando una suma. Sin embargo, si uno de los dos operandos es de tipo cadena, aunque el otro sea un n\u00famero o un booleano, siempre concatenar\u00e1, incluso si la cadena es de un d\u00edgito:</p> <pre><code>console.log(1 + \"1\") //11\nconsole.log(\"1\" + 2) //12\n</code></pre> <p>En Javascript, si hay m\u00e1s de un operando y el operador es binario se va realizando la operaci\u00f3n de dos en dos, seg\u00fan un orden que veremos posteriormente. De esta manera:</p> <pre><code>console.log(2 + 2 + \"2\") // 4 + \"2\" = \"42\"\nconsole.log(\"2\" + 2 + 4) // \"22\" + 4 = \"224\"\n</code></pre> <p>Warning</p> <p>El operador binario <code>+</code> es el \u00fanico operador binario que trata a las cadenas d\u00edgitos (las cadenas que son num\u00e9ricas) como cadenas y no los tratan como n\u00famero. El resto de operadores matem\u00e1ticos realizan la conversi\u00f3n de la cadena a n\u00famero, y en caso de no ser posible el resultado de la operaci\u00f3n ser\u00eda <code>NaN</code>.</p> <pre><code>console.log(2 - '1') // 1\nconsole.log('6' / '2') // 3\nconsole.log('hola mundo' / 2) //NaN\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operador-asignacion","title":"Operador Asignaci\u00f3n","text":"<p>El operador de asignaci\u00f3n <code>=</code> es un operador binario que sirve para asignar a una variable un valor, por lo que los operandos ser\u00eda la variable el valor.</p> <pre><code>let a = 10\n</code></pre> <p>En Javascript, se permite encadenar varias asignaciones, de forma que se eval\u00faen de derecha a izquierda:</p> <pre><code>let a, b, c\na = b = c = 4\n</code></pre> <p>En el ejemplo anterior, se realiza una asignaci\u00f3n encadenada, de forma que primero se realiza la que est\u00e9 m\u00e1s a la derecha (<code>c = 4</code>) y luego las restantes (<code>b = c</code> y <code>c = a</code>).</p> <p>Aqu\u00ed una demostraci\u00f3n de una asignaci\u00f3n encadenada m\u00e1s compleja:</p> <pre><code>let a = 1;\nlet b = 2;\nlet c = 3 - (a = b + 1);\nconsole.log(a); // 3\nconsole.log(c); // 0\n</code></pre> <p>En el ejemplo anterior, primero se eval\u00faa la asignaci\u00f3n <code>a = b + 1</code> y su resultado de utiliza en la siguiente asignaci\u00f3n <code>c = 3 - 3</code>, por lo que el valor de la variable <code>c</code> acaba siendo 0.</p> <p>Aunque es cierto que Javascript te permite encadenar las asignaciones, no es algo que se recomienda fervientemente, por lo que es m\u00e1s legible hacerlo secuencialmente. As\u00ed el ejemplo anterior, ser\u00eda m\u00e1s legible de esta forma:</p> <pre><code>let a = 1;\nlet b = 2;\na = b + 1;\nlet c = 3 - a;\nconsole.log(a); // 3\nconsole.log(c); // 0\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operadores-combinados","title":"Operadores combinados","text":"<p>En ciertas ocasiones queremos asignarle a una variable un nuevo valor que depende de su valor anterior, por ejemplo, podemos incrementar 2 unidades.</p> <pre><code>let number = 2\nnumber = number + 2\nconsole.log(number) // 4\n</code></pre> <p>En Javascript (como en otros lenguajes), existe la posibilidad de combinar la operaci\u00f3n y asignaci\u00f3n en un solo operando, por ejemplo <code>+=</code>. De esta forma, el ejemplo anterior quedar\u00eda:</p> <pre><code>let number = 2\nnumber += 2\nconsole.log(number) // 4\n</code></pre> <p>Primero se indicar\u00eda el operador matem\u00e1tico y luego el de asignaci\u00f3n, de est\u00e1 forma se eval\u00faa primero la expresi\u00f3n (<code>number + 2</code>) y luego se realiza la asignaci\u00f3n (<code>number = 4</code>).</p> <p>Tambi\u00e9n se puede hacer uso de m\u00e1s de una operaci\u00f3n matem\u00e1tica, prevaleciendo \u00e9sta siempre primero antes de la asignaci\u00f3n. De esta forma:</p> <pre><code>let n = 2;\nn *= 3 + 5;\nconsole.log(n); // 16\n</code></pre> <p>En el ejemplo anterior, primero se eval\u00faa la operaci\u00f3n de suma (<code>3 + 5</code>) y luego se realiza la operaci\u00f3n de multiplicaci\u00f3n (<code>2 * 8</code>), y por \u00faltimo la asignaci\u00f3n (<code>16</code>).</p>"},{"location":"bloque_i/tema_2/page-5/#operadores-incrementodecremento","title":"Operadores incremento/decremento","text":"<p>Los operadores incrementales y decrementales sirven para modificar el valor de las variables en un unidad. El operador incremento <code>++</code> modificar el valor de la variable en una unidad de forma incremental, mientras que el de decremento <code>--</code> lo decrementa en una unidad.</p> <pre><code>let count = 2;\ncount++; // 3\ncount--; // 2\n</code></pre> <p>Importante</p> <p>Incremento/decremento s\u00f3lo puede ser aplicado a variables. Intentar utilizarlo en un valor como 5++ dar\u00e1 un error.</p> <p>Estos operadores puede ser colocados antes o despu\u00e9s de una variable, teniendo un comportamiento diferente. Esta diferente es notable durante la evaluaci\u00f3n de una expresi\u00f3n. Si se colocan como sufijo (antes de la variable), el valor se ver\u00e1 incrementado/decrementado despu\u00e9s de usar la variable en la expresi\u00f3n evaluada, mientras que si es usado como prefijo (despu\u00e9s de la variable), el valor se vera incrementado/decrementado antes de usar la variable en la expresi\u00f3n.</p> <pre><code>let number = 1\nconsole.log(number++) // 1\nconsole.log(number) //\n</code></pre> <p>En el ejemplo anterior, tenemos una variable con un valor inicial a <code>1</code>. Al hacer el incremento como sufijo, primero se usa el valor de la variable antes de incrementarse para mostrarla por pantalla, por lo que se mostrar\u00e1 1, y luego se incrementar\u00e1 a <code>2</code>.</p> <p>Ahora veamos una demostraci\u00f3n, con un incremento como prefijo:</p> <pre><code>let number = 1\nconsole.log(++number) //2\nconsole.log(number)\n</code></pre> <p>En esta ocasi\u00f3n, primero se incrementa el valor y luego se muestra por pantalla.</p> <p>Veamos un ejemplo m\u00e1s complejo:</p> <pre><code>let counter = 1\nlet expr = 2 ** counter++ // 2\nlet other = 2 ** ++otherCounter //8\n</code></pre> <p>El valor de la variable <code>expr</code> es dos, ya que utiliza un incremento de sufijo, por lo que primero se usa el valor anterior <code>1</code> para realizar la operaci\u00f3n <code>2 ** 1</code> y luego se incrementa a <code>2</code>. Mientras que, la variable <code>other</code> tiene resultado <code>8</code> al usar un incremento de prefijo, por lo que primero se ha incrementado el valor (de <code>2</code> a <code>3</code>) y luego se ha usado \u00e9ste para la operaci\u00f3n <code>2 ** 3</code>.</p>"},{"location":"bloque_i/tema_2/page-5/#operadores-a-nivel-de-bits","title":"Operadores a nivel de bits","text":"<p>Los operados a nivel de bits son operadores que tratan a los n\u00fameros como n\u00fameros enteros de 32 bits, trabajando con su representaci\u00f3n binaria. Este tipo de operadores no es exclusivo de Javascript, sino que tambi\u00e9n son utilizados en otros lenguajes.</p> <p>Estos operadores se usan de forma muy puntual, simplemente cuando es necesario el uso de la representaci\u00f3n de los n\u00fameros a un bajo nivel, pero a\u00fan as\u00ed es bueno tener conocimientos de ellos.</p> <p>Podemos encontrar los siguientes operadores:</p> <ul> <li> <p>AND (<code>&amp;</code>). Devuelve un 1 en las posiciones de bit d\u00f3nde las posiciones de los operadores tienen un 1, por el contrario devuelven un 0.</p> <pre><code>let x = 9 // 1001\nlet y = 12 // 1100\nconsole.log(x &amp; y) // 8 (1000)\n</code></pre> </li> <li> <p>OR (<code>|</code>). Devuelve un cero en las posiciones de bit d\u00f3nde las posiciones de los dos operadores tienen un 0, por el contrario devuelven un 1.</p> <pre><code>let x = 9 // 1001\nlet y = 12 // 1100\nconsole.log(x | y) // 13 (1101)\n</code></pre> </li> <li> <p>XOR (<code>^</code>). Devuelve un cero en las posiciones d\u00f3nde el bit es el mismo y un 1 d\u00f3nde las posiciones son diferentes.</p> <pre><code>let x = 9 // 1001\nlet y = 12 // 1100\nconsole.log(x ^ y) // 5 (0101)\n</code></pre> </li> <li> <p>NOT (<code>~</code>). Es un operador unario que intercambia el valor, es decir si la posici\u00f3n tiene un valor de cero es cambiado por uno y viceversa.</p> <pre><code>let x = 9 // 1001\nconsole.log(~x) // 5 (0110)\n</code></pre> </li> <li> <p>LEFT SHIFT (<code>&lt;&lt;</code>). Es un operador binaria cuyo segundo operado indica el n\u00famero de bits que se desplazar\u00e1n del primer operado hacia la izquierda. En otras palabras, se a\u00f1ade tantos 0 como se indica al final del binario.</p> <pre><code>let x = 2 // 0000010\nconsole.log(x &lt;&lt; 1) // 4 (00000100)\n</code></pre> </li> <li> <p>RIGHT SHIFT (<code>&gt;&gt;</code>). Es un operador binario cuyo segundo operado indica el n\u00famero de bits que se desplazar\u00e1n del primer operado hacia la derecha. En otras palabras, desaparece la cantidad de binarios indicada.</p> <pre><code>let x = 2 // 0000010\nconsole.log(x &gt;&gt; 1) // 1 (000001)\n</code></pre> </li> <li> <p>ZERO-FILL RIGHT SHIFT (<code>&gt;&gt;&gt;</code>). Es un operador binario cuyo segundo operado indica el n\u00famero de bits que se desplazar\u00e1n del primer operado hacia la derecha, pero a\u00f1adiendo 0 a la parte izquierda. En otras palabras, desaparece la cantidad de binarios indicada.</p> <pre><code>let x = 2 // 0000010\nconsole.log(x &gt;&gt;&gt; 1) // 1 (0000001)\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_2/page-5/#operador-coma","title":"Operador coma","text":"<p>El operador coma <code>,</code> es uno de los operadores m\u00e1s raros e inusuales. A veces, es utilizado para escribir c\u00f3digo m\u00e1s corto, entonces tenemos que saberlo para poder entender qu\u00e9 est\u00e1 pasando.</p> <p>El operador coma nos permite evaluar varias expresiones, dividi\u00e9ndolas con una coma <code>,</code>. Cada una de ellas es evaluada, pero s\u00f3lo el resultado de la \u00faltima es devuelto.</p> <p>Por ejemplo:</p> <pre><code>let a = (1 + 2, 3 + 4);\nconsole.log(a); // 7 (el resultado de 3 + 4)\n</code></pre> <p>Aqu\u00ed, se eval\u00faa la primera expresi\u00f3n 1 + 2 y se desecha su resultado. Luego, se eval\u00faa 3 + 4 y se devuelve como resultado.</p> <p>Info</p> <p>Tenga en cuenta que el operador coma tiene una precedencia muy baja, inferior a <code>=</code>, por lo que los par\u00e9ntesis son importantes en el ejemplo anterior.</p> <p>Sin ellos: <code>a = 1 + 2, 3 + 4</code> se eval\u00faa primero el <code>+</code>, sumando los n\u00fameros a <code>a = 3, 7</code>, luego el operador de asignaci\u00f3n <code>=</code> asigna <code>a = 3</code>, y el resto es ignorado. Es igual que <code>(a = 1 + 2), 3 + 4</code>.</p> <p>A veces, las personas lo usan en construcciones m\u00e1s complejas para poner varias acciones en una l\u00ednea.</p> <p>Por ejemplo:</p> <pre><code>for (a = 1, b = 3, c = a * b; a &lt; 10; a++) {\n...\n}\n</code></pre> <p>Tales trucos se usan en muchos frameworks de JavaScript. Por eso los estamos mencionando. Pero generalmente no mejoran la legibilidad del c\u00f3digo, por lo que debemos pensar bien antes de usarlos.</p>"},{"location":"bloque_i/tema_2/page-5/#operadores-relaciones","title":"Operadores relaciones","text":"<p>Los operados relaciones realizan comparaciones entre los datos obteniendo siempre un resultado booleano (<code>true</code> o <code>false</code>). Entre ellos, podemos encontrar:</p> Operador Significado Ejemplo &lt; Menor que 3 &lt; 5 &gt; Mayor que 3 &gt; 5 &lt;= Menor o igual que 3 &lt;= 5 &gt;= Mayor o igual que 3 &gt;= 5 == Igual que 3 == 5 != Distinto que 3 != 5 <p>Se pueden comparar n\u00fameros, o cadenas, siendo el algoritmo de comparaci\u00f3n el siguiente:</p> <ol> <li>Compare el primer car\u00e1cter de ambas cadenas.</li> <li>Si el primer car\u00e1cter de la primera cadena es mayor (o menor) que el de la otra cadena, entonces la primera cadena es mayor (o menor) que la segunda. Hemos terminado.</li> <li>De lo contrario, si los primeros caracteres de ambas cadenas son los mismos, compare los segundos caracteres de la misma manera.</li> <li>Repita hasta el final de cada cadena.</li> <li>Si ambas cadenas tienen la misma longitud, entonces son iguales. De lo contrario, la cadena m\u00e1s larga es mayor.</li> </ol> <p>Por ejemplo, al comparar <code>Z &gt; A</code>, solo es necesario hacer el primer paso. Sin embargo, al comparar <code>Glow &gt; Glee</code>, es necesario m\u00e1s pasos:</p> <ol> <li><code>G</code> es igual a <code>G</code>.</li> <li><code>l</code> es igual a <code>l</code>.</li> <li><code>o</code> es mayor que <code>e</code>, por lo que la primera cadena es mayor.</li> </ol> <p>\u00a1OJO!</p> <p>El algoritmo de comparaci\u00f3n dado arriba es aproximadamente equivalente al utilizado de forma alfab\u00e9tica, pero no es exactamente el mismo.</p> <p>Por ejemplo, las may\u00fasculas importan. Una letra may\u00fascula <code>A</code> no es igual a la min\u00fascula <code>a</code>. La <code>a</code> min\u00fascula es mayor porque el car\u00e1cter en min\u00fascula tiene un \u00edndice mayor en la tabla de codificaci\u00f3n interna que utiliza Javascript (Unicode)</p> <p>Para comparar entre distintos tipos, Javascript intenta realizar una parseo a n\u00fameros, en caso de que sea posible, si no lo transforma en <code>NaN</code>. Un <code>NaN</code> nunca es ni mayor, ni menor, ni igual a un n\u00famero, por lo que una comparaci\u00f3n con dicho tipo num\u00e9rico dar\u00eda siempre false. Un booleano se puede entender como un n\u00famero binario, siendo <code>true</code> equivalente a <code>1</code>y <code>false</code> a <code>0</code>:</p> <pre><code>console.log('3' &gt; 4) // false\nconsole.log('Hola' == 2) // false\nconsole.log('Hola' != 2) // true\nconsole.log(true &gt; 0) // true\n</code></pre> <p>Warning</p> <p>En Javascript el n\u00famero <code>0</code> se puede entender en booleano como <code>false</code>, pero la cadena <code>\"0\"</code> se entiende como <code>true</code>, por lo que a la hora de compararlas hay que tenerlo en cuenta.</p> <p>Veamos otro ejemplo:</p> <pre><code>console.log(0 == false) //true\nconsole.log('' == false) // true\n</code></pre> <p>Ambas comparaciones son <code>true</code> porque al pasar los datos no num\u00e9ricos a n\u00fameros, se entienden como <code>0</code>. Esto puede suponer un problema, porque a veces es conveniente comprobar si el contenido de dos variables es exactamente igual, y en este caso siempre dar\u00eda <code>true</code>. Para ello hay un comparador de igualdad estricto que retornar\u00e1 <code>true</code> si y solo si los datos comparados son iguales en tipo y contenido:</p> <pre><code>console.log(3 === '3') // false\nconsole.log(0 === false) // false\n</code></pre> <p>En los ejemplos anteriores, vemos que los datos son iguales en contenido (recuerda que <code>false</code> equivale a <code>0</code>), pero no tienen el mismo tipo de dato, por lo que no ser\u00edan iguales estrictos. Existe, por ende, el comparador de desigualdad estricto <code>!==</code>.</p> <p>El uso del operador de igual estricto es un mejor pr\u00e1ctica que el uso del operador de igual b\u00e1sico, ya que el estricto es propenso a tener menos errores. Uno de los errores t\u00edpicos es que al comparar <code>null</code> y <code>undefined</code> con el operador <code>==</code> \u00e9ste devuelve <code>true</code>, pero con el operador <code>===</code> devuelve <code>false</code>.</p> <p>Warning</p> <p>Al hacer una comparaci\u00f3n de cualquier tipo de dato con <code>null</code> o <code>undefined</code> \u00e9sta dar\u00e1 <code>false</code>, ya que su valor \"num\u00e9rico\" es <code>NaN</code>:</p> <pre><code>console.log(3 &lt; null) // false\nconsole.log(undefined &gt; 5) // false\n</code></pre> <p>Solo puede ser <code>true</code> si su valor es <code>undefined</code> o <code>null</code> y se compara de igualdad:</p> <pre><code>let num\nconsole.log(num === undefined)\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Los operadores l\u00f3gicos son operadores binarios aplicados a cualquier tipo y que pueden devolver cualquier tipo:</p>"},{"location":"bloque_i/tema_2/page-5/#operador-or","title":"Operador OR (||)","text":"<p>El operador OR (<code>||</code>) es un operador que en la programaci\u00f3n cl\u00e1sica, retornar\u00e1 <code>true</code> si cualquiera de sus dos operandos es <code>true</code>:</p> <pre><code>console.log(true || false) // true\nconsole.log(false || true) // true\nconsole.log(true || true) // true\nconsole.log(false || false) // false\n</code></pre> <p>En el ejemplo anterior, solo retorna <code>false</code> cuando se compara dos <code>false</code>. Si se intenta utilizar como operador otro tipo de dato, se parsear\u00e1 a booleano. En el \u00e1mbito de los n\u00fameros se entiende que <code>0</code> es <code>false</code> y que <code>1</code> es <code>true</code>. En el caso de las cadenas, se entiende como <code>false</code> una cadena vac\u00eda, y como <code>true</code> una no vac\u00eda. Tambi\u00e9n se puede entender como <code>true</code> una variable distinta de <code>null</code> y <code>undefined</code>.</p> <pre><code>console.log(1 || 0) // true\nconsole.log('Hola' || '') // true\n</code></pre> <p>Adem\u00e1s de la funcionalidad cl\u00e1sica, en Javascript dicho operador, tiene una funci\u00f3n extra. Se puede usar dicho operador para la asignaci\u00f3n de una variable, de la siguiente forma: <code>const result = value1 || value2 || value3</code>. Su funcionamiento es simple:</p> <ul> <li>Eval\u00faa la expresi\u00f3n de izquierda a derecha.</li> <li>Transforma cada operando en un valor booleano. Si el resultado de alguno es <code>true</code>, se detiene en el primer operando que da <code>true</code>, retornando el valor original del operando.</li> <li>Si todos los operandos son <code>false</code> retorna el \u00faltimo operando.</li> </ul> <p>En otras palabras, una cadena de OR devuelve el primer valor verdadero o el \u00faltimo si ning\u00fan verdadero es encontrado.</p> <pre><code>const result1 = 0 || '' || 7 // 7\nconst result2 = 3 || undefined || false // 3\nconst result1 = null || 'Hola' || 9 // 'Hola'\nconst result4 = null || undefined || '' || 0 // 0\n</code></pre> <p>Uno de los usos m\u00e1s comunes de esta funcionalidad es poder definir una variable que depende de otros valores, pero en caso de los otros valores no est\u00e9n definidos (ya sea porque sean <code>null</code> o <code>undefined</code> o cadena vac\u00eda, o incluso cero) podemos indicarle un valor por defecto.</p> <pre><code>let name = ''\nlet firstName = null\nconst userName = name || firstName || 'Nombre de usuario'\n</code></pre> <p>En el ejemplo anterior se eval\u00faa las dos variables, en caso de que den <code>false</code>, se utiliza como valor de la variable <code>userName</code> la cadena <code>Nombre de usuario</code>.</p>"},{"location":"bloque_i/tema_2/page-5/#operador-and","title":"Operador AND (&amp;&amp;)","text":"<p>El operador AND (<code>&amp;&amp;</code>) es un operador que en la programaci\u00f3n cl\u00e1sica retornar\u00e1 <code>true</code> siempre y cuando todos los operandos devuelvan <code>true</code> y <code>false</code> si hay uno o m\u00e1s de uno que devuelve <code>false</code>.</p> <pre><code>console.log(true &amp;&amp; true); // true\nconsole.log(false &amp;&amp; true); // false\nconsole.log(true &amp;&amp; false); // false\nconsole.log(false &amp;&amp; false); // false\n</code></pre> <p>Al igual que operador OR, en Javascript, se puede usar el operador AND para la asignaci\u00f3n <code>const result = value1 &amp;&amp; value2 &amp;&amp; value3</code>. En este caso, el procedimiento es un ligeramente diferente:</p> <ul> <li>Eval\u00faa la expresi\u00f3n de izquierda a derecha.</li> <li>Transforma cada operando en un valor booleano. Si el resultado de alguno es <code>false</code>, se detiene en el primer operando que da <code>false</code>, retornando el valor original del operando.</li> <li>Si todos los operandos son <code>true</code> retorna el \u00faltimo operando.</li> </ul> <p>En otras palabras, AND retorna el primer valor falso o el \u00faltimo valor si ninguno fue encontrado. Las reglas anteriores son similares a las de OR. La diferencia es que AND retorna el primer valor falso mientras que OR retorna el primer valor verdadero.</p> <pre><code>const result1 = 0 &amp;&amp; '' &amp;&amp; 7 // 0\nconst result2 = 3 &amp;&amp; undefined &amp;&amp; false // undefined\nconst result1 = null &amp;&amp; 'Hola' &amp;&amp; 9 // null\nconst result4 = 1 &amp;&amp; 2 &amp;&amp; true &amp;&amp; 3 // 3\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operador-not","title":"Operador NOT (!)","text":"<p>El operador NOT (<code>!</code>) es un operador unario que se encarga de convertir dicho operando en un booleano (en caso de que no lo sea) y devuelve su valor booleano contrario.</p> <pre><code>console.log(!false) // true\nconsole.log(!2) // false\nconsole.log(!0) // true\nconsole.log(!'Hola') // false\nconsole.log(!'') // true\nconsole.log(!undefined) // true\n</code></pre> <p>Warning</p> <p>En Javascript los operadores AND, OR, NOT y NULLISH COALESCING son operadores corto-circuitos, es decir, van evaluando expresiones hasta que una de ellas obtiene un valor claro, dejando a las dem\u00e1s sin evaluar. Por ejemplo:</p> <pre><code>const result = 10 || 0 || false\n</code></pre> <p>En este ejemplo, el valor de la variable <code>result</code> es <code>10</code>, pero el tiempo de ejecuci\u00f3n es menor si se hubiese cambiado el orden, ya que al evaluar primero el 10, como se obtiene lo que se desea (una valor distinto de <code>false</code>) el resto de expresiones se dejan sin evaluar. Por eso, es importante el orden en el que se eval\u00faan dichas expresiones. Veamos otro ejemplo:</p> <pre><code>console.log(3 &gt; 5 &amp;&amp; 4 &gt; 2)\n</code></pre> <p>Ahora, se mostrar\u00e1 <code>false</code>, porque <code>3&gt;5</code> retorna <code>false</code> por lo que no es necesario evaluar la siguiente expresi\u00f3n, ya que siendo la primera <code>false</code> el operando <code>&amp;&amp;</code> retornar\u00e1 <code>false</code> s\u00ed o s\u00ed.</p>"},{"location":"bloque_i/tema_2/page-5/#operador-typeof","title":"Operador typeof","text":"<p>El operador <code>typeof</code> es un operador unario de Javascript que devuelve el tipo de dato del operando. Tambi\u00e9n se puede utilizar de la siguiente forma <code>typeof(x)</code> pero hay que tener en cuenta que <code>typeof</code> es un operando y no una funci\u00f3n.</p> <pre><code>console.log(typeof 'Hola') // string\nconsole.log(typeof 4) // number\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operador-ternario","title":"Operador ternario","text":"<p>El operador ternario es un operador con tres operando. El primer operando hace referencia a una condici\u00f3n que debe ser evaluada. Si esta condici\u00f3n es verdadera el operador retorna el segundo operando, mientras que si la condici\u00f3n es falsa el operador retorna el tercer operando. Su sintaxis es la siguiente:</p> <pre><code>condition ? trueValue : falseValue\n</code></pre> <p>Veamos un ejemplo:</p> <pre><code>const result = age &gt; 18 ? 'Mayor' : 'Menor'\n</code></pre> <p>Podemos tener una secuencia de operadores ternario si queremos evaluar m\u00e1s de una posibilidad:</p> <pre><code>let message = age &lt; 3 ? '\u00a1Hola, beb\u00e9!' : age &lt; 18 ? '\u00a1Hola!' : age &lt; 100 ? '\u00a1Felicidades!' : '\u00a1Qu\u00e9 edad tan inusual!';\nconsole.log(message)\n</code></pre> <p>La ejecuci\u00f3n del ejemplo anterior es la siguiente.</p> <ol> <li>Se comprueba si la expresi\u00f3n <code>age &lt; 3</code> es verdadera. En caso de serlo, retornar\u00e1 el valor <code>'Hola, beb\u00e9'</code>, y no comprobar\u00e1 el resto de condiciones.</li> <li>Si es falsa, comprobar\u00e1 la siguiente condici\u00f3n <code>age &lt; 18</code>. En este caso si es verdadera retornar\u00e1 <code>'\u00a1Hola!'</code>.</li> <li>Si es falsa, comprobar\u00e1 la \u00faltima condici\u00f3n, que de ser verdadera retornar\u00e1 <code>\u00a1Felicidades!</code>, por el contrario <code>\u00a1Qu\u00e9 edad tan inusual!</code>.</li> </ol>"},{"location":"bloque_i/tema_2/page-5/#operador-nullish-coalescing","title":"Operador Nullish Coalescing","text":"<p>El operador nullish coalescing (fusi\u00f3n de null) es un operador binario en el que retorna el primer operando si es distinto de <code>null</code> o <code>undefined</code>, o por el contario retorna el segundo:</p> <pre><code>let number\nconsole.log(number ?? 0) // 0\n</code></pre> <p>En el ejemplo anterior, se mostrar\u00e1 0, ya que la variable <code>number</code> es una variable <code>undefined</code> y por lo tanto la expresi\u00f3n <code>number ?? 0</code> retorna el segundo operado (<code>0</code>). En el siguiente ejemplo, retornar\u00e1 el valor de la variable <code>number</code> ya que no es <code>undefined</code>:</p> <pre><code>let number = 10\nconsole.log(number ?? 0) // 10\n</code></pre> <p>El operador nullish coalescing no es m\u00e1s que una sintaxis reducida del uso de un operador ternario con dicho prop\u00f3sito:</p> <pre><code>let number\nconsole.log(number !== undefined || number !== null ?  null : 0)\n</code></pre> <p>Tambi\u00e9n se puede usar una secuencia de dicho operador para seleccionar el primer valor que no sea <code>null</code>/<code>undefined</code>:</p> <pre><code>let firstName = null;\nlet lastName = null;\nlet nickName = \"MyNick\";\nconsole.log(firstName ?? lastName ?? nickName ?? \"Anonymous\"); // MyNick\n</code></pre> <p>El ejemplo anterior, tambi\u00e9n pod\u00eda haberse realizado con el operador OR (<code>||</code>). Hist\u00f3ricamente, el operador OR estuvo primero y existe desde el origen de JavaScript, as\u00ed que los desarrolladores lo estuvieron usando para tal prop\u00f3sito durante mucho tiempo.</p> <p>Por otro lado, el operador nullish coalescing es una adici\u00f3n reciente, y la raz\u00f3n es que la gente no estaba del todo satisfecha con <code>||</code>.</p> <p>La gran diferencia es que OR devuelve el primer valor verdadero  y nullish coalescing devuelve el primer valor definido. El <code>||</code> no distingue entre <code>false</code>, <code>0</code>, un string vac\u00edo <code>\"\"</code>, y <code>null</code>/<code>undefined</code>. Todos son lo mismo: valores falsos. Si cualquiera de ellos es el primer argumento de <code>||</code>, obtendremos el segundo argumento como resultado. Pero cierto es, que en la pr\u00e1ctica querremos usar dicho valor solo cuando no est\u00e9 definido o sea <code>null</code>. En el ejemplo siguiente, me interesa seguir usando el valor <code>0</code>, por eso no es conveniente usar el operador OR:</p> <pre><code>const height = 0\nconsole.log('La altura es', height ?? 'No hay altura')\n</code></pre> <p>Si hubi\u00e9semos usado el operador OR, hubiese devuelto la cadena, pero eso no ser\u00eda coherente ya que el valor de una altura si puede ser 0.</p> <p>Tips</p> <p>Por este motivo, se recomienda usar siempre el operador nullish coalescing en lugar del operador OR, y dejar dicho operador solo en situaciones concretas.</p> <p>Warning</p> <p>Por motivos de seguridad, JavaScript proh\u00edbe el uso de <code>??</code> junto con los operadores <code>&amp;&amp;</code> y <code>||</code>, salvo que la precedencia sea expl\u00edcitamente especificada con par\u00e9ntesis.</p> <pre><code>let x = 1 &amp;&amp; 2 ?? 3; // \u274c Syntax error\nlet y = (1 &amp;&amp; 2) ?? 3; // \u2705 2\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#precedencias","title":"Precedencias","text":"<p>En Javascript, como en cualquier otro lenguaje, existen demasiados operadores y a veces al usar varios de ellos a la vez es necesario tener en cuenta un precedencia a la hora de ejecutarse. Por ejemplo, en la expresi\u00f3n <code>3 + 5 * 2</code>, aunque primero vaya la suma, seg\u00fan la precedencia de operaciones, la multiplicaci\u00f3n tiene mayor precedencia que la suma por lo que primero se ejecutar\u00e1 <code>5 * 2</code> y luego el resultado se sumar\u00e1 a 3. En la siguiente tabla se recoge el orden de precedencia de los operadores de Javascript.</p> Precedencia Tipo de operador Asociatividad Operadores individuales 19 Agrupamiento - <code>()</code> 18 Acceso a propiedades (notaci\u00f3n por punto) A la izquierda <code>.</code> Acceso a propiedades (notaci\u00f3n por corchetes) A la izquierda <code>[]</code> Creaci\u00f3n de objetos (con argumentos) - <code>new</code> Llamada a funci\u00f3n A la izquierda <code>()</code> Encadenamiento opcional A la izquierda <code>?.</code> 17 Creaci\u00f3n de objetos (sin argumentos) A la derecha <code>new</code> 16 Incremento sufijo - <code>...++</code> Decremento sufijo <code>...--</code> 15 NOT l\u00f3gico A la derecha <code>!</code> NOT a nivel de bits <code>~</code> Suma unaria <code>+</code> Negaci\u00f3n unaria <code>-</code> Incremento prefijo <code>++...</code> Decremento prefijo <code>--...</code> <code>typeof</code> <code>typeof</code> <code>void</code> <code>void</code> <code>delete</code> <code>delete</code> <code>await</code> <code>await</code> 14 Potenciaci\u00f3n A la derecha <code>**</code> 13 Multiplicaci\u00f3n A la izquierda <code>*</code> Divisi\u00f3n <code>/</code> Resto <code>%</code> 12 Adici\u00f3n A la izquierda <code>+</code> Sustracci\u00f3n <code>-</code> 11 Desplazamiento de bits a la izquierda A la izquierda <code>&lt;&lt;</code> Desplazamiento de bits a la derecha <code>&gt;&gt;</code> Desplazamiento de bits a la derecha sin signo &gt;&gt;&gt; 10 Menor a A la izquierda <code>&lt;</code> Menor o igual a &lt;= Mayor a &gt; Mayor o igual a &gt;= <code>in</code> <code>in</code> <code>instanceof</code> <code>instanceof</code> 9 Igualdad A la izquierda <code>=</code> Desigualdad <code>!=</code> Igualdad estricta <code>===</code> Desigualdad estricta <code>!==</code> 8 AND nivel de bits A la izquierda <code>&amp;</code> 7 XOR nivel de bits A la izquierda <code>^</code> 6 OR nivel de bits A la izquierda <code>|</code> 5 AND l\u00f3gico A la izquierda <code>&amp;&amp;</code> 4 OR l\u00f3gico A la izquierda <code>||</code> Nullish coalescing <code>??</code> Condicional <code>...? ... : ...</code> 2 Asignaci\u00f3n A la derecha <code>=</code> <code>+=</code> <code>-=</code> <code>**=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&gt;&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code> <code>&amp;&amp;=</code> <code>||=</code> <code>??=</code> <code>yield</code> <code>yield</code> <code>yield*</code> <code>yield*</code> 1 Operador coma A la izquierda     <code>,</code> <p>La asociatividad hace referencia a la situaci\u00f3n en la cual dos operandos tenga la misma precedencia. En ese caso, se ejecutar\u00e1 primero seg\u00fan la asociatividad. Por ejemplo, en el caso de <code>3 * 3 / 3</code>, la multiplicaci\u00f3n y la divisi\u00f3n tiene la misma precedencia, y como su asociatividad es de izquierda, primero se ejecuta la operaci\u00f3n que est\u00e9 m\u00e1s a la izquierda, en este caso la multiplicaci\u00f3n.</p> <p>A veces, en ocasiones queremos realizar una operaci\u00f3n de baja precedencia antes que una de mayor procedencia, para ello se puede usar el operador con mayor precedencia los par\u00e9ntesis <code>()</code>. Por ejemplo, si en la operaci\u00f3n <code>2 + 3 * 5</code>, donde la multiplicaci\u00f3n tiene mayor precedencia que la suma, pero se desea hacer la suma antes, se debe colocar un par\u00e9ntesis en la expresi\u00f3n que se desea hacer primero: <code>(2 + 3) * 5</code>.</p>"},{"location":"bloque_i/tema_2/page-5/#ejercicios","title":"Ejercicios","text":"Ejercicio 5 <p>\u00bfCu\u00e1les son los valores finales de todas las variables <code>a</code>, <code>b</code>, <code>c</code> y <code>d</code> despu\u00e9s del c\u00f3digo a continuaci\u00f3n?</p> <pre><code>let a = 1, b = 1 let c = ++a let d = b++ </code></pre> Ejercicio 6 <p>\u00bfCu\u00e1les son los valores de <code>a</code> y <code>x</code> despu\u00e9s del c\u00f3digo de a continuaci\u00f3n:</p> <pre><code>let a = 2\nlet x = 1 + (a *= 2)\n</code></pre> Ejercicio 7 <p>\u00bfCu\u00e1les es el resultado de las siguientes expresiones?</p> <ol> <li>\"\" + 1 + 0</li> <li>\"\" - 1 + 0</li> <li>true + false</li> <li>6 / \"3\"</li> <li>\"2\" * \"3\"</li> <li>4 + 5 + \"px\"</li> <li>\"$\" + 4 + 5</li> <li>\"4\" - 2</li> <li>\"4px\" - 2</li> <li>\"  -9  \" + 5</li> <li>\"  -9  \" - 5</li> <li>null + 1</li> <li>undefined + 1</li> <li>\" \\t \\n\" - 2</li> <li>5 &gt; 4</li> <li>\"apple\" &gt; \"pineapple\"</li> <li>\"2\" &gt; \"12\"</li> <li>undefined == null</li> <li>undefined === null</li> <li>null == \"\\n0\\n\"</li> <li>null === +\"\\n0\\n\"</li> <li>null || 2 || undefined</li> <li>1 &amp;&amp; null &amp;&amp; 2</li> <li>null || 2 &amp;&amp; 3 || 4</li> </ol> Ejercicio 8 <p>Dado los siguientes valores de las variables <code>x</code>, <code>y</code>, <code>j</code> y <code>k</code>, a\u00f1adir los par\u00e9ntesis que sean necesarios para que las expresiones que las siguen eval\u00faen a verdadero: <code>x = 10</code>; <code>y = 19</code>; <code>j = true</code>; <code>k = undefined</code>.</p> <ol> <li>x == y || j</li> <li>x &gt;= y || x &lt;=y &amp;&amp; j</li> <li>!j || j</li> <li>!k &amp;&amp; k</li> </ol> Ejercicio 9 <p>Indica cual es la salida de las siguientes asignaciones:</p> <ol> <li>const result1 = 10 || 0 || null</li> <li>const result2 = null || undefined || 10</li> <li>const result3 = 0 || 'Sin valor'</li> <li>const result4 = 0 ?? 'Sin valor'</li> <li>const result5 = 10 &amp;&amp; 0 &amp;&amp; 'Mi valor'</li> <li>const result6 = 10 &amp;&amp; 'Mi Valor' &amp;&amp; '\u00daltima'</li> <li>const result7 = 10 &amp;&amp; 8 &amp;&amp; 0 || 20</li> <li>const result8 = 10 &amp;&amp; 10 || undefined &amp;&amp; value</li> </ol>"},{"location":"bloque_i/tema_2/page-6/","title":"6 Introducci\u00f3n a las funciones","text":""},{"location":"bloque_i/tema_2/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>A veces, es necesario repetir c\u00f3digo a lo largo de nuestro script. Por lo que a veces es necesario tener un bloque que recoja el c\u00f3digo a repetir y se ejecuten en diferentes partes.</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ul> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ul>"},{"location":"bloque_i/tema_2/page-6/#declaracion","title":"Declaraci\u00f3n","text":"<p>Para declarar una funci\u00f3n podemos usar la siguiente estructura:</p> <pre><code>function functionName(parameter1, parameter2, parameter3, ..., parameterN){\n// code\n}\n</code></pre> <p>Para hacer uso de esas funciones, se usa el nombre de la funci\u00f3n seguido de un par\u00e9ntesis <code>()</code>. Dentro del par\u00e9ntesis, los par\u00e1metros necesarios para ejecutar la funci\u00f3n.</p> <pre><code>functionName(parameter1, parameter2,..., parameterN)\n</code></pre> <p>Los par\u00e1metros son los datos que son necesarios para ejecutar una funci\u00f3n. Por ejemplo, si tenemos una funci\u00f3n llamada <code>suma</code>, \u00e9sta debe recibir los n\u00fameros que desea realizar la suma.</p> <p>En Javascript existen funciones nativas, es decir, funciones que fueron creadas para por y para el lenguaje y se pueden acceder a ellas gracias al motor del navegador. Entre ellas, podemos destacar: <code>alert</code>, <code>prompt</code> y <code>confirm</code>. Estas funciones son funciones para los navegadores webs. Son funciones del objeto <code>windows</code>.</p>"},{"location":"bloque_i/tema_2/page-6/#alert","title":"alert","text":"<p>La funci\u00f3n <code>alert(message)</code> es una funci\u00f3n de Javascript que ejecuta un cuadro de di\u00e1logo en el navegador, mostrando el <code>message</code> que se le pasa por par\u00e1metro. Este cuadro de di\u00e1logo se muestra de forma modal, es decir, se muestra de forma que no se puede interactuar con el resto de la p\u00e1gina hasta que el cuadro de di\u00e1logo no sea cerrado. Para poder cerrarlo, el cuadro de di\u00e1logo tiene un bot\u00f3n de Aceptar.</p> <pre><code>alert('Hola mundo')\n</code></pre> <p>Con HTML, CSS podemos crear nuestros propios modales, y a trav\u00e9s de Javascript podemos crearle nuestra propia interactividad. Pero de momento, usaremos los m\u00e9todos predeterminados por el lenguaje.</p>"},{"location":"bloque_i/tema_2/page-6/#prompt","title":"prompt","text":"<p>La funci\u00f3n <code>prompt(title, [default])</code> es una funci\u00f3n que muestra en el navegador un cuadro de di\u00e1logo para que el usuario introduzca un dato. Con el par\u00e1metro <code>title</code> indicamos el mensaje que mostramos en el cuadro de di\u00e1logo. Con el par\u00e1metro <code>default</code> es un par\u00e1metro opcional (no es necesario indicarlo) y representa un valor por defecto, en caso de que el usuario no introduzca ning\u00fan valor.</p> <pre><code>const age = prompt('\u00bfCu\u00e1l es tu edad?', 10)\nconst name = prompt('\u00bfCu\u00e1l es tu nombre?')\nconsole.log(`Hola ${name}, eres ${age &gt; 18 ? 'mayor' : 'menor'} de edad`)\n</code></pre> <p>El usuario introducir\u00e1 un dato en el campo de entrada y presionar el bot\u00f3n OK y el valor introducido por el usuario se le asignar\u00e1 a la variable indicada. En caso de presionar el bot\u00f3n cancelar o presiona la tecla Esc, se asignar\u00e1 a la variable el valor por defecto indicado, o <code>null</code> en caso de que no se haya indicado ninguna.</p> <p>Warning</p> <p>Es importante tener en cuenta que todo lo que el usuario introduzca haciendo uso de la funci\u00f3n <code>prompt</code> es considerado como texto. Si se desea otro tipo de dato es necesario realizar un control previo antes de su uso, as\u00ed como una conversi\u00f3n de datos.</p>"},{"location":"bloque_i/tema_2/page-6/#confirm","title":"confirm","text":"<p>La funci\u00f3n <code>confirm(message)</code> muestra un cuadro de di\u00e1logo con un <code>message</code> y dos botones: OK y CANCELAR. Si el usuario presiona el bot\u00f3n OK la funci\u00f3n retornar\u00e1 <code>true</code> y <code>false</code> en el caso contrario.</p> <pre><code>const isBoss = confirm('\u00bfEres el jefe?')\nalert(isBoss ? 'Es el jefe' : 'No es el jefe')\n</code></pre>"},{"location":"bloque_i/tema_2/page-6/#ejercicios","title":"Ejercicios","text":"Ejercicio 10 <p>Crea una p\u00e1gina web, realizando las siguientes opciones.</p> <ul> <li>Solicitar al usuario su nombre y su edad.</li> <li>Solicitar al usuario si est\u00e1 o no abonado a nuestra web.</li> <li>Mostrar en un cuadro de di\u00e1logo la siguiente informaci\u00f3n: <code>Hola Pedro, eres mayor de edad. No eres abonado a nuestra web</code>, o por el contrario <code>Hola Pedro, eres menor de edad. Eres abonado en nuestra web. Enhorabuena.</code></li> </ul>"},{"location":"bloque_i/tema_2/page-7/","title":"7 Conversi\u00f3n de tipos","text":""},{"location":"bloque_i/tema_2/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>La mayor\u00eda de las veces, los operados y las funciones realizan conversiones autom\u00e1ticas de los tipos que reciben por el tipo que requieren. Por ejemplo, cualquier valor pasado al m\u00e9todo <code>log</code> del <code>console</code> es convertido a cadena.</p> <p>Tambi\u00e9n, en ciertas ocasiones, es necesario realizar dicha conversi\u00f3n de forma expl\u00edcita. Existen diferentes funciones para realizar dicha conversi\u00f3n.</p>"},{"location":"bloque_i/tema_2/page-7/#conversion-explicita-a-cadena","title":"Conversi\u00f3n expl\u00edcita a cadena","text":"<p>Vamos a convertir un valor a cadena cuando necesitamos que dicho valor sea usado como tal. Es una de las conversiones m\u00e1s sencillas, ya que sea obtiene el mismo valor pero con comillas. Por ejemplo, <code>2</code> ser\u00eda <code>\"2\"</code>, <code>undefined</code> <code>\"undefined\"</code>, <code>false</code> <code>\"false\"</code>.</p> <p>Para convertir un valor a una cadena podemos hacer uso de la funci\u00f3n <code>String(value)</code></p> <pre><code>const number = 3\nconst numberString = String(number)\n</code></pre> <p>Tambi\u00e9n podemos usar las backticks introduciendo el valor a convertir dentro del <code>${...}</code>:</p> <pre><code>const number = 3\nconst numberString = `${number}`\nconsole.log(typeof numberString) // string\n</code></pre>"},{"location":"bloque_i/tema_2/page-7/#conversion-explicita-a-numero","title":"Conversi\u00f3n expl\u00edcita a n\u00famero","text":"<p>La conversi\u00f3n num\u00e9rica ocurre en funciones matem\u00e1ticas y expresiones. Por ejemplo, al hacer <code>\"3\" / \"3\"</code>, las cadenas se convierten autom\u00e1ticamente en n\u00famero. Sin embargo, si se desea hacer una conversi\u00f3n expl\u00edcita, es necesario hacer uso de la funci\u00f3n <code>Number(value)</code>.</p> <p>Warning</p> <p>El \u00fanico operador matem\u00e1tico que no realiza la conversi\u00f3n de cadenas autom\u00e1tica a n\u00famero es el operador de adici\u00f3n <code>+</code>. Este operador se entiende en dicho caso, como un operador de concatenaci\u00f3n de cadenas. Para poder hacer una operaci\u00f3n de adici\u00f3n de una cadena y un n\u00famero, es necesario hacer la conversi\u00f3n expl\u00edcita de la cadena a n\u00famero:</p> <pre><code>console.log(3 + \"3\") // 33\nconsole.log(3 + Number(\"3\")) // 6\n</code></pre> <p>Para pasar una cadena a n\u00famero se sigue los siguientes pasos:</p> <ol> <li>Se eliminan los espacios de las cadenas. Por lo que, si tenemos una cadena `\"  233  \", los espacios no afectar\u00edan a la conversi\u00f3n.</li> <li>Si la cadena resultante es vac\u00eda, se convierte al n\u00famero 0.</li> <li>Si la cadena resultante es una cadena de d\u00edgitos (solo contiene n\u00fameros), se convierte a n\u00famero.</li> <li>Si la cadena resultante es una cadena que contiene alg\u00fan car\u00e1cter distinto a un d\u00edgito, la conversi\u00f3n ser\u00eda err\u00f3nea y retornar\u00eda <code>NaN</code>.</li> </ol> <p>Existen cadenas especiales que pueden ser convertidos a n\u00fameros de base de decimal (base 10). Por ejemplo, para indicar que una cadena es una representaci\u00f3n num\u00e9rica octal, se debe usar <code>0o</code>. <code>0x</code> y <code>0b</code> representan una cadena hexadecimal y binaria, respectivamente:</p> <pre><code>console.log(Number(\"0o10\")) // 8 (octal)\nconsole.log(Number(\"2e1\")) // 20 (notaci\u00f3n exponencial)\nconsole.log(Number(\"0b10100\")) // 20 (binaria)\nconsole.log(Number(\"0xF\")) // 15 (hexadecimal)\n</code></pre> <p>Por desgracia, el m\u00e9todo <code>Number</code> no puede parsear unidades de medida a n\u00famero:</p> <pre><code>console.log('20px') // NaN\n</code></pre> <p>Si se desea parsear una valor booleano a un n\u00famero, ser\u00e1 convertido a 0 si el valor del booleano es <code>false</code>, y a 1 si es <code>true</code>.</p> <pre><code>console.log(Number(true)) // 1\nconsole.log(Number(false)) // 0 \n</code></pre> <p>De la misma manera, el tipo <code>undefined</code> se convierte como <code>NaN</code> y el tipo <code>null</code> se convierte a 0.</p> <pre><code>console.log(Number(null)) // 0\nconsole.log(Number(undefined)) // 1\n</code></pre> <p>Existen otros m\u00e9todos para parsear un valor a n\u00famero, <code>parseInt(value)</code> y <code>parseDouble(value)</code>. Su funcionamiento es similar, pero en el primer caso realiza la conversi\u00f3n a n\u00famero entero, y en el segundo a n\u00famero decimal.</p> <p>Warning</p> <p>Los m\u00e9todos <code>parseInt</code> y <code>parseDouble</code> solo sirven para pasar cadenas con d\u00edgitos. Cualquier otro tipo de valor (incluso las cadenas especiales para representar n\u00fameros de otras bases) retornar\u00eda <code>NaN</code> como resultado.</p> <pre><code>console.log(parseInt(false)) // NaN\nconsole.log(parseInt(\"0b1000\")) // NaN\n</code></pre> <p>Las funciones pueden recibir un segundo par\u00e1metro que indique la base a la que se desea convertir la cadena, sin necesidad de hacer el uso de cadenas especiales, como en el caso de <code>Number()</code>. Si no lo recibe, se usar\u00eda la base diez (decimal) por defecto.</p> <pre><code>console.log(parseInt(\"101000\", 2)) // 20\nconsole.log(parseInt(\"010\"), 8) // 8\nconsole.log(parseInt(\"0xF\"), 16) // 15\n</code></pre> <p>Al usar este n\u00famero con una cadena que comience con un n\u00famero, convierte la cadena en dicho n\u00famero ignorando el resto de la cadena. Por ello, este m\u00e9todo, si permite parsear unidades:</p> <pre><code>console.log(parseInt(\"2000 hola mundo\")) // 2000\nconsole.log(parseInt(\"20 hola 50\")) //20\nconsole.log(parseInt(\"0b10100\")) // 0\nconsole.log(parseInt(\"20em\")) // 20\n</code></pre> <p>Existe una manera m\u00e1s sencilla de realizar la conversi\u00f3n de manera expl\u00edcita, haciendo uso del operador unario <code>+</code>. Al usar dicho operador delante del valor a convertir, se convierte de forma autom\u00e1tica. Aunque si se usa en operaciones con varios operando, hay que tener en cuenta la precedencia, aunque dicho operador tiene mayor precedencia que los operadores matem\u00e1ticos.</p> <pre><code>console.log(+\"3\") //3\nconsole.log(+false) //0\nconsole.log(+true) // 1\nconsole.log(+null) // 0\nconsole.log(+undefined) //NaN\nconsole.log(+\"Hola\") // NaN\nconsole.log(+\"0b10100\") // 20\nconsole.log(+\"2e1\") // 20\nconsole.log(3 + +\"4\") // 7\n</code></pre>"},{"location":"bloque_i/tema_2/page-7/#conversion-explicita-a-boolean","title":"Conversi\u00f3n expl\u00edcita a boolean","text":"<p>Convertir a booleano es una de las operaciones de conversi\u00f3n m\u00e1s simples. Siguiendo las siguientes reglas:</p> <ul> <li>Los valores vac\u00edos, como <code>undefined</code>, <code>0</code>, <code>null</code>, <code>''</code>, <code>NaN</code> se convierten a <code>false</code>.</li> <li>El resto de valores se convierten a <code>true</code>.</li> </ul> <p>Para realizar la conversi\u00f3n expl\u00edcita de los valores, se hace uso de la funci\u00f3n <code>Boolean(value)</code>:</p> <pre><code>console.log(Boolean(1)) // true\nconsole.log(Boolean(0)) // false\nconsole.log(\"\") // false\nconsole.log(\"Hola\") // true\n</code></pre> <p>Warning</p> <p>Algunos lenguajes, como PHP, entiende la cadena <code>\"0\"</code> como <code>false</code>. Pero, en Javascript, cualquier cadena no vac\u00eda es siempre <code>true</code>. Al igual que ocurre con una cadena con solo espacios <code>\" \"</code></p> <pre><code>console.log(Boolean(\"0\")) // true\nconsole.log(Boolean(\" \")) // true\n</code></pre> <p>Existen otras formas de conversi\u00f3n impl\u00edcitas a booleanos, como los operadores l\u00f3gicos, las estructura <code>if</code>, etc.</p>"},{"location":"bloque_i/tema_3/page-1/","title":"1 Condicionales","text":""},{"location":"bloque_i/tema_3/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Los programas se construyen para procesar datos, manipul\u00e1ndolos de formas diferentes dependiendo de los valores que tengan. Los lenguajes de programaci\u00f3n deben proveer estructuras que les permitan a los programadores controlar el flujo de ejecuci\u00f3n de un programa dependiendo de los datos que procesan. Para ello, se incluyen las sentencias de control de flujo, que alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</p> <p>La programaci\u00f3n estructurada es un paradigma de programaci\u00f3n orientado a mejorar la claridad, calidad y tiempo de desarrollo de un programa de computadora recurriendo \u00fanicamente a subrutinas y tres estructuras b\u00e1sicas: secuencia, sentencias condicionales y bucles.</p>"},{"location":"bloque_i/tema_3/page-1/#secuencia-condicional","title":"Secuencia condicional","text":"<p>La ejecuci\u00f3n secuencial es el m\u00e1s b\u00e1sico de los mecanismos de control de flujo y consiste en la ejecuci\u00f3n de instrucciones en el orden en que se encuentran en el c\u00f3digo fuente del programa.</p> <p>Hasta ahora las instrucciones que hemos visto, son instrucciones que se ejecutan secuencialmente; es decir, podemos saber lo que hace el programa leyendo las l\u00edneas de izquierda a derecha y de arriba abajo.</p> <p>La sentencia condicional consiste en ejecutar instrucciones diferentes dependiendo del resultado de evaluar una expresi\u00f3n l\u00f3gica. Una expresi\u00f3n l\u00f3gica es cualquier tipo de expresi\u00f3n que devuelva un resultado booleano (<code>true</code> o <code>false</code>).</p>"},{"location":"bloque_i/tema_3/page-1/#condicional-simple","title":"Condicional Simple","text":"<p>El condicional simple es la estructura que ejecuta una serie de condiciones si cumple una condici\u00f3n:</p> <pre><code>if(condici\u00f3n){\n// instrucciones\n}\n</code></pre> <p>Por ejemplo:</p> <pre><code>const number = 10\nif(number &gt; 5){\nconsole.log(\"The number is greater than 5\")\n}\n</code></pre> <p>En caso de que no se cumpla la condici\u00f3n, no se ejecutar\u00e1 nada:</p> <pre><code>const number = 4\nif(number &gt; 5){\nconsole.log(\"The number is greater than 5\")\n}\n</code></pre> <p>Warning</p> <p>La sentencia <code>if(...)</code> se encarga de evaluar la expresi\u00f3n de dentro del par\u00e9ntesis y convertir su resultado en booleano, en caso de no serlo. Para ello, sigue las reglas de conversi\u00f3n vistas en el tema anterior.</p>"},{"location":"bloque_i/tema_3/page-1/#condicional-doble","title":"Condicional doble","text":"<p>Es igual que la anterior, s\u00f3lo que se a\u00f1ade un apartado <code>else</code> que contiene instrucciones que se ejecutar\u00e1n si la expresi\u00f3n evaluada por el <code>if</code> es falsa.</p> <pre><code>if(condici\u00f3n){\n// instrucciones si es verdadera\n} else {\n// instrucciones si es falsa\n}\n</code></pre> <p>En este caso, se comprueba si la condici\u00f3n del <code>if</code> es verdadera y en caso de serlo se ejecuta las instrucciones. Por el contrario, se ejecuta el conjunto de instrucciones del <code>else</code>.</p> <pre><code>if(number){\nconsole.log('La variable number existe y su valor es', number)\n} else {\nconsole.log('La variable number no existe')\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#condicional-multiple","title":"Condicional m\u00faltiple","text":""},{"location":"bloque_i/tema_3/page-1/#anidacion","title":"Anidaci\u00f3n","text":"<p>Dentro de una sentencia <code>if</code> se puede colocar otra sentencia <code>if</code>. A esto se le llama anidaci\u00f3n y permite crear programas donde se valoren expresiones complejas. La nueva sentencia puede ir tanto en la parte if como en la parte else.</p> <p>Las anidaciones se utilizan much\u00edsimo al programar. Solo hay que tener en cuenta que siempre se debe cerrar primero el \u00faltimo <code>if</code> que se abri\u00f3. Es muy importante tambi\u00e9n tabular el c\u00f3digo correctamente para que las anidaciones sean legibles.</p> <p>Ejemplo:</p> <pre><code>if(x == 1){\n// instrucciones\n} else {\nif(x == 2){\n// instrucciones\n} else {\nif(x == 3){\n// instrucciones\n}\n}\n}\n</code></pre> <p>Una forma m\u00e1s legible de escribir ese mismo c\u00f3digo dando lugar a la llamada estructura <code>if-else-if</code> ser\u00eda:</p> <pre><code>if(x == 1){\n// instrucciones\n} else if(x == 2){\n// instrucciones\n} else if(x == 3){\n// instrucciones\n}\n</code></pre> <p>Cuando se cumpla alguna de las condiciones, se ejecutan sus instrucciones correspondientes y despu\u00e9s ya se sale de la estructura if-else-if ya que las condiciones son autoexcluyentes, es decir, solamente se va a cumplir una. Por eso, no estar\u00eda bien hacer lo siguiente:</p> <pre><code>if(x == 1){ // Forma incorrecta de programar\n// instrucciones\n}\nif(x == 2){\n// instrucciones\n}\nif(x == 3){\n// instrucciones\n}\n</code></pre> <p>El motivo de que no sea adecuado es porque se pierde tiempo en comprobar todas las condiciones. Por ejemplo, si x vale 1, se ejecutan sus instrucciones correspondientes y luego se comprobar\u00eda si x vale 2, si x vale 3, etc. cuando no se va a cumplir ninguna m\u00e1s ya que si x vale 1 no puede valer ni 2 ni 3.</p> <pre><code>const age = parseInt(prompt(\"Introduzca su edad: \"))\nif (age &gt;= 18) {\nconsole.log(\"Eres mayor de edad\");\n} else if (age &gt;= 16 &amp;&amp; age &lt; 18) {\nconsole.log(\"Eres menor de edad pero tienes ciertos privilegios\");\n} else if (age &gt;= 14 &amp;&amp; age &lt; 16) {\nconsole.log(\"Eres menor de edad y adem\u00e1s no tienes privilegios\");\n} else {\nconsole.log(\"Eres menor de edad\");\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#switch","title":"Switch","text":"<p>El cuerpo de una sentencia <code>switch</code> se conoce como bloque switch. Esta sentencia eval\u00faa una expresi\u00f3n y cada <code>case</code> contiene un posible valor del resultado de dicha expresi\u00f3n; si efectivamente el resultado equivale a ese valor, se ejecutan las instrucciones de ese <code>case</code> y de los siguientes.</p> <pre><code>switch(expresi\u00f3n) {\ncase valor1 :\ninstrucciones\nbreak; // opcional\ncase valor2 :\ninstrucciones\nbreak; // opcional\n//....\n//....\ndefault : // opcional\ninstrucciones\nbreak; // opcional\n}\n</code></pre> <p>La instrucci\u00f3n <code>break</code> se utiliza para salir del <code>switch</code>. De tal modo que si queremos que para un determinado valor se ejecuten las instrucciones de un apartado <code>case</code> y solo las de ese apartado, entonces habr\u00e1 que finalizar ese <code>case</code> con un <code>break</code>. Cuando se alcanza una sentencia <code>break</code>, el <code>switch</code> termina y el flujo de control salta a la siguiente l\u00ednea que sigue a la sentencia <code>switch</code>.</p> <p>Fall through condition (condici\u00f3n de ca\u00edda): esta condici\u00f3n se produce en la sentencia <code>switch</code> cuando no se utiliza <code>break</code> en un <code>case</code> y causa la ejecuci\u00f3n de los siguientes <code>case</code> hasta que no se produce un break o se sale de la sentencia switch.</p> <p>El bloque <code>default</code> sirve para ejecutar instrucciones para los casos en los que la expresi\u00f3n no se ajuste a ning\u00fan case. T\u00e9cnicamente, el <code>break</code> del <code>default</code> no es necesario porque el flujo se sale de la sentencia <code>switch</code>, pero se recomienda utilizarlo para que la modificaci\u00f3n del c\u00f3digo sea m\u00e1s f\u00e1cil y menos propensa a errores.</p> <p>En ciertas ocasiones, se puede usar la sentencia <code>return</code> en lugar de la sentencia <code>break</code>, sobretodo cuando queremos que la estructura <code>switch</code> devuelva un valor, por ejemplo, dentro de una funci\u00f3n.</p> <pre><code>let a = 2 + 2;\nswitch (a) {\ncase 3:\nconsole.log('Muy peque\u00f1o');\nbreak;\ncase 4:\nconsole.log('\u00a1Exacto!');\nbreak;\ncase 5:\nconsole.log('Muy grande');\nbreak;\ndefault:\nconsole.log(\"Desconozco estos valores\");\n}\n</code></pre> <p>Expresiones</p> <p>Ambos <code>switch</code> y <code>case</code> permiten expresiones arbitrarias.</p> <pre><code>let a = \"1\";\nlet b = 0;\nswitch (+a) {\ncase b + 1:\nalert(\"esto se ejecuta, porque +a es 1, exactamente igual b+1\");\nbreak;\ndefault:\nalert(\"esto no se ejecuta\");\n}\n</code></pre> <p>Se pueden agrupar varias sentencias <code>case</code> en caso de que se desee que hagan las mismas instrucciones:</p> <pre><code>let a = 2 + 2;\nswitch (a) {\ncase 4:\nconsole.log('\u00a1Correcto!');\nbreak;\ncase 3:\ncase 5:\nconsole.log('\u00a1Incorrecto!');\nconsole.log(\"\u00bfPor qu\u00e9 no tomas una clase de matem\u00e1ticas?\");\nbreak;\ndefault:\nconsole.log('El resultado es extra\u00f1o. Realmente.');\n}\n</code></pre> <p>\u00a1Cuidado!</p> <p>Hay que tener en cuenta, que el tipo de dato a evaluar en las expresiones IMPORTAN, por lo que no es lo mismo evaluar el valor <code>\"3\"</code> que el valor <code>3</code>:</p> <pre><code>let arg = prompt(\"Ingrese un valor\");\nswitch (arg) {\ncase '0':\ncase '1':\nconsole.log('Uno o cero');\nbreak;\ncase '2':\nconsole.log('Dos');\nbreak;\ncase 3:\nconsole.log('\u00a1Nunca ejecuta!');\nbreak;\ndefault:\nconsole.log('Un valor desconocido');\n}\n</code></pre> <p>En el caso anterior, si el usuario introduce un valor entre 0 y 2, se ejecutar\u00e1 las instrucciones pertinentes. Pero, si introduce un 3, se ejecutar\u00e1 las instrucciones <code>default</code>, ya que el 3 introducido por el usuario es de tipo <code>string</code> y el que se esta evaluando en el <code>case</code> es de tipo <code>number</code> y las sentencias <code>case</code> hacen comparaciones estrictas, es decir, como si usar\u00e1n el comparador <code>===</code></p>"},{"location":"bloque_i/tema_3/page-1/#operador-ternario","title":"Operador Ternario","text":"<p>Como ya vimos en el tema anterior, el operador ternario realiza una funci\u00f3n id\u00e9ntica a la estructura condicional. La diferencia entre ambas es que el operador ternario es una expresi\u00f3n, que dependiendo de su valor devuelve un valor u otro, mientras que la estructura condicional, es una estructura que eval\u00faa una expresi\u00f3n y ejecuta una serie de instrucciones, seg\u00fan el valor de esa expresi\u00f3n.</p> <p>Se recomienda el uso de operador ternario, siempre que se desea devolver un valor dependiendo de una condici\u00f3n y no para la ejecuci\u00f3n de instrucciones. Por lo que, NO se recomienda hacer lo siguiente:</p> <pre><code>(company == 'Netscape') ?\nalert('\u00a1Correcto!') : alert('Equivocado.');\n</code></pre> <p>Para eso se recomienda el uso de la estructura condicional:</p> <pre><code>if (company == 'Netscape') {\nalert('\u00a1Correcto!');\n} else {\nalert('Equivocado.');\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>\u00bfSe ejecutar\u00e1 la siguiente instrucci\u00f3n? Justifica tu respuesta.</p> <pre><code>if(\"0\"){\nconsole.log('Hello')\n}\n</code></pre> Ejercicio 2 <p>Realizar un programa que le pregunte al usuario el nombre oficial de Javascript. Si el usuario introduce ECMAScript se mostrar\u00e1 por consola y de color verde una frase exitosa. Por el contrario, se mostrar\u00e1 en rojo, que la respuesta es incorrecta y se mostrar\u00e1 la respuesta correcta.</p> Ejercicio 3 <p>Realiza un programa que compruebe si un n\u00famero introducido por el usuario es un n\u00famero positivo, negativo o 0.</p> Ejercicio 4 <p>Reescribe el siguiente ejemplo, haciendo uso del operador ternario:</p> <pre><code>let result;\nif (a + b &lt; 4) {\nresult = 'Debajo';\n} else {\nresult = 'Encima';\n}\n</code></pre> Ejercicio 5 <p>Reescribe el siguiente ejemplo, haciendo uso de la estructura condicional:</p> <pre><code>let message = (login == 'Empleado') ? 'Hola' :\n(login == 'Director') ? 'Felicidades' :\n(login == '') ? 'Sin sesi\u00f3n' :\n'';\n</code></pre> Ejercicio 6 <p>Realiza un programa que lea tres n\u00fameros positivos y compruebe si son iguales. Por ejemplo: Si la entrada fuese 5 5 5, la salida deber\u00eda ser \u201chay tres n\u00fameros iguales a 5\u201d. Si la entrada fuese 4 6 4, la salida deber\u00eda ser \u201chay dos n\u00fameros iguales a 4\u201d. Si la entrada fuese 0 1 2, la salida deber\u00eda ser \u201cno hay n\u00fameros iguales\u201d.</p> Ejercicio 7 <p>Haciendo uso de la estructura condicional <code>if-else-if</code>, realiza un programa que solicite al usuario una nota y la eval\u00fae de la siguiente forma:</p> <ul> <li>0, 1, 2: Muy deficiente</li> <li>3, 4: Insuficiente</li> <li>5: Suficiente</li> <li>6: Bien</li> <li>7, 8: Notable</li> <li>9, 10: Sobresaliente</li> </ul> <p>Si introduce un n\u00famero diferente a los indicados anteriormente, mostrar\u00e1 un mensaje de error.</p> Ejercicio 8 <p>Realiza el mismo ejercicio anterior, haciendo uso de la estructura <code>switch</code>.</p> Ejercicio 9 <p>Realiza un programa que calcule el precio de un billete de ida y vuelta por avi\u00f3n, conociendo la distancia a recorrer, el n\u00famero de d\u00edas de estancia y sabiendo que si la distancia es superior a 1.000 Km y el n\u00famero de d\u00edas de estancia es superior a 7, la l\u00ednea a\u00e9rea le hace un descuento del 30 %. (Precio por kil\u00f3metro = 0,35 \u20ac).</p> Ejercicio 10 <p>Los empleados de una f\u00e1brica trabajan en dos turnos: diurno y nocturno. Se desea calcular el jornal diario de acuerdo con los siguientes tarifas: la tarifa de las horas diurnas es de 3 \u20ac por hora, mientras que el de las nocturnas es de 4,80 \u20ac po hora. Cuando se trata de un d\u00eda festivo, la tarifa se incrementa en 1,20 \u20ac por hora en el turno diurno y 1,80 \u20ac por hora en el nocturno.</p> Ejercicio 11 <p>Realiza un programa que dados tres n\u00fameros, los devuelva en orden ascendente.</p>"},{"location":"bloque_i/tema_3/page-2/","title":"2 Bucles","text":""},{"location":"bloque_i/tema_3/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>En programaci\u00f3n, un bucle o instrucci\u00f3n de control repetitiva (o iterativa) permite ejecutar una o m\u00e1s instrucciones varias veces, es decir, permite ejecutar un bloque de instrucciones repetidamente, escribi\u00e9ndolas una sola vez en el programa, reduciendo de este modo el c\u00f3digo del mismo. Cada vuelta que da el bucle se conoce como iteraci\u00f3n.</p> <p>Las variables que se utilizan en los bucles pueden tener distintas funciones:</p> <ul> <li>\u00edndice: es una variable que apunta a un recurso concreto. En los bucles, apunta al n\u00famero de iteraci\u00f3n. Se suelen utilizar por convenio los identificadores de variables <code>i</code>, <code>j</code> y <code>k</code>.</li> <li>contador: cuenta cu\u00e1ntas veces ocurre algo.</li> <li>acumulador: acumula operaciones parciales.</li> </ul> <p>Las instrucciones b\u00e1sicas que permiten construir este tipo de estructuras son <code>while</code>, <code>do-while</code> y <code>for</code>.</p>"},{"location":"bloque_i/tema_3/page-2/#while","title":"While","text":"<p>El bucle <code>while</code> agrupa instrucciones las cuales se ejecutan continuamente mientras una condici\u00f3n que se eval\u00faa sea verdadera. La condici\u00f3n se eval\u00faa antes de entrar dentro del <code>while</code> y cada vez que se termina de ejecutar las instrucciones del <code>while</code>.</p> <p>El programa se ejecuta siguiendo estos pasos:</p> <ol> <li>Se eval\u00faa la expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera ejecuta las instrucciones, sino el programa abandona la sentencia <code>while</code>.</li> <li>Tras ejecutar las instrucciones, volvemos al paso 1.</li> </ol> <pre><code>while(expresi\u00f3nL\u00f3gica){\n//instrucciones\n}\n</code></pre> <p>Por ejemplo, se quiere mostrar los n\u00fameros del 1 al 10:</p> <pre><code>let number = 0\nwhile(number &lt; 10){\nconsole.log(++number)\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#do-while","title":"Do-while","text":"<p>La \u00fanica diferencia respecto al <code>while</code> est\u00e1 en que la expresi\u00f3n l\u00f3gica se eval\u00faa despu\u00e9s de haber ejecutado las instrucciones. Es decir, el bucle al menos se ejecuta una vez. Los pasos son los siguientes:</p> <ol> <li>Ejecutar instrucciones.</li> <li>Evaluar expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera, volver al paso 1. Si es falsa, salir del do-while.</li> </ol> <p>El ejemplo anterior se har\u00eda de la siguiente manera:</p> <pre><code>let number = 0\ndo{\nconsole.log(++number)\n} while(number &lt; 10)\n</code></pre> <p>Se recomienda hacer uso de la estructura <code>do-while</code> cuando se desea que independientemente de la condici\u00f3n se ejecute las instrucciones al menos una vez. Uno de sus usos m\u00e1s comunes, es para pedir al usuario alg\u00fan dato, y en caso de que no se cumpla lo introducido se vuelva a introducir:</p> <pre><code>let number\ndo{\nnumber = parseInt(prompt('Introduce un n\u00famero entre 0 y 10'))\n} while(number &lt; 0 || number &gt; 10)\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#for","title":"For","text":"<p>El bucle <code>for</code> es una estructura de iteraci\u00f3n donde se utiliza una variable local que controle la iteraci\u00f3n. El funcionamiento es el siguiente:</p> <ol> <li>Se ejecuta la instrucci\u00f3n de inicializaci\u00f3n.</li> <li>Se comprueba la condici\u00f3n.</li> <li>Si la condici\u00f3n es cierta, entonces se ejecutan las instrucciones. Si la condici\u00f3n es falsa, se abandona el bloque for.</li> <li>Tras ejecutar las instrucciones, se ejecuta la instrucci\u00f3n de incremento y se vuelve al paso</li> </ol> <pre><code>for(inicializaci\u00f3n;condici\u00f3n;incremento){\n// instrucciones\n}\n</code></pre> <p>As\u00ed el ejemplo anterior:</p> <pre><code>for(let number = 1; number &lt;= 10; number++){\nconsole.log(number)\n}\n</code></pre> <p>La inicializaci\u00f3n se puede hacer tanto como dentro como fuera del bucle, aunque se recomienda hacer uso de ella dentro.</p> <p>Tambi\u00e9n se admite m\u00e1s de una variable, en cuyo caso, en las partes de inicializaci\u00f3n e incremento, se utiliza como separador la coma <code>,</code>:</p> <pre><code>for(int i = 0, j = 10; i &lt;= j; i++, j--){\nconsole.log(`i: ${i} j: ${j}`);\n}\n</code></pre> <p>Danger</p> <p>Por motivos de legibilidad de c\u00f3digo, es muy importante que las variables del <code>for</code> aparezcan en las 3 partes del <code>for</code>, es decir, en la inicializaci\u00f3n, en la condici\u00f3n y en el incremento, ya que el programador que quiera saber cu\u00e1ntas iteraciones realiza el bucle, solamente con fijarse en la l\u00ednea de c\u00f3digo donde se encuentra el <code>for</code>, pueda saberlo. Si las variables del <code>for</code> no aparecen en las 3 partes, eso nos indica que es m\u00e1s conveniente realizar un <code>while</code> o un <code>do-while</code>.</p> <p>Veamos el ejemplo que muestra n\u00fameros aleatorios entre 1 y 500 hasta que salga uno m\u00faltiplo de 7:</p> <pre><code>boolean exit = false;\nint number = 0, i;\nfor(i = 1; !exit; i++){ // Este for no es legible, se debe sustituir por un do-while\nnumber = Math.floor((Math.random() * 500) + 1);\nSystem.out.printf(\"Iteraci\u00f3n %d, n\u00famero: %d\\n\", i, number);\nexit = (number % 7 == 0);\n}\nSystem.out.printf(\"El m\u00faltiplo de 7 con valor %d se ha encontrado en la iteraci\u00f3n %d\", number, i - 1);\n</code></pre> <p>En Javascript, podemos omitir las siguientes partes:</p> <ul> <li> <p>La inicializaci\u00f3n, si se realiza fuera del bucle:</p> <pre><code>let i = 0\nfor (; i &lt; 3; i++) { alert(i)\n}\n</code></pre> </li> <li> <p>El incremento si se hace dentro del bucle:</p> <pre><code>let i = 0;\nfor (; i &lt; 3;) {\nalert( i++ );\n}\n</code></pre> </li> <li> <p>Todo, si no se desea que el bucle tenga l\u00edmite, es decir, que sea un bucle infinito.</p> <pre><code>for (;;) {\n// se repite sin limites\n}\n</code></pre> </li> </ul> <p>En cualquiera de los casos, es obligatorio el uso del punto y coma <code>;</code> para que no de un error de sintaxis.</p>"},{"location":"bloque_i/tema_3/page-2/#diferencias","title":"Diferencias","text":"<p>Todos los bucles se pueden hacer con <code>for</code>, <code>while</code> y <code>do-while</code>, entonces, \u00bfcu\u00e1l se debe usar? Es importante que le programador utilice la estructura m\u00e1s adecuada en cada caso:</p> <ul> <li>Un bucle <code>for</code> se utiliza cuando se conozca el n\u00famero de veces que se va a ejecutar el bucle, es decir, cuando se conozcan el n\u00famero de iteraciones de antemano.</li> <li>Si no se sabe de antemano el n\u00famero de iteraciones, entonces hay que utilizar <code>while</code> o <code>do-while</code>:</li> <li>Un bucle <code>do-while</code> se utiliza cuando las instrucciones del bucle se van a ejecutar al menos una vez.</li> <li>Un bucle <code>while</code> se utiliza, entonces, cuando las instrucciones del bucle pueden no ejecutarse nunca si la condici\u00f3n es falsa desde un principio.</li> </ul>"},{"location":"bloque_i/tema_3/page-2/#bucles-forin-forof","title":"Bucles for..in for..of","text":"<p>El bucle <code>for..in</code> es un bucle que sirve para recorrer un objeto en Javascript:</p> <pre><code>for (key in object) {\n// se ejecuta el cuerpo para cada clave entre las propiedades del objeto\n}\n</code></pre> <p>Por ejemplo:</p> <pre><code>let user = {\nname: \"John\",\nage: 30,\nisAdmin: true\n}\nfor (let key in user) {\nconsole.log(key, user[key])\n}\n</code></pre> <p>El bucle <code>for..of</code> se utiliza para recorrer los valores de un array:</p> <pre><code>const array = [1,2,3,4]\nfor(let a of array){\nconsole.log(a)\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Dados dos n\u00fameros <code>n1</code> y <code>n2</code>, tal que <code>n1 &lt;= n2</code>, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle <code>while</code>.</p> Ejercicio 2 <p>Realiza el ejercicio anterior haciendo uso del bucle <code>do-while</code>.</p> Ejercicio 3 <p>Realiza el ejercicio anterior haciendo uso del bucle <code>for</code>.</p> Ejercicio 4 <p>\u00bfCu\u00e1l es el \u00faltimo valor mostrado en alerta por este c\u00f3digo? \u00bfPor qu\u00e9?</p> <pre><code>let i = 3\nwhile (i) {\nconsole.log(i--)\n}\n</code></pre> Ejercicio 5 <p>Muestra los n\u00fameros pares comprendido entre 0 y 10. Usa el bucle que creas correspondiente, justificando su uso.</p> Ejercicio 6 <p>Escribe un bucle que solicite un n\u00famero mayor que 100. Si el usuario ingresa otro n\u00famero p\u00eddele que ingrese un valor de nuevo.</p> <p>El bucle debe pedir un n\u00famero hasta que el usuario ingrese un n\u00famero mayor que 100 o bien cancele la entrada o ingrese una linea vac\u00eda.</p> <p>Aqu\u00ed podemos asumir que el usuario solo ingresar\u00e1 n\u00fameros. No hay necesidad de implementar un manejo especial para entradas no num\u00e9ricas en esta tarea.</p> Ejercicio 7 <p>Escribe un programa que le solicite al usuario un n\u00famero, y muestre los n\u00fameros primos comprendidos entre 0 y dicho n\u00famero. Para <code>n = 10</code> el resultado ser\u00e1 2, 3, 5, 7. El c\u00f3digo deber\u00eda funcionar para cualquier n, no debe estar programado para valores fijos.</p> Ejercicio 8 <p>Realiza un programa que muestre la tabla de multiplicar de un n\u00famero solicitado por el usuario. El n\u00famero que debe introducir debe ser comprendido entre 1 y 10. </p>"}]}