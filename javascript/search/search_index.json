{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to Javascript World</p> <pre><code>console.log('Hello World')\n</code></pre>"},{"location":"bloque_i/tema_1/page-1/","title":"1 Introducci\u00f3n a Javascript","text":""},{"location":"bloque_i/tema_1/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Javascript es un lenguaje de programaci\u00f3n utilizado para crear p\u00e1ginas web din\u00e1micas e interactivas. Es el lenguaje de scripting m\u00e1s utilizado en la web y lo emplean los desarrolladores para a\u00f1adir funcionalidad a sitios web y aplicaciones.</p> <p>Puede utilizarse para crear interfaces de usuario interactivas, crear aplicaciones del lado del servidor, conectar bases de datos y mucho m\u00e1s. Su c\u00f3digo de programaci\u00f3n se ha convertido en una parte esencial del desarrollo web moderno y puede encontrarse en pr\u00e1cticamente todas las aplicaciones web.</p> <p>Javascript fue creado en 1995 como una forma de a\u00f1adir programaci\u00f3n a las p\u00e1ginas web. El lenguaje ha sido adoptado por la gran mayor\u00eda de los navegadores web. Una de sus aplicaciones m\u00e1s modernas es dirigirse a otras p\u00e1ginas web sin necesidad de realizar una recarga en el navegador. Adem\u00e1s permite interactuar de varias formas diferentes con la p\u00e1gina web.</p> <p>As\u00ed mismo, es compatible con todos los navegadores modernos, lo cual lo hace un lenguaje esencial por su versatilidad con diferentes plataformas.</p> <p>En general, con este lenguaje se incluye dinamismo al navegar un sitio web, cuando antes se caracterizaban por ser est\u00e1ticos. Es decir, un mejoramiento de la experiencia del usuario y al mismo tiempo, una optimizaci\u00f3n de procesos debido a su facilidad de uso tanto del lado del cliente, como del servidor.</p> <p>Entre sus tareas m\u00e1s comunes podemos encontrar el uso de bases de datos, optimizaci\u00f3n de las funciones de una plataforma y el desarrollo tanto de web apps como aplicaciones m\u00f3viles.</p>"},{"location":"bloque_i/tema_1/page-1/#historia","title":"Historia","text":"<p>JavaScript se introdujo en 1995 como una forma de agregar programas a p\u00e1ginas web en el navegador Netscape Navigator. En su momento fue una idea novedosa. En los primeros d\u00edas de la World Wide Web, HTML era bastante simple, y bastante f\u00e1cil de aprender casi todo lo que se necesitaba saber para agrupar p\u00e1ginas web. Cualquiera pod\u00eda hacer una Web juntando tablas, texto y a\u00f1adiendo alguna imagen.</p> <p>A principios de los a\u00f1os 90, la mayor\u00eda de usuarios que se conectaban a Internet lo hac\u00edan con m\u00f3dems a una velocidad m\u00e1xima de 28.8 kbps. Esa velocidad era m\u00e1s que suficiente para la \u00e9poca salvo que quisieras descargar imagenes de cierto tama\u00f1o. Lo cierto era que la web en aquel entonces no ofrec\u00eda gran cosa m\u00e1s que servir como una inmensa biblioteca donde los usuarios consultaban mayormente contenido basado en texto pero la evoluci\u00f3n que conocemos hoy estaba por llegar y pod\u00edan verse los primeros pasos.</p> <p>En esa \u00e9poca, empezaban a desarrollarse las primeras aplicaciones web y por tanto, las p\u00e1ginas web comenzaban a incluir formularios complejos. Con unas aplicaciones web cada vez m\u00e1s complejas y una velocidad de navegaci\u00f3n tan lenta, surgi\u00f3 la necesidad de un lenguaje de programaci\u00f3n que se ejecutara en el navegador del usuario. De esta forma, si el usuario no rellenaba correctamente un formulario, no se le hac\u00eda esperar mucho tiempo hasta que el servidor volviera a mostrar el formulario indicando los errores existentes.</p> <p>Desde entonces, el lenguaje ha sido adoptado por todos los dem\u00e1s navegadores gr\u00e1ficos principales. Ha hecho posibles las aplicaciones web modernas, aplicaciones con las que puede interactuar directamente sin hacer una recarga de p\u00e1gina para cada acci\u00f3n.</p> <p>En la actualidad los navegadores web no son las \u00fanicas plataformas en las que se utiliza JavaScript. Tambi\u00e9n es posible ejecutar c\u00f3digo JavaScript en un entorno servidor. De hecho las bases de datos, como MongoDB y CouchDB, usan JavaScript como su lenguaje de scripting y consulta. Varias plataformas para la programaci\u00f3n de escritorio y servidor, en particular el proyecto Node.js proporcionan un entorno para la programaci\u00f3n de JavaScript fuera del navegador.</p> <p>Warning</p> <p>Es importante recalcar que el lenguaje de programaci\u00f3n Javascript no tiene casi nada que ver con el lenguaje de programaci\u00f3n Java. La similitud entre ambos nombres se debe a una estrategia de marketing. Java ya era un lenguaje introducido fuertemente en el mercado cuando Javascript aterriz\u00f3 y dispon\u00eda de una amplia popularidad.</p>"},{"location":"bloque_i/tema_1/page-1/#evolucion","title":"Evoluci\u00f3n","text":"<p>Aunque JavaScript surgi\u00f3 como un lenguaje de script para mejorar las capacidades de la web de la \u00e9poca all\u00e1 por 1995 por la extinta Netscape, JavaScript no ha dejado de evolucionar desde entonces. Originalmente el lenguaje se basaba a su vez basaba en CEnvi desarrollado a su vez por Nombas.</p> <p>Brendan Eich, un programador que trabajaba en Netscape, pens\u00f3 que podr\u00eda solucionar las limitaciones de la web de entonces, adaptando otras tecnolog\u00edas existentes (como ScriptEase) al navegador Netscape Navigator 2.0, que iba a lanzarse en aquel a\u00f1o. Inicialmente, Eich denomin\u00f3 a su lenguaje LiveScript y fue un \u00e9xito.</p> <p>Fue entonces cuando, justo antes del lanzamiento, Netscape decidi\u00f3 cambiar el nombre por el de JavaScript y firm\u00f3 una alianza con Sun Microsystems para continuar el desarrollo del nuevo lenguaje de programaci\u00f3n.</p> <p>Microsoft, al ver el movimiento de uno de sus principales competidores, tambi\u00e9n decidi\u00f3 incorporar su propia implementaci\u00f3n de este lenguaje, llamada JScript, en la versi\u00f3n 3 de su navegador Internet Explorer.</p> <p>Esto contribuy\u00f3 todav\u00eda m\u00e1s al empuje y popularizaci\u00f3n del lenguaje, pero comenzaron a presentarse peque\u00f1os problemas por las diferencias entre implementaciones. A partir de estos hechos un documento est\u00e1ndar fue creado para describir la manera en que el lenguaje deber\u00eda funcionar. Dicho documento es conocido como ECMAScript standard. En la pr\u00e1ctica, los t\u00e9rminos ECMAScript y Javascript pueden ser intercambiados, por lo que habr\u00eda dos nombres identificativos para el mismo lenguaje.</p>"},{"location":"bloque_i/tema_1/page-1/#funciones-y-caracteristicas","title":"Funciones y caracter\u00edsticas","text":"<p>Entre las funciones que podemos encontrar en Javascript est\u00e1n:</p> <ul> <li>Agregar efectos visuales y de interacci\u00f3n a una p\u00e1gina web.</li> <li>Validaci\u00f3n de formularios.</li> <li>Automatizaci\u00f3n de tareas.</li> <li>Crear aplicaciones del lado del servidor.</li> <li>Crear chatbots.</li> <li>Desarrollo de aplicaciones m\u00f3viles y juegos.</li> <li>Crear mapas interactivos.</li> <li>Crear gr\u00e1ficos y visualizaciones de datos.</li> <li>Crear aplicaciones web progresivas (PWA)</li> </ul> <p>Adem\u00e1s, cuenta con las siguientes caracter\u00edsticas:</p> <ul> <li>Lenguaje multiplataforma: Puede ser utilizado en muchos marcos y plataformas, as\u00ed como puede ejecutarse en cualquier m\u00e1quina independientemente del sistema operativo de \u00e9sta.</li> <li>Lenguaje interpretado: Tiene un int\u00e9rprete que se encarga de traducir el c\u00f3digo Javascript a c\u00f3digo m\u00e1quina.</li> <li>Lenguaje orientado a objetos: Se basa en usar estructuras de datos orientados a objetos.</li> <li>Lenguaje de alto nivel: Puede ser comprendido de forma sencilla, sin complicaciones.</li> <li>Lenguaje tipado d\u00e9bil: No permite definir al desarrollador el tipo de los datos, as\u00ed como el tipo de dato puede ser cambiado en tiempo de ejecuci\u00f3n.</li> </ul> <p>Manuales</p> <p>MDN (Mozilla) JavaScript Reference es el manual principal, con ejemplos y otras informaciones. Es fant\u00e1stico para obtener informaci\u00f3n exhaustiva sobre funciones individuales del lenguaje, m\u00e9todos, etc.</p> <p>Adem\u00e1s, Javascript es un lenguaje en evoluci\u00f3n, y normalmente se a\u00f1aden nuevas caracter\u00edsticas. Para ver la compatibilidad por navegador y otros motores, consultar:</p> <ul> <li>https://caniuse.com \u2013 tablas de compatibilidad por caracter\u00edstica. Por ejemplo, para comprobar qu\u00e9 motores soportan funciones modernas de criptograf\u00eda: https://caniuse.com/#feat=cryptography. </li> <li>https://kangax.github.io/compat-table \u2013 tabla que muestra la compatibilidad o no de las prestaciones del lenguaje por motor.</li> </ul>"},{"location":"bloque_i/tema_1/page-2/","title":"2 Consola de desarrollador","text":""},{"location":"bloque_i/tema_1/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Un script es un fichero con c\u00f3digo Javascript que contiene las instrucciones que deseemos que se ejecuten en el entorno que queramos que sean ejecutadas. Un entorno de ejecuci\u00f3n es el lugar donde se va a ejecutar el c\u00f3digo incrustado en nuestro script.</p> <p>El entorno de ejecuci\u00f3n por defecto y m\u00e1s \u00fatil de Javascript es el navegador. Sin embargo, existen otros tipos de entornos de ejecuci\u00f3n como un dispositivo m\u00f3vil o la consola de nuestro ordenador.</p>"},{"location":"bloque_i/tema_1/page-2/#consola-del-navegador","title":"Consola del navegador","text":"<p>Una consola es un entorno en el que se puede ejecutar comandos y scripts. Todos los ordenadores tienen un consola instalada por defecto, pero hay ciertos programas que tienen sus propias consolas instaladas.</p> <p>El navegador tiene un integrado una consola para ver mensajes de error o de informaci\u00f3n, pero adem\u00e1s tambi\u00e9n poder ejecutar comandos. Dicha consola est\u00e1 basada y entiende el lenguaje de Javascript, por lo que es muy usada para el desarrollo de aplicaciones web con Javascript.</p> <p>Para poder acceder a ella, se deber\u00e1 acceder a las DevTools de nuestro navegador, y desde ah\u00ed acceder a la pesta\u00f1a Console. En algunos navegadores, existe el shortcut Ctrl+Shift+I para poder abrir las herramientas de desarrollador.</p>"},{"location":"bloque_i/tema_1/page-2/#console","title":"Console","text":"<p>El objeto <code>console</code> es el objeto predeterminado de Javascript para poder interactuar con la consola. Este objeto tiene diferentes m\u00e9todos que podemos usar para trabajar en la consola de formas diferentes:</p> <ul> <li> <p><code>log</code>. Se utiliza para mostrar mensajes de informaci\u00f3n en la consola. Es uno de los m\u00e1s usados. Tambi\u00e9n se puede usar <code>info</code>.</p> <pre><code>console.log('Hello world')\n</code></pre> </li> <li> <p><code>debug</code>. Muestra informaci\u00f3n con todo tipo de detalles.</p> <pre><code>console.debug('This is a debug message')\n</code></pre> </li> <li> <p><code>warn</code>. Se utiliza para mostrar una advertencia. Suele ir destacado en amarillo.</p> <pre><code>console.warn('This is a warn message')\n</code></pre> </li> <li> <p><code>error</code>. Se utiliza para mostrar mensajes de error. Suele ir destacado en rojo.</p> <pre><code>console.error('This is an error message')\n</code></pre> </li> <li> <p><code>clear</code>. Sirve para limpiar la consola, es decir, elimina los mensajes e instrucciones mostrados.</p> </li> </ul> <p>A la derecha de la consola de las DevTools hay un men\u00fa de opciones para poder filtrar los mensajes de la consola por el tipo de mensaje que sea seg\u00fan el m\u00e9todo utilizado.</p> <p>Se puede pasar diferentes mensajes en una misma llamada de la funci\u00f3n, separando cada mensaje por una coma. Esto producir\u00e1 que los mensajes se muestre uno al lado del otro.</p> <pre><code>console.log('This is a', 'message')\n</code></pre>"},{"location":"bloque_i/tema_1/page-2/#estilizar-mensajes","title":"Estilizar mensajes","text":"<p>Se puede estilizar los mensajes de consola, haciendo uso de instrucciones CSS. Para ello, las funciones usadas anteriormente pueden recibir un segundo argumento con una cadena que contenga el estilo CSS a aplicar. Para que no confunda la segunda cadena como un texto a mostrar, es importante que la primera cadena empiece con <code>%c</code>, de esta forma la consola entender\u00e1 que la siguiente instrucci\u00f3n es un estilo y no un mensaje a mostrar:</p> <pre><code>console.log('%cThis is a styled message', 'color: blue')\n</code></pre>"},{"location":"bloque_i/tema_1/page-2/#agrupar-mensajes","title":"Agrupar mensajes","text":"<p>Para mostrar los mensajes en un grupo, podemos usar los siguientes m\u00e9todo del objeto <code>console</code>:</p> <ul> <li><code>group</code>. Sirve para inicializar el grupo de mensajes. Puede recibir el nombre del grupo. Con <code>groupCollapsed</code> inicializa el grupo de mensajes, pero lo muestra colapsado.</li> <li><code>groupEnd</code>. Sirve para finalizar el grupo.</li> </ul> <p>Entre ambos m\u00e9todos se puede escribir diferentes tipos de mensajes, y en la consola de mostrar\u00e1 agrupados.</p>"},{"location":"bloque_i/tema_1/page-2/#tablas","title":"Tablas","text":"<p>Se puede mostrar los arrays y los objetos, que veremos m\u00e1s adelante, en forma de tabla haciendo uso del m\u00e9todo <code>table</code> del objecto <code>console</code>.</p> <pre><code>console.table(users);\n</code></pre>"},{"location":"bloque_i/tema_1/page-2/#assert","title":"Assert","text":"<p>El m\u00e9todo <code>assert</code> sirve para mostrar un mensaje en consola siempre y cuando se cumpla una condici\u00f3n.</p> <pre><code>console.assert(5 &lt; 10, \"5 es menor que 10\"); // No ocurre nada\nconsole.assert(5 &lt; 0, \"5 es menor que 0\"); // Muestra el mensaje indicado con un aviso de error\n</code></pre>"},{"location":"bloque_i/tema_1/page-3/","title":"3 C\u00f3digo Javascript","text":""},{"location":"bloque_i/tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos dicho, un script es un conjunto de instrucciones para ser ejecutadas. Para ejecutar un script de Javascript en el navegador, se pueden hacer de formas diferentes:</p> <ul> <li>Haciendo uso de la etiqueta HTML <code>script</code>.</li> <li>Creando un fichero Javascript e importando dicho fichero a un fichero HTML.</li> </ul> <p>Cada vez que usamos una de esta formas el c\u00f3digo Javascript se ejecutar\u00e1 cada vez que accedamos a la p\u00e1gina HTML d\u00f3nde se ha incrustado dicho c\u00f3digo.</p>"},{"location":"bloque_i/tema_1/page-3/#etiqueta-script","title":"Etiqueta script","text":"<p>La etiqueta <code>script</code> es una etiqueta HTML que permite introducir c\u00f3digo Javascript para que el navegador puede utilizar dicho c\u00f3digo. En dicha etiqueta podemos indicar las diferentes instrucciones a ejecutar. Normalmente la etiqueta puede ser utilizada en cualquier parte del documento, pero se recomienda su uso dentro de la etiqueta <code>head</code> o al final de la etiqueta <code>body</code>, antes de su cierre.</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;!--... --&gt;\n&lt;script&gt;\nconsole.log('This is a Javascript script')\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script&gt;\nconsole.log('This is a Javascript script')\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Podemos crear un fichero Javascript (de extension <code>.js</code>) con las instrucciones e insertar dicho fichero en un documento HTML, haciendo uso del atributo <code>src</code> de la etiqueta <code>script</code>:</p> JavascriptHTML <pre><code>console.log('This is a Javascript script')\n</code></pre> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;!--... --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script src=\"fichero.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Otra atributo que puede recibir dicha etiqueta es el atributo <code>type</code> para indicar el tipo script que se va a insertar. Para los archivos Javascript, el tipo es <code>type=\"text/javascript\"</code>.</p> <p>Tips</p> <p>En la mayor\u00eda de los casos se recomienda crear un fichero a parte e insertarlo en nuestro documento HTML. La ventaja de un archivo separado es que el navegador lo descargar\u00e1 y lo almacenar\u00e1 en cach\u00e9.</p> <p>Otras p\u00e1ginas que hacen referencia al mismo script lo tomar\u00e1n del cach\u00e9 en lugar de descargarlo, por lo que el archivo solo se descarga una vez.</p> <p>Eso reduce el tr\u00e1fico y hace que las p\u00e1ginas sean m\u00e1s r\u00e1pidas.</p> <p>Warning</p> <p>Una sola etiqueta <code>&lt;script&gt;</code> no puede tener el atributo <code>src</code> y c\u00f3digo dentro.</p> <pre><code>&lt;script src=\"file.js\"&gt;\nalert(1); // el contenido se ignora porque se estableci\u00f3 src\n&lt;/script&gt;\n</code></pre> <p>Debemos elegir un <code>&lt;script src=\"\u2026\"&gt;</code> externo o un <code>&lt;script&gt;</code> normal con c\u00f3digo.</p> <p>El ejemplo anterior se puede dividir en dos scripts para que funcione:</p> <pre><code>&lt;script src=\"file.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nalert(1);\n&lt;/script&gt;\n</code></pre>"},{"location":"bloque_i/tema_1/page-3/#orden-de-insercion","title":"Orden de inserci\u00f3n","text":"<p>En un mismo documento HTML, podemos tener diferentes etiquetas Javascript, en la parte del documento que m\u00e1s nos interesa. Es importante recalcar que el orden de utilizaci\u00f3n de esta etiqueta, ya que HTML se ejecuta de forma secuencial, es decir, l\u00ednea a l\u00ednea. Por ejemplo, si tenemos un documento HTML con un elemento <code>h1</code> y un script que trabaje con dicho <code>h1</code>, no es recomendable que el script se ejecute antes del <code>h1</code> ya que no puede tener acceso a dicho elemento, porque cuando se ejecute la l\u00ednea, este elemento a\u00fan no existe.</p> <p>Por este motivo, se recomienda insertar las librer\u00edas JAvascript en el <code>head</code> del documento, y las instrucciones que trabajen con el DOM como \u00faltima instrucci\u00f3n dentro de la etiqueta <code>body</code>.</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;!--...--&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Hello world&lt;/h1&gt;\n&lt;script&gt;\nconsole.log('Hello world')\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>En el ejemplo anterior, primero se mostrar\u00e1 el <code>h1</code> y luego se ejecutar\u00e1 y se mostrar\u00e1 el mensaje del <code>console.log()</code>.</p>"},{"location":"bloque_i/tema_1/page-3/#etiqueta-noscript","title":"Etiqueta noscript","text":"<p>En ciertas ocasiones, el navegador no es compatible con Javascript (cosa poco probable) o tiene desactivada la opci\u00f3n de Javascript en el navegador.</p> <p>La etiqueta <code>&lt;noscript&gt;</code> muestra un contenido alternativo para los usuarios que tiene desactivada la opci\u00f3n en su navegador o no es compatible.</p> <pre><code>&lt;script&gt;\nconsole.log(\"Hello World!\")\n&lt;/script&gt;\n&lt;noscript&gt;Your browser does not support JavaScript!&lt;/noscript&gt;\n</code></pre>"},{"location":"bloque_i/tema_2/page-1/","title":"1 Estructura del c\u00f3digo","text":""},{"location":"bloque_i/tema_2/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Las instrucciones de Javascript se pueden a\u00f1adir a un fichero de extensi\u00f3n <code>.js</code> e importarlo o directamente escribirlo en el documento a trav\u00e9s de la etiqueta <code>&lt;script&gt;&lt;/script&gt;</code>.</p> <p>Es importante destacar que el c\u00f3digo son las l\u00edneas del fichero que emiten ordenes para ser ejecutadas.</p>"},{"location":"bloque_i/tema_2/page-1/#sentencia","title":"Sentencia","text":"<p>Las sentencias son construcciones sint\u00e1cticas y comando que realiza acciones. Una sentencia es la unidad m\u00ednima de ejecuci\u00f3n de un programa. Un programa se compone de conjunto de sentencias que acaban resolviendo un problema.</p> <p>En nuestro c\u00f3digo, puede haber tantas sentencias como sea necesarias separadas por un punto y coma <code>;</code> o un salto de l\u00ednea.</p> <p>Tips</p> <p>Se aconseja que las sentencias se escriban separadas en l\u00ednea, para as\u00ed tener una mayor legibilidad del c\u00f3digo y facilitar as\u00ed su entendimiento.</p> <p>Veamos ejemplos de sentencias:</p> <pre><code>console.log('Mi primera sentencia');\nconsole.log('Mi segunda sentencia, pero no termina en punto y coma')\nconsole.log('\u00daltima sentencia de este script')\n</code></pre> <p>\u00a1CUIDADO!</p> <p>En la mayor\u00eda de los casos, un salto de l\u00ednea implica un punto y coma de forma impl\u00edcita, pero en NO siempre es as\u00ed. Podemos tener una sentencia y querer escribirla en diferentes l\u00edneas, el int\u00e9rprete sobre entiende que dicho salto de l\u00ednea no es un punto y como impl\u00edcito, si no una separaci\u00f3n normal, por lo que se ejecutar\u00eda la sentencia tal y como se desea:</p> <pre><code>console.log(3\n+\n2);\n</code></pre> <p>En el ejemplo anterior la salida es <code>5</code>, que es el resultado de sumar <code>3 + 2</code></p> <p>Hay que tener cuidado, porque en cierta ocasiones un salto de l\u00ednea no implica un punto y coma impl\u00edcito, sino que por el contrario se entiende como una separaci\u00f3n de c\u00f3digo y es algo que no el desarrollador no ha contemplado. Para dicho caso, se recomienda separar las l\u00edneas de c\u00f3digo con un punto y coma expl\u00edcito <code>;</code>. Veamos un ejemplo:</p> <pre><code>console.log('Hola mundo')\n[1, 2].forEach(console.log) // (1)!\n</code></pre> <ol> <li>\u274cEsto da error, porque se intenta ejecutar de la siguiente manera <code>console.log('Hola mundo')[1, 2].forEach(console.log)</code>, es decir, como una \u00fanica sentencia en lugar de dos.\u274c</li> </ol> <p>Para evitar el error anterior, se debe colocar punto y coma en la l\u00ednea que da problemas, y as\u00ed indicar que se trata de m\u00e1s de una sentencia:</p> <pre><code>console.log('Hola mundo');\n[1, 2].forEach(console.log)\n</code></pre> <p>Tips</p> <p>Es cierto que en la comunidad existen dos tipos de personas, los que utilizan el punto y coma en cada sentencia, o los que usa un salto de l\u00ednea en su lugar. Cada uno debe usar la t\u00e9cnica que mejor le parezca, pero siempre y cuando se intente evitar los errores mencionados anteriormente,</p>"},{"location":"bloque_i/tema_2/page-1/#comentarios","title":"Comentarios","text":"<p>Los comentarios son parte del c\u00f3digo que NO van a ser ejecutadas y se utilizan para dar informaci\u00f3n extra del c\u00f3digo que se esta desarrollando. Pueden ir escritos en cualquier lugar del script y son ignoradas por el motor (int\u00e9rprete) del navegador, por lo que el usuario no podr\u00e1 visualizarlos. Existen dos tipos de comentarios:</p> <ul> <li> <p>Comentarios en l\u00ednea: Solo ocupan un l\u00ednea y suelen usarse para comentarios puntuales y breves. Comienzan con dos barras diagonales <code>//</code>:</p> <pre><code>// Este es mi primer comentario en l\u00ednea\nconsole.log('Hey!')\n</code></pre> </li> <li> <p>Comentarios en bloque: Ocupan varias l\u00edneas y suelen usarse para comentarios m\u00e1s extensos. Comienzan con una barra inclinada y un asterisco <code>/*</code> y terminan con un asterisco y una barra inclinada <code>*/</code>:</p> <pre><code>/*\nEste es \nmi primer\ncomentario en \nbloque.\n*/\nconsole.log('Hey!')\n</code></pre> </li> </ul> <p>Los comentarios son una parte esencial del c\u00f3digo ya que proveen informaci\u00f3n sobre el mismo y ayudan a recordarnos a nosotros mismos porque decimos escribir dicho c\u00f3digo, adem\u00e1s de que si el c\u00f3digo es creado en grupo, ayuda a que todo el equipo entienda cual es nuestro objetivo con \u00e9l.</p> <p>Sin embargo, no se recomienda usar los comentarios para informaci\u00f3n personal, como contrase\u00f1as, ya que desde DevTools se puede acceder al script completo incluyendo los comentarios. Existen ciertas herramientas que para evitar eso, minimizan los scripts, eliminando los comentarios, que es lo recomendados antes de la publicaci\u00f3n de nuestra aplicaci\u00f3n.</p> <p>Warning</p> <p>No se permite escribir comentarios anidados, y en caso de intentarlo, ser\u00eda lanzado un error:</p> <pre><code>/*\n  /* comentario anidado ?!? */\n*/\nconsole.log( 'Mundo' );\n</code></pre>"},{"location":"bloque_i/tema_2/page-1/#expresiones","title":"Expresiones","text":"<p>Una expresi\u00f3n es una combinaci\u00f3n de operadores y operandos que se eval\u00faa gener\u00e1ndose un \u00fanico resultado de un tipo determinado.</p> <pre><code>console.log(3 + 2);\n</code></pre> <p>La diferencia entre las sentencias y las expresiones es que las expresiones devuelven un valor y las sentencias no devuelven nada.</p>"},{"location":"bloque_i/tema_2/page-1/#bloque","title":"Bloque","text":"<p>Un bloque es un conjunto de sentencias las cuales est\u00e1n delimitadas por llaves:</p> <pre><code>{\n// sentencias\n}\n</code></pre>"},{"location":"bloque_i/tema_2/page-2/","title":"2 Modo estricto","text":""},{"location":"bloque_i/tema_2/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Durante mucho tiempo, JavaScript evolucion\u00f3 sin problemas de compatibilidad. Se a\u00f1ad\u00edan nuevas caracter\u00edsticas al lenguaje sin que la funcionalidad existente cambiase.</p> <p>Esto ten\u00eda el beneficio de nunca romper c\u00f3digo existente, pero lo malo era que cualquier error o decisi\u00f3n incorrecta tomada por los creadores de JavaScript se quedaba para siempre en el lenguaje.</p> <p>Esto fue as\u00ed hasta 2009, cuando ECMAScript 5 (ES5) apareci\u00f3. Esta versi\u00f3n a\u00f1adi\u00f3 nuevas caracter\u00edsticas al lenguaje y modific\u00f3 algunas de las ya existentes. Entre ellas el uso estricto.</p>"},{"location":"bloque_i/tema_2/page-2/#use-strict","title":"use-strict","text":"<p>El use-strict es una nueva directiva del ES5 que indica que el c\u00f3digo debe ejecutarse en modo estricto. Todos los navegadores modernos admiten el use-strict, excepto Internet Explorer 9 y versiones anteriores.</p> <p>Para poder declarar el modo estricto, se puede realizar de dos formas:</p> <ul> <li> <p>Alcance global. Se usa el modo estricto en todo el script. Para ello, debe ser declarado como la primera sentencia de nuestro script.</p> <pre><code>\"use strict\"\nconsole.log('Hello world')\n</code></pre> </li> <li> <p>Alcance local. Se usa el modo estricto \u00fanicamente en la funci\u00f3n indicada. Para ello, debe ser declarado como la primera sentencia de nuestra funci\u00f3n.</p> <pre><code>console.log('Hello world')\nfunction con(){\n'use strict'\nconsole.log('This is a function')\n}\n</code></pre> </li> </ul> <p>!!! danger '!OJO!'</p> <pre><code>Si se desea un alcance global y se declara el modo estricto en una l\u00ednea diferente a la primera, el modo estricto es completamente ignorado:\n\n```javascript\nconsole.log('Hello world')\n\n'use strict' // \u274c No funciona\n```\n</code></pre> <p>El uso del modo estricto permite la escritura de c\u00f3digo Javascript de forma segura. Javascript es un lenguaje ampliamente flexible, lo que en ciertas ocasiones puede resultar peligroso. Al hacer uso del modo estricto podemos evitar que algunos de esos error se lleguen a cometer. Por ejemplo, en Javascript se puede usar una variable sin ser declarada previamente, lo que por defecto no se mostrar\u00e1 como un error al programador. Sin embargo, con el modo estricto dicha mala pr\u00e1ctica ser\u00e1 marcada como un error.</p>"},{"location":"bloque_i/tema_2/page-2/#prohibiciones-del-modo-estricto","title":"Prohibiciones del modo estricto","text":"<p>El modo estricto tiene cierta prohibiciones, es decir, cosas que con Javascript normal no se lanzar\u00eda un error, pero con el modo estricto s\u00ed. Varios de los conceptos descritos a continuaci\u00f3n, a\u00fan no han sido tratados, por lo que se recomienda visitar este apartado con cierta regularidad.</p> <p>Entre sus prohibiciones podemos encontrar:</p> <ul> <li> <p>No permite usar ni una variable ni un objeto sin declararlo.</p> <pre><code>x = 3.14 //\u274c\n</code></pre> </li> <li> <p>No permite eliminar ni una variable ni un objeto ni una funci\u00f3n.</p> <pre><code>let x = 3.14\ndelete x // \u274c\n</code></pre> </li> <li> <p>No se permite duplicar el nombre de un par\u00e1metro de una funci\u00f3n.</p> <pre><code>function myFunction(x1, x1){} //\u274c\n</code></pre> </li> <li> <p>No se permite literales num\u00e9ricos octales, ni caracteres de escape octal.</p> <pre><code>let x = 010 // \u274c\nlet x = \"\\010\" // \u274c\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_2/page-2/#se-deberia-usar","title":"\u00bfSe deber\u00eda usar?","text":"<p>Aunque la pregunta parece obvia, ciertamente no lo es. Se recomienda el uso de <code>use strict</code>, pero es cierto que las librer\u00edas actuales de Javascript tienen habilitada autom\u00e1ticamente esta opci\u00f3n, por lo que no ser\u00eda necesario que fuera usado expl\u00edcitamente por nosotros. Adem\u00e1s, las clases y m\u00f3dulos de Javascript tambi\u00e9n tienen activada dicha opci\u00f3n por defecto, por lo que tampoco ser\u00eda necesario.</p> <p>Tips</p> <p>Se recomienda que durante el desarrollo de Javascript b\u00e1sico si exista la posibilidad de usar el modo estricto, y una vez avanzado a las clases y m\u00f3dulos, dejar de usarlo.</p>"},{"location":"bloque_i/tema_2/page-3/","title":"3 Variables y constantes","text":""},{"location":"bloque_i/tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>A la largo del desarrollo de un script es necesario utilizar cierta informaci\u00f3n de forma repetida, por lo que es \u00fatil poder almacenar dicha informaci\u00f3n y poder usarlo en las partes del c\u00f3digo en las que sean necesarias.</p> <p>En programaci\u00f3n, existen las variables y las constantes para desempe\u00f1ar dicha funci\u00f3n.</p>"},{"location":"bloque_i/tema_2/page-3/#variables","title":"Variables","text":"<p>Las variables son contenedores que sirven para almacenar los datos que utiliza un programa. Dicho m\u00e1s sencillamente, son nombres que asociamos a determinados datos. La realidad es que cada variable ocupa un espacio en la memoria RAM del ordenador para almacenar el dato al que se refiere. Es decir, cuando utilizamos el nombre de la variable realmente estamos haciendo referencia a un dato que est\u00e1 en memoria.</p> <p>En Javascript existen dos limitaciones para nombrar a una variable:</p> <ol> <li>El nombre \u00fanicamente puede incluir letras, d\u00edgitos o los s\u00edmbolos <code>$</code> y <code>_</code>. Ejemplo: <code>$var</code>, <code>_var</code>, <code>var123</code>.</li> <li>El primer car\u00e1cter no puede ser un d\u00edgito. Ejemplo err\u00f3neos: <code>1var</code>.</li> </ol> <p>Se recomienda hacer uso de nombres descriptivos pero breves. La elecci\u00f3n de un nombre de variable debe ser mnem\u00f3nico, es decir, dise\u00f1ado para indicar al observador casual la intenci\u00f3n de su uso. Por ejemplo, si queremos usar una variable para almacenar una edad, la llamaremos <code>edad</code>. Adem\u00e1s se deber\u00eda evitar los nombres de variables de un solo car\u00e1cter excepto para las variables temporales usar y tirar. Los nombres comunes de las variables temporales son <code>i</code>, <code>j</code>, <code>k</code>, <code>m</code>, y <code>n</code> para enteros; <code>c</code>, <code>d</code>, y <code>e</code> para los caracteres.</p> <p>El estilo del nombre de las variables suele camelCase (o lowerCamelCase), es decir, las palabras van seguidas una detr\u00e1s de otra, con cada inicial en may\u00fascula, excepto la primera que va en min\u00fascula: <code>miPrimeraVariable</code>.</p> <p>Warning</p> <p>Es importante tener en cuenta la capitalizaci\u00f3n, ya que el mismo nombre escrito de formas diferentes da a lugar a dos variables distintas. <code>manzana</code> y <code>MANZANA</code> son dos variables distintas a pesar de tener el mismo nombre.</p> <p>Javascript permite escribir letras de cualquier alfabeto incluyendo letras del cir\u00edlico, logogramas chinos, etc., incluso nuestra letra <code>\u00f1</code>, pero no se recomienda su uso ya que existe una tradici\u00f3n internacional de utilizar ingl\u00e9s en el nombramiento de variables. Incluso si estamos escribiendo un script peque\u00f1o, este puede tener una larga vida por delante. Puede ser necesario que gente de otros pa\u00edses deba leerlo en alg\u00fan momento.</p> <p>Otra prohibici\u00f3n a tener en cuenta a la hora de nombra variables es que no se pueden utilizar palabras que usa el mismo lenguaje. Estas palabras son denominadas como palabras reservadas. Por ejemplo, no se puede usar la palabra <code>let</code> como nombre de variable. En la siguiente web, puedes conocer el listado oficial de este tipo de palabras: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords</p>"},{"location":"bloque_i/tema_2/page-3/#declaracion-de-una-variable","title":"Declaraci\u00f3n de una variable","text":"<p>Para declarar una variable es necesario usar la palabra <code>let</code> seguida del nombre de la variable:</p> <pre><code>let miPrimeraVariable\n</code></pre> <p>Se puede inicializar una variable, o cambiar el valor de la misma haciendo uso del operador <code>=</code>:</p> <pre><code>miPrimeraVariable = 10\n</code></pre> <p>Adem\u00e1s, se puede acceder a dicha variable usando su nombre:</p> <pre><code>let message message = 'Hello world'\nconsole.log(message)\n</code></pre> <p>Javascript permite definir una variable, es decir, declarar e inicializar una variable en una \u00fanica l\u00ednea:</p> <pre><code>let message = \"hello world\"\n</code></pre> <p>Tambi\u00e9n se puede definir y declarar varias variables en una sola l\u00ednea, separadas por coma <code>,</code>:</p> <pre><code>let name = 'John Doe', age = 25, message = 'Hello world'\n</code></pre> <p>Lo anterior, se podr\u00eda hacer en m\u00faltiples l\u00ednea, aunque no se recomienda:</p> <pre><code>let name = 'John Doe', age = 25, message = 'Hello world'\n</code></pre> <p>Tips</p> <p>Por norma general, se recomienda definir o declarar las variables en l\u00edneas diferentes con diferentes <code>let</code>. Aunque, es cierto que si son pocas variables y con informaci\u00f3n f\u00e1cil de leer, se podr\u00eda usar la forma m\u00faltiple lineal sin problema.</p> <p>Warning</p> <p>Declarar dos veces la misma variable produce un error de ejecuci\u00f3n.</p> <pre><code>let message = \"This\";\nlet message = \"That\"; // SyntaxError: 'message' ya fue declarado\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#funcionamiento-de-una-variable","title":"Funcionamiento de una variable","text":"<p>Podemos entender una variable como una caja que se encarga de almacenar informaci\u00f3n relevante para nuestro c\u00f3digo. Cuando una variable es declarada (no inicializada), estamos creando dicha caja, y una vez inicializada, almacenamos en la caja el valor correspondiente. Cuando una variable es modificada, su valor actual es eliminado de la caja y se inserta el nuevo valor en ella. Veamos un ejemplo:</p> <pre><code>let message //(1)!\nmessage = 'Hello world' //(2)!\nmessage = 'Goodbye' //(3)!\n</code></pre> <ol> <li>Se crea la caja para almacenar informaci\u00f3n.</li> <li>Se almacena el valor Hello World por primera vez en la caja.</li> <li>Se elimina el valor Hello World y se a\u00f1ade el nuevo valor Goodbye.</li> </ol> <p>Esto en realizar se refiere a que cuando creamos una variable, se reserva un espacio de memoria y al inicializarla se escribe el dato deseado en su interior. Cuando se modifica, ese dato se elimina y se sobreescribe el nuevo valor.</p>"},{"location":"bloque_i/tema_2/page-3/#ambito-de-vida-de-las-variables","title":"\u00c1mbito de vida de las variables","text":"<p>Toda variable tiene un \u00e1mbito de vida. Esto es la parte del c\u00f3digo en la que una variable se puede utilizar, que es en el bloque donde se ha declarado. De hecho las variables tienen un ciclo de vida:</p> <ol> <li>En la declaraci\u00f3n se reserva el espacio necesario para que se puedan comenzar a utilizar (digamos que se avisa de su futura existencia)</li> <li>Se la asigna su primer valor (la variable nace)</li> <li>Se la utiliza en diversas sentencias. Cuando finaliza el bloque en el que fue declarada, la variable muere. Es decir, se libera el espacio que ocupa esa variable en memoria.</li> <li>Una vez que la variable ha sido eliminada, no se puede utilizar. Dicho de otro modo, no se puede utilizar una variable m\u00e1s all\u00e1 del bloque en el que ha sido definida. Ejemplo:</li> </ol> <p>Podemos entender que una variable puede tener un \u00e1mbito de vida local o global. Podemos entender como una variable global, como aquella variable que puede ser accedida desde cualquier parte de nuestro script, es decir, la variable es declarada en el script y puede ser usada tanto dentro como fuera de cualquier bloque.</p> <pre><code>let number = 10\nconsole.log(number)\n</code></pre> <p>Por el contrario, una variable local es una variable que se declara dentro de un bloque y solo puede ser usada en dicho bloque y nunca fuera de \u00e9l:</p> <pre><code>{\nlet number = 10\nconsole.log(number)\n}\nconsole.log(number) // \u274c ReferenceError: number is not defined\n</code></pre> <p>Warning</p> <p>Normalmente, debemos definir una variable antes de utilizarla. Pero, en los viejos tiempos, era t\u00e9cnicamente posible crear una variable simplemente asignando un valor sin utilizar <code>let</code>. Esto a\u00fan funciona si no hacemos uso de <code>use strict</code> en nuestros scripts para mantener la compatibilidad con scripts antiguos.</p> <pre><code>num = 5; // se crea la variable \"num\" si no existe antes\nalert(num); // 5\n</code></pre> <p>Esto ser\u00eda una mala pr\u00e1ctica que se puede evitar haciendo del modo estricto:</p> <pre><code>\"use strict\";\nnum = 5; // \u274c error: num no est\u00e1 definida\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#constantes","title":"Constantes","text":"<p>Una constante es un valor que no puede ser modificado durante la ejecuci\u00f3n de un programa, \u00fanicamente puede ser le\u00eddo. Para crear una constante en Javascript se usa la palabra reservada <code>const</code> seguida del nombre de la variable y su inicializaci\u00f3n:</p> <pre><code>const miPrimeraConstante = 10\n</code></pre> <p>Al intentar modificar el valor de una variable producir\u00eda un error:</p> <pre><code>const miPrimeraConstante = 10\nmiPrimeraConstante = 20 // \u274c ERROR\n</code></pre> <p>Tips</p> <p>Existe una buena pr\u00e1ctica de escribir en may\u00fasculas y con guiones <code>_</code>, aquellas constantes que hacen referencia a ciertos datos que son dif\u00edciles de recordar, como por ejemplo el c\u00f3digo hexadecimal de un color:</p> <pre><code>const COLOR_RED = \"#F00\";\nconst COLOR_GREEN = \"#0F0\";\nconst COLOR_BLUE = \"#00F\";\nconst COLOR_ORANGE = \"#FF7F00\";\n</code></pre> <p>De esta forma podemos acceder al color rojo de una manera m\u00e1s sencilla usando su nombre de constante.</p> <p>Se aconseja escribir en may\u00fasculas aquellas constantes cuyo valor se conocen antes la ejecuci\u00f3n del programa y en min\u00fasculas aquellas cuyo valor se deben calcular u obtener durante la ejecuci\u00f3n:</p> <pre><code>const NAME = 'Server name'\nconst div = /*...*/\n</code></pre> <p>En el ejemplo anterior, la variable <code>NAME</code> se escribe en may\u00fasculas ya que es un valor que se conoce antes de ejecutar el script. Sin embargo, la variable <code>div</code> representa un elemento div del HTML por lo que no es un valor que se obtiene antes de la ejecuci\u00f3n del programa, sino que, por el contrario debe ser obtenido una vez se haya ejecutado el programa.</p>"},{"location":"bloque_i/tema_2/page-3/#var","title":"var","text":"<p>\u00a1OJO!</p> <p>La informaci\u00f3n transcrita en el siguiente punto tiene como objetivo \u00fanico INFORMAR sobre ciertos conocimientos antiguos de Javascript, por lo que NO se deber\u00edan llevar a la pr\u00e1ctica.</p> <p>La palabra reservada <code>var</code> se utilizaba en versiones anteriores de Javascript y tiene una utilizaci\u00f3n bastante similar a la palabra reservada <code>let</code>. Sin embargo, declarar una variable con <code>var</code> tiene ciertos usos peligrosos que fueren limitados con la incorporaci\u00f3n de <code>let</code>.</p> <p>Cuando declaramos una variable con <code>let</code> de forma global en nuestro script, dicha variable puede ser usada en cualquier parte de nuestro script, por lo que no se puede acceder a ella desde otros script (en caso de tener m\u00e1s de una etiqueta script en nuestro HTML, o diferentes m\u00f3dulos).</p> <pre><code>&lt;script&gt;\nlet number = 10\n&lt;/script&gt;\n&lt;script&gt;\n'use strict'\nconsole.log(number) // \u274c ERROR\n&lt;/script&gt;\n</code></pre> <p>Sin embargo, haciendo uso de la palabra <code>var</code>, esto si puede suceder, de forma que se puede declarar una variable en un script y poder usarlo en cualquier cualquier otro script, y en cualquier parte de nuestro c\u00f3digo, incluso si se declara dentro de un bloque:</p> <pre><code>&lt;script&gt;\n{\nvar number = 10\n}\n&lt;/script&gt;\n&lt;script&gt;\n'use strict'\nconsole.log(number)\n&lt;/script&gt;\n</code></pre> <p>Lo que ocurre en el ejemplo, no es una buena pr\u00e1ctica ya que exponemos a que nuestras variables sean modificadas desde cualquier parte, dentro o fuera de nuestro script.</p> <p>Otra de las malas pr\u00e1cticas que tiene el uso de <code>var</code>, es que permite redeclarar una variable, cosa que con el uso de <code>let</code> se ve limitado ya que lanza un error:</p> <pre><code>let number = 10\nlet number = 20 // \u274c ERROR\nvar number = 10\nvar number = 20\n</code></pre> <p>En este caso, se ignora la declaraci\u00f3n y \u00fanicamente se cambia su valor.</p> <p>Otra de las malas pr\u00e1cticas que tiene su uso es el hoisting (elevamiento). Permite inicializar la variable incluso antes de su declaraci\u00f3n, ya que no importa en el lugar que se declare porque siempre va a ser elevada al principio. Veamos un ejemplo:</p> <pre><code>phrase = \"Hello\";\nconsole.log(phrase);\nvar phrase;\n</code></pre> <p>En el c\u00f3digo anterior, permite inicializar la variable, y luego se declarar, aunque en realizar lo primero que se ejecuta es la declaraci\u00f3n debido al elevamiento. Esto puede provocar una dif\u00edcil legibilidad. El c\u00f3digo anterior, se ejecutar\u00eda de esta forma:</p> <pre><code>var phrase;\nphrase = \"Hello\";\nconsole.log(phrase);\n</code></pre>"},{"location":"bloque_i/tema_2/page-3/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Crea un script que realice los siguientes pasos:</p> <ol> <li>Declara dos variables: <code>admin</code> y <code>name</code>.</li> <li>Asigna el valor John a la variable <code>name</code>.</li> <li>Copia el valor de <code>name</code> en <code>admin</code>.</li> <li>Muestra por consola el valor de la variable <code>admin</code>, en color verde.</li> </ol> Ejercicio 2 <p>\u00bfC\u00f3mo nombrar\u00edas las siguientes variables?:</p> <ul> <li>Nombre actual del usuario que ha iniciado sesi\u00f3n en nuestra web.</li> <li>Nombre de nuestro planeta.</li> <li>Tiempo transcurrido desde el comienzo de una tarea, hasta su finalizaci\u00f3n.</li> <li>Fecha de nacimiento de un empleado.</li> <li>Capacidad m\u00e1xima de un disco duro.</li> <li>Capacidad ocupada de un disco duro.</li> <li>Capacidad sobrante de un disco duro.</li> </ul> Ejercicio 3 <p>Dado el siguiente c\u00f3digo, \u00bfcu\u00e1l dir\u00edas que deber\u00eda ir en may\u00fasculas? Justifica tu respuesta:</p> <pre><code>const birthday = '18.04.1982';\nconst age = calculateAgeFromDate(birthday);\n</code></pre>"},{"location":"bloque_i/tema_2/page-4/","title":"4 Tipos de datos b\u00e1sicos","text":""},{"location":"bloque_i/tema_2/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Javascript es un lenguaje tipado d\u00e9bil, es decir, no te obliga a indicar el tipo de las variables a la hora de declararlas. Sin embargo, esto no quiere decir que una variable no sea de un tipo especificado y que es bueno conocer los tipos de datos con los que se va a trabajar.</p> <p>Javascript tambi\u00e9n es un lenguaje din\u00e1micamente tipado. Esto quiere decir, que una variable puede ser declarada como un tipo, por ejemplo una cadena, y durante la ejecuci\u00f3n del programa puede pasar a ser un n\u00famero.</p> <pre><code>let variable = \"Hello\"\nvariable = 123\n</code></pre> <p>Aunque esto pueda parecer un gran acierto en Javascript, es cierto, que en ciertas ocasiones puede ser un problema, dependiendo de la utilidad que se le quiera dar a dicha variable. Por ejemplo, si queremos hacer una divisi\u00f3n, debemos disponer de dos n\u00fameros, si ahora bien, uno de esos n\u00fameros son introducidos por el usuario y \u00e9ste introduce una cadena, la operaci\u00f3n no ser\u00eda v\u00e1lida. Por ello, es recomendable realizar comprobaciones de tipo cuando sea necesario</p> <p>Existen ocho tipos de datos b\u00e1sicos diferentes en Javascript: <code>Number</code>, <code>BigInt</code>, <code>String</code>, <code>Boolean</code>, <code>null</code>, <code>undefined</code>, <code>Object</code> y <code>Symbol</code>. Adem\u00e1s, tambi\u00e9n existen otras estructuras de datos como las clases y los arrays.</p>"},{"location":"bloque_i/tema_2/page-4/#number","title":"Number","text":"<p>El tipo <code>number</code> representa los n\u00fameros en Javascript, tanto los n\u00fameros enteros, como los n\u00fameros de punto flotantes (decimales). El tipo <code>number</code> representa los n\u00fameros <code>+(2\u2075\u00b3+1)</code> y <code>-(2\u2075\u00b3-1)</code>.</p> <pre><code>let number = 2\nlet decimal = 1.60\n</code></pre> <p>Adem\u00e1s de los n\u00fameros comunes, existen los denominados valores num\u00e9ricos especiales que pertenecen a este tipo y representan un valor matem\u00e1tico especial:</p> <ul> <li><code>Infinity</code>. Representa el infinito matem\u00e1tico (<code>\u267e\ufe0f</code>). Es un n\u00famero especial que es mayor que cualquier otro n\u00famero. Haciendo uso del operador <code>-</code>, existir\u00e1 el <code>-Infinity</code> que representa el infinito negativo, siendo un n\u00famero m\u00e1s peque\u00f1o que cualquier otro. Este n\u00famero puede ser obtenido al dividir un n\u00famero entre 0.</li> <li> <p><code>NaN</code>. Representa un error de c\u00e1lculo. Es el resultado de un operaci\u00f3n matem\u00e1tica incorrecta o indefinida. Por ejemplo, es el resultado de dividir una cadena a un n\u00famero. Las siglas NaN significan Not a Number (No es n\u00famero), por lo que indica que el resultado de un operaci\u00f3n matem\u00e1tica que espera un n\u00famero no retorna el tipo esperado. Cualquier operaci\u00f3n que se haga con un operando de valor <code>NaN</code>, tambi\u00e9n devuelve un <code>NaN</code>, excepto <code>NaN ** 0 = 1</code>.</p> <p>Info</p> <p>Las operaciones matem\u00e1ticas, en Javascript, son operaciones seguras. A diferencia de otros lenguajes, como en Java, cuando se realizan operaciones vulnerables (dividir por cero, dividir una cadena por un n\u00famero) no lanza un error fatal, si no que por el contrario, si no que retorna un valor especial matem\u00e1tico como <code>NaN</code> o <code>Infinity</code>, salvaguardando as\u00ed el flujo de la aplicaci\u00f3n.</p> </li> </ul>"},{"location":"bloque_i/tema_2/page-4/#bigint","title":"BigInt","text":"<p>EL tipo <code>BigInt</code> representan n\u00fameros enteros de tama\u00f1o superior a <code>\u00b1(2\u2075\u00b3-1)</code>. Este tipo de n\u00famero existe, porque cuando se intenta realizar una operaci\u00f3n con <code>number</code> cuyo resultado quede fuera de dicho rango, habr\u00e1 un error de precisi\u00f3n:</p> <pre><code>console.log(9007199254740991 + 1); // 9007199254740992\nconsole.log(9007199254740991 + 2); // 9007199254740992\n</code></pre> <p>Para la mayor\u00eda de los prop\u00f3sitos, el rango de tipo <code>number</code> es suficiente, sin embargo a veces es necesario n\u00fameros realmente grandes, como para la criptograf\u00eda o estudios cient\u00edficos.</p> <p><code>BigInt</code> fue agregado recientemente a Javascript para solventar dicho problema de precisi\u00f3n. Para indicar que un n\u00famero es de tipo <code>BigInt</code> o no de tipo <code>number</code> se debe agregar una <code>n</code> al final de n\u00famero:</p> <pre><code>const bigInt = 1234567890123456789012345678901234567890n\n</code></pre>"},{"location":"bloque_i/tema_2/page-4/#string","title":"String","text":"<p>El tipo de dato <code>String</code> representa una cadena de caracteres y debe colocarse entre comillas:</p> <pre><code>const str = \"Soy una cadena\"\n</code></pre> <p>En Javascript se puede inicializar una cadena haciendo uso de tres tipos de comillas diferentes:</p> <ul> <li>Comillas dobles: <code>\"Hola\"</code>.</li> <li>Comillas simples: <code>'Hola'</code></li> <li>Comillas invertidas (backticks): <code>`Hola`</code></li> </ul> <p>Entre las comillas dobles y las comillas simples no existen diferencias entres ellas, simplemente sirven para mostrar literalmente el contenido de la cadena. Por ejemplo, si tengo la variable <code>sum = \"2+3\"</code> el valor de la variable es literalmente <code>2+3</code> y no <code>5</code>, que es el resultado de la suma.</p> <p>Por otro lado, las comillas backticks son comillas de funcionalidad extendida, es decir, nos permiten incrustar variables y expresiones de tal formal que el valor de la cadena sea el valor de la variable o expresi\u00f3n. Para ello, la variable o la expresi\u00f3n debe estar envuelta en <code>${...}</code>:</p> <pre><code>let name = \"John\"\nlet lastName = \"Doe\"\nlet fullName = `${name} ${lastName}`\nconsole.log(fullName) // \"John Doe\"\nlet number1 = 2\nlet number2 = 3\nlet result = `Result is ${number1 + number2}`\nconsole.log(result) // \"Result is 5\"\n</code></pre> <p>La expresi\u00f3n dentro de <code>${...}</code> se eval\u00faa y el resultado pasa a formar parte de la cadena. Podemos poner cualquier cosa ah\u00ed dentro: una variable como <code>name</code>, una expresi\u00f3n aritm\u00e9tica como <code>1 + 2</code>, o algo m\u00e1s complejo.</p> <p>Warning</p> <p>El uso de <code>${...}</code> solo se puede realizar con las backticks para el resto de comillas no funcionaria, ya que solo muestra el resultado literal:</p> <pre><code>const name = \"John\"\nconst lastName = \"Doe\"\nconst fullName = \"${name} ${lastName}\"\nconsole.log(fullName) // \"${name} ${lastName}\"\n</code></pre> <p>Info</p> <p>En algunos lenguajes, hay un tipo especial car\u00e1cter para un solo car\u00e1cter. Por ejemplo, en el lenguaje C y en Java es char.</p> <p>En JavaScript no existe tal tipo. S\u00f3lo hay un tipo: <code>string</code>. Un string puede estar formado por un solo car\u00e1cter, por ninguno, o por varios de ellos. </p> <p>Es importante conocer este dato, porque en ocasiones es necesario obtener solo un car\u00e1cter y el usuario es libre de introducir una cadena m\u00e1s ampl\u00eda, por lo que debe ser validado correctamente.</p>"},{"location":"bloque_i/tema_2/page-4/#boolean","title":"Boolean","text":"<p>El tipo <code>boolean</code> hace referencia a los valores <code>true</code> y <code>false</code>. Este tipo es usado com\u00fanmente para almacenar valores afirmativos (true) o negativos (false). Por ejemplo, s\u00ed, correcto, verdadero ser\u00edan formas de representar el valor <code>true</code>, mientras que no, incorrecto y falso para representar el valor <code>false</code>.</p> <pre><code>const isLegalAge = true\nconst isUserLogged = false\n</code></pre> <p>Los valores booleanos tambi\u00e9n son los resultados de realizar comparaciones, como veremos m\u00e1s adelante. Por ejemplo, <code>3 &gt; 4</code> ser\u00eda false ya que el n\u00famero 3 no es mayor que el n\u00famero 4.</p>"},{"location":"bloque_i/tema_2/page-4/#null","title":"null","text":"<p>En Javascript, el valor <code>null</code> hace referencia a un objeto inexistente. S\u00f3lo es un valor especial que representa nada, vac\u00edo o valor desconocido.</p> <pre><code>const age = null;\n</code></pre> <p>En el c\u00f3digo anterior, la variable <code>age</code> tiene un valor vac\u00edo o desconocido por que a\u00fan no ha sido calculado o est\u00e1 en espera de ser introducido.</p>"},{"location":"bloque_i/tema_2/page-4/#undefined","title":"undefined","text":"<p>En Javascript, cuando una variable es declarada pero no definida se dice que es de tipo <code>undefined</code> que literalmente significa no definida.</p> <p>La diferencia con <code>null</code>, es que el tipo <code>undefined</code> quiere decir que la caja que va a contener el valor a\u00fan no ha sido definida como tal, mientras que con <code>null</code>, la caja ha sido definida pero est\u00e1 completamente vac\u00eda.</p> <p>Aunque se puede asignar a una variable el valor <code>undefined</code> es algo que por legibilidad de c\u00f3digo no se recomienda. Para ello, se recomienda hacer uso del tipo <code>null</code>.</p> <p>Tanto <code>undefined</code> y <code>null</code> son tipos propios de Javascript.</p>"},{"location":"bloque_i/tema_2/page-4/#ejercicios","title":"Ejercicios","text":"Ejercicio 4 <p>\u00bfCu\u00e1l es la salida del siguiente script?</p> <pre><code>let name = \"Ilya\"\nconsole.log( `Hola ${1}` )    console.log( `Hola ${\"name\"}` )    console.log( `Hola ${name}` )\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/","title":"5 Operadores","text":""},{"location":"bloque_i/tema_2/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Los operadores son s\u00edmbolos que se utilizan para evaluar un expresi\u00f3n y as\u00ed devuelva un resultado. Por ejemplo, el operador <code>+</code> sirve para evaluar una suma y que as\u00ed devuelva un n\u00famero. Los operandos son los valores que interact\u00faan en la evaluaci\u00f3n, es decir, las partes de la operaci\u00f3n.</p> <p>Existen diferentes tipos de operadores, entre ellos:</p> <ul> <li>Operadores unarios. Son operadores que solo necesitan un \u00fanico operando.</li> <li>Operadores binarios. Son operadores que necesitan dos operandos, como la suma.</li> <li>Operadores ternarios. Son operadores que necesitan tres operandos.</li> </ul>"},{"location":"bloque_i/tema_2/page-5/#operadores-unarios","title":"Operadores unarios","text":"<p>En Javascript, los s\u00edmbolos positivo <code>+</code> y negativos <code>-</code> son operadores unarios que eval\u00faan el signo el operador. De esta forma podemos usar <code>-</code> para pasar un n\u00famero positivo a negativo:</p> <pre><code>console.log(+2) // positive number\nconsole.log(-2) // negative number\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operadores-matematicos","title":"Operadores matem\u00e1ticos","text":"<p>En Javascript tenemos los siguientes operadores para poder realizar operaciones matem\u00e1ticas:</p> Operador Descripci\u00f3n Ejemplo de expresi\u00f3n Resultado del ejemplo + Suma 2.5 + 7.1 9.6 - Resta 235.6 - 103.5 132.1 * Multiplicaci\u00f3n 1.2 * 1.1 1.32 / Divisi\u00f3n 0.050 / 0.027 / 2 0.253 % Resto Divisi\u00f3n entera 20 % 714.5 % 2 60.5 ** Exponenciaci\u00f3n 2 ** 2 4 <p>El operador exponenciaci\u00f3n sirve para realizar potencias o ra\u00edces. Para realizar ra\u00edces es necesario que el exponente de la potencia sea una fracci\u00f3n. Por ejemplo, para calcular la ra\u00edz cuadrada de 4: <code>2 ** (1/2)</code></p>"},{"location":"bloque_i/tema_2/page-5/#concatenar-cadenas","title":"Concatenar cadenas","text":"<p>El operador binario <code>+</code> tiene un tercer uso, concatenar cadenas. Une una o m\u00e1s cadenas obteniendo como resultado una nueva cadena completa.</p> <pre><code>const name = 'Jane'\nconst lastName = 'Doe'\nconst fullName = name + ' ' + lastName\nconsole.log(fullName) // Jane Doe\n</code></pre> <p>Hay que tener en cuenta que cuando se usa el operador de concatenaci\u00f3n con n\u00fameros, estar\u00edamos realizando una suma. Sin embargo, si uno de los dos operandos es de tipo cadena, aunque el otro sea un n\u00famero o un booleano, siempre concatenar\u00e1, incluso si la cadena es de un d\u00edgito:</p> <pre><code>console.log(1 + \"1\") //11\nconsole.log(\"1\" + 2) //12\n</code></pre> <p>En Javascript, si hay m\u00e1s de un operando y el operador es binario se va realizando la operaci\u00f3n de dos en dos, seg\u00fan un orden que veremos posteriormente. De esta manera:</p> <pre><code>console.log(2 + 2 + \"2\") // 4 + \"2\" = \"42\"\nconsole.log(\"2\" + 2 + 4) // \"22\" + 4 = \"224\"\n</code></pre> <p>Warning</p> <p>El operador binario <code>+</code> es el \u00fanico operador binario que trata a las cadenas d\u00edgitos (las cadenas que son num\u00e9ricas) como cadenas y no los tratan como n\u00famero. El resto de operadores matem\u00e1ticos realizan la conversi\u00f3n de la cadena a n\u00famero, y en caso de no ser posible el resultado de la operaci\u00f3n ser\u00eda <code>NaN</code>.</p> <pre><code>console.log(2 - '1') // 1\nconsole.log('6' / '2') // 3\nconsole.log('hola mundo' / 2) //NaN\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operador-asignacion","title":"Operador Asignaci\u00f3n","text":"<p>El operador de asignaci\u00f3n <code>=</code> es un operador binario que sirve para asignar a una variable un valor, por lo que los operandos ser\u00eda la variable el valor.</p> <pre><code>let a = 10\n</code></pre> <p>En Javascript, se permite encadenar varias asignaciones, de forma que se eval\u00faen de derecha a izquierda:</p> <pre><code>let a, b, c\na = b = c = 4\n</code></pre> <p>En el ejemplo anterior, se realiza una asignaci\u00f3n encadenada, de forma que primero se realiza la que est\u00e9 m\u00e1s a la derecha (<code>c = 4</code>) y luego las restantes (<code>b = c</code> y <code>c = a</code>).</p> <p>Aqu\u00ed una demostraci\u00f3n de una asignaci\u00f3n encadenada m\u00e1s compleja:</p> <pre><code>let a = 1;\nlet b = 2;\nlet c = 3 - (a = b + 1);\nconsole.log(a); // 3\nconsole.log(c); // 0\n</code></pre> <p>En el ejemplo anterior, primero se eval\u00faa la asignaci\u00f3n <code>a = b + 1</code> y su resultado de utiliza en la siguiente asignaci\u00f3n <code>c = 3 - 3</code>, por lo que el valor de la variable <code>c</code> acaba siendo 0.</p> <p>Aunque es cierto que Javascript te permite encadenar las asignaciones, no es algo que se recomienda fervientemente, por lo que es m\u00e1s legible hacerlo secuencialmente. As\u00ed el ejemplo anterior, ser\u00eda m\u00e1s legible de esta forma:</p> <pre><code>let a = 1;\nlet b = 2;\na = b + 1;\nlet c = 3 - a;\nconsole.log(a); // 3\nconsole.log(c); // 0\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operadores-combinados","title":"Operadores combinados","text":"<p>En ciertas ocasiones queremos asignarle a una variable un nuevo valor que depende de su valor anterior, por ejemplo, podemos incrementar 2 unidades.</p> <pre><code>let number = 2\nnumber = number + 2\nconsole.log(number) // 4\n</code></pre> <p>En Javascript (como en otros lenguajes), existe la posibilidad de combinar la operaci\u00f3n y asignaci\u00f3n en un solo operando, por ejemplo <code>+=</code>. De esta forma, el ejemplo anterior quedar\u00eda:</p> <pre><code>let number = 2\nnumber += 2\nconsole.log(number) // 4\n</code></pre> <p>Primero se indicar\u00eda el operador matem\u00e1tico y luego el de asignaci\u00f3n, de est\u00e1 forma se eval\u00faa primero la expresi\u00f3n (<code>number + 2</code>) y luego se realiza la asignaci\u00f3n (<code>number = 4</code>).</p> <p>Tambi\u00e9n se puede hacer uso de m\u00e1s de una operaci\u00f3n matem\u00e1tica, prevaleciendo \u00e9sta siempre primero antes de la asignaci\u00f3n. De esta forma:</p> <pre><code>let n = 2;\nn *= 3 + 5;\nconsole.log(n); // 16\n</code></pre> <p>En el ejemplo anterior, primero se eval\u00faa la operaci\u00f3n de suma (<code>3 + 5</code>) y luego se realiza la operaci\u00f3n de multiplicaci\u00f3n (<code>2 * 8</code>), y por \u00faltimo la asignaci\u00f3n (<code>16</code>).</p>"},{"location":"bloque_i/tema_2/page-5/#operadores-incrementodecremento","title":"Operadores incremento/decremento","text":"<p>Los operadores incrementales y decrementales sirven para modificar el valor de las variables en un unidad. El operador incremento <code>++</code> modificar el valor de la variable en una unidad de forma incremental, mientras que el de decremento <code>--</code> lo decrementa en una unidad.</p> <pre><code>let count = 2;\ncount++; // 3\ncount--; // 2\n</code></pre> <p>Importante</p> <p>Incremento/decremento s\u00f3lo puede ser aplicado a variables. Intentar utilizarlo en un valor como 5++ dar\u00e1 un error.</p> <p>Estos operadores puede ser colocados antes o despu\u00e9s de una variable, teniendo un comportamiento diferente. Esta diferente es notable durante la evaluaci\u00f3n de una expresi\u00f3n. Si se colocan como sufijo (antes de la variable), el valor se ver\u00e1 incrementado/decrementado despu\u00e9s de usar la variable en la expresi\u00f3n evaluada, mientras que si es usado como prefijo (despu\u00e9s de la variable), el valor se vera incrementado/decrementado antes de usar la variable en la expresi\u00f3n.</p> <pre><code>let number = 1\nconsole.log(number++) // 1\nconsole.log(number) //\n</code></pre> <p>En el ejemplo anterior, tenemos una variable con un valor inicial a <code>1</code>. Al hacer el incremento como sufijo, primero se usa el valor de la variable antes de incrementarse para mostrarla por pantalla, por lo que se mostrar\u00e1 1, y luego se incrementar\u00e1 a <code>2</code>.</p> <p>Ahora veamos una demostraci\u00f3n, con un incremento como prefijo:</p> <pre><code>let number = 1\nconsole.log(++number) //2\nconsole.log(number)\n</code></pre> <p>En esta ocasi\u00f3n, primero se incrementa el valor y luego se muestra por pantalla.</p> <p>Veamos un ejemplo m\u00e1s complejo:</p> <pre><code>let counter = 1\nlet expr = 2 ** counter++ // 2\nlet other = 2 ** ++otherCounter //8\n</code></pre> <p>El valor de la variable <code>expr</code> es dos, ya que utiliza un incremento de sufijo, por lo que primero se usa el valor anterior <code>1</code> para realizar la operaci\u00f3n <code>2 ** 1</code> y luego se incrementa a <code>2</code>. Mientras que, la variable <code>other</code> tiene resultado <code>8</code> al usar un incremento de prefijo, por lo que primero se ha incrementado el valor (de <code>2</code> a <code>3</code>) y luego se ha usado \u00e9ste para la operaci\u00f3n <code>2 ** 3</code>.</p>"},{"location":"bloque_i/tema_2/page-5/#operadores-a-nivel-de-bits","title":"Operadores a nivel de bits","text":"<p>Los operados a nivel de bits son operadores que tratan a los n\u00fameros como n\u00fameros enteros de 32 bits, trabajando con su representaci\u00f3n binaria. Este tipo de operadores no es exclusivo de Javascript, sino que tambi\u00e9n son utilizados en otros lenguajes.</p> <p>Estos operadores se usan de forma muy puntual, simplemente cuando es necesario el uso de la representaci\u00f3n de los n\u00fameros a un bajo nivel, pero a\u00fan as\u00ed es bueno tener conocimientos de ellos.</p> <p>Podemos encontrar los siguientes operadores:</p> <ul> <li> <p>AND (<code>&amp;</code>). Devuelve un 1 en las posiciones de bit d\u00f3nde las posiciones de los operadores tienen un 1, por el contrario devuelven un 0.</p> <pre><code>let x = 9 // 1001\nlet y = 12 // 1100\nconsole.log(x &amp; y) // 8 (1000)\n</code></pre> </li> <li> <p>OR (<code>|</code>). Devuelve un cero en las posiciones de bit d\u00f3nde las posiciones de los dos operadores tienen un 0, por el contrario devuelven un 1.</p> <pre><code>let x = 9 // 1001\nlet y = 12 // 1100\nconsole.log(x | y) // 13 (1101)\n</code></pre> </li> <li> <p>XOR (<code>^</code>). Devuelve un cero en las posiciones d\u00f3nde el bit es el mismo y un 1 d\u00f3nde las posiciones son diferentes.</p> <pre><code>let x = 9 // 1001\nlet y = 12 // 1100\nconsole.log(x ^ y) // 5 (0101)\n</code></pre> </li> <li> <p>NOT (<code>~</code>). Es un operador unario que intercambia el valor, es decir si la posici\u00f3n tiene un valor de cero es cambiado por uno y viceversa.</p> <pre><code>let x = 9 // 1001\nconsole.log(~x) // 5 (0110)\n</code></pre> </li> <li> <p>LEFT SHIFT (<code>&lt;&lt;</code>). Es un operador binaria cuyo segundo operado indica el n\u00famero de bits que se desplazar\u00e1n del primer operado hacia la izquierda. En otras palabras, se a\u00f1ade tantos 0 como se indica al final del binario.</p> <pre><code>let x = 2 // 0000010\nconsole.log(x &lt;&lt; 1) // 4 (00000100)\n</code></pre> </li> <li> <p>RIGHT SHIFT (<code>&gt;&gt;</code>). Es un operador binario cuyo segundo operado indica el n\u00famero de bits que se desplazar\u00e1n del primer operado hacia la derecha. En otras palabras, desaparece la cantidad de binarios indicada.</p> <pre><code>let x = 2 // 0000010\nconsole.log(x &gt;&gt; 1) // 1 (000001)\n</code></pre> </li> <li> <p>ZERO-FILL RIGHT SHIFT (<code>&gt;&gt;&gt;</code>). Es un operador binario cuyo segundo operado indica el n\u00famero de bits que se desplazar\u00e1n del primer operado hacia la derecha, pero a\u00f1adiendo 0 a la parte izquierda. En otras palabras, desaparece la cantidad de binarios indicada.</p> <pre><code>let x = 2 // 0000010\nconsole.log(x &gt;&gt;&gt; 1) // 1 (0000001)\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_2/page-5/#operador-coma","title":"Operador coma","text":"<p>El operador coma <code>,</code> es uno de los operadores m\u00e1s raros e inusuales. A veces, es utilizado para escribir c\u00f3digo m\u00e1s corto, entonces tenemos que saberlo para poder entender qu\u00e9 est\u00e1 pasando.</p> <p>El operador coma nos permite evaluar varias expresiones, dividi\u00e9ndolas con una coma <code>,</code>. Cada una de ellas es evaluada, pero s\u00f3lo el resultado de la \u00faltima es devuelto.</p> <p>Por ejemplo:</p> <pre><code>let a = (1 + 2, 3 + 4);\nconsole.log(a); // 7 (el resultado de 3 + 4)\n</code></pre> <p>Aqu\u00ed, se eval\u00faa la primera expresi\u00f3n 1 + 2 y se desecha su resultado. Luego, se eval\u00faa 3 + 4 y se devuelve como resultado.</p> <p>Info</p> <p>Tenga en cuenta que el operador coma tiene una precedencia muy baja, inferior a <code>=</code>, por lo que los par\u00e9ntesis son importantes en el ejemplo anterior.</p> <p>Sin ellos: <code>a = 1 + 2, 3 + 4</code> se eval\u00faa primero el <code>+</code>, sumando los n\u00fameros a <code>a = 3, 7</code>, luego el operador de asignaci\u00f3n <code>=</code> asigna <code>a = 3</code>, y el resto es ignorado. Es igual que <code>(a = 1 + 2), 3 + 4</code>.</p> <p>A veces, las personas lo usan en construcciones m\u00e1s complejas para poner varias acciones en una l\u00ednea.</p> <p>Por ejemplo:</p> <pre><code>for (a = 1, b = 3, c = a * b; a &lt; 10; a++) {\n...\n}\n</code></pre> <p>Tales trucos se usan en muchos frameworks de JavaScript. Por eso los estamos mencionando. Pero generalmente no mejoran la legibilidad del c\u00f3digo, por lo que debemos pensar bien antes de usarlos.</p>"},{"location":"bloque_i/tema_2/page-5/#operadores-relaciones","title":"Operadores relaciones","text":"<p>Los operados relaciones realizan comparaciones entre los datos obteniendo siempre un resultado booleano (<code>true</code> o <code>false</code>). Entre ellos, podemos encontrar:</p> Operador Significado Ejemplo &lt; Menor que 3 &lt; 5 &gt; Mayor que 3 &gt; 5 &lt;= Menor o igual que 3 &lt;= 5 &gt;= Mayor o igual que 3 &gt;= 5 == Igual que 3 == 5 != Distinto que 3 != 5 <p>Se pueden comparar n\u00fameros, o cadenas, siendo el algoritmo de comparaci\u00f3n el siguiente:</p> <ol> <li>Compare el primer car\u00e1cter de ambas cadenas.</li> <li>Si el primer car\u00e1cter de la primera cadena es mayor (o menor) que el de la otra cadena, entonces la primera cadena es mayor (o menor) que la segunda. Hemos terminado.</li> <li>De lo contrario, si los primeros caracteres de ambas cadenas son los mismos, compare los segundos caracteres de la misma manera.</li> <li>Repita hasta el final de cada cadena.</li> <li>Si ambas cadenas tienen la misma longitud, entonces son iguales. De lo contrario, la cadena m\u00e1s larga es mayor.</li> </ol> <p>Por ejemplo, al comparar <code>Z &gt; A</code>, solo es necesario hacer el primer paso. Sin embargo, al comparar <code>Glow &gt; Glee</code>, es necesario m\u00e1s pasos:</p> <ol> <li><code>G</code> es igual a <code>G</code>.</li> <li><code>l</code> es igual a <code>l</code>.</li> <li><code>o</code> es mayor que <code>e</code>, por lo que la primera cadena es mayor.</li> </ol> <p>\u00a1OJO!</p> <p>El algoritmo de comparaci\u00f3n dado arriba es aproximadamente equivalente al utilizado de forma alfab\u00e9tica, pero no es exactamente el mismo.</p> <p>Por ejemplo, las may\u00fasculas importan. Una letra may\u00fascula <code>A</code> no es igual a la min\u00fascula <code>a</code>. La <code>a</code> min\u00fascula es mayor porque el car\u00e1cter en min\u00fascula tiene un \u00edndice mayor en la tabla de codificaci\u00f3n interna que utiliza Javascript (Unicode)</p> <p>Para comparar entre distintos tipos, Javascript intenta realizar una parseo a n\u00fameros, en caso de que sea posible, si no lo transforma en <code>NaN</code>. Un <code>NaN</code> nunca es ni mayor, ni menor, ni igual a un n\u00famero, por lo que una comparaci\u00f3n con dicho tipo num\u00e9rico dar\u00eda siempre false. Un booleano se puede entender como un n\u00famero binario, siendo <code>true</code> equivalente a <code>1</code>y <code>false</code> a <code>0</code>:</p> <pre><code>console.log('3' &gt; 4) // false\nconsole.log('Hola' == 2) // false\nconsole.log('Hola' != 2) // true\nconsole.log(true &gt; 0) // true\n</code></pre> <p>Warning</p> <p>En Javascript el n\u00famero <code>0</code> se puede entender en booleano como <code>false</code>, pero la cadena <code>\"0\"</code> se entiende como <code>true</code>, por lo que a la hora de compararlas hay que tenerlo en cuenta.</p> <p>Veamos otro ejemplo:</p> <pre><code>console.log(0 == false) //true\nconsole.log('' == false) // true\n</code></pre> <p>Ambas comparaciones son <code>true</code> porque al pasar los datos no num\u00e9ricos a n\u00fameros, se entienden como <code>0</code>. Esto puede suponer un problema, porque a veces es conveniente comprobar si el contenido de dos variables es exactamente igual, y en este caso siempre dar\u00eda <code>true</code>. Para ello hay un comparador de igualdad estricto que retornar\u00e1 <code>true</code> si y solo si los datos comparados son iguales en tipo y contenido:</p> <pre><code>console.log(3 === '3') // false\nconsole.log(0 === false) // false\n</code></pre> <p>En los ejemplos anteriores, vemos que los datos son iguales en contenido (recuerda que <code>false</code> equivale a <code>0</code>), pero no tienen el mismo tipo de dato, por lo que no ser\u00edan iguales estrictos. Existe, por ende, el comparador de desigualdad estricto <code>!==</code>.</p> <p>El uso del operador de igual estricto es un mejor pr\u00e1ctica que el uso del operador de igual b\u00e1sico, ya que el estricto es propenso a tener menos errores. Uno de los errores t\u00edpicos es que al comparar <code>null</code> y <code>undefined</code> con el operador <code>==</code> \u00e9ste devuelve <code>true</code>, pero con el operador <code>===</code> devuelve <code>false</code>.</p> <p>Warning</p> <p>Al hacer una comparaci\u00f3n de cualquier tipo de dato con <code>null</code> o <code>undefined</code> \u00e9sta dar\u00e1 <code>false</code>, ya que su valor \"num\u00e9rico\" es <code>NaN</code>:</p> <pre><code>console.log(3 &lt; null) // false\nconsole.log(undefined &gt; 5) // false\n</code></pre> <p>Solo puede ser <code>true</code> si su valor es <code>undefined</code> o <code>null</code> y se compara de igualdad:</p> <pre><code>let num\nconsole.log(num === undefined)\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Los operadores l\u00f3gicos son operadores binarios aplicados a cualquier tipo y que pueden devolver cualquier tipo:</p>"},{"location":"bloque_i/tema_2/page-5/#operador-or","title":"Operador OR (||)","text":"<p>El operador OR (<code>||</code>) es un operador que en la programaci\u00f3n cl\u00e1sica, retornar\u00e1 <code>true</code> si cualquiera de sus dos operandos es <code>true</code>:</p> <pre><code>console.log(true || false) // true\nconsole.log(false || true) // true\nconsole.log(true || true) // true\nconsole.log(false || false) // false\n</code></pre> <p>En el ejemplo anterior, solo retorna <code>false</code> cuando se compara dos <code>false</code>. Si se intenta utilizar como operador otro tipo de dato, se parsear\u00e1 a booleano. En el \u00e1mbito de los n\u00fameros se entiende que <code>0</code> es <code>false</code> y que <code>1</code> es <code>true</code>. En el caso de las cadenas, se entiende como <code>false</code> una cadena vac\u00eda, y como <code>true</code> una no vac\u00eda. Tambi\u00e9n se puede entender como <code>true</code> una variable distinta de <code>null</code> y <code>undefined</code>.</p> <pre><code>console.log(1 || 0) // true\nconsole.log('Hola' || '') // true\n</code></pre> <p>Adem\u00e1s de la funcionalidad cl\u00e1sica, en Javascript dicho operador, tiene una funci\u00f3n extra. Se puede usar dicho operador para la asignaci\u00f3n de una variable, de la siguiente forma: <code>const result = value1 || value2 || value3</code>. Su funcionamiento es simple:</p> <ul> <li>Eval\u00faa la expresi\u00f3n de izquierda a derecha.</li> <li>Transforma cada operando en un valor booleano. Si el resultado de alguno es <code>true</code>, se detiene en el primer operando que da <code>true</code>, retornando el valor original del operando.</li> <li>Si todos los operandos son <code>false</code> retorna el \u00faltimo operando.</li> </ul> <p>En otras palabras, una cadena de OR devuelve el primer valor verdadero o el \u00faltimo si ning\u00fan verdadero es encontrado.</p> <pre><code>const result1 = 0 || '' || 7 // 7\nconst result2 = 3 || undefined || false // 3\nconst result1 = null || 'Hola' || 9 // 'Hola'\nconst result4 = null || undefined || '' || 0 // 0\n</code></pre> <p>Uno de los usos m\u00e1s comunes de esta funcionalidad es poder definir una variable que depende de otros valores, pero en caso de los otros valores no est\u00e9n definidos (ya sea porque sean <code>null</code> o <code>undefined</code> o cadena vac\u00eda, o incluso cero) podemos indicarle un valor por defecto.</p> <pre><code>let name = ''\nlet firstName = null\nconst userName = name || firstName || 'Nombre de usuario'\n</code></pre> <p>En el ejemplo anterior se eval\u00faa las dos variables, en caso de que den <code>false</code>, se utiliza como valor de la variable <code>userName</code> la cadena <code>Nombre de usuario</code>.</p>"},{"location":"bloque_i/tema_2/page-5/#operador-and","title":"Operador AND (&amp;&amp;)","text":"<p>El operador AND (<code>&amp;&amp;</code>) es un operador que en la programaci\u00f3n cl\u00e1sica retornar\u00e1 <code>true</code> siempre y cuando todos los operandos devuelvan <code>true</code> y <code>false</code> si hay uno o m\u00e1s de uno que devuelve <code>false</code>.</p> <pre><code>console.log(true &amp;&amp; true); // true\nconsole.log(false &amp;&amp; true); // false\nconsole.log(true &amp;&amp; false); // false\nconsole.log(false &amp;&amp; false); // false\n</code></pre> <p>Al igual que operador OR, en Javascript, se puede usar el operador AND para la asignaci\u00f3n <code>const result = value1 &amp;&amp; value2 &amp;&amp; value3</code>. En este caso, el procedimiento es un ligeramente diferente:</p> <ul> <li>Eval\u00faa la expresi\u00f3n de izquierda a derecha.</li> <li>Transforma cada operando en un valor booleano. Si el resultado de alguno es <code>false</code>, se detiene en el primer operando que da <code>false</code>, retornando el valor original del operando.</li> <li>Si todos los operandos son <code>true</code> retorna el \u00faltimo operando.</li> </ul> <p>En otras palabras, AND retorna el primer valor falso o el \u00faltimo valor si ninguno fue encontrado. Las reglas anteriores son similares a las de OR. La diferencia es que AND retorna el primer valor falso mientras que OR retorna el primer valor verdadero.</p> <pre><code>const result1 = 0 &amp;&amp; '' &amp;&amp; 7 // 0\nconst result2 = 3 &amp;&amp; undefined &amp;&amp; false // undefined\nconst result1 = null &amp;&amp; 'Hola' &amp;&amp; 9 // null\nconst result4 = 1 &amp;&amp; 2 &amp;&amp; true &amp;&amp; 3 // 3\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operador-not","title":"Operador NOT (!)","text":"<p>El operador NOT (<code>!</code>) es un operador unario que se encarga de convertir dicho operando en un booleano (en caso de que no lo sea) y devuelve su valor booleano contrario.</p> <pre><code>console.log(!false) // true\nconsole.log(!2) // false\nconsole.log(!0) // true\nconsole.log(!'Hola') // false\nconsole.log(!'') // true\nconsole.log(!undefined) // true\n</code></pre> <p>Warning</p> <p>En Javascript los operadores AND, OR, NOT y NULLISH COALESCING son operadores corto-circuitos, es decir, van evaluando expresiones hasta que una de ellas obtiene un valor claro, dejando a las dem\u00e1s sin evaluar. Por ejemplo:</p> <pre><code>const result = 10 || 0 || false\n</code></pre> <p>En este ejemplo, el valor de la variable <code>result</code> es <code>10</code>, pero el tiempo de ejecuci\u00f3n es menor si se hubiese cambiado el orden, ya que al evaluar primero el 10, como se obtiene lo que se desea (una valor distinto de <code>false</code>) el resto de expresiones se dejan sin evaluar. Por eso, es importante el orden en el que se eval\u00faan dichas expresiones. Veamos otro ejemplo:</p> <pre><code>console.log(3 &gt; 5 &amp;&amp; 4 &gt; 2)\n</code></pre> <p>Ahora, se mostrar\u00e1 <code>false</code>, porque <code>3&gt;5</code> retorna <code>false</code> por lo que no es necesario evaluar la siguiente expresi\u00f3n, ya que siendo la primera <code>false</code> el operando <code>&amp;&amp;</code> retornar\u00e1 <code>false</code> s\u00ed o s\u00ed.</p>"},{"location":"bloque_i/tema_2/page-5/#operador-typeof","title":"Operador typeof","text":"<p>El operador <code>typeof</code> es un operador unario de Javascript que devuelve el tipo de dato del operando. Tambi\u00e9n se puede utilizar de la siguiente forma <code>typeof(x)</code> pero hay que tener en cuenta que <code>typeof</code> es un operando y no una funci\u00f3n.</p> <pre><code>console.log(typeof 'Hola') // string\nconsole.log(typeof 4) // number\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#operador-ternario","title":"Operador ternario","text":"<p>El operador ternario es un operador con tres operando. El primer operando hace referencia a una condici\u00f3n que debe ser evaluada. Si esta condici\u00f3n es verdadera el operador retorna el segundo operando, mientras que si la condici\u00f3n es falsa el operador retorna el tercer operando. Su sintaxis es la siguiente:</p> <pre><code>condition ? trueValue : falseValue\n</code></pre> <p>Veamos un ejemplo:</p> <pre><code>const result = age &gt; 18 ? 'Mayor' : 'Menor'\n</code></pre> <p>Podemos tener una secuencia de operadores ternario si queremos evaluar m\u00e1s de una posibilidad:</p> <pre><code>let message = age &lt; 3 ? '\u00a1Hola, beb\u00e9!' : age &lt; 18 ? '\u00a1Hola!' : age &lt; 100 ? '\u00a1Felicidades!' : '\u00a1Qu\u00e9 edad tan inusual!';\nconsole.log(message)\n</code></pre> <p>La ejecuci\u00f3n del ejemplo anterior es la siguiente.</p> <ol> <li>Se comprueba si la expresi\u00f3n <code>age &lt; 3</code> es verdadera. En caso de serlo, retornar\u00e1 el valor <code>'Hola, beb\u00e9'</code>, y no comprobar\u00e1 el resto de condiciones.</li> <li>Si es falsa, comprobar\u00e1 la siguiente condici\u00f3n <code>age &lt; 18</code>. En este caso si es verdadera retornar\u00e1 <code>'\u00a1Hola!'</code>.</li> <li>Si es falsa, comprobar\u00e1 la \u00faltima condici\u00f3n, que de ser verdadera retornar\u00e1 <code>\u00a1Felicidades!</code>, por el contrario <code>\u00a1Qu\u00e9 edad tan inusual!</code>.</li> </ol>"},{"location":"bloque_i/tema_2/page-5/#operador-nullish-coalescing","title":"Operador Nullish Coalescing","text":"<p>El operador nullish coalescing (fusi\u00f3n de null) es un operador binario en el que retorna el primer operando si es distinto de <code>null</code> o <code>undefined</code>, o por el contario retorna el segundo:</p> <pre><code>let number\nconsole.log(number ?? 0) // 0\n</code></pre> <p>En el ejemplo anterior, se mostrar\u00e1 0, ya que la variable <code>number</code> es una variable <code>undefined</code> y por lo tanto la expresi\u00f3n <code>number ?? 0</code> retorna el segundo operado (<code>0</code>). En el siguiente ejemplo, retornar\u00e1 el valor de la variable <code>number</code> ya que no es <code>undefined</code>:</p> <pre><code>let number = 10\nconsole.log(number ?? 0) // 10\n</code></pre> <p>El operador nullish coalescing no es m\u00e1s que una sintaxis reducida del uso de un operador ternario con dicho prop\u00f3sito:</p> <pre><code>let number\nconsole.log(number !== undefined || number !== null ?  null : 0)\n</code></pre> <p>Tambi\u00e9n se puede usar una secuencia de dicho operador para seleccionar el primer valor que no sea <code>null</code>/<code>undefined</code>:</p> <pre><code>let firstName = null;\nlet lastName = null;\nlet nickName = \"MyNick\";\nconsole.log(firstName ?? lastName ?? nickName ?? \"Anonymous\"); // MyNick\n</code></pre> <p>El ejemplo anterior, tambi\u00e9n pod\u00eda haberse realizado con el operador OR (<code>||</code>). Hist\u00f3ricamente, el operador OR estuvo primero y existe desde el origen de JavaScript, as\u00ed que los desarrolladores lo estuvieron usando para tal prop\u00f3sito durante mucho tiempo.</p> <p>Por otro lado, el operador nullish coalescing es una adici\u00f3n reciente, y la raz\u00f3n es que la gente no estaba del todo satisfecha con <code>||</code>.</p> <p>La gran diferencia es que OR devuelve el primer valor verdadero  y nullish coalescing devuelve el primer valor definido. El <code>||</code> no distingue entre <code>false</code>, <code>0</code>, un string vac\u00edo <code>\"\"</code>, y <code>null</code>/<code>undefined</code>. Todos son lo mismo: valores falsos. Si cualquiera de ellos es el primer argumento de <code>||</code>, obtendremos el segundo argumento como resultado. Pero cierto es, que en la pr\u00e1ctica querremos usar dicho valor solo cuando no est\u00e9 definido o sea <code>null</code>. En el ejemplo siguiente, me interesa seguir usando el valor <code>0</code>, por eso no es conveniente usar el operador OR:</p> <pre><code>const height = 0\nconsole.log('La altura es', height ?? 'No hay altura')\n</code></pre> <p>Si hubi\u00e9semos usado el operador OR, hubiese devuelto la cadena, pero eso no ser\u00eda coherente ya que el valor de una altura si puede ser 0.</p> <p>Tips</p> <p>Por este motivo, se recomienda usar siempre el operador nullish coalescing en lugar del operador OR, y dejar dicho operador solo en situaciones concretas.</p> <p>Warning</p> <p>Por motivos de seguridad, JavaScript proh\u00edbe el uso de <code>??</code> junto con los operadores <code>&amp;&amp;</code> y <code>||</code>, salvo que la precedencia sea expl\u00edcitamente especificada con par\u00e9ntesis.</p> <pre><code>let x = 1 &amp;&amp; 2 ?? 3; // \u274c Syntax error\nlet y = (1 &amp;&amp; 2) ?? 3; // \u2705 2\n</code></pre>"},{"location":"bloque_i/tema_2/page-5/#precedencias","title":"Precedencias","text":"<p>En Javascript, como en cualquier otro lenguaje, existen demasiados operadores y a veces al usar varios de ellos a la vez es necesario tener en cuenta un precedencia a la hora de ejecutarse. Por ejemplo, en la expresi\u00f3n <code>3 + 5 * 2</code>, aunque primero vaya la suma, seg\u00fan la precedencia de operaciones, la multiplicaci\u00f3n tiene mayor precedencia que la suma por lo que primero se ejecutar\u00e1 <code>5 * 2</code> y luego el resultado se sumar\u00e1 a 3. En la siguiente tabla se recoge el orden de precedencia de los operadores de Javascript.</p> Precedencia Tipo de operador Asociatividad Operadores individuales 19 Agrupamiento - <code>()</code> 18 Acceso a propiedades (notaci\u00f3n por punto) A la izquierda <code>.</code> Acceso a propiedades (notaci\u00f3n por corchetes) A la izquierda <code>[]</code> Creaci\u00f3n de objetos (con argumentos) - <code>new</code> Llamada a funci\u00f3n A la izquierda <code>()</code> Encadenamiento opcional A la izquierda <code>?.</code> 17 Creaci\u00f3n de objetos (sin argumentos) A la derecha <code>new</code> 16 Incremento sufijo - <code>...++</code> Decremento sufijo <code>...--</code> 15 NOT l\u00f3gico A la derecha <code>!</code> NOT a nivel de bits <code>~</code> Suma unaria <code>+</code> Negaci\u00f3n unaria <code>-</code> Incremento prefijo <code>++...</code> Decremento prefijo <code>--...</code> <code>typeof</code> <code>typeof</code> <code>void</code> <code>void</code> <code>delete</code> <code>delete</code> <code>await</code> <code>await</code> 14 Potenciaci\u00f3n A la derecha <code>**</code> 13 Multiplicaci\u00f3n A la izquierda <code>*</code> Divisi\u00f3n <code>/</code> Resto <code>%</code> 12 Adici\u00f3n A la izquierda <code>+</code> Sustracci\u00f3n <code>-</code> 11 Desplazamiento de bits a la izquierda A la izquierda <code>&lt;&lt;</code> Desplazamiento de bits a la derecha <code>&gt;&gt;</code> Desplazamiento de bits a la derecha sin signo &gt;&gt;&gt; 10 Menor a A la izquierda <code>&lt;</code> Menor o igual a &lt;= Mayor a &gt; Mayor o igual a &gt;= <code>in</code> <code>in</code> <code>instanceof</code> <code>instanceof</code> 9 Igualdad A la izquierda <code>=</code> Desigualdad <code>!=</code> Igualdad estricta <code>===</code> Desigualdad estricta <code>!==</code> 8 AND nivel de bits A la izquierda <code>&amp;</code> 7 XOR nivel de bits A la izquierda <code>^</code> 6 OR nivel de bits A la izquierda <code>|</code> 5 AND l\u00f3gico A la izquierda <code>&amp;&amp;</code> 4 OR l\u00f3gico A la izquierda <code>||</code> Nullish coalescing <code>??</code> Condicional <code>...? ... : ...</code> 2 Asignaci\u00f3n A la derecha <code>=</code> <code>+=</code> <code>-=</code> <code>**=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&gt;&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code> <code>&amp;&amp;=</code> <code>||=</code> <code>??=</code> <code>yield</code> <code>yield</code> <code>yield*</code> <code>yield*</code> 1 Operador coma A la izquierda     <code>,</code> <p>La asociatividad hace referencia a la situaci\u00f3n en la cual dos operandos tenga la misma precedencia. En ese caso, se ejecutar\u00e1 primero seg\u00fan la asociatividad. Por ejemplo, en el caso de <code>3 * 3 / 3</code>, la multiplicaci\u00f3n y la divisi\u00f3n tiene la misma precedencia, y como su asociatividad es de izquierda, primero se ejecuta la operaci\u00f3n que est\u00e9 m\u00e1s a la izquierda, en este caso la multiplicaci\u00f3n.</p> <p>A veces, en ocasiones queremos realizar una operaci\u00f3n de baja precedencia antes que una de mayor procedencia, para ello se puede usar el operador con mayor precedencia los par\u00e9ntesis <code>()</code>. Por ejemplo, si en la operaci\u00f3n <code>2 + 3 * 5</code>, donde la multiplicaci\u00f3n tiene mayor precedencia que la suma, pero se desea hacer la suma antes, se debe colocar un par\u00e9ntesis en la expresi\u00f3n que se desea hacer primero: <code>(2 + 3) * 5</code>.</p>"},{"location":"bloque_i/tema_2/page-5/#ejercicios","title":"Ejercicios","text":"Ejercicio 5 <p>\u00bfCu\u00e1les son los valores finales de todas las variables <code>a</code>, <code>b</code>, <code>c</code> y <code>d</code> despu\u00e9s del c\u00f3digo a continuaci\u00f3n?</p> <pre><code>let a = 1, b = 1 let c = ++a let d = b++ </code></pre> Ejercicio 6 <p>\u00bfCu\u00e1les son los valores de <code>a</code> y <code>x</code> despu\u00e9s del c\u00f3digo de a continuaci\u00f3n:</p> <pre><code>let a = 2\nlet x = 1 + (a *= 2)\n</code></pre> Ejercicio 7 <p>\u00bfCu\u00e1les es el resultado de las siguientes expresiones?</p> <ol> <li>\"\" + 1 + 0</li> <li>\"\" - 1 + 0</li> <li>true + false</li> <li>6 / \"3\"</li> <li>\"2\" * \"3\"</li> <li>4 + 5 + \"px\"</li> <li>\"$\" + 4 + 5</li> <li>\"4\" - 2</li> <li>\"4px\" - 2</li> <li>\"  -9  \" + 5</li> <li>\"  -9  \" - 5</li> <li>null + 1</li> <li>undefined + 1</li> <li>\" \\t \\n\" - 2</li> <li>5 &gt; 4</li> <li>\"apple\" &gt; \"pineapple\"</li> <li>\"2\" &gt; \"12\"</li> <li>undefined == null</li> <li>undefined === null</li> <li>null == \"\\n0\\n\"</li> <li>null === +\"\\n0\\n\"</li> <li>null || 2 || undefined</li> <li>1 &amp;&amp; null &amp;&amp; 2</li> <li>null || 2 &amp;&amp; 3 || 4</li> </ol> Ejercicio 8 <p>Dado los siguientes valores de las variables <code>x</code>, <code>y</code>, <code>j</code> y <code>k</code>, a\u00f1adir los par\u00e9ntesis que sean necesarios para que las expresiones que las siguen eval\u00faen a verdadero: <code>x = 10</code>; <code>y = 19</code>; <code>j = true</code>; <code>k = undefined</code>.</p> <ol> <li>x == y || j</li> <li>x &gt;= y || x &lt;=y &amp;&amp; j</li> <li>!j || j</li> <li>!k &amp;&amp; k</li> </ol> Ejercicio 9 <p>Indica cual es la salida de las siguientes asignaciones:</p> <ol> <li>const result1 = 10 || 0 || null</li> <li>const result2 = null || undefined || 10</li> <li>const result3 = 0 || 'Sin valor'</li> <li>const result4 = 0 ?? 'Sin valor'</li> <li>const result5 = 10 &amp;&amp; 0 &amp;&amp; 'Mi valor'</li> <li>const result6 = 10 &amp;&amp; 'Mi Valor' &amp;&amp; '\u00daltima'</li> <li>const result7 = 10 &amp;&amp; 8 &amp;&amp; 0 || 20</li> <li>const result8 = 10 &amp;&amp; 10 || undefined &amp;&amp; value</li> </ol>"},{"location":"bloque_i/tema_2/page-6/","title":"6 Introducci\u00f3n a las funciones","text":""},{"location":"bloque_i/tema_2/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>A veces, es necesario repetir c\u00f3digo a lo largo de nuestro script. Por lo que a veces es necesario tener un bloque que recoja el c\u00f3digo a repetir y se ejecuten en diferentes partes.</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ul> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ul>"},{"location":"bloque_i/tema_2/page-6/#declaracion","title":"Declaraci\u00f3n","text":"<p>Para declarar una funci\u00f3n podemos usar la siguiente estructura:</p> <pre><code>function functionName(parameter1, parameter2, parameter3, ..., parameterN){\n// code\n}\n</code></pre> <p>Para hacer uso de esas funciones, se usa el nombre de la funci\u00f3n seguido de un par\u00e9ntesis <code>()</code>. Dentro del par\u00e9ntesis, los par\u00e1metros necesarios para ejecutar la funci\u00f3n.</p> <pre><code>functionName(parameter1, parameter2,..., parameterN)\n</code></pre> <p>Los par\u00e1metros son los datos que son necesarios para ejecutar una funci\u00f3n. Por ejemplo, si tenemos una funci\u00f3n llamada <code>suma</code>, \u00e9sta debe recibir los n\u00fameros que desea realizar la suma.</p> <p>En Javascript existen funciones nativas, es decir, funciones que fueron creadas para por y para el lenguaje y se pueden acceder a ellas gracias al motor del navegador. Entre ellas, podemos destacar: <code>alert</code>, <code>prompt</code> y <code>confirm</code>. Estas funciones son funciones para los navegadores webs. Son funciones del objeto <code>windows</code>.</p>"},{"location":"bloque_i/tema_2/page-6/#alert","title":"alert","text":"<p>La funci\u00f3n <code>alert(message)</code> es una funci\u00f3n de Javascript que ejecuta un cuadro de di\u00e1logo en el navegador, mostrando el <code>message</code> que se le pasa por par\u00e1metro. Este cuadro de di\u00e1logo se muestra de forma modal, es decir, se muestra de forma que no se puede interactuar con el resto de la p\u00e1gina hasta que el cuadro de di\u00e1logo no sea cerrado. Para poder cerrarlo, el cuadro de di\u00e1logo tiene un bot\u00f3n de Aceptar.</p> <pre><code>alert('Hola mundo')\n</code></pre> <p>Con HTML, CSS podemos crear nuestros propios modales, y a trav\u00e9s de Javascript podemos crearle nuestra propia interactividad. Pero de momento, usaremos los m\u00e9todos predeterminados por el lenguaje.</p>"},{"location":"bloque_i/tema_2/page-6/#prompt","title":"prompt","text":"<p>La funci\u00f3n <code>prompt(title, [default])</code> es una funci\u00f3n que muestra en el navegador un cuadro de di\u00e1logo para que el usuario introduzca un dato. Con el par\u00e1metro <code>title</code> indicamos el mensaje que mostramos en el cuadro de di\u00e1logo. Con el par\u00e1metro <code>default</code> es un par\u00e1metro opcional (no es necesario indicarlo) y representa un valor por defecto, en caso de que el usuario no introduzca ning\u00fan valor.</p> <pre><code>const age = prompt('\u00bfCu\u00e1l es tu edad?', 10)\nconst name = prompt('\u00bfCu\u00e1l es tu nombre?')\nconsole.log(`Hola ${name}, eres ${age &gt; 18 ? 'mayor' : 'menor'} de edad`)\n</code></pre> <p>El usuario introducir\u00e1 un dato en el campo de entrada y presionar el bot\u00f3n OK y el valor introducido por el usuario se le asignar\u00e1 a la variable indicada. En caso de presionar el bot\u00f3n cancelar o presiona la tecla Esc, se asignar\u00e1 a la variable el valor por defecto indicado, o <code>null</code> en caso de que no se haya indicado ninguna.</p> <p>Warning</p> <p>Es importante tener en cuenta que todo lo que el usuario introduzca haciendo uso de la funci\u00f3n <code>prompt</code> es considerado como texto. Si se desea otro tipo de dato es necesario realizar un control previo antes de su uso, as\u00ed como una conversi\u00f3n de datos.</p>"},{"location":"bloque_i/tema_2/page-6/#confirm","title":"confirm","text":"<p>La funci\u00f3n <code>confirm(message)</code> muestra un cuadro de di\u00e1logo con un <code>message</code> y dos botones: OK y CANCELAR. Si el usuario presiona el bot\u00f3n OK la funci\u00f3n retornar\u00e1 <code>true</code> y <code>false</code> en el caso contrario.</p> <pre><code>const isBoss = confirm('\u00bfEres el jefe?')\nalert(isBoss ? 'Es el jefe' : 'No es el jefe')\n</code></pre>"},{"location":"bloque_i/tema_2/page-6/#ejercicios","title":"Ejercicios","text":"Ejercicio 10 <p>Crea una p\u00e1gina web, realizando las siguientes opciones.</p> <ul> <li>Solicitar al usuario su nombre y su edad.</li> <li>Solicitar al usuario si est\u00e1 o no abonado a nuestra web.</li> <li>Mostrar en un cuadro de di\u00e1logo la siguiente informaci\u00f3n: <code>Hola Pedro, eres mayor de edad. No eres abonado a nuestra web</code>, o por el contrario <code>Hola Pedro, eres menor de edad. Eres abonado en nuestra web. Enhorabuena.</code></li> </ul>"},{"location":"bloque_i/tema_2/page-7/","title":"7 Conversi\u00f3n de tipos","text":""},{"location":"bloque_i/tema_2/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>La mayor\u00eda de las veces, los operados y las funciones realizan conversiones autom\u00e1ticas de los tipos que reciben por el tipo que requieren. Por ejemplo, cualquier valor pasado al m\u00e9todo <code>log</code> del <code>console</code> es convertido a cadena.</p> <p>Tambi\u00e9n, en ciertas ocasiones, es necesario realizar dicha conversi\u00f3n de forma expl\u00edcita. Existen diferentes funciones para realizar dicha conversi\u00f3n.</p>"},{"location":"bloque_i/tema_2/page-7/#conversion-explicita-a-cadena","title":"Conversi\u00f3n expl\u00edcita a cadena","text":"<p>Vamos a convertir un valor a cadena cuando necesitamos que dicho valor sea usado como tal. Es una de las conversiones m\u00e1s sencillas, ya que sea obtiene el mismo valor pero con comillas. Por ejemplo, <code>2</code> ser\u00eda <code>\"2\"</code>, <code>undefined</code> <code>\"undefined\"</code>, <code>false</code> <code>\"false\"</code>.</p> <p>Para convertir un valor a una cadena podemos hacer uso de la funci\u00f3n <code>String(value)</code></p> <pre><code>const number = 3\nconst numberString = String(number)\n</code></pre> <p>Tambi\u00e9n podemos usar las backticks introduciendo el valor a convertir dentro del <code>${...}</code>:</p> <pre><code>const number = 3\nconst numberString = `${number}`\nconsole.log(typeof numberString) // string\n</code></pre>"},{"location":"bloque_i/tema_2/page-7/#conversion-explicita-a-numero","title":"Conversi\u00f3n expl\u00edcita a n\u00famero","text":"<p>La conversi\u00f3n num\u00e9rica ocurre en funciones matem\u00e1ticas y expresiones. Por ejemplo, al hacer <code>\"3\" / \"3\"</code>, las cadenas se convierten autom\u00e1ticamente en n\u00famero. Sin embargo, si se desea hacer una conversi\u00f3n expl\u00edcita, es necesario hacer uso de la funci\u00f3n <code>Number(value)</code>.</p> <p>Warning</p> <p>El \u00fanico operador matem\u00e1tico que no realiza la conversi\u00f3n de cadenas autom\u00e1tica a n\u00famero es el operador de adici\u00f3n <code>+</code>. Este operador se entiende en dicho caso, como un operador de concatenaci\u00f3n de cadenas. Para poder hacer una operaci\u00f3n de adici\u00f3n de una cadena y un n\u00famero, es necesario hacer la conversi\u00f3n expl\u00edcita de la cadena a n\u00famero:</p> <pre><code>console.log(3 + \"3\") // 33\nconsole.log(3 + Number(\"3\")) // 6\n</code></pre> <p>Para pasar una cadena a n\u00famero se sigue los siguientes pasos:</p> <ol> <li>Se eliminan los espacios de las cadenas. Por lo que, si tenemos una cadena `\"  233  \", los espacios no afectar\u00edan a la conversi\u00f3n.</li> <li>Si la cadena resultante es vac\u00eda, se convierte al n\u00famero 0.</li> <li>Si la cadena resultante es una cadena de d\u00edgitos (solo contiene n\u00fameros), se convierte a n\u00famero.</li> <li>Si la cadena resultante es una cadena que contiene alg\u00fan car\u00e1cter distinto a un d\u00edgito, la conversi\u00f3n ser\u00eda err\u00f3nea y retornar\u00eda <code>NaN</code>.</li> </ol> <p>Existen cadenas especiales que pueden ser convertidos a n\u00fameros de base de decimal (base 10). Por ejemplo, para indicar que una cadena es una representaci\u00f3n num\u00e9rica octal, se debe usar <code>0o</code>. <code>0x</code> y <code>0b</code> representan una cadena hexadecimal y binaria, respectivamente:</p> <pre><code>console.log(Number(\"0o10\")) // 8 (octal)\nconsole.log(Number(\"2e1\")) // 20 (notaci\u00f3n exponencial)\nconsole.log(Number(\"0b10100\")) // 20 (binaria)\nconsole.log(Number(\"0xF\")) // 15 (hexadecimal)\n</code></pre> <p>Por desgracia, el m\u00e9todo <code>Number</code> no puede parsear unidades de medida a n\u00famero:</p> <pre><code>console.log('20px') // NaN\n</code></pre> <p>Si se desea parsear una valor booleano a un n\u00famero, ser\u00e1 convertido a 0 si el valor del booleano es <code>false</code>, y a 1 si es <code>true</code>.</p> <pre><code>console.log(Number(true)) // 1\nconsole.log(Number(false)) // 0 \n</code></pre> <p>De la misma manera, el tipo <code>undefined</code> se convierte como <code>NaN</code> y el tipo <code>null</code> se convierte a 0.</p> <pre><code>console.log(Number(null)) // 0\nconsole.log(Number(undefined)) // 1\n</code></pre> <p>Existen otros m\u00e9todos para parsear un valor a n\u00famero, <code>parseInt(value)</code> y <code>parseDouble(value)</code>. Su funcionamiento es similar, pero en el primer caso realiza la conversi\u00f3n a n\u00famero entero, y en el segundo a n\u00famero decimal.</p> <p>Warning</p> <p>Los m\u00e9todos <code>parseInt</code> y <code>parseDouble</code> solo sirven para pasar cadenas con d\u00edgitos. Cualquier otro tipo de valor (incluso las cadenas especiales para representar n\u00fameros de otras bases) retornar\u00eda <code>NaN</code> como resultado.</p> <pre><code>console.log(parseInt(false)) // NaN\nconsole.log(parseInt(\"0b1000\")) // NaN\n</code></pre> <p>Las funciones pueden recibir un segundo par\u00e1metro que indique la base a la que se desea convertir la cadena, sin necesidad de hacer el uso de cadenas especiales, como en el caso de <code>Number()</code>. Si no lo recibe, se usar\u00eda la base diez (decimal) por defecto.</p> <pre><code>console.log(parseInt(\"101000\", 2)) // 20\nconsole.log(parseInt(\"010\"), 8) // 8\nconsole.log(parseInt(\"0xF\"), 16) // 15\n</code></pre> <p>Al usar este n\u00famero con una cadena que comience con un n\u00famero, convierte la cadena en dicho n\u00famero ignorando el resto de la cadena. Por ello, este m\u00e9todo, si permite parsear unidades:</p> <pre><code>console.log(parseInt(\"2000 hola mundo\")) // 2000\nconsole.log(parseInt(\"20 hola 50\")) //20\nconsole.log(parseInt(\"0b10100\")) // 0\nconsole.log(parseInt(\"20em\")) // 20\n</code></pre> <p>Existe una manera m\u00e1s sencilla de realizar la conversi\u00f3n de manera expl\u00edcita, haciendo uso del operador unario <code>+</code>. Al usar dicho operador delante del valor a convertir, se convierte de forma autom\u00e1tica. Aunque si se usa en operaciones con varios operando, hay que tener en cuenta la precedencia, aunque dicho operador tiene mayor precedencia que los operadores matem\u00e1ticos.</p> <pre><code>console.log(+\"3\") //3\nconsole.log(+false) //0\nconsole.log(+true) // 1\nconsole.log(+null) // 0\nconsole.log(+undefined) //NaN\nconsole.log(+\"Hola\") // NaN\nconsole.log(+\"0b10100\") // 20\nconsole.log(+\"2e1\") // 20\nconsole.log(3 + +\"4\") // 7\n</code></pre>"},{"location":"bloque_i/tema_2/page-7/#conversion-explicita-a-boolean","title":"Conversi\u00f3n expl\u00edcita a boolean","text":"<p>Convertir a booleano es una de las operaciones de conversi\u00f3n m\u00e1s simples. Siguiendo las siguientes reglas:</p> <ul> <li>Los valores vac\u00edos, como <code>undefined</code>, <code>0</code>, <code>null</code>, <code>''</code>, <code>NaN</code> se convierten a <code>false</code>.</li> <li>El resto de valores se convierten a <code>true</code>.</li> </ul> <p>Para realizar la conversi\u00f3n expl\u00edcita de los valores, se hace uso de la funci\u00f3n <code>Boolean(value)</code>:</p> <pre><code>console.log(Boolean(1)) // true\nconsole.log(Boolean(0)) // false\nconsole.log(\"\") // false\nconsole.log(\"Hola\") // true\n</code></pre> <p>Warning</p> <p>Algunos lenguajes, como PHP, entiende la cadena <code>\"0\"</code> como <code>false</code>. Pero, en Javascript, cualquier cadena no vac\u00eda es siempre <code>true</code>. Al igual que ocurre con una cadena con solo espacios <code>\" \"</code></p> <pre><code>console.log(Boolean(\"0\")) // true\nconsole.log(Boolean(\" \")) // true\n</code></pre> <p>Existen otras formas de conversi\u00f3n impl\u00edcitas a booleanos, como los operadores l\u00f3gicos, las estructura <code>if</code>, etc.</p>"},{"location":"bloque_i/tema_3/page-1/","title":"1 Condicionales","text":""},{"location":"bloque_i/tema_3/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Los programas se construyen para procesar datos, manipul\u00e1ndolos de formas diferentes dependiendo de los valores que tengan. Los lenguajes de programaci\u00f3n deben proveer estructuras que les permitan a los programadores controlar el flujo de ejecuci\u00f3n de un programa dependiendo de los datos que procesan. Para ello, se incluyen las sentencias de control de flujo, que alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</p> <p>La programaci\u00f3n estructurada es un paradigma de programaci\u00f3n orientado a mejorar la claridad, calidad y tiempo de desarrollo de un programa de computadora recurriendo \u00fanicamente a subrutinas y tres estructuras b\u00e1sicas: secuencia, sentencias condicionales y bucles.</p>"},{"location":"bloque_i/tema_3/page-1/#secuencia-condicional","title":"Secuencia condicional","text":"<p>La ejecuci\u00f3n secuencial es el m\u00e1s b\u00e1sico de los mecanismos de control de flujo y consiste en la ejecuci\u00f3n de instrucciones en el orden en que se encuentran en el c\u00f3digo fuente del programa.</p> <p>Hasta ahora las instrucciones que hemos visto, son instrucciones que se ejecutan secuencialmente; es decir, podemos saber lo que hace el programa leyendo las l\u00edneas de izquierda a derecha y de arriba abajo.</p> <p>La sentencia condicional consiste en ejecutar instrucciones diferentes dependiendo del resultado de evaluar una expresi\u00f3n l\u00f3gica. Una expresi\u00f3n l\u00f3gica es cualquier tipo de expresi\u00f3n que devuelva un resultado booleano (<code>true</code> o <code>false</code>).</p>"},{"location":"bloque_i/tema_3/page-1/#condicional-simple","title":"Condicional Simple","text":"<p>El condicional simple es la estructura que ejecuta una serie de condiciones si cumple una condici\u00f3n:</p> <pre><code>if(condici\u00f3n){\n// instrucciones\n}\n</code></pre> <p>Por ejemplo:</p> <pre><code>const number = 10\nif(number &gt; 5){\nconsole.log(\"The number is greater than 5\")\n}\n</code></pre> <p>En caso de que no se cumpla la condici\u00f3n, no se ejecutar\u00e1 nada:</p> <pre><code>const number = 4\nif(number &gt; 5){\nconsole.log(\"The number is greater than 5\")\n}\n</code></pre> <p>Warning</p> <p>La sentencia <code>if(...)</code> se encarga de evaluar la expresi\u00f3n de dentro del par\u00e9ntesis y convertir su resultado en booleano, en caso de no serlo. Para ello, sigue las reglas de conversi\u00f3n vistas en el tema anterior.</p>"},{"location":"bloque_i/tema_3/page-1/#condicional-doble","title":"Condicional doble","text":"<p>Es igual que la anterior, s\u00f3lo que se a\u00f1ade un apartado <code>else</code> que contiene instrucciones que se ejecutar\u00e1n si la expresi\u00f3n evaluada por el <code>if</code> es falsa.</p> <pre><code>if(condici\u00f3n){\n// instrucciones si es verdadera\n} else {\n// instrucciones si es falsa\n}\n</code></pre> <p>En este caso, se comprueba si la condici\u00f3n del <code>if</code> es verdadera y en caso de serlo se ejecuta las instrucciones. Por el contrario, se ejecuta el conjunto de instrucciones del <code>else</code>.</p> <pre><code>if(number){\nconsole.log('La variable number existe y su valor es', number)\n} else {\nconsole.log('La variable number no existe')\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#condicional-multiple","title":"Condicional m\u00faltiple","text":""},{"location":"bloque_i/tema_3/page-1/#anidacion","title":"Anidaci\u00f3n","text":"<p>Dentro de una sentencia <code>if</code> se puede colocar otra sentencia <code>if</code>. A esto se le llama anidaci\u00f3n y permite crear programas donde se valoren expresiones complejas. La nueva sentencia puede ir tanto en la parte if como en la parte else.</p> <p>Las anidaciones se utilizan much\u00edsimo al programar. Solo hay que tener en cuenta que siempre se debe cerrar primero el \u00faltimo <code>if</code> que se abri\u00f3. Es muy importante tambi\u00e9n tabular el c\u00f3digo correctamente para que las anidaciones sean legibles.</p> <p>Ejemplo:</p> <pre><code>if(x == 1){\n// instrucciones\n} else {\nif(x == 2){\n// instrucciones\n} else {\nif(x == 3){\n// instrucciones\n}\n}\n}\n</code></pre> <p>Una forma m\u00e1s legible de escribir ese mismo c\u00f3digo dando lugar a la llamada estructura <code>if-else-if</code> ser\u00eda:</p> <pre><code>if(x == 1){\n// instrucciones\n} else if(x == 2){\n// instrucciones\n} else if(x == 3){\n// instrucciones\n}\n</code></pre> <p>Cuando se cumpla alguna de las condiciones, se ejecutan sus instrucciones correspondientes y despu\u00e9s ya se sale de la estructura if-else-if ya que las condiciones son autoexcluyentes, es decir, solamente se va a cumplir una. Por eso, no estar\u00eda bien hacer lo siguiente:</p> <pre><code>if(x == 1){ // Forma incorrecta de programar\n// instrucciones\n}\nif(x == 2){\n// instrucciones\n}\nif(x == 3){\n// instrucciones\n}\n</code></pre> <p>El motivo de que no sea adecuado es porque se pierde tiempo en comprobar todas las condiciones. Por ejemplo, si x vale 1, se ejecutan sus instrucciones correspondientes y luego se comprobar\u00eda si x vale 2, si x vale 3, etc. cuando no se va a cumplir ninguna m\u00e1s ya que si x vale 1 no puede valer ni 2 ni 3.</p> <pre><code>const age = parseInt(prompt(\"Introduzca su edad: \"))\nif (age &gt;= 18) {\nconsole.log(\"Eres mayor de edad\");\n} else if (age &gt;= 16 &amp;&amp; age &lt; 18) {\nconsole.log(\"Eres menor de edad pero tienes ciertos privilegios\");\n} else if (age &gt;= 14 &amp;&amp; age &lt; 16) {\nconsole.log(\"Eres menor de edad y adem\u00e1s no tienes privilegios\");\n} else {\nconsole.log(\"Eres menor de edad\");\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#switch","title":"Switch","text":"<p>El cuerpo de una sentencia <code>switch</code> se conoce como bloque switch. Esta sentencia eval\u00faa una expresi\u00f3n y cada <code>case</code> contiene un posible valor del resultado de dicha expresi\u00f3n; si efectivamente el resultado equivale a ese valor, se ejecutan las instrucciones de ese <code>case</code> y de los siguientes.</p> <pre><code>switch(expresi\u00f3n) {\ncase valor1 :\ninstrucciones\nbreak; // opcional\ncase valor2 :\ninstrucciones\nbreak; // opcional\n//....\n//....\ndefault : // opcional\ninstrucciones\nbreak; // opcional\n}\n</code></pre> <p>La instrucci\u00f3n <code>break</code> se utiliza para salir del <code>switch</code>. De tal modo que si queremos que para un determinado valor se ejecuten las instrucciones de un apartado <code>case</code> y solo las de ese apartado, entonces habr\u00e1 que finalizar ese <code>case</code> con un <code>break</code>. Cuando se alcanza una sentencia <code>break</code>, el <code>switch</code> termina y el flujo de control salta a la siguiente l\u00ednea que sigue a la sentencia <code>switch</code>.</p> <p>Fall through condition (condici\u00f3n de ca\u00edda): esta condici\u00f3n se produce en la sentencia <code>switch</code> cuando no se utiliza <code>break</code> en un <code>case</code> y causa la ejecuci\u00f3n de los siguientes <code>case</code> hasta que no se produce un break o se sale de la sentencia switch.</p> <p>El bloque <code>default</code> sirve para ejecutar instrucciones para los casos en los que la expresi\u00f3n no se ajuste a ning\u00fan case. T\u00e9cnicamente, el <code>break</code> del <code>default</code> no es necesario porque el flujo se sale de la sentencia <code>switch</code>, pero se recomienda utilizarlo para que la modificaci\u00f3n del c\u00f3digo sea m\u00e1s f\u00e1cil y menos propensa a errores.</p> <p>En ciertas ocasiones, se puede usar la sentencia <code>return</code> en lugar de la sentencia <code>break</code>, sobretodo cuando queremos que la estructura <code>switch</code> devuelva un valor, por ejemplo, dentro de una funci\u00f3n.</p> <pre><code>let a = 2 + 2;\nswitch (a) {\ncase 3:\nconsole.log('Muy peque\u00f1o');\nbreak;\ncase 4:\nconsole.log('\u00a1Exacto!');\nbreak;\ncase 5:\nconsole.log('Muy grande');\nbreak;\ndefault:\nconsole.log(\"Desconozco estos valores\");\n}\n</code></pre> <p>Expresiones</p> <p>Ambos <code>switch</code> y <code>case</code> permiten expresiones arbitrarias.</p> <pre><code>let a = \"1\";\nlet b = 0;\nswitch (+a) {\ncase b + 1:\nalert(\"esto se ejecuta, porque +a es 1, exactamente igual b+1\");\nbreak;\ndefault:\nalert(\"esto no se ejecuta\");\n}\n</code></pre> <p>Se pueden agrupar varias sentencias <code>case</code> en caso de que se desee que hagan las mismas instrucciones:</p> <pre><code>let a = 2 + 2;\nswitch (a) {\ncase 4:\nconsole.log('\u00a1Correcto!');\nbreak;\ncase 3:\ncase 5:\nconsole.log('\u00a1Incorrecto!');\nconsole.log(\"\u00bfPor qu\u00e9 no tomas una clase de matem\u00e1ticas?\");\nbreak;\ndefault:\nconsole.log('El resultado es extra\u00f1o. Realmente.');\n}\n</code></pre> <p>\u00a1Cuidado!</p> <p>Hay que tener en cuenta, que el tipo de dato a evaluar en las expresiones IMPORTAN, por lo que no es lo mismo evaluar el valor <code>\"3\"</code> que el valor <code>3</code>:</p> <pre><code>let arg = prompt(\"Ingrese un valor\");\nswitch (arg) {\ncase '0':\ncase '1':\nconsole.log('Uno o cero');\nbreak;\ncase '2':\nconsole.log('Dos');\nbreak;\ncase 3:\nconsole.log('\u00a1Nunca ejecuta!');\nbreak;\ndefault:\nconsole.log('Un valor desconocido');\n}\n</code></pre> <p>En el caso anterior, si el usuario introduce un valor entre 0 y 2, se ejecutar\u00e1 las instrucciones pertinentes. Pero, si introduce un 3, se ejecutar\u00e1 las instrucciones <code>default</code>, ya que el 3 introducido por el usuario es de tipo <code>string</code> y el que se esta evaluando en el <code>case</code> es de tipo <code>number</code> y las sentencias <code>case</code> hacen comparaciones estrictas, es decir, como si usar\u00e1n el comparador <code>===</code></p>"},{"location":"bloque_i/tema_3/page-1/#operador-ternario","title":"Operador Ternario","text":"<p>Como ya vimos en el tema anterior, el operador ternario realiza una funci\u00f3n id\u00e9ntica a la estructura condicional. La diferencia entre ambas es que el operador ternario es una expresi\u00f3n, que dependiendo de su valor devuelve un valor u otro, mientras que la estructura condicional, es una estructura que eval\u00faa una expresi\u00f3n y ejecuta una serie de instrucciones, seg\u00fan el valor de esa expresi\u00f3n.</p> <p>Se recomienda el uso de operador ternario, siempre que se desea devolver un valor dependiendo de una condici\u00f3n y no para la ejecuci\u00f3n de instrucciones. Por lo que, NO se recomienda hacer lo siguiente:</p> <pre><code>(company == 'Netscape') ?\nalert('\u00a1Correcto!') : alert('Equivocado.');\n</code></pre> <p>Para eso se recomienda el uso de la estructura condicional:</p> <pre><code>if (company == 'Netscape') {\nalert('\u00a1Correcto!');\n} else {\nalert('Equivocado.');\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-1/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>\u00bfSe ejecutar\u00e1 la siguiente instrucci\u00f3n? Justifica tu respuesta.</p> <pre><code>if(\"0\"){\nconsole.log('Hello')\n}\n</code></pre> Ejercicio 2 <p>Realizar un programa que le pregunte al usuario el nombre oficial de Javascript. Si el usuario introduce ECMAScript se mostrar\u00e1 por consola y de color verde una frase exitosa. Por el contrario, se mostrar\u00e1 en rojo, que la respuesta es incorrecta y se mostrar\u00e1 la respuesta correcta.</p> Ejercicio 3 <p>Realiza un programa que compruebe si un n\u00famero introducido por el usuario es un n\u00famero positivo, negativo o 0.</p> Ejercicio 4 <p>Reescribe el siguiente ejemplo, haciendo uso del operador ternario:</p> <pre><code>let result;\nif (a + b &lt; 4) {\nresult = 'Debajo';\n} else {\nresult = 'Encima';\n}\n</code></pre> Ejercicio 5 <p>Reescribe el siguiente ejemplo, haciendo uso de la estructura condicional:</p> <pre><code>let message = (login == 'Empleado') ? 'Hola' :\n(login == 'Director') ? 'Felicidades' :\n(login == '') ? 'Sin sesi\u00f3n' :\n'';\n</code></pre> Ejercicio 6 <p>Realiza un programa que lea tres n\u00fameros positivos y compruebe si son iguales. Por ejemplo: Si la entrada fuese 5 5 5, la salida deber\u00eda ser \u201chay tres n\u00fameros iguales a 5\u201d. Si la entrada fuese 4 6 4, la salida deber\u00eda ser \u201chay dos n\u00fameros iguales a 4\u201d. Si la entrada fuese 0 1 2, la salida deber\u00eda ser \u201cno hay n\u00fameros iguales\u201d.</p> Ejercicio 7 <p>Haciendo uso de la estructura condicional <code>if-else-if</code>, realiza un programa que solicite al usuario una nota y la eval\u00fae de la siguiente forma:</p> <ul> <li>0, 1, 2: Muy deficiente</li> <li>3, 4: Insuficiente</li> <li>5: Suficiente</li> <li>6: Bien</li> <li>7, 8: Notable</li> <li>9, 10: Sobresaliente</li> </ul> <p>Si introduce un n\u00famero diferente a los indicados anteriormente, mostrar\u00e1 un mensaje de error.</p> Ejercicio 8 <p>Realiza el mismo ejercicio anterior, haciendo uso de la estructura <code>switch</code>.</p> Ejercicio 9 <p>Realiza un programa que calcule el precio de un billete de ida y vuelta por avi\u00f3n, conociendo la distancia a recorrer, el n\u00famero de d\u00edas de estancia y sabiendo que si la distancia es superior a 1.000 Km y el n\u00famero de d\u00edas de estancia es superior a 7, la l\u00ednea a\u00e9rea le hace un descuento del 30 %. (Precio por kil\u00f3metro = 0,35 \u20ac).</p> Ejercicio 10 <p>Los empleados de una f\u00e1brica trabajan en dos turnos: diurno y nocturno. Se desea calcular el jornal diario de acuerdo con los siguientes tarifas: la tarifa de las horas diurnas es de 3 \u20ac por hora, mientras que el de las nocturnas es de 4,80 \u20ac po hora. Cuando se trata de un d\u00eda festivo, la tarifa se incrementa en 1,20 \u20ac por hora en el turno diurno y 1,80 \u20ac por hora en el nocturno.</p> Ejercicio 11 <p>Realiza un programa que dados tres n\u00fameros, los devuelva en orden ascendente.</p>"},{"location":"bloque_i/tema_3/page-2/","title":"2 Bucles","text":""},{"location":"bloque_i/tema_3/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>En programaci\u00f3n, un bucle o instrucci\u00f3n de control repetitiva (o iterativa) permite ejecutar una o m\u00e1s instrucciones varias veces, es decir, permite ejecutar un bloque de instrucciones repetidamente, escribi\u00e9ndolas una sola vez en el programa, reduciendo de este modo el c\u00f3digo del mismo. Cada vuelta que da el bucle se conoce como iteraci\u00f3n.</p> <p>Las variables que se utilizan en los bucles pueden tener distintas funciones:</p> <ul> <li>\u00edndice: es una variable que apunta a un recurso concreto. En los bucles, apunta al n\u00famero de iteraci\u00f3n. Se suelen utilizar por convenio los identificadores de variables <code>i</code>, <code>j</code> y <code>k</code>.</li> <li>contador: cuenta cu\u00e1ntas veces ocurre algo.</li> <li>acumulador: acumula operaciones parciales.</li> </ul> <p>Las instrucciones b\u00e1sicas que permiten construir este tipo de estructuras son <code>while</code>, <code>do-while</code> y <code>for</code>.</p>"},{"location":"bloque_i/tema_3/page-2/#while","title":"While","text":"<p>El bucle <code>while</code> agrupa instrucciones las cuales se ejecutan continuamente mientras una condici\u00f3n que se eval\u00faa sea verdadera. La condici\u00f3n se eval\u00faa antes de entrar dentro del <code>while</code> y cada vez que se termina de ejecutar las instrucciones del <code>while</code>.</p> <p>El programa se ejecuta siguiendo estos pasos:</p> <ol> <li>Se eval\u00faa la expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera ejecuta las instrucciones, sino el programa abandona la sentencia <code>while</code>.</li> <li>Tras ejecutar las instrucciones, volvemos al paso 1.</li> </ol> <pre><code>while(expresi\u00f3nL\u00f3gica){\n//instrucciones\n}\n</code></pre> <p>Por ejemplo, se quiere mostrar los n\u00fameros del 1 al 10:</p> <pre><code>let number = 0\nwhile(number &lt; 10){\nconsole.log(++number)\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#do-while","title":"Do-while","text":"<p>La \u00fanica diferencia respecto al <code>while</code> est\u00e1 en que la expresi\u00f3n l\u00f3gica se eval\u00faa despu\u00e9s de haber ejecutado las instrucciones. Es decir, el bucle al menos se ejecuta una vez. Los pasos son los siguientes:</p> <ol> <li>Ejecutar instrucciones.</li> <li>Evaluar expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera, volver al paso 1. Si es falsa, salir del do-while.</li> </ol> <p>El ejemplo anterior se har\u00eda de la siguiente manera:</p> <pre><code>let number = 0\ndo{\nconsole.log(++number)\n} while(number &lt; 10)\n</code></pre> <p>Se recomienda hacer uso de la estructura <code>do-while</code> cuando se desea que independientemente de la condici\u00f3n se ejecute las instrucciones al menos una vez. Uno de sus usos m\u00e1s comunes, es para pedir al usuario alg\u00fan dato, y en caso de que no se cumpla lo introducido se vuelva a introducir:</p> <pre><code>let number\ndo{\nnumber = parseInt(prompt('Introduce un n\u00famero entre 0 y 10'))\n} while(number &lt; 0 || number &gt; 10)\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#for","title":"For","text":"<p>El bucle <code>for</code> es una estructura de iteraci\u00f3n donde se utiliza una variable local que controle la iteraci\u00f3n. El funcionamiento es el siguiente:</p> <ol> <li>Se ejecuta la instrucci\u00f3n de inicializaci\u00f3n.</li> <li>Se comprueba la condici\u00f3n.</li> <li>Si la condici\u00f3n es cierta, entonces se ejecutan las instrucciones. Si la condici\u00f3n es falsa, se abandona el bloque for.</li> <li>Tras ejecutar las instrucciones, se ejecuta la instrucci\u00f3n de incremento y se vuelve al paso</li> </ol> <pre><code>for(inicializaci\u00f3n;condici\u00f3n;incremento){\n// instrucciones\n}\n</code></pre> <p>As\u00ed el ejemplo anterior:</p> <pre><code>for(let number = 1; number &lt;= 10; number++){\nconsole.log(number)\n}\n</code></pre> <p>La inicializaci\u00f3n se puede hacer tanto como dentro como fuera del bucle, aunque se recomienda hacer uso de ella dentro.</p> <p>Tambi\u00e9n se admite m\u00e1s de una variable, en cuyo caso, en las partes de inicializaci\u00f3n e incremento, se utiliza como separador la coma <code>,</code>:</p> <pre><code>for(int i = 0, j = 10; i &lt;= j; i++, j--){\nconsole.log(`i: ${i} j: ${j}`);\n}\n</code></pre> <p>Danger</p> <p>Por motivos de legibilidad de c\u00f3digo, es muy importante que las variables del <code>for</code> aparezcan en las 3 partes del <code>for</code>, es decir, en la inicializaci\u00f3n, en la condici\u00f3n y en el incremento, ya que el programador que quiera saber cu\u00e1ntas iteraciones realiza el bucle, solamente con fijarse en la l\u00ednea de c\u00f3digo donde se encuentra el <code>for</code>, pueda saberlo. Si las variables del <code>for</code> no aparecen en las 3 partes, eso nos indica que es m\u00e1s conveniente realizar un <code>while</code> o un <code>do-while</code>.</p> <p>Veamos el ejemplo que muestra n\u00fameros aleatorios entre 1 y 500 hasta que salga uno m\u00faltiplo de 7:</p> <pre><code>boolean exit = false;\nint number = 0, i;\nfor(i = 1; !exit; i++){ // Este for no es legible, se debe sustituir por un do-while\nnumber = Math.floor((Math.random() * 500) + 1);\nSystem.out.printf(\"Iteraci\u00f3n %d, n\u00famero: %d\\n\", i, number);\nexit = (number % 7 == 0);\n}\nSystem.out.printf(\"El m\u00faltiplo de 7 con valor %d se ha encontrado en la iteraci\u00f3n %d\", number, i - 1);\n</code></pre> <p>En Javascript, podemos omitir las siguientes partes:</p> <ul> <li> <p>La inicializaci\u00f3n, si se realiza fuera del bucle:</p> <pre><code>let i = 0\nfor (; i &lt; 3; i++) { alert(i)\n}\n</code></pre> </li> <li> <p>El incremento si se hace dentro del bucle:</p> <pre><code>let i = 0;\nfor (; i &lt; 3;) {\nalert( i++ );\n}\n</code></pre> </li> <li> <p>Todo, si no se desea que el bucle tenga l\u00edmite, es decir, que sea un bucle infinito.</p> <pre><code>for (;;) {\n// se repite sin limites\n}\n</code></pre> </li> </ul> <p>En cualquiera de los casos, es obligatorio el uso del punto y coma <code>;</code> para que no de un error de sintaxis.</p>"},{"location":"bloque_i/tema_3/page-2/#diferencias","title":"Diferencias","text":"<p>Todos los bucles se pueden hacer con <code>for</code>, <code>while</code> y <code>do-while</code>, entonces, \u00bfcu\u00e1l se debe usar? Es importante que le programador utilice la estructura m\u00e1s adecuada en cada caso:</p> <ul> <li>Un bucle <code>for</code> se utiliza cuando se conozca el n\u00famero de veces que se va a ejecutar el bucle, es decir, cuando se conozcan el n\u00famero de iteraciones de antemano.</li> <li>Si no se sabe de antemano el n\u00famero de iteraciones, entonces hay que utilizar <code>while</code> o <code>do-while</code>:</li> <li>Un bucle <code>do-while</code> se utiliza cuando las instrucciones del bucle se van a ejecutar al menos una vez.</li> <li>Un bucle <code>while</code> se utiliza, entonces, cuando las instrucciones del bucle pueden no ejecutarse nunca si la condici\u00f3n es falsa desde un principio.</li> </ul>"},{"location":"bloque_i/tema_3/page-2/#bucles-forin-forof","title":"Bucles for..in for..of","text":"<p>El bucle <code>for..in</code> es un bucle que sirve para recorrer un objeto en Javascript:</p> <pre><code>for (key in object) {\n// se ejecuta el cuerpo para cada clave entre las propiedades del objeto\n}\n</code></pre> <p>Por ejemplo:</p> <pre><code>let user = {\nname: \"John\",\nage: 30,\nisAdmin: true\n}\nfor (let key in user) {\nconsole.log(key, user[key])\n}\n</code></pre> <p>El bucle <code>for..of</code> se utiliza para recorrer los valores de un array:</p> <pre><code>const array = [1,2,3,4]\nfor(let a of array){\nconsole.log(a)\n}\n</code></pre>"},{"location":"bloque_i/tema_3/page-2/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Dados dos n\u00fameros <code>n1</code> y <code>n2</code>, tal que <code>n1 &lt;= n2</code>, mostrar los n\u00fameros pares comprendidos entre ellos ambos incluidos. Visualizar al final el n\u00famero total de pares encontrados. Hacer uso del bucle <code>while</code>.</p> Ejercicio 2 <p>Realiza el ejercicio anterior haciendo uso del bucle <code>do-while</code>.</p> Ejercicio 3 <p>Realiza el ejercicio anterior haciendo uso del bucle <code>for</code>.</p> Ejercicio 4 <p>\u00bfCu\u00e1l es el \u00faltimo valor mostrado en alerta por este c\u00f3digo? \u00bfPor qu\u00e9?</p> <pre><code>let i = 3\nwhile (i) {\nconsole.log(i--)\n}\n</code></pre> Ejercicio 5 <p>Muestra los n\u00fameros pares comprendido entre 0 y 10. Usa el bucle que creas correspondiente, justificando su uso.</p> Ejercicio 6 <p>Escribe un bucle que solicite un n\u00famero mayor que 100. Si el usuario ingresa otro n\u00famero p\u00eddele que ingrese un valor de nuevo.</p> <p>El bucle debe pedir un n\u00famero hasta que el usuario ingrese un n\u00famero mayor que 100 o bien cancele la entrada o ingrese una linea vac\u00eda.</p> <p>Aqu\u00ed podemos asumir que el usuario solo ingresar\u00e1 n\u00fameros. No hay necesidad de implementar un manejo especial para entradas no num\u00e9ricas en esta tarea.</p> Ejercicio 7 <p>Escribe un programa que le solicite al usuario un n\u00famero, y muestre los n\u00fameros primos comprendidos entre 0 y dicho n\u00famero. Para <code>n = 10</code> el resultado ser\u00e1 2, 3, 5, 7. El c\u00f3digo deber\u00eda funcionar para cualquier n, no debe estar programado para valores fijos.</p> Ejercicio 8 <p>Realiza un programa que muestre la tabla de multiplicar de un n\u00famero solicitado por el usuario. El n\u00famero que debe introducir debe ser comprendido entre 1 y 10. </p>"},{"location":"bloque_i/tema_4/page-1/","title":"1 Funciones","text":""},{"location":"bloque_i/tema_4/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>Podemos distinguir tres t\u00e9rminos que poseen diferencias:</p> <ul> <li>Funci\u00f3n: conjunto de instrucciones que devuelven un resultado.</li> <li>Procedimiento: conjunto de instrucciones que se ejecutan sin devolver ning\u00fan resultado.</li> <li>M\u00e9todo: funci\u00f3n o procedimiento que pertenece a un objeto.</li> </ul> <p>Dichas funciones se pueden utilizar desde muchos sitios diferentes, por lo que de manera general, no se suelen poner mensajes en consola en las funciones ya que puede ser que dichos mensajes no interesen en todos los sitios donde se utilice dicha funci\u00f3n. A no ser que la funci\u00f3n se haya creado espec\u00edficamente para dar mensajes informativos en consola.</p>"},{"location":"bloque_i/tema_4/page-1/#declaracion","title":"Declaraci\u00f3n","text":"<p>Existen diferentes maneras de crear una funci\u00f3n, pero la forma est\u00e1ndar y longeva es la siguiente:</p> <pre><code>function functionName([param1, param2, param3, ..., paramN]){\n// instrucciones\n[return value]\n}\n</code></pre> <p>Para declarar una funci\u00f3n de forma est\u00e1ndar es necesario hacer uso de la palabra reservada <code>function</code> seguido del nombre de la funci\u00f3n (functionName) y par\u00e9ntesis. Dentro de estos par\u00e9ntesis se pueden declarar los par\u00e1metros necesarios para usar dentro de la funci\u00f3n. Los par\u00e1metros son variables que se necesitan usar dentro de las funciones y que en cada llamada de la funci\u00f3n tiene valores diferentes. Una funci\u00f3n puede recibir ning\u00fan par\u00e1metro.</p> <p>Las funciones, adem\u00e1s, pueden retornar un valor que puede ser usada en variables o en otras funciones. Si una funci\u00f3n no retorna ning\u00fan valor, estar\u00edamos hablando t\u00e9cnicamente de un procedimiento.</p> <p>Veamos un ejemplo de una funci\u00f3n que recibe dos n\u00fameros, y retorne la suma de ambos:</p> <pre><code>function suma(sumando1, sumando2){\nreturn sumando1 + sumando2\n}\n</code></pre> <p>Ahora, veamos un ejemplo de una funci\u00f3n con dos retornos. En este caso, en el momento que retorne una de los dos valores, abandona el flujo de la funci\u00f3n. Una funci\u00f3n aunque tenga varios <code>return</code> solo puede retornar un valor:</p> <pre><code>function isPair(number){\nif(number % 2 === 0){\nreturn 'es par'\n}\nreturn 'es impar'\n}\n</code></pre> <p>En el ejemplo anterior, si el n\u00famero obtenido como par\u00e1metro es par, retorna el valor de <code>es par</code>. Por el contrario, si el n\u00famero es impar, no entra en la condici\u00f3n y obvia el primer <code>return</code>, por lo que retornar\u00eda <code>es impar</code>. Veamos un ejemplo de procedimiento:</p> <pre><code>function sayHi(){\nconsole.log('Hi')\n}\n</code></pre> <p>Recuerda</p> <p>En este punto, es bueno recordar el \u00e1mbito de vida de una variable, y recordar la diferencia entre \u00e1mbito de vida local y \u00e1mbito de vida global, tal y como lo vimos en el tema dos</p>"},{"location":"bloque_i/tema_4/page-1/#llamada","title":"Llamada","text":"<p>Para realizar la llamada de una funci\u00f3n, se usa la siguiente estructura: <code>functionName([arg1, arg2, ..., argN])</code>. Se le puede indicar los argumentos que reciba.</p> <p>La diferente entre argumento y par\u00e1metro es que un par\u00e1metro es una variable que se define a la hora de declarar la funci\u00f3n y un argumento es el valor del par\u00e1metro a la hora de la llamada de la funci\u00f3n.</p> <p>Warning</p> <p>Si una funci\u00f3n no recibe par\u00e1metros pero en su llamada le pasamos argumentos, estos ser\u00e1n omitidos y Javascript no lanzar\u00eda error. Lo mismo ocurrir\u00eda si recibe X par\u00e1metros, y se le pasa m\u00e1s argumentos de los deseados:</p> <pre><code>function sayHi(){\nconsole.log('Hi!')\n}\nsayHi('Hola mundo')\n</code></pre> <p>Lo mismo ocurre, en el caso contario, si una funci\u00f3n define un par\u00e1metro y este no es recibido como argumento, se entiende que el valor de ese par\u00e1metro es <code>undefined</code>:</p> <pre><code>function sayHi(msg){\nconsole.log(msg)\n}\nsayHi()\n</code></pre> <p>En el siguiente ejemplo, podemos comprobar mejor la diferencia entre procedimiento y funci\u00f3n:</p> <pre><code>function sum(num1, num2){\nreturn num1 + num2\n}\nfunction show(msg){\nconsole.log(msg)\n}\nlet sumValue = sum(2, 4)\nshow(sumValue)\n</code></pre> <p>Como vemos en el ejemplo, la funci\u00f3n <code>sum</code> retorna la suma de los dos par\u00e1metros que recibe, por lo que el valor retornado puede ser usado en otra variable o como argumento de otra funci\u00f3n. Mientras que, la funci\u00f3n <code>show</code> es un procedimiento, ya que no retorna nada, y no puede ser usada en ninguna variable. Sin embargo, si por error es usada, el valor de dicha variable ser\u00e1 <code>undefined</code> ya que el procedimiento no retorna ning\u00fan valor, pero podemos entender que por defecto retorna <code>undefined</code>.</p>"},{"location":"bloque_i/tema_4/page-1/#parametros-predeterminados","title":"Par\u00e1metros predeterminados","text":"<p>Como hemos dicho anteriormente, si un par\u00e1metro no es pasado como argumento en una funci\u00f3n su valor predeterminado es <code>undefined</code>. Sin embargo, algunos lenguajes como Javascript permite definir un valor predeterminado para dichos par\u00e1metros para el caso de que no sean usados:</p> <pre><code>function sayHi(msg = 'Hi'){\nconsole.log(msg)\n}\nsayHi()\n</code></pre> <p>En el ejemplo anterior, como la llamada a la funci\u00f3n no recibe par\u00e1metros, mostrara por consola el valor predeterminado <code>Hi</code>.</p> <p>Warning</p> <p>En versiones anteriores, no eran soportados los par\u00e1metros predeterminados. Entonces, se usa un condicional para comprobar si el valor era <code>undefined</code> y se indicada un valor:</p> <pre><code>function sayHi(msg){\nif(msg === undefined){\nmsg = 'Hi'\n}\nconsole.log(msg)\n}\n</code></pre> <p>O se usaba el operador <code>||</code>:</p> <pre><code>function sayHi(msg){\nmsg = msg || 'Hi'\nconsole.log(msg)\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-1/#nomenclatura","title":"Nomenclatura","text":"<p>Las funciones son acciones, por lo que se recomienda que su nombre sea un verbo. Debe ser breve, lo m\u00e1s preciso posible y describir lo que hace la funci\u00f3n, para que alguien que lea el c\u00f3digo obtenga una indicaci\u00f3n de lo que hace la funci\u00f3n.</p> <p>Es una pr\u00e1ctica generalizada comenzar una funci\u00f3n con un prefijo verbal que describe vagamente la acci\u00f3n. Debe haber un acuerdo dentro del equipo sobre el significado de los prefijos.</p> <p>Por ejemplo, funciones que comienzan con show usualmente muestran algo.</p> <p>Funciones que comienza con\u2026</p> <ul> <li>get\u2026 \u2013 devuelven un valor</li> <li>calc\u2026 \u2013 calculan algo</li> <li>create\u2026 \u2013 crean algo</li> <li>check\u2026 \u2013 revisan algo y devuelven un boolean, etc.</li> </ul> <p>Ejemplos de este tipo de nombres:</p> <pre><code>showMessage(..)     // muestra un mensaje\ngetAge(..)          // devuelve la edad (la obtiene de alguna manera)\ncalcSum(..)         // calcula una suma y devuelve el resultado\ncreateForm(..)      // crea un formulario (y usualmente lo devuelve)\ncheckPermission(..) // revisa permisos, y devuelve true/false\n</code></pre> <p>Tips</p> <p>Es altamente recomendable que una funci\u00f3n solo tenga un objeto, es decir, una acci\u00f3n. Una funci\u00f3n debe hacer exactamente lo que sugiere su nombre, no m\u00e1s.</p> <p>Dos acciones independientes por lo general merecen dos funciones, incluso si generalmente se convocan juntas (en ese caso, podemos hacer una tercera funci\u00f3n que llame a esas dos).</p> <p>Algunos ejemplos de c\u00f3mo se rompen estas reglas:</p> <ul> <li><code>getAge</code> \u2013 est\u00e1 mal que muestre una <code>alert</code> o un <code>log</code> con la edad (solo debe obtenerla).</li> <li><code>createForm</code> \u2013 est\u00e1 mal que modifique el documento agreg\u00e1ndole el form (solo debe crearlo y devolverlo).</li> <li><code>checkPermission</code> \u2013 est\u00e1 mal que muestre el mensaje acceso otorgado/denegado(solo debe realizar la verificaci\u00f3n y devolver el resultado).</li> </ul> <p>En estos ejemplos asumimos los significados comunes de los prefijos. T\u00fa y tu equipo pueden acordar significados diferentes, aunque usualmente no muy diferente. En cualquier caso, debe haber una compromiso firme de lo que significa un prefijo, de lo que una funci\u00f3n con prefijo puede y no puede hacer. Todas las funciones con el mismo prefijo deben obedecer las reglas. Y el equipo debe compartir ese conocimiento.</p> <p>Tambi\u00e9n se considera que una buena pr\u00e1ctica que una funci\u00f3n sea lo m\u00e1s breve posible. En caso de que una funci\u00f3n sea demasiado larga, se deber\u00eda revisar y comprobar que el c\u00f3digo no se puede dividir en m\u00e1s funciones. De esta forma, se obtiene una serie de ventajas, como una mayor legibilidad, m\u00e1s facilidad a la hora de probar y depurar.</p>"},{"location":"bloque_i/tema_4/page-1/#recursividad","title":"Recursividad","text":"<p>La recursividad es un patr\u00f3n de programaci\u00f3n que es \u00fatil en situaciones en las que una tarea puede dividirse naturalmente en varias tareas del mismo tipo, pero m\u00e1s simples. O cuando una tarea se puede simplificar en una acci\u00f3n f\u00e1cil m\u00e1s una variante m\u00e1s simple de la misma tarea. O, como veremos pronto, tratar con ciertas estructuras de datos.</p> <p>Sabemos que cuando una funci\u00f3n resuelve una tarea, en el proceso puede llamar a muchas otras funciones. Un caso particular de esto se da cuando una funci\u00f3n se llama a s\u00ed misma. Esto es lo que se llama recursividad.</p> <p>Esta t\u00e9cnica es peligrosa ya que se pueden generar f\u00e1cilmente llamadas infinitas (la funci\u00f3n se llama a s\u00ed misma, tras la llamada se vuelve a llamar a s\u00ed misma, y as\u00ed sucesivamente sin freno ni control). Por lo tanto, es muy importante tener en cuenta cu\u00e1ndo la funci\u00f3n debe dejar de llamarse.</p> <p>Hay que ser muy cauteloso cuando se utiliza la recursividad, pero permite soluciones muy originales y abre la posibilidad de solucionar problemas muy complejos.</p> <p>Veamos un ejemplo sin recursividad:</p> <pre><code>function multiplicate(num1, num2){\nlet result = 0\nfor(let i = 1; i &lt;= num2; i++){\nresult += num1\n}\nreturn result\n}\n</code></pre> <p>En ele ejemplo anterior observamos como se realiza la multiplicaci\u00f3n de dos n\u00fameros realizando suma. En este caso, se est\u00e1 utilizando la iteraci\u00f3n. Le sumamos a la variable <code>result</code> el valor del argumento <code>num1</code> tantas veces como se indica en <code>num2</code>. Ahora bien, cuando hacemos una multiplicaci\u00f3n como ejemplo <code>2*3</code>, \u00bfno es lo mismo que <code>2+2*2</code>?, o lo que es lo mismo, <code>2 + 2 + 2 * 1</code>. En este caso, el indice que indica el n\u00famero de veces a sumar se va reduciendo. En este caso, estamos pensando haciendo uso de la recursividad, ya que cada vez que hacemos una multiplicaci\u00f3n estar\u00edamos llamando a nuestra funci\u00f3n.</p> <pre><code>function multiplicate(num1, num2){\nreturn num1 + multiplicate(num1, num2 - 1)\n}\n</code></pre> <p>Sin embargo, el ejemplo anterior da lugar a que sea infinito, ya que no se controla cual debe ser la \u00faltima recursi\u00f3n, que en este caso ser\u00eda cuando <code>num2</code> valga 1. Esta sentencia de control, se llama caso base es necesaria en la funciones recursivas, ya que indican la \u00faltima ejecuci\u00f3n de la recursividad.</p> <pre><code>function multiplicate(num1, num2){\nif(num2 === 1){\nreturn num1\n}\nreturn num1 + multiplicate(num1, num2 - 1)\n}\n</code></pre> <p>Si se desea hacer la multiplicaci\u00f3n <code>2 * 3</code>:</p> <ol> <li>En la ejecuci\u00f3n inicial no se ejecuta el bloque <code>if</code> si no que se ejecuta <code>2 + multiplicate(2, 2)</code></li> <li>En la siguiente, sigue sin entrar en el <code>if</code>, por lo que se ejecuta <code>2 + multiplicate(2, 1)</code></li> <li>En esta ejecuci\u00f3n retornar\u00eda <code>2</code>, ya que <code>num2</code> vale 1 y entrar\u00eda en el <code>if</code>.</li> <li>Una vez retornado <code>2</code>, podemos completar la ejecuci\u00f3n del paso 2, retornando <code>2 + 2</code>, que ser\u00eda 4.</li> <li>Por \u00faltimo, usar\u00edamos dicho valor, en la ejecuci\u00f3n del paso 1, <code>2 + 4</code>, dando como resultado <code>6</code>.  </li> </ol> <p>El n\u00famero m\u00e1ximo de llamadas anidadas (incluida la primera) se llama profundidad de recursividad. En nuestro caso, ser\u00e1 exactamente <code>num2</code>.</p> <p>La profundidad m\u00e1xima de recursividad est\u00e1 limitada por el motor de JavaScript. Podemos confiar en que sea 10 000; algunos motores permiten m\u00e1s, pero 100 000 probablemente est\u00e9 fuera del l\u00edmite para la mayor\u00eda de ellos. Hay optimizaciones autom\u00e1ticas que ayudan a aliviar esto (\u201coptimizaciones de llamadas de cola\u201d), pero a\u00fan no tienen soporte en todas partes y funcionan solo en casos simples.</p> <p>Eso limita la aplicaci\u00f3n de la recursividad, pero sigue siendo muy amplia. Hay muchas tareas donde la forma recursiva de pensar proporciona un c\u00f3digo m\u00e1s simple y f\u00e1cil de mantener.</p>"},{"location":"bloque_i/tema_4/page-1/#recursividad-vs-iteracion","title":"Recursividad vs iteraci\u00f3n","text":"<p>Ambas implican sentencias repetitivas hasta llegar a una determinada condici\u00f3n, por lo que ambas pueden generar programas que no finalizan si la condici\u00f3n nunca se cumple. En el caso de la iteraci\u00f3n es una condici\u00f3n la que permite determinar el final, la recursividad lo que hace es ir simplificando el problema hasta generar una llamada a la funci\u00f3n que devuelva un valor y no se vuelva a llamar. Para un ordenador es m\u00e1s costosa la recursividad ya que implicar realizar muchas llamadas a funciones, es decir, es m\u00e1s r\u00e1pida la soluci\u00f3n iterativa. Entonces, \u00bfpor qu\u00e9 elegir recursividad? La recursividad se utiliza s\u00f3lo s\u00ed:</p> <ul> <li>No encontramos la soluci\u00f3n iterativa a un problema.</li> <li>El c\u00f3digo es mucho m\u00e1s claro en su versi\u00f3n recursiva.</li> </ul>"},{"location":"bloque_i/tema_4/page-1/#pila","title":"Pila","text":"<p>Una pila (stack) es una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del ingl\u00e9s Last In, First Out, \u00faltimo en entrar, primero en salir) de supuestos en el \u00e1rea de inform\u00e1tica debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.</p> <p>Para el manejo de los datos cuenta con dos operaciones b\u00e1sicas: apilar (push), que coloca un objeto en la pila, y su operaci\u00f3n inversa, desapilar (pop), que retira el \u00faltimo elemento apilado.</p> <p>En cada momento s\u00f3lo se tiene acceso a la parte superior de la pila, es decir, al \u00faltimo objeto apilado (denominado TOS, Top of Stack). La operaci\u00f3n desapilar permite la obtenci\u00f3n de este elemento, que es retirado de la pila permitiendo el acceso al anterior (apilado con anterioridad), que pasa a ser el \u00faltimo, el nuevo TOS.</p> <p>Para las llamadas entre funciones, se utiliza una estructura de tipo pila: supongamos que se est\u00e1 procesando una funci\u00f3n y en su interior llama a otra funci\u00f3n. La funci\u00f3n se abandona para procesar la funci\u00f3n de la llamada, pero antes se almacena en una pila la direcci\u00f3n que apunta a la funci\u00f3n. Ahora supongamos que esa nueva funci\u00f3n llama a su vez a otra funci\u00f3n. Igualmente, se almacena su direcci\u00f3n, se abandona y se atiende la petici\u00f3n. As\u00ed en tantos casos como existan peticiones. La ventaja de la pila es que no requiere definir ninguna estructura de control ni conocer las veces que el programa estar\u00e1 saltando entre funciones para despu\u00e9s retomarlas, con la \u00fanica limitaci\u00f3n de la capacidad de almacenamiento de la pila. Conforme se van cerrando las funciones, se van rescatando las funciones precedentes mediante sus direcciones almacenadas en la pila y se va concluyendo su proceso, esto hasta llegar a la primera.</p> <p>En el caso de una funci\u00f3n recursiva, esto es posible implementarlo con sencillez mediante una pila. La funci\u00f3n se llama a s\u00ed misma tantas veces como sea necesario hasta que el resultado de la funci\u00f3n cumpla la condici\u00f3n de retorno; entonces, todas las funciones abiertas van completando su proceso en cascada. No se necesita saber cuantas veces se anidar\u00e1 y, por tanto, tampoco cuando se cumplir\u00e1 la condici\u00f3n, con la \u00fanica limitaci\u00f3n de la capacidad de la pila. De sobrepasarse ese l\u00edmite, normalmente porque se entra en un bucle sin final, se produce el error de desbordamiento de la pila (stack overflow).</p> <p>Supongamos que tenemos la funci\u00f3n <code>multiplicate(2, 3)</code>, en la primera llamada, volvemos a llamar el valor <code>multiplicate(2, 2)</code> poniendo esta llamada en la primera posici\u00f3n de la pila. La llamada de <code>multiplicate(2, 2)</code> se ejecuta y pasa a llamar <code>multiplicate(2, 1)</code>, apilando esta llamada al comienzo de la pila. Al ejecutar <code>multiplicate(2, 1)</code> retorna 1, por lo que se desapila de la pila y con el valor retornado va operando las llamadas de la pila <code>multiplicate(2, 2)</code> la de <code>multiplicate(2, 3)</code>.</p>"},{"location":"bloque_i/tema_4/page-1/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>La siguiente funci\u00f3n devuelve <code>true</code> si el par\u00e1metro <code>age</code> es mayor a <code>18</code>. De lo contrario, solicita confirmaci\u00f3n y devuelve su resultado. \u00bfFuncionan ambos c\u00f3digos de la misma forma? \u00bfCu\u00e1l ser\u00eda el m\u00e1s \u00f3ptimo? Justifica tu respuesta:</p> AB <pre><code>function checkAge(age) {\nif (age &gt; 18) {\nreturn true;\n} else {\n// ...\nreturn confirm('\u00bfTus padres te permitieron?');\n}\n}\n</code></pre> <pre><code>function checkAge(age) {\nif (age &gt; 18) {\nreturn true;\n}\n// ...\nreturn confirm('\u00bfTus padres te permitieron?');\n}\n</code></pre> Ejercicio 2 <p>\u00bfCu\u00e1l es la salida del siguiente programa?</p> <pre><code>function showMessages(msg){\nconsole.log('This is your message:', msg)\n}\nconsole.log(showMessages('Hola mundo'))\n</code></pre> Ejercicio 3 <p>Crea una funci\u00f3n que calcule reciba una base y un exponente y devuelva la potencia baseexponente.</p> Ejercicio 4 <p>Realiza una funci\u00f3n que devuelva el factorial de un n\u00famero que debe recibir como argumento.</p> Ejercicio 5 <p>Realiza una funci\u00f3n que reciba 3 par\u00e1metros: dos de tipo entero y uno de tipo cadena. La funci\u00f3n deber\u00e1 sumar, restar, multiplicar o dividir los valores de los dos primeros par\u00e1metros dependiendo de la operaci\u00f3n indicada en el tercer par\u00e1metro, y devolver el resultado. La operaci\u00f3n predeterminada ser\u00eda la suma.</p> Ejercicio 6 <p>Realiza una funci\u00f3n que retorne el m\u00e1ximo com\u00fan divisor de dos n\u00fameros.</p> Ejercicio 7 <p>Realiza una funci\u00f3n que retorne el m\u00ednimo com\u00fan m\u00faltiplo de dos n\u00fameros.</p> Ejercicio 8 <p>Realiza una funci\u00f3n que muestre todos los n\u00fameros primos hasta un l\u00edmite indicado. Por ejemplo, si se indica como l\u00edmite 100, se mostrar\u00e1 los n\u00fameros primeros entre 0 y 100.</p> Ejercicio 9 <p>Se dice que un n\u00famero entero es un n\u00famero perfecto si la suma de sus divisores propios (incluyendo el 1 y sin incluirse \u00e9l mismo) da como resultado el mismo n\u00famero. Por ejemplo, 6 es un n\u00famero perfecto, porque sus divisores propios son 1, 2 y 3; y 6 = 1 + 2 + 3. Los siguientes n\u00fameros perfectos son 28, 496 y 8128.</p> <p>Realiza una funci\u00f3n que muestre todos los n\u00fameros perfectos hasta un l\u00edmite indicado.</p> Ejercicio 10 <p>Realiza una funci\u00f3n que reciba un n\u00famero entero positivo de n cifras y devuelva el n\u00famero con sus cifras en orden inverso. No utilizar cadenas ni calcular previamente el n\u00famero de cifras. Ej: 24.321 debe devolver 12.345</p> Ejercicio 11 <p>La serie Fibonacci se define mediante: a0 = 0 a1 = 1 an = an-1 + an-2, es decir, la serie Fibonacci ser\u00eda la siguiente 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p> <p>Realiza una funci\u00f3n que retorne el valor en la posici\u00f3n indicada. Por ejemplo, si se indica:</p> <ul> <li>0 retorna 0</li> <li>1 retorna 1</li> <li>4 retorna 3</li> <li>7 retorna 13</li> </ul> Ejercicio 12 <p>Realiza una funci\u00f3n que retorne los X n\u00fameros primeros de la serie Fibonacci, siendo X un argumento que debe recibir.</p> Ejercicio 13 <p>Realiza una funci\u00f3n que calcule el primer elemento de la serie Fibonacci que se mayor o igual que un valor introducido por par\u00e1metro. Por ejemplo, si recibe 20, devolver\u00e1 21, ya que es el primer elemento de la serie mayor o igual que 20.</p> Ejercicio 14 <p>El m\u00e1ximo com\u00fan divisor de los enteros a y b es el entero m\u00e1s grande que es divisor exacto de a y de b. Escribe una funci\u00f3n recursiva llamada <code>gcd</code> que devuelva el m\u00e1ximo com\u00fan divisor de a y b. El m\u00e1ximo com\u00fan divisor de a y b se define recursivamente como sigue:</p> <ul> <li>si b = 0 \u2192 gcd(a, b) = a</li> <li>si b \u2260 0 \u2192 gcd(a, b) = gcd(b, a % b)</li> </ul> Ejercicio 15 <p>Realiza el ejercicio 3 haciendo uso de la recursividad</p> Ejercicio 16 <p>Realiza el ejercicio 4 haciendo uso de la recursividad</p> Ejercicio 17 <p>Realiza el ejercicio 11 haciendo uso de la recursividad</p> Ejercicio 18 <p>Realiza el ejercicio 12 haciendo uso de la recursividad</p> Ejercicio 19 <p>Realiza el ejercicio 13 haciendo uso de la recursividad</p> Ejercicio 20 <p>Escribe una funci\u00f3n recursiva <code>sumTo(n)</code> que calcule la suma de los n\u00fameros <code>1 + 2 + ... + n</code>. Por ejemplo:</p> <pre><code>sumTo(1) = 1\nsumTo(2) = 2 + 1 = 3\nsumTo(3) = 3 + 2 + 1 = 6\nsumTo(4) = 4 + 3 + 2 + 1 = 10\n...\nsumTo(100) = 100 + 99 + ... + 2 + 1 = 5050\n</code></pre> Ejercicio 21 <p>Escribe una funci\u00f3n recursiva que dada una cadena retorne la cadena invertida. Por ejemplo, si la funci\u00f3n recibe <code>\"Hola a todos\"</code>, devuelve <code>\"sodot a aloH\"</code></p>"},{"location":"bloque_i/tema_4/page-2/","title":"2 M\u00e9todos en datos primitivos","text":""},{"location":"bloque_i/tema_4/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Javascript permite tratar a los datos primitivos como si fueran objetos, por lo que podemos hacer uso de ciertos m\u00e9todos en ellos. La diferencia entre un dato primitivo y un objeto, es que los datos primitivos almacenan un dato simple (como un n\u00famero), mientras que los objetos permiten almacenar diferentes tipos de datos.</p> <p>El gran dilema de esto es que hay cosas que se desea hacer con los datos primitivos que ser\u00eda de utilidad poder hacerlo con m\u00e9todos (al igual que con los objetos). Sin embargo, los datos primitivos deben de ser tan r\u00e1pidos y livianos como sea posible.</p> <p>La soluci\u00f3n es que los primitivos siguen siendo primitivos, pero el lenguaje permite el acceso a m\u00e9todos y propiedades de \u00e9stos. Para que esto funcione, se crea una envoltura especial (object wrapper) que provee la funcionalidad extra y luego es destruido.</p> <p>Los objetos wrappers son diferentes para cada tipo y suelen llamarse igual que el tipo primitivo pero la primera letra may\u00fascula. As\u00ed como, el object wrapper para el tipo primitivo <code>string</code> es <code>String</code>.</p>"},{"location":"bloque_i/tema_4/page-3/","title":"3 N\u00fameros","text":""},{"location":"bloque_i/tema_4/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Como hemos visto hasta ahora, en Javascript tiene dos tipos de n\u00fameros primitivos, el tipo <code>number</code> y el tipo <code>bigInt</code> para n\u00fameros m\u00e1s grandes. El object wrapper para cada uno de ellos es, <code>Number</code> y <code>BigInt</code>, respectivamente.</p> <p>Los n\u00fameros pueden ser escritos de forma seguida como <code>1000</code> o usando el car\u00e1cter <code>_</code> como separador de miles <code>1_000</code>. En la pr\u00e1ctica, no hay diferencia de escribir un n\u00famero de una forma u otra. Sin embargo, al usar <code>_</code> como separador hace que el c\u00f3digo sea m\u00e1s legible.</p> <p>Tambi\u00e9n podemos escribir la sintaxis <code>NeX</code> donde <code>N</code> es el n\u00famero y donde <code>X</code> es el n\u00famero de 0 que contiene. Tambi\u00e9n es una forma de expresar la exponentiation cient\u00edfica:</p> <pre><code>let billion = 1e9 // 1.000.000.000 \u00f3 1 x 10\u2079\nlet mcs = 1e-6 // 0.000001 \u00f3 1 x 10\u207b\u2076\n</code></pre> <p>Un n\u00famero puede ser expresado tambi\u00e9n en diferente formas seg\u00fan su base:</p> <ul> <li>Binarios. Se usa el prefijo <code>0b</code>. Por ejemplo, `0b11111111' que representa 255 en base decimal.</li> <li>Octal. Se usa el prefijo <code>0o</code>. Por ejemplo, <code>0o377</code>, que representa 255.</li> <li>Hexadecimal. Se usa el prefijo <code>0x</code>. Por ejemplo, <code>0xff</code>.</li> </ul>"},{"location":"bloque_i/tema_4/page-3/#metodo-tostring","title":"M\u00e9todo toString","text":"<p>El m\u00e9todo <code>toString([base])</code> se encarga de transformar el n\u00famero a una cadena seg\u00fan la base indica (en caso de no indicarse ninguna base, se obtiene la cadena en base decimal). La base es un n\u00famero comprendido entre 2 y 36.</p> <pre><code>const number = 3\nconsole.log(number.toString()) // \"3\"\nconsole.log(number.toString(2)) // \"11\"\n</code></pre> <p>Warning</p> <p>Cuando se utiliza un m\u00e9todo de n\u00fameros con un literal num\u00e9rico, es necesario hacer uso de doble puntuaci\u00f3n para la llamada del m\u00e9todo <code>..</code>, ya que Javascript entiende con un \u00fanico punto <code>.</code> un valor decimal.  En caso de usarlo, dar\u00eda en Syntax Error</p> <pre><code>console.log(1..toString())\n</code></pre>"},{"location":"bloque_i/tema_4/page-3/#la-clase-math","title":"La clase Math","text":"<p>La clase <code>Math</code> es una clase de utilidad (solo almacena funciones y constantes) que contiene varias funciones para poder trabajar con n\u00fameros, as\u00ed como ciertas constantes. Entre las constantes podemos encontrar:</p> <ul> <li><code>Math.PI</code>: Valor de variable pi.</li> <li><code>Math.E</code>: Valor del n\u00famero de Euler.</li> </ul> <p>Entre los m\u00e9todos m\u00e1s comunes encontramos:</p> <ul> <li><code>Math.pow(a, b)</code>. Calcula la potencia, siendo <code>a</code> la base y <code>b</code> el exponente.</li> <li><code>Math.sign(number)</code>. Comprueba si el n\u00famero indicado es positivo (devuelve <code>1</code>), negativo (devuelve <code>-1</code>) o 0 (devuelve <code>-1</code>).</li> <li><code>Math.sqrt(number)</code>. Calcula la ra\u00edz cuadrada del n\u00famero indicado.</li> <li><code>Math.abs(number)</code>. Retorna el valor absoluto de un n\u00famero.</li> <li><code>Math.sin(radians)</code>. Retorna el seno de un \u00e1ngulo expresado en radianes.</li> <li><code>Math.cos(radians)</code>. Retorna el coseno de un \u00e1ngulo expresado en radianes.</li> <li><code>Math.min(values)</code>. Retorna el valor m\u00ednimo de una serie de valores.</li> <li><code>Math.max(values)</code>. Retorna el valor m\u00e1ximo de una serie de valores.</li> </ul> <p>Info</p> <p>Descubre m\u00e1s m\u00e9todos de la clase <code>Math</code>: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math</p>"},{"location":"bloque_i/tema_4/page-3/#redondeo","title":"Redondeo","text":"<p>La clase <code>Math</code> contiene, adem\u00e1s, una serie de m\u00e9todos para poder redondear n\u00fameros.</p> <ul> <li><code>Math.floor(number)</code>. Redondea hacia abajo, por lo que el n\u00famero <code>3.1</code> se convierte en <code>3</code> y <code>-1.1</code> se convierte en <code>-2</code>.</li> <li><code>Math.ceil(number)</code>. Redondea hacia arriba, as\u00ed el n\u00famero <code>3.1</code> se convierte en <code>4</code> y <code>-1.1</code> se convierte en <code>-1</code>.</li> <li><code>Math.round(number)</code>. Redondea hacia el valor m\u00e1s cercano, de esa manera <code>3.1</code> redondea a <code>3</code> y <code>3.6</code> redondea a <code>4</code>.</li> <li><code>Math.trunc(number)</code>. Elimina la parte decimal del n\u00famero, qued\u00e1ndose con la parte entera. As\u00ed, el n\u00famero <code>3.6</code> es <code>3</code>, y <code>-1.1</code> es 1.</li> </ul> <p>Estos m\u00e9todos sirven para redondear hasta la parte entera, no sirven para redondear en posiciones decimales. Para poder redondear a una d\u00e9cima espec\u00edfica podemos seguir dos formas:</p> <ul> <li> <p>Multiplicando y dividiendo. Para redondear un n\u00famero a una d\u00e9cima <code>n</code> espec\u00edfica, se multiplica el n\u00famero por <code>1</code> seguido de tantos ceros como d\u00e9cimas se quiere redondear. Una vez redondeado, se vuelve a dividir por el mismo n\u00famero. Por ejemplo, si se desea redondear un n\u00famero decimal a dos d\u00e9cimas, se multiplicar\u00eda y dividir\u00eda por 100:</p> <pre><code>const number = 1.23456\nconst mult = number * 100 // 123.456\nconst round = Math.round(mult) // 123\nconst div = round / 100 // 1.23\nconsole.log(Math.round(number * 100) / 100) // 1.23\n</code></pre> </li> <li> <p>Haciendo uso del m\u00e9todo <code>toFixed(n)</code> del object wrapper <code>Number</code>, siendo <code>n</code> el n\u00famero de d\u00e9cimas a mostrar (si no se usa redondea a la parte entera). Es similar al m\u00e9todo <code>Math.round()</code>. El problema de este m\u00e9todo, es que no solo redondea el n\u00famero, si no que retorna dicho n\u00famero como una cadena. Por lo que habr\u00eda que usar alguna forma de conversi\u00f3n vista en el Tema 2 para poder ser usada como n\u00famero:</p> <pre><code>let num = 12.35\nconsole.log(+num.toFixed(1)) // 12.4\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_4/page-3/#comprobacion","title":"Comprobaci\u00f3n","text":"<p>El m\u00e9todo <code>isFinite</code> convierte su argumento a n\u00famero y comprueba si dicho n\u00famero es un n\u00famero regular, es decir, no es <code>Infinity</code>, ni <code>-Infinity</code>, ni <code>NaN</code>.</p> <pre><code>console.log(isFinite(\"15\")) // true\nconsole.log(isFinite(\"str\")) // false // (1)!\nconsole.log(isFinite(Infinity)) // false\n</code></pre> <ol> <li>La conversi\u00f3n de <code>str</code> a n\u00famero da como resultado <code>NaN</code>.</li> </ol> <p>El m\u00e9todo <code>isNaN</code> convierte su argumento a n\u00famero y comprueba si el resultado es <code>NaN</code>:</p> <pre><code>console.log(isNaN(NaN)) // true\nconsole.log(isNaN(\"str\")) // true\n</code></pre> <p>Warning</p> <p>El valor <code>NaN</code> es el \u00fanico que al comparar con cualquier otro valor, siempre devuelve <code>false</code>, incluy\u00e9ndose a \u00e9l mismo. Por eso, no se podr\u00eda hacer lo siguiente:</p> <pre><code>if(NaN === NaN) {} // false\n</code></pre>"},{"location":"bloque_i/tema_4/page-3/#numero-aleatorio","title":"N\u00famero aleatorio","text":"<p>La funci\u00f3n <code>Math.random()</code> retorna un n\u00famero aleatorio comprendido entre 0 y 1. Si se desea obtener un n\u00famero mayor, se recomienda multiplicar el valor por el l\u00edmite deseado. Por ejemplo, si se desea obtener un n\u00famero aleatorio entre 0 y 10, se recomienda multiplicar por 10.</p> <pre><code>console.log(Math.random())\nconsole.log(Math.random() * 2)\nconsole.log(Math.random() * 10)\nconsole.log(Math.random() * 100)\n</code></pre> <p>Estos m\u00e9todos devuelve un n\u00famero decimal, si se desea obtener un n\u00famero entero, se puede usar los m\u00e9todos de redondeo vistos en los apartados anteriores.</p> <p>En ciertas ocasiones se desea obtener un valor comprendido entre dos valores, como por ejemplo, entre 10 y 20. Para ello se puede multiplicar el n\u00famero aleatorio multiplicado por la resta entre el l\u00edmite m\u00e1ximo y m\u00ednimo a\u00f1adido a una unidad, posteriormente sum\u00e1ndole el valor m\u00ednimo al resultado. La formula quedar\u00eda as\u00ed:</p> <pre><code>Math.random() * (max - min + 1) + min\n</code></pre> <p>Incluso, se puede obviar los decimales:</p> <pre><code>Math.floor(Math.random() * (max - min + 1) +  min)\n</code></pre> <p>Veamos un ejemplo:</p> <pre><code>const randomNumberBetween10And20 = Math.floor(Math.random() * 11 + 10) // 20 - 10 + 1\n</code></pre>"},{"location":"bloque_i/tema_4/page-3/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Crea un programa Javascript que solicite varios n\u00fameros, hasta que cancele la petici\u00f3n. Luego muestra, el n\u00famero m\u00e1s peque\u00f1o y el n\u00famero m\u00e1s grande. Crea dos versiones, una sin usar los m\u00e9todos <code>Math.min</code> y <code>Math.max</code> creando tus propios m\u00e9todos, y otra haciendo uso de dichas funciones. Compara los resultados</p> Ejercicio 2 <p>Crea un programa Javascript que solicite al usuario una figura entre las siguientes: Cuadrado, Tri\u00e1ngulo, Rect\u00e1ngulo, C\u00edrculo. Al elegir una de ellas, se le solicitar\u00e1, adem\u00e1s, los datos necesarios para calcular el \u00e1rea de la figura deseada. Muestra en una alerta, el \u00e1rea redondeada en dos decimales. Si el usuario introduce una figura no v\u00e1lida, se le volver\u00e1 a solicitar hasta que introduzca una figura v\u00e1lida. Adem\u00e1s, realiza las comprobaciones pertinentes.</p> <p>Para estos ejercicios se va a crear un fichero llamado <code>numbers.js</code>. En ellos, se va a crear las diferentes funciones indicadas a continuaci\u00f3n. Posteriormente, se va a crear otro script para realizar las pruebas pertinentes a mano alzada.</p> Method 1 <p>Crea una funci\u00f3n que que dado dos par\u00e1metros, devuelva un n\u00famero aleatorio entre ambos.</p> Method 2 <p>Crea una funci\u00f3n que reciba un n\u00famero y devuelva el n\u00famero redondeado con el n\u00famero de d\u00e9cimas indicada. Si recibe un cero, redondea a la parte entera. El m\u00e9todo puede no recibir ning\u00fan par\u00e1metro, en dicho caso el valor del n\u00famero ha recibir ser\u00eda 0.</p> Method 3 <p>Crea una funci\u00f3n que reciba un n\u00famero y devuelva el n\u00famero truncado con el n\u00famero de d\u00e9cimas indicada. Si recibe un cero, trunca a la parte entera. El m\u00e9todo puede no recibir ning\u00fan par\u00e1metro, en dicho caso el valor del n\u00famero ha recibir ser\u00eda 0.</p> Method 4 <p>\u00bfSab\u00edas que un ra\u00edz cuadrada se puede expresar como una potencia? Por ejemplo, la ra\u00edz cuadrada de 4, se puede expresar como 4\u00bd. Al igual que la ra\u00edz cuadrada, cualquier ra\u00edz puede ser expresada como potencia, de esta forma, la ra\u00edz cuarta de 16, se puede expresar como 16\u00bc. Sabiendo esto, crea un m\u00e9todo que reciba dos n\u00fameros, la base y el tipo de ra\u00edz a calcular, y haz que devuelva la ra\u00edz en\u00e9sima a calcular.</p>"},{"location":"bloque_i/tema_4/page-4/","title":"4 Cadenas","text":""},{"location":"bloque_i/tema_4/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos visto en el tema 2 una cadena es un conjunto de caracteres que se pueden formar de tres maneras:</p> <ul> <li>Comillas simples.</li> <li>Comillas dobles.</li> <li>Comillas invertidas (backticks)</li> </ul> <p>Adem\u00e1s, las comillas invertidas nos permit\u00edan evaluar expresiones haciendo uso de la estructura <code>${}</code>:</p> <pre><code>console.log(`El resultado de 2 + 2 es ${2 + 2}`)\n</code></pre> <p>Otra de las ventajas que tiene este tipo de comillas, es que te permite crear cadenas de multiple l\u00edneas, cosa que con el otro tipo de cadenas se debe usar el car\u00e1cter <code>\\n</code>:</p> <pre><code>const stringMultiline = `Esto es un cadena\nmulti l\u00ednea`\nconst stringError = \"Esto no es una cadena multi l\u00ednea \ny adem\u00e1s da error\"\nconst string = \"Esto es una cadena multi l\u00ednea\\nsin errores usando el car\u00e1cter \\\\n\"  </code></pre>"},{"location":"bloque_i/tema_4/page-4/#caracteres-especiales","title":"Caracteres especiales","text":"<p>Existe una serie de caracteres especiales que al escribirlas en una cadena, mostrar\u00e1 algo diferente entre ellas, podemos encontrar:</p> Car\u00e1cter Descripci\u00f3n <code>\\n</code> Salto de l\u00ednea <code>\\r</code> En Windows, los archivos de texto usan una combinaci\u00f3n de dos caracteres \\r\\n para representar un corte de l\u00ednea, mientras que en otros SO es simplemente '\\n'. Esto es por razones hist\u00f3ricas, la mayor\u00eda del software para Windows tambi\u00e9n reconoce '\\n'. <code>\\'</code> <code>\\\"</code> <code>\\`</code> Comillas <code>\\\\</code> Barra invertida <code>\\t</code> Tabulaci\u00f3n <code>\\b</code>, <code>\\f</code>, <code>\\v</code> Retroceso, avance de formulario, tabulaci\u00f3n vertical \u2013 Se mencionan para ser exhaustivos. Vienen de muy viejos tiempos y no se usan actualmente. <p>Veamos un ejemplo:</p> <pre><code>console.log(\"Esto es una cadena que usa:\\n\\t- Comillas simples: \\'\\n\\t- Comillas dobles:\\\"\\n\\t- Comillas invertidas: \\`\\n\\t- Barra invertida:\\\\\") //(1)!\n</code></pre> <ol> <li>SALIDA:Esto es una cadena que usa:    - Comillas simples: '    - Comillas dobles: \"    - Comillas invertidas: `    - Barra invertida: \\ */</li> </ol> <p>Si se desea usar la forma literal de algunos de estos caracteres ser\u00e1 necesario hacer uso de un doble uso de la barra invertida <code>\\\\</code>. Veamos un ejemplo:</p> <pre><code>console.log(`\nEn Javascript, para hacer un salto de l\u00ednea es necesario usar \\\\n. Mientras que,\npara hacer una tabulaci\u00f3n es necesario hacer uso del \\\\t, al igual que con las comillas (\\\\' \\\\\")\n`)\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#tamano-de-string","title":"Tama\u00f1o de string","text":"<p>El tipo <code>string</code> tiene diferentes m\u00e9todos y propiedades que nos permite tratar con las cadenas de una forma m\u00e1s sencilla. Entre ellas, encontramos la propiedad <code>length</code> que permite obtener el tama\u00f1o de la cadena.</p> <pre><code>const string = 'Hello world'\nconst stringLength = string.length // 11\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#acceder-a-caracteres","title":"Acceder a caracteres","text":"<p>Para poder acceder a una car\u00e1cter espec\u00edfico de una cadena, es necesario conocer su posici\u00f3n. Debemos tener en cuenta, que la posici\u00f3n dentro de la cadena de caracteres empieza en 0, por lo que el primer car\u00e1cter tendr\u00e1 una posici\u00f3n 0. Al ser la primera posici\u00f3n 0, la \u00faltima posici\u00f3n ser\u00e1 un valor inferior al tama\u00f1o de la cadena <code>str.length - 1</code>.</p> <p>Para acceder a un car\u00e1cter de una cadena conociendo su posici\u00f3n, podemos usar corchetes <code>[pos]</code> o el m\u00e9todo <code>at(pos)</code>:</p> <pre><code>const string = \"Hello World\"\nconsole.log(string[0]) //H\nconsole.log(string[string.length - 1]) // d\nconsole.log(string[2]) // l\nconsole.log(string[11]) // undefined\nconsole.log(string[12]) // undefined\n</code></pre> <p>Una de las gran diferencias al usar corchetes o el m\u00e9todo <code>at</code>, es que si a los corchetes se le indica un n\u00famero negativo, siempre devuelve un <code>undefined</code>. Por el contrario, el m\u00e9todo <code>at()</code> con una posici\u00f3n negativa devuelve el car\u00e1cter empezando a leer la cadena a la inversa:</p> <pre><code>console.log(string[-1]) // undefined\nconsole.log(string.at(-1)) // d\nconsole.log(string.at(-11)) //H\nconsole.log(string.at(-12)) // undefined\n</code></pre> <p>String inmutables</p> <p>Las cadenas son INMUTABLES por lo que no se puede reasignar un nuevo valor a sus caracteres. Para cambiar el valor de un car\u00e1cter, ser\u00e1 necesario crear una nueva cadena.</p> <pre><code>const string = \"Hello World\"\nstring[0] = 'A' // \u274c\u274cERROR\nconst newString =  'A' + string[1] + string[2] + string[3] //... \n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#capitalizacion","title":"Capitalizaci\u00f3n","text":"<p>Los m\u00e9todos para trabajar con la capitalizaci\u00f3n de cadenas son:</p> <ul> <li><code>toLowerCase()</code>: Transforma la cadena en min\u00fasculas.</li> <li><code>toUpperCase()</code>: Transforma la cadena en may\u00fasculas.</li> </ul> <pre><code>const string = \"Hello World\"\nconsole.log(string.toUpperCase()) // HELLO WORLD\nconsole.log(string.toLowerCase()) // hello world\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#localizar-caracteres-en-cadenas","title":"Localizar caracteres en cadenas","text":"<p>Existen diversos m\u00e9todos para poder comprobar y localizar caracteres dentro de una cadena, como <code>indexOf</code>, <code>lastIndexOf</code>, <code>includes</code>, <code>startsWith</code>, <code>endsWith</code>.</p>"},{"location":"bloque_i/tema_4/page-4/#indexof","title":"indexOf","text":"<p>El m\u00e9todo <code>indexOf(c)</code> comprueba si el car\u00e1cter <code>c</code> se encuentra en la cadena y retorna la primera posici\u00f3n en la que se encuentra. Por el contrario, retornar\u00e1 <code>-1</code>, si el car\u00e1cter no se encuentra en la cadena. Veamos un ejemplo:</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.indexOf('e')) // 1\n</code></pre> <p>En caso de haber m\u00e1s de una coincidencia, retornar\u00e1 el valor de la primera coincidencia, ya que empieza a realizar la b\u00fasqueda desde el primer car\u00e1cter.</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.indexOf('o')) // 4\n</code></pre> <p>El m\u00e9todo <code>indexOf(c, [i])</code>, puede recibir un segundo par\u00e1metro que indica a partir de que posici\u00f3n buscar el car\u00e1cter. De esta manera, podemos localizar la siguientes referencias de un car\u00e1cter:</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.indexOf('o', 5)) // 7\n</code></pre> <p>Tambi\u00e9n podemos localizar una subcadena dentro de la cadena, retornando la primera posici\u00f3n del primer car\u00e1cter de la misma:</p> <pre><code>const string = \"This is a large string\"\nconsole.log(string.indexOf(\"string\")) // 16\n</code></pre> <p>En el ejemplo anterior, retornar\u00e1 <code>16</code> porque la subcadena string comienza en el car\u00e1cter 16 de la cadena principal. De esta manera podemos hacer comprobaciones de si una cadena contiene una subcadena:</p> <pre><code>const string = \"This is a large string\"\nif(string.indexOf(\"This\") &gt; -1){\nconsole.log(`La cadena ${string} contiene la cadena \"this\"`)\n}\n</code></pre> <p>\u00a1OJO!</p> <p>En el ejemplo anterior hay que tener mucho cuidado, si hacemos la comprobaci\u00f3n si la comparaci\u00f3n, ya que si el m\u00e9todo retorna <code>0</code>, quiere decir que la cadena si existe, pero al usarlo en el condicional se convertir\u00e1 a booleano (recuerda que 0 en booleano es <code>false</code>) por lo que no entrar\u00eda en el bloque <code>if</code>. Por el contrario, si no encuentra la cadena, el m\u00e9todo retorna un <code>-1</code>, que al pasarlo a booleano es <code>true</code>, por lo que si ejecutar\u00eda el bloque <code>if</code>:</p> <pre><code>const string = \"This is a large string\"\nif(string.indexOf(\"This\")){\nconsole.log(`La cadena ${string} contiene la cadena \"this\"`)\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#lastindexof","title":"lastIndexOf","text":"<p>El m\u00e9todo <code>lastIndexOf(c, [pos])</code> es un m\u00e9todo bastante similar a <code>indexOf</code>, con la diferencia de que en este caso, la b\u00fasqueda comienza a hacerla desde el final de la cadena, por lo que retorna el \u00faltimo valor que parece en la cadena. Veamos un ejemplo:</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.lastIndexOf(\"o\")) // 7\nconsole.log(string.lastIndexOf(\"o\", 5)) // 4\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#includes","title":"includes","text":"<p>El m\u00e9todo <code>includes(c)</code> retornar\u00e1 <code>true</code> si <code>c</code> se encuentra en la cadena. Por el contrario retornar\u00e1 <code>false</code>. Puede recibir un segundo argumento para indicar desde que posici\u00f3n realizar la comprobaci\u00f3n.</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.includes(\"Hello\")) // true\nconsole.log(string.includes(\"no\")) // false\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#startswith","title":"startsWith","text":"<p>El m\u00e9todo <code>startsWith(c)</code> comprueba si la cadena empieza con los caracteres indicados. Retorna <code>true</code> si comienza con dicho car\u00e1cter (o caracteres) y <code>false</code> al contrario.</p> <pre><code>console.log('Hello world'.startsWith('Hello')) // true\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#endswith","title":"endsWith","text":"<p>El m\u00e9todo <code>endsWith(c)</code> comprueba si la cadena termina con los caracteres indicados. Retorna <code>true</code> si termina con dicho car\u00e1cter (o caracteres) y <code>false</code> al contrario.</p> <pre><code>console.log('Hello world'.endsWith('world')) // true\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#obtener-subcadenas","title":"Obtener subcadenas","text":"<p>El tipo <code>string</code> nos ofrece varios m\u00e9todos para obtener una subcadena dada una cadena: <code>substring</code>, <code>substr</code> y <code>slice</code>.</p>"},{"location":"bloque_i/tema_4/page-4/#slice","title":"slice","text":"<p>El m\u00e9todo <code>slice(start, [end])</code> retorna una subcadena desde la posici\u00f3n indicado (<code>start</code>) hasta la posici\u00f3n final (<code>end</code>) (no incluido). Si no se indica posici\u00f3n final, recortar\u00e1 hasta el final de la cadena.</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.slice(0, 5)) // Hello\nconsole.log(string.slice(6)) // world\n</code></pre> <p>Se pueden usar valores negativos, para comenzar a cortar desde el final.:</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.slice(-11, -5)) // Hello\n</code></pre> <p>Si se intercambian las posiciones, es decir, si se indica primero la posici\u00f3n mayor que la posici\u00f3n menor, el m\u00e9todo <code>slice</code> retorna una cadena vac\u00eda.</p> <pre><code>console.log(\"Hello world\".slice(2, 1)) // \"\"\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#substring","title":"substring","text":"<p>El m\u00e9todo <code>substring(start, [end])</code> es bastante similar al m\u00e9todo <code>slice</code>, pero en este caso, si se usa una posici\u00f3n mayor y luego una menor, este m\u00e9todo lo intercambiar\u00e1. Sin embargo, no se pueden usar argumentos negativos, ya que son tratados como 0.</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.substring(0, 5)) // Hello\nconsole.log(string.substring(6)) // world\nconsole.log(string.substring(-10, -5)) // \"\"\nconsole.log(string.substring(-10, 5)) // Hello (similar a (0, 5))\nconsole.log(string.substring(2, 1)) // e\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#substr","title":"substr","text":"<p>El m\u00e9todo <code>substr(start, [length])</code> recorta una cadena desde la posici\u00f3n inicial indicada, tantos caracteres como indica el segundo argumento (<code>length</code>), a diferente de los otros m\u00e9todos que se indicaba la posici\u00f3n final. El argumento del tama\u00f1o, no puede ser negativo</p> <pre><code>const string = \"Hello world\"\nconsole.log(string.substr(3, 5)) // lo wo\nconsole.log(string.substr(0, 5)) // Hello\nconsole.log(string.substr(6)) // world\nconsole.log(string.substr(-10, -5)) // \"\"\nconsole.log(string.substr(-10, 5)) // ello\nconsole.log(string.substr(2, 1)) //  l \n</code></pre> <p>Warning</p> <p>Este m\u00e9todo ha sido indicado como <code>deprecated</code> en las versiones recientes de Javascript, por lo que no se recomienda su uso.</p>"},{"location":"bloque_i/tema_4/page-4/#comparacion","title":"Comparaci\u00f3n","text":"<p>Para poder comparar cadenas en Javascript se realiza la comparaci\u00f3n, car\u00e1cter a car\u00e1cter. Cada car\u00e1cter tiene un representaci\u00f3n de codificaci\u00f3n (en Javascript las cadenas est\u00e1n representadas por la codificaci\u00f3n <code>UTF-16</code>), por lo que para comparar los caracteres, ser\u00e1 mayor el que mayor codificaci\u00f3n tenga. Veamos un ejemplo:</p> <pre><code>console.log('a' &gt; 'Z') // tur\n</code></pre> <p>A pesar, de que la <code>a</code> aparezca antes en el abecedario, su codificaci\u00f3n corresponde a 97, mientras que la <code>Z</code> a la 90, por lo que ciertamente <code>a</code> es mayor que <code>Z</code>. Lo mismo puede ocurrir con los acentos.</p> <p>Con el m\u00e9todo <code>codePointAt(pos)</code> retorna el valor codificado del car\u00e1cter posicionado en la cadena. Si no se indica posici\u00f3n, retornar\u00e1 el valor codificado del primer car\u00e1cter:</p> <pre><code>console.log('a'.codePointAt(0)) // 97\nconsole.log('Z'.codePointAt()) // 90\nconsole.log('Hello World'.codePointAt(5)) // 32\n</code></pre> <p>Por el contrario, podemos obtener el car\u00e1cter que representa un c\u00f3digo a trav\u00e9s del m\u00e9todo est\u00e1tico <code>String.fromCodePoint(code)</code>:</p> <pre><code>console.log(String.fromCodePoint(97)) // a\n</code></pre> <p>El algoritmo correcto para realizar comparaciones de strings es m\u00e1s complejo de lo que parece, debido a que los alfabetos son diferentes para diferentes lenguajes. Una letra que se ve igual en dos alfabetos distintos, pueden tener distintas posiciones. Para ello existe el m\u00e9todo <code>localeCompare(string, [locales, options])</code> que permite comparar cadenas teniendo en cuenta el alfabeto del idioma especificado. Sus argumentos son:</p> <ul> <li><code>string</code>. Cadena para comparar.</li> <li><code>locales</code>. Idioma al comparar. En caso de ser especificado, obtiene el idioma del entorno.</li> <li><code>options</code>. Un objeto con las configuraciones previas, como la sensibilidad a la may\u00fasculas.</li> </ul> <p>El m\u00e9todo, adem\u00e1s, retornar\u00e1:</p> <ul> <li><code>1</code> si la primera cadena es mayor que la segunda.</li> <li><code>-1</code> si la segunda cadena es mayor que la primera.</li> <li><code>0</code> si ambas son iguales.</li> </ul> <pre><code>console.log(\"Hola mundo\".localeCompare(\"Hello world\", \"es\")) // 1\n</code></pre>"},{"location":"bloque_i/tema_4/page-4/#ejercicios","title":"Ejercicios","text":"<p>Para estos ejercicios se va a crear un fichero llamado strings.js. En ellos, se va a crear las diferentes funciones indicadas a continuaci\u00f3n. Posteriormente, se va a crear otro script para realizar las pruebas pertinentes a mano alzada.</p> Method 1 <p>Crea un m\u00e9todo llamado <code>capitalize(string, [onlyFirst = true])</code>, que transforme la cadena obtenida como argumento a capitalizada. Una cadena es capitalizada, indicando la primera palabra en may\u00fasculas. Por ejemplo: <code>'Hello world'</code>. Recibir\u00e1 un segundo argumento booleano para comprobar si se hace una capitalizaci\u00f3n en cada palabra. Por ejemplo, <code>Hello World</code>. En caso de no recibir este par\u00e1metro solo capitalizar\u00e1 la primera letra.</p> Method 2 <p>Crea una funci\u00f3n <code>truncate(str, maxlength, [ellipsis = '...'])</code> que verifique la longitud de <code>str</code> y, si excede <code>maxlength</code>  reemplaza el final de <code>str</code> con el car\u00e1cter indicado como tercer argumento que por defecto ser\u00e1 puntos suspensivos, para hacer su longitud igual a <code>maxlength</code>.</p> <pre><code>truncate(\"Lo que me gustar\u00eda contar sobre este tema es:\", 20) //\"Lo que me gustar\u00eda c\u2026\"\ntruncate(\"Hola a todos!\", 20) // \"Hola a todos!\"\n</code></pre> Method 3 <p>Crea una funci\u00f3n <code>jump(string, maxLength)</code> que inserte saltos de l\u00ednea cada vez que la cadena llegue a <code>maxLength</code>.</p> <pre><code>jump(\"hola mundo esto es una cadena super larga con muchos saltos de l\u00ednea\", 5)\n/*\nhola \nmundo\n esto\nes un\na cad\nena s\nuper \nlarga\n con \nmucho\nsalto\ns de \nl\u00ednea\n*/\n</code></pre> Method 4 <p>Crea dos funciones, <code>isEmpty(string)</code> e <code>isNotEmpty(string)</code>, que compruebe si <code>string</code> es una cadena vac\u00eda o no, respectivamente.</p> Method 5 <p>Crea dos funciones, <code>isBlank(string)</code> e <code>isNotBlank(string)</code> que comprueba si <code>string</code> es una cadena vac\u00eda o con espacios en blanco; o no, respectivamente.</p> Method 6 <p>Realiza un m\u00e9todo <code>isPalindrome(string)</code> que comprueba si la cadena <code>string</code> es pal\u00edndroma, es decir, se puede leer de igual forma de izquierda a derecha que derecha a izquierda (sin tener en cuenta los espacios ni las comas o puntos.).</p>"},{"location":"bloque_i/tema_4/page-5/","title":"5 Expresiones de una funci\u00f3n","text":""},{"location":"bloque_i/tema_4/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>En muchos lenguajes de programaci\u00f3n, como Java, una funci\u00f3n no es m\u00e1s que es una estructura de c\u00f3digo reutilizable. Sin embargo, en Javascript las funciones son m\u00e1s que estructuras, son consideradas como un tipo de dato especial, al igual que los n\u00fameros o las cadenas.</p> <p>Por lo que, al igual que las cadenas o los n\u00fameros, podemos declarar una funci\u00f3n como si fuese una variable o una constante:</p> <pre><code>const sayHi = function(){\nconsole.log('hi')\n}\n</code></pre> <p>La sintaxis <code>function(){}</code> se denomina funci\u00f3n an\u00f3nima, es decir, se crea una funci\u00f3n sin nombre que luego se le asigna a una variable. Para llamar dicha funci\u00f3n, se usa el nombre de la variable a la que le ha sido asignada:</p> <pre><code>sayHi()\n</code></pre>"},{"location":"bloque_i/tema_4/page-5/#funcion-como-valor","title":"Funci\u00f3n como valor","text":"<p>En Javascript una funci\u00f3n puede funcionar como un valor. Si mostramos por consola una funci\u00f3n (sin realizar su llamada), mostrar\u00e1 el contenido de la funci\u00f3n:</p> <pre><code>const sayHi = function(){\nconsole.log('Hi')\n}\nconsole.log(sayHi)\n</code></pre> <p>Al usar una funci\u00f3n como valor, podemos reutilizarla en varias variables, de esta manera:</p> <pre><code>function myFunction(){ //(1)!\nconsole.log(\"Hi\") }\nconst sayHi = myFunction //(2)!\nmyFunction() //(3)!\nsayHi() //(4)!\n</code></pre> <ol> <li>Se crea una funci\u00f3n</li> <li>Se copia el valor de la funci\u00f3n <code>myFunction</code> en <code>sayHi</code></li> <li>Se ejecuta <code>myFunction</code></li> <li>Se ejecuta <code>sayHi</code></li> </ol>"},{"location":"bloque_i/tema_4/page-5/#callback","title":"Callback","text":"<p>En JavaScript, un callback es una funci\u00f3n que se pasa como argumento a otra funci\u00f3n y que se ejecuta despu\u00e9s de que ocurra alg\u00fan evento o proceso as\u00edncrono. Los callbacks son una forma fundamental de manejar la asincron\u00eda en JavaScript, ya que JavaScript es un lenguaje de programaci\u00f3n de un solo hilo que utiliza eventos y callbacks para manejar tareas as\u00edncronas.</p> <p>Supongamos que queremos crear una funci\u00f3n que realice una pregunta de S\u00ed/No. Si la respuesta es S\u00ed ejecutar\u00e1 una funci\u00f3n, y si la respuesta es No ejecutar\u00e1 otra. Esta funci\u00f3n puede ser m\u00e1s flexible si se le pasase que hacer en cada uno de los dos casos, y esto es posible gracias a los callbacks. Veamos un ejemplo:</p> <pre><code>function ask(question, yes, ok){\nif(confirm(question)){\nyes()\n} else {\nno()\n}\n}\nfunction ok(){\nconsole.log('Est\u00e1s de acuerdo')\n}\nfunction cancel(){\nconsole.log('Cancelaste')\n}\nask(\"\u00bfEst\u00e1s de acuerdo?\", ok, cancel)\n</code></pre> <p>En el ejemplo anterior, le pasamos al m\u00e9todo <code>ask</code> los valores de las funciones <code>ok</code> y <code>cancel</code> para que sean ejecutadas. De esta forma, la funci\u00f3n <code>ask</code> es una funci\u00f3n flexible a cualquier acci\u00f3n en caso de confirmar o cancelar la petici\u00f3n del m\u00e9todo <code>confirm</code>.</p>"},{"location":"bloque_i/tema_4/page-5/#crear-funciones-de-forma-dinamica","title":"Crear funciones de forma din\u00e1mica","text":"<p>Una funci\u00f3n al ser tratada como un valor, puede ser creada din\u00e1micamente de forma que pueda realizar una operaci\u00f3n u otra. Supongamos que dependiendo de la edad del usuario vamos a realizar un c\u00e1lculo u otro, en esa se estar\u00eda creando una funci\u00f3n de forma din\u00e1mica. Veamos un ejemplo:</p> <pre><code>const age = 18\nconst func = age &gt; 18 ? function() {\n// Code\nconsole.log('Eres mayor de edad')\n}\n: function() {\n// code\nconsole.log('Eres menor de edad')\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-5/#ejercicios","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza un m\u00e9todo que reciba un n\u00famero y una funci\u00f3n que solo ser\u00e1 ejecuta si el n\u00famero indicado es par. </p>"},{"location":"bloque_i/tema_4/page-6/","title":"6 Funciones Flecha","text":""},{"location":"bloque_i/tema_4/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Las funciones flecha en JavaScript son una caracter\u00edstica introducida en ECMAScript 6 (tambi\u00e9n conocido como ES6 o ES2015) que proporciona una sintaxis m\u00e1s concisa y clara para definir funciones. La sintaxis de una funci\u00f3n flecha se parece a una flecha <code>=&gt;</code>, de ah\u00ed su nombre.</p>"},{"location":"bloque_i/tema_4/page-6/#expresion-de-una-funcion-flecha","title":"Expresi\u00f3n de una funci\u00f3n flecha","text":"<p>Una funci\u00f3n flecha, no es m\u00e1s que una funci\u00f3n an\u00f3nima que puede ser introducida en una variable. Por lo que si la expresi\u00f3n de una funci\u00f3n an\u00f3nima es:</p> <pre><code>const func = function(args){\n// code\nreturn value\n}\n</code></pre> <p>La funci\u00f3n flecha es muy parecida, pero m\u00e1s compacta. En primer lugar, no es necesario usar la palabra <code>function</code> y se usa una flecha (<code>=&gt;</code>) entre la declaraci\u00f3n de los par\u00e1metros y el bloque:</p> <pre><code>const func = (args) =&gt; {\n// code\nreturn value\n}\n</code></pre> <p>Veamos un ejemplo para realizar la suma de dos n\u00fameros:</p> <pre><code>const suma = (a, b) =&gt; {\nreturn a + b\n}\n</code></pre> <p>Cuando el cuerpo (bloque) de una funci\u00f3n flecha solo tiene una l\u00ednea y est\u00e1 es una expresi\u00f3n de retorno, la funci\u00f3n de flecha se puede omitir las llaves <code>{}</code> y la palabra <code>return</code>:</p> <pre><code>const func = () =&gt; value\n</code></pre> <p>De esta manera, el ejemplo anterior se podr\u00eda simplificar de la siguiente forma:</p> <pre><code>const suma (a, b) =&gt; a + b\n</code></pre> <p>De la misma manera, si una funci\u00f3n flecha solo recibe un argumento, tambi\u00e9n puede obviar los par\u00e9ntesis:</p> <pre><code>const func = onlyParam =&gt; {\n// code\nreturn something\n}\n</code></pre> <p>Por ejemplo, si tenemos un m\u00e9todo que recibe un n\u00famero para calcular si es primo o no:</p> <pre><code>const prime = number =&gt; {\nfor(let i = 2; &lt; i &lt; number; i++){\nif(number % i === 0) return false\n}\nreturn true\n}\n</code></pre> <p>Por el contrario, si no recibe ning\u00fan par\u00e1metro, si es obligatorio el uso de par\u00e9ntesis:</p> <pre><code>const sayHi = () =&gt; {\nconsole.log('Hi!')\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-6/#funciones-flechas-dinamicas","title":"Funciones flechas din\u00e1micas","text":"<p>Al igual que las funciones an\u00f3nimas, se puede pasar una funci\u00f3n flecha como valor de una variable de forma din\u00e1mica:</p> <pre><code>const age = 18\nconst func = age &gt; 18 ? () =&gt; {\n// Code\nconsole.log('Eres mayor de edad')\n}\n: () =&gt; {\n// code\nconsole.log('Eres menor de edad')\n}\n</code></pre>"},{"location":"bloque_i/tema_4/page-6/#funciones-flechas-como-callbacks","title":"Funciones flechas como callbacks","text":"<p>Las funciones flechas pueden ser usadas como argumentos en otras funciones que reciban un callback:</p> <pre><code>function connectServer(callback){\nconsole.log('creating server...')\nconst server = 'Server'\nconst success = Math.rand() * 10\nif(success !== 1){\nconsole.log('Error to connecting Server ' + server)\nreturn\n}\ncallback()\n}\nconnectServer(() =&gt; {\nconsole.log('Connected server successfully')\n})\n</code></pre> <p>Existe una sintaxis especial, que ocurre cuando el n\u00famero y tipo de par\u00e1metros necesarios por el callback y por la funci\u00f3n flecha sean los mismo, se puede omitir la estructura compacta y usar solo el nombre de la variable que referencia la funci\u00f3n flecha:</p> <pre><code>function connectServer(callback){\nconsole.log('creating server...')\nconst server = 'Server'\nconst success = Math.rand() * 10\nif(success !== 1){\nconsole.log('Error to connecting Server ' + server)\nreturn\n}\ncallback()\n}\nconst callback = () =&gt; {\nconsole.log('Connected server successfully')\n}\nconnectServer(callback)\n</code></pre>"},{"location":"bloque_i/tema_4/page-6/#ejercicios","title":"Ejercicios","text":"<p>Realiza todos los ejercicios realizados hasta ahora con funciones de flechas. Las funciones realizadas en el fichero <code>numbers.js</code> y <code>strings.js</code> no ser\u00e1n reemplazadas, si no que usando Git se crear\u00e1 una nueva versi\u00f3n del proyecto.</p>"},{"location":"bloque_i/tema_5/page-1/","title":"1 Introducci\u00f3n a los objetos","text":""},{"location":"bloque_i/tema_5/page-1/#colecciones","title":"Colecciones","text":"<p>Hasta ahora, hemos visto diferentes tipos de datos en Javascript, como <code>string</code>, <code>number</code>, <code>boolean</code>, etc. En ciertas ocasiones podemos agrupar varios datos en una \u00fanica variable. Esta agrupaci\u00f3n es lo que se conoce como colecci\u00f3n.</p> <p>Existen diferentes tipos de colecciones que veremos entre este tema y el siguiente. Uno de ellos son los objetos.</p> <p>Los objetos son un tipo de colecci\u00f3n en la cual se agrupan diferentes tipos de datos haciendo uso de par de clave-valor. La clave identifica la propiedad del objeto y debe ser \u00fanica e irrepetible, adem\u00e1s debe ser de tipo <code>string</code>. Por otro lado, el valor es el dato que se almacena, puede ser de cualquier tipo, y no tiene por que ser \u00fanico.</p> <p>Las propiedad clave-valor de un objeto va en vuelto entre llaves:</p> <pre><code>const obj = {\nkey1: value1,\nkey2: value2,\n//...\nkeyN: valueN\n}\n</code></pre> <p>Un objeto vac\u00edo es un objeto que no tiene ninguna propiedad:</p> <pre><code>const obj = {}\n</code></pre>"},{"location":"bloque_i/tema_5/page-1/#propiedades-de-un-objeto","title":"Propiedades de un objeto","text":"<p>Una propiedad es un dato almacenado en el objeto, suele ser un par clave-valor, donde la clave es la identificaci\u00f3n de la propiedad. La sintaxis para indicar una propiedad es la siguiente: <code>key:value</code>.</p> <p>Para acceder a una propiedad, se usa el operador <code>.</code> sobre el objeto, seguido del nombre de la propiedad:</p> <pre><code>const obj = {\nname: \"John\",\nage: 16\n}\nconsole.log(obj.name)\n</code></pre> <p>Podemos cambiar el valor de una propiedad, de la siguiente forma: <code>obj.property = newValue</code>. Si la propiedad no existe en el objeto, se crea la propiedad en el objeto con el valor indicado.</p> <pre><code>const obj = {\nname = \"John\"\nage: 16\n}\nobj.age = 17\nobj.isAdmin = true\nconsole.log(obj) // {name: \"John\", age: 17, isAdmin: true}\n</code></pre> <p>Para eliminar una propiedad se usa la palabra reservada <code>delete</code> seguida de la propiedad a usar:</p> <pre><code>const obj = {\nname = \"John\"\nage: 16\n}\ndelete obj.age\nconsole.log(obj) // {name: \"John\"}\n</code></pre> <p>El nombre de las claves de las propiedades de un objeto, son siempre strings, por lo que no es obligatorio hacer uso de comillas para especificarlas. Sin embargo, si se desea indicar un nombre de clave son espacios, y m\u00e1s de una palabra, su uso se vuelve obligatorio:</p> <pre><code>const obj = { name: \"John\",\nage: 17,\n\"is admin\": false\n}\n</code></pre> <p>No se puede acceder a una propiedad de estas caracter\u00edsticas de la forma com\u00fan. Tambi\u00e9n se puede acceder a una propiedad haciendo uso de corchetes <code>obj[key]</code>. Este m\u00e9todo es el obligatorio para acceder a las propiedades que contienen espacios:</p> <pre><code>const obj = { name: \"John\",\nage: 17,\n\"is admin\": false\n}\nconsole.log(obj[\"name\"], obj[\"is admin\"])\n</code></pre> <p>Los corchetes tambi\u00e9n se usa para crear/modificar una propiedad:</p> <pre><code>const key = \"new key\"\nobj[key] = \"hola\"\nconsole.log(obj) // {\"new key\": \"hola\"}\n</code></pre> <p>Otro de los usos de los corchetes, es cuando la key es desconocida en momento de ejecuci\u00f3n, por ejemplo, cuando el usuario debe introducirla:</p> <pre><code>const obj = {\nname: \"John\",\nage: 17\n}\nconst key = prompt(\"\u00bfQu\u00e9 dato quieres saber ahora?\", \"name\")\nconsole.log(obj[key])\n</code></pre> <p>Los corchetes son mucho m\u00e1s potentes que la notaci\u00f3n de punto. Permiten cualquier nombre de propiedad, incluso variables. Pero tambi\u00e9n es m\u00e1s engorroso escribirlos.</p> <p>Entonces, la mayor\u00eda de las veces, cuando los nombres de propiedad son conocidos y simples, se utiliza el punto. Y si necesitamos algo m\u00e1s complejo, entonces cambiamos a corchetes.</p> <p>Warning</p> <p>El nombre de las propiedades, al diferencia de las variables, pueden ser palabras reservadas del lenguaje, como <code>for</code>, <code>if</code>, <code>let</code>, etc.</p> <pre><code>const obj = {\nfor: 1,\nlet: 2,\nif: 30\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-1/#atajo-de-propiedades","title":"Atajo de propiedades","text":"<p>Supongamos que tenemos dos variables, <code>name</code> y <code>age</code>, que contienen el nombre y edad de una persona. Dichas variables van a ser a\u00f1adidas a un objeto, cuya propiedades tienen el mismo nombre de las variables, <code>name</code> y <code>age</code>:</p> <pre><code>const name = \"John\"\nconst age = 17\nconst person = {\nname: name,\nage: age\n}\n</code></pre> <p>Cuando sucede algo as\u00ed, donde  la propiedad y la variable que contiene el valor, tienen el mismo nombre, se puede omitir y escribirlo una \u00fanica vez, siendo una declaraci\u00f3n equivalente:</p> <pre><code>const name = \"John\"\nconst age = 17\nconst person = {\nname, // equivalente a name: name\nage // equivalente a age: age\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-1/#operador-in","title":"Operador in","text":"<p>El operador <code>in</code> es un operador binario que comprueba si el primer operando es una propiedad que pertenece al segundo operando, que debe ser un objeto. Retorna un valor booleano, <code>true</code> si la propiedad existe en el objeto, <code>false</code> si no existe:</p> <pre><code>const obj = {\nname: \"John\",\nage: 17\n}\nconsole.log(\"age\" in obj) // true\n</code></pre>"},{"location":"bloque_i/tema_5/page-1/#bucle-forin","title":"Bucle for..in","text":"<p>Para recorrer un objeto en un bucle, tenemos la estructure <code>for..in</code>, que va recorriendo todas las propiedades del objeto:</p> <pre><code>const obj = {\nname: \"John\",\nage: 17\n}\nfor(const key in obj){\nconsole.log(obj[key])\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-2/","title":"2 Referencias","text":""},{"location":"bloque_i/tema_5/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Una de las diferencias entre objetos y primitivos es que los objetos son almacenados y copiados por referencia, son almacenados y copiados por valor completo</p> <p>Una referencia en cualquier lenguaje de programaci\u00f3n hace alusi\u00f3n a la posici\u00f3n en memoria RAM que tiene una variable. Una variable es conceptualmente un recipiente donde se almacena un dato.</p> <p>Una variable es un lugar en la memoria donde se guarda un dato. Para ser exacto, este lugar en la memoria es la Pila o Stack. Pero cuando se crea un objeto, el objeto se guarda en una parte de la memoria llamada Heap.</p> <p>Stack es una secci\u00f3n de memoria que contiene m\u00e9todos, variables locales y variables de referencia. La memoria de pila siempre se referencia en el orden de \u00faltimo en entrar primero en salir. Las variables locales se crean en la pila.</p> <p>Heap es una secci\u00f3n de memoria que contiene objetos y tambi\u00e9n puede contener variables de referencia. Las propiedades se crean en el heap.</p>"},{"location":"bloque_i/tema_5/page-2/#representacion-en-memoria-de-tipos-primitivos","title":"Representaci\u00f3n en memoria de tipos primitivos","text":"<p>Veamos paso a paso un ejemplo:</p> <ul> <li> <p>Cuando se declara una variable de un tipo primitivo, el compilador reserva un \u00e1rea de memoria para ella:</p> <pre><code>const i, j\n</code></pre> <p> Figura 1 - Referencia de primitivos </p> </li> <li> <p>Cuando se asigna un valor, \u00e9ste es escrito en el \u00e1rea reservada:</p> <pre><code>i = 16\nj = 3\n</code></pre> <p> Figura 2 - Referencia de primitivos </p> </li> <li> <p>La asignaci\u00f3n entre variables significa copiar el contenido de una variable en la otra:</p> <pre><code>i = j;\n</code></pre> <p> Figura 3 - Referencia de primitivos </p> </li> <li> <p>La comparaci\u00f3n entre variables compara los contenidos de las mismas:</p> <pre><code>i == j; // true porque 3 es igual a 3\n</code></pre> </li> </ul> <pre><code>const i = 10, j = 20\nconsole.log(\"Valor de la variable i:\", i)\nconsole.log(\"Valor de la variable j:\", j)\ni = j\nconsole.log(\"Valor de la variable i:\", i)\nconsole.log(\"Valor de la variable j:\", j)\nconsole.log(`i y j${i == j ? \"\" : \" no\"} tiene el mismo contenido`)\n</code></pre>"},{"location":"bloque_i/tema_5/page-2/#representacion-en-memoria-de-objetos","title":"Representaci\u00f3n en memoria de objetos","text":"<p>Supongamos que tenemos una objeto Complex con dos atributos: r, i.</p> <ul> <li> <p>Cuando se declara una variable de un objeto, el compilador reserva un \u00e1rea de memoria para ella. Mientras no se cree ning\u00fan objeto con el operador {}, lo que contendr\u00e1 ser\u00e1 undefined. La palabra reservada undefined indica que una variable que referencia a un objeto se encuentra de momento sin referenciar a ninguno:</p> <pre><code>const c1\n</code></pre> <p> Figura 4 - Referencia de objetos </p> </li> <li> <p>Cuando se crea el objeto llamando con el operador {}, lo que se guarda en la variable complex1 es la direcci\u00f3n de memoria donde se ha almacenado el objeto en el heap, es decir, la diferencia entre los tipos primitivos y los objetos es que en los primitivos la variable almacena el valor y en los objetos, la variable almacena la direcci\u00f3n de memoria donde se encuentra el objeto.</p> <pre><code>c1 = {\nr: 7.2,\ni: 2.4\n}\n</code></pre> <p> Figura 5 - Referencia de objetos </p> </li> <li> <p>La asignaci\u00f3n entre variables de objetos significa copiar la direcci\u00f3n de memoria donde se encuentra el objeto:</p> <pre><code>const c2 = c1;\n</code></pre> <p>En este caso, el valor de la variable c2 es 0x2A18, por lo tanto, ambas variables apuntan al mismo objeto. Si una de ellas modifica alg\u00fan valor del objeto, tambi\u00e9n le afectar\u00e1 a la otra variable. Por ejemplo, si a c2 le cambiamos el valor de r a 9.7, si consultamos el valor de r de c1, tambi\u00e9n valdr\u00e1 9.7, en lugar de 7.2.</p> </li> <li> <p>La comparaci\u00f3n entre referencias no compara los contenidos de los objetos sino las direcciones de memoria, es decir, si apuntan al mismo sitio.</p> <pre><code>c2 == c1 // (1)!\nconst c3 = new Complex(7.2, 2.4)\nc3 == c1 // (2)!\n</code></pre> <ol> <li><code>true</code> porque apuntan al mismo sitio</li> <li><code>false</code> porque aunque tengan los mismos valores, no apuntan al mismo sitio</li> </ol> <p>Para comparar el contenido de los objetos, se debe utilizar el operador <code>===</code>:</p> <pre><code>c3 === c1 // (1)!\n</code></pre> <ol> <li><code>true</code> porque los contenidos de los objetos son los mismos</li> </ol> </li> </ul> <pre><code>const c1 = {r: 7.2, i: 2.3}\nconst c2 = c1\nconsole.log(\"C1 -&gt; r: \" c1.r, \"i: \", c1.i)\nconsole.log(\"C2 -&gt; r: \" c2.r, \"i: \", c2.i)\nc1.r = 10\nc2.j = 7.6\nconsole.log(\"C1 -&gt; r: \" c1.r, \"i: \", c1.i)\nconsole.log(\"C2 -&gt; r: \" c2.r, \"i: \", c2.i)\nconst c3 = {r: 10, i: 7.6}\nconsole.log(\"C2 -&gt; r: \" c3.r, \"i: \", c3.i)\nconsole.log(\"c1 == c2 -&gt; \", c1 == c2)\nconsole.log(\"c1 == c3 -&gt; \", c1 == c3)\nconsole.log(\"c1 === c3 -&gt; \", c1 === c3)\n</code></pre>"},{"location":"bloque_i/tema_5/page-2/#garbage-collector","title":"Garbage Collector","text":"<p>Garbage Collector (recolector de basura) es un programa que se ejecuta en el motor Javascript que elimina los objetos que ya no est\u00e1n siendo utilizados por una aplicaci\u00f3n. Es una forma de gesti\u00f3n autom\u00e1tica de la memoria.</p> <p>Un objeto es elegible para el recolector de basura cuando deja de existir alguna referencia hacia \u00e9l. Veamos algunos ejemplos.</p> <pre><code>const c1 = { r: 7.2, i: 2.4 };\n//...\nc1 = null;\n//...\n</code></pre> <p>Existe un objeto referenciado por la variable c1. Cuando la variable c1 pierde la referencia porque se le asigna el null, se pierde cualquier forma de acceder al objeto, de modo que pasa a ser elegible para el recolector de basura.</p> <pre><code>const c1 = {r: 7.2, i: 2.4};\nconst c2 = c1;\n// ...\nc1 = null;\n// ...\n</code></pre> <p>En este segundo ejemplo, el objeto no pasa a ser elegible para ser recolectado pues aunque la variable c1 haya perdido la referencia porque se le asigna el null, todav\u00eda existe una referencia hacia el objeto por la variable c2</p> <pre><code>const c1 = {r: 7.2, i: 2.4};\n//...\nc1 = {r: 8.3, i: 2.7};\n//...\n</code></pre> <p>En este otro ejemplo, la variable c1 es reasignada, es decir, se le asigna otro objeto mediante el operador  new, por  lo  tanto  se  pierde  cualquier  referencia  al  objeto  creado  al  principio  <code>new Complex(7.2 , 2.4)</code> por lo que dicho objeto pasa a ser elegible para el recolector de basura.</p>"},{"location":"bloque_i/tema_5/page-2/#clonacion","title":"Clonaci\u00f3n","text":"<p>El problema de la referencia, es que en ciertas ocasiones es necesario crear una copia de un objeto que se pueda manipular sin tener que manipular el objeto real.</p> <p>Una soluci\u00f3n para este problema es iterar el objeto original e ir copiando los valores de forma primitiva en otro objeto:</p> <pre><code>const obj = {\nname: \"John\",\nage: 17\n}\nconst copy = {}\nfor(const key in obj){\ncopy[key] =  obj[key]    }\nconsole.log(obj, copy) //{name: \"John\", age: 17}, {name: \"John\", age: 17}\ncopy.age = 20\nconsole.log(obj, copy) //{name: \"John\", age: 17}, {name: \"John\", age: 20}\n</code></pre> <p>Tambi\u00e9n existe el m\u00e9todo est\u00e1tico <code>Object.assign(dest, ...sources)</code> que copia el valor de sources en el objeto de destino dest.</p> <pre><code>const user = { name: \"John\" };\nconst permissions1 = { canView: true };\nconst permissions2 = { canEdit: true };\nObject.assign(user, permissions1, permissions2);\nconsole.log(user.name); // John\nconsole.log(user.canView); // true\nconsole.log(user.canEdit); // true\n</code></pre> <p>Si la propiedad ya existe, el m\u00e9todo sobrescribe el valor:</p> <pre><code>const user = { name: \"John\" }\nObject.assign(user, { name: \"Pete\" })\nalert(user.name) // ahora user = { name: \"Pete\" }\n</code></pre>"},{"location":"bloque_i/tema_5/page-2/#objetos-anidados","title":"Objetos anidados","text":"<p>Hasta ahora, todos las propiedades de los objetos que hemos visto ten\u00edan un valor primitivo. Cierto es, que una propiedad de un objeto, tambi\u00e9n puede ser otro objeto:</p> <pre><code>const user = {\nname: \"John\",\nsizes: {\nheight: 182,\nwidth: 50\n}\n}\nconsole.log(user.sizes.height) // 182\n</code></pre> <p>Si se le asigna con el m\u00e9todo <code>Object.assign()</code>, el objeto interno no se copiar\u00e1, si no que referenciar\u00e1, por lo que volvemos a tener el mismo problema:</p> <pre><code>const user = {\nname: \"John\",\nsizes: {\nheight: 182,\nwidth: 50\n}\n}\nconst clone = Object.assign({}, user)\nalert( user.sizes === clone.sizes ) // true\nuser.sizes.width = 60\nconsole.log(clone.sizes.width) // 60\n</code></pre> <p>Para corregir esto, debemos hacer que user y clone sean objetos completamente separados, debemos usar un bucle que examine cada valor de <code>user[key]</code> y, si es un objeto, que replique su estructura tambi\u00e9n. Esto es conocido como \u201cclonaci\u00f3n profunda\u201d o \u201cclonaci\u00f3n estructurada\u201d. Existe un m\u00e9todo <code>structuredClone</code> que implementa tal clonaci\u00f3n profunda.</p> <p>El m\u00e9todo <code>structuredClone(obj)</code> clona el objeto pasado como argumento con todas sus propiedades anidadas, es decir, hace una copia profunda.</p> <pre><code>const user = {\nname: \"John\",\nsizes: {\nheight: 182,\nwidth: 50\n}\n}\nconst clone = structuredClone(user)\nconsole.log(user.sizes === clone.sizes) // false\nuser.sizes.width = 60\nconsole.log(clone.sizes.width) // 50\n</code></pre>"},{"location":"bloque_i/tema_5/page-3/","title":"3 M\u00e9todos y operadores","text":""},{"location":"bloque_i/tema_5/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Los objetos no solo pueden tener propiedades de tipo primitivo u otros objetos, si no que tambi\u00e9n pueden contener funciones.</p> <pre><code>const obj = {\nname: \"John\",\nage: 17,\nsayHi: function(){\nconsole.log('Hi!')\n}\n}\nconsole.log(obj.sayHi())\n</code></pre> <p>En el ejemplo anterior, se ha creado un m\u00e9todo dentro del objeto. Al llamar al m\u00e9todo, se ejecuta el mismo.</p> <p>Al crear un m\u00e9todo dentro de un objeto, se le puede pasar una funci\u00f3n ya creada:</p> <pre><code>const sayHi = () =&gt; {\nconsole.log('Hi!')\n}\nconst obj = {\nname: \"John\",\nage: 17\n}\nobj.sayHi = sayHi\n</code></pre> <p>Tambi\u00e9n existe una forma abreviada de escribir una funci\u00f3n en un objeto:</p> <pre><code>const obj = {\nname: \"John\",\nage: 17,\nsayHi: function(){\nconsole.log('Hi!')\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_5/page-3/#acceso-al-objeto-actual","title":"Acceso al objeto actual","text":"<p>Cuando se declaran m\u00e9todos dentro de los objetos, en ciertas ocasiones se desea acceder al objeto en el cu\u00e1l se est\u00e1 creando el m\u00e9todo. Para ello, existe la palabra reservada <code>this</code> que hace referencia al objeto actual:</p> <pre><code>const obj = {\nname: \"John\",\nage: 17,\nsayHi: function(){\nconsole.log('Hi!' + this.name)\n}\n}\nconsole.log(obj.sayHi())\n</code></pre> <p>Cuando se ejecute el m\u00e9todo <code>sayHi</code>, el valor de <code>this</code> ser\u00e1 el valor actual del objeto <code>obj</code>-.</p> <p>\u00a1Cuidado!</p> <p>T\u00e9cnicamente, tambi\u00e9n es posible acceder al objeto sin this, haciendo referencia a \u00e9l por medio de la variable externa. Pero tal c\u00f3digo no es confiable. Si decidimos copiar user a otra variable, por ejemplo admin = user y sobrescribir user con otra cosa, entonces acceder\u00e1 al objeto incorrecto.</p>"},{"location":"bloque_i/tema_5/page-3/#this-no-es-vinculado","title":"this no es vinculado","text":"<p>En JavaScript, la palabra clave this se comporta de manera distinta a la mayor\u00eda de otros lenguajes de programaci\u00f3n. Puede ser usado en cualquier funci\u00f3n, incluso si no es el m\u00e9todo de un objeto.</p> <p>No hay error de sintaxis en el siguiente ejemplo:</p> <pre><code>function sayHi() {\nconsole.log(this.name)\n}\n</code></pre> <p>El valor de <code>this</code> es evaluado durante el tiempo de ejecuci\u00f3n, dependiendo del contexto. Por ejemplo, aqu\u00ed la funci\u00f3n es asignada a dos objetos diferentes y tiene diferentes <code>this</code> en sus llamados:</p> <pre><code>const user = { name: \"John\" }\nconst admin = { name: \"Admin\" }\nfunction sayHi() {\nconsole.log(this.name)\n}\nuser.f = sayHi;\nadmin.f = sayHi;\nuser.f(); // John  (this == user)\nadmin.f(); // Admin  (this == admin)\nadmin['f'](); // Admin\n</code></pre> <p>La regla es simple: si <code>obj.f()</code> es llamado, entonces <code>this</code> es <code>obj</code> durante el llamado de <code>f</code>. Entonces es tanto <code>user</code> o <code>admin</code> en el ejemplo anterior.</p> <p>Warning</p> <p>Podemos incluso llamar la funci\u00f3n sin un objeto en absoluto:</p> <pre><code>function sayHi() {\nconsole.log(this)\n}\nsayHi() // undefined\n</code></pre> <p>En este caso <code>this</code> es <code>undefined</code> en el modo estricto. Si tratamos de acceder a t<code>his.name</code>, habr\u00e1 un error.</p> <p>En modo no estricto el valor de <code>this</code> en tal caso ser\u00e1 el objeto global (window en un navegador). Este es un comportamiento hist\u00f3rico que \"use strict\" corrige.</p> <p>Usualmente tal llamado es un error de programa. Si hay this dentro de una funci\u00f3n, se espera que sea llamada en un contexto de objeto. ```</p> <p>Info</p> <p>Si vienes de otro lenguaje de programaci\u00f3n, probablemente est\u00e9s habituado a la idea de un <code>this</code> vinculado, donde los m\u00e9todo definidos en un objeto siempre tienen <code>this</code> referenciando ese objeto.</p> <p>En JavaScript this es libre, su valor es evaluado al momento de su llamado y no depende de d\u00f3nde fue declarado el m\u00e9todo sino de cu\u00e1l es el objeto delante del punto.</p> <p>El concepto de <code>this</code> evaluado en tiempo de ejecuci\u00f3n tiene sus pros y sus contras. Por un lado, una funci\u00f3n puede ser reusada por diferentes objetos. Por otro, la mayor flexibilidad crea m\u00e1s posibilidades para equivocaciones.</p> <p>Nuestra posici\u00f3n no es juzgar si la decisi\u00f3n del dise\u00f1o de lenguaje es buena o mala. Vamos a entender c\u00f3mo trabajar con ello, obtener beneficios y evitar problemas.</p> <p>Las funciones de flecha son especiales: ellas no tienen su propio <code>this</code>. Si nosotros hacemos referencia a <code>this</code> desde tales funciones, esta ser\u00e1 tomada desde afuera de la funci\u00f3n normal.</p> <p>Por ejemplo, aqu\u00ed arrow() usa <code>this</code> desde fuera del m\u00e9todo <code>user.sayHi()</code>:</p> <pre><code>let user = {\nfirstName: \"Ilya\",\nsayHi() {\nconst arrow = () =&gt; alert(this.firstName);\narrow();\n}\n};\nuser.sayHi(); // Ilya\n</code></pre>"},{"location":"bloque_i/tema_5/page-3/#objeto-global","title":"Objeto global","text":"<p>El objeto global proporciona variables y funciones que est\u00e1n disponibles en cualquier lugar. Por defecto, aquellas que est\u00e1n integradas en el lenguaje o el entorno.</p> <p>En un navegador se denomina <code>window</code>, para Node.js es <code>global</code>, para otros entornos puede tener otro nombre.</p> <p>Recientemente, se agreg\u00f3 <code>globalThis</code> al lenguaje, como un nombre estandarizado para un objeto global, que deber\u00eda ser compatible con todos los entornos al igual que con los principales navegadores.</p> <p>Se puede acceder a todas las propiedades de forma directa, sin necesidad de hacer uso de su nombre:</p> <pre><code>console.log('Hi')  // window.console.log('Hi')\n</code></pre> <p>En un navegador, las funciones y variables globales declaradas con <code>var</code> (\u00a1no con let/const!) se convierten en propiedades del objeto global:</p> <pre><code>var gVar = 5;\nconsole.log(window.gVar); // 5\n</code></pre> <p>El mismo efecto lo tienen las declaraciones de funci\u00f3n (sentencias con la palabra clave function en el flujo principal del c\u00f3digo, no las expresiones de funci\u00f3n).</p> <p>Como el uso de <code>var</code> no est\u00e1 recomendado, si un valor es tan importante que desea que est\u00e9 disponible globalmente, puede ser indicado directamente como una propiedad:</p> <pre><code>window.currentUser = {\nname: \"John\"\n}\nconsole.log(currentUser.name)  // John\nconsole.log(window.currentUser.name) // John\n</code></pre> <p>Dicho esto, generalmente se desaconseja el uso de variables globales. Deber\u00eda haber la menor cantidad posible de ellas. El dise\u00f1o del c\u00f3digo donde una funci\u00f3n obtiene variables de \u201centrada\u201d y produce cierto \u201cresultado\u201d es m\u00e1s claro, menos propenso a errores y m\u00e1s f\u00e1cil de probar que si usa variables externas o globales.</p>"},{"location":"bloque_i/tema_5/page-3/#constructor","title":"Constructor","text":"<p>Como ya hemos visto, la sintaxis habitual para crear un objeto, es haciendo uso de las llaves <code>{}</code>. Sin embargo, podemos crear una funci\u00f3n que se encargue de la creaci\u00f3n de estos objetos. Esta funci\u00f3n es conocida como constructor y su uso requiere la palabra <code>new</code> como precedente al nombre del m\u00e9todo.</p> <p>El constructor es t\u00e9cnicamente una funci\u00f3n normal, pero suele ir escrita en may\u00fasculas y precedidas por el operador <code>new</code>.</p> <pre><code>function User(name){\nthis.name = name\nthis.admin = false\n}\nconst user = new User(\"Jack\")\nconsole.log(user) // {name: \"Jack\", admin: false}\n</code></pre> <p>Cuando una funci\u00f3n es ejecuta con el operador <code>new</code> realiza los siguientes pasos:</p> <ol> <li>Crea un objeto vac\u00edo que se le asigna a <code>this</code> (a un objeto actual)</li> <li>Se ejecuta el cuerpo de la funci\u00f3n. \u00c9ste, normalmente, modifica el objeto actual (<code>this</code>) y se le a\u00f1ade sus propiedades.</li> <li>Se devuelve el valor del objeto actual (<code>this</code>)</li> </ol> <p>Al usar el operador <code>new</code> tanto el paso 1 como el 3, se realizan de forma impl\u00edcita, es decir, no es necesario indicarlo en el cuerpo de la funci\u00f3n:</p> <pre><code>function User(name){\n// this = {} (impl\u00edcitamente)\n// agregar propiedades\nthis.name = name\nthis.admin = false\n// return this (impl\u00edcitamente)\n}\n</code></pre> <p>El principal objetivo de usar constructores es implementar c\u00f3digo reutilizable y que sea de f\u00e1cil lectura a la hora de crear varios objetos del mismo tipo.</p> <p>T\u00e9cnicamente cualquier funci\u00f3n puede ser llamada como constructor, al hacer uso del operador <code>new</code>. El hecho de que est\u00e9 escrito con primera letra may\u00fascula simplemente es un convencionalismo, no una sintaxis obligatoria.</p> <p>Esto puede acarrear varios problemas, por ejemplo, cuando se desea usar crear un objeto y no se usa el operador <code>new</code>. En ese caso, el objeto no ser\u00e1 devuelto. El operador <code>new</code> tiene una propiedad <code>target</code> que nos permitir\u00e1 comprobar si la funci\u00f3n ha sido o no llamada con dicho operador.</p> <p>Cuando se llama a una funci\u00f3n con el operador <code>new</code>, su propiedad <code>target</code> contiene la funci\u00f3n en s\u00ed. Por el contrario, ser\u00eda <code>undefined</code>.</p> <pre><code>function User(name){\nconsole.log(new.target)\n}\nUser() // undefined\nnew User() // function User(name)...\n</code></pre> <p>Esto nos da una mayor flexibilidad a la hora de definir nuestro constructor, ya que podemos realizar la comprobaci\u00f3n de si ha sido llamado con el operador <code>new</code> y en caso de no hacerlo, obligarlo a llamarlo:</p> <pre><code>function User(name){\nif(!new.target){\nreturn new User(name)\n}\nthis.name = name\n}\nconst user = User(\"John\")\nconsole.log(user) // {name: \"John\"}\n</code></pre> <p>Este enfoque es utilizado a veces en las librer\u00edas para hacer el sintaxis m\u00e1s flexible. As\u00ed la gente puede llamar a la funci\u00f3n con o sin <code>new</code> y a\u00fan funciona. Sin embargo, probablemente no sea algo bueno para usar en todas partes, porque omitir new hace que sea un poco menos obvio lo que est\u00e1 sucediendo. Con new todos sabemos que se est\u00e1 creando el nuevo objeto.</p>"},{"location":"bloque_i/tema_5/page-3/#constructores-con-return-explicitos","title":"Constructores con return expl\u00edcitos","text":"<p>Como hemos visto, un constructor retorna de impl\u00edcitamente un objeto con las propiedades modificadas en el cuerpo del constructor. Sin embargo, un constructor puede usar una sentencia <code>return</code> expl\u00edcitamente, pudiendo ocurrir dos cosas:</p> <ul> <li> <p>Si el valor devuelto es un objeto, se retorna dicho objeto obviando el <code>this</code>.</p> <pre><code>function BigUser(){\nthis.name = \"John\"\nreturn {name: \"Godzilla\"}\n}\nconsole.log(new BigUser()) // {name: \"Godzilla\"}\n</code></pre> </li> <li> <p>Si el valor devuelto es un dato primitivo, se omite retornando el valor de <code>this</code>.</p> <pre><code>function BigUser(){\nthis.name = \"John\"\nreturn 10\n}\nconsole.log(new BigUser()) // {name: \"John\"}\n</code></pre> </li> </ul> <p>Info</p> <p>A la hora de usar el operador <code>new</code> seguido de la funci\u00f3n constructora, no estamos obligados a usar los par\u00e9ntesis de invocaci\u00f3n de funciones: </p> <pre><code>const user = new User\n</code></pre> <p>Sin embargo, se recomienda su uso, ya que esta t\u00e9cnica no se considera buena pr\u00e1ctica.</p>"},{"location":"bloque_i/tema_5/page-3/#constructores-con-metodos","title":"Constructores con m\u00e9todos","text":"<p>En un constructor no solo podemos definir propiedades, sino tambi\u00e9n definir m\u00e9todos:</p> <pre><code>function User(name){\nthis.name = name\nthis.sayHi = () =&gt; {\nconsole.log('Hi!')\n}\n}\n</code></pre> <p>Incluso, se puede usar una callback como par\u00e1metro del constructor para a\u00f1adir m\u00e9todos de forma m\u00e1s din\u00e1mica:</p> <pre><code>function Animal(name, sound){\nthis.name = name\nthis.sound = sound\n}\nconst dogSound = () =&gt; {\nconsole.log('Guau!')\n}\nconst catSound = () =&gt; {\nconsole.log('Miau!')\n}\nconst dog = new Animal('Dog', dogSound)\nconst cat = new Animal('Cat', catSound)\ndog.sound()\ncat.sound()\n</code></pre>"},{"location":"bloque_i/tema_5/page-3/#operador-opcional","title":"Operador opcional","text":"<p>Supongamos que tenemos un objeto, y queremos acceder a la propiedad direcci\u00f3n que presumimos que tambi\u00e9n es un objeto y que de ah\u00ed queremos obtener la calle. Si todo va bien, podemos acceder a dicha informaci\u00f3n haciendo uso de <code>user.address.street</code>.</p> <p>El problema est\u00e1 si el objeto <code>address</code> no existe o est\u00e1 vac\u00edo. En este caso, el valor de la propiedad <code>street</code> ser\u00eda <code>undefined</code>. Hasta aqu\u00ed todo es normal, pero supongamos que tenemos el objeto <code>user</code> vac\u00edo o sin la propiedad <code>address</code>. En este caso, no nos devolver\u00eda directamente <code>undefined</code> si no que nos dar\u00eda un error en la ejecuci\u00f3n.</p> <p>Podemos evitar dicho error, haciendo uso de una ternaria:</p> <pre><code>const user = {}\nconsole.log(user.address ? user.address.street : undefined)\n</code></pre> <p>De esta forma, se evita el error de ejecuci\u00f3n y obligamos a que nos devuelva un valor <code>undefined</code>. Sin embargo, la cosa se complica al querer acceder a propiedades de objetos m\u00e1s profundos:</p> <pre><code>const user = {}\nconsole.log(\nuser.address ? user.address.street\n? user.address.street.name\n: undefined\n: undefined\n)\n</code></pre> <p>Una forma m\u00e1s elegante de hacer es haciendo uso del operador <code>&amp;&amp;</code>:</p> <pre><code>const user = {}\nconsole.log(user.address &amp;&amp; user.address.street &amp;&amp; user.address.street.name)\n</code></pre> <p>Sin embargo, a\u00fan as\u00ed se nos puede quedar un c\u00f3digo bastante engorroso, repetitivo y largo, dependiendo de la profundidad de la propiedad a usar.</p> <p>El operador opcional <code>?.</code> es un operador que detiene la evaluaci\u00f3n y retorna <code>undefined</code> si el valor antes del operador es <code>null</code> o <code>undefined</code>. As\u00ed, <code>value?.prop</code> retornar\u00e1 el valor de <code>prop</code> si este existe, o devolver\u00e1 <code>undefined</code> si no.</p> <pre><code>console.log(user?.address?.street?.name)\n</code></pre> <p>La sintaxis <code>?.</code> hace opcional el valor delante de \u00e9l, pero no m\u00e1s all\u00e1. Por ejemplo, en <code>user?.address.street.name</code>, el operador permite que <code>user</code> sea <code>null/undefined</code> (y devuelve <code>undefined</code> en tal caso), pero solo a <code>user</code>. El resto de las propiedades son accedidas de la manera normal. Si queremos que algunas de ellas sean opcionales, necesitamos reemplazar m\u00e1s <code>.</code> con <code>?.</code>.</p> <p>No abuses del operador opcional</p> <p>Deber\u00edamos usar <code>?.</code> solo donde est\u00e1 bien que algo no exista. Por ejemplo, si de acuerdo con la l\u00f3gica de nuestro c\u00f3digo, el objeto user debe existir, pero <code>address</code> es opcional, entonces deber\u00edamos escribir user.address?.street y no <code>user?.address?.street</code>.</p> <p>De esta forma, si por un error <code>user</code> no est\u00e1 definido, lo sabremos y lo arreglaremos. De lo contrario, los errores de codificaci\u00f3n pueden silenciarse donde no sea apropiado y volverse m\u00e1s dif\u00edciles de depurar.</p> <p>Warning</p> <p>Si no hay una variable user declarada, entonces <code>user?.anything</code> provocar\u00e1 un error:</p> <pre><code>// ReferenceError: user no est\u00e1 definido\nuser?.address;\n</code></pre> <p>La variable debe ser declarada (con <code>let/const/var user</code> o como par\u00e1metro de funci\u00f3n). El encadenamiento opcional solo funciona para variables declaradas.</p> <p>\u00a1Importante!</p> <p>El operador opcional es una operaci\u00f3n cortocircuito, es decir, detiene la ejecuci\u00f3n devolviendo <code>undefined</code> en el momento que encuentra una propiedad <code>null</code> o <code>undefined</code>, por lo que si hay operaciones posteriores al uso del operador, \u00e9stas no se ejecutar\u00e1n.</p> <pre><code>const user = null\nconst x = 0\nuser?.sayHi(x++) // (1)!\nconsole.log(x) // 0\n</code></pre> <ol> <li>no hay <code>user</code>, por lo que la ejecuci\u00f3n no alcanza a <code>sayHi</code> ni a <code>x++</code></li> </ol> <p>El operador opcional tambi\u00e9n puede ser usada en los siguientes casos:</p> <ul> <li> <p>Invocaci\u00f3n de m\u00e9todos. Comprueba en primer lugar, si el m\u00e9todo existe en el objeto, y en caso de serlo, ejecuta el m\u00e9todo. Su sintaxis es <code>obj.fun?.()</code>.</p> <pre><code>const user = {}\nconsole.log(user?.sayHi?.())\n</code></pre> </li> <li> <p>Acceso de propiedades con corchetes. Comprueba que el objeto est\u00e1 definido, en dicho caso devuelve la propiedad, si no <code>undefined</code>.</p> <pre><code>const user = {}\nconsole.log(user?.[name])\n</code></pre> </li> <li> <p>Eliminar propiedad de un objeto. Elimina la propiedad del objeto si el objeto est\u00e1 definido.</p> <pre><code>const user = {}\ndelete user?.name\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_5/page-4/","title":"4 Symbol","text":""},{"location":"bloque_i/tema_5/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>En JavaScript, el tipo <code>Symbol</code> es un tipo de dato primitivo que se introdujo en ECMAScript 2015 (ES6). Los s\u00edmbolos son \u00fanicos e inmutables, lo que significa que cada s\u00edmbolo es diferente de cualquier otro s\u00edmbolo, incluso si tienen la misma descripci\u00f3n. Los s\u00edmbolos se utilizan principalmente como identificadores \u00fanicos para las propiedades de los objetos.</p> <p>Para crear un <code>Symbol</code> se puede usar su constructor (no es obligatorio el uso de <code>new</code>) en el que se le puede pasar opcionalmente una descripci\u00f3n del mismo:</p> <pre><code>const symbol = Symbol('id')\nconsole.log(symbol) //Symbol(id)\n</code></pre> <p>Cada vez que se crea un s\u00edmbolo, \u00e9stos son \u00fanicos, incluso si tienen el mismo identificador o descripci\u00f3n:</p> <pre><code>const symbol1 = Symbol('id')\nconst symbol2 = Symbol('id')\nconsole.log(symbol1 === symbol2) // false\n</code></pre> <p>Podemos acceder a la descripci\u00f3n indicada a trav\u00e9s de la propiedad <code>description</code>:</p> <pre><code>const symbol = Symbol('id')\nconsole.log(symbol.description) // id\n</code></pre>"},{"location":"bloque_i/tema_5/page-4/#propiedades-ocultas","title":"Propiedades ocultas","text":"<p>Una de las funciones de los s\u00edmbolos es ser usado como propiedades en los objetos. Dichas propiedades se consideran ocultas ya que no pueden ser accedidas de forma sencilla. Para acceder a ellas, necesitamos el s\u00edmbolo \u00fanico que lo representa:</p> <pre><code>const id = Symbol('id')\nconst user = {\n[id]: 1,\nname: 'John'\n}\nconsole.log(user[id]) // 1\n</code></pre> <p>En el ejemplo anterior se ha podido acceder a la propiedad que simboliza el id debido a que ten\u00edamos el valor del s\u00edmbolo almacenado en una variable. Si el objeto es usado en otro lugar y se desconoce la variable que almacena la propiedad simbolizada, ser\u00eda imposible acceder a ella.</p> <p>Aunque parezca una desventaja, realmente es una ventaja, ya que de esta forma se estar\u00eda protegiendo las propiedades de tal forma que no puedan ser ni modificadas ni eliminadas de forma err\u00f3nea. Adem\u00e1s, si desde otro script se desea a\u00f1adir la misma propiedad <code>id</code> para otros fines, podr\u00eda hacerlo sin sobrescribir el originalmente creado.</p> <p>Las propiedades simbolizadas son ocultadas por el bucle <code>for..in</code>. Sin embargo, el m\u00e9todo <code>Object.assign</code> permite copiar perfectamente estas propiedades.</p>"},{"location":"bloque_i/tema_5/page-4/#simbolos-globales","title":"S\u00edmbolos globales","text":"<p>Como hemos visto, normalmente todos los Symbols son diferentes aunque tengan el mismo nombre. Pero algunas veces necesitamos que symbols con el mismo nombre sean la misma entidad.</p> <p>Para lograr esto, existe un global symbol registry. Ah\u00ed podemos crear symbols y accederlos despu\u00e9s, lo cual nos garantiza que cada vez que se acceda a la clave con el mismo nombre, esta te devuelva exactamente el mismo symbol.</p> <p>JavaScript proporciona un registro global de s\u00edmbolos. Puedes crear s\u00edmbolos que sean accesibles globalmente utilizando <code>Symbol.for(key)</code> y obtener s\u00edmbolos globales existentes con <code>Symbol.keyFor(key)</code>:</p> <pre><code>const id = Symbol.for('id')\nconst idAgain = Symbol.for('id')\nconsole.log(id === idAgain) // true\nconsole.log(Symbol.keyFor(id)) // id\n</code></pre> <p>El <code>Symbol.keyFor</code> utiliza internamente el registro global symbol registry para buscar la clave del s\u00edmbolo, por lo tanto, no funciona para los s\u00edmbolos que no est\u00e1n dentro del registro. Si el s\u00edmbolo no es global, no ser\u00e1 capaz de encontrarlo y por lo tanto devolver\u00e1 <code>undefined</code>.</p>"},{"location":"bloque_i/tema_5/page-5/","title":"5 Conversi\u00f3n de objetos a primitivos","text":""},{"location":"bloque_i/tema_5/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>\u00bfQu\u00e9 sucede cuando los objetos se suman <code>obj1 + obj2</code>, se restan <code>obj1 - obj2</code> o se imprimen utilizando <code>console.log(obj)</code>?</p> <p>JavaScript no permite personalizar c\u00f3mo los operadores trabajan con los objetos. Al contrario de otros lenguajes de programaci\u00f3n como Ruby o C++, no podemos implementar un m\u00e9todo especial para manejar una suma (u otros operadores).</p> <p>En ese caso, los objetos se convierten autom\u00e1ticamente en valores primitivos, y luego se lleva a cabo la operaci\u00f3n sobre esos primitivos, y resultan en un valor primitivo.</p> <p>Esto es una limitaci\u00f3n importante: el resultado de <code>obj1 + obj2</code> (u otra operaci\u00f3n) \u00a1no puede ser otro objeto!</p> <p>Por ejemplo no podemos hacer objetos que representen vectores o matrices, sumarlas y esperar un objeto sumado como resultado. Tal objetivo arquitectural cae autom\u00e1ticamente fuera del tablero.</p> <p>Como t\u00e9cnicamente no podemos hacer mucho aqu\u00ed, no se hacen matem\u00e1ticas con objetos en proyectos reales. Cuando ocurre, con alguna rara excepci\u00f3n es por un error de c\u00f3digo.</p>"},{"location":"bloque_i/tema_5/page-5/#reglas-de-conversion","title":"Reglas de conversi\u00f3n","text":"<p>En el cap\u00edtulo Conversiones de Tipos, hemos visto las reglas para las conversiones de valores primitivos num\u00e9ricos, strings y booleanos. Las reglas para convertir un objeto a un primitivo son:</p> <ol> <li>No hay conversi\u00f3n a <code>boolean</code>. Todos los objetos son <code>true</code> en un contexto booleano, tan simple como eso. Solo hay conversiones num\u00e9ricas y de strings.</li> <li>La conversi\u00f3n num\u00e9rica ocurre cuando restamos objetos o aplicamos funciones matem\u00e1ticas. Por ejemplo, los objetos de tipo <code>Date</code> se pueden restar, y el resultado de <code>date1 - date2</code> es la diferencia horaria entre dos fechas.</li> <li>En cuanto a la conversi\u00f3n de <code>strings</code>: generalmente ocurre cuando imprimimos un objeto como en <code>console.log(obj)</code> y en contextos similares.</li> </ol> <p>Podemos implementar la conversi\u00f3n de tipo string y num\u00e9rica por nuestra cuenta, utilizando m\u00e9todos de objeto especiales.</p> <p>Para realizar la conversi\u00f3n, JavaScript intenta buscar y llamar a tres m\u00e9todos del objeto:</p> <ol> <li>Busca y llama, si el m\u00e9todo existe, a <code>obj[Symbol.toPrimitive](hint)</code>: el m\u00e9todo con la clave simb\u00f3lica <code>Symbol.toPrimitive</code> (s\u00edmbolo del sistema)</li> <li>Si no lo encuentra y hint es <code>string</code>, intenta llamar a <code>obj.toString()</code> y <code>obj.valueOf()</code>, lo que exista.</li> <li>Si no lo encuentra y hint es <code>number</code> o <code>default</code>, intenta llamar a <code>obj.valueOf()</code> y <code>obj.toString()</code>, lo que exista.</li> </ol>"},{"location":"bloque_i/tema_5/page-5/#symboltoprimitive","title":"Symbol.toPrimitive","text":"<p>Hay un s\u00edmbolo incorporado llamado <code>Symbol.toPrimitive</code> que debe utilizarse para nombrar el m\u00e9todo de conversi\u00f3n, as\u00ed:</p> <pre><code>obj[Symbol.toPrimitive] = function(hint) {\n// aqu\u00ed va el c\u00f3digo para convertir este objeto a un primitivo\n// debe devolver un valor primitivo\n// hint = \"sugerencia\", uno de: \"string\", \"number\", \"default\"\n}\n</code></pre> <p>Si el m\u00e9todo <code>Symbol.toPrimitive</code> existe, es usado para todos los hints y no ser\u00e1n necesarios m\u00e1s m\u00e9todos.</p> <pre><code>const user = {\nname: \"John\",\nmoney: 1000,\n[Symbol.toPrimitive](hint) {\nconsole.log(`sugerencia: ${hint}`);\nreturn hint == \"string\" ? `{name: \"${this.name}\"}` : this.money;\n}\n}\nconsole.log(user) // sugerencia: string -&gt; {name: \"John\"}\nconsole.log(+user); // sugerencia: number -&gt; 1000\nconsole.log(user + 500); // sugerencia: default -&gt; 1500\n</code></pre> <p>Como podemos ver en el c\u00f3digo, user se convierte en un string autodescriptivo o en una cantidad de dinero, depende de la conversi\u00f3n. Un \u00fanico m\u00e9todo <code>user[Symbol.toPrimitive]</code> maneja todos los casos de conversi\u00f3n.</p>"},{"location":"bloque_i/tema_5/page-5/#tostringvalueof","title":"toString/valueOf","text":"<p>Si no existe <code>Symbol.toPrimitive</code> entonces JavaScript trata de encontrar los m\u00e9todos <code>toString</code> y <code>valueOf</code>:</p> <ul> <li>Para una sugerencia string: trata de llamar a <code>toString</code> primero; pero si no existe, o si devuelve un objeto en lugar de un valor primitivo, llama a <code>valueOf</code> (as\u00ed, <code>toString</code> tiene prioridad en conversiones string).</li> <li>Para otras sugerencias: trata de llamar a <code>valueOf</code> primero; y si no existe, o si devuelve un objeto en lugar de un valor primitivo, llama a <code>toString</code> (as\u00ed, <code>valueOf</code> tiene prioridad para matem\u00e1ticas).</li> </ul> <p>Los m\u00e9todos <code>toString</code> y <code>valueOf</code> provienen de tiempos remotos. No son s\u00edmbolos (los s\u00edmbolos no exist\u00edan en aquel tiempo) sino m\u00e9todos normales nombrados con strings. Proporcionan una forma alternativa al viejo estilo de implementar la conversi\u00f3n.</p> <p>Estos m\u00e9todos deben devolver un valor primitivo. Si <code>toString</code> o <code>valueOf</code> devuelve un objeto, entonces se ignora (lo mismo que si no hubiera un m\u00e9todo).</p> <p>De forma predeterminada, un objeto simple tiene los siguientes m\u00e9todos <code>toString</code> y <code>valueOf</code>:</p> <ul> <li>El m\u00e9todo <code>toString</code> devuelve un string <code>[object Object]</code>.</li> <li>El m\u00e9todo <code>valueOf</code> devuelve el objeto en s\u00ed.</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>const user = {name: \"John\"};\nconsole.log(user); // [object Object]\nconsole.log(user.valueOf() === user); // true\n</code></pre> <p>Ahora, veamos el ejemplo anterior, sin usar <code>Symbol.toPrimitive</code>:</p> <pre><code>const user = {\nname: \"John\",\nmoney: 1000,\n// para sugerencia=\"string\"\ntoString() {\nreturn `{name: \"${this.name}\"}`\n},\n// para sugerencia=\"number\" o \"default\"\nvalueOf() {\nreturn this.money\n}\n}\nconsole.log(user) // toString -&gt; {name: \"John\"}\nconsole.log(+user) // valueOf -&gt; 1000\nconsole.log(user + 500) // valueOf -&gt; 1500\n</code></pre> <p>En ausencia de <code>Symbol.toPrimitive</code> y <code>valueOf</code>, <code>toString</code> manejar\u00e1 todas las conversiones primitivas.</p> <p>Lo importante que debe saber acerca de todos los m\u00e9todos de conversi\u00f3n primitiva es que no necesariamente devuelven la primitiva sugerida.</p> <p>No hay control para que <code>toString</code> devuelva exactamente un <code>string</code>, ni para que el m\u00e9todo <code>Symbol.toPrimitive</code> con una sugerencia <code>number</code> devuelva un n\u00famero.</p> <p>Lo \u00fanico obligatorio es que estos m\u00e9todos deben devolver un valor primitivo, no un objeto.</p> <p>Info</p> <p>Por razones hist\u00f3ricas, si <code>toString</code> o <code>valueOf</code> devuelve un objeto, no hay ning\u00fan error, pero dicho valor se ignora (como si el m\u00e9todo no existiera). Esto se debe a que en la antig\u00fcedad no exist\u00eda un buen concepto de error en JavaScript.</p> <p>Por el contrario, <code>Symbol.toPrimitive</code> es m\u00e1s estricto, debe devolver un valor primitivo, en caso contrario s\u00ed habr\u00e1 un error.</p>"},{"location":"bloque_i/tema_5/page-6/","title":"6 Funciones como objetos","text":""},{"location":"bloque_i/tema_5/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos visto, las funciones en Javascript son tratadas como un valor. Eso es debido a que las funciones son objetos. Esto quiere decir, que no solo pueden ser llamados, si no que se pueden modificar, acceder o eliminar sus propiedades.</p>"},{"location":"bloque_i/tema_5/page-6/#la-propiedad-name","title":"La propiedad name","text":"<p>La propiedad <code>name</code> de una funci\u00f3n devuelve el nombre de la funci\u00f3n:</p> <pre><code>function sayHi(){\nconsole.log('Hi!')\n}\nconsole.log(sayHi.name) // sayHi\n</code></pre> <p>En la especificaci\u00f3n, esta caracter\u00edstica se denomina nombre contextual. Si la funci\u00f3n no proporciona una, entonces en una asignaci\u00f3n se deduce del contexto.</p> <pre><code>const sayHi = function() {\nconsole.log(\"Hi\")\n}\nconsole.log(sayHi.name) // sayHi\n</code></pre>"},{"location":"bloque_i/tema_5/page-6/#la-propiedad-length","title":"La propiedad length","text":"<p>La propiedad <code>length</code> devuelve el n\u00famero de par\u00e1metros que una funci\u00f3n espera recibir. Por eso, si su usa el operador rest (se ver\u00e1 m\u00e1s adelante) \u00e9stas no ser\u00e1n contabilizadas.</p> <pre><code>const func = (a,b) =&gt; {}\nconsole.log(func.length)\n</code></pre> <p>La propiedad <code>length</code> a veces se usa para introspecci\u00f3n en funciones que operan en otras funciones.</p>"},{"location":"bloque_i/tema_5/page-6/#propiedades-personalizadas","title":"Propiedades personalizadas","text":"<p>Podemos a\u00f1adirle a una funci\u00f3n las propiedades que consideremos. Por ejemplo, podemos crear una propiedad, para conocer el n\u00famero de veces que ha sido llamada la funci\u00f3n:</p> <pre><code>function sayHi() {\nconsole.log(\"Hi\")\nsayHi.counter++\n}\nsayHi.counter = 0\nsayHi() // Hi\nsayHi() // Hi\nconsole.log(`Called ${sayHi.counter} times`) //  Called 2 times\n</code></pre> <p>Una propiedad no es una variable</p> <p>Una propiedad asignada a una funci\u00f3n como <code>sayHi.counter = 0</code> no define una variable local counter dentro de ella. En otras palabras, una propiedad <code>counter</code> y una variable <code>let counter</code> son dos cosas no relacionadas.</p> <p>Podemos tratar una funci\u00f3n como un objeto, almacenar propiedades en ella, pero eso no tiene ning\u00fan efecto en su ejecuci\u00f3n. Las variables no son propiedades de la funci\u00f3n y viceversa. Estos solo son dos mundos paralelos.</p>"},{"location":"bloque_i/tema_5/page-6/#funciones-closure","title":"Funciones closure","text":"<p>Una funci\u00f3n se llama anidada o closure cuando se crea dentro de otra funci\u00f3n.</p> <pre><code>function sayHiBye(firstName, lastName) {\nfunction getFullName() {\nreturn firstName + \" \" + lastName;\n}\nconsole.log(\"Hello, \" + getFullName())\nconsole.log(\"Bye, \" + getFullName())\n}\n</code></pre> <p>Aqu\u00ed la funci\u00f3n anidada <code>getFullName()</code> se hace por conveniencia. Puede acceder a las variables externas y, por lo tanto, puede devolver el nombre completo. Las funciones anidadas son bastante comunes en JavaScript.</p> <p>Lo que es mucho m\u00e1s interesante, es que puede devolverse una funci\u00f3n anidada: ya sea como propiedad de un nuevo objeto o como resultado en s\u00ed mismo. Luego se puede usar en otro lugar. No importa d\u00f3nde, todav\u00eda tiene acceso a las mismas variables externas.</p> <p>A continuaci\u00f3n, <code>makeCounter</code> crea la funci\u00f3n contador que devuelve el siguiente n\u00famero en cada invocaci\u00f3n:</p> <pre><code>function makeCounter() {\nconst count = 0;\nreturn function() {\nconst count++;\n};\n}\nconst counter = makeCounter();\nconsole.log(counter()) // 0\nconsole.log(counter()) // 1\nconsole.log(counter()) // 2\n</code></pre> <p>Las propiedades de la funci\u00f3n a veces pueden reemplazar las clausuras o closures. Por ejemplo, podemos reescribir este ejemplo para usar una propiedad de funci\u00f3n:</p> <pre><code>function makeCounter() {\nfunction counter() {\nreturn counter.count++\n}\ncounter.count = 0\nreturn counter;\n}\nconst counter = makeCounter()\nconsole.log(counter()) // 0\nconsole.log(counter()) // 1\n</code></pre> <p><code>count</code> ahora se almacena en la funci\u00f3n directamente, no en su entorno l\u00e9xico externo.</p> <p>Entonces, \u00bfusar una propiedad personalizada es mejor o peor que usar una clausura?  La principal diferencia es que si el valor de <code>count</code> vive en una variable externa, entonces el c\u00f3digo externo no puede acceder a \u00e9l. Solo las funciones anidadas pueden modificarlo. Y si est\u00e1 vinculado a una funci\u00f3n, entonces tal cosa es posible:</p> <pre><code>function makeCounter() {\nfunction counter() {\nreturn counter.count++\n}\ncounter.count = 0\nreturn counter\n}\nconst counter = makeCounter()\ncounter.count = 10;\nconsole.log(counter()) // 10\n</code></pre> <p>Por lo tanto, la elecci\u00f3n de la implementaci\u00f3n depende de nuestros objetivos.</p>"},{"location":"bloque_i/tema_5/page-6/#expresion-de-funcion-con-nombre","title":"Expresi\u00f3n de funci\u00f3n con nombre","text":"<p>Named Function Expression, o NFE, es un t\u00e9rmino para Expresiones de funciones que tienen un nombre:</p> <pre><code>const sayHi = function func(who) {\nconsole.log(`Hello, ${who}`)\n}\nsayHi()\n</code></pre> <p>Al usar <code>func</code> como nombre la funci\u00f3n no produce ning\u00fan cambio aparente. Sin embargo, esto permite poder acceder a las propiedades de la funci\u00f3n, haciendo referencia a ella de internamente, teniendo en cuenta que dicho nombre no es accesible fuera de ella.</p> <pre><code>const sayHi = function func(who) {\nif (who) {\nalert(`Hello, ${who}`)\n} else {\nfunc(\"Guest\")\n}\n}\nsayHi() // Hello, Guest\nfunc() // \u274cError\n</code></pre> <p>\u00bfPodemos usar <code>sayHi</code> como referencia de la funci\u00f3n de forma interna? La respuesta es s\u00ed, pero hay que tener en cuenta que la referencia a la variable <code>sayHi</code> puede cambiar:</p> <pre><code>let sayHi = function(who) {\nif (who) {\nconsole.log(`Hello, ${who}`)\n} else {\nsayHi(\"Guest\") // Error: sayHi no es una funci\u00f3n\n}\n}\nconst welcome = sayHi;\nsayHi = null;\nwelcome(); // \u274cError\n</code></pre> <p>Eso sucede porque la funci\u00f3n toma <code>sayHi</code> de su entorno l\u00e9xico externo. No hay <code>sayHi</code> local, por lo que se utiliza la variable externa. Y en el momento de la llamada, ese <code>sayHi</code> externo es nulo.</p> <p>El nombre opcional que podemos poner en la Expresi\u00f3n de funci\u00f3n est\u00e1 destinado a resolver exactamente este tipo de problemas.</p>"},{"location":"bloque_i/tema_5/page-6/#constructor-de-una-funcion","title":"Constructor de una funci\u00f3n","text":"<p>Como ya hemos visto, una funci\u00f3n es un objeto, por lo que podemos usar un constructor para poder crearla:</p> <pre><code>const func = new Function([arg1, arg2, ..., argN], body)\n</code></pre> <p>Al constructor se le pasa el n\u00famero de par\u00e1metros a usar en la funci\u00f3n y el cuerpo de la funci\u00f3n. Todo ello en cadena:</p> <pre><code>const sumar = new Function('a', 'b', 'return a + b')\nconsole.log(sumar(1, 2)) // 3\n</code></pre> <p>Tambi\u00e9n se puede crear una funci\u00f3n sin argumentos:</p> <pre><code>const sayHi = new Function('console.log(\"Hi!\")')\nsayHi()\n</code></pre> <p>La mayor diferencia sobre las otras maneras de crear funciones que hemos visto, es que la funci\u00f3n se crea desde un <code>string</code> y es pasada en tiempo de ejecuci\u00f3n. Las declaraciones anteriores nos obliga a los programadores, a escribir el c\u00f3digo de la funci\u00f3n en el script. Pero <code>new Function</code> nos permite convertir cualquier string en una funci\u00f3n. Por ejemplo, podemos recibir una nueva funci\u00f3n desde el servidor y ejecutarlo.</p> <p>Se utilizan en casos muy espec\u00edficos, como cuando recibimos c\u00f3digo de un servidor, o compilar din\u00e1micamente una funci\u00f3n a partir de una plantilla. La necesidad surge en etapas avanzadas de desarrollo.</p> <p>Normalmente, una funci\u00f3n recuerda d\u00f3nde naci\u00f3 en una propiedad especial llamada <code>[[Environment]]</code>, que hace referencia al entorno l\u00e9xico desde d\u00f3nde se cre\u00f3.</p> <p>Pero cuando una funci\u00f3n es creada usando new Function, su <code>[[Environment]]</code> no hace referencia al entorno l\u00e9xico actual, sino al global.</p> <p>Entonces, tal funci\u00f3n no tiene acceso a las variables externas, solo a las globales.</p> <pre><code>function getFunc() {\nconst valor = \"test\"\nconst func = new Function('console.log(valor)')\nreturn func\n}\ngetFunc()(); // \u274cerror: valor is not defined\n</code></pre> <p>De la forma normal, no habr\u00eda error:</p> <pre><code>function getFunc() {\nconst valor = \"test\"\nconst func = function() { console.log(valor) }\nreturn func\n}\ngetFunc()() // test\n</code></pre> <p>Esta caracter\u00edstica especial de <code>new Function</code> parece extra\u00f1a, pero resulta muy \u00fatil en la pr\u00e1ctica.</p> <p>Imagina que debemos crear una funci\u00f3n a partir de una <code>string</code>. El c\u00f3digo de dicha funci\u00f3n no se conoce al momento de escribir el script (es por eso que no usamos funciones regulares), sino que se conocer\u00e1 en el proceso de ejecuci\u00f3n. Podemos recibirlo del servidor o de otra fuente.</p> <p>Nuestra nueva funci\u00f3n necesita interactuar con el script principal. \u00bfQu\u00e9 pasa si pudiera acceder a las variables locales externas? El problema es que antes de publicar el JavaScript a producci\u00f3n, este es comprimido usando un minifier (un programa especial que comprime c\u00f3digo eliminando los comentarios extras, espacios y, lo que es m\u00e1s importante, renombra las variables locales a otras m\u00e1s cortas).</p> <p>Por ejemplo, si una funci\u00f3n tiene <code>let userName</code>, el minifier lo reemplaza con <code>let a</code> (u otra letra si \u00e9sta est\u00e1 siendo utilizada), y lo hace en todas partes. Esto normalmente es una pr\u00e1ctica segura, porque al ser una variable local, nada de fuera de la funci\u00f3n puede acceder a ella. Y dentro de una funci\u00f3n, el minifier reemplaza todo lo que la menciona. Los Minificadores son inteligentes, ellos analizan la estructura del c\u00f3digo, por lo tanto, no rompen nada. No realizan un simple buscar y reemplazar.</p> <p>Pero si <code>new Function</code> pudiera acceder a las variables externas, no podr\u00eda encontrar la variable <code>userName</code> renombrada. Si <code>new Function</code> tuviera acceso a variables externas, tendr\u00edamos problemas con los minificadores. Adem\u00e1s, tal c\u00f3digo ser\u00eda una mala arquitectura y propensa a errores. Para pasar algo a una funci\u00f3n creada como new Function, debemos usar sus argumentos.</p>"},{"location":"bloque_i/tema_5/page-7/","title":"Ejercicios","text":"Ejercicio 1 <p>Escribe la funci\u00f3n <code>isEmpty(obj)</code> que recibe un objeto, y comprueba si est\u00e1 vac\u00edo (devuelve <code>true</code>) o no (devuelve <code>false</code>).</p> Ejercicio 2 <p>Escribe una funci\u00f3n que te permita sumar los valores num\u00e9ricos de un objeto.</p> Ejercicio 3 <p>Aqu\u00ed la funci\u00f3n makeUser devuelve un objeto. \u00bfCu\u00e1l es el resultado de acceder a su <code>ref</code>? \u00bfPor qu\u00e9?</p> <pre><code>function makeUser() {\nreturn {\nname: \"John\",\nref: this\n}\n}\nconst user = makeUser()\nconsole.log(user.ref.name) // \u00bfCu\u00e1l es el resultado?\n</code></pre> Ejercicio 4 <p>Crea un objeto calculator con tres m\u00e9todos:</p> <ul> <li><code>read()</code> pide dos valores y los almacena como propiedades de objeto con nombres a y b.</li> <li><code>sum()</code> devuelve la suma de los valores almacenados.</li> <li><code>mul()</code> multiplica los valores almacenados y devuelve el resultado.</li> </ul>"},{"location":"bloque_i/tema_6/page-1/","title":"1 Arrays","text":""},{"location":"bloque_i/tema_6/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Hasta ahora, hemos visto los tipos de datos primitivos y hemos visto los objetos. En el tema anterior, introducimos el concepto de colecci\u00f3n como una estructura de datos, es decir, una estructura que se almacenan varios datos, como los objetos.</p> <p>Un array es una colecci\u00f3n de datos que permite almacenar una lista de diferentes tipos de datos. Una de las peculiaridades de est\u00e1 colecci\u00f3n es que me permite ordenar, a\u00f1adir y modificar datos entre los elementos de la colecci\u00f3n, a diferente de los objetos que estaban constractados con el nombre de una propiedad.</p>"},{"location":"bloque_i/tema_6/page-1/#declaracion","title":"Declaraci\u00f3n","text":"<p>Para declarar un array, se puede usar su constructor <code>new Array</code> o <code>[]</code>. Podemos crear un array vac\u00edo o con datos iniciales:</p> <pre><code>const fruit = [\"Apple\", \"Orange\", \"Plum\"]\nconst numbers = new Array(1, 2, 3)\n</code></pre>"},{"location":"bloque_i/tema_6/page-1/#acceso-a-un-elemento","title":"Acceso a un elemento","text":"<p>Para acceder a un elemento del array, se puede usar la siguiente estructura <code>array[index]</code>, siendo index la posici\u00f3n del elemento en la lista. Las posiciones en los arrays empiezan a contar desde 0. Por lo tanto, el primer elemento de un array tiene \u00edndice 0, el segundo \u00edndice 2, etc.</p> <pre><code>const fruit = [\"Apple\", \"Orange\", \"Plum\"]\nconsole.log(fruit[0])\nconsole.log(fruit[1])\nconsole.log(fruit[2])\n</code></pre> <p>Tambi\u00e9n podemos acceder a un elemento haciendo uso del m\u00e9todo <code>at(index)</code>. Si recibe un valor negativo, localiza el elemento desde el final del array:</p> <pre><code>const fruit = [\"Apple\", \"Orange\", \"Plum\"]\nconsole.log(fruit.at(1)) // Orange\nconsole.log(fruit.at(-1)) // Plum\n</code></pre>"},{"location":"bloque_i/tema_6/page-1/#propiedad-length","title":"Propiedad length","text":"<p>La propiedad <code>length</code> de los arrays devuelve el n\u00famero de elementos que contiene:</p> <pre><code>const fruit = [\"Apple\", \"Orange\", \"Plum\"]\nconsole.log(fruit.length) // 3\n</code></pre> <p>Tambi\u00e9n se puede utilizar para acceder al \u00faltimo elemento de un array de tama\u00f1o no conocido previamente, teniendo en cuenta que el \u00faltimo elemento no coincide con el valor de <code>length</code> si no con un previo, debido a que en los arrays se empiezan a contar desde 0:</p> <pre><code>const fruit = [\"Apple\", \"Orange\", \"Plum\"]\nconsole.log(fruit[fruit.length - 1]) // Plum\n</code></pre> <p>La propiedad <code>length</code> es una propiedad que puede ser modificable. Si se le incrementa, no ocurre nada rese\u00f1able, simplemente al acceder al elemento incrementado retornar\u00e1 un <code>undefined</code> (lo mismo si no existiera pero el tama\u00f1o es inferior). Mientras que, si es decrementado, el array se trunca con el n\u00famero de elementos indicados:</p> <pre><code>const fruit = [\"Apple\", \"Orange\", \"Plum\"]\nconsole.log(fruit.length) // 3\nconsole.log(fruit[3]) // undefined\nfruit.length = 5\nconsole.log(fruit) // [\"Apple\", \"Orange\", \"Plum\"]\nconsole.log(fruit[3]) // undefined\nfruit.length = 2\nconsole.log(fruit) // [\"Apple\", \"Orange\"]\n</code></pre> <p>Si se usa el constructor <code>new Array()</code> con un \u00fanico argumento num\u00e9rico, se est\u00e1 indicando el valor de la propiedad <code>length</code>, no creando un array cuyo valor \u00fanico es el n\u00famero indicado:</p> <pre><code>const array = new Array(2)\nconsole.log(array[0]) // undefined\nconsole.log(array.length) // 2\n</code></pre>"},{"location":"bloque_i/tema_6/page-1/#tipos-de-datos","title":"Tipos de datos","text":"<p>Dentro de un array, puede existir cualquier tipo de dato, desde un tipo primitivo, un objeto, una funci\u00f3n o incluso otro array. Aunque no es lo recomendado, esto es posible.</p> <pre><code>const array = [\"Hola\", 1, {name: \"John\"}, () =&gt; console.log('hola'), [1,2]]\n</code></pre>"},{"location":"bloque_i/tema_6/page-1/#recorrer-un-array","title":"Recorrer un array","text":"<p>Podemos recorrer un array, haciendo uso del bucle visto hasta ahora, teniendo en cuenta su propiedad <code>length</code>:</p> <pre><code>const arr = [\"Apple\", \"Orange\", \"Pear\"]\nfor (let i = 0; i &lt; arr.length; i++) {\nconsole.log(arr[i])\n}\n</code></pre> <p>Los arrays, al ser tambi\u00e9n objetos, tambi\u00e9n pueden usar el bucle <code>for..in</code> siendo su clave la posici\u00f3n que ocupa dentro del array:</p> <pre><code>const fruits = [\"Apple\", \"Orange\", \"Plum\"]\nfor (let key in arr) {\nconsole.log(arr[key])\n}\n</code></pre> <p>Aunque existe un bucle espec\u00edfico para recorrer los arrays. El bucle <code>for..of</code> recorre cada uno de los elementos del array. La diferencia con los dos anteriores, es que los dos anteriores recorren sus \u00edndices (en el caso de <code>for..in</code> como propiedades).</p> <pre><code>const fruits = [\"Apple\", \"Orange\", \"Plum\"]\nfor (let key of arr) {\nconsole.log(arr)\n}\n</code></pre>"},{"location":"bloque_i/tema_6/page-1/#arrays-multidimensionales","title":"Arrays multidimensionales","text":"<p>Los arrays pueden tener items que a su vez sean arrays. Podemos usarlos como arrays multidimensionales, por ejemplo para almacenar matrices:</p> <pre><code>const matrix = [\n[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]\n]\nconsole.log(matrix[1][1]) // 5, el elemento central\n</code></pre>"},{"location":"bloque_i/tema_6/page-1/#metodo-tostring","title":"M\u00e9todo toString","text":"<p>Los arrays tienen su propia implementaci\u00f3n del m\u00e9todo <code>toString</code> que devuelve un lista de elementos separados por coma. Los arrays no tienen <code>Symbol.toPrimitive</code> ni un <code>valueOf</code> viable, ellos implementan la conversi\u00f3n <code>toString</code> solamente, as\u00ed <code>[]</code> se vuelve una cadena vac\u00eda, <code>[1]</code> se vuelve \"1\" y <code>[1,2]</code> se vuelve \"1,2\".</p>"},{"location":"bloque_i/tema_6/page-1/#comparaciones-de-array","title":"Comparaciones de array","text":"<p>Las arrays en JavaScript, a diferencia de otros lenguajes de programaci\u00f3n, no deben ser comparadas con el operador <code>==</code>. Este operador no tiene un tratamiento especial para arrays, trabaja con ellas como con cualquier objeto, es decir, devolver\u00e1 <code>true</code> si se referencia a un objeto.</p> <p>La comparaci\u00f3n estricta <code>===</code> es a\u00fan m\u00e1s simple, ya que no convierte tipos, pero a\u00fan as\u00ed no compara los elementos del array. Para comparar los elementos de un array, ser\u00e1 necesario realizar un bucle e ir compar\u00e1ndolos.</p>"},{"location":"bloque_i/tema_6/page-1/#anadir-elementos","title":"A\u00f1adir elementos","text":"<p>Para a\u00f1adir elementos a un array, se puede inicializar el valor de la posici\u00f3n deseada en el que se desea a\u00f1adir el elemento:</p> <pre><code>const array = [1, 2, 3]\narray[3] = 10\nconsole.log(array) // [1,2,3,10]\n</code></pre> <p>Si se indica un \u00edndice superior al siguiente que deber\u00eda ser elegido (en el ejemplo, se elige el \u00edndice 3 por que es el que naturalmente tocar\u00eda), el resto de elementos se mantendr\u00e1 <code>undefined</code> y el elegido tendr\u00e1 el valor deseado. Es importante recalcar que el resto de \u00edndices no inicializados no ser\u00e1n mostrados a la hora de mostrar el array a trav\u00e9s de un <code>console.log</code>. Mientras que haciendo un <code>for</code> para recorrerla o haciendo uso de <code>toString</code> si veremos esos espacios dejados:</p> <pre><code>const array = [1, 2, 3]\narray[10] = 10\nconsole.log(array) // [1,2,3,10]\nconsole.log(array.toString()) // 1,2,3,,,,,,,10\n</code></pre> <p>Sin embargo, si se da un valor a un \u00edndice ya inicializado, en ese caso, el valor ser\u00e1 sobrescrito. Esto es una de las razones por lo que no se recomienda el uso de esta forma para rellenar un array.</p> <pre><code>const array = [1,2,3]\narray[1] = 3\nconsole.log(array) // [1,3,3]\n</code></pre> <p>Se puede hacer uso del m\u00e9todo <code>push(elements)</code> para a\u00f1adir todos los elementos que se desea al final del array:</p> <pre><code>const array = [1,2,3]\narray.push(4,5)\nconsole.log(array) // [1,2,3,4,5]\n</code></pre> <p>Haciendo uso del m\u00e9todo <code>unshift(element)</code> los elementos ser\u00e1n a\u00f1adidos al principio del array, desplazando as\u00ed los elementos que estaban al principio del array a la posici\u00f3n correspondiente:</p> <pre><code>const array = [1,2,3]\narray.unshift(4,5)\nconsole.log(array) // [4, 5, 1, 2, 3]\n</code></pre>"},{"location":"bloque_i/tema_6/page-1/#eliminar-elementos","title":"Eliminar elementos","text":"<p>Para eliminar un elemento del array, existen diferentes elementos, como <code>pop()</code> que toma el \u00faltimo elemento del array y lo devuelve:</p> <pre><code>const array = [1,2,3]\nconst element = array.pop()\nconsole.log(element, array) // 3, [1,2]\n</code></pre> <p>El m\u00e9todo <code>shift()</code> elimina el primer elemento y lo devuelve:</p> <pre><code>const array = [1,2,3]\nconst element = array.shift()\nconsole.log(element, array) // 1, [2,3]\n</code></pre> <p>El operador <code>delete</code> elimina el valor de una posici\u00f3n espec\u00edfica, dejando <code>undefined</code> en su lugar. Este m\u00e9todo no es recomendado ya que no elimina la posici\u00f3n del array:</p> <pre><code>const array = [1,2,3]\ndelete array[1]\nconsole.log(array) // [1, undefined, 3]\n</code></pre>"},{"location":"bloque_i/tema_6/page-10/","title":"10 Decoradores y redirecciones, call/apply","text":""},{"location":"bloque_i/tema_6/page-10/#introduccion","title":"Introducci\u00f3n","text":"<p>JavaScript ofrece una flexibilidad excepcional cuando se trata de funciones. Se pueden pasar, usar como objetos, y ahora veremos c\u00f3mo redirigir las llamadas entre ellas y decorarlas.</p> <p>Digamos que tenemos una funci\u00f3n <code>slow(x)</code>, que es pesada para la CPU, pero cuyos resultados son estables, es decir, que con la misma <code>x</code> siempre devuelve el mismo resultado.</p> <p>Si la funci\u00f3n se llama con frecuencia, es posible que queramos almacenar en cach\u00e9 (recordar) los resultados obtenidos para evitar perder tiempo en calcularlos de nuevo.</p> <p>Pero en lugar de agregar esta funcionalidad en <code>slow()</code>, crearemos una funci\u00f3n contenedora (en ingl\u00e9s wrapper, envoltorio) que agregue almacenamiento en cach\u00e9.</p> <p>Veamos el ejemplo:</p> <pre><code>function slow(x) {\n// puede haber un trabajo pesado de CPU aqu\u00ed\nconsole.log(`Called with ${x}`)\nreturn x\n}\nfunction cachingDecorator(func) {\nconst cache = {}\nreturn function(x) {\nif (x in cache) { return cache[x] // (1)!\n}\nconst result = func(x)  // (2)!\ncache[x] = result  // (3)!\nreturn result\n}\n}\nslow = cachingDecorator(slow)\nconsole.log(slow(1)) // (4)!\nconsole.log(\"Again: \" + slow(1)) // (5)!\nconsole.log(slow(2)) // (6)!\nconsole.log(\"Again: \" + slow(2)) // (7)!\n</code></pre> <ol> <li>si hay tal propiedad en cach\u00e9 lee el resultado</li> <li>de lo contrario llame a <code>func</code></li> <li>almacenamos en cach\u00e9 (recordamos) el resultado</li> <li>slow(1) es cacheado y se devuelve el resultado</li> <li>el resultado slow(1) es devuelto desde cach\u00e9</li> <li>slow(2) es cacheado y devuelve el resultado</li> <li>el resultado slow(2) es devuelto desde cach\u00e9</li> </ol>"},{"location":"bloque_i/tema_6/page-10/#decorador","title":"Decorador","text":"<p>En el c\u00f3digo anterior, <code>cachingDecorator</code> es un decorador: una funci\u00f3n especial que toma otra funci\u00f3n y altera su comportamiento.</p> <p>La idea es que podemos llamar a <code>cachingDecorator</code> para cualquier funci\u00f3n, y devolver el contenedor de almacenamiento en cach\u00e9. Eso es genial, porque podemos tener muchas funciones que podr\u00edan usar dicha funci\u00f3n, y todo lo que tenemos que hacer es aplicarles <code>cachingDecorator</code>.</p> <p>Al separar el cach\u00e9 del c\u00f3digo de la funci\u00f3n principal, tambi\u00e9n permite mantener el c\u00f3digo principal m\u00e1s simple.</p> <p>El resultado de <code>cachingDecorator(func)</code> es un contenedor: <code>function(x)</code> que envuelve la llamada de <code>func(x)</code> en la l\u00f3gica de almacenamiento en cach\u00e9:</p> <p> Figura 7 - Decorator</p> <p>Desde un c\u00f3digo externo, la funci\u00f3n <code>slow</code> envuelta sigue haciendo lo mismo. Simplemente se agreg\u00f3 un aspecto de almacenamiento en cach\u00e9 a su comportamiento.</p> <p>Para resumir, hay varios beneficios de usar un <code>cachingDecorator</code> separado en lugar de alterar el c\u00f3digo de <code>slow</code> en s\u00ed mismo:</p> <ul> <li>El <code>cachingDecorator</code> es reutilizable. Podemos aplicarlo a otra funci\u00f3n.</li> <li>La l\u00f3gica de almacenamiento en cach\u00e9 es independiente, no aument\u00f3 la complejidad de <code>slow</code> en s\u00ed misma (si hubiera alguna).</li> <li>Podemos combinar m\u00faltiples decoradores si es necesario.</li> </ul>"},{"location":"bloque_i/tema_6/page-10/#call","title":"call","text":"<p>El decorador de cach\u00e9 mencionado anteriormente no es adecuado para trabajar con m\u00e9todos de objetos. Por ejemplo, en el siguiente c\u00f3digo, <code>worker.slow()</code> deja de funcionar despu\u00e9s de la decoraci\u00f3n:</p> <pre><code>let worker = {\nsomeMethod() {\nreturn 1\n},\nslow(x) {\n// una aterradora tarea muy pesada para la CPU\nalert(\"Called with \" + x)\nreturn x * this.someMethod() // (1)!\n}\n}\n// el mismo c\u00f3digo de antes\nfunction cachingDecorator(func) {\nconst cache = {}\nreturn function(x) {\nif (x in cache) { return cache[x] }\nconst result = func(x)  // (2)!\ncache[x] = result  return result\n}\n}\nconsole.log(worker.slow(1)) // el m\u00e9todo original funciona\nworker.slow = cachingDecorator(worker.slow) // ahora hazlo en cach\u00e9\nconsole.log( worker.slow(2) ) // \u274c Error: Cannot read property 'someMethod' of undefined\n</code></pre> <ol> <li>El error ocurre en esta l\u00ednea que intenta acceder a this.someMethod y falla.</li> <li>La raz\u00f3n es que el contenedor llama a la funci\u00f3n original como <code>func(x)</code> en esta l\u00ednea. Y, cuando se llama as\u00ed, la funci\u00f3n obtiene <code>this = undefined</code>.</li> </ol> <p>El error ocurre cuando se intenta acceder a <code>this.someMethod</code> y falla debido que el contenedor llama a la funci\u00f3n original como <code>func(x)</code> y al llamarla as\u00ed la funci\u00f3n obtiene <code>this = undefined</code>.</p> <p>Entonces, el contenedor pasa la llamada al m\u00e9todo original, pero sin el contexto <code>this</code>.</p> <p>El m\u00e9todo <code>call(context, ...args)</code> permite llamar a una funci\u00f3n que estable expl\u00edcitamente el valor de <code>this</code>.</p> <pre><code>func(1, 2, 3);\nfunc.call(obj, 1, 2, 3)\n</code></pre> <p>Ambos llaman <code>func</code> con argumentos 1, 2 y 3. La \u00fanica diferencia es que <code>func.call</code> tambi\u00e9n establece <code>this</code> en <code>obj</code>.</p> <p>Como ejemplo, en el siguiente c\u00f3digo llamamos a <code>sayHi</code> en el contexto de diferentes objetos: <code>sayHi.call(user)</code> ejecuta <code>sayHi</code> estableciendo <code>this = user</code>, y la siguiente l\u00ednea establece <code>this = admin</code>:</p> <pre><code>function sayHi() {\nconsole.log(this.name)\n}\nconst user = { name: \"John\" }\nconst admin = { name: \"Admin\" }\nsayHi.call(user) // John\nsayHi.call(admin) // Admin\n</code></pre> <p>De esta forma, podemos solucionar nuestro problema anterior:</p> <pre><code>const worker = {\nsomeMethod() {\nreturn 1\n},\nslow(x) {\nalert(\"Called with \" + x);\nreturn x * this.someMethod()\n}\n}\nfunction cachingDecorator(func) {\nconst cache = {}\nreturn function(x) {\nif (x in cache) { return cache[x] }\nconst result = func(x)\ncache[x] = result  return result\n}\n}\nworker.slow = cachingDecorator(worker.slow)\nconsole.log(worker.slow(2))\nconsole.log(worker.slow(2))\n</code></pre> <p>Vamos a depurarlo, para ver el funcionamiento correctamente del <code>this</code>:</p> <ol> <li>Despu\u00e9s del decorador <code>worker.slow</code>, ahora el contenedor es <code>function(x) { ... }</code>.</li> <li>Entonces, cuando <code>worker.slow(2)</code> se ejecuta, el contenedor toma 2 como un argumento y a <code>this=worker</code> (objeto antes del punto).</li> <li>Dentro del contenedor, suponiendo que el resultado a\u00fan no se haya almacenado en cach\u00e9, <code>func.call(this, x)</code> pasa el <code>this</code> actual (<code>=worker</code>) y el argumento actual (<code>=2</code>) al m\u00e9todo original.</li> </ol>"},{"location":"bloque_i/tema_6/page-10/#decoradores-con-varios-argumentos","title":"Decoradores con varios argumentos","text":"<p>Hasta ahora, nuestro m\u00e9todo <code>cachingDecorator</code> nos permit\u00eda trabajar con funciones monoargumentales. Sin embargo, hay funciones de m\u00e1s de una funci\u00f3n. Hay muchas posibles soluciones:</p> <ol> <li>Implemente una nueva estructura de datos similar a un mapa (o use una de un tercero) que sea m\u00e1s vers\u00e1til y permita m\u00faltiples propiedades.</li> <li>Use objetos anidados: <code>cache[y]</code> ser\u00e1 un objeto que almacena el par <code>[x, result]</code>. As\u00ed podemos obtener result como <code>cache[y][x]</code>.</li> <li>Unir dos valores en uno. En nuestro caso particular, podemos usar un string <code>\"x,y\"</code> como la propiedad de un objeto. Por flexibilidad, podemos permitir proporcionar un funci\u00f3n hashing para el decorador, que sabe hacer un valor de muchos.</li> </ol> <p>Veamos la mejor, haciendo uso de la tercera forma:</p> <pre><code>const worker = {\nslow(min, max) {\nconsole.log(`Called with ${min},${max}`)\nreturn min + max\n}\n}\nfunction cachingDecorator(func, hash) {\nconst cache = {}\nreturn function() {\nconst key = hash(arguments); // (1)!\nif (key in cache) {\nreturn cache[key]\n}\nconst result = func.call(this, ...arguments); // (2)!\ncache[key] = result\nreturn result\n}\n}\nfunction hash(arguments) {\nreturn arg[0] + ',' + arg[1]\n}\nworker.slow = cachingDecorator(worker.slow, hash)\nconsole.log(worker.slow(3, 5))\nconsole.log(\"Again \" + worker.slow(3, 5))\n</code></pre> <ol> <li>Llama a <code>hash</code> para crear una sola propiedad de <code>arguments</code>. Aqu\u00ed usamos una simple funci\u00f3n de uni\u00f3n que convierte los argumentos <code>(3, 5)</code> en la propiedad <code>3,5</code>. Los casos m\u00e1s complejos pueden requerir otras funciones <code>hash</code>.</li> <li>Se usa <code>func.call(this, ...arguments)</code> para pasar tanto el contexto como todos los argumentos que obtuvo el contenedor (no solo el primero) a la funci\u00f3n original.</li> </ol> <p>Ahora funciona con cualquier n\u00famero de argumentos (aunque la funci\u00f3n <code>hash</code> tambi\u00e9n necesitar\u00eda ser ajustada para permitir cualquier n\u00famero de argumentos).</p> <p>Hagamos una \u00faltima mejora, usemos <code>Map</code>, en lugar de objetos:</p> <pre><code>const worker = {\nslow(min, max) {\nconsole.log(`Called with ${min},${max}`)\nreturn min + max\n}\n}\nfunction cachingDecorator(func, hash) {\nconst cache = new Map()\nreturn function() {\nconst key = hash(arguments)\nif (cache.has(key)) {\nreturn cache.get(key)\n}\nconst result = func.call(this, ...arguments)\ncache.set(key, result)\nreturn result\n}\n}\nfunction hash(arguments) {\nreturn arg[0] + ',' + arg[1]\n}\nworker.slow = cachingDecorator(worker.slow, hash)\nconsole.log(worker.slow(3, 5))\nconsole.log(\"Again \" + worker.slow(3, 5))\n</code></pre>"},{"location":"bloque_i/tema_6/page-10/#apply","title":"apply","text":"<p>En vez de <code>func.call(this, ...arguments)</code>, podr\u00edamos usar <code>func.apply(this, arguments)</code>. Ejecuta la configuraci\u00f3n <code>func</code>, usando <code>this = context</code> y usa un objeto tipo array <code>args</code> como lista de argumentos.</p> <p>La \u00fanica diferencia de sintaxis entre <code>call</code> y <code>apply</code> es que <code>call</code> espera una lista de argumentos, mientras que <code>apply</code> lleva consigo un objeto tipo matriz.</p>"},{"location":"bloque_i/tema_6/page-10/#prestamo-de-metodo","title":"Pr\u00e9stamo de m\u00e9todo","text":"<p>Al usar el m\u00e9todo <code>join()</code> dentro de la funci\u00f3n <code>hash</code> no funcionar\u00e1. Esto es debido a que estamos llamando a <code>hash(arguments)</code>, y el objeto <code>arguments</code> es iterable y s\u00edmil-array (no es un array real).</p> <p>Podemos evitar dicho error de la siguiente forma:</p> <pre><code>function hash() {\nconsole.log([].join.call(arguments)) // 1,2\n}\nhash(1, 2)\n</code></pre>"},{"location":"bloque_i/tema_6/page-10/#bind","title":"bind","text":"<p>En ciertas ocasiones, el <code>this</code> no puede ser utilizado dentro de una funci\u00f3n, ya sea porque no est\u00e9 vinculado a un objeto o por que se haya perdido.</p> <pre><code>function func(){\nconsole.log(this.username)\n}\nfunc()\n</code></pre> <p>Con el m\u00e9todo <code>bind(context)</code> se puede vincular un contexto a una funci\u00f3n de forma, que si se pierde <code>this</code> pueda ser reutilizado.</p> <pre><code>const boundFunc = func.bind(context)\n</code></pre> <p>El resultado de <code>func.bind(context)</code> es un objeto ex\u00f3tico, una funci\u00f3n similar a una funci\u00f3n regular que se puede llamar como funci\u00f3n; esta pasa la llamada de forma transparente a <code>func</code> estableciendo <code>this = context</code>.</p> <pre><code>const user = {\nfirstName: \"John\"\n}\nfunction func() {\nconsole.log(this.firstName)\n}\nconst funcUser = func.bind(user)\nfuncUser()\n</code></pre> <p>Todos los argumentos se pasan al <code>func</code> original tal cual, por ejemplo:</p> <pre><code>const user = {\nfirstName: \"John\"\n}\nfunction func(phrase) {\nconsole.log(phrase + ', ' + this.firstName)\n}\nconst funcUser = func.bind(user);\nfuncUser(\"Hello\") // Hello, John\n</code></pre>"},{"location":"bloque_i/tema_6/page-11/","title":"11 Polyfills y transpiradores","text":""},{"location":"bloque_i/tema_6/page-11/#introduccion","title":"Introducci\u00f3n","text":"<p>El lenguaje JavaScript evoluciona constantemente. Nuevas propuestas al lenguaje aparecen regularmente, son analizadas y, si se consideran valiosas, se agregan a la lista en https://tc39.github.io/ecma262/ y luego avanzan a la especificaci\u00f3n.</p> <p>Los equipos de desarrollo detr\u00e1s de los int\u00e9rpretes (engines) de JavaScript tienen sus propias ideas sobre qu\u00e9 implementar primero. Pueden decidir implementar propuestas que est\u00e1n en borrador y posponer cosas que ya est\u00e1n en la especificaci\u00f3n porque son menos interesantes o simplemente porque son m\u00e1s dif\u00edciles de hacer.</p> <p>Por lo tanto, es bastante com\u00fan para un int\u00e9rprete implementar solo parte del est\u00e1ndar.</p> <p>Una buena p\u00e1gina para ver el estado actual de soporte de caracter\u00edsticas del lenguaje es https://kangax.github.io/compat-table/es6/ (es grande, todav\u00eda tenemos mucho que aprender).</p> <p>Por un lado, siempre es interesante usar las nuevas funcionalidades. Por otro lado, \u00bfc\u00f3mo hacer que nuestro c\u00f3digo moderno funcione en int\u00e9rpretes m\u00e1s viejos que a\u00fan no entienden las caracter\u00edsticas m\u00e1s nuevas?</p> <p>Hay dos herramientas para ello:</p> <ul> <li>Transpiladores</li> <li>Polyfills.</li> </ul>"},{"location":"bloque_i/tema_6/page-11/#transpiladores","title":"Transpiladores","text":"<p>Un transpilador es un software que traduce un c\u00f3digo fuente a otro c\u00f3digo fuente. Puede analizar (leer y entender) c\u00f3digo moderno y reescribirlo usando sintaxis y construcciones m\u00e1s viejas para que tambi\u00e9n funcione en int\u00e9rpretes antiguos.</p> <p>Por ejemplo, antes del a\u00f1o 2020 JavaScript no ten\u00eda el operador nullish coalescing <code>??</code>. Entonces, si un visitante lo usa en un navegador desactualizado, este fallar\u00eda en entender un c\u00f3digo como <code>height = height ?? 100</code>.</p> <p>Un transpilador analizar\u00eda nuestro c\u00f3digo y reescribir\u00eda <code>height ?? 100</code> como <code>(height !== undefined &amp;&amp; height !== null) ? height : 100</code>.</p> <pre><code>// antes de ejecutar el transpilador\nheight = height ?? 100\n// despu\u00e9s de ejecutar el transpilador\nheight = (height !== undefined &amp;&amp; height !== null) ? height : 100\n</code></pre> <p>Ahora el c\u00f3digo rescrito es apto para los int\u00e9rpretes de JavaScript m\u00e1s viejos.</p> <p>Usualmente, un desarrollador ejecuta el transpilador en su propia computadora y luego despliega el c\u00f3digo transpilado al servidor.</p> <p>Acerca de nombres, Babel es uno de los m\u00e1s prominentes transpiladores circulando.</p> <p>Sistemas de desarrollo de proyectos modernos, tales como webpack, brindan los medios para ejecutar la transpilaci\u00f3n autom\u00e1tica en cada cambio de c\u00f3digo, haciendo muy f\u00e1cil la integraci\u00f3n al proceso de desarrollo.</p>"},{"location":"bloque_i/tema_6/page-11/#polyfills","title":"Polyfills","text":"<p>Nuevas caracter\u00edsticas en el lenguaje pueden incluir no solo construcciones sint\u00e1cticas y operadores, sino tambi\u00e9n funciones integradas.</p> <p>Por ejemplo, <code>Math.trunc(n)</code> es una funci\u00f3n que corta la parte decimal de un n\u00famero, ej. <code>Math.trunc(1.23) devuelve 1</code>.</p> <p>En algunos (muy desactualizados) int\u00e9rpretes JavaScript no existe <code>Math.trunc</code>, as\u00ed que tal c\u00f3digo fallar\u00e1.</p> <p>Aqu\u00ed estamos hablando de nuevas funciones, no de cambios de sintaxis. No hay necesidad de transpilar nada. Solo necesitamos declarar la funci\u00f3n faltante.</p> <p>Un script que actualiza o agrega funciones nuevas es llamado polyfill. Este llena los vac\u00edos agregando las implementaciones que faltan.</p> <p>En este caso particular, el polyfill para <code>Math.trunc</code> es un script que lo implementa:</p> <pre><code>if (!Math.trunc) {\nMath.trunc = function(number) {\nreturn number &lt; 0 ? Math.ceil(number) : Math.floor(number);\n}\n}\n</code></pre> <p>JavaScript es un lenguaje muy din\u00e1mico, los scripts pueden agregar o modificar cualquier funci\u00f3n, incluso las integradas.</p> <p>Dos librer\u00edas interesantes de polyfills son:</p> <ul> <li><code>core js</code> \u2013 da much\u00edsimo soporte, pero permite que se incluyan solamente las caracter\u00edsticas necesitadas.</li> <li><code>polyfill.io</code> \u2013 servicio que brinda un script con polyfills dependiendo de las caracter\u00edsticas del navegador del usuario.</li> </ul>"},{"location":"bloque_i/tema_6/page-11/#metodos-de-extension","title":"M\u00e9todos de extensi\u00f3n","text":"<p>Un m\u00e9todo de extensi\u00f3n es un m\u00e9todo que se crear y se a\u00f1ade a un objeto ya creado (normalmente a uno global) que permite reutilizarlo con la sintaxis <code>obj.func()</code>.</p> <p>De la misma forma que podemos usar polyfills para utilizar funciones modernas en entornos no actualizados, podemos crear m\u00e9todos de extensi\u00f3n.</p> <pre><code>Array.last = function(){\nreturn this[this.length - 1]\n}\nconst array = [1, 2, 3]\nconsole.log(array.last())\n</code></pre> <p>Es importante tener ciertas consideraciones:</p> <ul> <li>Verificar la Existencia: Siempre verifica si el m\u00e9todo ya existe antes de a\u00f1adirlo para evitar sobrescribir m\u00e9todos existentes, lo que podr\u00eda causar conflictos o errores.</li> <li>No Sobrescribir M\u00e9todos Nativos: Nunca sobrescribas m\u00e9todos nativos existentes. Esto puede romper el comportamiento esperado del c\u00f3digo y hacer que sea incompatible con otros scripts o futuras versiones de JavaScript.</li> <li>Modificaci\u00f3n Local: Si solo necesitas estos m\u00e9todos en una parte espec\u00edfica de tu aplicaci\u00f3n, considera encapsularlos dentro de esa parte del c\u00f3digo en lugar de modificar los prototipos globalmente.</li> </ul> <p>Tambi\u00e9n es conveniente conocer la diferente entre m\u00e9todo de extensi\u00f3n y polyfill. Un m\u00e9todo de extensi\u00f3n se refiere a la adici\u00f3n de nuevos m\u00e9todos a los prototipos de objetos nativos para proporcionar funcionalidad adicional que no est\u00e1 incluida originalmente en el lenguaje. Estos m\u00e9todos no son necesariamente parte de ninguna especificaci\u00f3n del lenguaje, sino que son creados para satisfacer necesidades espec\u00edficas del desarrollador. Sin embargo, un polyfill es un fragmento de c\u00f3digo (normalmente JavaScript en un entorno web) que proporciona la implementaci\u00f3n de una funcionalidad que est\u00e1 prevista en una especificaci\u00f3n de JavaScript, pero que puede no estar disponible en algunos entornos m\u00e1s antiguos o espec\u00edficos del usuario. Los polyfills permiten que el c\u00f3digo que utiliza estas caracter\u00edsticas funcione en navegadores o entornos que no las soportan nativamente.</p>"},{"location":"bloque_i/tema_6/page-12/","title":"Ejercicios","text":"Ejercicio 1 <p>Realiza la siguientes operaciones:</p> <ol> <li>Crear un array styles con los items \u201cJazz\u201d y \u201cBlues\u201d.</li> <li>Agregar \u201cRock-n-Roll\u201d al final.</li> <li>Reemplazar el valor en el medio por \u201cClassics\u201d. Tu c\u00f3digo para encontrar el valor medio debe funcionar con cualquier array de longitud impar.</li> <li>Quitar el primer valor del array y mostrarlo.</li> <li>Anteponer Rap y Reggae al array.</li> </ol> Ejercicio 2 <p>\u00bfCu\u00e1l es la salida de este c\u00f3digo? Justifica tu respuesta:</p> <pre><code>let arr = [\"a\", \"b\"];\narr.push(function() {\nalert( this );\n});\narr[2](); // ?\n</code></pre> Ejercicio 3 <p>Escribe una funci\u00f3n <code>sumInput()</code> que calcule la suma de todos los items del array y lo devuelva.</p> <p>Luego pida al usuario valores usando prompt y los almacene en el array. Termine de pedirlos cuando el usuario ingrese un valor no num\u00e9rico, una cadena vac\u00eda, o presione Esc.</p> Ejercicio 4 <p>Realiza una funci\u00f3n llamada <code>reduce</code> que reciba un callback con la operaci\u00f3n a realizar sobre el array. Por ejemplo, si se quiere sumar, recibir\u00e1 un callback, que realice la suma.</p> Ejercicio 5 <p>Realiza un m\u00e9todo, que dada una propiedad CSS, elimine los guiones <code>-</code> y cree una \u00fanica cadena de forma lowerCamelCase. Por ejemplo, para la propiedad <code>background-color</code> el m\u00e9todo debe retornar <code>backgroundColor</code>.</p> Ejercicio 6 <p>Escribe una funci\u00f3n <code>filterRange(arr, a, b)</code> que obtenga un array, busque los elementos con valor mayor o igual a <code>a</code> y menor o igual a <code>b</code> y devuelva un array con los resultados.</p> Ejercicio 7 <p>Realiza un m\u00e9todo que retorne un array ordenado de forma descendiente.</p> Ejercicio 8 <p>Realiza un m\u00e9todo que dado un array de objetos, obtenga un array \u00fanicamente con la propiedad nombre. Si el objeto no tiene dicha propiedad, no ser\u00e1 a\u00f1adido de ninguna forma al array resultado.</p> Ejercicio 9 <p>Realiza el mismo ejercicio anterior, pero que devuelva una propiedad indicada como par\u00e1metro.</p> Ejercicio 10 <p>Realiza un m\u00e9todo que dado un array de personas (nombre, apellidos y edad), retorne un nuevo array de personas con las propiedades (nombreCompleto y edad).</p> Ejercicio 11 <p>Realiza una funci\u00f3n que baraje un array.</p> Ejercicio 12 <p>Realiza un m\u00e9todo que dado un array de alumnos (nombre, nota), devuelva la nota media del array.</p> Ejercicio 13 <p>Realiza un m\u00e9todo que retorne un array sin elementos duplicados. Solamente se deben usar m\u00e9todos de arrays</p> Ejercicio 14 <p>Realiza un m\u00e9todo que dado un array de objetos, retorne un objeto que agrupe todos los objetos del array por la propiedad indicada. Por ejemplo:</p> <pre><code>const users = [\n{id: 1, name: \"Ismael\", course: \"1\u00baD\"},\n{id: 2, name: \"Anna\", course: \"1\u00baD\"},\n{id: 3, name: \"Sophie\", course: \"1\u00baB\"},\n{id: 4, name: \"Taylor\", course: \"1\u00baB\"}\n]\nconsole.log(yourMethod(users, course))\n/*\n{\n    \"1\u00baD\" : [\n        {id: 1, name: \"Ismael\"},\n        {id: 2, name: \"Anna\"}\n    ],\n    \"1\u00baB\": [\n        {id: 3, \"Sophie\"},\n        {id: 4, \"Taylor\"}\n    ]\n}\n*/    </code></pre> Ejercicio 15 <p>Dado un objecto con salarios, crea un m\u00e9todo que devuelva la suma de los salarios.</p> Ejercicio 16 <p>Crea un m\u00e9todo que cuente las propiedades de un objeto.</p> Ejercicio 16 <p>Crea un m\u00e9todo que devuelva un array sin repetidos. Haz uso de los conjuntos</p> Ejercicio 17 <p>Se desea acceder a las claves de un mapa, y aplicarle el m\u00e9todo <code>push(value)</code> para a\u00f1adirle un nuevo valor. Sin embargo, al ejecutar el siguiente c\u00f3digo obtenemos un error. Observa el siguiente c\u00f3digo, y justifica porque da un error e intenta solucionarlo para que nos permita ejecutar el c\u00f3digo.</p> <pre><code>let map = new Map();\nmap.set(\"name\", \"John\");\nlet keys = map.keys();\n// Error: keys.push no es una funci\u00f3n\nkeys.push(\"more\");\n</code></pre> Ejercicio 18 <p>Dado el siguiente objeto:</p> <pre><code>const user = {\nname: \"John\",\nyears: 30\n}\n</code></pre> <p>Escriba la asignaci\u00f3n desestructurante que asigne las propiedades:</p> <ul> <li><code>name</code> en la variable <code>name</code>.</li> <li><code>years</code> en la variable <code>age</code>.</li> <li><code>isAdmin</code> en la variable <code>isAdmin</code> (<code>false</code>, si no existe tal propiedad)</li> </ul> Ejercicio 19 <p>Crear la funci\u00f3n <code>topSalary(salaries)</code> que devuelva el nombre de la persona mejor pagada.</p> <ul> <li>Si salaries es vac\u00edo, debe devolver null.</li> <li>Si hay varias personas con la mejor paga, devolver cualquiera de ellas.</li> </ul> <p>Utilice <code>Object.entries</code> y destructuraci\u00f3n para iterar sobre pares de claves/valores.</p> Ejercicio 20 <p>Crea un objeto <code>Date</code> para la fecha: <code>Feb 20, 2012, 3:12am</code>. La zona horaria es local. Obt\u00e9n la misma salida por consola.</p> Ejercicio 21 <p>Crea una funci\u00f3n <code>getDateAgo(date, days)</code> que devuelva el d\u00eda del mes que corresponde, contando la cantidad de d\u00edas days respecto de la fecha date.</p> <p>Por ejemplo, si hoy es 20, entonces <code>getDateAgo(new Date(), 1)</code> deber\u00eda ser 19 y <code>getDateAgo(new Date(), 2)</code> deber\u00eda ser 18.</p> Ejercicio 22 <p>Escribe una funci\u00f3n <code>getLastDayOfMonth(year, month)</code> que devuelva el \u00faltimo d\u00eda del mes dado. A veces es 30, 31 o incluso 28/29 para febrero.</p> Ejercicio 23 <p>Escribe una funci\u00f3n <code>getSecondsToday()</code>que devuelva la cantidad de segundos transcurridos desde el comienzo del d\u00eda.</p> Ejercicio 24 <p>Crea una funci\u00f3n <code>getSecondsToTomorrow()</code> que devuelva la cantidad de segundos que faltan para el d\u00eda de ma\u00f1ana.</p> Ejercicio 25 <p>Crea un programa que transforme un objeto a cadena JSON y viceversa.</p>"},{"location":"bloque_i/tema_6/page-2/","title":"2 M\u00e9todos arrays","text":""},{"location":"bloque_i/tema_6/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Existen diferentes m\u00e9todos para trabajar con arrays. Algunos de ellos sirven para modificar el array original, a\u00f1adiendo o eliminando elementos de una forma m\u00e1s compleja de la vista hasta ahora, mientras que otros m\u00e9todos sirven para poder recorrer el array, encontrar elementos dentro del mismo, entre otras cosas.</p>"},{"location":"bloque_i/tema_6/page-2/#metodos-para-anadirreemplazareliminar-elementos","title":"M\u00e9todos para a\u00f1adir/reemplazar/eliminar elementos","text":"<p>El m\u00e9todo <code>splice(start, [deleteCount, elem1, ..., elemN])</code> es un m\u00e9todo multiuso, usado para poder eliminar, a\u00f1adir o reemplazar elementos de un array. Modifica el array desde la posici\u00f3n start indicada, eliminado los elementos deseados (deleteCount) y a\u00f1adiendo en su lugar los elementos indicados. Adem\u00e1s, devuelve un array con los elementos eliminados</p> <pre><code>const array = [1,2,3]\nconst result = array.splice(1, 1, 10) console.log(array) // [1, 10, 3]\nconsole.log(result) // [2]\n</code></pre> <p>En el ejemplo anterior, se ha localizado el elemento del array que comienza en la posici\u00f3n 1, se ha eliminado un \u00fanico elemento a partir de ese indice (el 2), y a partir del mismo se ha a\u00f1adido el elemento nuevo (10).</p> <p>El m\u00e9todo puede ser usado \u00fanicamente para eliminar elementos:</p> <pre><code>const array = [1, 2, 3, 4, 5, 6]\narray.splice(2, 3)\nconsole.log(array) // [1, 2, 6]\n</code></pre> <p>Adem\u00e1s, si se indican m\u00e1s elementos de reemplazo que elementos eliminados, estos elementos se a\u00f1aden ocupando las posiciones pertinentes, desplazando los elementos posteriores si es necesario:</p> <pre><code>const array = [1, 2, 3, 4, 5, 6]\narray.splice(2, 3, 7, 8, 9 , 10, 11)\nconsole.log(array) // [1, 2, 7, 8, 9, 19, 11, 6]\n</code></pre> <p>Tambi\u00e9n puede ser usado para a\u00f1adir elementos indicando una cantidad de 0 a eliminar. En este caso a\u00f1adir\u00e1 elementos a partir del \u00edndice indicado, desplazando si es necesario los elementos posteriores:</p> <pre><code>const array = [1, 2, 3, 4]\narray.splice(1, 0, 5)\nconsole.log(array) // [1, 2, 5, 3, 4]\n</code></pre> <p>Se pueden utilizar \u00edndices negativos para indicar la posici\u00f3n del array a localizar. En este caso, la b\u00fasqueda comenzar\u00e1 desde el final:</p> <pre><code>const array = [1, 2, 5]\narray.splice(-1, 0, 3, 4)\nconsole.log(array) // [1, 2, 3, 4, 5]\n</code></pre> <p>El m\u00e9todo <code>slice([start], [end])</code> devuelve un nuevo array con los elementos comprendidos entre start y end (no inclusive). Ambas posiciones pueden ser negativas, y se obtendr\u00eda a partir del final del array:</p> <pre><code>const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconst other = array.slice(3, 6)\nconsole.log(other) // [4, 5, 6]\n</code></pre> <p>Si no se indica el segundo par\u00e1metro, el nuevo array obtenido coge los elementos desde la posici\u00f3n indica hasta el final</p> <pre><code>const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconst other = array.slice(-2)\nconsole.log(other) // [9, 10]\n</code></pre> <p>Tambi\u00e9n puede ser usado sin argumentos. En este caso, se hace una copia del array completo sin referencia, es decir, que puede ser manipulado sin modificar el array original:</p> <pre><code>const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconst other = array.slice()\nconsole.log(other) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre> <p>El m\u00e9todo <code>concat(...args)</code> es un m\u00e9todo que devuelve un nuevo array concatenando los arrays dados. Se le puede pasar tanto arrays, como elementos:</p> <pre><code>const array = [1,2,3]\nconst newArray = array.concat([3, 4], 5, 6)\nconsole.log(newArray) // [1, 2, 3, 4, 5, ,6]\n</code></pre> <p>Un objeto puede ser considerado como un array, si su propiedad <code>Symbol.isConcatSpreadable</code> es <code>true</code>. En dicho caso, al concatenar un objeto a un array, no lo a\u00f1ade como elemento, si no que que cada valor, se concatena al array como un elemento:</p> <pre><code>const array = [1,2,3]\nconst obj = {\n0: 4,\n1: 5,\n[Symbol.isConcatSpreadable]: true,\nlength: 2\n}\nconst newArray = array.concat(obj)\nconsole.log(newArray) // [1,2,3,4,5]\n</code></pre> <p>Ten en cuenta, que un array debe tener una propiedad <code>length</code>, por lo que si un objeto debe ser tratado como un array tambi\u00e9n debe contener esta propiedad.</p>"},{"location":"bloque_i/tema_6/page-2/#metodos-para-busqueda-de-elementos","title":"M\u00e9todos para b\u00fasqueda de elementos","text":"<p>Los m\u00e9todos <code>indexOf(item, from)</code>, <code>lastIndexOf(item, from)</code> e <code>includes(item, from)</code> tiene una funcionalidad parecida a los m\u00e9todos de las cadenas:</p> <pre><code>const array = [1, 2, 0, false, 2]\nconsole.log(array.indexOf(2)) // 1\nconsole.log(array.indexOf(2, -3)) // 4\nconsole.log(array.lastIndexOf(false)) // 3\nconsole.log(array.lastIndexOf(0)) // 2\nconsole.log(array.includes(1)) // true\n</code></pre> <p>Hay que tener en cuenta que las b\u00fasquedas se hace de forma estricta, por ello en el ejemplo, al intentar localizar <code>false</code>, devuelve el \u00edndice 3 y no el 2, ya que b\u00fasqueda la coincidencia exacta (<code>===</code>)</p> <p>Existen otros m\u00e9todos de b\u00fasqueda como el m\u00e9todo <code>find(callback)</code> que recibe una callback. Este m\u00e9todo va recorriendo elemento a elemento del array aplic\u00e1ndole la callback. El m\u00e9todo retornar\u00e1 el primer elemento que devuelva <code>true</code> al aplicarle la callback. La callback puede recibir tres argumentos:</p> <ul> <li><code>item</code>. Elemento al que se quiere realizar la callback.</li> <li><code>index</code>. \u00cdndice del elemento. Es opcional.</li> <li><code>array</code>. El array original. Es opcional.</li> </ul> <p>Al aplicarle la callback a cada uno de los elementos, retornar\u00e1 el primer elemento que devuelva <code>true</code>. Supongamos, que tenemos un array de objetos y se desea obtener el primer elemento cuya id sea igual a 1:</p> <pre><code>const users = [\n{id: 1, name: \"Celina\"},\n{id: 2, name: \"David\"},\n{id: 3, name: \"Federico\"}\n]\nconst user = user.find(function(item,index, array){\nreturn item.id === 1\n})\nconsole.log(user) // {id: 1, name: \"Celina\"}\n</code></pre> <p>Al ser una callback, puede ser usada con funciones de flecha, y adem\u00e1s se puede omitir los par\u00e1metros opcionales si no van ser usados:</p> <pre><code>const users = [\n{id: 1, name: \"Celina\"},\n{id: 2, name: \"David\"},\n{id: 3, name: \"Federico\"}\n]\nconst user = user.find((item) =&gt; item.id === 1)\nconsole.log(user) // {id: 1, name: \"Celina\"}\n</code></pre> <p>El m\u00e9todo <code>findIndex(callback)</code> tiene el mismo funcionamiento. Sin embargo, en lugar de retornar el elemento, retorna su \u00edndice. <code>findLastIndex(callback)</code> realiza la b\u00fasqueda desde el final.</p> <pre><code>const users = [\n{id: 1, name: \"John\"},\n{id: 2, name: \"Pete\"},\n{id: 3, name: \"Mary\"},\n{id: 4, name: \"John\"}\n]\nconsole.log(users.findIndex(user =&gt; user.name == 'John')) // 0\nconsole.log(users.findLastIndex(user =&gt; user.name == 'John')) // 3\n</code></pre> <p>El m\u00e9todo <code>filter(callback)</code> recibe una callback similar al del m\u00e9todo <code>find(callback)</code>, pero <code>filter(callback)</code> retorna todos los elementos que al aplicarle la callback devuelvan <code>true</code>. Por lo que, en este caso, no devuelve un \u00fanico elemento, si no un array:</p> <pre><code>const users = [\n{id: 1, name: \"Celina\"},\n{id: 2, name: \"David\"},\n{id: 3, name: \"Federico\"}\n]\nconst someUsers = users.filter(item =&gt; item.id &lt; 3)\nconsole.log(someUsers.length) // 2\n</code></pre>"},{"location":"bloque_i/tema_6/page-2/#metodos-para-la-iteracion","title":"M\u00e9todos para la iteraci\u00f3n","text":"<p>El m\u00e9todo <code>forEach(callback)</code> recibe un callback y va recorriendo el array elemento a elemento aplicando el callback. El callback, a diferencia del m\u00e9todo <code>find(callback)</code> no retorna nada. El callback recibe los mismo argumentos que las funciones anteriores (<code>item</code>, <code>index</code>, <code>array</code>)</p> <pre><code>[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach((item, index, array) =&gt; {\nconsole.log(`${item} is at index ${index} in ${array}`)\n})\n</code></pre> <p>La funci\u00f3n <code>forEach(callback)</code> tampoco devuelve nada.</p>"},{"location":"bloque_i/tema_6/page-2/#transformar-un-array","title":"Transformar un array","text":"<p>El m\u00e9todo <code>map(callback)</code> recorre cada elemento del array aplic\u00e1ndole el callback. Este callback debe retorna un nuevo elemento. Normalmente se utiliza para transformar cada uno de los elementos del array.</p> <pre><code>const array = [1, 2, 3]\nconst mapped = array.map(item =&gt; item * item)\nconsole.log(mapped) // [1, 4, 9]\n</code></pre> <p>El m\u00e9todo <code>map(callback)</code>retorna un nuevo array con los elementos modificados. Tambi\u00e9n se suele utilizar para transformar el tipo del array en otro. Por ejemplo, supongamos que tenemos un array de cadenas y queremos obtener un array con el tama\u00f1o de cada uno de ellas:</p> <pre><code>const lengths = [\"Bilbo\", \"Gandalf\", \"Nazgul\"].map(item =&gt; item.length)\nconsole.log(lengths) // 5,7,6\n</code></pre> <p>El m\u00e9todo <code>sort()</code> ordena el array deseado. Adem\u00e1s, retorna un nuevo array con los elementos ordenados, pero puede ser omitido, ya que tambi\u00e9n ordena el array original.</p> <pre><code>const arr = [ 1, 2, 15 ]\narr.sort();\nconsole.log(arr) // [1, 15, 2]\n</code></pre> <p>El array es ordenado, PERO SE ORDENA SUS ELEMENTOS COMO SI FUESEN CADENAS. Para indicar un orden diferente, ser\u00e1 necesario indicarle una callback que reciba dos elementos del array y retorne un n\u00famero. Suponiendo que tenemos dos elementos <code>a</code> y <code>b</code>, si la callback retorna:</p> <ul> <li>un n\u00famero positivo, quiere decir que el primer elemento <code>a</code> es mayor que el segundo elemento <code>b</code>.</li> <li>un n\u00famero negativo, quiere decir que el primer elemento <code>a</code> es menor que el segundo elemento <code>b</code>.</li> <li>cero, quiere decir que ambos elementos son iguales.</li> </ul> <pre><code>const array = [1, 2, 15]\nfunction compare(a,b){\nif(a &lt; b) return -1\nif(a &gt; b) return 1\nif(a === b) return 0\n}\narray.sort(compare)\nconsole.log(array) // [1, 2, 15]\n</code></pre> <p>El m\u00e9todo <code>compare</code> debe ser modificado para cada tipo de dato a comparar.</p> <p>Ahora, veamos el m\u00e9todo <code>reverse()</code> cuya funci\u00f3n es encarga de revertir el array, devolviendo as\u00ed un nuevo array revertido.</p> <pre><code>const array = [1,2,3]\nconsole.log(array.reverse()) // [3,2,1]\n</code></pre> <p>Las cadenas tienen un m\u00e9todo llamado <code>split([delimite], [length])</code> que retorna un array como elementos a las subcadenas que se encuentran antes y despu\u00e9s del delimitador indicado. Por ejemplo, si tenemos una cadena con nombre de las personas separados por coma, podemos obtener un array de cadenas, cuyo elementos ser\u00e1n cada nombre. Adem\u00e1s puede recibir un segundo argumento con el n\u00famero de elementos a a\u00f1adir al array:</p> <pre><code>const usersString = \"Cecilia, David, John, Luc\u00eda\"\nconst array = usersString.split(\", \", 2)\nconsole.log(array) // [Cecilia, David]\n</code></pre> <p>Si no recibe ning\u00fan argumento, retorna un array con la cadena como \u00fanico argumento.</p> <p>Existe una funci\u00f3n con un objetivo contrario. El m\u00e9todo <code>join([glue])</code> retorna una cadena uniendo cada uno de los elementos del array con el car\u00e1cter de uni\u00f3n (glue) indicado. Si no se indica ninguno, se usar\u00e1 la coma <code>,</code> por defecto</p> <pre><code>const array = ['Bilbo', 'Gandalf', 'Nazgul']\nconsole.log(array.join(';')) // Bilbo;Gandalf;Nazgul\nconsole.log(array.join()) // Bilbo,Gandalf,Nazgul\n</code></pre> <p>El m\u00e9todo <code>reduce(callback, [initialValue])</code> tiene como objetivo reducir un array a un simple valor. Su callback es una funci\u00f3n un poco m\u00e1s compleja de lo visto hasta ahora. Al usar dicha funci\u00f3n se va recorriendo el array, aplic\u00e1ndole el callback, almacenando el valor devuelto por la misma en una variable acumuladora, que a su vez se le pasa como argumento a la funci\u00f3n <code>reduce</code>. Una vez finalizada la iteraci\u00f3n retorna el valor final del acumulador. Por este motivo, la callback recibe los siguientes argumentos:</p> <ul> <li><code>accumulator</code>. Es el valor del acumulador de la funci\u00f3n. Su valor inicial coincide con el par\u00e1metro <code>initial</code> de la funci\u00f3n <code>reduce</code> o por el contrario con el primer valor del array.</li> <li><code>item</code>. Elemento del array.</li> <li><code>index</code>. Indice del elemento del array.</li> <li><code>array</code>. El array en s\u00ed.</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>const array = [1,2,3,4]\nconst value = array.reduce((sum, current) =&gt; sum + current, 0) console.log(value) // 10\n</code></pre> <p>En el ejemplo anterior, en la primera llamada el valor del acumulador es 0, y se cambia su valor por el resultado de la suma, por lo que en la segunda llamada su valor es 3. As\u00ed, sucesivamente, hasta completar el array y devolver el valor 10. Veamoslo en una tabla:</p> acumulador(<code>sum</code>) element(<code>current</code>) resultado(<code>sum + current</code>) primera llamada 0 1 1 segunda llamada 1 2 3 tercera llamada 3 3 6 \u00faltima llamada 6 4 10 <p>Em el caso de no haber valor inicial, <code>reduce</code> toma el primer elemento del array como valor inicial y comienza la iteraci\u00f3n a partir del segundo elemento. Siendo la iteraci\u00f3n as\u00ed:</p> acumulador(<code>sum</code>) element(<code>current</code>) resultado(<code>sum + current</code>) primera llamada 1 2 3 segunda llamada 3 3 6 \u00faltima llamada 6 4 10 <p>Sin embargo, este uso requiere tener extremo cuidado. Si el array est\u00e1 vac\u00edo, entonces el llamado a <code>reduce</code> sin valor inicial devuelve error.</p> <pre><code>const array = []\nconsole.log(array.reduce((a,b) =&gt; a + b)) // \u274c ERROR\n</code></pre> <p>Este es el motivo por el que se recomienda utilizar el valor inicial.</p>"},{"location":"bloque_i/tema_6/page-2/#isarray","title":"isArray","text":"<p>Los arrays, como ya hemos visto, son objetos. Por ello, al usar el operador <code>typeof</code> con array, el resultado obtenido es <code>object</code>, ya que dicho operador no distingue entre los objetos y los arrays. El m\u00e9todo est\u00e1tico de la clase de utilidad <code>Array.isArray(array)</code> retorna <code>true</code> si el objeto a comprobar es un array, por el contrario, retornar\u00e1 <code>false</code>.</p> <pre><code>const array = []\nconst obj = {}\nconsole.log(Array.isArray(array)) // true\nconsole.log(Array.isArray(obj)) // false\n</code></pre>"},{"location":"bloque_i/tema_6/page-2/#otros-metodos-de-array","title":"Otros m\u00e9todos de array","text":"<p>Adem\u00e1s de todos los m\u00e9todos utilizados, existen otros m\u00e9todos \u00fatiles para trabajar con javascript:</p> <ul> <li> <p><code>some(callback)</code>. Retorna <code>true</code> si al aplicarle la callback a los elementos del array, alguno devuelve <code>true</code>.</p> <pre><code>const array = [1,2,3,4]\nconst isEven = el =&gt; el % 2 === 0\nconsole.log(array.some(isEven)) // true\n</code></pre> </li> <li> <p><code>every(callback)</code>. Devuelve <code>true</code>si todos para todos los elementos del array, el callback retorna <code>true</code>.</p> <pre><code>const array = [1, 2, 3, 4]\nconst isEven = el =&gt; el % 2 === 0\nconsole.log(array.every(isEven)) // false\n</code></pre> </li> <li> <p><code>fill(value, [start], [end])</code>. Rellena el array con el valor indicado, desde la posici\u00f3n indicada hasta la posici\u00f3n final indicada. Si no se indica posici\u00f3n se rellena todos los elementos del array, con el valor indicado. Si se indica un \u00edndice superior al tama\u00f1o del array, solo rellenar\u00e1 hasta el \u00faltimo elemento, no a\u00f1adir\u00e1 m\u00e1s elementos.</p> <pre><code>const array = [1, 2, 3, 4]\narray.fill(10, 3, 5)\nconsole.log(array) // [1, 2 , 3, 10]\narray.fill('a', 2)\nconsole.log(array) // [1, 2, 'a', 'a']\narray.fill(0)\nconsole.log(array) // [0, 0, 0, 0]\n</code></pre> </li> <li> <p><code>copyWithin(target, [start], [end])</code>. Copia a partir de la posici\u00f3n target los valores comprendidos entre la posici\u00f3n inicial y final (no inclusive).</p> <pre><code>const array1 = ['a', 'b', 'c', 'd', 'e']\nconsole.log(array1.copyWithin(0, 3, 4)) // [\"d\", \"b\", \"c\", \"d\", \"e\"]\nconsole.log(array1.copyWithin(1, 3)) // [\"d\", \"d\", \"e\", \"d\", \"e\"]\n</code></pre> </li> <li> <p><code>flat([depth])</code>. Dada una matriz, retorna una array con la matriz unificada. El par\u00e1metro <code>depth</code> indica el nivel de profundidad, y su valor por defecto es 1.</p> <pre><code>const arr1 = [1, 2, [3, 4]]\narr1.flat() // [1, 2, 3, 4]\nconst arr2 = [1, 2, [3, 4, [5, 6]]]\narr2.flat() // [1, 2, 3, 4, [5, 6]]\nconst arr3 = [1, 2, [3, 4, [5, 6]]]\narr3.flat(2) // [1, 2, 3, 4, 5, 6]\n</code></pre> </li> <li> <p><code>flatMap(callback, [depth])</code>. Es similar al anterior. Suele ser usado cuando al transformar el array, el <code>map</code> devuelve un array cuyo elementos son otros arrays. De esta forma, en primer lugar, se realiza la transformaci\u00f3n y luego la uni\u00f3n.</p> <pre><code>const arr1 = [1, 2, 1]\nconst result = arr1.flatMap((num) =&gt; (num === 2 ? [2, 2] : 1))\nconsole.log(result) // [1, 2, 2, 1]\n</code></pre> </li> </ul> <p>De todos los m\u00e9todos devueltos, se pueden concatenar llamadas a aquellos m\u00e9todo que retornen un array y as\u00ed poder realizar varias operaciones seguidas. Por ejemplo, supongamos que queremos la suma de los cuadrados de los n\u00fameros pares de un array:</p> <pre><code>const array = [1,2,3,4,5,6]\nconst sum = array.filter(x -&gt; x % 2 === 0) // [2,4,6]\n.map(x -&gt; x * x) // [4, 16, 36]\n.reduce((acc, item) -&gt; acc + item, 0) // 56\nconsole.log(sum) // 56\n</code></pre> <p>La \u00faltima concatenaci\u00f3n puede ser una operaci\u00f3n terminal, es decir, un m\u00e9todo que devuelva un \u00fanico valor, como un booleano o un n\u00famero.</p>"},{"location":"bloque_i/tema_6/page-3/","title":"3 Iteradores","text":""},{"location":"bloque_i/tema_6/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Un iterador es un tipo de objeto que permite ser iterado, es decir, puede ser recorrido por alguna estructura iteradora (bucles de objetos). Se podr\u00eda decir, que los iteradores son una generalizaci\u00f3n de los arrays, ya que \u00e9stos pueden ser iterados.</p> <p>Existen varios tipos de objetos que pueden ser iterados, como por ejemplo las cadenas. Adem\u00e1s, existen objetos cuya estructura no sea similar al de un array o matriz, pero sin embargo, pueden ser iterados por los bucles de forma sencilla.</p> <p>Las cadenas son iteradores, por lo que podemos iterar una cadena dentro de un bucle <code>for..of</code>:</p> <pre><code>for (const char of \"test\") {\nconsole.log(char)\n}\n</code></pre>"},{"location":"bloque_i/tema_6/page-3/#symboliterator","title":"Symbol.iterator","text":"<p>La propiedad <code>Symbol.iterator</code> es una propiedad de los objetos que indica la forma en la que debe ser iterado el objeto iterador. Si el objeto, no tiene dicha propiedad, podemos decir que el objeto no es un iterador, por lo que no podr\u00e1 ser recorrido por un bucle.</p> <p>Supongamos que queremos crear un objeto <code>range</code>, con dos propiedad num\u00e9ricas. Su propiedad <code>Symbol.iterator</code> debe permite iterar desde la propiedad <code>from</code> hasta la propiedad <code>to</code>. La propiedad <code>Symbol.iterator</code> debe devolver un objeto con el m\u00e9todo <code>next()</code> que es el m\u00e9todo llamado por el bucle:</p> <pre><code>const range = {\nfrom: 1,\nto: 5\n}\nrange[Symbol.iterator] = function() { // (1)!\nreturn { // (2)!\ncurrent: this.from,\nlast: this.to,\nnext() { // (3)!\nif (this.current &lt;= this.last) {\nreturn { done: false, value: this.current++ } // (4)!\n} else {\nreturn { done: true }\n}\n}\n}\n}\nfor (const num of range) {\nconsole.log(num) // 1, 2, 3, 4, 5\n}\n</code></pre> <ol> <li>Al usar el bucle <code>for..of</code>, se llama a este m\u00e9todo.</li> <li>Este m\u00e9todo devuelve un iterador y a partir de entonces, trabajar\u00e1 con dicho objeto.</li> <li>El m\u00e9todo <code>next()</code> es el m\u00e9todo usado por el bucle</li> <li>El m\u00e9todo <code>next()</code> deber\u00e1 devolver un objeto con las propiedades, <code>done</code> (indica si el bucle debe finalizar o no), y <code>value</code> (valor a devolver)</li> </ol> <p>Como vemos en el ejemplo anterior, al utilizar el objeto <code>range</code> dentro de la estructura <code>for..of</code>, \u00e9ste, llama a la funci\u00f3n <code>Symbol.Iterator</code> del objeto <code>range</code>. Este m\u00e9todo, retorna un objeto con el m\u00e9todo <code>next()</code> que es llamado por cada iteraci\u00f3n. El m\u00e9todo <code>next()</code> debe devolver un nuevo objeto con dos propiedades: <code>done</code> y <code>value</code>. La propiedad <code>done</code> indicar\u00e1 si el bucle debe finalizar (<code>true</code>) o no. Mientras que la propiedad <code>value</code> indica el valor que debe ser usado en el bucle.</p> <p>Un iterador puede ser recorrido expl\u00edcitamente haciendo uso del m\u00e9todo <code>next()</code> del iterador devuelto por <code>Symbol.iterator</code>:</p> <pre><code>const str = \"Hola\"\nconst iterator = str[Symbol.iterator]()\nwhile(true){\nconst result = iterator.next()\nconsole.log(result.value)\nif(result.done) return\n}\n</code></pre>"},{"location":"bloque_i/tema_6/page-3/#array-like","title":"array-like","text":"<p>Un simil-array (array-like) es un tipo de objeto con una estructura parecida a un array, es decir, tiene la propiedad <code>length</code> y utiliza \u00edndices.</p> <pre><code>const arrayLike = {\n0: \"Hola\",\n1: \"Mundo\",\nlength: 2\n}\n</code></pre> <p>Este tipo de objetos no son iteradores por defecto, por lo que no pueden ser recorridos por el bucle <code>for..of</code>. Para que un simil-array, sea un iterador se debe implementar la propiedad <code>Symbol.iterator</code>.</p>"},{"location":"bloque_i/tema_6/page-3/#crear-array-desde-iteradores-o-array-like","title":"Crear array desde iteradores o array-like","text":"<p>Tanto los iterables como los array-like generalmente no son arrays, y por tanto no pueden utilizar sus m\u00e9todos, como <code>push</code> <code>pop</code>, etc. Eso es bastante inconveniente si tenemos un objeto de este tipo y queremos trabajar con \u00e9l como con una matriz.</p> <p>Existe un m\u00e9todo est\u00e1tico de la clase de utilidad, <code>Array.from(object)</code> que toma como valor un iterador o un array-like y crea un verdadero array a partir de \u00e9l. En el caso de los array-like, crea un array a partir de los \u00edndices del objeto, mientras que en el caso del iterador, crear un array llamando al m\u00e9todo <code>next()</code> del objeto iterador de la propiedad <code>Symbol.iterator</code>:</p> <pre><code>const arrayLike = {\n0: \"Hola\",\n1: \"Mundo\",\nlength: 2\n}\nconst array = Array.from(arrayLike) console.log(array.pop()) // Mundo\n</code></pre> <p>Adem\u00e1s, puede recibir un segundo par\u00e1metro, con un callback que sirve para transformar los valores del array, al igual que la funci\u00f3n <code>map</code> de los arrays.</p> <pre><code>const str = \"Hola mundo\"\nconst array = Array.from(str, (c, i) =&gt; c + i)\nconsole.log(array) // ['H0','o1','l2','a3',' 4','m5','u6','n7','d8','o9']\n</code></pre>"},{"location":"bloque_i/tema_6/page-4/","title":"4 Mapas y colecciones","text":""},{"location":"bloque_i/tema_6/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Hasta ahora hemos visto diferentes tipos de colecciones, como los objetos, los arrays o los iterados. Adem\u00e1s de estas colecciones existen otro tipos de colecciones, como los mapas y los conjuntos.</p> <p>Adem\u00e1s de estas colecciones, existen m\u00e9todos para tratar a los objetos como iteradores. La clase de utilidad <code>Object</code> dispone de varios m\u00e9todos est\u00e1ticos para ellos:</p> <ul> <li><code>Object.keys(obj)</code>. Devuelve un array con las claves del objeto.</li> <li><code>Object.values(obj)</code>. Devuelve un array con los valores del objeto.</li> <li><code>Object.entries(obj)</code>. Devuelve una matriz, es decir, un array de arrays, donde cada sub-array, es un elemento <code>[clave, valor]</code>.</li> </ul> <pre><code>const obj = {\nname: \"John\",\nage: 25\n}\nfor(const key of Object.keys(obj)){\nconsole.log(key)\n}\nfor(const value of Object.values(obj)){\nconsole.log(value)\n}\nfor(const entry of Object.entries(obj)){\nconsole.log(obj[0], obj[1])\n}\n</code></pre> <p>Warning</p> <p>Al igual que un bucle <code>for..in</code>, estos m\u00e9todos ignoran propiedades que utilizan <code>Symbol(...)</code> como nombre de propiedades.</p> <p>Normalmente, esto es conveniente. Pero si tambi\u00e9n queremos propiedades simb\u00f3licas, entonces hay un m\u00e9todo aparte <code>Object.getOwnPropertySymbols</code> que devuelve un array de \u00fanicamente propiedades simb\u00f3licas. Tambi\u00e9n existe un m\u00e9todo <code>Reflect.ownKeys(obj)</code> que devuelve todas las propiedades.</p> <p>Al igual que tenemos el <code>Object.entries(obj)</code> tenemos el m\u00e9todo <code>Object.fromEntries(array)</code> que retorna un objeto con el primer valor de la entry como clave, y el segundo como valor.</p> <p>Los objetos no puede utilizar por defecto, los m\u00e9todos <code>map</code>, o <code>filter</code>, cosa que a veces complica un poco la l\u00f3gica de programaci\u00f3n. Sin embargo, gracias a los m\u00e9todos vistos, podemos utilizarlo sin problemas. Para ello, en primer lugar, debemos transforma el objeto en un array de clave-valor con el m\u00e9todo <code>Object.entries(obj)</code>. Posteriormente, usar sobre dicho array, los m\u00e9todos <code>map</code>, <code>filter</code> o el que se necesite. Por \u00faltimo, volver a tener un objeto con el resultado de dichos m\u00e9todos con el objeto <code>Object.fromEntries(entries)</code>. Este \u00faltimo paso solo es necesario si lo que se desea obtener es un objeto, y se han usado m\u00e9todos que devuelvan un array. Veamos un ejemplo:</p> <pre><code>const prices = {\nbanana: 1,\norange: 2,\nmeat: 4\n}\nconst entries = Object.entries(prices) // [[\"banana\", 1], [\"orange\", 2], [\"meat\", 4]]\n.map(entry =&gt; [entry[0], entry[1] * 2]) // [[\"banana\", 2], [\"orange\", 4], [\"meat\", 8]]\nconst newObject = Object.fromEntries(entries)\nconsole.log(newObject) // {banana: 2, orange: 4, meat: 8}\n</code></pre>"},{"location":"bloque_i/tema_6/page-4/#mapas","title":"Mapas","text":"<p>Un mapa es un tipo de colecci\u00f3n que almacena datos con la estructura clave:valor, al igual que los objetos. Sin embargo, la principal diferencia emana en que los mapas permiten que la clave sea cualquier tipo de dato, a diferencia de los objetos que siempre eran cadenas.</p> <p>Para crear un mapa se puede usar el constructor <code>Map()</code>. Al constructor se le puede pasar un array o iterador para inicializar el mapa.</p> <pre><code>const empty = new Map()\nconst map = new Map([\n[1, \"one\"],\n[2, \"two\"],\n[3, \"three\"]\n])\n</code></pre> <p>Los mapas tienen m\u00e9todos que nos permiten trabajar con ellos:</p> <ul> <li><code>set(key, value)</code>. A\u00f1ade la clave y el valor al mapa. Si la clave ya existe en el mapa, sobrescribe su valor.</li> <li><code>get(key)</code>. Obtiene el valor dada una clave.</li> <li><code>has(key)</code>. Comprueba si el mapa contiene la clave dada.</li> <li><code>delete(key)</code>. Elimina tanto el valor como la clave dada.</li> <li><code>clear()</code>. Vac\u00eda el mapa.</li> <li><code>size</code>. Obtiene la cantidad de elementos (clave-valor) que posee el mapa</li> </ul> <pre><code>const map = new Map()\nmap.set('1', 'str1')\nmap.set(1, 'num1')\nmap.set(true, 'bool1')\nconsole.log(map.get(1))\nconsole.log(map.get('1'))\nconsole.log(map.size)\n</code></pre> <p>Como se puede observar en el ejemplo, cualquier tipo de dato puede funcionar como clave de un mapa. En los objetos, las claves siempre eran cadenas, si se indicaban otro tipo de datos, estas se pasaban a cadena. En los mapas, incluso, se puede indicar un objeto como clave:</p> <pre><code>const obj = {name: 'John'}\nconst map = new Map()\nmap.set(obj, 123)\nconsole.log(map.get(obj)) // 123\n</code></pre> <p>Si se intentase esto con un objeto, el objeto usado como clave pasar\u00eda a ser una cadena, lo que dar\u00eda problemas si tenemos m\u00e1s de un objeto:</p> <pre><code>const john = { name: \"John\" }\nconst ben = { name: \"Ben\" }\nconst visitsCountObj = {}\nvisitsCountObj[ben] = 234\nvisitsCountObj[john] = 123\nconsole.log(visitsCountObj[\"[object Object]\"]) // 123\n</code></pre> <p>Al hacer uso del m\u00e9todo <code>set(key, value)</code> para indicar propiedades, se pueden concatenar varios <code>set(key, value)</code>, ya que este m\u00e9todo retorna el mismo mapa:</p> <pre><code>const map = new Map()\nmap.set('key1', 'value1')\n.set('key2', 'value2')\n.set('key3', 'value3')\n</code></pre> <p>Podemos recorrer un mapa, a trav\u00e9s de los siguientes m\u00e9todos:</p> <ul> <li><code>keys()</code>. Retorna un iterador con las claves del mapa.</li> <li><code>values()</code>. Retorna un iterador con los valores del mapa.</li> <li><code>entries()</code>. Retorna un iterador con la clave y el valor como un array, la primera posici\u00f3n,<code>0</code>, representa la clave, y la segunda posici\u00f3n, <code>1</code>, representa el valor.</li> </ul> <p>Son m\u00e9todos parecidos a los que se usan con los objetos, siendo la principal diferencia que los m\u00e9todos de mapas devuelven iteradores, mientras que los de objectos devuelve un array.</p> <p>Veamos un ejemplo:</p> <pre><code>const recipeMap = new Map([\n['pepino', 500],\n['tomates', 350],\n['cebollas',    50]\n])\nfor (const vegetable of recipeMap.keys()) {\nconsole.log(vegetable) // pepino, tomates, cebollas\n}\nfor (const amount of recipeMap.values()) {\nconsole.log(amount) // 500, 350, 50\n}\nfor (const entry of recipeMap) { // lo mismo que recipeMap.entries()\nconsole.log(entry[0], entry[1]) // pepino,500 (etc)\n}\n</code></pre> <p>A diferente de los objetos, a la hora de iterar un Mapa, \u00e9ste conserva el orden de interacci\u00f3n.</p> <p>Otra forma de iterar un mapa, es a trav\u00e9s del m\u00e9todo <code>forEach(callback)</code> que recibe una callback que se le aplicar\u00e1 a cada uno de los elementos (clave-valor) del mapa. Esta callback recibe tres argumento, el valor del elemento en cuesti\u00f3n, su clave, y el mapa en s\u00ed. Veamos un ejemplo:</p> <pre><code>const recipeMap = new Map([\n['pepino', 500],\n['tomates', 350],\n['cebollas',    50]\n])\nrecipeMap.forEach((value, key, map) =&gt; {\nconsole.log(`${key}: ${value}`)\n})\n</code></pre> <p>Podemos crear un mapa a trav\u00e9s de un objecto, usando el m\u00e9todo <code>Object.entries(entries)</code> en el constructor del mapa. Adem\u00e1s, de la misma forma, haciendo uso del m\u00e9todo <code>Object.fromEntries(entries)</code> podemos crear un objeto a partir de un mapa, usando como entries el m\u00e9todo <code>entries()</code> de los mapas.</p> <pre><code>const obj = {\nname: \"John\",\nage: 30\n}\nconst map = new Map(Object.entries(obj))\nconsole.log(map.get('name')) // John\nconst newObj = Object.fromEntries(map.entries())\nconsole.log(newObj) // {name: \"John\", age: 30}\n</code></pre> <p>Es importante tener en cuenta que todas las claves del mapa, sean del tipo que sean, se pasar\u00e1n a cadena para que funcionen como clave del objeto.</p>"},{"location":"bloque_i/tema_6/page-4/#mapas-debiles","title":"Mapas d\u00e9biles","text":"<p>Como vimos ya vimos, el motor de JavaScript mantiene un valor en la memoria mientras sea accesible y pueda ser potencialmente usado. Normalmente, los elementos de una estructura, como las propiedades de un objeto o los elementos de un array, permanecen en memoria mientras dicha estructura est\u00e9 en uso.</p> <p>Por ejemplo, si agregamos un objeto a un array, mientras el array permanezca en memoria, el objeto tambi\u00e9n estar\u00e1 en memoria, incluso si no hay otras referencias a \u00e9l.</p> <p>Del mismo modo, si usamos un objeto como la clave en un <code>Map</code> regular, entonces mientras exista el <code>Map</code>, ese objeto tambi\u00e9n existe. Este objeto ocupa memoria y no puede ser reclamado por el recolector de basura.</p> <p><code>WeakMap</code> es una estructura de datos similar a <code>Map</code>, pero no impide la recolecci\u00f3n de basura de objetos usados como claves.</p> <p>La primera diferencia con <code>Map</code> es que en <code>WeakMap</code> las claves deben ser objetos, no valores primitivos:</p> <pre><code>const weakMap = new WeakMap()\nconst obj = {}\nweakMap.set(obj, \"ok\") // (1)!\nweakMap.set(\"test\", \"Whoops\") // (2)!\n</code></pre> <ol> <li>\u2705 La clave es un objeto, por lo que no hay problema.</li> <li>\u274c La clave es una cadena, aqu\u00ed da error.</li> </ol> <p>Ahora, si usamos un objeto como clave y no hay otras referencias a ese objeto, se eliminar\u00e1 de la memoria (y del <code>map</code>) autom\u00e1ticamente.</p> <pre><code>const john = { name: \"John\" }\nconst weakMap = new WeakMap()\nweakMap.set(john, \"...\")\njohn = null\n// \u00a1John se elimin\u00f3 de la memoria!\n</code></pre> <p>Ahora, si <code>john</code> solo existe como la clave de <code>WeakMap</code>, se eliminar\u00e1 autom\u00e1ticamente del <code>map</code> (y de la memoria).</p> <p><code>WeakMap</code> no admite la iteraci\u00f3n ni los m\u00e9todos <code>keys()</code>, <code>values()</code>, <code>entries()</code>, as\u00ed que no hay forma de obtener todas las claves o valores de \u00e9l.</p> <p>WeakMap tiene solo los siguientes m\u00e9todos: <code>set(key, value)</code>, <code>get(key)</code>, <code>delete(key)</code>, <code>has(key)</code>.</p> <p>Dicha limitaci\u00f3n es debida por razones t\u00e9cnicas. Si un objeto ha perdido todas las dem\u00e1s referencias (como <code>john</code> en el c\u00f3digo anterior), entonces se debe recolectar autom\u00e1ticamente como basura. Pero t\u00e9cnicamente no se especifica exactamente cu\u00e1ndo se realiza la limpieza.</p> <p>El motor de JavaScript decide eso. Puede optar por realizar la limpieza de la memoria inmediatamente o esperar y realizar la limpieza m\u00e1s tarde cuando ocurran m\u00e1s eliminaciones. Por lo tanto, t\u00e9cnicamente no se conoce el recuento actual de elementos de un <code>WeakMap</code>. El motor puede haberlo limpiado o no, o lo hizo parcialmente. Por esa raz\u00f3n, los m\u00e9todos que acceden a todas las claves/valores no son soportados.</p> <p>El \u00e1rea principal de aplicaci\u00f3n de <code>WeakMap</code> es como almacenamiento de datos adicional.</p> <p>Si estamos trabajando con un objeto que pertenece a otro c\u00f3digo (tal vez incluso una biblioteca de terceros), y queremos almacenar algunos datos asociados a \u00e9l que solo deber\u00edan existir mientras el objeto est\u00e9 vivo, entonces <code>WeakMap</code> es exactamente lo que se necesita.</p> <p>Ponemos los datos en un <code>WeakMap</code> utilizando el objeto como clave, y cuando el objeto sea recolectado por el recolector de basura, esos datos tambi\u00e9n desaparecer\u00e1n autom\u00e1ticamente: <code>weakMap.set(john, \"secrets documents\")</code>, de esta forma si <code>john</code> desaparece, secrets documents tambi\u00e9n lo har\u00e1.</p> <p>Por ejemplo, tenemos un c\u00f3digo que mantiene un recuento de visitas para los usuarios. La informaci\u00f3n se almacena en un <code>map</code>: un objeto de usuario es la clave y el recuento de visitas es el valor. Cuando un usuario se va (su objeto ser\u00e1 recolectado por el recolector de basura), ya no queremos almacenar su recuento de visitas.</p> <pre><code>const visitsCountMap = new Map() // map: user =&gt; visits count\nfunction countUser(user) {\nconst count = visitsCountMap.get(user) || 0;\nvisitsCountMap.set(user, count + 1)\n}\nconst john = { name: \"John\" }\ncountUser(john)\njohn = null\n</code></pre> <p>Ahora el objeto <code>john</code> deber\u00eda ser recolectado como basura, pero permanece en la memoria, ya que es una propiedad en <code>visitCountMap</code>.</p> <p>Necesitamos limpiar <code>visitCountMap</code> cuando eliminamos usuarios, de lo contrario, crecer\u00e1 en la memoria indefinidamente. Tal limpieza puede convertirse en una tarea tediosa en arquitecturas complejas.</p> <p>Lo podemos evitar cambiando a <code>WeakMap</code> en su lugar:</p> <pre><code>const visitsCountMap = new WeakMap() //  user =&gt; visits count\nfunction countUser(user) {\nconst count = visitsCountMap.get(user) || 0\nvisitsCountMap.set(user, count + 1)\n}\nconst john = { name: \"John\" }\ncountUser(john)\njohn = null\n</code></pre> <p>Ahora no tenemos que limpiar <code>visitasCountMap</code>. Despu\u00e9s de que el objeto <code>john</code> se vuelve inalcanzable por todos los medios excepto como una propiedad de <code>WeakMap</code>, se elimina de la memoria junto con la informaci\u00f3n asociada a esa clave de <code>WeakMap</code>.</p> <p>Otro ejemplo com\u00fan es el almacenamiento en cach\u00e9 cuando se debe recordar el resultado de una funci\u00f3n (en cach\u00e9), para que las llamadas futuras en el mismo objeto lo reutilicen. Podemos usar <code>Map</code> para almacenar resultados:</p> <pre><code>const cache = new Map()\nfunction process(obj) {\nif (!cache.has(obj)) {\nlet result = obj\ncache.set(obj, result)\nreturn result\n}\nreturn cache.get(obj)\n}\nlet obj = {/* digamos que tenemos un objeto */};\nlet result1 = process(obj); // calculado\n// ...despu\u00e9s, en otro lugar del c\u00f3digo...\nlet result2 = process(obj); // resultado recordado tomado de la memoria cach\u00e9\n// ...despu\u00e9s, cuando el objeto no se necesita m\u00e1s:\nobj = null;\nconsole.log(cache.size); // 1\n</code></pre> <p>Para m\u00faltiples llamadas de proceso (<code>obj</code>) con el mismo objeto, solo calcula el resultado la primera vez, y luego lo toma de cach\u00e9. La desventaja es que necesitamos limpiar el cach\u00e9 cuando el objeto ya no es necesario.</p> <p>Si reemplazamos <code>Map</code> por <code>WeakMap</code>, este problema desaparece: el resultado en cach\u00e9 se eliminar\u00e1 de la memoria autom\u00e1ticamente despu\u00e9s de que el objeto se recolecte.</p> <pre><code>const cache = new WeakMap()\nfunction process(obj) {\nif (!cache.has(obj)) {\nconst result = obj\ncache.set(obj, result)\nreturn result\n}\nreturn cache.get(obj)\n}\nconst obj = {/* alg\u00fan objeto */}\nconst result1 = process(obj)\nconst result2 = process(obj)\n// ...despu\u00e9s, cuando el objeto no se necesitar\u00e1 m\u00e1s:\nobj = null\n// No se puede obtener cache.size, ya que es un WeakMap,\n// pero es 0 o pronto ser\u00e1 0\n// Cuando obj se recolecte como basura, los datos en cach\u00e9 tambi\u00e9n se eliminar\u00e1n\n</code></pre>"},{"location":"bloque_i/tema_6/page-4/#conjuntos","title":"Conjuntos","text":"<p>Un conjunto es una colecci\u00f3n especial sin claves, donde cada valor es \u00fanico dentro de la colecci\u00f3n. Se puede considerar como una especia de array pero sin elementos repetidos, solamente con elementos \u00fanicos. Para crear un conjunto se puede utilizar su constructor <code>Set([iterable])</code> que puede recibir un iterable para inicializarlo. Si recibe un iterable con valores repetidos, estos son omitidos por el conjunto:</p> <pre><code>const set = new Set([1,2,3,1,2,3])\nconsole.log(set) // [1,2,3]\n</code></pre> <p>Sus m\u00e9todos m\u00e1s destacados son:</p> <ul> <li><code>add(value)</code>. A\u00f1ade el valor (si no existe en el conjunto), y devuelve el conjunto en s\u00ed.</li> <li><code>delete(value)</code>. Elimina el valor, y devuelve <code>true</code> si el valor exist\u00eda al momento de la llamada; si no, devuelve <code>false</code>.</li> <li><code>has(value)</code>. Devuelve <code>true</code> si el valor existe en el conjunto, si no, devuelve <code>false</code>.</li> <li><code>clear()</code>. Elimina todo el contenido del conjunto</li> <li><code>size</code>. Devuelve la cantidad de elementos del conjunto.</li> </ul> <p>La caracter\u00edstica principal es que llamadas repetidas de <code>set.add(value)</code> con el mismo valor no hacen nada. Esa es la raz\u00f3n por la cual cada valor aparece en <code>Set</code> solo una vez.</p> <pre><code>const set = new Set();\nconst john = { name: \"John\" }\nconst pete = { name: \"Pete\" }\nconst mary = { name: \"Mary\" }\nset.add(john)\nset.add(pete)\nset.add(mary)\nset.add(john)\nset.add(mary)\nconsole.log(set.size) // 3\n</code></pre> <p>La alternativa a <code>Set</code> podr\u00eda ser un array de usuarios, y c\u00f3digo para verificar si hay duplicados en cada inserci\u00f3n usando el m\u00e9todo <code>find(callback)</code>. Pero el rendimiento ser\u00eda mucho peor, porque este m\u00e9todo recorre el array completo comprobando cada elemento. Set est\u00e1 optimizado internamente para verificar unicidad.</p> <p>Podemos recorrer un conjunto con el bucle <code>for..of</code> como cualquier iterable, o haciendo uso del m\u00e9todo <code>forEach(callback)</code>, donde recorrer\u00e1 cada elemento del conjunto aplic\u00e1ndole el callback:</p> <pre><code>const set = new Set([\"oranges\", \"apples\", \"bananas\"])\nfor (let value of set) console.log(value)\nset.forEach((value, valueAgain, set) =&gt; {\nconsole.log(value)\n})\n</code></pre> <p>Tenga en cuenta que la funci\u00f3n callback pasada en <code>forEach</code> tiene 3 argumentos: un valor, luego el mismo valor valueAgain y luego el objeto de destino que es <code>set</code>. El mismo valor aparece en los argumentos dos veces. Eso es por compatibilidad con <code>Map</code> donde la funci\u00f3n callback tiene tres argumentos. Aunque parezca extra\u00f1o, en ciertos casos puede ayudar a reemplazar <code>Map</code> con <code>Set</code> y viceversa con facilidad.</p>"},{"location":"bloque_i/tema_6/page-4/#conjuntos-debiles","title":"Conjuntos d\u00e9biles","text":"<p><code>WeakSet</code> es una clase an\u00e1loga a <code>Set</code>, pero en esta estructura solo podemos agregar objetos y no tipos primitivos. El objeto, al igual que en <code>WeakMap</code>, solo existir\u00e1 en la colecci\u00f3n mientras sea accesible desde otro lugar. Al igual que Set, admite <code>add(value)</code>, <code>has(value)</code> y <code>delete(value)</code>, pero no <code>size</code> ni iteraciones.</p> <p>Al ser d\u00e9bil, tambi\u00e9n sirve como almacenamiento adicional. Pero no para datos arbitrarios, sino para hechos s\u00ed/no. Una membres\u00eda en <code>WeakSet</code> puede significar algo sobre el objeto. Por ejemplo, podemos agregar usuarios a <code>WeakSet</code> para realizar un seguimiento de los que visitaron nuestro sitio:</p> <pre><code>const visitedSet = new WeakSet()\nconst john = { name: \"John\" }\nconst pete = { name: \"Pete\" }\nconst mary = { name: \"Mary\" }\nvisitedSet.add(john) // John nos visita\nvisitedSet.add(pete) // luego Pete\nvisitedSet.add(john) // John otra vez\n// visitedSet tiene 2 usuarios ahora\n// comprobar si John nos visit\u00f3?\nconsole.log(visitedSet.has(john)) // true\n// comprobar si Mary nos visit\u00f3?\nconsole.log(visitedSet.has(mary)) // false\njohn = null;\n// visitedSet se limpiar\u00e1 autom\u00e1ticamente\n</code></pre> <p>La limitaci\u00f3n m\u00e1s notable de <code>WeakMap</code> y <code>WeakSet</code> es la ausencia de iteraciones y la imposibilidad de obtener todo el contenido actual. Esto puede parecer inconveniente, pero no impide que <code>WeakMap</code> / <code>WeakSet</code> haga su trabajo principal: ser un almacenamiento adicional de datos para objetos que se almacenan/administran en otro lugar.</p>"},{"location":"bloque_i/tema_6/page-5/","title":"5 Destructuraci\u00f3n","text":""},{"location":"bloque_i/tema_6/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Las dos estructuras de datos m\u00e1s usadas en JavaScript son los objetos y los arrays.Los objetos nos permiten crear una simple entidad que almacena items con una clave cada uno y los arrays nos permiten reunir items en una lista ordenada.</p> <p>Sin embargo cuando los pasamos a una funci\u00f3n o lo introducimos en variables, tal vez no necesitemos un objeto o array como un conjunto sino en piezas individuales.</p> <p>La asignaci\u00f3n desestructurante (o destructuraci\u00f3n) es una sintaxis especial que nos permite desempaquetar arrays u objetos en varias variables, para poder ser utilizados de forma m\u00e1s conveniente</p> <p>La destructuraci\u00f3n tambi\u00e9n funciona bien con funciones complejas que tienen muchos argumentos, valores por defecto, etc\u00e9tera.</p>"},{"location":"bloque_i/tema_6/page-5/#destructuracion-de-arrays","title":"Destructuraci\u00f3n de arrays","text":"<p>Para destructurar un array a la hora de inicializar la variables (o los par\u00e1metros de una funci\u00f3n), se debe indicar el nombre de las variables entre corchetes <code>[]</code>. Cada variable declarada hace referencia a la posici\u00f3n del array que ocupa. Por ejemplo, <code>const [var1, var2, var3]</code>, <code>var1</code> se inicializar\u00e1 con el primer valor del array, <code>var2</code> con el segundo y <code>var3</code> con el tercero.</p> <pre><code>const arr = [\"John\", \"Smith\"]\n// asignaci\u00f3n desestructurante\n// fija firstName = arr[0]\n// y surname = arr[1]\nconst [firstName, surname] = arr\nconsole.log(firstName) // John\nconsole.log(surname) // Smith\n</code></pre> <p>Ahora podemos trabajar con variables en lugar de miembros de array. Se llama asignaci\u00f3n desestructurante porque desestructura al copiar elementos dentro de variables, pero el array en s\u00ed no es modificado.</p> <p>Los elementos a los que no se deseen acceder, pueden ser omitidos por una coma <code>,</code>:</p> <pre><code>const [firstName,,title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"]\nconsole.log(title) // Consul\n</code></pre> <p>En el c\u00f3digo de arriba, el segundo elemento del array es omitido, el tercero es asignado a <code>title</code>, y el resto de los elementos del array tambi\u00e9n se omiten (debido a que no hay variables para ellos).</p> <p>La destructuraci\u00f3n no solo funciona con arrays, sino con cualquier estructura iterable</p> <pre><code>const [a, b, c] = \"abc\" // [\"a\", \"b\", \"c\"]\nconst [one, two, three] = new Set([1, 2, 3])\n</code></pre> <p>Adem\u00e1s, se puede asignar cualquier tipo de dato, como por ejemplo, las propiedades de un objeto:</p> <pre><code>const user = {}\n[user.name, user.surname] = \"John Smith\".split(\" \")\nconsole.log(user) // {name: 'John', surname: 'Smith'}\n</code></pre> <p>La destructuraci\u00f3n no solo se pueden realizar en variables, tambi\u00e9n se pueden realizar en bucles y en funciones de flecha. Por ejemplo:</p> <pre><code>const user = {\nname: 'John',\nage: 25\n}\nObject.entries(user).forEach(([key, value]) =&gt; console.log(key, value))\nfor(const [key, value] of Object.entries(user)){\nconsole.log(key, value)\n}\n</code></pre>"},{"location":"bloque_i/tema_6/page-5/#valores-predeterminados","title":"Valores predeterminados","text":"<p>Si el array o el objeto, es m\u00e1s corto que la lista de variables a la izquierda, lso valores ausentes se consideran <code>undefined</code>:</p> <pre><code>const [firstName, surname] = []\nconsole.log(firstName, surname) // undefined undefined\n</code></pre> <p>Para evitar dicho error, se le puede indicar un valor predeterminado a la asignaci\u00f3n desestructurada:</p> <pre><code>const [firstName = \"John\", surname = \"Smith\"] = [\"Julius\"]\nconsole.log(firstName, surname) // Julius Smith\n</code></pre> <p>Los valores predeterminados pueden ser expresiones m\u00e1s complejas e incluso llamadas a funci\u00f3n, que ser\u00e1n evaluadas s\u00f3lo si el valor no ha sido proporcionado.</p> <pre><code>const [name = prompt('nombre?'), surname = prompt('apellido?')] = [\"Julius\"]\nconsole.log(name, surname) // Julius (lo que el usuario introduzca)\n</code></pre>"},{"location":"bloque_i/tema_6/page-5/#destructuracion-de-objetos","title":"Destructuraci\u00f3n de objetos","text":"<p>La asignaci\u00f3n desestructurante tambi\u00e9n funciona con objetos, pero en lugar de utilizar corchetes, se deben usar llaves <code>{}</code>. El nombre de las variables desestructuradas deben de coincidir con el nombre de las propiedades a la que se debe acceder, en principio, no pueden ser modificadas. En este caso, el orden no importa, lo \u00fanico relevante es el nombre de las propiedades</p> <pre><code>const options = {\ntitle: \"Menu\",\nwidth: 100,\nheight: 200\n}\nconst {title, width, height} = options\nconsole.log(title)  // Menu\nconsole.log(width)  // 100\nconsole.log(height) // 2\n</code></pre> <p>Se le puede aplicar un cambio de nombre a la variable desestructurada, utilizando dos puntos <code>:</code> seguido del nombre deseado.</p> <pre><code>const options = {\ntitle: \"Menu\",\nwidth: 100,\nheight: 200\n}\nconst {width: w, height: h, title} = options\nconsole.log(title)  // Menu\nconsole.log(w)      // 100\nconsole.log(h)      // 200\n</code></pre> <p>Al igual que las estructuras iterables, se le puede indicar un valor por defecto:</p> <pre><code>const options = {\ntitle: \"Menu\",\n}\nconst {width = 100, height = 200, title} = options\nconsole.log(title)  // Menu\nconsole.log(width)  // 100\nconsole.log(height) // 200\n</code></pre> <p>Los valores por defectos, tambi\u00e9n, pueden ser cualquier expresi\u00f3n o llamadas de funci\u00f3n. Adem\u00e1s, se puede utilizar el renombramiento de la variable y el valor por defecto a la vez:</p> <pre><code>const options = {\ntitle: \"Menu\",\n}\nconst {width:w = 100, height:h = 200, title} = options\nconsole.log(title)  // Menu\nconsole.log(w)      // 100\nconsole.log(h)      // 200\n</code></pre>"},{"location":"bloque_i/tema_6/page-5/#destructuracion-anidada","title":"Destructuraci\u00f3n anidada","text":"<p>Si un objeto o array contiene objetos y arrays anidados, podemos utilizar patrones del lado izquierdo m\u00e1s complejos para extraer porciones m\u00e1s profundas.</p> <pre><code>const options = {\nsize: {\nwidth: 100,\nheight: 200\n},\nitems: [\"Cake\", \"Donut\"],\nextra: true\n}\nconst {\nsize: { width,\nheight\n},\nitems: [item1, item2], title = \"Menu\" } = options\nconsole.log(title)  // Menu\nconsole.log(width)  // 100\nconsole.log(height) // 200\nconsole.log(item1)  // Cake\nconsole.log(item2)  // Donut\n</code></pre> <p>Todas las propiedades del objeto <code>options</code> con excepci\u00f3n de extra que no est\u00e1 en el lado izquierda, son asignadas a las variables correspondientes. Tenga en cuenta que no hay variables para <code>size</code> e <code>items</code>, ya que tomamos su contenido en su lugar. Para poder utilizar en una variable, adem\u00e1s su contenido, se pude volver a escribir el nombre de la propiedad:</p> <pre><code>const options = {\nsize: {\nwidth: 100,\nheight: 200\n},\nitems: [\"Cake\", \"Donut\"],\nextra: true\n}\nconst {\nsize,\nsize: { width,\nheight\n},\nitems: [item1, item2], title = \"Menu\" } = options\nconsole.log(title)  // Menu\nconsole.log(width)  // 100\nconsole.log(height) // 200\nconsole.log(item1)  // Cake\nconsole.log(item2)  // Donut\nconsole.log(size)   // {width: 100, height: 200}\n</code></pre>"},{"location":"bloque_i/tema_6/page-5/#argumentos-de-funcion-inteligentes","title":"Argumentos de funci\u00f3n inteligentes","text":"<p>Hay momentos en que una funci\u00f3n tiene muchos argumentos, la mayor\u00eda de los cuales son opcionales. Eso es especialmente cierto para las interfaces de usuario. Imagine una funci\u00f3n que crea un men\u00fa. Puede tener ancho, altura, t\u00edtulo, elementos de lista, etc\u00e9tera.</p> <pre><code>function showMenu(title = \"Untitled\", width = 200, height = 100, items = []) {\n// ...\n}\n</code></pre> <p>En la vida real, el problema es c\u00f3mo recordar el orden de los argumentos. Normalmente los IDEs (Entorno de desarrollo integrado) intentan ayudarnos, especialmente si el c\u00f3digo est\u00e1 bien documentado, pero a\u00fan as\u00ed suele ser bastan engorroso. Otro problema es c\u00f3mo llamar a una funci\u00f3n si queremos que use sus valores predeterminados en la mayor\u00eda de los argumentos.</p> <p>Otra de las consecuencias de esta forma de declarar las funciones, es que dejan de ser completamente legibles y la persona que use nuestra funci\u00f3n no sabe que par\u00e1metro esta indicando.</p> <p>Para solucionar dichos problemas, podemos pasar los argumentos como un objeto, y la funci\u00f3n inmediatamente los desestructura en variables:</p> <pre><code>const options = {\ntitle: \"My menu\",\nitems: [\"Item1\", \"Item2\"]\n}\nfunction showMenu({title = \"Untitled\", width = 200, height = 100, items = []}) {\nconsole.log(`${title} ${width} ${height}`) // My Menu 200 100\nconsole.log(items) // Item1, Item2\n}\nshowMenu(options)\n</code></pre> <p>Tambi\u00e9n podemos usar destructuraci\u00f3n m\u00e1s compleja con objetos anidados y mapeo de dos puntos:</p> <pre><code>const options = {\ntitle: \"My menu\",\nitems: [\"Item1\", \"Item2\"]\n}\nfunction showMenu({\ntitle = \"Untitled\",\nwidth: w = 100,\nheight: h = 200,\nitems: [item1, item2] }) {\nconsole.log( `${title} ${w} ${h}` ) // My Menu 100 200\nconsole.log( item1 ) // Item1\nconsole.log( item2 ) // Item2\n}\nshowMenu(options)\n</code></pre> <p>La destructuraci\u00f3n supone que <code>showMenu()</code> tiene un argumento. Si queremos todos los valores predeterminados, debemos especificar un objeto vac\u00edo:</p> <pre><code>showMenu({}); // ok, todos los valores son predeterminados\nshowMenu(); // esto dar\u00eda un error\n</code></pre> <p>Podemos solucionar esto, poniendo <code>{}</code> como valor predeterminado para todo el objeto de argumentos:</p> <pre><code>function showMenu({ title = \"Menu\", width = 100, height = 200 } = {}) {\nconsole.log(`${title} ${width} ${height}`)\n}\nshowMenu() // Menu 100 200\n</code></pre> <p>En el c\u00f3digo de arriba, todo el objeto de argumentos es <code>{}</code> por defecto, por lo tanto siempre hay algo para desestructurar.</p>"},{"location":"bloque_i/tema_6/page-6/","title":"6 Par\u00e1metros REST y Spread operator","text":""},{"location":"bloque_i/tema_6/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>En ciertas ocasiones, se desean crear funciones con argumentos ilimitados. Es m\u00e1s, existen funciones que pueden recibir tantos argumentos como sea necesario. Por ejemplo, el m\u00e9todo <code>Math.max(arg1, arg2, ..., argN)</code> obtiene el m\u00e1ximo de una lista de argumentos.</p> <p>Una funci\u00f3n puede ser llamada con cualquier n\u00famero de argumentos sin importar c\u00f3mo sea definida.</p> <pre><code>function sum(a, b) {\nreturn a + b\n}\nconsole.log(sum(1, 2, 3, 4, 5)) // 3\n</code></pre> <p>No habr\u00e1 ning\u00fan error por exceso* de argumentos. Sin embargo, por supuesto, en el resultado solo los dos primeros ser\u00e1n tomados en cuenta, entonces el resultado del c\u00f3digo anterior es 3.</p> <p>Para poder indicar que una funci\u00f3n puede recibir tantos par\u00e1metros como se estime, se debe indicar el nombre del argumento, precedido por tres puntos <code>...</code>. Dichos argumentos, pueden ser tratados en el interior de la funci\u00f3n como un array:</p> <pre><code>function sumAll(...args) { // args es el nombre del array\nlet sum = 0\nfor (let arg of args) sum += arg\nreturn sum\n}\nconsole.log(sumAll(1)) // 1\nconsole.log(sumAll(1, 2)) // 3\nconsole.log(sumAll(1, 2, 3)) // 6\n</code></pre> <p>Se puede alternar argumentos est\u00e1ticos, o argumentos din\u00e1micos, siempre indicando los est\u00e1ticos primeros y los din\u00e1micos al final. En una funci\u00f3n, solo se puede indicar un argumento din\u00e1mico.</p> <pre><code>function showName(firstName, lastName, ...titles) {\nconsole.log(firstName + ' ' + lastName) // Julio Cesar\nconsole.log(titles[0]) // C\u00f3nsul\nconsole.log(titles[1]) // Emperador\nconsole.log(titles.length) // 2\n}\nshowName(\"Julio\", \"Cesar\", \"C\u00f3nsul\", \"Emperador\");\n</code></pre>"},{"location":"bloque_i/tema_6/page-6/#la-variable-arguments","title":"La variable arguments","text":"<p>Antiguamente, los par\u00e1metros rest no exist\u00edan en el lenguaje. Entonces, para poder acceder a todos los argumentos de una funci\u00f3n se usaba el objeto <code>arguments</code> que contiene todos los argumentos indexados. A\u00fan funciona, podemos encontrarlo en c\u00f3digo antiguo.</p> <pre><code>function showName() {\nconsole.log(arguments.length)\nconsole.log(arguments[0])\nconsole.log(arguments[1])\n}\n// muestra: 2, Julio, Cesar\nshowName(\"Julio\", \"Cesar\")\n// muestra: 1, Ilya, undefined (no hay segundo argumento)\nshowName(\"Ilya\")\n</code></pre> <p><code>arguments</code> es un array-like e iterable, pero no es un array real, por lo que no soporta los m\u00e9todos de los array como <code>map</code>. Adem\u00e1s, siempre contiene todos los argumentos. No podemos capturarlos parcialmente como hicimos con los par\u00e1metros rest.</p> <p>Las funciones flechas no soportan arguments</p> <p>Si accedemos el objeto <code>arguments</code> desde una funci\u00f3n flecha, toma su valor dela funci\u00f3n normal externa.</p> <p>Aqu\u00ed hay un ejemplo:</p> <pre><code>function f() {\nlet showArg = () =&gt; alert(arguments[0]);\nshowArg();\n}\nf(1); // 1\n</code></pre> <p>Como recordamos, las funciones de flecha no tienen su propio <code>this</code>. Ahora sabemos que tampoco tienen el objeto especial <code>arguments</code>.</p>"},{"location":"bloque_i/tema_6/page-6/#spread-operator","title":"Spread operator","text":"<p>El spread operator es un operador que permite obtener de un array los elementos de ese array de forma individual. La estructura de este operador es tres puntos <code>...</code> seguidos de la variable: <code>...array</code>. Por ejemplo, el m\u00e9todo <code>Math.max(...args)</code> recibe como argumento una lista de argumentos, si se intenta pasar un array devolver\u00eda un resultado no deseado:</p> <pre><code>const array = [1,2,3]\nconsole.log(Math.max(array)) // NaN\n</code></pre> <p>Al usar el spread operador sobre el array, obtendremos los elementos del array de forma individual, siendo usado como una lista de argumentos en el m\u00e9todo <code>Math.max()</code>:</p> <pre><code>const array = [1,2,3]\nconsole.log(Math.max(...array)) // similar a Math.max(1,2,3)\n</code></pre> <p>Se pueden utilizar en m\u00faltiples arrays:</p> <pre><code>const array1 = [1,2,3]\nconst array2 = [4,5,6]\nconst max = Math.max(...array1, ...array2) // Similar a Math.max(1,2,3,4,5,6)\n</code></pre> <p>Otro de los usos que se le suele dar al spread operator, es para unificar arrays en un \u00fanico array:</p> <pre><code>const array1 = [1,2,3]\nconst array2 = [4,5,6]\nconst merge = [0, ...array1, ...array2]\n</code></pre> <p>El operador spread utiliza internamente iteradores para iterar los elementos, de la misma manera que <code>for..of</code> hace. Entonces, para una cadena <code>for..of</code>retorna caracteres y <code>...str</code> se convierte en <code>\"H\",\"o\",\"l\",\"a\"</code>. La lista de caracteres es pasada a la inicializaci\u00f3n del array <code>[...str]</code>. El resultado es el mismo que usar <code>Array.from(str)</code>. La diferencia entre el m\u00e9todo <code>Array.from(obj)</code> y <code>[...obj]</code> es que el primer opera con array-likes e iterables y el segundo solo con iterables.</p> <p>El spread operator tambi\u00e9n puede ser usado con los objetos, teniendo la misma funcionalidad:</p> <pre><code>const obj = {a: 1, b:2 }\nconst newObject = {...obj, c:3}\n</code></pre> <p>Otro de los funcionamientos del operador es utilizarlo para realizar copias del array o del objeto, teniendo referencias diferentes. Esta manera de copiar un objeto es mucho m\u00e1s corta que <code>let objCopy = Object.assign({}, obj);</code> o para un array <code>let arrCopy = Object.assign([], arr);</code>por lo que preferimos usarla siempre que podemos.</p>"},{"location":"bloque_i/tema_6/page-6/#destructuracion-y-rest","title":"Destructuraci\u00f3n y rest","text":"<p>Como hemos visto en el apartado anterior, podemos realizar la destructuraci\u00f3n de objetos y de objetos iterables. Si el array o el objeto iterable, es mayor que la lista desestructurada, el resto de los elementos son omitidos.</p> <p>Todos los elementos omitidos, pueden ser asignados a un nuevo array u objeto iterable haciendo uso de <code>...varName</code>:</p> <pre><code>const [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\nalert(rest[0]); // Consul\nalert(rest[1]); // of the Roman Republic\nalert(rest.length); // 2\n</code></pre> <p>El valor de <code>rest</code> es un array con los elementos restantes del array original. Podemos usar cualquier otro nombre de variable en lugar de <code>rest</code>, s\u00f3lo hay que asegurar que tenga tres puntos que lo antecedan y que est\u00e9 \u00faltimo en la asignaci\u00f3n desestructurante.</p> <p>De la misma forma, cuando desestructuramos un objeto, omitiendo algunas propiedades, estas pueden ser recogidas en otro objeto haciendo uso de <code>rest</code>:</p> <pre><code>const options = {\ntitle: \"Menu\",\nheight: 200,\nwidth: 100\n}\nconst {title, ...rest} = options\nconsole.log(rest.height)  // 200\nconsole.log(rest.width)   // 100\n</code></pre>"},{"location":"bloque_i/tema_6/page-7/","title":"7 Colecciones inmutables","text":""},{"location":"bloque_i/tema_6/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>Un objeto es inmutable cuando su contenido no puede ser modificado. Hasta ahora, hemos visto, el concepto de constante, que es un tipo de variable que no puede cambiar su valor. Sin embargo, si yo creo un objeto completo, como un objeto, o un iterable o un array, de forma constante, si puedo modificar su contenido, a\u00f1adiendo, eliminado o reemplazando elementos:</p> <pre><code>const array = [1,2,3]\narray.push(4)\nconsole.log(array) // [1,2,3,4]\n</code></pre> <p>Son constantes porque no puede cambiar el valor referenciado en memoria, por lo que su espacio en memoria no puede ser cambiado por otro:</p> <pre><code>const array = [1,2,3]\narray = [4,5,6] // \u274c ERROR\n</code></pre> <p>Una colecci\u00f3n inmutable es aquella la cual no puede cambiar de posici\u00f3n en memoria, y adem\u00e1s no puede ser modificada su contenido. Este tipo de colecciones, suelen ser usadas para estructuras de datos que no se desean que sean modificadas en absoluto. Por ejemplo, obtener la lista de usuarios de una base de datos, no es conveniente que dicha lista pueda ser modificada y mostrar valores que no est\u00e1n en la base de datos.</p>"},{"location":"bloque_i/tema_6/page-7/#crear-colecciones-inmutables","title":"Crear colecciones inmutables","text":"<p>El m\u00e9todo <code>Object.freeze(obj)</code> crea una colecci\u00f3n inmutable, siendo obj cualquier tipo de estructura que se desea que sea inmutable:</p> <pre><code>const obj = Object.freeze({\nname: 'John',\nage: 35\n})\nobj.name = 'Helena' //(1)!\n</code></pre> <ol> <li>Lanza error en el modo estricto.</li> </ol> <p>Al intentar modificar el contenido de una colecci\u00f3n inmutable, esta modificaci\u00f3n ser\u00e1 ignorada. Si estamos en el modo estricto, al intentar modificar, dar\u00e1 un error.</p> <p>La colecci\u00f3n solamente es inmutable parcialmente, ya que si el objecto contiene otro tipos de estructuras \u00e9stas no son inmutables. Para evitar esto, se deber\u00eda realizar una inmutabilidad profunda.</p> <pre><code>function deepFreeze(obj) {\nconst propNames = Object.getOwnPropertyNames(obj);\nfor (const name of propNames) {\nconst value = obj[name];\nif (value &amp;&amp; typeof value === 'object') {\ndeepFreeze(value);\n}\n}\nreturn Object.freeze(obj);\n}\nconst obj = deepFreeze({\nname: 'John',\naddress: {\ncity: 'New York',\nzip: '10001'\n}\n})\nobj.name = 'Doe'\nobj.address.city = 'Los Angeles'\nconsole.log(obj) // { name: 'John', address: { city: 'New York', zip: '10001' } }\n</code></pre> <p>Con el m\u00e9todo <code>Object.seal(obj)</code> se permite crear un objeto al que no se le puede a\u00f1adir propiedades, sin embargo, permite la modificaci\u00f3n de los ya existentes.</p> <pre><code>const obj = Object.seal({\nname: 'John',\nage: 30\n})\nobj.name = 'Doe' // Permitido\ndelete obj.age // No har\u00e1 nada\nconsole.log(obj) // { name: 'Doe', age: 30 }\n</code></pre> <p>Ambos m\u00e9todos puede ser usados con objetos, con arrays, con mapas, con conjuntos y con cualquier estructura iterable:</p> <pre><code>const inmutableMap = Object.freeze(new Map([[\"key\", \"value\"]]))\n</code></pre>"},{"location":"bloque_i/tema_6/page-8/","title":"8 Fechas","text":""},{"location":"bloque_i/tema_6/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>El objeto <code>Date</code> es un objeto de Javascript que representa una unidad de tiempo. Este objeto almacena la fecha, la hora, y brinda m\u00e9todos para administrarlas.</p>"},{"location":"bloque_i/tema_6/page-8/#creacion","title":"Creaci\u00f3n","text":"<p>Para crear un nuevo objeto <code>Date</code> se lo instancia con su constructor <code>new Date()</code>. Si no se le indica ning\u00fan argumento, se obtendr\u00e1 la fecha y hora actual:</p> <pre><code>console.log(new Date()) // Fecha y hora actual\n</code></pre> <p>Si recibe un \u00fanico argumento num\u00e9rico, este argumento se entender\u00e1 un timestamp. Un timestamp es un n\u00famero entero que representa la cantidad de milisegundos transcurridos desde el inicio de 1970. Este timestamp es una representaci\u00f3n num\u00e9rica liviana de una fecha. Es posible crear una fecha a partir de un timestamp usando <code>new Date(timestamp)</code>, y convertir el objeto Date actual a un timestamp utilizando el m\u00e9todo <code>date.getTime()</code>. Las fechas anteriores a 01.01.1970 tienen timestamps negativos,</p> <pre><code>const Jan02_1970 = new Date(24 * 3600 * 1000)\nconsole.log(Jan02_1970)\n</code></pre> <p>Si por el contrario, se pasa un \u00fanico argumento de cadena, entonces la cadena ser\u00e1 analizada y se convierte en fecha autom\u00e1ticamente.</p> <pre><code>const date = new Date(\"2017-01-26\")\n</code></pre> <p>Tambi\u00e9n se puede crear una fecha con los siguientes argumentos <code>new Date(a\u00f1o, mes, d\u00eda, horas, minutos, segundos, ms)</code> siendo solamente obligatorio los dos primeros.:</p> <ul> <li>El a\u00f1o deber\u00eda tener 4 d\u00edgitos. Por compatibilidad, aqu\u00ed 2 d\u00edgitos ser\u00e1n considerados 19xx, pero 4 d\u00edgitos es lo firmemente sugerido.</li> <li>La cuenta del mes comienza desde el 0 (enero), y termina en el 11 (diciembre).</li> <li>El par\u00e1metro fecha efectivamente es el d\u00eda del mes, si est\u00e1 ausente se asume su valor en 1.</li> <li>Si los par\u00e1metros horas/minutos/segundos/ms est\u00e1n ausentes, se asumen sus valores iguales a 0</li> </ul> <pre><code>new Date(2011, 0, 1, 0, 0, 0, 0) // 1 Jan 2011, 00:00:00\nnew Date(2011, 0, 1)\n</code></pre>"},{"location":"bloque_i/tema_6/page-8/#metodos-para-trabajar-con-los-componentes","title":"M\u00e9todos para trabajar con los componentes","text":"<p>Una vez creado el objeto <code>Date</code>, dicho objeto dispone de varios m\u00e9todos que se encargan de obtener las diferentes partes de una fecha. Entre ellos, encontramos:</p> <ul> <li><code>getFullYear()</code>. Devuelve el a\u00f1o con 4 d\u00edgitos.</li> <li><code>getMonth()</code>. Devuelve el mes de 0 (Enero) a 11 (Diciembre).</li> <li><code>getDate()</code>. Devuelve el d\u00eda del mes, un n\u00famero comprendido entre 0 y 31.</li> <li><code>getHours()</code>. Obtiene la hora.</li> <li><code>getMinutes()</code>. Obtiene los minutos.</li> <li><code>getSeconds()</code>. Obtiene los segundos.</li> <li><code>getMilliseconds()</code>. Devuelve los componentes horario correspondientes.</li> <li><code>getDay()</code>. Devuelve el d\u00eda de la semana, siendo 0 el Domingo hasta el 6 siendo S\u00e1bado.</li> <li><code>getTime()</code>. Devuelve el timestamp de una fecha.</li> <li><code>getTimezoneOffset()</code>. Devuelve la diferencia entre UTC y el huso horario actual, en minutos.</li> </ul> <p>Todos estos m\u00e9todos devuelven los componentes correspondientes a la zona local.Adem\u00e1s, existes los m\u00e9todos UTC, que devuelven los componentes para la zona horaria UTC+0, a excepci\u00f3n de <code>getTime()</code> y <code>getTimezoneOffset()</code>. Esos m\u00e9todos tienen una nomenclatura similar a los anteriores, solo hay que poner la palabra UTC entre get y el nombre del m\u00e9todo, por ejemplo: <code>getUTCFullYear()</code>, <code>getUTCDay()</code>, etc.</p> <p>Al igual que tenemos los m\u00e9todos para obtener los componentes, existen diferentes m\u00e9todos para modificarlos. Su nomenclatura es bastante similar, sustituyendo el get por el set.</p> <ul> <li><code>setFullYear(year, [month], [date])</code>. Espec\u00edfica el a\u00f1o de una fecha, as\u00ed como de forma opcional, el mes y el d\u00eda.</li> <li><code>setMonth(month, [date])</code>. Espec\u00edfica el mes de una fecha, as\u00ed como de forma opcional, el d\u00eda.</li> <li><code>setDate(date)</code>. Espec\u00edfica el d\u00eda de una fecha.</li> <li><code>setHours(hour, [min], [sec], [ms])</code>. Espec\u00edfica la hora de una fecha, as\u00ed como de forma opcional, los minutos, los segundos y los milisegundos.</li> <li><code>setMinutes(min, [sec], [ms])</code>. Espec\u00edfica los minutos de una fecha, as\u00ed como, opcionalmente, los segundos y milisegundos.</li> <li><code>setSeconds(sec, [ms])</code>. Espec\u00edfica los segundos de una fecha, y opcionalmente, los milisegundos.</li> <li><code>setMilliseconds(ms)</code>. Espec\u00edfica los milisegundos de una fecha.</li> <li><code>setTime(ms)</code>. Establece la cantidad de segundos transcurridos desde 01.01.1970 GMT+0.</li> </ul> <p>A excepci\u00f3n de <code>setTime()</code>, todos los dem\u00e1s m\u00e9todos poseen una variante UTC, por ejemplo: <code>setUTCHours()</code>.</p> <pre><code>const date = new Date()\nconsole.log('Year:', date.getFullYear())\ndate.setFullYear(2020)\nconsole.log('Year:', date.getFullYear()) // 2020\n</code></pre>"},{"location":"bloque_i/tema_6/page-8/#autocorreccion","title":"Autocorrecci\u00f3n","text":"<p>La autocorrecci\u00f3n es una caracter\u00edstica muy \u00fatil de los objetos <code>Date</code>. Podemos fijar valores fuera de rango, y se ajustar\u00e1n autom\u00e1ticamente. Veamos un ejemplo:</p> <pre><code>const date = new Date(2013, 0, 32)\nconsole.log(date) // 1-02-2013\n</code></pre> <p>Los componentes de la fecha que est\u00e1n fuera de rango se distribuyen autom\u00e1ticamente. Por ejemplo, supongamos que necesitamos incrementar la fecha 28 Feb 2016 en 2 d\u00edas. El resultado puede ser 2 Mar o 1 Mar dependiendo de si es a\u00f1o bisiesto. Afortunadamente, no tenemos de qu\u00e9 preocuparnos. S\u00f3lo debemos agregarle los 2 d\u00edas y el objeto <code>Date</code> se encargar\u00e1 del resto:</p> <pre><code>const date = new Date(2016, 1, 28)\ndate.setDate(date.getDate() + 2)\nconsole.log(date) // 1 Mar 2016\n</code></pre> <p>Esta caracter\u00edstica se usa frecuentemente para obtener la fecha, a partir de un per\u00edodo de tiempo espec\u00edfico. Por ejemplo, supongamos que queremos obtener la fecha de hoy pero transcurridos 70 segundos a partir de este preciso instante.</p> <pre><code>const date = new Date()\ndate.setSeconds(date.getSeconds() + 70)\nconsole.log(date) // Se muestra la fecha correcta.\n</code></pre> <p>Tambi\u00e9n podemos fijar valores en 0 o incluso valores negativos. Por ejemplo:</p> <pre><code>const date = new Date(2016, 0, 2) // 2 Jan 2016\ndate.setDate(1)\nconsole.log(date) // 1 Jan 2016\ndate.setDate(0)\nconsole.log(date) // 31 Dec 2015\n</code></pre>"},{"location":"bloque_i/tema_6/page-8/#conversion-de-fechas-a-numeros","title":"Conversi\u00f3n de fechas a n\u00fameros","text":"<p>Cuando convertimos un objeto <code>Date</code> a n\u00famero toma el valor del timestamp actual, al igual que el m\u00e9todo <code>date.getTime()</code>:</p> <pre><code>const date = new Date()\nconsole.log(+date) // similar a date.getTime()\n</code></pre> <p>Las fechas pueden ser restadas, el resultado es su diferencia en milisegundos. Suele ser usado para la medici\u00f3n de tiempo:</p> <pre><code>const start = new Date() // simula una operaci\u00f3n de 100.000 milisegundos\nfor (const i = 0; i &lt; 100000; i++) {\nconst doSomething = i * i * i\n}\nconst end = new Date()\nconsole.log(`El tiempo transcurrido es de ${end - start} ms`)\n</code></pre>"},{"location":"bloque_i/tema_6/page-8/#fecha-actual","title":"Fecha actual","text":"<p>Para obtener los milisegundos actuales, hasta hora cre\u00e1bamos un objeto con <code>new Date()</code> y llamabamos al m\u00e9todo <code>getTime()</code>. Sin embargo, existe un m\u00e9todo est\u00e1tico <code>Date.now()</code> que nos devuelve el timestamp actual. Esta forma es mucho m\u00e1s r\u00e1pida, y por lo consiguiente, no afecta al recolector de basura.</p> <p>Mayormente se utiliza por conveniencia o cuando la performance del c\u00f3digo es fundamental, como por ejemplo en juegos de JavaScript u otras aplicaciones espec\u00edficas.</p> <p>Veamos el ejemplo anterior con el nuevo m\u00e9todo:</p> <pre><code>const start = Date.now() // simula una operaci\u00f3n de 100.000 milisegundos\nfor (const i = 0; i &lt; 100000; i++) {\nconst doSomething = i * i * i\n}\nconst end = Date.now()\nconsole.log(`El tiempo transcurrido es de ${end - start} ms`)\n</code></pre>"},{"location":"bloque_i/tema_6/page-8/#formato-de-fecha","title":"Formato de fecha","text":"<p>En JavaScript, el constructor <code>new Date()</code> puede aceptar una cadena que representa una fecha. Hay varios formatos de cadena que son compatibles con <code>new Date()</code>, como el formato UTC, el formato ISO, o formatos personalizados. Si una fecha es creada a partir de una cadena y \u00e9sta no es correcta, se retornar\u00e1 un <code>Invalid Date</code>.</p> <p>Existen diferentes patrones para especifica una fecha, por ejemplo <code>YY</code> representa la fecha con dos d\u00edgitos, <code>MM</code>, el mes con dos d\u00edgitos, etc. Al hacer uso de estas expresiones puede dar lugar a ambig\u00fcedades dependiendo del la zona horaria en la que te encuentres, por lo que no se recomienda su uso.</p> <p>Sin embargo, Javascript, dispone de diferentes m\u00e9todos que realizan dichas operaciones de forma segura.</p> <p>El primero de ellos <code>toString()</code> devuelve la fecha con un formato UTC con la timezone correspondiente a su llamada, existe el m\u00e9todo equivalente UTC <code>toUTCString()</code>:</p> <pre><code>const event = new Date('August 19, 1975 23:15:30')\nconsole.log(event.toString()) // Tue Aug 19 1975 23:15:30 GMT+0200 (CEST)\n</code></pre> <p>Tambi\u00e9n existe el m\u00e9todo <code>toDateString()</code> que devuelve una cadena con solo la fecha, en formato UTC (y un similar <code>toTimeString()</code> para \u00fanicamente el tiempo).</p> <pre><code>const event = new Date('August 19, 1975 23:15:30')\nconsole.log(event.toDateString()) // Tue Aug 19 1975\n</code></pre> <p>Si se desea obtener la fecha en formato ISO 8601, existe el m\u00e9todo <code>toISOString()</code>. El formato ISO es similar a: <code>YYYY-MM-ddTHH:mm:ss.ms</code></p> <pre><code>const date = new Date()\nconst isoString = date.toISOString()\nconsole.log(isoString) // 2024-05-28T12:35:20.000Z\n</code></pre> <p>El m\u00e9todo <code>toLocaleString([locale], [options])</code> devuelve una cadena con el formato local indicado:</p> <pre><code>const date = new Date();\nconst formattedDate = date.toLocaleString('en-US') // Formato para EE.UU.\nconsole.log(formattedDate) // 5/28/2024, 18:00:00\nconst formattedDateEs = date.toLocaleString('es-ES') // Formato para Espa\u00f1a\nconsole.log(formattedDateEs) // 28/5/2024, 18:00:00\n</code></pre> <p>Pueden recibir un objeto con las opciones a modificar de la cadena a devolver. Entre sus propiedades encontramos:</p> <ul> <li><code>weekday</code>. Indica el nombre de la semana. Puede tener tres valores diferentes: <code>long</code> para indicar el nombre completo (ej: Tuesday), <code>short</code> para indicar el nombre con las tres primeras letras (ej: Tue), o <code>narrow</code> para indicar el nombre con la inicial (ej: <code>T</code>).</li> <li><code>year</code>. Representa el a\u00f1o. Sus valores pueden ser <code>numeric</code> para mostrar el a\u00f1o con los 4 d\u00edgitos o <code>2-digit</code> para representarlo con 2.</li> <li><code>month</code>. Representa el mes. Sus valores pueden ser, para representar el nombre: <code>long</code>, <code>short</code>, <code>narrow</code>; y para representarlo en d\u00edgito: <code>numeric</code>, que representa el mes con el n\u00famero del mes (ej: 5) o <code>2-digit</code> (ej: 05).</li> <li><code>day</code>: Representa el d\u00eda del mes. Sus valores pueden ser <code>numeric</code> o <code>2-digit</code>.</li> <li><code>timezone</code>: Espec\u00edfica la zona a utilizar.</li> <li><code>timezoneName</code>: Representa la forma en la que se representa.</li> <li><code>hour</code>, <code>minute</code>, <code>second</code>: Representa horas, minutos y segundos respectivamente, pudiendo ser sus valores <code>numeric</code> o <code>2-digit</code>.</li> <li><code>hour12</code>: Indica si la hora se representa con formato 12 (<code>true</code>) o 24 (<code>false</code>) horas. Si el valor es <code>true</code>, adem\u00e1s se a\u00f1adir\u00e1 AM o PM seg\u00fan el caso.</li> </ul> <pre><code>const options = {\nyear: 'numeric',\nmonth: 'long',\nday: 'numeric',\nhour: 'numeric',\nminute: 'numeric',\nsecond: 'numeric',\nhour12: true\n}\nconsole.log(new Date().toLocaleString('es-ES', options)) // 30 de mayo de 2024, 11:37:57 a. m.\n</code></pre> <p>Adem\u00e1s,existen los m\u00e9todos <code>toLocaleDateString()</code> y <code>toLocaleTimeString()</code> para formatear solo la fecha o la hora, respectivamente.</p> <p>El m\u00e9todo <code>Date.parse(str)</code> permite convertir una cadena en una fecha, devolviendo un timestamp. Si el formato no es v\u00e1lido retorna un <code>NaN</code>:</p> <pre><code>const date = new Date(Date.parse(\"2012-01-26T13:51:50.417-07:00\"))\nconsole.log(date)\n</code></pre>"},{"location":"bloque_i/tema_6/page-9/","title":"JSON","text":""},{"location":"bloque_i/tema_6/page-9/#introduccion","title":"Introducci\u00f3n","text":"<p>JSON (JavaScript Object Notation) es un formato ligero de intercambio de datos que es f\u00e1cil de leer y escribir tanto para los humanos como para las m\u00e1quinas. Se utiliza ampliamente para transmitir datos en aplicaciones web, particularmente entre un cliente (como un navegador web) y un servidor.</p> <p>JSON tiene una sintaxis simple y f\u00e1cil de entender. JSON se basa en texto, lo que lo hace independiente del lenguaje y f\u00e1cil de manipular y generar. Permite representar estructuras de datos complejas, como objetos y arrays, de una manera estructurada y organizada.</p>"},{"location":"bloque_i/tema_6/page-9/#estructura-de-un-json","title":"Estructura de un JSON","text":"<p>La estructura de un objeto JSON es igual a la de un objeto de Javascript. La principal diferencia es que JSON es una estructura de datos basado en texto, es decir, en una cadena (<code>string</code>). En los lenguajes basados en el servidor (o en Node JS de Javascript), se puede utilizar dichas cadenas para introducirlas en ficheros de texto de extensi\u00f3n <code>.json</code>.</p> <p>Un objeto JSON debe ser o un objeto javascript o un array de objetos javascript.</p> <pre><code>const json = `{\n  \"nombre\": \"Juan\",\n  \"edad\": 30,\n  \"casado\": false,\n  \"hijos\": [\n    {\n      \"nombre\": \"Ana\",\n      \"edad\": 10\n    },\n    {\n      \"nombre\": \"Luis\",\n      \"edad\": 8\n    }\n  ],\n  \"direccion\": {\n    \"calle\": \"Calle Falsa\",\n    \"numero\": 123,\n    \"ciudad\": \"Madrid\"\n  }\n}`\n</code></pre>"},{"location":"bloque_i/tema_6/page-9/#conversiones-a-json","title":"Conversiones a JSON","text":"<p>El m\u00e9todo <code>JSON.stringify(obj)</code> pasa un objeto javascript a un objeto cadena JSON.</p> <pre><code>const student = {\nname: 'John',\nage: 30,\nisAdmin: false,\ncourses: ['html', 'css', 'js'],\nspouse: null\n}\nconst json = JSON.stringify(student)\nconsole.log(json)\n/*\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"isAdmin\": false,\n  \"courses\": [\"html\", \"css\", \"js\"],\n  \"spouse\": null\n}\n*/\n</code></pre> <p>Si se le pasa un tipo de dato que no sea objeto o lista el m\u00e9todo retornara el dato en forma de cadena:</p> <pre><code>console.log(JSON.stringify(1)) // \"1\"\n</code></pre> <p>JSON es una especificaci\u00f3n de s\u00f3lo datos independiente del lenguaje, por lo tanto algunas propiedades de objeto espec\u00edficas de Javascript son omitidas por <code>JSON.stringify(obj)</code> como, funciones o m\u00e9todos, propiedades simb\u00f3licas y propiedades que almacenan <code>undefined</code>.</p> <pre><code>const user = {\nname: 'John'\nsayHi() {\nconsole.log(\"Hello\")\n},\n[Symbol(\"id\")]: 123,\nsomething: undefined\n}\nconsole.log(JSON.stringify(user)) // {\"name\": \"John\"}\n</code></pre> <p>Si el objeto o array contiene otros objetos o array anidados, estos ser\u00e1n pasados a cadena de forma autom\u00e1tica, por lo que no es necesario realizar un bucle recursivo:</p> <p>Otra de las ventajas de este m\u00e9todo es que si el objeto o array de objetos contiene una referencia a otro array u objeto, dicha referencia ser\u00e1 sustituida por dicho valor y ser\u00e1 pasado a cadena JSON:</p> <pre><code>const student = {\nname: \"John Smith\",\nage: 20\n}\nconst course = {\nname: \"1\u00baDAM\",\nstudents: [student]\n}\nconsole.log(JSON.stringify(course))\n// {\"name\":\"1\u00baDAM\",\"students\":[{\"name\":\"John Smith\",\"age\":20}]}\n</code></pre> <p>Sin embargo, si existiesen referencias circulares, ese decir, que un objeto referencia a otro que le esta referenciando as\u00ed mismo (objeto A referencia a objeto B y objeto B referencia a objeto A), se lanzar\u00e1 un error\ud83e\uddee</p> <pre><code>const room = {\nnumber: 23\n}\nconst meetup = {\ntitle: \"Conference\",\nparticipants: [\"john\", \"ann\"]\n}\nmeetup.place = room      room.occupiedBy = meetup\nJSON.stringify(meetup) // \u274c Error\n</code></pre> <p>El m\u00e9todo <code>JSON.stringify(obj, [replacer], [space])</code> puede recibir dos par\u00e1metros m\u00e1s. El replacer puede ser un array de propiedades a mostrar, omitiendo as\u00ed el resto de propiedades:</p> <pre><code>const room = {\nnumber: 23\n}\nconst meetup = {\ntitle: \"Conference\",\nparticipants: [{name: \"John\"}, {name: \"Alice\"}],\nplace: room // meetup hace referencia a room\n}\nroom.occupiedBy = meetup // room hace referencia a meetup\nconsole.log(JSON.stringify(meetup, ['title', 'participants']))\n// {\"title\":\"Conference\",\"participants\":[{},{}]}\n</code></pre> <p>El replacer tambi\u00e9n puede ser una funci\u00f3n que llame a cada par clave-valor y devuelva el valor sustituido o un <code>undefined</code> para ser omitido. Siguiendo el ejemplo anterior, se quiere devolver el objeto en JSON a excepci\u00f3n de la propiedad <code>occupiedBy</code>:</p> <pre><code>let room = {\nnumber: 23\n}\nlet meetup = {\ntitle: \"Conference\",\nparticipants: [{name: \"John\"}, {name: \"Alice\"}],\nplace: room }\nroom.occupiedBy = meetup\nconsole.log( JSON.stringify(meetup, function replacer(key, value) {\nreturn (key == 'occupiedBy') ? undefined : value;\n}))\n</code></pre> <p>De esta forma, se ha evitado la referencia circular. El valor de <code>this</code> dentro de replacer es el objeto que contiene la propiedad actual.</p> <p>Tenga en cuenta que la funci\u00f3n replacer recibe todos los pares de propiedad/valor incluyendo objetos anidados y elementos de array. El primer llamado es especial. Se realiza utilizando un Objeto contenedor especial: <code>{\"\": meetup}</code>. En otras palabras, el primer par (propiedad, valor) tiene una propiedad vac\u00eda, y el valor es el objeto objetivo como un todo.</p> <p>La idea es proporcionar tanta capacidad para replacer como sea posible tiene una oportunidad de analizar y reemplazar/omitir incluso el objeto entero si es necesario.</p> <p>Otro uso que se le puede dar a los replacer es el formate de fecha especifico. Cuando se pasa una fecha con el m\u00e9todo <code>JSON.stringify()</code>, se obtiene una cadena de fecha simple:</p> <pre><code>const user = {\nname: 'John',\nage: 20,\nborn: new Date(1996, 6, 6)\n}\nconsole.log(JSON.stringify(user))\n//{\"name\":\"John\",\"age\":20,\"born\":\"1996-07-05T22:00:00.000Z\"}\n</code></pre> <p>Gracias al par\u00e1metro funci\u00f3n replacer se le puede dar el formato deseado, pero hay que tener en cuenta que el par\u00e1metro value es de tipo <code>string</code> a pesar de que el valor de la propiedad sea <code>Date</code>:</p> <pre><code>const user = {\nname: 'John',\nage: 20,\nborn: new Date(1996, 6, 6)\n}\nconsole.log(JSON.stringify(user, (key, value) =&gt; {\nif(key === 'born') return new Date(value).toLocaleDateString('es-ES', {year: '2-digit', month: 'long', day: '2-digit'})\nreturn value\n}))\n// {\"name\":\"John\",\"age\":20,\"born\":\"06 de julio de 96\"}\n</code></pre> <p>El siguiente argumento opcional de <code>JSON.stringify(obj, [replacer], [space])</code>  es el n\u00famero de espacios a utilizar para un formato agradable, tambi\u00e9n conocido como pretty-printing. Anteriormente todos los objetos convertidos a <code>String</code> no ten\u00edan sangr\u00eda ni espacios adicionales. Eso est\u00e1 bien si queremos enviar un objeto por la red. El argumento space es utilizado exclusivamente para una salida agradable. El siguiente ejemplo, mostrar\u00e1 el JSON en formato agradable:</p> <pre><code>const user = {\nname: \"John\",\nage: 25,\nroles: {\nisAdmin: false,\nisEditor: true\n}\n}\nconsole.log(JSON.stringify(user, null, 2))\n/*\n{\n  \"name\": \"John\",\n  \"age\": 25,\n  \"roles\": {\n    \"isAdmin\": false,\n    \"isEditor\": true\n  }\n}\n*/\n</code></pre> <p>El valor space tambi\u00e9n puede ser una cadena. En dicho caso, representa el car\u00e1cter que se muestra como identaci\u00f3n.</p> <pre><code>const user = {\nname: \"John\",\nage: 25,\nroles: {\nisAdmin: false,\nisEditor: true\n}\n}\nconsole.log(JSON.stringify(user, null, \"----\"))\n/*\n{\n----\"name\": \"John\",\n----\"age\": 25,\n----\"roles\": {\n--------\"isAdmin\": false,\n--------\"isEditor\": true\n----}\n}\n*/\n</code></pre> <p>Se puede personalizar la salida en cadena de las propiedades de los objetos, escribiendo el m\u00e9todo <code>toJSON()</code> dentro del objeto. Volvamos al ejemplo de las fechas:</p> <pre><code>const user = {\nname: 'John',\nage: 20,\nborn: new Date(1996, 6, 6),\ntoJSON(){\nconst entries = Object.entries(this).map(([key, value]) =&gt; {   if(key === 'born') {\nconst str = value.toLocaleDateString('es-ES', {year: '2-digit', month: 'long', day: '2-digit'})\nreturn [key, str]\n}\nreturn [key, value]\n})\nreturn Object.fromEntries(entries)\n}\n}\nconsole.log(JSON.stringify(user))\n</code></pre>"},{"location":"bloque_i/tema_6/page-9/#conversiones-a-objetos","title":"Conversiones a objetos","text":"<p>Para pasar de una cadena JSON a un objeto o array en javascript, existe el m\u00e9todo <code>JSON.parse(str, [reviver])</code>, donde recibe la cadena y una funci\u00f3n reviver que ser\u00e1 llamada para cada clave-valor y as\u00ed transformar el valor:</p> <pre><code>const str = \"[0, 1, 2, 3]\"\nconst numbers = JSON.parse(str)\nconsole.log(numbers[1]) // 1\n</code></pre> <p>Tambi\u00e9n se parsea de forma autom\u00e1tica los objetos o arrays anidados:</p> <pre><code>const userData = '{ \"name\": \"John\", \"age\": 35, \"isAdmin\": false, \"friends\": [0,1,2,3] }'\nconst user = JSON.parse(userData)\nconsole.log(user.friends[1]) // 1\n</code></pre> <p>\u00a1Cuidado!</p> <p>El JSON puede ser tan complejo como sea necesario, los objetos y arrays pueden incluir otros objetos y arrays. Pero deben cumplir el mismo formato JSON. Aqu\u00ed algunos de los errores m\u00e1s comunes al escribir JSON a mano (a veces tenemos que escribirlo por debugging):</p> <pre><code>let json = `{\n  name: \"John\",                     // error: nombre de propiedad sin comillas\n  \"surname\": 'Smith',               // error: comillas simples en valor (debe ser doble)\n  'isAdmin': false                  // error: comillas simples en propiedad (debe ser doble)\n  \"birthday\": new Date(2000, 2, 3), // error: no se permite \"new\", \u00fanicamente valores simples\n  \"friends\": [0,1,2,3]              // aqu\u00ed todo bien\n}`\n</code></pre> <p>Adem\u00e1s, JSON no admite comentarios. Agregar un comentario a JSON lo hace inv\u00e1lido.</p> <p>Por \u00faltimo, podemos usar el m\u00e9todo reviver para poder cambiar el valor de alguna propiedad. Hagamos el ejemplo de la fecha al contrario, en este caso lo obtenido por el valor de la fecha es una cadena y no un objeto de tipo <code>Date</code>, por lo que sea cual sea la cadena, es necesario parsearla a fecha:</p> <pre><code>const json = '{\"name\":\"John\",\"age\":20,\"born\":\"1996-07-05T22:00:00.000Z\"}'\nconst user = JSON.parse(json, (key, value) =&gt; {\nif(key !== 'born') return value\nreturn new Date(value)\n})\nconsole.log(user) // object\n</code></pre>"},{"location":"bloque_i/tema_7/page-1/","title":"1 Introducci\u00f3n a las expresiones regulares","text":""},{"location":"bloque_i/tema_7/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Una expresi\u00f3n regular es una secuencia de caracteres que forma un patr\u00f3n de b\u00fasqueda proporcionando una manera muy flexible de buscar o reemplazar cadenas de texto. En Javascript se encuentran disponibles a trav\u00e9s del objeto <code>RegExp</code>, y de algunos m\u00e9todos de cadenas.</p> <p>Una expresi\u00f3n regular debe constar de un patr\u00f3n de caracteres, que se buscar\u00e1 en la cadena, ya sea para devolverla o para reemplazarla. Adem\u00e1s, se le pueden indicar diferentes tipos de configuraci\u00f3n llamadas flags (banderas).</p> <p>Un patr\u00f3n puede ser una cadena exacta, o una secuencia de caracteres que ampl\u00ede las posibilidades. Por ejemplo:</p> <ul> <li>Hola mundo es patr\u00f3n exacto, por lo que se comprobar\u00e1 si la cadena a comprobar es exactamente la indicada.</li> <li>Empezar por un n\u00famero es un patr\u00f3n flexible, nos permite comprobar si la cadena empieza o no por n\u00famero, cualquiera de ellos (0-9).</li> </ul>"},{"location":"bloque_i/tema_7/page-1/#creacion-de-un-expresion-regular","title":"Creaci\u00f3n de un expresi\u00f3n regular","text":"<p>Para crear una expresi\u00f3n regular podemos usar el constructor de objetos de la clase <code>RegEx(pattern, [flags])</code>, que recibe dos par\u00e1metros: el patr\u00f3n a comprobar y las banderas (configuraciones) a aplicar.</p> <pre><code>const regex = new RegEx(pattern, flags)\n</code></pre> <p>Existe una forma m\u00e1s corta de crear una expresi\u00f3n regular, haciendo uso de las barras <code>/pattern/flags</code>:</p> <pre><code>const regex = /pattern/\nconst regexWithFlags = /pattern/flags\n</code></pre>"},{"location":"bloque_i/tema_7/page-1/#banderas","title":"Banderas","text":"<p>Como hemos anteriormente, una bandera (flag) es una configuraci\u00f3n que se aplica a la expresi\u00f3n regular a la hora de buscar en una cadena. En Javascript, existen 6 diferentes:</p> <ul> <li>Case insensitive (<code>i</code>). No distingue entre may\u00fasculas y min\u00fasculas.</li> <li>All coincidences (<code>g</code>). Encuentra todas las coincidencias que cumplan la expresi\u00f3n regular, por el contrario solo devuelve la primera coincidencia.</li> <li>Multiline (<code>m</code>). Modo multil\u00ednea (se desarrolla m\u00e1s adelante)</li> <li>Dotall (<code>s</code>). Permite que el punto, <code>.</code>, coincida con el car\u00e1cter de l\u00ednea nueva.</li> <li>Unicode support (<code>u</code>). Permite soporte completo a Unicode.</li> <li>Adhesive (<code>y</code>). Modo adhesivo, es decir, b\u00fasqueda en la posici\u00f3n exacta del texto.</li> </ul>"},{"location":"bloque_i/tema_7/page-1/#busqueda-en-cadenas","title":"B\u00fasqueda en cadenas","text":"<p>El m\u00e9todo <code>match(regEx)</code>, es un m\u00e9todo de cadena que comprueba si la cadena cumple con la expresi\u00f3n regular indicada. Puede funcionar de formas diferentes:</p> <ul> <li> <p>Si tiene un flag <code>g</code> devuelve un arreglo con todas las coincidencias.</p> <pre><code>const str = 'We will, we will rock you'\nconsole.log(str.match(/we/gi)) // [We, we]\n</code></pre> </li> <li> <p>Si no existe dicha flag, devolver\u00e1 un array cuya primera posici\u00f3n ser\u00e1 la coincidencia. Aunque puede contener m\u00e1s \u00edndices, el resto de \u00edndices ser\u00e1 tratados posteriormente. Adem\u00e1s, tiene propiedades informativas, como <code>index</code>, que devuelve el n\u00famero del \u00edndice que contiene la coincidencia, e <code>input</code> que devuelve la cadena en la cual se hace la b\u00fasqueda.</p> <pre><code>const str = 'We will, we will rock you'\nconst result = str.match(/we/i)\nconsole.log(result[0]) // We\nconsole.log(result.length) // 1\nconsole.log(result.index) // 0\nconsole.log(result.input) // We will, we will rock you\n</code></pre> </li> <li> <p>Si no existe coincidencia, se devolver\u00e1 un null.</p> <pre><code>const str = 'Javascript'\nconsole.log(str.match(/HTML/)) // null\n</code></pre> <p>Es importante recalcar, que no devuelve un array vac\u00edo, simplemente retorna un <code>null</code>. No entender esto, puede provocar errores como el siguiente:</p> <pre><code>const result = 'Javascript'.match(/HTML/)\nif(!result.length){ // (1)!\nconsole.log('ERROR')\n}\n</code></pre> <ol> <li>\u274c\u274cNo se puede leer la propiedad <code>length</code> de un <code>null</code>\u274c\u274c</li> </ol> <p>Una forma de evitar este error, es haciendo uso del operador <code>??</code></p> <pre><code>const result = 'Javascript'.match(/HTML/) ?? []\nif(!result.length){     console.log('ERROR')\n}\n</code></pre> </li> </ul>"},{"location":"bloque_i/tema_7/page-1/#reemplazar-en-cadenas","title":"Reemplazar en cadenas","text":"<p>El m\u00e9todo <code>replace(regex, replacement)</code> reemplaza las coincidencias encontradas de la expresi\u00f3n regular, por los valores indicados <code>replacement</code>. Por ejemplo:</p> <pre><code>console.log('We will, we will'.replace(/we/i, \"I\")) // I will, we will\nconsole.log('We will, we will'.replace(/we/ig, \"I\")) // I will, I will\n</code></pre> <p>El argumento replacement puede usar combinaciones especiales para poder insertar fragmentos en la coincidencia:</p> <ul> <li><code>$&amp;</code> - Inserta toda la coincidencia.</li> <li><code>$`</code> - Inserta una parte de la cadena antes de la coincidencia.</li> <li><code>$'</code> - Inserta una parte de la cadena despu\u00e9s de la coincidencia.</li> <li><code>$n</code> - Si <code>n</code> es un n\u00famero de 1 o 2 d\u00edgitos, entonces inserta el contenido de los par\u00e9ntesis n-\u00e9simo (desarrollado m\u00e1s adelante)</li> <li><code>$&lt;name&gt;</code> - Inserta el contenido de los par\u00e9ntesis con el nombre dado.</li> <li><code>$$</code> - Inserta el car\u00e1cter <code>$</code>.</li> </ul> <pre><code>console.log('Me gusta HTML'.replace(/HTML/, \"$&amp; y Javascript\")) // Me gusta HTML y Javascript\n</code></pre>"},{"location":"bloque_i/tema_7/page-1/#metodo-test","title":"M\u00e9todo test","text":"<p>El m\u00e9todo <code>test(str)</code> es un m\u00e9todo de la clase <code>RegEx</code> que comprueba si el patr\u00f3n aparece en la cadena, al menos una vez. Devuelve <code>true</code> si encuentra coincidencia, <code>false</code> por lo contrario.</p> <pre><code>const str = 'Me gusta Javascript'\nconst regEx = /gusta/i\nconsole.log(regEx.test(str)) // true\n</code></pre>"},{"location":"bloque_i/tema_7/page-2/","title":"2 Clases de caracteres","text":""},{"location":"bloque_i/tema_7/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Una clase de caracteres es una notaci\u00f3n especial que coincide con cualquier s\u00edmbolo de un determinado conjunto</p> <p>Entre las diferentes clases de caracteres, la m\u00e1s usadas son:</p> <ul> <li><code>\\d</code>. Representa un d\u00edgito, es decir, un car\u00e1cter de <code>0</code> a <code>9</code>.</li> <li><code>\\w</code>. Representa un car\u00e1cter de palabra, es decir, letra de alfabeto latino, un d\u00edgito, o un gui\u00f3n bajo (<code>_</code>). Las letras no latina no pertenecen a este conjunto.</li> <li><code>\\s</code>. Representa un espacio en blanco, incluyendo tabulaciones, l\u00edneas nuevas, etc.</li> </ul> <pre><code>const str = '+7(903)-123-45-67'\nconst regEx = /\\d/g\nconsole.log(str.match(regEx)) // [7, 9, 0, 3, 1, 2, 3, 4, 5, 6, 7]\n</code></pre> <p>Los conjuntos pueden ser usados individualmente o seguidos. Por ejemplo, la expresi\u00f3n <code>/\\d\\s\\w/i</code> indica que buscamos un n\u00famero seguido de un espacio seguido de un car\u00e1cter de palabra.</p>"},{"location":"bloque_i/tema_7/page-2/#inversas","title":"Inversas","text":"<p>Para cada clase de caracteres que hemos visto anteriormente, existe una clase inversa, indicada con la misma letra pero en may\u00fasculas y hace que coincida con el resto de caracteres que no cumple con el conjunto original:</p> <ul> <li><code>\\D</code>. Representa cualquier car\u00e1cter que no sea un d\u00edgito.</li> <li><code>\\W</code>. Representa cualquier car\u00e1cter que no sea un car\u00e1cter de palabra, como un car\u00e1cter no latino, o un espacio.</li> <li><code>\\S</code>. Representa cualquier car\u00e1cter que no sea un espacio.</li> </ul> <pre><code>const str = '+7(903)-123-45-67'\nconst regEx = /\\D/g\nconsole.log(str.replace(regEx, str)) // 79031234567\n</code></pre>"},{"location":"bloque_i/tema_7/page-2/#punto","title":"Punto","text":"<p>El patr\u00f3n punto (<code>.</code>) es una clase de caracteres especial que representa a cualquier car\u00e1cter excepto a una nueva l\u00ednea.</p> <pre><code>console.log(/./.test('Z')) // true\n</code></pre> <p>El punto, por defecto, no contempla el salto de l\u00ednea (<code>\\n</code>), por lo que la siguiente expresi\u00f3n va a dar null:</p> <pre><code>console.log('A\\nB'.match(/A.B/)) // null\n</code></pre> <p>Sin embargo, haciendo uso de la bandera <code>\\s</code>, hace que el punto contemple el salto de l\u00ednea como cualquier car\u00e1cter. De esta forma, el ejemplo anterior, ya tiene una coincidencia:</p> <pre><code>console.log('A\\nB'.match(/A.B/s)) // [A\\nB]\n</code></pre> <p>Warning</p> <p>Por lo general, se presta poco atenci\u00f3n a los espacios, se da por hecho que las cadenas <code>1-5</code> y <code>1 - 5</code> son id\u00e9nticas, cuando en realidad no lo son. A la hora de comprobar un patr\u00f3n sobre una cadena hay que tener en cuenta los espacios, ya que si no se les tiene en cuenta la comprobaci\u00f3n podr\u00eda fallar:</p> <pre><code>console.log('1 - 5'.match(/\\d-\\d/)) // null\n</code></pre>"},{"location":"bloque_i/tema_7/page-2/#unicode","title":"Unicode","text":"<p>Cada car\u00e1cter en Unicode tiene varias propiedades, es decir, describen a que categor\u00eda pertenece el car\u00e1cter y contienen informaci\u00f3n diversa al respecto. Por ejemplo, si un car\u00e1cter tiene la propiedad <code>Letter</code>, significa que pertenece a una alfabeto de cualquier idioma, o <code>Number</code> que significa que es un d\u00edgito.</p> <p>Se puede buscar caracteres teniendo en cuenta a la propiedad Unicode a la que pertenece, haciendo uso de <code>\\p{...}</code>. Para usar dicha expresi\u00f3n, es necesario usar la flag <code>u</code>. Por ejemplo, <code>p{Letter}</code> representa una letra en cualquier idioma. Tambi\u00e9n se puede usar <code>p{L}</code>:</p> <pre><code>const str = \"A \u10d1 \u3131\"\nconsole.log(str.match(/\\p{L}/gu)) // [A, \u10d1, \u3131]\nconsole.log(str.math(/\\p{L}/g)) // null\n</code></pre> <p>Haciendo uso de <code>\\P{...}</code> estaremos excluyendo los caracteres de la propiedad Unicode indicada. Por ejemplo, con <code>\\P{L}</code>, excluimos todas las letras de cualquier idioma.</p> <p>Las categor\u00edas de letras (<code>Letter</code> o <code>L</code>), son:</p> <ul> <li>lowercase (<code>Ll</code>)</li> <li>modifier (<code>Lm</code>)</li> <li>titlecase (<code>Lt</code>)</li> <li>uppercase (<code>Lu</code>)</li> <li>other (<code>Lo</code>)</li> </ul> <p>Las categor\u00edas de n\u00fameros (<code>Number</code> o <code>N</code>), son:</p> <ul> <li>D\u00edgito decimal <code>Nd</code></li> <li>Letter number <code>Nl</code></li> <li>other <code>No</code></li> </ul> <p>Otras categor\u00edas y subcategor\u00edas importantes:</p> <ul> <li>Punctuation (puntuaci\u00f3n) <code>P</code>:<ul> <li>connector (conector) <code>Pc</code>,</li> <li>dash (gui\u00f3n) <code>Pd</code>,</li> <li>initial quote (comilla inicial) <code>Pi</code>,</li> <li>final quote (comilla final) <code>Pf</code>,</li> <li>open (abre) <code>Ps</code>,</li> <li>close (cierra) <code>Pe</code>,</li> <li>other (otro) <code>Po</code>.</li> </ul> </li> <li>Mark (marca) <code>M</code> (acentos etc):<ul> <li>spacing combining (combinaci\u00f3n de espacios) <code>Mc</code>,</li> <li>enclosing (encerrado) <code>Me</code>,</li> <li>non-spacing (sin espaciado) <code>Mn</code>.</li> </ul> </li> <li>Symbol (s\u00edmbolo) <code>S</code>:<ul> <li>currency (moneda) <code>Sc</code>,</li> <li>modifier (modificador) <code>Sk</code>,</li> <li>math (matem\u00e1tica) <code>Sm</code>,</li> <li>other (otro) <code>So</code>.</li> </ul> </li> <li>Separator (separador) <code>Z</code>:<ul> <li>line (l\u00ednea) <code>Zl</code>,</li> <li>paragraph (p\u00e1rrafo) <code>Zp</code>,</li> <li>space (espacio) <code>Zs</code>.</li> </ul> </li> <li>Other (otros) <code>C</code>:<ul> <li>control <code>Cc</code>,</li> <li>format (formato) <code>Cf</code>,</li> <li>not assigned (sin asignaci\u00f3n) <code>Cn</code>,</li> <li>private use (uso privado) <code>Co</code>,</li> <li>surrogate (sustituto) <code>Cs</code>.</li> </ul> </li> </ul> <p>Tambi\u00e9n existen categor\u00edas derivadas, como <code>Alphabetic</code> o <code>Hex_digit</code>. Veamos un ejemplo, donde busquemos n\u00fameros escritos en Hexadecimal:</p> <pre><code>const regEx = /x\\p{Hex_Digit}/u\nconsole.log('N\u00famero: xAF'.match(regEx)) // xAF\n</code></pre> <p>Existe una propiedad Unicode llamada <code>Script</code>, que permite buscar caracteres de un sistema de escritura dado. Para ello, debemos usar <code>Script=&lt;value&gt;</code> siendo value el valor del sistema de escritura:</p> <pre><code>const regexp = /\\p{sc=Han}/gu // devuelve sinogramas chinos\nconst str = `Hello \u041f\u0440\u0438\u0432\u0435\u0442 \u4f60\u597d 123_456`\nconsole.log(str.match(regexp)) // \u4f60,\u597d\n</code></pre>"},{"location":"bloque_i/tema_7/page-2/#anclas","title":"Anclas","text":"<p>Los caracteres caret <code>^</code> y d\u00f3lar <code>$</code> tienen un significado especial en una expresi\u00f3n regular, tienen una funci\u00f3n de anclas.</p> <p>El car\u00e1cter <code>^</code> representa el principio de una cadena, mientras que <code>$</code> representa el final:</p> <pre><code>const str = 'Javascript is a programming language'\nconsole.log(/^Javascript/.test(str)) // true\n</code></pre> <p>La expresi\u00f3n <code>^Javascript</code> indica que la cadena comienza con la palabra Javascript. De igual manera, funciona el car\u00e1cter <code>$</code>:</p> <pre><code>const str = 'Javascript is a programming language'\nconsole.log(/programming$/.test(str)) // true\n</code></pre> <p>Al usar ambos anclajes a la vez, nos permite probar si una cadena coincide al completo con el patr\u00f3n deseado. Por ejemplo, para comprobar si la entrada de un usuario es correcta, o si la contrase\u00f1a indicada por el usuario cumple los requisitos:</p> <pre><code>const good = '12:34'\nconst bad = '12:234'\nconst regEx = /^\\d\\d:\\d\\d$/\nconsole.log(regEx.test(good)) // true\nconsole.log(regEx.test(bad)) // false\n</code></pre> <p>Cuando el modo multilinea est\u00e1 activado (<code>m</code>) el comportamiento de las anclas se ve afectado. De esta forma, no solo ha de coincidir el principio y el final de la cadena con el patr\u00f3n, sino que cada una de las l\u00edneas de la cadena:</p> <pre><code>const str = `1er lugar: Winnie\n2do lugar: Piglet\n3er lugar: Eeyore`\nconsole.log(str.match(/^\\d/gm)) // [1, 2, 3]\n</code></pre> <p>En el ejemplo anterior, vemos como la cadena debe empezar por un d\u00edgito, y el resultado devuelve un array con los 3 valores, uno por cada l\u00ednea. Sin hacer uso de la flag <code>m</code>, solo devolver\u00eda <code>1</code>, que es el inicio de la cadena. De la misma forma funciona el <code>$</code>.</p>"},{"location":"bloque_i/tema_7/page-2/#limite-de-palabra","title":"L\u00edmite de palabra","text":"<p>Como hemos visto antes, existen dos anclas para indicar el comienzo y el final de una cadena. Pero, en ocasiones, nos interesa limitar una palabra dentro del patr\u00f3n. Para ello, se usa el car\u00e1cter <code>\\b</code>. Cuando el motor regex se encuentra con dicho car\u00e1cter, comprueba que la posici\u00f3n en la cadena es un l\u00edmite de palabra. Existen tres posiciones que se califican como limites de palabra:</p> <ul> <li>Al comienzo de la cadena, si el primer car\u00e1cter de la cadena es una car\u00e1cter de palabra (<code>\\w</code>).</li> <li>Entro dos caracteres de la cadena.</li> <li>Al final de la cadena, si el \u00faltimo car\u00e1cter es un car\u00e1cter de palabra.</li> </ul> <pre><code>console.log(\"Hello, Java!\".match(/\\bJava\\b/)) // Java\nconsole.log(\"Hello, JavaScript!\".match(/\\bJava\\b/)) // null\n</code></pre> <p>Tambi\u00e9n se puede usar el l\u00edmite de palabra con d\u00edgitos.</p>"},{"location":"bloque_i/tema_7/page-3/","title":"3 Conjuntos","text":""},{"location":"bloque_i/tema_7/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>En ciertas ocasiones, es necesario hacer uso de los caracteres especiales en el conjunto de la expresi\u00f3n regular, como por ejemplo la barra invertida <code>\\</code> o el punto <code>.</code>.</p> <p>Si se desea comprobar si la cadena tiene un punto, no podemos usar la expresi\u00f3n <code>.</code> ya que representa cualquier car\u00e1cter. Para anular cualquier car\u00e1cter especial, podemos usar el car\u00e1cter de la barra invertida <code>\\</code>:</p> <pre><code>console.log(5.1.match(/\\d\\.\\d/)) // [5.1]\n</code></pre> <p>Se puede hacer incluso con la misma barra:</p> <pre><code>console.log('1\\\\2'.match(/\\\\/)) // [\\]\n</code></pre> <p>Las barras normales <code>/</code> no son consideradas como car\u00e1cter especial en Javascript. Sin embargo, se pueden usar para delimitar una expresi\u00f3n regular, por lo que si en ella se quiere usar, tambi\u00e9n se deber\u00eda preceder el car\u00e1cter <code>\\</code>:</p> <pre><code>console.log(\"/\".match(/\\//)) // [/]\n</code></pre> <p>Otra forma de poder buscar una barra en una cadena, es haciendo uso del constructor de la clase <code>RegEx</code>:</p> <pre><code>console.log('/'.match(new RegEx('/')))\n</code></pre> <p>\u00a1Importante!</p> <p>Al usar el constructor <code>new RegEx</code> hay que tener en cuenta que las barras invertidas son consumidas como cadena, por lo que expresiones como <code>\\d</code> o <code>\\.</code> no tendr\u00edan funcionamiento:</p> <pre><code>console.log('Capitulo 5.1'.match(new RegEx(\"\\d\\.\\d\"))) //null\n</code></pre> <p>Para evitar dicho error, habr\u00eda que duplicar la cadena invertida para que obtenga <code>\\d</code> en lugar de <code>d</code>.</p> <pre><code>console.log('Capitulo 5.1'.match(new RegEx(\"\\\\d\\\\.\\\\d\"))) //[5.1]\n</code></pre>"},{"location":"bloque_i/tema_7/page-3/#conjunto-y-rangos","title":"Conjunto y rangos","text":"<p>En ciertas ocasiones, queremos buscar o reemplazar un conjunto espec\u00edfico que no es contemplado por lo que hemos visto anteriormente. Para ello, podemos especificar un conjunto espec\u00edfico haciendo uso de los corchetes <code>[...]</code>. De esta manera, denotamos que la cadena cumpla con cualquier car\u00e1cter dentro de los corchetes. Veamos un ejemplo:</p> <pre><code>const course = \"1\u00ba ESO A\"\nconsole.log(course.match(/[ABC]$/)) // [A]\n</code></pre> <p>En el ejemplo anterior, comprobamos si el curso termina en una de las letras posibles. Dado que hay tres cursos (A, B, C), para que sea un curso v\u00e1lido, debe terminar en A, B o en C. Veamos otro ejemplo:</p> <pre><code>console.log('2x-3'.match(/2[abcdefghijklmnopqrstuvwxyz]-3/)) // [x]\n</code></pre> <p>En este ejemplo, se ha intentado comprobar si la expresi\u00f3n es una ecuaci\u00f3n matem\u00e1tica. Para ello, el car\u00e1cter que va despu\u00e9s de 2 debe ser una letra.</p> <p>En ciertas ocasiones, escribir todo un conjunto contin\u00fao se puede hacer un poco pesado. Para ello, podemos hacer uso de los rangos <code>[...-...]</code>, que son un tipo de conjunto donde se indica el comienzo del rango y el final del mismo, y abarca todas las posibilidades entre ambos. Veamos el ejemplo anterior, haciendo uso de rangos:</p> <pre><code>console.log('2x-3'.match(/2[a-z]-3/)) // [x]\n</code></pre> <p>Dentro de los conjuntos, tambi\u00e9n se pueden usar clases de caracteres. En el siguiente ejemplo, vamos a comprobar si la cadena empieza con un car\u00e1cter de palabra o con un espacio.</p> <pre><code>console.log('Prueba'.match(/[\\w\\s]/))\n</code></pre> <p>Si por el contario, se desea excluir los caracteres dentro del conjunto, se debe usar el car\u00e1cter caret dentro de los corchetes que indican el conjunto <code>[^...]</code>. Veamos un ejemplo, donde queremos obtener los caracteres especiales de una cadena:</p> <pre><code>console.log('minuevoemail12@gmail.com'.match(/[^\\d\\sA-Z]/gi)) // [@, .]\n</code></pre> <p>Tal y como hemos visto en el punto anterior, al usar en una expresi\u00f3n la b\u00fasqueda de caracteres especiales (como el punto), es necesario hacer uso de la barra invertida <code>\\</code>. Dentro de los conjuntos no es necesario escapar dichos caracteres en las siguientes ocasiones:</p> <ul> <li>El punto <code>.</code>, el operador m\u00e1s <code>+</code> y los par\u00e9ntesis <code>()</code> nunca necesitan escape dentro de un conjunto.</li> <li>El gui\u00f3n <code>-</code> no es necesario realizar escape, ni al principio ni al final de la expresi\u00f3n. Es necesario realizar escape, cuando va entre dos caracteres y no indica un rango. Por ejemplo: <code>[a\\-z]</code>, en este caso queremos comprobar si hay coincidencia de la letra a o z, o un gui\u00f3n. Si el gui\u00f3n no se escapa, buscar\u00eda las coincidencias entre las letras a y z.</li> <li>El car\u00e1cter caret <code>^</code> no es necesario realizar escape en ninguna posici\u00f3n, solamente al principio de la expresi\u00f3n, que puede significar exclusi\u00f3n.</li> <li>El corchete de apertura <code>[</code> nunca se escapa, pero el corchete de cierre <code>]</code> siempre es necesario realizarle el escape.</li> </ul>"},{"location":"bloque_i/tema_7/page-4/","title":"4 Cuantificadores","text":""},{"location":"bloque_i/tema_7/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Supongamos que deseamos localizar un mismo conjunto, o una misma clase de caracteres que se repite cierta ocasi\u00f3n, o por el contrario puede o no aparecer. Para ello, podemos hacer uso de los cuantificadores para indicar el n\u00famero de veces que debe aparecer un conjunto o una clase de caracteres dentro de una cadena.</p>"},{"location":"bloque_i/tema_7/page-4/#numero-de-veces","title":"N\u00famero de veces","text":"<p>Para indicar que una expresi\u00f3n se repite n-veces, es necesario indicarlo entre corchetes <code>{n}</code>. Por ejemplo:</p> <pre><code>console.log('I am 12453 months'.match(/\\d{5}/)) // [12345]\n</code></pre> <p>En el ejemplo anterior, se realiza una b\u00fasqueda de un d\u00edgito que aparezca 5 veces.</p> <p>Cuando usamos la expresi\u00f3n <code>{n}</code>, hacemos referencia al n\u00famero exacto de veces que debe aparecer el conjunto o clase de caracteres en la cadena a evaluar. Sin embargo, en ciertas ocasiones nos interesa que el n\u00famero de veces que aparece sea comprendido entre un rango, por ejemplo entre 3 y 5 veces, para ello usamos la expresi\u00f3n <code>{n,m}</code>, siendo n el l\u00edmite inferior y m el l\u00edmite superior. Veamos un ejemplo, donde se busque la coincidencia entre 3 y 5 veces:</p> <pre><code>console.log('I am not 12 years old, I am 3456 months'.match(/\\d{3,5}/)) // [3456]\n</code></pre> <p>Incluso, a veces, solo queremos indicar el n\u00famero m\u00ednimo de veces que debe aparecer. Para ello, usamos <code>{n,}</code>, siendo n el n\u00famero m\u00ednimo de veces que debe aparecer un conjunto o clase de caracteres:</p> <pre><code>console.log('I am not 12 years old, I am 3456 months'.match(/\\d{3,}/)) // [3456]\n</code></pre>"},{"location":"bloque_i/tema_7/page-4/#abreviaciones","title":"Abreviaciones","text":"<p>Para ciertos rangos de apariciones de conjunto o clases de caracteres, se dispone de algunos caracteres especiales que abrevian a dichos rangos:</p> <ul> <li> <p><code>+</code>: indica que un conjunto o clase de caracteres debe aparecer uno o m\u00e1s veces. Es equivalente a <code>{1,}</code>. Veamos un ejemplo:</p> <p>```javascript console.log('+7(903)-123-45-67'.match(/\\d+/g)) // [7, 903, 123, 45, 67] ````</p> </li> <li> <p><code>?</code>: indica que un conjunto o clase de caracteres debe aparecer cero o una vez. Es equivalente a <code>{0,1}</code>. Veamos un ejemplo:</p> <pre><code>console.log('AA-12345-B'.match(/[A-Z]?/)) // [A, A, B]\n</code></pre> </li> <li> <p><code>*</code>: indica que un conjunto o clase de caracteres debe aparecer todas las veces posibles, incluso no aparecer. Es equivalente a <code>{0,}</code>:</p> <p>```javascript console.log('100 10 1'.match(/\\d0*/g)) // [100, 10, 1]</p> </li> </ul> <p>Veamos varios ejemplos:</p> <ul> <li> <p>Obtener n\u00fameros decimales de una cadena:</p> <pre><code>console.log(\"0 1 12.345 7890\".match(/\\d+\\.\\d+/g)) // [12.245]\n</code></pre> <p>En este ejemplo se busca una cadena que aparezca un n\u00famero al menos una vez (<code>\\d</code>) seguido de un punto seguido de otro n\u00famero (<code>\\.</code>) que aparezca tambi\u00e9n al menos una vez (<code>\\d</code>)</p> </li> <li> <p>Obtener etiquetas HTML sin atributos:</p> <pre><code>const regEx = /&lt;\\/?[a-z][a-z\\d]*&gt;/gi\nconsole.log('&lt;body&gt;This is a body&lt;/body&gt;'.match(regEx)) // [&lt;body&gt;, &lt;/body&gt;]\nconsole.log('&lt;h1&gt;This is a title&lt;/h1&gt;'.match(regEx)) // [&lt;h1&gt;, &lt;/h1&gt;]\n</code></pre> <p>En este ejemplo se busca una cadena que empiece por el signo menor <code>&lt;</code> seguido por un barra que puede aparecer entre 0 o 1 vez <code>\\/?</code> (en caso de que sea etiqueta de cierre aparecer\u00e1 una vez, y en caso de que sea etiqueta de apertura no aparecer\u00e1) una letra comprendida entre la a y la z <code>[a-z]</code>, seguido de un letra o un n\u00famero que se puede repetir varias veces, o simplemente no puede aparecer <code>[a-z\\d]*</code>, terminando por un car\u00e1cter de mayor <code>&gt;</code>.</p> </li> </ul>"},{"location":"bloque_i/tema_7/page-4/#greedy-matching","title":"Greedy matching","text":"<p>La greedy matching* (b\u00fasqueda codiciosa) se refiere a la forma en la que realiza la b\u00fasqueda de la expresi\u00f3n en la expresi\u00f3n regular a trav\u00e9s de sus cuantificadores. Se pueden realizar de dos formas: codiciosa (*greedy) o reticente (reluctant).</p> <p>La b\u00fasqueda codiciosa tiene como objetivo encontrar el mayor n\u00famero de coincidencias posibles. Adem\u00e1s, es la forma por defecto que se utiliza a la hora de utilizar los cuantificadores.</p> <pre><code>const regex = /a.*/\nconst texto = \"abc aaaa aaaa\"\nconst resultado = texto.match(regex)\nconsole.log(resultado[0]) // \"abc aaaa aaaa\"\n</code></pre>"},{"location":"bloque_i/tema_7/page-4/#reluctant-matching","title":"Reluctant matching","text":"<p>La reluctant matching (b\u00fasqueda reticente) intenta realizar la b\u00fasqueda comprobando en el n\u00famero menor de caracteres posibles, pero siempre cumpliendo el patr\u00f3n. Para indicar que los cuantificadores se usan de este modo se debe a\u00f1adir una interrogaci\u00f3n <code>?</code>:</p> <pre><code>const regex = /a.+?a/;\nconst texto = \"abc aaaa aaaa\";\nconst resultado = texto.match(regex);\nconsole.log(resultado[0]); // \"abc a\"\n</code></pre> <p>Incluso, cuando se desea buscar una o ninguna vez:</p> <pre><code>const regex /a??bc/\nconsole.log(\"abc aaaa aaaa\".match(regex)) // [abc]\n</code></pre> <p>Iteremos con el ejemplo, supongamos que tenemos una cadena <code>Hola soy Marta, pero no soy ninguna \"bruja\" como me llaman por ah\u00ed, yo me considero \"cient\u00edfica\"</code>, y se desea obtener las palabras que van entre comillas, en el caso greedy, empieza a iterar desde el primer car\u00e1cter y va avanzando hasta comprobar que el patr\u00f3n se cumpla en alguno de ellos o se termine la cadena.</p> <pre><code>const str = `Hola soy Marta, pero no soy ninguna \"bruja\" como me llaman por ah\u00ed, yo me considero \"cient\u00edfica\"`\nconst regex = /\".+\"/g\nconst result = str.match(regex)\nconsole.log(result) // [\"bruja\", \"cient\u00edfica\"]\n</code></pre> <p>En el caso reticente (reluctant) se abarcar\u00e1 la b\u00fasqueda desde la primera coincidencia con el patr\u00f3n, obviando el resto de caracteres. Una vez coincidido el patr\u00f3n, no busca en los siguientes caracteres, si no que comprueba la siguiente coincidencia.</p> <pre><code>const str = `Hola soy Marta, pero no soy ninguna \"bruja\" como me llaman por ah\u00ed, yo me considero \"cient\u00edfica\"`\nconst regex = /\".+?\"/g\nconst result = str.match(regex)\nconsole.log(result) // [\"bruja\", \"cient\u00edfica\"]\n</code></pre>"},{"location":"bloque_i/tema_7/page-5/","title":"5 Grupos","text":""},{"location":"bloque_i/tema_7/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Un grupo de captura es una parte de una expresi\u00f3n regular que se desea obtener. Para indicar dentro de un expresi\u00f3n que un parte pertenece a un grupo de captura, se envuelve entre par\u00e9ntesis <code>(...)</code></p> <p>Podemos usar, despu\u00e9s del par\u00e9ntesis de captura, un cuantificador para cuantificar el n\u00famero de veces que debe aparecer el grupo:</p> <pre><code>console.log('Gogogo now!'.match(/(go)+/ig)) //[go, go go]\n</code></pre> <p>En cambio, si se usa como grupo de captura podemos obtener una matriz independiente con los valores capturados. Supongamos que tenemos una cadena y queremos comprobar si es o no un email, y en caso de serlo obtener el nombre de dominio. Un email se compone de un nombre y un dominio unido por el car\u00e1cter <code>@</code> teniendo una estructura as\u00ed <code>name@domain</code>. Como se desea obtener el dominio, esa parte de la expresi\u00f3n regular debe de estar envuelta entre par\u00e9ntesis.</p>"},{"location":"bloque_i/tema_7/page-5/#grupos-con-match","title":"Grupos con match","text":"<p>Para obtener los grupos de las coincidencias encontradas haciendo uso de la funci\u00f3n <code>match(regex)</code> de las cadenas, si no tiene el indicador <code>g</code>, se acceder\u00e1 a la posici\u00f3n del grupo, que est\u00e1n enumeradas de izquierda a derecha. De esta manera, para el primer grupo se acceder\u00e1 al \u00edndice 1, al grupo 2 el \u00edndice 2, etc. Al acceder al \u00edndice 0, se obtiene la coincidencia completa.</p> <p>Veamos un ejemplo, donde se obtiene la primera coincidencia de las etiquetas HTML:</p> <pre><code>const str = \"&lt;h1&gt;Hello world!&lt;/h1&gt;\"\nconst tags = str.match(/&lt;(.*?)&gt;)\nconsole.log(tags[0]) // &lt;h1&gt;\nconsole.log(tags[1]) // h1\n</code></pre> <p>Tambi\u00e9n existe la posibilidad de anidar grupos. De esta manera, el acceso var\u00eda un poco, siguiendo la numeraci\u00f3n de izquierda a derecha, pero si alguno tiene alg\u00fan subgrupo se cuenta primero los de adentro.</p> <p>Supongamos, ahora, que queremos obtener la etiqueta, el atributo con su valor. Para ello, usamos la siguiente expresi\u00f3n <code>&lt;(([a-z][a-z\\d]*)\\s*(([a-z]*)=\\s*(\"[\\w\\s]*\")))&gt;</code>. Al aplic\u00e1rselo a la etiqueta <code>&lt;span class=\"my\"&gt;</code>:</p> <ul> <li>el primer grupo corresponde a la etiqueta completa: <code>span class=\"my\"</code></li> <li>el segundo grupo corresponde al nombre de la etiqueta: <code>span</code></li> <li>el tercer grupo corresponde al atributo y su valor: <code>class=\"my\"</code></li> <li>el cuarto grupo corresponde al nombre del atributo: <code>class</code></li> <li>el quinto grupo corresponde al valor del atributo: <code>\"my\"</code></li> </ul> <pre><code>const regex = /&lt;(([a-z][a-z\\d]*)\\s*(([a-z]*)=\\s*(\"[\\w\\s]*\")))&gt;/\nconst str = `&lt;span class=\"my\"&gt;This is a span&lt;/span&gt;`\nconst result = str.match(regex)\nconsole.log(result[0]) //&lt;span class=\"my\"&gt;\nconsole.log(result[1]) // span class=\"my\"\nconsole.log(result[2]) // span\nconsole.log(result[3]) // class=\"my\"\nconsole.log(result[4]) // class\nconsole.log(result[5]) // \"my\"\n</code></pre>"},{"location":"bloque_i/tema_7/page-5/#grupos-opcionales","title":"Grupos opcionales","text":"<p>A veces, usamos un grupo que puede aparecer una vez o ninguna, en ese caso, estamos tratando con un grupo opcional. Si el grupo no se encuentra, pero se ha encontrado coincidencia, el array contendr\u00e1 en la posici\u00f3n del grupo espec\u00edfico un valor <code>undefined</code>:</p> <pre><code>let match = 'a'.match(/a(z)?(c)?/);\nconsole.log(match.length) // 3\nconsole.log(match[0]) // a (coincidencia completa)\nconsole.log(match[1]) // undefined\nconsole.log(match[2]) // undefined\n</code></pre> <p>La longitud sigue siendo tres, pero el array se compone de dos posiciones con valor <code>undefined</code>.</p>"},{"location":"bloque_i/tema_7/page-5/#grupos-en-todas-las-coincidencias","title":"Grupos en todas las coincidencias","text":"<p>Al usar el indicador <code>g</code> el array devuelto, no nos devuelve los valores de los grupos que se desea obtener.</p> <pre><code>const str = `&lt;h1&gt;Title&lt;/h1&gt; &lt;h2&gt;Subtitle&lt;/h2&gt;`\nconst tags = str.match(/&lt;(.*?)&gt;/g)\nconsole.log(tags) // [&lt;h1&gt;, &lt;h2&gt;]\n</code></pre> <p>Para poder obtener el valor de los grupos, se puede hacer uso del m\u00e9todo <code>matchAll(regex)</code>. Al igual que <code>match(regex)</code> busca coincidencias pero tiene algunas diferencias:</p> <ul> <li>No devuelve un array, si no un objeto iterable</li> <li>Cuando est\u00e1 presente el indicador <code>g</code>, devuelve todas coincidencias como un array de grupos.</li> <li>Si no hay coincidencias, NO devuelve <code>null</code>, sino un objecto iterable vac\u00edo.</li> </ul> <pre><code>const results = '&lt;h1&gt; &lt;h2&gt;'.matchAll(/&lt;(.*?)&gt;/gi)\n// results - no es un array, sino un objeto iterable\nconsole.log(results) // [object RegExp String Iterator]\nresults = Array.from(results) // lo convirtamos en array\nconsole.log(results[0]) // &lt;h1&gt;,h1 (1er etiqueta)\nconsole.log(results[1]) // &lt;h2&gt;,h2 (2da etiqueta)\n</code></pre> <p>Cada coincidencia del <code>matchAll(regex)</code> tiene la misma estructura devuelta por un <code>match(regex)</code> sin el flag <code>g</code>:</p> <pre><code>const results = '&lt;h1&gt; &lt;h2&gt;'.matchAll(/&lt;(.*?)&gt;/gi)\nconst [tag1, tag2] = results\nconsole.log(tag1[0]) // &lt;h1&gt;\nconsole.log(tag1[1]) // h1\nconsole.log(tag1.index) // 0\nconsole.log(tag1.input) // &lt;h1&gt; &lt;h2&gt;\n</code></pre>"},{"location":"bloque_i/tema_7/page-5/#grupos-con-nombre","title":"Grupos con nombre","text":"<p>Cuando un patr\u00f3n es simple, es factible enumerar los grupos. Sin embargo, cuando tenemos una expresi\u00f3n compleja y se desea recordar el n\u00famero del grupo al que acceder, es dif\u00edcil de recordar. Para ello, podemos nombrar a los grupos y acceder a ellos con mayor facilidad.</p> <p>Para nombrar un grupo, se debe indicar <code>?&lt;name&gt;</code> despu\u00e9s del par\u00e9ntesis de apertura. Para acceder a un grupo por su nombre, debemos acceder al objeto <code>groups</code> del resultado:</p> <pre><code>const dateRegexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/\nconst str = \"2019-04-30\"\nconst groups = str.match(dateRegexp).groups\nconsole.log(groups.year) // 2019\nconsole.log(groups.month) // 04\nconsole.log(groups.day) // 30\n</code></pre> <p>Tambi\u00e9n, se pueden usar en <code>matchAll(regex)</code>:</p> <pre><code>const dateRegexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/g\nconst str = \"2019-10-30 2020-01-01\"\nconst results = str.matchAll(dateRegexp)\nfor(let result of results) {\nlet {year, month, day} = result.groups\nconsole.log(`${day}.${month}.${year}`)\n}\n</code></pre>"},{"location":"bloque_i/tema_7/page-5/#grupos-en-reemplazo","title":"Grupos en reemplazo","text":"<p>Como hemos visto anteriormente, el m\u00e9todo <code>replace(regex, replacement)</code> reemplaza todas las coincidencias por el valor indicado. Pero, supongamos que tenemos una cadena y lo que deseamos es cambiar el orden, gracias a <code>$n</code> podemos acceder al n\u00famero de grupo y reescribir la cadena en otro orden:</p> <pre><code>const str = \"John Bull\";\nconst regexp = /(\\w+) (\\w+)/;\nconsole.log(str.replace(regexp, '$2, $1')) // Bull, John\n</code></pre> <p>Tambi\u00e9n se puede hacer con par\u00e1metros nombrados, haciendo uso de <code>$&lt;name&gt;</code>:</p> <pre><code>const regexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/g;\nconst str = \"2019-10-30, 2020-01-01\";\nconsole.log(str.replace(regexp, '$&lt;day&gt;.$&lt;month&gt;.$&lt;year&gt;'));\n// 30.10.2019, 01.01.2020\n</code></pre>"},{"location":"bloque_i/tema_7/page-5/#grupos-no-capturados","title":"Grupos no capturados","text":"<p>Podemos no capturar un grupo, cuando queremos cuantificar un grupo pero no queremos obtener un resultado. Para excluir un grupo, se debe usar <code>?:</code> despu\u00e9s del par\u00e9ntesis de apertura:</p> <pre><code>const str = \"Gogogo John!\"\n// ?: excluye 'go' de la captura\nconst regexp = /(?:go)+ (\\w+)/i\nconst result = str.match(regexp)\nconsole.log(result[0]) // Gogogo John (coincidencia completa)\nconsole.log(result[1]) // John\nconsole.log(result.length) // 2 (no hay m\u00e1s \u00edtems en el array)\n</code></pre>"},{"location":"bloque_i/tema_7/page-5/#referencias-inversas","title":"Referencias inversas","text":"<p>Supongamos que se desea encontrar una cadena que est\u00e9 envuelta entre comillas, ya sea simple o doble, con la \u00fanica condici\u00f3n de que la de comienzo y la de final deben ser la misma. El patr\u00f3n ser\u00eda algo tal que as\u00ed <code>['\"](.*?)['\"]</code>. Sin embargo, si tenemos usamos un tipo de comillas dentro de otras, esto puede dar coincidencias incorrectas:</p> <pre><code>const str = `He said: \"She's the one!\".`\nconst regex = /['\"](.*?)['\"]/g\nconsole.log(str.match(regex)) // \"She'\n</code></pre> <p>Como se puede observar, devuelve <code>\"She'</code>, que para nada es lo que deseamos, ya que no se cumple la condici\u00f3n de que la cadena obtenida debe comenzar con el mismo tipo de comillas.</p> <p>Para solucionar dicho problema, debemos agrupar <code>['\"]</code> y hacer referencia a \u00e9l al final de la expresi\u00f3n. De esta forma, se entender\u00e1 la referencia como el mismo valor obtenido en el grupo referenciado. Para referenciar un grupo usamos la barra invertida seguida del n\u00famero de grupo a referenciar.</p> <pre><code>const str = `He said: \"She's the one!\".`\nconst regex = /(['\"])(.*?)\\1/g\nconsole.log(str.match(regex)) // \"She's the one\"\n</code></pre> <p>Ahora, el problema esta resuelto y obtenemos el valor que realmente deseamos. Tambi\u00e9n se puede hacer referencia a los grupos nombrados, <code>\\k&lt;name&gt;</code>.</p> <pre><code>const str = `He said: \"She's the one!\".`\nconst regexp = /(?&lt;quote&gt;['\"])(.*?)\\k&lt;quote&gt;/g\nconsole.log(str.match(regexp)) // \"She's the one!\"\n</code></pre> <p>Warning</p> <p>Si usamos un grupo opcional (<code>?:</code>) no podemos hacer referencia a \u00e9l dentro de una expresi\u00f3n regular, ya que no son memorizados por el motor.</p>"},{"location":"bloque_i/tema_7/page-6/","title":"6 Comprobaciones","text":""},{"location":"bloque_i/tema_7/page-6/#alternancia","title":"Alternancia","text":"<p>La alternancia es un t\u00e9rmino en un expresi\u00f3n regular que permite obtener una coincidencia entre dos valores. Para usar la alternancia se utiliza la barra vertical <code>|</code>. Por ejemplo, si queremos encontrar coincidencia de unos valores ser\u00eda: <code>html|css|javascript</code></p> <pre><code>const regexp = /html|php|css|java(script)?/gi;\nconst str = \"Primera aparici\u00f3n de HTML, luego CSS, luego JavaScript\";\nconsole.log(str.match(regexp)) // 'HTML', 'CSS', 'JavaScript'\n</code></pre> <p>Es bastante similar a los corchetes <code>[]</code>, pero con la diferencia de que los corchetes solo permite alternar caracteres, es decir, para <code>[html]</code> busca coincidencias con cada una de las letras de html y no con la palabra completa en s\u00ed.</p> <p>Para alternar una parte de la expresi\u00f3n, se puede hacer uso de los par\u00e9ntesis: <code>I love (HTML|Javascript)</code>.</p>"},{"location":"bloque_i/tema_7/page-6/#look-around","title":"Look around","text":"<p>En ciertas ocasiones, es necesario buscar \u00fanicamente las coincidencias donde un patr\u00f3n es precedido o seguido por otro patr\u00f3n. Para ello, existe una sintaxis conocidas como look around, que se puede dividir en otras dos: look ahead y look behind que realizan una b\u00fasqueda posterior y previa, respectivamente.</p> <p>Por ejemplo, supongamos que tenemos la cadena <code>1 pavo cuesta 30\u20ac</code> y deseamos obtener el precio. Para ello, necesitamos localizar el n\u00famero que sigue a una moneda.</p>"},{"location":"bloque_i/tema_7/page-6/#look-ahead","title":"Look ahead","text":"<p>Su sintaxis es <code>X(?=Y)</code>, es decir, buscar el valor de X, si y solo si es seguido por <code>Y</code>. En el ejemplo del precio anterior, la expresi\u00f3n regular ser\u00eda algo tal que as\u00ed <code>\\d+(?=\u20ac)</code>. De esta manera, devolver\u00e1 el valor de X (el precio) pero no el de Y (la moneda). El funcionamiento es el siguiente:</p> <ul> <li>Primero, localiza la parte de la cadena que coincida con el valor X.</li> <li>Posteriormente, comprueba si va precedido del valor Y y devuelve. Por el contrario, omite su valor, y pasa a buscar el siguiente.</li> </ul> <pre><code>const str = '1 pavo cuesta 30\u20ac'\nconsole.log(str.match(/\\d+(?=\u20ac)/)) // 30\n</code></pre> <p>Tambi\u00e9n posible realizar comprobaciones m\u00e1s complejas como <code>X(?=Y)(?=Z)</code>. En este caso, el funcionamiento es:</p> <ol> <li>Localiza la parte de la cadena que coincida con el valor de X.</li> <li>Verifica si va seguido de Y, sino omite su valor.</li> <li>Verifica si va seguido de Z, sino omite su valor.</li> <li>Si ambas verificaciones se cumplen, devuelve el valor de X, sino sigue realizando la b\u00fasqueda.</li> </ol> <pre><code>const str = '1 pavo cuesta 30\u20ac'\nconsole.log(str.match(/\\d+(?=\\s)(?=.*30)/) // 1\n</code></pre> <p>En el ejemplo anterior se realiza la b\u00fasqueda de un d\u00edgito (repetido uno o m\u00e1s veces), seguido de un espacio, y en alg\u00fan momento del n\u00famero 30.</p> <p>A veces, queremos realizar una b\u00fasqueda haciendo uso de la sintaxis look head pero en negativo, es decir, que no vaya seguido un patr\u00f3n espec\u00edfico. Para ello, tenemos la sintaxis <code>X(?!Y)</code>, que significa buscar el valor de X, si y solo si no va seguido de Y.</p> <pre><code>const str = '2 pavos cuesta 60\u20ac'\nconsole.log(str.match(/\\d+(?!\u20ac)/)) // 2\n</code></pre>"},{"location":"bloque_i/tema_7/page-6/#look-behind","title":"Look behind","text":"<p>Look behind usa una l\u00f3gica similar a la sintaxis de look ahead, pero en lugar de comprobar lo que le procede, comprueba lo que le precede. Su sintaxis ser\u00eda: <code>(?&lt;=Y)X</code> que significa buscar el valor de X, si y solo si va precedido del valor Y.</p> <pre><code>const str = '1 pavo cuesta $30'\nconsole.log(str.match(/(?&lt;=\u20ac)\\d+/)) // 30\n</code></pre> <p>Tambi\u00e9n existe una sintaxis negativa: <code>(?&lt;!Y)X</code> que significa buscar el valor de X, si y solo si no va precedido del valor Y.</p> <pre><code>const str = '2 pavos cuesta $60'\nconsole.log(str.match(/(?&lt;!$)\\d+/)) // 2\n</code></pre>"},{"location":"bloque_i/tema_7/page-6/#capturar-valor-de-look-around","title":"Capturar valor de look around","text":"<p>Como hemos visto anteriormente, el valor de Y de un look around no es devuelto, ni siquiera es capturado. Sin embargo, existen los escenarios donde se desea obtener el valor de X, tanto como el valor de Y. Para ello, ser\u00eda necesario envolver el valor de Y en un par\u00e9ntesis:</p> <pre><code>const str = '1 pavo cuesta 30\u20ac'\nconst regex = /\\d+(?=(\u20ac))/\nconsole.log(str.match(regex)) // [30, \u20ac]\n</code></pre> <p>Como puede ver, te devuelve un array, cuyo valor del grupo 0 (la coincidencia encontrada) es <code>30</code>, y no <code>30\u20ac</code>. Sin embargo, existe un \u00edndice 1, con el valor del grupo 1, en este caso <code>\u20ac</code></p>"},{"location":"bloque_i/tema_7/page-7/","title":"7 M\u00e1s m\u00e9todos RegEx","text":""},{"location":"bloque_i/tema_7/page-7/#metodo-exec","title":"M\u00e9todo exec","text":"<p>El indicar <code>y</code> permite realizar la b\u00fasqueda en una posici\u00f3n dada en la cadena de origen. Supongamos que tenemos la cadena <code>const varName = \"value\"</code>, y necesitamos obtener el nombre de la variable que comienza en la posici\u00f3n 4. Al usar la expresi\u00f3n <code>/\\w+/</code> solo encontrar\u00e1 la primera palabra de la cadena (<code>let</code>), que no es el valor del cual disponemos. Lo l\u00f3gico ser\u00eda empezar a buscar desde la posici\u00f3n 4, que es donde sabemos que comienza el nombre de la variable.</p> <p>Existe un m\u00e9todo de la clase <code>RegEx</code> denominado <code>exec(string)</code>, que sin los flags <code>g</code> e <code>y</code> funciona exactamente igual que <code>match(regex)</code>. Sin embargo, al usar dicho m\u00e9todo con la flag <code>g</code>, realiza la b\u00fasqueda desde la posici\u00f3n almacenada en su propiedad <code>lastIndex</code>. Al encontrar coincidencia, el valor de dicha propiedad ser\u00e1 cambiado por la posici\u00f3n anterior a la coincidencia.</p> <p>Se pueden realizar llamadas sucesivas, para ir obtener coincidencias una detr\u00e1s de otras:</p> <pre><code>const str = `let varName`\nconst regex = /\\w+/g\nconsole.log(regex.lastIndexOf) // (1)!\nconst word1 = regex.exec(str)\nconsole.log(word1[0]) // let \nconsole.log(regexp.lastIndex) // (2)!\nconst word2 = regexp.exec(str)\nconsole.log(word2[0]) // varName\nconsole.log(regexp.lastIndex) // (3)!\nconst word3 = regexp.exec(str)\nconsole.log(word3) // null\nconsole.log(regexp.lastIndex) // (4)!\n</code></pre> <ol> <li>El valor inicial es 0.</li> <li>El valor es 3, posici\u00f3n posterior a la coincidencia.</li> <li>El valor es 11, posici\u00f3n posterior a la coincidencia.</li> <li>El valor es 0, se reinicia al final de la b\u00fasqueda.</li> </ol> <p>La b\u00fasqueda tambi\u00e9n se podr\u00eda realizar en un bucle.</p> <pre><code>const str = 'let varName'\nconst regexp = /\\w+/g\nlet result\nwhile (result = regexp.exec(str)) {\nconsole.log(`Found ${result[0]} at position ${result.index}`)\n}\n</code></pre> <p>De esta manera, podemos solucionar el problema que nos ata\u00f1e, y obtener coincidencia en el \u00edndice 4.</p> <pre><code>const str = 'let varName = \"value\"';\nconst regexp = /\\w+/g\nregexp.lastIndex = 4\nconst word = regexp.exec(str)\nconsole.log(word) // varName\n</code></pre> <p>Sin embargo, si usamos la propiedad <code>lastIndex</code> y  no hay ninguna coincidencia encontrada, pero s\u00ed en un lugar posterior, \u00e9sta ser\u00e1 encontrada. Pero esto, en ciertas ocasiones, no es lo que se desea obtener, sino que se desea obtener la coincidencia en la posici\u00f3n exacta. Para ello, usamos el indicador <code>y</code> para realizar la b\u00fasqueda exactamente en la posici\u00f3n lastIndex y no comenzando en ella:</p> <pre><code>const str = 'let varName = \"value\"'\nconst regexp = /\\w+/y\nregexp.lastIndex = 3\nconsole.log(regexp.exec(str)) // null\nregexp.lastIndex = 4\nconsole.log(regexp.exec(str)) // varName\n</code></pre> <p>Como podemos observar, la expresi\u00f3n no coincide en la posici\u00f3n 3, pero s\u00ed en la posici\u00f3n 4. No solamente es lo que necesitamos, sino que tambi\u00e9n es una mejora en el rendimiento.</p>"},{"location":"bloque_i/tema_7/page-7/#metodo-split","title":"M\u00e9todo split","text":"<p>El m\u00e9todo <code>split(regex|substring, limit)</code> es un m\u00e9todo de cadena que te permite obtener un array de subcadenas. Podemos indicar una substring para indicar por que car\u00e1cter o subcadena separar la cadena original:</p> <pre><code>console.log('12-34-56'.split('-')) // [12, 34, 56]\n</code></pre> <p>En lugar de usar una subcadena, tambi\u00e9n se puede usar una expresi\u00f3n regular como separador:</p> <pre><code>console.log('12, 34, 56'.split('/,\\s*/')) // [12, 34, 56]\n</code></pre> <p>Tambi\u00e9n se puede indicar un argumento con el n\u00famero de elementos que se desea obtener como resultado en el array.</p>"},{"location":"bloque_i/tema_7/page-7/#metodo-search","title":"M\u00e9todo search","text":"<p>El m\u00e9todo <code>search(regex)</code> es un m\u00e9todo de las cadenas que retorna la posici\u00f3n de la primera coincidencia o un <code>-1</code>, si no hay coincidencias.</p> <pre><code>const str = 'A drop of ink may make a million think'\nconsole.log(str.search(/ink/i)) // 10\n</code></pre> <p>Warning</p> <p>Solo devuelve la posici\u00f3n de la primera coincidencia. En caso de que haya m\u00e1s de una, el resto de las coincidencias ser\u00e1n omitidas.</p>"},{"location":"bloque_i/tema_7/page-8/","title":"Ejercicios","text":"Ejercicio 1 <p>Crea y comprueba las siguientes expresiones regulares:</p> <ol> <li>que la cadena sea exactamente \u201ctrue\u201d.</li> <li>que la cadena sea de tres letras, may\u00fasculas o min\u00fasculas.</li> <li>que la cadena contenga 5 o m\u00e1s caracteres que no sean la \u00f1, la z ni la x.</li> <li>que la cadena no empiece con un n\u00famero.</li> <li>que la cadena tenga varios caracteres excepto la b.</li> <li>que la cadena sea un n\u00famero de tel\u00e9fono.</li> <li>que la cadena sea un DNI.</li> <li>que la cadena sea un nombre, es decir, que no tenga espacios, que no sea una cadena vac\u00eda y que empiece por may\u00fasculas.</li> <li>que la cadena empiece con vocal y luego tenga varias consonantes o ninguna.</li> <li>que la cadena tenga un n\u00famero positivo m\u00e1s peque\u00f1o que 300.</li> </ol> Ejercicio 2 <p>\u00bfQu\u00e9 cadena coincide con el patr\u00f3n <code>^$</code>?</p> Ejercicio 3 <p>Crea un funci\u00f3n que te permita encontrar los puntos suspensivos en una cadena. La funci\u00f3n debe retornar cuantos puntos suspensivos se han encontrado.</p> Ejercicio 4 <p>Crea una funci\u00f3n que te permita encontrar colores en formato hexadecimal. La funci\u00f3n debe devolver un array con los valores de los colores. Realiza una prueba con un fichero CSS.</p> Ejercicio 5 <p>Crea una funci\u00f3n que encuentre las etiquetas HTML con sus atributos. La funci\u00f3n debe devolver un objeto con la siguiente estructura: nombre de la etiqueta y lista de atributos (pares nombre y valor)</p> Ejercicio 6 <p>Crea una funci\u00f3n que encuentre en una expresi\u00f3n matem\u00e1tica, los operandos y las operaciones. Calcula el valor de la expresi\u00f3n.</p> Ejercicio 7 <p>Crea una funci\u00f3n que dado un string que simula un fichero HTML, inserte una etiqueta dada dentro del body.</p> Ejercicio 8 <p>Crea una funci\u00f3n que reciba una cadena y comprueba si tiene un formato de tiempo v\u00e1lido (Horas:minutos:segundos)</p>"},{"location":"bloque_i/tema_8/page-1/","title":"1 Configuraci\u00f3n de las propiedades de los objetos","text":""},{"location":"bloque_i/tema_8/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Como hemos visto hasta ahora, los objetos pueden almacenar propiedades, que son un par clave-valor que indican un atributo del objeto a definir. Sin embargo, las propiedades son m\u00e1s que un simple clave-valor.</p>"},{"location":"bloque_i/tema_8/page-1/#indicadores-de-propiedades","title":"Indicadores de propiedades","text":"<p>Las propiedades de objeto, aparte de un <code>value</code>, tienen tres atributos especiales (tambi\u00e9n llamados indicadores):</p> <ul> <li><code>writable</code> - si es <code>true</code> puede ser editado, de otra forma es solo de lectura.</li> <li><code>enumerable</code> - si es <code>true</code> puede ser listado en bucles.</li> <li><code>configurable</code> - si es <code>true</code>, la propiedad puede ser borrada y estos atributos pueden ser modificados.</li> </ul> <p>Si creamos un objeto de la forma usual, todos estos indicadores est\u00e1n a <code>true</code>. Para poder consular dichos indicadores podemos usar el m\u00e9todo <code>Object.getOwnPropertyDescriptor(obj, propertyName)</code>, que recibe tanto el objeto como el nombre de la propiedad. Veamos un ejemplo:</p> <pre><code>const user = {\nname: \"Juan\"\n}\nconst descriptor = Object.getOwnPropertyDescriptor(user, 'name')\nconsole.log(JSON.stringify(descriptor, null, 2))\n/* descriptor de propiedad:\n{\n  \"value\": \"Juan\",\n  \"writable\": true,\n  \"enumerable\": true,\n  \"configurable\": true\n}\n*/\n</code></pre> <p>Para modificar los indicadores se puede usar el m\u00e9todo <code>Object.defineProperty(obj, propertyName, descriptor)</code>, que recibe el objeto y la el nombre de la propiedad a crear, as\u00ed como el descriptor de la propiedad a aplicar. Si la propiedad existe, el m\u00e9todo actualiza sus indicadores. De otra forma, crear\u00e1 la propiedad con el valor y el indicador dado; en ese caso, si el indicador no es proporcionado, es asumido como <code>false</code>.</p> <pre><code>const user = {};\nObject.defineProperty(user, \"name\", {\nvalue: \"Juan\"\n})\nconst descriptor = Object.getOwnPropertyDescriptor(user, 'name')\nconsole.log(JSON.stringify(descriptor, null, 2 ))\n/*\n{\n  \"value\": \"Juan\",\n  \"writable\": false,\n  \"enumerable\": false,\n  \"configurable\": false\n}\n */\n</code></pre> <p>Cuando <code>writable</code> es <code>false</code> impide modificar la propiedad. Dar\u00e1 un error en modo estricto, de lo contrario la operaci\u00f3n ser\u00e1 omitida.</p> <pre><code>const user = {\nname: \"Juan\"\n}\nObject.defineProperty(user, \"name\", {writable: false})\nuser.name = \"Pedro\" // \u274c\n</code></pre> <p>El indicador <code>enumerable</code> es <code>false</code> impide acceder a una propiedad para listarla, a trav\u00e9s de un bucle. Esto suele ser \u00fatil, cuando deseamos que algunas propiedades (o m\u00e9todos) no se muestren al listar el objeto. Tambi\u00e9n son excluidas al usar el  m\u00e9todo <code>Object.keys(obj)</code></p> <pre><code>const user = {\nname: \"Juan\",\ntoString() {\nreturn this.name;\n}\n}\nObject.defineProperty(user, \"toString\", {\nenumerable: false\n})\nfor (const key in user) console.log(key)\n</code></pre> <p>Por \u00faltimo, una propiedad no configurable no puede ser eliminada, y sus atributos no pueden ser modificados. No se podr\u00eda sobrescribir la propiedad, ni siquiera cambiar sus indicadores. Una propiedad no configurable impide cambios en los indicadores de la propiedad y su eliminaci\u00f3n, pero permite el cambio de su valor.</p> <p>Info</p> <p>Hay una excepci\u00f3n menor acerca del cambio de indicadores.</p> <p>Podemos cambiar<code>writable: true</code> a <code>false</code> en una propiedad no configurable, impidiendo en m\u00e1s la modificaci\u00f3n de su valor (sumando una capa de protecci\u00f3n). Aunque no hay vuelta atr\u00e1s.</p> <p>Si se desea definir los indicadores de m\u00e1s de una propiedad, se puede usar el m\u00e9todo <code>Object.defineProperties(obj, descriptors)</code></p> <pre><code>Object.defineProperties(user, {\nname: { value: \"Juan\", writable: false },\nsurname: { value: \"Perez\", writable: false },\n// ...\n})\n</code></pre> <p>Para obtener todos los descriptores al mismo tiempo, podemos usar el m\u00e9todo <code>Object.getOwnPropertyDescriptors(obj)</code>. Junto con <code>Object.defineProperties</code>, puede ser usado como una forma consciente de los indicadores de clonar un objeto, ya que normalmente cuando se clona un objeto no se clona sus indicadores. Adem\u00e1s, este m\u00e9todo, no ignora ni los descriptores ni las propiedades simb\u00f3licas:</p> <pre><code>const clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj))\n</code></pre>"},{"location":"bloque_i/tema_8/page-1/#objeto-inmutable","title":"Objeto inmutable","text":"<p>En el tema 6 vimos dos m\u00e9todos para hacer un objeto completamente inmutable <code>Object.freeze(obj)</code> y <code>Object.seal(obj)</code>. El primer m\u00e9todo estable las propiedades del objeto como no writable y no configurable, mientras que las del segundo solo establece las propiedades como no configurable.</p> <p>Existe otro m\u00e9todo <code>Object.preventExtensions(obj)</code> que impide a\u00f1adir propiedades al objeto, pero si permite su modificaci\u00f3n de propiedades.</p> <p>Existe su m\u00e9todos <code>is</code>, es decir, m\u00e9todos que comprueban si los objetos son inmutables de alguna de las formas anteriores:</p> <ul> <li><code>Object.isExtensible(obj)</code>. Comprueba si no permite a\u00f1adir propiedades, es decir, si ha sido sellado con el m\u00e9todo <code>Object.preventExtensions(obj)</code>.</li> <li><code>Object.isSealed(obj)</code>. Comprueba si el objeto es inmutable, pero te permite modificar las propiedades, es decir, ha sido sellado con <code>Object.seal(obj)</code>.</li> <li><code>Object.isFrozen(obj)</code>. Comprueba si el objeto es inmutable completamente, es decir, ha sido sellado con <code>Object.freeze(obj)</code>.</li> </ul>"},{"location":"bloque_i/tema_8/page-1/#getters-y-setters-de-una-propiedad","title":"Getters y setters de una propiedad","text":"<p>Existen dos tipos de propiedades de objetos: el primer tipo son las propiedades de datos (vistas hasta ahora) y el segundo tipo de propiedades son las propiedades de acceso o accessors.</p> <p>Las propiedades de acceso son, en esencia, funciones que se ejecutan para obtener (get) y asignar (set) un valor, pero que para un c\u00f3digo externo se ven como propiedades normales.</p> <p>Las propiedades de acceso se construyen con m\u00e9todos de obtenci\u00f3n getter y asignaci\u00f3n setter. En un objeto literal se denotan con <code>get</code> y <code>set</code>:</p> <pre><code>const obj = {\nget propName(){\n// Getter action\n}\nset propName(value){\n// Setter action\n}\n}\n</code></pre> <p>El getter ser\u00e1 llamado cuando se desea acceder a la propiedad, mientras que el setter lo ser\u00e1 cuando se desea modificar:</p> <pre><code>const user = {\nname: \"John\",\nsurname: \"Smith\",\nget fullName() {\nreturn `${this.name} ${this.surname}`;\n}\n}\nconsole.log(user.fullName) // John Smith\n</code></pre> <p>En el ejemplo anterior, tenemos una propiedad definida con getter, <code>fullName</code>. Desde fuera, una propiedad de acceso se parece a una normal. Esa es la idea de estas propiedades. No llamamos a <code>user.fullName</code> como una funci\u00f3n, la leemos normalmente, el getter se ejecuta por detr\u00e1s.</p> <p>La propiedad <code>fullName</code> solo tiene un \u00fanico receptor, getter, por lo que no se podr\u00e1 modificar al no tener definido una funci\u00f3n setter.</p> <pre><code>const user = {\nname: \"John\",\nsurname: \"Smith\",\nget fullName() {\nreturn `${this.name} ${this.surname}`;\n},\nset fullName(value) {\n[this.name, this.surname] = value.split(\" \");\n}\n}\n// set fullName se ejecuta con el valor dado.\nuser.fullName = \"Alice Cooper\"\nconsole.log(user.name) // Alice\nconsole.log(user.surname) // Cooper\n</code></pre> <p>Los descriptores de propiedades de acceso son diferentes de aquellos para las propiedades de datos. Para las propiedades de acceso, no hay cosas como <code>value</code> y <code>writable</code>, sino de get y set. As\u00ed que un descriptor de accesos puede tener:</p> <ul> <li><code>get</code> \u2013 una funci\u00f3n sin argumentos, que funciona cuando se lee una propiedad,</li> <li><code>set</code> \u2013 una funci\u00f3n con un argumento, que se llama cuando se establece la propiedad,</li> <li><code>enumerable</code> \u2013 lo mismo que para las propiedades de datos,</li> <li><code>configurable</code> \u2013 lo mismo que para las propiedades de datos.</li> </ul> <pre><code>const user = {\nname: \"John\",\nsurname: \"Smith\"\n}\nObject.defineProperty(user, 'fullName', {\nget() {\nreturn `${this.name} ${this.surname}`\n},\nset(value) {\n[this.name, this.surname] = value.split(\" \")\n}\n})\nconsole.log(user.fullName) // John Smith\nfor(let key in user) console.log(key)\n</code></pre> <p>Warning</p> <p>Tenga en cuenta que una propiedad puede ser un acceso (tiene m\u00e9todos <code>get</code>/<code>set</code>) o una propiedad de datos (tiene un <code>value</code>), no ambas. Si intentamos poner ambos, get y value, en el mismo descriptor, habr\u00e1 un error.</p> <p>Getters y setters pueden ser usados como envoltorios sobre valores de propiedad reales para obtener m\u00e1s control sobre ellos. Por ejemplo, si queremos prohibir nombres demasiado cortos para usuario, podemos guardar nombre en una propiedad especial nombre. Y filtrar las asignaciones en el <code>setter</code>:</p> <pre><code>const user = {\nget name() {\nreturn this._name\n},\nset name(value) {\nif (value.length &lt; 4) {\nconsole.log(\"El nombre es demasiado corto, necesita al menos 4 caracteres\");\nreturn\n}\nthis._name = value\n}\n}\nuser.name = \"Pete\"\nconsole.log(user.name) // Pete\nuser.name = \"\" // El nombre es demasiado corto...\n</code></pre>"},{"location":"bloque_i/tema_8/page-2/","title":"2 Herencia protot\u00edpica","text":""},{"location":"bloque_i/tema_8/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>En programaci\u00f3n, se conoce la herencia como el paradigma que permite tener una objeto que hereda tanto propiedades como m\u00e9todos de otro objeto. Por ejemplo: tenemos un objeto user con sus propiedades y m\u00e9todos, y queremos hacer que admin y guest sean variantes ligeramente modificadas del mismo. Nos gustar\u00eda reutilizar lo que tenemos en user. No queremos copiar ni reimplementar sus m\u00e9todos, sino solamente construir un nuevo objeto encima del existente.</p> <p>La herencia protot\u00edpica es una caracter\u00edsticas de Javascript que ayuda a realizar esta operaci\u00f3n de herencia.</p>"},{"location":"bloque_i/tema_8/page-2/#prototype","title":"[[Prototype]]","text":"<p>En JavaScript, los objetos tienen una propiedad oculta especial <code>[[Prototype]]</code> (como se menciona en la especificaci\u00f3n); que puede ser <code>null</code>, o hacer referencia a otro objeto llamado prototipo. Cuando leemos una propiedad de <code>object</code>, si JavaScript no la encuentra all\u00ed la toma autom\u00e1ticamente del prototipo. En programaci\u00f3n esto se llama herencia protot\u00edpica.</p> <p>La propiedad <code>[[Prototype]]</code> es interna y est\u00e1 oculta, pero hay muchas formas de configurarla. Una de ellas es usar el nombre especial <code>__proto__</code>, as\u00ed:</p> <pre><code>const animal = {\neats: true\n}\nconst rabbit = {\njumps: true\n}\nrabbit.__proto__ = animal // (1)!\nconsole.log(rabbit.eats) //(2)!\nconsole.log(rabbit.jumps)\n</code></pre> <ol> <li>Estable que el prototipo de <code>rabbit</code> es <code>animal</code>.</li> <li>No encuentra la propiedad <code>eats</code> en el objeto <code>rabbit</code> por lo que JavaScript sigue la referencia <code>[[Prototype]]</code> y la encuentra en <code>animal</code> (busca de abajo hacia arriba)</li> </ol> <p>Cuando se realiza la b\u00fasqueda de un propiedad de un objeto y \u00e9sta no se encuentra en dicho objeto, Javascript sigue la referencia <code>[[Prototype]]</code> hasta encontrarla. Si no la encuentra, se devuelve <code>undefined</code> (de abajo a arriba).</p> <pre><code>---\ntitle: Herencia protot\u00edpica\n---\nclassDiagram\n    class animal{\n        eats: true\n    }\n\n    class rabitt{\n        jumps: true\n    }\n\n    animal &lt;|-- rabitt</code></pre> Figura 1 - Herencia protot\u00edpica <p>Aqu\u00ed podemos decir que animal es el prototipo de rabbit o que rabbit hereda protot\u00edpicamente de animal. Entonces, si animal tiene muchas propiedades y m\u00e9todos \u00fatiles, estos estar\u00e1n autom\u00e1ticamente disponibles en rabbit. Dichas propiedades se denominan heredadas.</p> <p>La herencia puede ser m\u00e1s extensas, es decir, podemos tener un objeto que herede de otro objeto que a su vez hereda de otro:</p> <pre><code>const animal = {\neats: true,\nwalk() {\nconsole.log(\"Animal da un paseo\")\n}\n}\nconst rabbit = {\njumps: true,\n__proto__: animal\n}\nconst longEar = {\nearLength: 10,\n__proto__: rabbit\n}\nlongEar.walk()\nconsole.log(longEar.jumps)\n</code></pre> <p>Info</p> <p>Es un error com\u00fan de principiantes no saber la diferencia entre ambos.</p> <p>Tenga en cuenta que <code>__proto__</code> no es lo mismo que la propiedad interna <code>[[Prototype]]</code>. En su lugar, <code>__proto__</code> es un getter/setter para <code>[[Prototype]]</code>. </p> <p>La propiedad <code>__proto__</code> es algo antigua y existe por razones hist\u00f3ricas, por lo que los navegadores y entornos del lado del servidor contin\u00faan soport\u00e1ndola, as\u00ed que es bastante seguro su uso. Seg\u00fan la especificaci\u00f3n, solamente los navegadores est\u00e1n obligados a continuar soport\u00e1ndola. Desde JavaScript Moderno se recomienda el uso de las funciones Object.getPrototypeOf y Object.setPrototypeOf para obtener y establecer el prototipo. Estudiaremos estas funciones m\u00e1s adelante.</p> <p>Como la notaci\u00f3n <code>__proto__</code> es m\u00e1s intuitiva, la usaremos en los ejemplos.</p> <p>El prototipo solo se usa para leer propiedades. Las operaciones de escritura/eliminaci\u00f3n funcionan directamente con el objeto. Veamos un ejemplo:</p> <pre><code>const animal = {\neats: true,\nwalk() {\n/* este m\u00e9todo no ser\u00e1 utilizado por rabbit */\n}\n}\nconst rabbit = {\n__proto__: animal\n}\nrabbit.walk = function() {\nconsole.log(\"\u00a1Conejo! \u00a1Salta, salta!\")\n}\nrabbit.walk() // \u00a1Conejo! \u00a1Salta, salta!\n</code></pre> <p>De ahora en adelante, la llamada <code>rabbit.walk()</code> encuentra el m\u00e9todo inmediatamente en el objeto y lo ejecuta, sin usar el prototipo.</p> <p>Las propiedades de acceso son una excepci\u00f3n, ya que la asignaci\u00f3n es manejada por una funci\u00f3n setter. Por lo tanto, escribir en una propiedad de este tipo es en realidad lo mismo que llamar a una funci\u00f3n.</p> <pre><code>const user = {\nname: \"John\",\nsurname: \"Smith\",\nset fullName(value) {\n[this.name, this.surname] = value.split(\" \")\n},\nget fullName() {\nreturn `${this.name} ${this.surname}`\n}\n}\nconst admin = {\n__proto__: user,\nisAdmin: true\n}\nconsole.log(admin.fullName)\nadmin.fullName = \"Alice Cooper\"\nconsole.log(admin.fullName)\nconsole.log(user.fullName)\n</code></pre> <p>No importa d\u00f3nde se encuentre el m\u00e9todo, en un objeto o su prototipo. En una llamada al m\u00e9todo, <code>this</code> es siempre el objeto antes del punto. Entonces, la llamada al setter <code>admin.fullName=</code> usa a <code>admin</code> como <code>this</code>, no a <code>user</code>.</p> <p>Esto es realmente algo muy importante, porque podemos tener un gran objeto con muchos m\u00e9todos y tener objetos que hereden de \u00e9l. Y cuando los objetos heredados ejecutan los m\u00e9todos heredados, modificar\u00e1n solo sus propios estados, no el estado del gran objeto.</p> <p>El bucle <code>for..in</code> puede acceder a las propiedades heredadas. Sin embargo, si no se desea acceder a ellas, se puede utilizar el m\u00e9todo <code>hasOwnProperty(key)</code> del objeto, que comprueba si el objeto tiene la propiedad interna (NO heredada) llamada <code>key</code>.</p> <pre><code>const animal = {\neats: true\n}\nconst rabbit = {\njumps: true,\n__proto__: animal\n}\nfor(const prop in rabbit) {\nlet isOwn = rabbit.hasOwnProperty(prop)\nif (isOwn) {\nconsole.log(`Es nuestro: ${prop}`) // Es nuestro: jumps\n} else {\nconsole.log(`Es heredado: ${prop}`) // Es heredado: eats\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_8/page-2/#fprototype","title":"F.prototype","text":"<p>Como ya hemos visto, podemos delegar la creaci\u00f3n de un objeto a trav\u00e9s de una funci\u00f3n constructora, a trav\u00e9s del operador <code>new</code>:</p> <pre><code>function Rabbit(name){\nthis.name = name\n}\n</code></pre> <p><code>F.prototype</code> es la forma de indicar la herencia del objeto a construir. Se utiliza, para establecer el valor del <code>__proto__</code> a trav\u00e9s de la funci\u00f3n constructora:</p> <pre><code>const animal = {\neats: true\n}\nfunction Rabbit(name) {\nthis.name = name\n}\nRabbit.prototype = animal\nconst rabbit = new Rabbit(\"Conejo Blanco\") //  rabbit.__proto__ == animal\nconsole.log(rabbit.eats) // verdadero\n</code></pre> <p>La configuraci\u00f3n de <code>Rabbit.prototype = animal</code> literalmente establece lo siguiente: Cuando se crea un <code>new Rabbit</code>, asigne animal a su <code>[[Prototype]]</code>.</p> <p>Warning</p> <p>La propiedad <code>F.prototype</code> solo se usa cuando se llama a <code>new F</code>. Asigna <code>[[Prototype]]</code> del nuevo objeto.</p> <p>Si, despu\u00e9s de la creaci\u00f3n, la propiedad <code>F.prototype</code> cambia (<code>F.prototype = &lt;otro objeto&gt;</code>), los nuevos objetos creados por <code>new F</code> tendr\u00e1n otro objeto como <code>[[Prototype]]</code>, pero los objetos ya existentes conservar\u00e1n el antiguo.</p>"},{"location":"bloque_i/tema_8/page-2/#metodos-modernos","title":"M\u00e9todos modernos","text":"<p>Como ya hemos mencionado,leer y escribir en <code>__proto__</code> se considera desactualizado y algo obsoleto. Sin embargo, existen m\u00e9todos modernos que nos permiten tratar con ellos:</p> <ul> <li><code>Object.getPrototypeOf(obj)</code>: Devuelve el <code>[[Prototype]]</code> del objeto.</li> <li><code>Object.setPrototypeOf(obj, proto)</code>: Establece el <code>[[Prototype]]</code> del objeto a proto.</li> </ul> <p>El \u00fanico uso de <code>__proto__</code> que no est\u00e1 mal visto, es como una propiedad cuando se crea un nuevo <code>objeto: { __proto__: ... }</code>.</p> <p>Aunque existe el m\u00e9todo <code>Object.create(proto, [descriptors])</code>, crea un objeto vac\u00edo con el proto dado como <code>[[Prototype]]</code> y descriptores de propiedad opcionales.</p> <p>Warning</p> <p>T\u00e9cnicamente, podemos obtener/configurar <code>[[Prototype]]</code> en cualquier momento. Pero generalmente solo lo configuramos una vez en el momento de creaci\u00f3n del objeto y ya no lo modificamos: rabbit hereda de animal, y eso no va a cambiar.</p> <p>Y los motores de JavaScript est\u00e1n altamente optimizados para esto. Cambiar un prototipo sobre la marcha con <code>Object.setPrototypeOf</code> u <code>obj.__proto__=</code> es una operaci\u00f3n muy lenta ya que rompe las optimizaciones internas para las operaciones de acceso a la propiedad del objeto. Por lo tanto, ev\u00edtelo a menos que sepa lo que est\u00e1 haciendo, o no le importe la velocidad de JavaScript .</p>"},{"location":"bloque_i/tema_8/page-3/","title":"3 Prototipos nativos","text":""},{"location":"bloque_i/tema_8/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>La propiedad <code>prototype</code> es ampliamente utilizada por el n\u00facleo de Javascript. Todas las funciones constructoras integradas los usan.</p>"},{"location":"bloque_i/tema_8/page-3/#objectprototype","title":"Object.prototype","text":"<p>En Javascript, existe una funci\u00f3n constructora global para crear objetos  <code>new Object()</code>, similar a <code>obj = {}</code>. El objecto <code>Object</code> tiene su propio <code>prototype</code> que hace referencia a un gran objeto con varios m\u00e9todos, incluido <code>toString()</code>. Por ello, cuando se crea un objeto vac\u00edo, se le puede realizar la llamada al m\u00e9todo <code>toString()</code>, ya que indirectamente hereda de este objeto.</p> <pre><code>const obj = {}\nconsole.log(obj.toString()) // [Object object]\n</code></pre> <p>Otros objetos integrados, como <code>Array</code>, <code>Date</code> , <code>Function</code>, tambi\u00e9n mantienen los m\u00e9todos en sus prototipos.</p> <p>Por ejemplo, cuando creamos una matriz <code>[1, 2, 3]</code>, el constructor predeterminado <code>new Array()</code> se usa internamente. Entonces <code>Array.prototype</code> se convierte en su prototipo y proporciona sus m\u00e9todos. Eso es muy eficiente en memoria.</p> <p>Por especificaci\u00f3n, todos los prototipos integrados tienen <code>Object.prototype</code> en el tope. Es por eso que algunos dicen todo hereda de los objetos.</p>"},{"location":"bloque_i/tema_8/page-3/#primitivos","title":"Primitivos","text":"<p>Como recordamos, los primitivos no son objetos. Pero si tratamos de acceder a sus propiedades, se crean los objetos contenedores temporales utilizando los constructores integrados <code>String</code>, <code>Number</code> y <code>Boolean</code>, estos proporcionan los m\u00e9todos y luego desaparecen.</p> <p>Estos objetos se crean de manera invisible para nosotros y la mayor\u00eda de los motores los optimizan, pero la especificaci\u00f3n lo describe exactamente de esta manera. Los m\u00e9todos de estos objetos tambi\u00e9n residen en prototipos, disponibles como <code>String.prototype</code>, <code>Number.prototype</code> y <code>Boolean.prototype</code>.</p> <p>Warning</p> <p>Los valores especiales <code>null</code> y <code>undefined</code> se distinguen. No tienen objetos contenedores, por lo que los m\u00e9todos y propiedades no est\u00e1n disponibles para ellos. Y tampoco tienen los prototipos correspondientes.</p>"},{"location":"bloque_i/tema_8/page-3/#cambiando-prototipos-nativos","title":"Cambiando prototipos nativos","text":"<p>Los prototipos nativos pueden ser modificados. Por ejemplo, si agregamos un m\u00e9todo a <code>String.prototype</code>, estar\u00e1 disponible para todas las cadenas:</p> <pre><code>String.prototype.show = function() {\nconsole.log(this)\n}\n\"BOOM!\".show() // BOOM!\n</code></pre> <p>Durante el proceso de desarrollo, podemos tener ideas para nuevos m\u00e9todos integrados que nos gustar\u00eda tener, y podemos sentir la tentaci\u00f3n de agregarlos a los prototipos nativos. Pero eso es generalmente una mala idea.</p> <p>Los prototipos son globales, por lo que es f\u00e1cil generar un conflicto. Si dos bibliotecas agregan un m\u00e9todo String.prototype.show, entonces una de ellas sobrescribir\u00e1 el m\u00e9todo de la otra.</p> <p>Por lo tanto, en general, modificar un prototipo nativo se considera una mala idea. En la programaci\u00f3n moderna, solo hay un caso en el que se aprueba la modificaci\u00f3n de prototipos nativos: haciendo un polyfill.</p> <p>Cuando un m\u00e9todo existe en la especificaci\u00f3n de JavaScript, pero a\u00fan no est\u00e1 soportado por un motor de JavaScript en particular, podemos hacer polyfill; esto es, crear un m\u00e9todo sustituto.</p> <p>Luego podemos implementarlo manualmente y completar el prototipo integrado con \u00e9l.</p> <pre><code>if (!String.prototype.repeat) {\nString.prototype.repeat = function(n) {\nreturn new Array(n + 1).join(this)\n}\n}\nconsole.log(\"La\".repeat(3))\n</code></pre>"},{"location":"bloque_i/tema_8/page-3/#prestamo-de-prototipos","title":"Pr\u00e9stamo de prototipos","text":"<p>Anteriormente, en Decoradores y redirecciones, call/apply hablamos sobre el pr\u00e9stamo de m\u00e9todo, cuando tomamos un m\u00e9todo de un objeto y lo copiamos en otro. A menudo se toman prestados algunos m\u00e9todos de prototipos nativos.</p> <pre><code>const obj = {\n0: \"Hola\",\n1: \"mundo!\",\nlength: 2,\n}\nobj.join = Array.prototype.join\nconsole.log(obj.join(',')) // Hola,mundo!\n</code></pre> <p>Funciona porque el algoritmo interno del m\u00e9todo integrado <code>join</code> solo se preocupa por los \u00edndices correctos y la propiedad <code>length</code>. No comprueba si el objeto es realmente un arreglo. Muchos m\u00e9todos integrados son as\u00ed.</p> <p>Otra posibilidad es heredar estableciendo <code>obj.__proto__</code> en <code>Array.prototype</code>, de modo que todos los m\u00e9todos Array est\u00e9n disponibles autom\u00e1ticamente en <code>obj</code>. Pero eso es imposible si obj ya hereda de otro objeto. Recuerde, solo podemos heredar de un objeto a la vez.</p>"},{"location":"bloque_i/tema_8/page-4/","title":"4 Programaci\u00f3n Orientada a objetos","text":""},{"location":"bloque_i/tema_8/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es una t\u00e9cnica de programar aplicaciones basada en una serie de objetos independientes que se comunican entre s\u00ed.</p> <p>En inform\u00e1tica, una clase es una plantilla para la creaci\u00f3n de objetos de datos seg\u00fan un modelo predefinido. Las clases se utilizan para representar entidades o conceptos, como los sustantivos en el lenguaje. Cada clase es un modelo que define un conjunto de variables \u2014el estado\u2014, y m\u00e9todos apropiados para operar con dichos datos \u2014el comportamiento\u2014.</p> <p>Un objeto es un elemento del programa que integra sus propios datos y su propio funcionamiento. Es decir, un objeto est\u00e1 formado por datos (atributos o propiedades) y por las funciones que es capaz de realizar el objeto (m\u00e9todos). Esta forma de programar se asemeja m\u00e1s al pensamiento humano. La cuesti\u00f3n es detectar adecuadamente los objetos necesarios para una aplicaci\u00f3n. De hecho hay que detectar las distintas clases de objetos.</p> <p>Hasta ahora, dicha plantilla, ha sido representada con los objetos, y hemos facilitado su creaci\u00f3n a trav\u00e9s de las funciones constructoras. Sin embargo, en Javascript moderno existe una nueva sintaxis, que nos introduce nuevas caracter\u00edsticas.</p>"},{"location":"bloque_i/tema_8/page-4/#clases","title":"Clases","text":"<p>Para crear una clase, se usa la palabra reservada <code>class</code> seguida del nombre de la clase, indicando en un bloque, los m\u00e9todos y propiedades de clase:</p> <pre><code>class MyClass {\nconstructor() { ... }\nmethod1() { ... }\nmethod2() { ... }\nmethod3() { ... }\n...\n}\n</code></pre> <p>Para crear un objeto de este tipo, se puede usar la funci\u00f3n constructora <code>new MyClass()</code>, que llama internamente al m\u00e9todo <code>constructor</code>. Veamos un ejemplo:</p> <pre><code>class User {\nconstructor(name) {\nthis.name = name\n}\nsayHi() {\nalert(this.name)\n}\n}\nconst user = new User(\"John\")\nuser.sayHi() // John\n</code></pre> <p>Warning</p> <p>Un tropiezo com\u00fan en desarrolladores principiantes es poner una coma entre los m\u00e9todos de clase, lo que resulta en un error de sintaxis.</p> <p>La notaci\u00f3n aqu\u00ed no debe ser confundida con la sintaxis de objeto literal. Dentro de la clase no se requieren comas.</p> <p>Lo que la construcci\u00f3n <code>class User {...}</code> hace realmente es:</p> <ol> <li>Crea una funci\u00f3n llamada <code>User</code>, la que se vuelve el resultado de la declaraci\u00f3n de la clase. El c\u00f3digo de la funci\u00f3n es tomado del m\u00e9todo constructor (se asume vac\u00edo si no se escribe tal m\u00e9todo).</li> <li>Almacena los m\u00e9todos de clase, tales como <code>sayHi</code>, en <code>User.prototype</code>.</li> </ol> <p>Despu\u00e9s de que el objeto <code>new User</code> es creado, cuando llamamos a sus m\u00e9todos estos son tomados del prototipo, tal como hemos visto. As\u00ed el objeto tiene acceso a m\u00e9todos de clase.</p> <pre><code>class User {\nconstructor(name) { this.name = name }\nsayHi() { alert(this.name) }\n}\nconsole.log(typeof User) // function\nconsole.log(User === User.prototype.constructor) // true\nconsole.log(User.prototype.sayHi) // el c\u00f3digo del m\u00e9todo sayHi\nconsole.log(Object.getOwnPropertyNames(User.prototype)) // constructor, sayHi\n</code></pre> <p>A veces se dice que class es az\u00facar sint\u00e1ctica (sintaxis que es dise\u00f1ada para una lectura m\u00e1s f\u00e1cil, pero que no introduce nada nuevo), porque en realidad podemos declarar lo mismo sin la palabra clave class en absoluto:</p> <pre><code>function User(name) {\nthis.name = name\n}\nUser.prototype.sayHi = function() {\nconsole.log(this.name)\n}\nconst user = new User(\"John\")\nuser.sayHi()\n</code></pre> <p>El resultado de esta definici\u00f3n es el mismo. As\u00ed, efectivamente hay razones para que <code>class</code> sea considerada az\u00facar sint\u00e1ctica para definir un constructor junto con sus m\u00e9todos de prototipo.</p> <p>Sin embargo, existe algunas diferencias:</p> <ol> <li>Una funci\u00f3n creada por <code>class</code> es etiquetada por una propiedad interna especial <code>[[IsClassConstructor]]:true</code>. Entones no es exactamente lo mismo que crearla manualmente. El lenguaje verifica esa propiedad en varios lugares. Por ejemplo, a diferencia de las funciones regulares, esta debe ser llamada con <code>new</code>.</li> <li>Los m\u00e9todos de clase no son enumerables. La definici\u00f3n de clase establece la bandera enumerable a <code>false</code> para todos los m\u00e9todos en prototype. Esto es bueno porque si hacemos for..in a un objeto usualmente no queremos sus m\u00e9todos de clase.</li> <li>Las clases siempre asumen <code>use strict</code>. Todo el c\u00f3digo dentro del constructor de clase est\u00e1 autom\u00e1ticamente en modo estricto.</li> </ol> <p>Adem\u00e1s la sintaxis <code>class</code> brinda nuevas caracter\u00edsticas que iremos viendo.</p>"},{"location":"bloque_i/tema_8/page-4/#expresion-de-clases","title":"Expresi\u00f3n de clases","text":"<p>Al igual que las funciones, las clases pueden ser definidas dentro de otra expresi\u00f3n, pasadas, devueltas, asignadas, etc.</p> <pre><code>const User = class {\nsayHi() {\nalert(\"Hello\")\n}\n}\n</code></pre> <p>Al igual que las expresiones de funci\u00f3n, las expresiones de clase pueden tener un nombre. Si una expresi\u00f3n de clase tiene un nombre, este es visible solamente dentro de la clase.</p> <pre><code>const User = class MyClass {\nsayHi() {\nconsole.log(MyClass)\n}\n}\nnew User().sayHi()\nconsole.log(MyClass) // \u274c\n</code></pre> <p>Incluso, se pueden crear clases de forma din\u00e1mica:</p> <pre><code>function makeClass(phrase) {\nreturn class {\nsayHi() {\nalert(phrase)\n}\n}\n}\n// Crea una nueva clase\nconst User = makeClass(\"Hello\")\nnew User().sayHi() // Hello\n</code></pre>"},{"location":"bloque_i/tema_8/page-4/#getters-y-setters","title":"Getters y setters","text":"<p>Al igual que los objetos literales, las clases pueden incluir getters/setters, propiedades calculadas, etc.</p> <pre><code>class User {\nconstructor(name) {\nthis.name = name\n}\nget name() {\nreturn this._name\n}\nset name(value) {\nif (value.length &lt; 4) {\nconsole.log(\"Nombre demasiado corto.\")\nreturn\n}\nthis._name = value\n}\n}\nconst user = new User(\"John\")\nconsole.log(user.name) // John\nuser = new User(\"\"); // Nombre demasiado corto.\n</code></pre> <p>Adem\u00e1s, se puede crear un nombre de propiedad calculado haciendo uso de corchetes <code>[]</code>:</p> <pre><code>class User {\n['say' + 'Hi']() {\nconsole.log(\"Hello\")\n}\n}\nnew User().sayHi()\n</code></pre>"},{"location":"bloque_i/tema_8/page-4/#class-fields","title":"Class fields","text":"<p>Las campos de clases es una sintaxis que nos permite agregar una propiedad cualquiera.</p> <pre><code>class User {\nname = \"John\"\nsayHi() {\nconsole.log(`Hello, ${this.name}!`)\n}\n}\nnew User().sayHi() // Hello, John!\n</code></pre> <p>La diferencia importante de las propiedades definidas como campos de clase es que estas son establecidas en los objetos individuales, no compartidas en <code>User.prototype</code>.</p>"},{"location":"bloque_i/tema_8/page-4/#vinculacion-de-metodos-usando-campos-de-clase","title":"Vinculaci\u00f3n de m\u00e9todos usando campos de clase","text":"<p>Como se demostr\u00f3 en  Funci\u00f3n bind: vinculaci\u00f3n de funciones, las funciones en JavaScript tienen un <code>this</code> din\u00e1mico. Este depende del contexto del llamado.</p> <p>Entonces si un m\u00e9todo de objeto es pasado y llamado en otro contexto, this ya no ser\u00e1 una referencia a su objeto.</p> <pre><code>class Button {\nconstructor(value) {\nthis.value = value\n}\nclick() {\nalert(this.value)\n}\n}\nconst button = new Button(\"hello\")\nsetTimeout(button.click, 1000) // undefined\n</code></pre> <p>Hay dos enfoques para solucionarlo, como se discute en el cap\u00edtulo Funci\u00f3n bind: vinculaci\u00f3n de funciones:</p> <ol> <li>Pasar un contenedor o wrapper-function como: <code>setTimeout(() =&gt; button.click(), 1000)</code>.</li> <li> <p>Vincular el m\u00e9todo al objeto, por ejemplo en el constructor.</p> <pre><code>class Button {\nconstructor(value) {\nthis.value = value\n}\nclick = () =&gt; {\nconsole.log(this.value)\n}\n}\nlet button = new Button(\"hello\")\nsetTimeout(button.click, 1000) // hello\n</code></pre> </li> </ol> <p>Un campo de clase <code>click = () =&gt; {...}</code> es creado para cada objeto. Hay una funci\u00f3n para cada objeto <code>Button</code>, con <code>this</code> dentro referenciando ese objeto. Podemos pasar <code>button.click</code> a cualquier lado y el valor de this siempre ser\u00e1 el correcto.</p>"},{"location":"bloque_i/tema_8/page-5/","title":"5 Herencia de clases","text":""},{"location":"bloque_i/tema_8/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Al igual que los objetos pueden heredar propiedades y m\u00e9todos de otros otros objetos, las clases tambi\u00e9n pueden heredar de otras clases.</p> <p>Para que una clase herede de otra clase se debe usar la palabra reservada <code>extends</code> seguida de la clase a heredar:</p> <pre><code>class MyClass extends ParentClass{\n}\n</code></pre> <p>Veamos un ejemplo:</p> AnimalRabbit <pre><code>class Animal {\nconstructor(name) {\nthis.speed = 0\nthis.name = name\n}\nrun(speed) {\nthis.speed = speed\nconsole.log(`${this.name} corre a una velocidad de ${this.speed}.`)\n}\nstop() {\nthis.speed = 0\nconsole.log(`${this.name} se queda quieto.`)\n}\n}\nconst animal = new Animal(\"Mi animal\")\n</code></pre> <pre><code>class Rabbit extends Animal {\nhide() {\nconsole.log(`\u00a1${this.name} se esconde!`)\n}\n}\nlet rabbit = new Rabbit(\"Conejo Blanco\")\nrabbit.run(5) // Conejo Blanco corre a una velocidad de 5.\nrabbit.hide() // \u00a1Conejo Blanco se esconde!\n</code></pre> <p>Los objetos de la clase <code>Rabbit</code> tienen acceso a los m\u00e9todos de <code>Rabbit</code>, como <code>rabbit.hide()</code>, y tambi\u00e9n a los m\u00e9todos <code>Animal</code>, como <code>rabbit.run()</code>.</p> <p>Internamente, la palabra clave <code>extends</code> funciona con la buena mec\u00e1nica de prototipo,es decir, establece <code>Rabbit.prototype.[[Prototype]]</code> a <code>Animal.prototype</code>. Entonces, si no se encuentra un m\u00e9todo en <code>Rabbit.prototype</code>, JavaScript lo toma de <code>Animal.prototype</code>.</p> <p>Info</p> <p>La sintaxis de clase permite especificar no solo una clase, sino cualquier expresi\u00f3n despu\u00e9s de <code>extends</code>.</p> <p>Por ejemplo, una llamada a funci\u00f3n que genera la clase padre:</p> <pre><code>function f(phrase) {\nreturn class {\nsayHi() { console.log(phrase) }\n}\n}\nclass User extends f(\"Hola\") {}\nnew User().sayHi() // Hola\n</code></pre> <p>Observa que <code>class User</code> hereda del resultado de <code>f(\"Hola\")</code>.</p> <p>Eso puede ser \u00fatil para patrones de programaci\u00f3n avanzados cuando usamos funciones para generar clases dependiendo de muchas condiciones y podamos heredar de ellas.</p>"},{"location":"bloque_i/tema_8/page-5/#sobrescribir-un-metodo","title":"Sobrescribir un m\u00e9todo","text":"<p>Por defecto, todos los m\u00e9todos que no est\u00e1n especificados en la clase hija se toman directamente tal cual de la clase padre. Si especificamos el mismo m\u00e9todo que el m\u00e9todo padre, ser\u00e1 usado el m\u00e9todo del hijo, en lugar del m\u00e9todo padre. A esta operaci\u00f3n se le denomina sobrescribir de un m\u00e9todo:</p> <pre><code>class Rabbit extends Animal{\nstop(){\n// Se usar\u00e1 este m\u00e9todo\n// en lugar del m\u00e9todo de Animal\n}\n}\n</code></pre> <p>Sin embargo, no siempre queremos reemplazar totalmente un m\u00e9todo padre sino construir sobre \u00e9l, modificarlo o ampliar su funcionalidad. Hacemos algo con nuestro m\u00e9todo, pero queremos llamar al m\u00e9todo padre antes, despu\u00e9s o durante el proceso. A trav\u00e9s de la palabra clave <code>super</code> podemos acceder a los m\u00e9todos y propiedades definidos en el padre:</p> AnimalRabbit <pre><code>class Animal {\nconstructor(name) {\nthis.speed = 0\nthis.name = name\n}\nrun(speed) {\nthis.speed = speed\nconsole.log(`${this.name} corre a una velocidad de ${this.speed}.`)\n}\nstop() {\nthis.speed = 0\nconsole.log(`${this.name} se queda quieto.`)\n}\n}\n</code></pre> <pre><code>class Rabbit extends Animal {\nhide() {\nconsole.log(`\u00a1${this.name} se esconde!`)\n}\nstop() {\nsuper.stop() // llama el stop padre\nthis.hide() // y luego hide\n}\n}\nconst rabbit = new Rabbit(\"Conejo Blanco\");\nrabbit.run(5); // Conejo Blanco corre a una velocidad de 5.\nrabbit.stop(); // Conejo Blanco se queda quieto. \u00a1Conejo Blanco se esconde!\n</code></pre> <p>\u00a1OJO!</p> <p>Las funciones de flecha no tienen <code>super</code>.</p>"},{"location":"bloque_i/tema_8/page-5/#sobrescribir-un-constructor","title":"Sobrescribir un constructor","text":"<p>Como hemos visto hasta ahora, podemos sobrescribir cualquier m\u00e9todo de nuestro padre, incluso podemos a\u00f1adirle funcionalidad a trav\u00e9s del <code>super</code>. Sin embargo, sobrescribir el constructor es un poco m\u00e1s complejo.</p> <p>De acuerdo con la especificaci\u00f3n, si una clase extiende otra clase y no tiene constructor, se genera el siguiente constructor vac\u00edo:</p> <pre><code>class Rabbit extends Animal {\nconstructor(...args) {\nsuper(...args);\n}\n}\n</code></pre> <p>Como podemos ver, b\u00e1sicamente llama al <code>constructor</code> padre pas\u00e1ndole todos los argumentos. Esto sucede si no escribimos un constructor propio. Observa, que para llamar al constructor padre, hacemos uso de la sintaxis <code>super(...args)</code>.</p> <p>Los constructores en las clases heredadas que a\u00f1adan atributos de la clases deben llamar a <code>super(...),</code> y  hacerlo antes de usar <code>this</code>. Esto es debido a que, en JavaScript, hay una distinci\u00f3n entre una funci\u00f3n constructora de una clase heredera (llamada constructor derivado) y otras funciones. Un constructor derivado tiene una propiedad interna especial <code>[[ConstructorKind]]:\"derived\".</code> Esa es una etiqueta interna especial. Esa etiqueta afecta su comportamiento con <code>new</code>. Cuando una funci\u00f3n regular se ejecuta con <code>new</code>, crea un objeto vac\u00edo y lo asigna a <code>this</code>, pero cuando se ejecuta un constructor derivado, no hace esto. Espera que el constructor padre haga este trabajo.</p> <p>Entonces un constructor derivado debe llamar a <code>super</code> para ejecutar su constructor padre (base), de lo contrario no se crear\u00e1 el objeto para <code>this</code>. Y obtendremos un error.</p> <pre><code>class Animal {\nconstructor(name) {\nthis.speed = 0\nthis.name = name\n}\n// ...\n}\nclass Rabbit extends Animal {\nconstructor(name, earLength) {\nsuper(name)\nthis.earLength = earLength\n}\n// ...\n}\n// todo bien ahora\nconst rabbit = new Rabbit(\"Conejo Blanco\", 10)\nconsole.log(rabbit.name) // Conejo Blanco\nconsole.log(rabbit.earLength) // 10\n</code></pre>"},{"location":"bloque_i/tema_8/page-5/#sobrescribir-class-fields","title":"Sobrescribir class fields","text":"<p>Al igual que sobrescribimos m\u00e9todos, tambi\u00e9n puede sobrescribirse las propiedades o atributos de una clase. Sin embargo, hay un comportamiento peculiar cuando accedemos a los campos sobrescritos en el constructor padre, muy diferente a de la mayor\u00eda de los dem\u00e1s lenguajes de programaci\u00f3n. Veamos un ejemplo:</p> <pre><code>class Animal {\nname = 'animal'\nconstructor() {\nconsole.log(this.name)\n}\n}\nclass Rabbit extends Animal {\nname = 'rabbit'\n}\nnew Animal(); // animal\nnew Rabbit(); // animal\n</code></pre> <p>Aqu\u00ed, la clase <code>Rabbit</code> extiende <code>Animal</code> y sobrescribe el campo <code>name</code> con un valor propio. Rabbit no tiene su propio constructor, entonces es llamado el de Animal. Lo interesante es que en ambos casos: <code>new Animal()</code> y <code>new Rabbit()</code>,  muestra animal. En otras palabras, el constructor padre siempre usa el valor de su propio campo de clase, no el sobrescrito.</p> <p>Esto es debido al orden de inicializaci\u00f3n, si el campo es inicializado antes del constructor para la clase base o inmediatamente despu\u00e9s del <code>super()</code>.</p> <p>En nuestro caso, <code>Rabbit</code> es la clase derivada y no hay <code>constructor()</code> en ella. Como establecimos previamente, es lo mismo que si hubiera un constructor vac\u00edo con solamente <code>super(...args)</code>.</p> <p>Entonces, <code>new Rabbit()</code> llama a <code>super()</code> y se ejecuta el constructor padre, y (por la regla de la clase derivada) solamente despu\u00e9s de que sus campos de clase sean inicializados. En el momento de la ejecuci\u00f3n del constructor padre, todav\u00eda no existen los campos de clase de <code>Rabbit</code>, por ello los campos de Animal son los usados.</p> <p>Esta sutil diferencia entre campos y m\u00e9todos es particular de JavaScript Afortunadamente este comportamiento solo se revela si los campos sobrescritos son usados en el constructor padre.</p> <p>Si esto se vuelve un problema, uno puede corregirlo usando m\u00e9todos o getters/setters en lugar de campos.</p>"},{"location":"bloque_i/tema_8/page-5/#super-internamente","title":"Super internamente","text":"<p>Cuando se ejecuta un m\u00e9todo de objeto, obtiene el objeto actual como <code>this</code>. Si llamamos a <code>super.method()</code> entonces, el motor necesita obtener el <code>method</code> del prototipo del objeto actual. La tarea puede parecer simple, pero no lo es. El motor conoce el objeto actual <code>this</code>, por lo que podr\u00eda obtener el <code>method</code> padre como <code>this.__proto__.method</code>. Desafortunadamente, una soluci\u00f3n tan ingenua no funcionar\u00e1.</p> <p>En el siguiente ejemplo, se hace la asignaci\u00f3n <code>rabbit.__proto__ = animal</code>. Ahora, en <code>rabbit.eat()</code> llamaremos a <code>animal.eat()</code>, usando <code>this.__proto__</code>:</p> <pre><code>const animal = {\nname: \"Animal\",\neat() {\nconsole.log(`${this.name} come.`)\n}\n}\nconst rabbit = {\n__proto__: animal,\nname: \"Conejo\",\neat() {\n// as\u00ed es como supuestamente podr\u00eda funcionar super.eat()\nthis.__proto__.eat.call(this)\n}\n}\nrabbit.eat() // Conejo come.\n</code></pre> <p>En el ejemplo, tomamos <code>eat</code> del prototipo (animal) y lo llamamos en el contexto del objeto actual. Tenga en cuenta que <code>.call(this)</code> es importante aqu\u00ed, porque un simple <code>this.__proto__.eat()</code> ejecutar\u00eda al padre eat en el contexto del prototipo, no del objeto actual. Y en el c\u00f3digo anterior, funciona seg\u00fan lo previsto.</p> <p>Ahora agreguemos un objeto m\u00e1s a la cadena:</p> <pre><code>const animal = {\nname: \"Animal\",\neat() {\nconsole.log(`${this.name} come.`)\n}\n}\nconst rabbit = {\n__proto__: animal,\neat() {\n// ...rebota al estilo de conejo y llama al m\u00e9todo padre (animal)\nthis.__proto__.eat.call(this) }\n}\nconst longEar = {\n__proto__: rabbit,\neat() {\n// ...haz algo con orejas largas y llama al m\u00e9todo padre (rabbit)\nthis.__proto__.eat.call(this)\n}\n}\nlongEar.eat() // \u274c\n</code></pre> <p>\u00a1El c\u00f3digo ya no funciona! Podemos ver el error al intentar llamar a <code>longEar.eat()</code>. Puede que no sea tan obvio, pero si depuramos la llamada <code>longEar.eat()</code>, podremos ver por qu\u00e9. En ambas l\u00edneas donde se llama al m\u00e9todo <code>eat</code>, el valor de <code>this</code> es el objeto actual (<code>longEar</code>). Todos los m\u00e9todos de objeto obtienen el objeto actual como <code>this</code>, no un prototipo o algo as\u00ed. Entonces, en ambos casos el valor de <code>this.__proto__</code> es exactamente el mismo: <code>rabbit</code>. Ambos llaman a <code>rabbit.eat</code> sin subir la cadena en el bucle sin fin.</p> <p>El problema no se puede resolver usando solamente <code>this</code>.</p> <p>Para proporcionar la soluci\u00f3n, JavaScript agrega una propiedad interna especial para las funciones: <code>[[HomeObject]]</code>. Cuando una funci\u00f3n se especifica como un m\u00e9todo de clase u objeto, su propiedad <code>[[HomeObject]]</code> se convierte en ese objeto.</p> <p>Entonces super lo usa para resolver el problema del prototipo padre y sus m\u00e9todos. Veamos c\u00f3mo funciona:</p> <pre><code>const animal = {\nname: \"Animal\",\neat() {         // animal.eat.[[HomeObject]] == animal\nconsole.log(`${this.name} come.`)\n}\n}\nconst rabbit = {\n__proto__: animal,\nname: \"Conejo\",\neat() {         // rabbit.eat.[[HomeObject]] == rabbit\nsuper.eat()\n}\n}\nconst longEar = {\n__proto__: rabbit,\nname: \"Oreja Larga\",\neat() {         // longEar.eat.[[HomeObject]] == longEar\nsuper.eat()\n}\n}\nlongEar.eat()  // Oreja Larga come.\n</code></pre> <p>Funciona seg\u00fan lo previsto, debido a la mec\u00e1nica de <code>[[HomeObject]]</code>. Un m\u00e9todo, como <code>longEar.eat</code>, conoce su <code>[[HomeObject]]</code> y toma el m\u00e9todo padre de su prototipo, sin el uso de <code>this</code>.</p> <p>Generalmente las funciones son libres, es decir que no est\u00e1n vinculadas a objetos en JavaScript. Esto es para que puedan copiarse entre objetos y llamarse con otro <code>this</code>.</p> <p>La existencia misma de <code>[[HomeObject]]</code> viola ese principio, porque los m\u00e9todos recuerdan sus objetos. <code>[[HomeObject]]</code>no se puede cambiar, por lo que este v\u00ednculo es para siempre.</p> <p>El \u00fanico lugar en el lenguaje donde se usa <code>[[HomeObject]]</code> es en <code>super</code>. Si un m\u00e9todo no usa <code>super</code>, entonces todav\u00eda podemos considerarlo libre y copiarlo entre objetos. Pero con <code>super</code> las cosas pueden salir mal.</p> <p>Aqu\u00ed est\u00e1 la demostraci\u00f3n de un resultado incorrecto de <code>super</code> despu\u00e9s de copiarlo:</p> <pre><code>let animal = {\nsayHi() {\nconsole.log(`Soy un animal`)\n}\n}\n// rabbit hereda de animal\nlet rabbit = {\n__proto__: animal,\nsayHi() {\nsuper.sayHi()\n}\n}\nlet plant = {\nsayHi() {\nconsole.log(\"Soy una planta\")\n}\n}\n// tree hereda de plant\nlet tree = {\n__proto__: plant,\nsayHi: rabbit.sayHi\n}\ntree.sayHi()  // Soy un animal \n</code></pre> <p>Una llamada a <code>tree.sayHi()</code> muestra Soy un animal. En la llamada <code>rabbit.sayHi</code> del objeto <code>tree</code> el m\u00e9todo <code>tree.sayHi</code> se copi\u00f3 de <code>rabbit</code>, por lo que Su <code>[[HomeObject]]</code> es <code>rabbit</code>, ya que fue creado en <code>rabbit</code>. No hay forma de cambiar <code>[[HomeObject]]</code>. El c\u00f3digo de <code>tree.sayHi()</code> tiene dentro a <code>super.sayHi()</code>, que sube desde rabbit y toma el m\u00e9todo de animal.</p> <p><code>[[HomeObject]]</code> se define para m\u00e9todos tanto en clases como en objetos simples. Pero para los objetos, los m\u00e9todos deben especificarse exactamente como <code>method()</code>, no como <code>method: function()</code>. La diferencia puede no ser esencial para nosotros, pero es importante para JavaScript.</p> <p>En el siguiente ejemplo, se utiliza una sintaxis sin m\u00e9todo para la comparaci\u00f3n. La propiedad <code>[[HomeObject]]</code> no est\u00e1 establecida y la herencia no funciona:</p> <pre><code>const animal = {\neat: function() { // escrito as\u00ed intencionalmente en lugar de eat() {...\n// ...\n}\n}\nconst rabbit = {\n__proto__: animal,\neat: function() {\nsuper.eat()\n}\n}\nrabbit.eat() // \u274c\n</code></pre>"},{"location":"bloque_i/tema_8/page-6/","title":"6 Acceso a propiedades y m\u00e9todos","text":""},{"location":"bloque_i/tema_8/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Uno de los principios b\u00e1sicos de la programaci\u00f3n orientada a objetos es la delimitaci\u00f3n de algunas propiedades, para que no puedan ser accedidas fueras de la clase perteneciente.</p> <p>Supongamos, por ejemplo, una m\u00e1quina de caf\u00e9, tiene en su exterior: un bot\u00f3n, una pantalla, algunos agujeros, y da como resultado un buen caf\u00e9. Sin embargo, por dentro, est\u00e1 compuesta por muchos otros componentes que hacen una funci\u00f3n interna para preparar el caf\u00e9. No es necesario conocer su funcionamiento para poder usar la m\u00e1quina de caf\u00e9.</p> <p>En Javascript existen dos tipos de acceso para las propiedades y los m\u00e9todos:</p> <ul> <li>p\u00fablico: accesible desde cualquier lugar.</li> <li>privado: accesible solo desde dentro de la clase.</li> </ul> <p>Podemos decir que la parte interna de una m\u00e1quina de caf\u00e9 constituye su parte privada, y la parte externa constituye la parte p\u00fablica.</p> <p>En muchos otros lenguajes tambi\u00e9n existen campos protegidos accesibles solo desde dentro de la clase y aquellos que lo extienden (como privado, pero m\u00e1s acceso desde clases heredadas). En cierto sentido, est\u00e1n m\u00e1s extendidos que los privados, porque generalmente queremos que las clases heredadas tengan acceso a ellas.</p> <p>Los campos protegidos no se implementan en JavaScript a nivel de lenguaje, pero en la pr\u00e1ctica son muy convenientes, por lo que se emulan.</p>"},{"location":"bloque_i/tema_8/page-6/#campos-publicos","title":"Campos p\u00fablicos","text":"<p>Por defecto, todos los campos creados (sin indicar nada) son creados como p\u00fablicos, por lo que pueden ser accedidos y modificados desde cualquier otra parte del c\u00f3digo. Veamos un ejemplo:</p> <pre><code>class CoffeeMachine{\nwaterAmount = 0\nconstructor(power){\nthis.power = power\nconsole.log(`Se cre\u00f3 una m\u00e1quina de caf\u00e9, potencia: ${power}`)\n}\n}\nconst coffeeMachine = new CoffeeMachine(100)\ncoffeeMachine.waterAmount = 200\n</code></pre> <p>Como observamos en el ejemplo, el campo <code>waterAmount</code> y <code>power</code> son dos campos p\u00fablicos. Se pueden obtener y configurar desde cualquier otra parte.</p> <p>A partir de ES2022, se permite escribir la palabra <code>public</code> para declarar los campos de una clase:</p> <pre><code>class CoffeeMachine{\npublic waterAmount = 0\nconstructor(power){\nthis.power = power\nconsole.log(`Se cre\u00f3 una m\u00e1quina de caf\u00e9, potencia: ${power}`)\n}\n}\n</code></pre> <p>Incluso, podemos si un campo es pasado por el constructor y luego inicializado (como <code>power</code>), puede ser pasado por el constructor como <code>public fieldName</code>:</p> <pre><code>class CoffeeMachine{\npublic waterAmount = 0\nconstructor(public power){ // (1)!\nconsole.log(`Se cre\u00f3 una m\u00e1quina de caf\u00e9, potencia: ${power}`)\n}\n}\n</code></pre> <ol> <li>Similar a <code>this.power = power</code></li> </ol>"},{"location":"bloque_i/tema_8/page-6/#proteccion-de-campos","title":"Protecci\u00f3n de campos","text":"<p>Algunos campos se pueden proteger a trav\u00e9s de los m\u00e9todos <code>getter</code> y <code>setter</code>. De tal forma que, estos campos puedan ser modificados y comprobados como el creador de la clase disponga. Supongamos, en el ejemplo anterior, que la propiedad <code>waterAmount</code> no puede ser negativa. Por convencionalismos, a las variables protegidas, suelen precederles en el nombre un gui\u00f3n bajo <code>_</code>:</p> <pre><code>class CoffeeMachine {\n_waterAmount = 0\nset waterAmount(value) {\nif (value &lt; 0) {\nvalue = 0\n}\nthis._waterAmount = value\n}\nget waterAmount() {\nreturn this._waterAmount\n}\nconstructor(power) {\nthis._power = power\n}\n}\nlet coffeeMachine = new CoffeeMachine(100)\ncoffeeMachine.waterAmount = -10 // _waterAmount se vuelve 0, no -10\n</code></pre> <p>Sin embargo, est\u00e1 propiedad no est\u00e1 del todo protegida, ya que su acceso sigue siendo p\u00fablico, por lo que puede ser modificada desde fuera del c\u00f3digo:</p> <pre><code>coffeeMachine._waterAmount = - 10\n</code></pre> <p>Se puede crear una propiedad de solo lectura omitiendo el setter de la propiedad y definiendo solo el getter:</p> <pre><code>class CoffeeMachine {\n// ...\nconstructor(power) {\nthis._power = power\n}\nget power() {\nreturn this._power\n}\n}\nconst coffeeMachine = new CoffeeMachine(100)\nconsole.log(`La potencia es: ${coffeeMachine.power}W`) // Potencia es: 100W\ncoffeeMachine.power = 25 // \u274c\n</code></pre> <p>Normalmente, las funciones getters o setters se prefieren como m\u00e9todos y no como propiedades:</p> <pre><code>class CoffeeMachine {\n_waterAmount = 0\nsetWaterAmount(value) {\nif (value &lt; 0) {\nvalue = 0\n}\nthis._waterAmount = value\n}\ngetWaterAmount() {\nreturn this._waterAmount\n}\nconstructor(power) {\nthis._power = power\n}\n}\nlet coffeeMachine = new CoffeeMachine(100)\ncoffeeMachine.setWaterAmount(-10) // _waterAmount se vuelve 0, no -10\n</code></pre> <p>Eso parece un poco m\u00e1s largo, pero las funciones son m\u00e1s flexibles. Pueden aceptar m\u00faltiples argumentos (incluso si no los necesitamos en este momento). Por otro lado, la sintaxis get/set es m\u00e1s corta, por lo que, en \u00faltima instancia, no existe una regla estricta.</p>"},{"location":"bloque_i/tema_8/page-6/#privacidad","title":"Privacidad","text":"<p>Hasta ahora, tanto los campos p\u00fablicos o privados, pueden ser como m\u00ednimo accedidos fuera de nuestra clase (tambi\u00e9n podr\u00edan ser modificados si no son de solo lectura).</p> <p>Para impedir que una propiedad sea accedida desde fuera de nuestra clase, \u00e9sta deber\u00eda ser privada. Para indicar que una propiedad es privada, se debe usar la el asterisco <code>#</code> antes del nombre de la propiedad: <code>#fieldName</code>.</p> <pre><code>class CoffeeMachine {\n#waterLimit = 200\n#fixWaterAmount(value) {\nif (value &lt; 0) return 0\nif (value &gt; this.#waterLimit) return this.#waterLimit\n}\nsetWaterAmount(value) {\nthis.#waterLimit = this.#fixWaterAmount(value)\n}\n}\nconst coffeeMachine = new CoffeeMachine()\ncoffeeMachine.#fixWaterAmount(123) // \u274c\ncoffeeMachine.#waterLimit = 1000 // \u274c\n</code></pre> <p>Tambi\u00e9n puede ser indicada una propiedad privada con la palabra <code>private</code>, a partir del ES2022, incluso, al igual que <code>public</code>, puede ser indicada en el constructor:</p> <pre><code>class CoffeeMachine {\nprivate waterLimit = 200\nconstructor(private waterLimit){} // private field\nprivate fixWaterAmount(value) {\nif (value &lt; 0) return 0\nif (value &gt; this.waterLimit) return this.waterLimit\n}\npublic setWaterAmount(value) {\nthis.waterLimit = this.fixWaterAmount(value)\n}\n}\n</code></pre> <p>Una de las desventajas de los campos privados es que no pueden ser accedidos a trav\u00e9s de <code>this[name]</code>.</p> <p>Una vez visto esto, podemos crear campos p\u00fablicos, privados y protegidos de una forma sencilla y segura:</p> <pre><code>class CoffeeMachine {\nprivate _waterLimit = 200 // protected field\nconstructor(private power){} // private field\nprivate fixWaterAmount(value) {\nif (value &lt; 0) return 0\nif (value &gt; this._waterLimit) return this._waterLimit\n}\npublic setWaterAmount(value) { // public method\nthis._waterLimit = this.#fixWaterAmount(value)\n}\npublic getWaterAmount(){\nreturn this._waterLimit\n}\n}\n</code></pre>"},{"location":"bloque_i/tema_8/page-6/#propiedades-heredables","title":"Propiedades heredables","text":"<p>Las propiedades p\u00fablicas y las protegidas p\u00fablicas de una clase se heredan autom\u00e1ticamente en todos sus hijos, por lo que pueden acceder a ellas y modificarlas. Adem\u00e1s, pueden ser sobrescritas.</p> <p>Sin embargo, las propiedades privadas y las protegidas privadas de una clase no son heredadas por sus hijos, por lo que no pueden ni acceder a ellas, ni modificarlas, no sobrescribirlas.</p> <pre><code>class Person {\nprivate name // Propiedad privada\nconstructor(private name) {\n}\ngetName() {\nreturn this.nombre\n}\n}\nclass Student extends Person {\nconstructor(name, registration) {\nsuper(name)\nthis.registration = registration }\nshowInfo() {\nconsole.log(`Nombre: ${this.getName()}`) console.log(`Matr\u00edcula: ${this.matricula}`) }\n}\nconst student = new Student(\"Juan\", 12345)\nstudent.showInfo()\n</code></pre> <p>Warning</p> <p>En Javascript, a diferencia de otros lenguajes, no es posible impedir que un m\u00e9todo sea sobrescrito, por lo que hay que tener claro si un m\u00e9todo puede ser o no sobrescrito haci\u00e9ndolo privado.</p> <p>Tampoco es posible crear constructores privados. Aunque se puede obtener ciertas l\u00f3gicas para poder impedir la creaci\u00f3n de objetos a trav\u00e9s de constructores de la clase, y delegar la creaci\u00f3n a m\u00e9todos est\u00e1ticos.</p>"},{"location":"bloque_i/tema_8/page-6/#propiedades-y-metodos-estaticos","title":"Propiedades y m\u00e9todos est\u00e1ticos","text":"<p>Las propiedades y m\u00e9todos est\u00e1ticos en JavaScript son miembros de una clase que pertenecen a la clase en s\u00ed, no a las instancias individuales de la clase. Esto significa que se pueden acceder y utilizar sin crear una instancia de la clase.</p> <p>Para declarar una propiedad o un m\u00e9todo como est\u00e1tico, se debe usar la palabra reservada <code>static</code> antes del nombre.</p> <pre><code>class User {\nstatic staticMethod() {\nconsole.log(this === User)\n}\n}\n</code></pre> <p>Para usar un m\u00e9todo o propiedad est\u00e1tico se debe hacer la llamada desde la clase y no desde una instancia de \u00e9l:</p> <pre><code>User.staticMethod()\n</code></pre> <p>Tambi\u00e9n puede ser asignado como una propiedad de la clase:</p> <pre><code>class User {\nUser.staticMethod = function(){\nconsole.log(this === User)\n}\n}\n</code></pre> <p>Por lo general, los m\u00e9todos est\u00e1ticos se utilizan para implementar funciones que pertenecen a la clase como un todo, no a un objeto particular de la misma.</p> <p>Por ejemplo, tenemos objetos <code>Article</code> y necesitamos una funci\u00f3n para compararlos, una soluci\u00f3n natural ser\u00eda agregar el m\u00e9todo <code>Article.compare</code>.</p> <p>Tambi\u00e9n suelen ser usados como constructores de los objetos, haciendo uso del patr\u00f3n de factor\u00eda. Sin embargo, se suele recomendar intentar hacer inaccesible el constructor de la clase.</p> <p>Las propiedades y m\u00e9todos est\u00e1ticos son heredados.</p>"},{"location":"bloque_i/tema_8/page-7/","title":"7 Mixins","text":""},{"location":"bloque_i/tema_8/page-7/#mixins","title":"Mixins","text":"<p>En JavaScript podemos heredar de un solo objeto. Solo puede haber un <code>[[Prototype]]</code> para un objeto. Y una clase puede extender \u00fanicamente otra clase.</p> <p>Pero a veces eso se siente restrictivo. Por ejemplo, tenemos una clase <code>StreetSweeper</code> y una clase <code>Bicycle</code>, y queremos hacer su combinaci\u00f3n, un <code>StreetSweepingBicycle</code>, o tenemos una clase <code>User</code> y una clase <code>EventEmitter</code> que implementa la generaci\u00f3n de eventos, y nos gustar\u00eda agregar la funcionalidad de <code>EventEmitter</code> a <code>User</code>, para que nuestros usuarios puedan emitir eventos.</p> <p>Un mixin es una clase que contiene m\u00e9todos que pueden ser utilizados por otras clases sin necesidad de heredar de ella.</p> <p>En otras palabras, un mixin proporciona m\u00e9todos que implementan cierto comportamiento, pero su uso no es exclusivo, lo usamos para agregar el comportamiento a otras clases.</p> <p>La forma m\u00e1s sencilla de implementar un mixin en JavaScript es hacer un objeto con m\u00e9todos \u00fatiles, para que podamos combinarlos f\u00e1cilmente en un prototipo de cualquier clase.</p> <pre><code>const sayHiMixin = {\nsayHi() {\nconsole.log(`Hola ${this.name}`)\n},\nsayBye() {\nconsole.log(`Adi\u00f3s ${this.name}`)\n}\n}\nclass User {\nconstructor(name) {\nthis.name = name\n}\n}\n// copia los m\u00e9todos\nObject.assign(User.prototype, sayHiMixin)\nnew User(\"t\u00edo\").sayHi() // Hola t\u00edo!\n</code></pre> <p>No hay herencia, sino un simple m\u00e9todo de copia. Entonces, User puede heredar de otra clase y tambi\u00e9n incluir el mixin para \u201cmezclar\u201d los m\u00e9todos adicionales, como este:</p> <pre><code>class User extends Person {\n// ...\n}\nObject.assign(User.prototype, sayHiMixin)\n</code></pre> <p>Los mixins pueden hacer uso de la herencia dentro de s\u00ed mismos.</p> <pre><code>const sayMixin = {\nsay(phrase) {\nconsole.log(phrase)\n}\n}\nlet sayHiMixin = {\n__proto__: sayMixin,\nsayHi() {\n// llama al m\u00e9todo padre\nsuper.say(`Hola ${this.name}`) },\nsayBye() {\nsuper.say(`Adios ${this.name}`)\n}\n}\nclass User {\nconstructor(name) {\nthis.name = name\n}\n}\n// copia los m\u00e9todos\nObject.assign(User.prototype, sayHiMixin)\n// User ahora puede decir hola\nnew User(\"t\u00edo\").sayHi() // Hola t\u00edo!\n</code></pre> <p>Ten en cuenta que la llamada al m\u00e9todo padre <code>super.say()</code> de <code>sayHiMixin</code> busca el m\u00e9todo en el prototipo de ese mixin, no en la clase. Esto se debe a que los m\u00e9todos <code>sayHi</code> y <code>sayBye</code> se crearon inicialmente en <code>sayHiMixin</code>. Entonces, a pesar de que se copiaron, su propiedad interna <code>[[[HomeObject]]</code> hace referencia a sayHiMixin, como se muestra en la imagen de arriba. Como super busca los m\u00e9todos padres en <code>[[HomeObject]].[[Prototype]]</code>, esto significa que busca sayHiMixin.<code>[[Prototype]]</code>.</p> <p>Ahora hagamos un mixin para la vida real.</p> <p>Una caracter\u00edstica importante de muchos objetos del navegador (por ejemplo) es que pueden generar eventos. Los eventos son una excelente manera de transmitir informaci\u00f3n a cualquiera que lo desee. As\u00ed que hagamos un mixin que nos permita agregar f\u00e1cilmente funciones relacionadas con eventos a cualquier clase/objeto.</p> <ul> <li>El mixin proporcionar\u00e1 un m\u00e9todo <code>trigger(name, [...data])</code> para generar un evento cuando le ocurra algo importante. El argumento name es un nombre del evento, opcionalmente seguido de argumentos adicionales con datos del evento.</li> <li>Tambi\u00e9n el m\u00e9todo <code>on(name, handler)</code> que agrega la funci\u00f3n <code>handler</code> como listener a eventos con el nombre dado. Se llamar\u00e1 cuando se desencadene un evento con el nombre name dado, y obtenga los argumentos de la llamada <code>trigger</code>.</li> <li>Y el m\u00e9todo <code>off(name, handler)</code> que elimina el listener handler.</li> </ul> <p>Despu\u00e9s de agregar el mixin, un objeto user podr\u00e1 generar un evento login cuando el visitante inicie sesi\u00f3n. Y otro objeto, por ejemplo, calendar puede querer escuchar dichos eventos para cargar el calendario para el persona registrada.</p> <p>O bien, un menu puede generar el evento seleccionar cuando se selecciona un elemento del men\u00fa, y otros objetos pueden asignar controladores para reaccionar ante ese evento. Y as\u00ed. Veamos el c\u00f3digo:</p> <pre><code>const eventMixin = {\n/**\n   * Suscribe al evento, uso:\n   *  menu.on('select', function(item) { ... }\n  */\non(eventName, handler) {\nif (!this._eventHandlers) this._eventHandlers = {}\nif (!this._eventHandlers[eventName]) {\nthis._eventHandlers[eventName] = []\n}\nthis._eventHandlers[eventName].push(handler)\n},\n/**\n   * Cancelar la suscripci\u00f3n, uso:\n   *  menu.off('select', handler)\n   */\noff(eventName, handler) {\nlet handlers = this._eventHandlers?.[eventName]\nif (!handlers) return\nfor (let i = 0 i &lt; handlers.length i++) {\nif (handlers[i] === handler) {\nhandlers.splice(i--, 1)\n}\n}\n},\n/**\n   * Generar un evento con el nombre y los datos\n   *  this.trigger('select', data1, data2)\n   */\ntrigger(eventName, ...args) {\nif (!this._eventHandlers?.[eventName]) {\nreturn // no hay controladores para ese nombre de evento\n}\n// Llama al controlador\nthis._eventHandlers[eventName].forEach(handler =&gt; handler.apply(this, args))\n}\n}\n</code></pre> <ul> <li><code>on(eventName, handler)</code>: asigna la funci\u00f3n <code>handler</code> para que se ejecute cuando se produce el evento con ese nombre. T\u00e9cnicamente, hay una propiedad <code>_eventHandlers</code> que almacena una matriz de controladores para cada nombre de evento, y simplemente la agrega a la lista.</li> <li><code>off(eventName, handler)</code> \u2013 elimina la funci\u00f3n de la lista de controladores.</li> <li><code>trigger(eventName, ...args)</code> \u2013 genera el evento: se llama a todos los controladores de <code>_eventHandlers[eventName]</code>, con una lista de argumentos <code>...args</code>.</li> </ul> <p>Ahora veamos, su uso:</p> <pre><code>class Menu {\nchoose(value) {\nthis.trigger(\"select\", value)\n}\n}\n// Agrega el mixin con m\u00e9todos relacionados con eventos\nObject.assign(Menu.prototype, eventMixin);\nconst menu = new Menu()\n// agrega un controlador, que se llamar\u00e1 en la selecci\u00f3n:\nmenu.on(\"select\", value =&gt; console.log(`Valor seleccionado: ${value}`));\n// desencadena el evento =&gt; el controlador anterior se ejecuta y muestra:\n// Valor seleccionado: 123\nmenu.choose(\"123\")\n</code></pre> <p>Ahora, si queremos que el c\u00f3digo reaccione a una selecci\u00f3n de men\u00fa, podemos escucharlo con <code>menu.on(...)</code>. Y el mixin de <code>eventMixin</code> hace que sea f\u00e1cil agregar ese comportamiento a tantas clases como queramos, sin interferir con la cadena de herencia.</p> <p>Warning</p> <p>En otros lenguajes existe el concepto de interfaces, que se entiendo como una clase abstracta con m\u00e9todos no definidos que deben ser implementados por las clases. Este tipo de estructura fueron creadas para que una clase pudiese heredar de otra clase, pero a\u00fan as\u00ed implementas m\u00e9todos comunes. </p> <p>En Javascript este concepto no existe de forma nativa, aunque se pudiese simular como los objetos y su herencia, nos limitar\u00eda la posibilidad de heredar de una \u00fanica clase y no de otras, por lo que no ser\u00eda \u00fatil.</p> <p>Sin embargo, un tipo de implementaci\u00f3n v\u00e1lida ser\u00eda haciendo uso de Typescript.</p>"},{"location":"bloque_i/tema_8/page-7/#instanceof","title":"instanceof","text":"<p>El operador <code>instanceof</code> es un operador que me permite comprobar si un objeto pertenece a una clase o no. Su sintaxis es la siguiente: <code>obj instanceof Class</code></p>"},{"location":"bloque_i/tema_8/page-8/","title":"8 Manejo de errores","text":""},{"location":"bloque_i/tema_8/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos visto, en ciertas ocasiones hay m\u00e9todos o funciones que lanzan errores. Esto puedo ocurrir debido a nuestros descuidos, una entrada inesperada del usuario, una respuesta err\u00f3nea del servidor y por otras razones m\u00e1s.</p> <p>Por lo general, un script se detiene inmediatamente en caso de error, imprimi\u00e9ndolo en la consola.</p> <p>En Javascript, existe la estructura <code>try-catch</code> que permite el manejo de estos errores.</p>"},{"location":"bloque_i/tema_8/page-8/#try-catch","title":"Try catch","text":"<p>La construcci\u00f3n <code>try...catch</code>tiene dos bloques principales: <code>try</code>, y luego <code>catch</code>:</p> <pre><code>try{\n//... \n} catch(error){\n// ...\n}\n</code></pre> <p>En primer lugar, se ejecuta el c\u00f3digo del bloque <code>try</code>, si no hubo errores, se omite el bloque <code>catch</code>, se termina la ejecuci\u00f3n del bloque <code>try</code> y se sigue con la ejecuci\u00f3n del script. Sin embargo, si en alg\u00fan momento del bloque <code>try</code> que se encuentra alg\u00fan error, \u00e9ste es captura, de tal forma que se detiene la ejecuci\u00f3n del bloque <code>try</code> y se contin\u00faa con el bloque <code>catch</code>. El bloque <code>catch</code> recibe un variable <code>error</code> (se puede utilizar cualquier nombre) que contiene un objeto con detalles sobre el error. Posteriormente, continua con el script.</p> <p>Entonces, un error dentro del bloque try {...} no mata el script tenemos la oportunidad de manejarlo en catch.</p> <p>Veamos un ejemplo sin errores:</p> <pre><code>try{\nconsole.log('Inicio try')\nconsole.log('Fin try')\n} catch(error){\nconsole.log('Catch ignorado porque no da error')\n}\nconsole.log('Sigue el c\u00f3digo fuera del bloque try-catch')\n</code></pre> <p>Ahora, veamos un c\u00f3digo de error:</p> <pre><code>try{\nconsole.log('Inicio try')\nconsole.log(element) // \u274c\nconsole.log('Fin try (no alcanzado)')\n} catch(error){\nconsole.log('Ha ocurrido un error')\n}\nconsole.log('Sigue el c\u00f3digo fuera del bloque try-catch')\n</code></pre> <p>Warning</p> <p>Para que <code>try-catch</code> funcione, el c\u00f3digo debe ser ejecutable. En otras palabras, deber\u00eda ser JavaScript v\u00e1lido.</p> <p>No funcionar\u00e1 si el c\u00f3digo es sint\u00e1cticamente incorrecto, por ejemplo, si hay llaves sin cerrar:</p> <pre><code>try {\n{{{{{{{{{{{{\n} catch(err) {\nconsole.log(\"El motor no puede entender este c\u00f3digo, no es v\u00e1lido.\");\n}\n</code></pre> <p>El motor de JavaScript primero lee el c\u00f3digo y luego lo ejecuta. Los errores que ocurren en la fase de lectura se denominan errores de \u201ctiempo de an\u00e1lisis\u201d y son irrecuperables (desde dentro de ese c\u00f3digo). Eso es porque el motor no puede entender el c\u00f3digo.</p> <p>Entonces, <code>try-catch</code> solo puede manejar errores que ocurren en un c\u00f3digo v\u00e1lido. Dichos errores se denominan \u201cerrores de tiempo de ejecuci\u00f3n\u201d o, a veces, \u201cexcepciones\u201d.</p>"},{"location":"bloque_i/tema_8/page-8/#objeto-error","title":"Objeto Error","text":"<p>Cuando se produce un error, JavaScript genera un objeto que contiene los detalles al respecto. El objeto se pasa como argumento para <code>catch</code>. El error tiene dos propiedades principales:</p> <ul> <li><code>name</code>: Nombre del error, por ejemplo, <code>ReferenceError</code>.</li> <li><code>message</code>: Mensaje con informaci\u00f3n m\u00e1s detallada del error.</li> <li><code>stack</code>: Pila de llamadas actual: una cadena con informaci\u00f3n sobre la secuencia de llamadas anidadas que condujeron al error. Utilizado para fines de depuraci\u00f3n</li> </ul> <pre><code>try {\nlalala // error, la variable no est\u00e1 definida!\n} catch (err) {\nconsole.log(err.name) // ReferenceError\nconsole.log(err.message) // lalala no est\u00e1 definida!\nconsole.log(err.stack) // ReferenceError: lalala no est\u00e1 definida en (...call stack)\nconsole.log(err) // ReferenceError: lalala no est\u00e1 definido\n}\n</code></pre> <p>Si no se necesita utilizar el objeto error, \u00e9ste puede ser omitido en versiones recientes del lenguaje:</p> <pre><code>try{\n} catch{\n}\n</code></pre>"},{"location":"bloque_i/tema_8/page-8/#operador-throw","title":"Operador throw","text":"<p>El operador <code>throw</code> genera en nuestro c\u00f3digo un error. Su sintaxis es: <code>throw &lt;error obj&gt;</code>. T\u00e9cnicamente, podemos usar cualquier cosa como un objeto error. Eso puede ser incluso un primitivo, como un n\u00famero o una cadena, pero es mejor usar objetos, preferiblemente con propiedades <code>name</code> y <code>message</code> (para mantenerse algo compatible con los errores incorporados).</p> <p>JavaScript tiene muchos constructores integrados para manejar errores est\u00e1ndar: <code>Error</code>, <code>SyntaxError</code>, <code>ReferenceError</code>, <code>TypeError</code> y otros. Podemos usarlos para crear objetos de error tambi\u00e9n.</p> <pre><code>const json = '{ \"age\": 30 }' // dato incompleto\ntry {\nconst user = JSON.parse(json) // &lt;-- sin errores\nif (!user.name) {\nthrow new SyntaxError(\"dato incompleto: sin nombre\") // (*)\n}\nalert( user.name )\n} catch (err) {\nalert( \"Error en JSON: \" + err.message ) // Error en JSON: dato incompleto: sin nombre\n}\n</code></pre>"},{"location":"bloque_i/tema_8/page-8/#relanzando","title":"Relanzando","text":"<p>Catch solo debe procesar los errores que conoce y volver a lanzar (rethrow) a todos los dem\u00e1s. La t\u00e9cnica de rethrowing puede explicarse con m\u00e1s detalle:</p> <ol> <li>Catch captura todos lo errores.</li> <li>En el bloque <code>catch (err) {...}</code> analizamos el objeto error <code>err</code>.</li> <li>Si no sabemos c\u00f3mo manejarlo, lanzamos <code>throw err</code>.</li> </ol> <pre><code>const json = '{ \"age\": 30 }' // dato incompleto\ntry {\nconst user = JSON.parse(json)\nif (!user.name) {\nthrow new SyntaxError(\"dato incompleto: sin nombre\")\n}\nblabla() // error inesperado\nconsole.log(user.name)\n} catch (err) {\nif (err instanceof SyntaxError) {\nalert( \"Error en JSON: \" + err.message )\n} else {\nthrow err // rethrow (*)\n}\n}\n</code></pre> <p>El bloque catch en realidad maneja solo los errores con los que sabe c\u00f3mo lidiar y omite todos los dem\u00e1s.</p>"},{"location":"bloque_i/tema_8/page-8/#finally","title":"finally","text":"<p>Existe un estructura similar a <code>try-catch</code>, la estructura <code>try-catch-finally</code>, que a\u00f1ade el bloque <code>finally</code>. Este bloque ser\u00e1 ejecutado independientemente de si ha habido errores (se ejecuta el <code>catch</code>) o no (se termina la ejecuci\u00f3n del <code>try</code>). La cl\u00e1usula <code>finally</code> a menudo se usa cuando comenzamos a hacer algo y queremos finalizarlo en cualquier resultado.</p> <p>Por ejemplo, queremos medir el tiempo que tarda una funci\u00f3n de n\u00fameros de <code>Fibonacci fib(n)</code>. Naturalmente, podemos comenzar a medir antes de que se ejecute y terminar despu\u00e9s.  En particular, la implementaci\u00f3n de <code>fib(n)</code> en el c\u00f3digo siguiente devuelve un error para n\u00fameros negativos o no enteros. La cl\u00e1usula <code>finally</code> es un excelente lugar para terminar las mediciones, pase lo que pase.</p> <p>Aqu\u00ed <code>finally</code> garantiza que el tiempo se medir\u00e1 correctamente en ambas situaciones, en caso de una ejecuci\u00f3n exitosa de <code>fib</code> y en caso de error:</p> <pre><code>const num = +prompt(\"Ingrese un n\u00famero entero positivo?\", 35)\nconst diff, result\nfunction fib(n) {\nif (n &lt; 0 || Math.trunc(n) != n) {\nthrow new Error(\"Debe ser un n\u00famero positivo y entero.\")\n}\nreturn n &lt;= 1 ? n : fib(n - 1) + fib(n - 2)\n}\nlet start = Date.now()\ntry {\nresult = fib(num)\n} catch (err) {\nresult = 0\n} finally {\ndiff = Date.now() - start\n}\nconsole.log(result || \"error ocurrido\")\nconsole.log(`la ejecuci\u00f3n tom\u00f3 ${diff}ms`)\n</code></pre> <p>Warning</p> <p>La cl\u00e1usula <code>finally</code> funciona para cualquier salida de <code>try-catch</code>. Eso incluye un <code>return</code> expl\u00edcito.</p> <p>En el ejemplo a continuaci\u00f3n, hay un <code>return</code> en <code>try</code>. En este caso, <code>finally</code> se ejecuta justo antes de que el control regrese al c\u00f3digo externo.</p> <pre><code>function func() {\ntry {\nreturn 1\n} catch (err) {\n/*...*/\n} finally {\nconsole.log('finally')\n}\n}\nconsole.log(func()) // primero funciona console de \"finally\", y luego este\n</code></pre> <p>Info</p> <p>La construcci\u00f3n <code>try-finally</code>, sin la cl\u00e1usula <code>catch</code>, tambi\u00e9n es \u00fatil. Lo aplicamos cuando no queremos manejar los errores (se permite que se pierdan), pero queremos asegurarnos de que los procesos que comenzamos est\u00e9n finalizados.</p> <pre><code>function func() {\n// comenzar a hacer algo que necesita ser completado (como mediciones)\ntry {\n// ...\n} finally {\n// completar esto si todo muere\n}\n}\n</code></pre> <p>En el c\u00f3digo anterior, siempre se produce un error dentro de <code>try</code>, porque no hay <code>catch</code>. Pero <code>finally</code> funciona antes de que el flujo de ejecuci\u00f3n abandone la funci\u00f3n.</p>"},{"location":"bloque_i/tema_8/page-8/#captura-global","title":"Captura global","text":"<p>No hay ninguna en la especificaci\u00f3n para la captura global de errores, pero los entornos generalmente lo proporcionan, porque es realmente \u00fatil. Por ejemplo, Node.js tiene <code>process.on(\"uncaughtException\")</code> para eso. Y en el navegador podemos asignar una funci\u00f3n a la propiedad especial <code>window.onerror</code>, que se ejecutar\u00e1 en caso de un error no detectado.</p> <pre><code>window.onerror = function(message, url, line, col, error) {\n// ...\n};\n</code></pre> <p>Los par\u00e1metros recibidos son:</p> <ul> <li><code>message</code>. Mensaje del error.</li> <li><code>url</code>. URL del fichero que ha lanzado el error.</li> <li><code>line</code>. L\u00ednea del fichero que ha lanzado el error.</li> <li><code>col</code>. Columna de la l\u00ednea que ha lanzado el error.</li> <li><code>error</code>. Objeto error.</li> </ul> <pre><code>window.onerror = function(message, url, line, col, error) {\nconsole.log(`${message}\\n At ${line}:${col} of ${url}`)\n}\nfunction readData() {\nbadFunc() // \u00a1Vaya, algo sali\u00f3 mal!\n}\nreadData()\n</code></pre> <p>El rol del controlador global <code>window.onerror</code> generalmente no es recuperar la ejecuci\u00f3n del script, probablemente sea imposible en caso de errores de programaci\u00f3n, pero s\u00ed enviar el mensaje de error a los desarrolladores.</p> <p>Tambi\u00e9n hay servicios web que proporcionan registro de errores para tales casos, como https://errorception.com o https://www.muscula.com.</p> <p>Estos servicios funcionan as\u00ed:</p> <ul> <li>Nos registramos en el servicio y obtenemos un fragmento de JS (o la URL de un script) para insertar en las p\u00e1ginas.</li> <li>Ese script JS establece una funci\u00f3n personalizada <code>window.onerror</code>.</li> <li>Cuando se produce un error, se env\u00eda una solicitud de red al servicio.</li> <li>Podemos iniciar sesi\u00f3n en la interfaz web del servicio y ver los errores registrados.</li> </ul>"},{"location":"bloque_i/tema_8/page-8/#extendiendo-error","title":"Extendiendo error","text":"<p>Cuando desarrollamos alg\u00fan programa, a menudo necesitamos nuestras propias clases de error para reflejar cosas espec\u00edficas que pueden salir mal en nuestras tareas. Para errores en las operaciones de red, podemos necesitar <code>HttpError</code>, para las operaciones de la base de datos <code>DbError</code>, para las operaciones de b\u00fasqueda <code>NotFoundError</code>, etc.</p> <p>Nuestros errores deben admitir propiedades de error b\u00e1sicas como <code>message</code>, <code>name</code> y, preferiblemente, <code>stack</code>. Pero tambi\u00e9n pueden tener otras propiedades propias, por ejemplo, los objetos <code>HttpError</code> pueden tener una propiedad <code>statusCode</code> con un valor como 404 o 403 o 500.</p> <p>JavaScript permite usar <code>throw</code> con cualquier argumento, por lo que t\u00e9cnicamente nuestras clases de error personalizadas no necesitan heredarse de <code>Error</code>. Pero si heredamos, entonces es posible usar <code>obj instanceof Error</code> para identificar objetos error. Entonces es mejor heredar de \u00e9l.</p> <p>A medida que la aplicaci\u00f3n crece, nuestros propios errores forman naturalmente una jerarqu\u00eda. Por ejemplo, <code>HttpTimeoutError</code> puede heredar de <code>HttpError</code>, y as\u00ed sucesivamente.</p> <p>Como ejemplo, consideremos una funci\u00f3n <code>readUser(json)</code> que deber\u00eda leer JSON con los datos del usuario.</p> <p>Internamente, usaremos <code>JSON.parse</code>. Si recibe json mal formado, entonces arroja <code>SyntaxError</code>. Pero incluso si json es sint\u00e1cticamente correcto, eso no significa que sea un usuario v\u00e1lido. Puede perder los datos necesarios. Por ejemplo, puede no tener propiedades de nombre y edad que son esenciales para nuestros usuarios.</p> <p>Nuestra funci\u00f3n <code>readUser(json)</code> no solo leer\u00e1 JSON, sino que verificar\u00e1 (validar\u00e1) los datos. Si no hay campos obligatorios, o el formato es incorrecto, entonces es un error. Eso no es un <code>SyntaxError</code>, porque los datos son sint\u00e1cticamente correctos, sino otro tipo de error. Lo llamaremos <code>ValidationError</code> y crearemos una clase para ello. Un error de ese tipo tambi\u00e9n debe llevar la informaci\u00f3n sobre el campo infractor.</p> <p>Nuestra clase <code>ValidationError</code> deber\u00eda heredar de la clase incorporada <code>Error</code>.</p> <p>Esa clase est\u00e1 incorporada, pero aqu\u00ed est\u00e1 su c\u00f3digo aproximado para que podamos entender lo que estamos extendiendo:</p> <pre><code>class Error {\nconstructor(message) {\nthis.message = message\nthis.name = \"Error\"\nthis.stack = [call stack] }\n}\n</code></pre> <p>Ahora heredemos <code>ValidationError</code> y prob\u00e9moslo en acci\u00f3n:</p> <pre><code>class ValidationError extends Error {\nconstructor(message) {\nsuper(message) // (1)!\nthis.name = \"ValidationError\" // (2)!\n}\n}\nfunction test() {\nthrow new ValidationError(\"Vaya!\")\n}\ntry {\ntest()\n} catch(err) {\nconsole.log(err.message) // Vaya!\nconsole.log(err.name) // ValidationError\nconsole.log(err.stack) // una lista de llamadas anidadas con n\u00fameros de l\u00ednea para cada una\n}\n</code></pre> <ol> <li>Llamamos al constructor padre</li> <li>Sobrescribimos la propiedad <code>name</code>.</li> </ol> <p>Veamos su uso con la funci\u00f3n <code>readUser(user)</code>:</p> <pre><code>// Uso\nfunction readUser(json) {\nlet user = JSON.parse(json)\nif (!user.age) {\nthrow new ValidationError(\"Sin campo: age\")\n}\nif (!user.name) {\nthrow new ValidationError(\"Sin campo: name\")\n}\nreturn user\n}\n// Ejemplo de trabajo con try..catch\ntry {\nlet user = readUser('{ \"age\": 25 }')\n} catch (err) {\nif (err instanceof ValidationError) {\nconsole.log(\"Dato inv\u00e1lido: \" + err.message) // Dato inv\u00e1lido: sin campo: nombre\n} else if (err instanceof SyntaxError) { //\nconsole.log(\"Error de sintaxis JSON: \" + err.message)\n} else {\nthrow err // error desconocido, vuelva a lanzarlo\n}\n}\n</code></pre> <p>El bloque <code>try-catch</code> en el c\u00f3digo anterior maneja tanto nuestro <code>ValidationError</code> como el <code>SyntaxError</code> incorporado de <code>JSON.parse.</code></p> <p>La clase <code>ValidationError</code> es demasiado gen\u00e9rica. Son muchas las cosas que pueden salir mal. La propiedad podr\u00eda estar ausente, o puede estar en un formato incorrecto (como un valor de cadena para <code>age</code> en lugar de un n\u00famero). Hagamos una clase m\u00e1s concreta <code>PropertyRequiredError</code> espec\u00edficamente para propiedades ausentes. Esta clase llevar\u00e1 informaci\u00f3n adicional sobre la propiedad que falta.</p> <pre><code>class PropertyRequiredError extends ValidationError {\nconstructor(property) {\nsuper(\"Sin propiedad: \" + property)\nthis.name = \"PropertyRequiredError\"\nthis.property = property;\n}\n}\n</code></pre> <p>La nueva clase <code>PropertyRequiredError</code> es f\u00e1cil de usar, solo necesitamos pasar el nombre de la propiedad. El <code>message</code> legible para humanos es generado por el constructor.</p> <p>Tenga en cuenta que <code>this.name</code> en el constructor <code>PropertyRequiredError</code> se asigna de nuevo manualmente. Eso puede volverse un poco tedioso, asignar <code>this.name = &lt;class name&gt;</code> en cada clase de error personalizada. Podemos evitarlo haciendo nuestra propia clase error b\u00e1sico que asigna <code>this.name = this.constructor.name</code>. Y luego herede todos nuestros errores personalizados.</p> <pre><code>class MyError extends Error {\nconstructor(message) {\nsuper(message)\nthis.name = this.constructor.name\n}\n}\nclass ValidationError extends MyError { }\nclass PropertyRequiredError extends ValidationError {\nconstructor(property) {\nsuper(\"sin propiedad: \" + property)\nthis.property = property\n}\n}\n</code></pre> <p>Ahora los errores personalizados son mucho m\u00e1s cortos, especialmente <code>ValidationError</code>, ya que eliminamos la l\u00ednea <code>this.name = ...</code> en el constructor.</p>"},{"location":"bloque_i/tema_8/page-9/","title":"Ejercicios","text":"Ejercicio 1 <p>Muestra las salidas del siguiente c\u00f3digo:</p> <pre><code>const animal = {\njumps: null\n}\nconst rabbit = {\n__proto__: animal,\njumps: true\n}\nconsole.log( rabbit.jumps ) // ? (1)\ndelete rabbit.jumps\nconsole.log( rabbit.jumps ) // ? (2)\ndelete animal.jumps\nconsole.log( rabbit.jumps ) // ? (3)\n</code></pre> Ejercicio 2 <p>Tenemos dos hamsters: speedy y lazy heredando del objeto hamster general. Cuando alimentamos a uno de ellos, el otro tambi\u00e9n est\u00e1 lleno. \u00bfPor qu\u00e9? \u00bfC\u00f3mo podemos arreglarlo?</p> <pre><code>const hamster = {\nstomach: [],\neat(food) {\nthis.stomach.push(food)\n}\n}\nconst speedy = {\n__proto__: hamster\n}\nconst lazy = {\n__proto__: hamster\n}\n// Este encontr\u00f3 la comida\nspeedy.eat(\"manzana\")\nconsole.log( speedy.stomach ) // manzana\n// Este tambi\u00e9n lo tiene, \u00bfpor qu\u00e9? arreglar por favor.\nconsole.log( lazy.stomach ) // manzana\n</code></pre> Ejercicio 3 <p>Crea una clase estudiante, con las propiedades pertinentes y ponla a prueba.</p> Ejercicio 4 <p>Aqu\u00ed est\u00e1 el c\u00f3digo de la clase Rabbit que extiende a Animal.</p> <p>Desafortunadamente, los objetos Rabbit no se pueden crear. \u00bfQue pasa? Arr\u00e9glalo.</p> <pre><code>class Animal {\nconstructor(name) {\nthis.name = name\n}\n}\nclass Rabbit extends Animal {\nconstructor(name) {\nthis.name = name\nthis.created = Date.now()\n}\n}\nconst rabbit = new Rabbit(\"Conejo Blanco\") // \u274c\nconsole.log(rabbit.name)\n</code></pre> Ejercicio 5 <p>Dise\u00f1a una clase Cafetera que modele una cafetera real. La cafetera tendr\u00e1 las siguientes caracter\u00edsticas:</p> <p>Propiedades privadas:</p> <ul> <li><code>capacidadMaximaAgua</code>: La cantidad m\u00e1xima de agua que la cafetera puede contener (en mililitros).</li> <li><code>cantidadAguaActual</code>: La cantidad actual de agua en la cafetera (en mililitros).</li> <li><code>cantidadCafeMolido</code>: La cantidad de caf\u00e9 molido agregado a la cafetera (en gramos).</li> <li><code>estadoCafetera</code>: Un valor que indica el estado actual de la cafetera (\"apagada\", \"preparando\", \"encendida\").</li> </ul> <p>Propiedades p\u00fablicas:</p> <ul> <li><code>capacidadMaximaCafe</code>: La cantidad m\u00e1xima de caf\u00e9 molido que la cafetera puede contener (en gramos).</li> </ul> <p>M\u00e9todos p\u00fablicos:</p> <ul> <li><code>agregarAgua(cantidadAgua)</code>: Agrega la cantidad especificada de agua a la cafetera.</li> <li><code>agregarCafeMolido(cantidadCafe)</code>: Agrega la cantidad especificada de caf\u00e9 molido a la cafetera.</li> <li><code>prepararCafe()</code>: Inicia el proceso de preparaci\u00f3n del caf\u00e9. Este m\u00e9todo debe verificar si hay suficiente agua y caf\u00e9 molido, y si la cafetera est\u00e1 apagada. Si las condiciones son correctas, cambia el estado a \"preparando\" y simula el tiempo de preparaci\u00f3n (por ejemplo, 3 segundos). Luego, cambia el estado a \"encendida\".</li> <li><code>servirCafe(cantidad)</code>: Sirve la cantidad especificada de caf\u00e9 (en mililitros). Este m\u00e9todo debe verificar si hay suficiente caf\u00e9 preparado y si la cafetera est\u00e1 encendida. Si las condiciones son correctas, reduce la cantidad de caf\u00e9 preparado y simula el tiempo de servido (por ejemplo, 1 segundo).</li> <li><code>apagarCafetera()</code>: Apaga la cafetera y reinicia el estado a \"apagada\".</li> <li><code>vaciarCafetera()</code>: Vac\u00eda el agua y el caf\u00e9 molido de la cafetera.</li> <li><code>obtenerEstado()</code>: Devuelve el estado actual de la cafetera.</li> <li><code>obtenerCantidadAguaActual()</code>: Devuelve la cantidad actual de agua en la cafetera.</li> <li><code>obtenerCantidadCafePreparado()</code>: Devuelve la cantidad de caf\u00e9 preparado que queda en la cafetera.</li> </ul> <p>Restricciones:</p> <ul> <li>No se puede agregar m\u00e1s agua que la capacidad m\u00e1xima.</li> <li>No se puede agregar m\u00e1s caf\u00e9 molido que la capacidad m\u00e1xima.</li> <li>No se puede preparar caf\u00e9 si no hay suficiente agua o caf\u00e9 molido.</li> <li>No se puede servir caf\u00e9 si no hay caf\u00e9 preparado o si la cafetera est\u00e1 apagada.</li> <li>No se puede vaciar la cafetera si est\u00e1 preparando caf\u00e9.</li> </ul> <p>Instrucciones:</p> <ol> <li>Crea una clase Cafetera utilizando las propiedades y m\u00e9todos descritos anteriormente.</li> <li>Implementa la l\u00f3gica de cada m\u00e9todo para que cumpla con las restricciones especificadas.</li> <li>Crea una instancia de Cafetera y prueba los diferentes m\u00e9todos para asegurarte de que funciona correctamente.</li> <li>Agrega comentarios a tu c\u00f3digo para explicar el funcionamiento de cada m\u00e9todo y propiedad.</li> </ol> <p>Ejemplo de uso:</p> <pre><code>const cafetera = new Cafetera(1000, 50)\ncafetera.agregarAgua(500)\ncafetera.agregarCafeMolido(30)\nconsole.log(`Estado actual: ${cafetera.obtenerEstado()}`) // Imprime: apagada\ncafetera.prepararCafe()\nconsole.log(`Estado actual: ${cafetera.obtenerEstado()}`) // Imprime: preparando\ncafetera.servirCafe(200)\nconsole.log(`Cantidad de caf\u00e9 preparado restante: ${cafetera.obtenerCantidadCafePreparado()}`) // Imprime: 30\ncafetera.apagarCafetera()\nconsole.log(`Estado actual: ${cafetera.obtenerEstado()}`) // Imprime: apagada\n</code></pre> <p>Se podr\u00e1n crear m\u00e9todos adicionales para hacer el c\u00f3digo m\u00e1s legible, pero estos deber\u00e1n ser privados.</p> Ejercicio 6 <p>Crea una nueva versi\u00f3n de la clase anterior, pero impidiendo poder usar el constructor fuera de la clase original. Adem\u00e1s, deber\u00e1s crear un m\u00e9todo est\u00e1tico que se encargue de la creaci\u00f3n de los objetos de la clase.</p> Ejercicio 7 <p>\u00bfPorqu\u00e9 el siguiente c\u00f3digo devuelve <code>true</code>?</p> <pre><code>function A() {}\nfunction B() {}\nA.prototype = B.prototype = {}\nconst a = new A()\nconsole.log(a instanceof B) // true\n</code></pre> Ejercicio 8 <p>Crea un m\u00e9todo que te permita realizar la ra\u00edz cuadrada de un n\u00famero positivo. Si el usuario introduce algo que no es un n\u00famero deber\u00e1 lanzar un <code>NumberFormatError</code>, y si introduce un n\u00famero negativo, lanzar\u00e1 un <code>NegativeNumberError</code>. Crea ambas clases de errores</p>"},{"location":"bloque_i/tema_9/page-1/","title":"1 Generadores","text":""},{"location":"bloque_i/tema_9/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Las funciones vista hasta ahora pod\u00edan devolver un \u00fanico valor, o por el contrario no devolver nada.</p> <p>Los generadores son funciones que pueden producir m\u00faltiples valores, uno tras otro, a pedido. Suelen funcionar bien con los iterables, permitiendo crear flujos de datos con facilidad.</p>"},{"location":"bloque_i/tema_9/page-1/#funciones-generadoras","title":"Funciones generadoras","text":"<p>Para definir una funci\u00f3n generadora, es necesario una sintaxis especial: <code>function*</code>. Veamos un ejemplo:</p> <pre><code>function* generateSequence(){\nyield 1\nyield 2\nreturn 3\n}\n</code></pre> <p>Las funciones generadoras se comportan de manera diferente a las normales. Cuando se llama a dicha funci\u00f3n, no ejecuta su c\u00f3digo. En su lugar, devuelve un objeto especial, llamado objeto generador, para gestionar la ejecuci\u00f3n.</p> <p>El m\u00e9todo principal de un generador es <code>next()</code>. Cuando se llama, se ejecuta hasta la declaraci\u00f3n <code>yield &lt;value&gt;</code> m\u00e1s cercana (se puede omitir value, entonces ser\u00e1 <code>undefined</code>). Luego, la ejecuci\u00f3n de la funci\u00f3n se detiene y el value obtenido se devuelve al c\u00f3digo externo.</p> <p>El resultado de <code>next()</code> es siempre un objeto con dos propiedades:</p> <ul> <li><code>value</code>: el valor de <code>yield</code>.</li> <li><code>done</code>: <code>true</code> si la ejecuci\u00f3n ha terminado, o de lo contrario <code>false</code>.</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>function* generateSequence(){\nyield 1\nyield 2\nreturn 3\n}\nconst generator = generateSequence()\nconst one = generator.next()\nconsole.log(JSON.stringify(one)) // {value: 1, done: false}\n</code></pre> <p>Si volvemos a llamar al m\u00e9todo <code>next()</code> reanuda la ejecuci\u00f3n del c\u00f3digo, devolviendo el siguiente <code>yield</code>. Una vez que llega a la sentencia <code>return</code> da por finalizada la generaci\u00f3n, por lo que el valor devuelto es el objeto con la propiedad <code>done</code> a <code>true</code>. Si se intenta llamar a la funci\u00f3n <code>next()</code>, despu\u00e9s de la \u00faltima llamada posible devolver\u00e1 el siguiente objeto: <code>{done: true}</code>.</p> <p>Las funciones generadoras son iterables, por lo que puede ser usados en el bucle <code>for..of</code>, donde se llama internamente a su m\u00e9todo <code>next()</code>:</p> <pre><code>function* generateSequence(){\nyield 1\nyield 2\nreturn 3\n}\nconst generator = generateSequence()\nfor(const value of generator){\nconsole.log(value)\n}\n</code></pre> <p>El ejemplo anterior muestra 1, luego 2, y no llega a mostrar el 3. Esto es debido a que la iteraci\u00f3n <code>for..of</code> ignora el \u00faltimo <code>value</code>, cuando <code>done: true</code>. Entonces, si queremos que todos los resultados se muestren con <code>for..of</code>, debemos devolverlos con <code>yield</code>.</p> <p>Al ser iteradores, tambi\u00e9n pueden ser usadas junto con el spread operator:</p> <pre><code>function* generateSequence() {\nyield 1\nyield 2\nyield 3\n}\nconst sequence = [0, ...generateSequence()]\nconsole.log(sequence) // 0, 1, 2, 3\n</code></pre>"},{"location":"bloque_i/tema_9/page-1/#generadores-en-iterables","title":"Generadores en iterables","text":"<p>Anteriormente creamos un iterador <code>range</code>, como el siguiente:</p> <pre><code>const range = {\nfrom: 1,\nto: 5,\n[Symbol.iterator]() {\nreturn {\ncurrent: this.from,\nlast: this.to,\nnext() {\nif (this.current &lt;= this.last) {\nreturn { done: false, value: this.current++ }\n} else {\nreturn { done: true }\n}\n}\n}\n}\n}\nconsole.log([...range]) // 1,2,3,4,5\n</code></pre> <p>Podemos utilizar una funci\u00f3n generadora para la iteraci\u00f3n, proporcion\u00e1ndole como valor de <code>Symbol.iterator</code>.</p> <pre><code>const range = {\nfrom: 1,\nto: 5,\n*[Symbol.iterator](){ // (1)!\nfor(let value = this.from; value &lt;= this.to; value++){\nyield value\n}\n}\n}\nconsole.log([...range]) // 1,2,3,4,5\n</code></pre> <ol> <li>Equivalente a <code>[Symbol.iterator]: function*()</code></li> </ol> <p>Los generadores se agregaron al lenguaje JavaScript con los iteradores en mente, para implementarlos f\u00e1cilmente. La variante con un generador es mucho m\u00e1s concisa que el c\u00f3digo iterable original de <code>range</code> y mantiene la misma funcionalidad.</p> <p>Warning</p> <p>En los ejemplos anteriores, generamos secuencias finitas, pero tambi\u00e9n podemos hacer un generador que produzca valores para siempre. Por ejemplo, una secuencia interminable de n\u00fameros pseudoaleatorios.</p> <p>Eso seguramente requerir\u00eda un <code>break</code> (o <code>return</code>) en <code>for..of</code> sobre dicho generador. De lo contrario, el bucle se repetir\u00eda para siempre y se colgar\u00eda.</p>"},{"location":"bloque_i/tema_9/page-1/#composicion-del-generador","title":"Composici\u00f3n del generador","text":"<p>La composici\u00f3n del generador es una caracter\u00edstica especial de los generadores que permite incrustar generadores entre s\u00ed de forma transparente. Por ejemplo, tenemos una funci\u00f3n que genera una secuencia de n\u00fameros:</p> <pre><code>function* generateSequence(start, end) {\nfor (let i = start; i &lt;= end; i++) yield i\n}\n</code></pre> <p>Ahora nos gustar\u00eda reutilizarlo para generar una secuencia m\u00e1s compleja:</p> <ul> <li>primero, d\u00edgitos 0..9 (con c\u00f3digos de caracteres 48\u202657),</li> <li>seguido de letras may\u00fasculas del alfabeto A..Z (c\u00f3digos de caracteres 65\u202690)</li> <li>seguido de letras del alfabeto en min\u00fascula a..z (c\u00f3digos de car\u00e1cter 97\u2026122)</li> </ul> <p>Podemos usar esta secuencia, por ejemplo para crear contrase\u00f1as seleccionando caracteres de \u00e9l (tambi\u00e9n podr\u00eda agregar caracteres de sintaxis), pero vamos a generarlo primero.</p> <p>En una funci\u00f3n regular, para combinar los resultados de muchas otras funciones, las llamamos, almacenamos los resultados y luego nos unimos al final. Para los generadores, hay una sintaxis especial <code>yield*</code> para incrustar (componer) un generador en otro.</p> <pre><code>function* generateSequence(start, end) {\nfor (let i = start; i &lt;= end; i++) yield i\n}\nfunction* generatePasswordCodes() {\n// 0..9\nyield* generateSequence(48, 57)\n// A..Z\nyield* generateSequence(65, 90)\n// a..z\nyield* generateSequence(97, 122)\n}\nlet str = ''\nfor(let code of generatePasswordCodes()) {\nstr += String.fromCharCode(code)\n}\nconsole.log(str) // 0..9A..Za..z\n</code></pre> <p>La directiva <code>yield*</code> delega la ejecuci\u00f3n a otro generador. Este t\u00e9rmino significa que <code>yield*</code> gen itera sobre el generador gen y reenv\u00eda de forma transparente sus yields al exterior. Como si los valores fueran proporcionados por el generador externo.</p> <p>El resultado es el mismo que si insertamos el c\u00f3digo de los generadores anidados:</p> <pre><code>function* generateSequence(start, end) {\nfor (let i = start; i &lt;= end; i++) yield i\n}\nfunction* generatePasswordCodes() {\n// yield* generateSequence(48, 57)\nfor (let i = 48; i &lt;= 57; i++) yield i\n// yield* generateSequence(65, 90)\nfor (let i = 65; i &lt;= 90; i++) yield i\n// yield* generateSequence(97, 122)\nfor (let i = 97; i &lt;= 122; i++) yield i\n}\nlet str = ''\nfor(let code of generatePasswordCodes()) {\nstr += String.fromCharCode(code)\n}\nconsole.log(str) // 0..9A..Za..z\n</code></pre> <p>La composici\u00f3n de un generador es una forma natural de insertar un flujo de un generador en otro. No usa memoria adicional para almacenar resultados intermedios.</p>"},{"location":"bloque_i/tema_9/page-1/#sentencia-yield","title":"Sentencia yield","text":"<p>Hasta este momento, los generadores eran similares a los objetos iterables, con una sintaxis especial para generar valores. Pero de hecho son mucho m\u00e1s potentes y flexibles.</p> <p>Eso es porque <code>yield</code> es una calle de doble sentido: no solo devuelve el resultado al exterior, sino que tambi\u00e9n puede pasar el valor dentro del generador.</p> <p>Para hacerlo, deber\u00edamos llamar a <code>generator.next (arg)</code>, con un argumento. Ese argumento se convierte en el resultado de <code>yield</code>. Veamos un ejemplo:</p> <pre><code>function* gen() {\nlet result = yield \"2 + 2 = ?\"\nconsole.log(result)\n}\nconst generator = gen()\nconst question = generator.next().value // &lt;-- yield devuelve el valor\ngenerator.next(4); // --&gt; pasar el resultado al generador\n</code></pre> <p>La primera llamada a <code>generator.next()</code> debe hacerse siempre sin un argumento (el argumento se ignora si se pasa). Inicia la ejecuci\u00f3n y devuelve el resultado del primer yield <code>2 + 2 = ?</code>. En este punto, el generador detiene la ejecuci\u00f3n, mientras permanece en dicha l\u00ednea.</p> <p>Luego, como se muestra en la imagen de arriba, el resultado de yield entra en la variable question en el c\u00f3digo de llamada. En <code>generator.next(4)</code>, el generador se reanuda y <code>4</code> entra como resultado: <code>let result = 4</code>.</p> <p>Tenga en cuenta que el c\u00f3digo externo no tiene que llamar inmediatamente a <code>next(4)</code>. Puede que lleve alg\u00fan tiempo. Eso no es un problema ya que el generador esperar\u00e1.</p> <p>Como podemos ver, a diferencia de las funciones regulares, un generador y el c\u00f3digo de llamada pueden intercambiar resultados pasando valores en <code>next/yield</code>.</p> <p>Para hacer las cosas m\u00e1s obvias, aqu\u00ed hay otro ejemplo, con m\u00e1s llamadas:</p> <pre><code>function* gen() {\nlet ask1 = yield \"2 + 2 = ?\"\nconsole.log(ask1) // 4\nlet ask2 = yield \"3 * 3 = ?\"\nconsole.log(ask2) // 9\n}\nlet generator = gen()\nconsole.log(generator.next().value) // \"2 + 2 = ?\"\nconsole.log(generator.next(4).value) // \"3 * 3 = ?\"\nconsole.log(generator.next(9).done) // true\n</code></pre> <p>Veamos su funcionamiento:</p> <ol> <li>El primer <code>.next()</code> inicia la ejecuci\u00f3n y llega al primer <code>yield</code>.</li> <li>El resultado se devuelve al c\u00f3digo externo.</li> <li>El segundo <code>.next(4)</code> pasa 4 de nuevo al generador como resultado del primer <code>yield</code> y reanuda la ejecuci\u00f3n.</li> <li>Alcanza el segundo <code>yield</code>, que se convierte en el resultado de la llamada del generador.</li> <li>El tercer <code>next(9)</code> pasa 9 al generador como resultado del segundo <code>yield</code> y reanuda la ejecuci\u00f3n que llega al final de la funci\u00f3n, as\u00ed que <code>done: true</code>.</li> </ol> <p>Es como un juego de \u201cping-pong\u201d. Cada <code>next(value)</code> (excluyendo el primero) pasa un valor al generador, que se convierte en el resultado del <code>yield</code> actual, y luego recupera el resultado del siguiente <code>yield</code>.</p>"},{"location":"bloque_i/tema_9/page-1/#generatorthrow","title":"generator.throw","text":"<p>Como observamos en los ejemplos anteriores, el c\u00f3digo externo puede pasar un valor al generador, como resultado de <code>yield</code>, pero tambi\u00e9n puede iniciar (lanzar) un error all\u00ed. Eso es natural, ya que un error es una especie de resultado.</p> <p>Para pasar un error a un <code>yield</code>, deber\u00edamos llamar a <code>generator.throw(err)</code>. En ese caso, el <code>err</code> se coloca en la l\u00ednea con ese <code>yield</code>.</p> <pre><code>function* gen() {\ntry {\nlet result = yield \"2 + 2 = ?\"\nconsole.log(\"La ejecuci\u00f3n no llega aqu\u00ed, porque la excepci\u00f3n se lanza arriba\");\n} catch(e) {\nconsole.log(e)\n}\n}\nlet generator = gen()\nlet question = generator.next().value\ngenerator.throw(new Error(\"The answer is not found in my database\"))\n</code></pre> <p>El error, arrojado al generador conduce a una excepci\u00f3n en la l\u00ednea con <code>yield</code>. En el ejemplo anterior, <code>try..catch</code> lo captura y lo muestra.</p> <p>Si no lo detectamos, al igual que cualquier excepci\u00f3n, cae del generador en el c\u00f3digo de llamada. Podemos atraparlo al lanzar el error:</p> <pre><code>function* generate() {\nlet result = yield \"2 + 2 = ?\"\n}\nlet generator = generate()\nlet question = generator.next().value\ntry {\ngenerator.throw(new Error(\"La respuesta no se encuentra en mi base de datos\"));\n} catch(e) {\nconsole.log(e)\n}\n</code></pre>"},{"location":"bloque_i/tema_9/page-1/#generatorreturn","title":"generator.return","text":"<p><code>generator.return(value)</code> detiene la ejecuci\u00f3n de generator y devuelve el valor <code>value</code> dado.</p> <pre><code>function* gen() {\nyield 1\nyield 2\nyield 3\n}\nconst g = gen()\ng.next()        // { value: 1, done: false }\ng.return('foo') // { value: \"foo\", done: true }\ng.next()        // { value: undefined, done: true }\n</code></pre> <p>Si volvemos a usar <code>generator.return()</code> en un generator finalizado, devolver\u00e1 ese valor nuevamente.No se usa a menudo, ya que la mayor parte del tiempo queremos todos los valores, pero puede ser \u00fatil cuando queremos detener el generador en una condici\u00f3n espec\u00edfica.</p>"},{"location":"bloque_i/tema_9/page-2/","title":"2 Programaci\u00f3n As\u00edncrona","text":""},{"location":"bloque_i/tema_9/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>La programaci\u00f3n as\u00edncrona es un paradigma de programaci\u00f3n en el que las operaciones, como la lectura/escritura de archivos o la solicitud de datos a un servidor, se ejecutan de manera no bloqueante, es decir, no detienen la ejecuci\u00f3n del programa mientras esperan que se completen. En lugar de bloquear el hilo de ejecuci\u00f3n hasta que se termine la operaci\u00f3n, la programaci\u00f3n as\u00edncrona permite que el programa contin\u00fae ejecutando otras tareas.</p> <p>Las operaciones no bloquean el hilo principal del programa. Esto es especialmente \u00fatil para mejorar la eficiencia y la capacidad de respuesta en aplicaciones que manejan m\u00faltiples operaciones de entrada/salida.</p> <p>Permite que las aplicaciones manejen m\u00e1s tareas concurrentemente, especialmente aquellas que dependen de operaciones de entrada/salida y mejora la capacidad de respuesta de las aplicaciones, como las interfaces de usuario, ya que no se bloquean esperando que se completen las operaciones.</p> <p>Sin embargo, puede ser m\u00e1s dif\u00edcil de entender y depurar debido a la naturaleza no lineal del flujo de control y los errores pueden ser m\u00e1s dif\u00edciles de manejar, especialmente cuando se encadenan m\u00faltiples operaciones as\u00edncronas.</p>"},{"location":"bloque_i/tema_9/page-2/#callbacks-en-asincronia","title":"Callbacks en asincron\u00eda","text":"<p>Muchas funciones son proporcionadas por el entorno de Javascript que permiten programar acciones as\u00edncronas. Por ejemplo, una de esas funciones es la funci\u00f3n <code>setTimeout</code>. Hay otros ejemplos del mundo real de acciones as\u00edncronas, por ejemplo la carga de scripts y m\u00f3dulos.</p> <pre><code>function loadScript(src) {\nlet script = document.createElement('script')\nscript.src = src\ndocument.head.append(script)\n}\n</code></pre> <p>El m\u00e9todo <code>loadScript(src)</code> inserta en el documento una etiqueta nueva, creada din\u00e1micamente, <code>&lt;script src =\"...\"&gt;</code> con el c\u00f3digo <code>src</code> dado. El navegador comienza a cargarlo autom\u00e1ticamente y lo ejecuta cuando la carga se completa. El script se ejecuta as\u00edncronamente, ya que comienza a cargarse ahora, pero se ejecuta m\u00e1s tarde, cuando la funci\u00f3n ya ha finalizado.</p> <p>Supongamos, que es necesario usar el script inmediatamente despu\u00e9s de la llamada a la funci\u00f3n <code>loadScript(src)</code>.</p> <pre><code>loadScript('/my/script.js') // el script tiene a \"function newFunction() {\u2026}\"\nnewFunction(); // \u274c no existe dicha funci\u00f3n!\n</code></pre> <p>El navegador no tuvo tiempo de cargar el script. Hasta el momento, la funci\u00f3n <code>loadScript</code> no proporciona una forma de monitorear la finalizaci\u00f3n de la carga. El script se carga y finalmente se ejecuta, eso es todo. Pero necesitamos saber cu\u00e1ndo sucede, para poder usar las funciones y variables nuevas de dicho script.</p> <p>Podemos solventar este problema, a trav\u00e9s de un callback:</p> <pre><code>function loadScript(src, callback) {\nlet script = document.createElement('script')\nscript.src = src\nscript.onload = () =&gt; callback(script)\ndocument.head.append(script)\n}\n</code></pre> <p>El evento <code>onload</code>, b\u00e1sicamente ejecuta una funci\u00f3n despu\u00e9s de que el script fue cargado y ejecutado. Ahora, si queremos llamar las nuevas funciones desde el script, lo hacemos dentro de la callback:</p> <pre><code>loadScript('/my/script.js', function() {\nnewFunction()\n// ...\n})\n</code></pre> <p>Eso se llama programaci\u00f3n as\u00edncrona basado en callback. Una funci\u00f3n que hace algo de forma as\u00edncrona deber\u00eda aceptar un argumento de callback donde ponemos la funci\u00f3n por ejecutar despu\u00e9s de que se complete.</p>"},{"location":"bloque_i/tema_9/page-2/#callback-en-otra-callback","title":"Callback en otra callback","text":"<p>Es posible, que en una llamada callback podamos realizar otra llamada callback:</p> <pre><code>loadScript('/my/script.js', function(script) {\nloadScript('/my/script2.js', function(script) {\nloadScript('/my/script3.js', function(script) {\n})\n})\n})\n</code></pre> <p>En el ejemplo anterior, al ejecutar el primer script, ejecuta el segundo script, y una vez cargado el segundo, ejecuta el tercero.</p>"},{"location":"bloque_i/tema_9/page-2/#manejo-de-errores","title":"Manejo de errores","text":"<p>La callback enviada debe tener en cuenta los errores de la funci\u00f3n y poder, as\u00ed, enfrentarse a ellos. Por ello, la callback debe recibir un par\u00e1metro de tipo <code>Error</code>:</p> <pre><code>function loadScript(src, callback) {\nlet script = document.createElement('script')\nscript.src = src\nscript.onload = () =&gt; callback(null, script)\nscript.onerror = () =&gt; callback(new Error(`Error de carga de script con ${src}`))\ndocument.head.append(script)\n}\nloadScript('/my/script.js', function(error, script) {\nif (error) {\n// maneja el error\n} else {\n// script cargado satisfactoriamente\n}\n})\n</code></pre> <p>El estilo usado en el ejemplo anterior se conoce como error first callback:</p> <ol> <li>El primer argumento de la callback est\u00e1 reservado para un error, si este ocurre. En tal caso se llama a <code>callback(err)</code>.</li> <li>El segundo argumento (y los siguientes si es necesario) son para el resultado exitoso. En este caso se llama a <code>callback(null, result1, result2 ...)</code></li> </ol> <p>As\u00ed usamos una \u00fanica funci\u00f3n de callback tanto para informar errores como para transferir resultados.</p>"},{"location":"bloque_i/tema_9/page-2/#piramide-infernal","title":"Pir\u00e1mide infernal","text":"<p>A primera vista, es una forma viable de codificaci\u00f3n as\u00edncrona para una o quiz\u00e1s dos llamadas anidadas, se ve bien.</p> <p>Pero para m\u00faltiples acciones as\u00edncronas que van una tras otra, tendremos un c\u00f3digo como este:</p> <pre><code>loadScript('1.js', function(error, script) {\nif (error) {\nhandleError(error);\n} else {\n// ...\nloadScript('2.js', function(error, script) {\nif (error) {\nhandleError(error);\n} else {\n// ...\nloadScript('3.js', function(error, script) {\nif (error) {\nhandleError(error)\n} else {\n// ...continua despu\u00e9s de que se han cargado todos los script (*)\n}\n})\n}\n})\n}\n})\n</code></pre> <p>A medida que las llamadas se anidan m\u00e1s, el c\u00f3digo se vuelve m\u00e1s profundo y dif\u00edcil de administrar, especialmente si tenemos un c\u00f3digo real en lugar de <code>\u2026</code> que puede incluir m\u00e1s bucles, declaraciones condicionales, etc.</p> <p>A esto se le llama infierno de callbacks o pir\u00e1mide infernal (callback hell, pyramid of doom). La pir\u00e1mide de llamadas anidadas crece hacia la derecha con cada acci\u00f3n as\u00edncrona. Pronto se sale de control. Entonces esta forma de codificaci\u00f3n no es tan buena.</p> <p>Una de las formas de evitar esta pir\u00e1mide es poder tratar cada callback como una funci\u00f3n independiente, lo que har\u00eda que el c\u00f3digo quedase m\u00e1s limpio. Sin embargo, el c\u00f3digo es dif\u00edcil de leer, y habr\u00e1 que saltar de un lado a otro mientras se lee. Es un inconveniente, especialmente si el lector no est\u00e1 familiarizado con el c\u00f3digo y no sabe d\u00f3nde dirigir la mirada.</p>"},{"location":"bloque_i/tema_9/page-3/","title":"3 Promesas","text":""},{"location":"bloque_i/tema_9/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>En la programaci\u00f3n as\u00edncrona, se require un c\u00f3digo productor que realiza una funci\u00f3n y se toma su tiempo para realizarla (de forma as\u00edncrona). Tambi\u00e9n, se require un c\u00f3digo consumidor que necesita el resultado del c\u00f3digo productor, una vez que \u00e9ste lo tenga listo. Por otro lado, necesitamos un objeto que una ambos c\u00f3digos.</p> <p>En Javascript, las promesas son objetos que representa la conclusi\u00f3n de una operaci\u00f3n as\u00edncrona y su valor (o error) resultante. Es una herramienta poderosa para manejar operaciones as\u00edncronas de una manera m\u00e1s manejable y legible que los tradicionales callbacks.</p> <p>De esta forma, el c\u00f3digo consumidor se subscribir\u00e1 a la promesa, esperando as\u00ed que el c\u00f3digo productor realice su operaci\u00f3n y retorn\u00e9 el valor deseado, o un error si es necesario.</p> <p>Para construir una promesa, se utiliza la siguiente sintaxis:</p> <pre><code>const promise = new Promise(function(resolve, reject)){\n//...\n}\n</code></pre> <p>La funci\u00f3n pasada en el constructor se llama ejecutor. Cuando se crea una promesa, el ejecutor corre autom\u00e1ticamente. Este contiene el c\u00f3digo productor que a la larga deber\u00eda producir el resultado.</p> <p>Sus argumentos resolve y reject son callbacks proporcionadas por el propio JavaScript. Nuestro c\u00f3digo solo est\u00e1 dentro del ejecutor. Cuando el ejecutor obtiene el resultado (m\u00e1s tarde o m\u00e1s temprano, eso no importa), debe llamar a una de estas dos callbacks:</p> <ul> <li><code>resolve(value)</code>: resuelto si el trabajo finaliz\u00f3 con \u00e9xito, con el resultado <code>value</code>.</li> <li><code>reject(error)</code>: rechazado si ocurri\u00f3 un error, con un objeto error.</li> </ul> <p>El ejecutor corre autom\u00e1ticamente e intenta realizar una tarea. Cuando termina con el intento, llama a <code>resolve</code> si fue exitoso o <code>reject</code> si hubo un error.</p> <p>El objeto <code>promise</code> devuelto por el constructor tiene estas propiedades internas:</p> <ul> <li><code>state</code>: estado de la promesa. Su valor inicial es <code>pending</code>, luego cambia a <code>fulfilled</code> cuando llama a <code>resolve</code>, o <code>rejected</code> cunado llama a <code>reject</code>.</li> <li><code>result</code>: resultado de la promesa. Su valor inicial es <code>undefined</code>, luego cambia al valor del <code>resolve(value)</code> o al error del <code>reject(error)</code>.</li> </ul> <pre><code>flowchart LR\n\n    promise[\"state: 'pending'\n        result: undefined\n    \"]\n\n    fulfilled[\"state: 'fulfilled'\n        result: value\n    \"]\n\n    rejected[\"state: 'rejected'\n        result: error\n    \"]\n\n    promise ----&gt; fulfilled\n    promise ----&gt; rejected    </code></pre> Figura  - Promesas <p>Aqu\u00ed hay un ejemplo de un constructor de promesas y una funci\u00f3n ejecutora simple con c\u00f3digo productor que toma tiempo (a trav\u00e9s de <code>setTimeout</code>):</p> <pre><code>const promise = new Promise(function(resolve, reject) {\n// la funci\u00f3n se ejecuta autom\u00e1ticamente cuando se construye la promesa\n// despu\u00e9s de 1 segundo, indica que la tarea est\u00e1 hecha con el resultado \"hecho\"\nsetTimeout(() =&gt; resolve(\"hecho\"), 1000);\n})\n</code></pre> <p>Hay que tener en cuenta:</p> <ol> <li>Se llama al ejecutor de forma autom\u00e1tica e inmediata.</li> <li>El ejecutor recibe dos argumentos: <code>resolve</code> y <code>reject</code>. Estas funciones est\u00e1n predefinidas por el motor de JavaScript, por lo que no necesitamos crearlas. Solo debemos llamar a una de ellas cuando est\u00e9 listo. Despu\u00e9s de un segundo de procesamiento^, el ejecutor llama a <code>resolve(\"hecho\")</code> para producir el resultado. Esto cambia el estado del objeto promise a <code>fulfilled</code></li> </ol> <p>Warning</p> <p>El ejecutor har\u00e1 un \u00fanico llamado: a un <code>resolve</code> o a un <code>reject</code>. Una vez que el estado es establecido, este cambio es definitivo. Por lo que, se ignorar\u00e1n todas las llamadas adicionales. La idea es que una tarea realizada por el ejecutor puede tener solamente un resultado, o un error.</p> <p>Adem\u00e1s, tanto <code>resolve</code> como <code>reject</code> esperan un \u00fanico argumento (o ninguno) e ignorar\u00e1n argumentos adicionales.</p>"},{"location":"bloque_i/tema_9/page-3/#consumidores","title":"Consumidores","text":"<p>Un objeto Promise sirve como enlace entre el ejecutor (el c\u00f3digo productor) y las funciones consumidoras, que recibir\u00e1n un resultado o un error. Las funciones de consumo pueden registrarse (suscribirse) utilizando los m\u00e9todos <code>.then</code> y <code>.catch</code>.</p> <p>El m\u00e9todo <code>then</code> puede recibir dos callbacks:</p> <ul> <li><code>function(result)</code> que se ejecuta cuando resuelve la promesa y recibe el resultado.</li> <li><code>function(error)</code> que se ejecuta cuando se rechaza la promesa y recibe el error.</li> </ul> <p>Veamos un ejemplo:</p> <pre><code>const promise = new Promise(function(resolve, reject) {\nsetTimeout(() =&gt; resolve(\"hecho!\"), 1000)\n})\npromise.then(\nresult =&gt; console.log(result), // hecho!\nerror =&gt; console.log(error) // no se ejecuta\n)\n</code></pre> <p>Si solo nos interesan las terminaciones exitosas, entonces podemos proporcionar solo un argumento de funci\u00f3n para <code>.then</code>:</p> <pre><code>const promise = new Promise(function(resolve, reject) {\nsetTimeout(() =&gt; resolve(\"hecho!\"), 1000)\n})\npromise.then(\nresult =&gt; console.log(result) // hecho!\n)\n</code></pre> <p>Y si solo nos interesa el error, indicamos como null el primer argumento y pasamos como segundo argumento el callback de error, o se puede usar el m\u00e9todo <code>catch</code>.</p> <p>El m\u00e9todo <code>catch</code> ser\u00e1 ejecuta cuando la promesa ha sido rechaza, y recibe una callback para manejar el error:</p> <pre><code>const promise = new Promise((resolve, reject) =&gt; {\nsetTimeout(() =&gt; reject(new Error(\"Vaya!\")), 1000)\n})\npromise.catch(error =&gt; console.log(error))\n</code></pre> <p>Al igual que la estructura <code>try-catch</code> tiene la sentencia <code>finally</code>, existe un m\u00e9todo <code>finally</code> en las promesas, que ser\u00e1 ejecuta independientemente de si la promesa ha sido resulta o rechazada.</p> <p>La idea de <code>finally</code> es establecer un manejador para realizar la limpieza y finalizaci\u00f3n despu\u00e9s de que las operaciones se hubieran completado.</p> <p>El m\u00e9todo <code>finally</code> recibe una callback sin argumentos:</p> <pre><code>const promise = new Promise(function(resolve, reject) {\nsetTimeout(() =&gt; resolve(\"hecho!\"), 1000)\n})\npromise.finally(() =&gt; console.log('Promesa finalizada'))\n</code></pre>"},{"location":"bloque_i/tema_9/page-3/#concatenacion-de-operaciones","title":"Concatenaci\u00f3n de operaciones","text":"<p>Cuando se crea una promesa, se puede concatenar los diferentes m\u00e9todos vistos ya que todos devuelven la misma promesa. Por lo que, no solo se puede concatenar, si no, que no importa el orden en el que se realice dicha concatenaci\u00f3n:</p> <pre><code>new Promise((resolve, reject) =&gt; {\n// ...\n}).then(value =&gt; console.log(value))\n.catch(error =&gt; console.log(error))\n.finally(() =&gt; console.log('Promises done'))\n</code></pre> <p>De esta forma, una vez creada la promesa, se ejecuta el m\u00e9todo correspondiente al estado de la promesa (<code>then</code> si el estado es <code>fulfilled</code> o <code>catch</code> si el estado es <code>rejected</code>), y en \u00faltima instancia el m\u00e9todo <code>finally</code>.</p> <p>Tambi\u00e9n al consumir, podemos ir modificando el valor seg\u00fan nos sea conveniente:</p> <pre><code>new Promise((resolve, _) =&gt; {\nsetTimeout(() =&gt; resolve(1), 1000)\n}).then(result =&gt; result * 2) // 2\n.then(result =&gt; result * 2) // 4\n.then(result =&gt; result * 2) // 8\n</code></pre> <p>Si se hace de forma separada, el resultado obtenido no ser\u00e1 modificado en las siguientes llamadas, sino que utiliza el valor devuelto por la promesa:</p> <pre><code>let promise = new Promise(function(resolve, reject) {\nsetTimeout(() =&gt; resolve(1), 1000)\n})\npromise.then(function(result) {\nalert(result) // 1\nreturn result * 2\n})\npromise.then(function(result) {\nalert(result) // 1\nreturn result * 2\n})\npromise.then(function(result) {\nalert(result) // 1\nreturn result * 2\n})\n</code></pre> <p>Lo que hicimos aqu\u00ed fue a\u00f1adir varios controladores a una sola promesa. No se pasan el resultado el uno al otro; en su lugar, lo procesan de forma independiente.</p> <p>Un controlador (\u201chandler\u201d), utilizado en <code>then(handler)</code>, puede crear y devolver una promesa. En ese caso, otros manejadores esperan hasta que se estabilice (resuelva o rechace) y luego obtienen su resultado.</p> <pre><code>new Promise((resolve, reject) =&gt; {\nsetTimeout(() =&gt; resolve(1), 1000)\n}).then(result =&gt; {\nreturn new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(result * 2), 1000) // 2\n})\n}).then(result =&gt; { return new Promise((resolve, reject) =&gt; {\nsetTimeout(() =&gt; resolve(result * 2), 1000) // 4\n})\n}).then(result =&gt; {\nconsole.log(result) // 4\n})\n</code></pre> <p>Veamos el ejemplo, donde se cargaba de forma as\u00edncrona el script haciendo uso de promesas:</p> <pre><code>loadScript(\"/article/promise-chaining/one.js\")\n.then(script =&gt; loadScript(\"/article/promise-chaining/two.js\"))\n.then(script =&gt; loadScript(\"/article/promise-chaining/three.js\"))\n.then(script =&gt; {\none()\ntwo()\nthree()\n})\n</code></pre>"},{"location":"bloque_i/tema_9/page-3/#objetos-thenables","title":"Objetos Thenables","text":"<p>Los objetos Thenables son aquellos objetos que disponen de un m\u00e9todo <code>then</code>, por lo que puede ser utilizado en la concatenaci\u00f3n de promesas y ser tratada como una.</p> <p>La idea es que las librer\u00edas de terceros puedan implementar sus propios objetos compatibles con la promesa. Pueden tener un conjunto extendido de m\u00e9todos, pero tambi\u00e9n ser compatibles con las promesas nativas, porque implementan <code>then</code>.</p> <p>Veamos un ejemplo:</p> <pre><code>class Thenable {\nconstructor(num) {\nthis.num = num;\n}\nthen(resolve, reject) {\nconsole.log(resolve)\nsetTimeout(() =&gt; resolve(this.num * 2), 1000)\n}\n}\nnew Promise(resolve =&gt; resolve(1))\n.then(result =&gt; {\nreturn new Thenable(result) })\n.then(console.log) // muestra 2 despu\u00e9s de 1000 ms\n</code></pre>"},{"location":"bloque_i/tema_9/page-3/#manejo-de-errores","title":"Manejo de errores","text":"<p>Las promesas encadenadas son excelentes manejando los errores. Cuando una promesa es rechazada, el control salta al manejador de rechazos m\u00e1s cercano. Esto es muy conveniente en la pr\u00e1ctica.</p> <pre><code>new Promise((resolve, reject) =&gt; {\n//...\n}).then(value =&gt; console.log(value))\n.catch(err =&gt; console.log(err))\n</code></pre> <p>Tambi\u00e9n puede ocurrir, que el error no ocurra en al promesa inicial, sino que \u00e9sta devuelva un resultado l\u00f3gico, pero al consumirlo con el m\u00e9todo <code>then</code> haya ocurrido un error. Por ejemplo, supongamos que tenemos una promesa que devuelve una cadena de forma JSON, pero est\u00e1 cadena no tiene el formato JSON correcto, al usar el m\u00e9todo <code>JSON.parse</code> con dicho valor, dar\u00e1 un error que ser\u00e1 recogido en el <code>catch</code>:</p> <pre><code>new Promise((resolve, reject) =&gt; {\nresolve(`{\"name\": \"John\", ,: 10}`)\n}).then(response =&gt; response.json())\n.catch(error =&gt; console.log(error))\n</code></pre> <p>El c\u00f3digo de un ejecutor de promesas y de manejadores de promesas tiene embebido un <code>try-catch</code> invisible. Si ocurre una excepci\u00f3n, esta es atrapada y es tratada como un rechazo:</p> <pre><code>new Promise((resolve, reject) =&gt; {\nthrow new Error(\"Whoops!\");\n}).catch(console.log)\n</code></pre> <p>Esto sucede no solo en la funci\u00f3n ejecutora, sino tambi\u00e9n en sus manejadores. Si hacemos <code>throw</code> dentro de una llamada a <code>then</code>, esto devolver\u00e1 una promesa rechazada, por lo que el control salta a manejador de errores m\u00e1s cercano.</p> <pre><code>new Promise((resolve, reject) =&gt; {\nresolve(\"ok\")\n}).then((result) =&gt; {\nthrow new Error(\"Whoops!\") // rechaza la promesa\n}).catch(console.log)\n</code></pre> <p>Al igual que en los bloques <code>try-catch</code> en el <code>catch</code> se puede relanzar un error que ser\u00e1 recogido por el siguiente <code>catch</code> m\u00e1s cercano:</p> <pre><code>new Promise((resolve, reject) =&gt; {\nthrow new Error(\"Whoops!\")\n}).catch(error =&gt; {\nif(error instanceof MyError){\n// handler error\n} else {\nthrow error\n}\n}).then(doSomething)\n.catch(error =&gt; console.log(error))\n</code></pre> <p>La ejecuci\u00f3n salta del primer <code>catch</code> al siguiente <code>catch</code>.</p> <p>En caso de que se genere un error, la promesa se rechaza y la ejecuci\u00f3n salta al manejador de rechazos m\u00e1s cercano. Pero aqu\u00ed no hay ninguno. Entonces el error se atasca, ya que no hay c\u00f3digo para manejarlo. En la pr\u00e1ctica, al igual que con los errores comunes no manejados en el c\u00f3digo, esto significa que algo ha salido terriblemente mal.</p> <p>En dicho caso, el script muere con un mensaje en la consola. Algo similar sucede con los rechazos de promesas no manejadas.</p>"},{"location":"bloque_i/tema_9/page-4/","title":"4 Construcci\u00f3n de promesas","text":""},{"location":"bloque_i/tema_9/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Como hemos visto hasta ahora, para construir una promesa, podemos usar el constructor Promise. Sin embargo, existen 6 m\u00e9todos est\u00e1ticos diferentes para crear promesas en situaciones diferentes.</p>"},{"location":"bloque_i/tema_9/page-4/#promiseall","title":"Promise.all","text":"<p>El m\u00e9todo est\u00e1tico <code>Promise.all(promises)</code> recibe un iterable de promesas, devolviendo una nueva promesa. Esta nueva promesa ser\u00e1 resuelta cuando todas las promesas del iterador lo sean.</p> <pre><code>Promise.all([\nnew Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 3000)),\nnew Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000)),\nnew Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000)),\n])\n.then(console.log) // 1,2,3\n</code></pre> <p>Ten en cuenta que el orden de los miembros del array es el mismo que el de las promesas que los originan. Aunque la primera promesa es la que toma m\u00e1s tiempo en resolverse, es a\u00fan la primera en el array de resultados.</p> <p>Si cualquiera de las promesas es rechazada, la promesa devuelta por <code>Promise.all</code> inmediatamente rechaza: reject con ese error.</p> <pre><code>Promise.all([\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)),\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(\"Whoops!\")), 2000)),\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))\n]).catch(console.log) // Error: Whoops!\n</code></pre> <p>Si una promesa se rechaza, <code>Promise.all</code> se rechaza inmediatamente, olvidando completamente las otras de la lista. Aquellos resultados son ignorados.</p>"},{"location":"bloque_i/tema_9/page-4/#promiseallsettled","title":"Promise.allSettled","text":"<p>Mientras que <code>Promise.all</code> rechaza todas las promesas cuando una de ellas es rechazada, <code>Promise.allSettled</code> solo espera que todas las promesas se resuelvan sin importar sus resultados. El array resultante tiene, una estructura similar a la siguiente:</p> <ul> <li><code>{status: \"fulfilled\", value: result}</code> para respuestas exitosas.</li> <li><code>{status: \"rejected\", reason: error}</code> para errores.</li> </ul> <pre><code>Promise.allSettled([\n// ...\n])\n.then(results =&gt; {\nresults.forEach((result, num) =&gt; {\nif (result.status == \"fulfilled\") {\nconsole.log(`${urls[num]}: ${result.value.status}`)\n}\nif (result.status == \"rejected\") {\nconsole.log(`${urls[num]}: ${result.reason}`)\n}\n})\n})\n</code></pre> <p><code>Promise.all</code> se suele utilizar cuando se desea el resultado de todas las promesas, y en caso de que fall\u00e9 alguna, no nos interesa el resultado final. Es como un todo o nada</p>"},{"location":"bloque_i/tema_9/page-4/#promiserace","title":"Promise.race","text":"<p>Es similar a <code>Promise.all</code>, pero espera solamente por la primera respuesta y obtiene su resultado (o error):</p> <pre><code>Promise.race([\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)),\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(\"Whoops!\")), 2000)),\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))\n]).then(console.log) // 1\n</code></pre> <p>La primera promesa fue la m\u00e1s r\u00e1pida, por lo que se vuelve resultado. En cuanto una promesa responde, gana la carrera, y todos los resultados o errores posteriores son ignorados.</p>"},{"location":"bloque_i/tema_9/page-4/#promiseany","title":"Promise.any","text":"<p>Es similar a <code>Promise.race</code>, pero espera solamente por la primera promesa cumplida y obtiene su resultado. Si todas la promesas fueron rechazadas, entonces la promesa que devuelve es rechazada con <code>AggregateError</code>, un error especial que almacena los errores de todas las promesas en su propiedad errors.</p> <pre><code>Promise.any([\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(\"Whoops!\")), 1000)),\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 2000)),\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))\n]).then(console.log) // 1\n</code></pre> <p>La primera promesa fue la m\u00e1s r\u00e1pida, pero fue rechazada entonces devuelve el resultado de la segunda. Una vez que la primera promesa cumplida gana la carrera, los dem\u00e1s resultados ser\u00e1n ignorados.</p> <p>Aqu\u00ed hay un ejemplo donde todas la promesas fallan:</p> <pre><code>Promise.any([\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(\"Ouch!\")), 1000)),\nnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(\"Error!\")), 2000))\n]).catch(error =&gt; {\nconsole.log(error.constructor.name); // AggregateError\nconsole.log(error.errors[0]); // Error: Ouch!\nconsole.log(error.errors[1]); // Error: Error!\n})\n</code></pre> <p>Como puedes ver, los objetos de error de las promesas que fallaron est\u00e1n disponibles en la propiedad errors del objeto <code>AggregateError</code>.</p>"},{"location":"bloque_i/tema_9/page-4/#promiseresolve-y-promisereject","title":"Promise.resolve y Promise.reject","text":"<p>Warning</p> <p>Los m\u00e9todos <code>Promise.resolve</code> y <code>Promise.reject</code> son raramente necesitados en c\u00f3digo moderno porque la sintaxis <code>async/await</code> (que veremos luego) las hace algo obsoletas.</p> <p>El m\u00e9todo <code>Promise.resolve(value)</code> crea una promesa resuelta con el resultado dado, mientras que <code>Promise.reject(error)</code> rechaza una promesa con el error.</p> <pre><code>const cache = new Map();\nfunction loadCached(url) {\nif (cache.has(url)) {\nreturn Promise.resolve(cache.get(url))\n}\nreturn new Promises((res, rej) =&gt; {\n// Conecta con las url\n})\n.then(response =&gt; response.text())\n.then(text =&gt; {\ncache.set(url,text)\nreturn text\n})\n}\n</code></pre>"},{"location":"bloque_i/tema_9/page-4/#promisificacion","title":"Promisificaci\u00f3n","text":"<p>Promisificaci\u00f3n es una simple transformaci\u00f3n, es la conversi\u00f3n de una funci\u00f3n que acepta una callback a una funci\u00f3n que devuelve una promesa.</p> <p>A menudo estas transformaciones son necesarias en la vida real ya que muchas funciones y librer\u00edas est\u00e1n basadas en callbacks, pero las promesas son m\u00e1s convenientes as\u00ed que tiene sentido promisificarlas.</p> <p>Veamos un ejemplo.</p> <pre><code>function loadScript(src, callback) {\nconst script = document.createElement('script')\nscript.src = src\nscript.onload = () =&gt; callback(null, script)\nscript.onerror = () =&gt; callback(new Error(`Error de carga de script ${src}`))\ndocument.head.append(script)\n}\n</code></pre> <p>La funci\u00f3n carga un script con el <code>src</code> dado, y llama a <code>callback(err)</code> en caso de error o <code>callback(null, script)</code> en caso de carga exitosa. Esto est\u00e1 ampliamente acordado en el uso de callbacks, lo hemos visto antes.</p> <p>Ahora, vamos a promisificarla. Haremos una funci\u00f3n nueva que va a hacer lo mismo (carga el script), pero devuelve una promesa en vez de usar callbacks.</p> <pre><code>const loadScriptPromise = function(src) {\nreturn new Promise((resolve, reject) =&gt; {\nloadScript(src, (err, script) =&gt; {\nif (err) reject(err)\nelse resolve(script)\n})\n})\n}\n</code></pre> <p>En la pr\u00e1ctica, la promisificaci\u00f3n es una operaci\u00f3n bastante utilizada, por lo que podemos crear un ayudante que se encargue de promisificar las funciones que reciben callbacks.</p> <pre><code>function promisify(f) {\nreturn function (...args) { // devuelve una funci\u00f3n contenedora\nreturn new Promise((resolve, reject) =&gt; {\nfunction callback(err, result) { // nuestro callback personalizado para f\nif (err) {\nreject(err);\n} else {\nresolve(result);\n}\n}\nargs.push(callback); // adjunta nuestro callback personalizado al final de los argumentos\nf.call(this, ...args); // llama a la funci\u00f3n original\n})\n}\n}\nconst loadScriptPromise = promisify(loadScript)\nloadScriptPromise(...).then(...)\n</code></pre> <p>El c\u00f3digo puede verse complicado, pero es esencialmente lo mismo que escribimos arriba al promisificar la funci\u00f3n <code>loadScript</code>. Una llamada a <code>promisify(f)</code> devuelve una funci\u00f3n contenedora que envuelve a la funci\u00f3n. Este contenedor devuelve una promesa y redirige el llamado a la funci\u00f3n original, siguiendo el resultado en el callback personalizado.</p> <p>Aqu\u00ed <code>promisify</code> asume que la funci\u00f3n original espera un callback con dos argumentos <code>(err, result)</code>. Eso es lo que usualmente encontramos. Entonces nuestro callback personalizado est\u00e1 exactamente en el formato correcto, y promisify funciona muy bien para tal caso.</p> <p>Esta funci\u00f3n promificadora puede ser m\u00e1s avanzada de diferentes maneras.</p>"},{"location":"bloque_i/tema_9/page-5/","title":"5 Microtareas","text":""},{"location":"bloque_i/tema_9/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Los manejadores o controladores de promesas son siempre as\u00edncronos. Incluso cuando una promesa es inmediatamente resuelta, el c\u00f3digo en las l\u00edneas debajo se ejecutar\u00e1 antes que estos controladores.</p> <p>Veamos un ejemplo:</p> <pre><code>const promise = Promise.resolve()\npromise.then(() =&gt; console.log(\"\u00a1Promesa realizada!\"))\nconsole.log(\"c\u00f3digo finalizado\") </code></pre> <p>Al ejecutar el c\u00f3digo anterior, primero se ejecuta el \u00faltimo log, en lugar de la promesa.</p>"},{"location":"bloque_i/tema_9/page-5/#microtasks-queue","title":"Microtasks queue","text":"<p>Las tareas as\u00edncronas necesitan una gesti\u00f3n adecuada. Para ello, el est\u00e1ndar ECMA especifica una cola interna <code>PromiseJobs</code>, en ocasiones m\u00e1s conocida como cola de microtareas (t\u00e9rmino de V8).</p> <p>Como se indica en la especificaci\u00f3n:</p> <ul> <li>La cola es first-in-first-out (FIFO), es decir, primero en entrar primero en salir, la tarea que entr\u00f3 primero en la cola, ser\u00e1 la primera en ejecutarse.</li> <li>La ejecuci\u00f3n de una tarea se inicia s\u00f3lo cuando no se est\u00e1 ejecutando nada m\u00e1s.</li> </ul> <p>O, en palabras m\u00e1s simples, cuando una promesa est\u00e1 lista, sus controladores se ponen en la cola; ellos a\u00fan no se ejecutan. Cuando el motor de Javascript se libera del c\u00f3digo actual, toma una tarea de la cola y la ejecuta.</p> <p>Es por eso que el c\u00f3digo finalizado en el ejemplo anterior se muestra primero.</p> <p>Los controladores de promesas siempre pasan por esta cola interna. Si hay una cadena con m\u00faltiples llamadas a los controladores,  entonces cada uno de ellos se ejecuta de forma as\u00edncrona, es decir, primero se pone en la cola, luego se ejecuta cuando se completa el c\u00f3digo actual y se finalizan los controladores previamente en la cola.</p>"},{"location":"bloque_i/tema_9/page-5/#rechazo-no-controlado","title":"Rechazo no controlado","text":"<p>Como ya hemos visto, cuando un error es lanzado y no es capturado por ninguna promesa,\u00e9ste ser\u00e1 manejado por unhandled rejection. Se produce un rechazo no controlado cuando no se maneja un error de promesa al final de la cola de microtareas.</p> <p>Si se olvida a\u00f1adir el <code>catch</code>, entonces, despu\u00e9s de que la cola de microtareas est\u00e9 vac\u00eda, el motor activa el evento <code>unhandledrejection</code>. <code>unhandledrejection</code> se genera cuando se completa la cola de microtareas, el motor examina las promesas y, si alguna de ellas est\u00e1 en el estado rechazado, entonces el evento se dispara.</p>"},{"location":"bloque_i/tema_9/page-6/","title":"6 Async/Await","text":""},{"location":"bloque_i/tema_9/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos visto podemos ejecutar tareas de forma as\u00edncrona gracias a las promesas de Javascript y poderlas consumir con su m\u00e9todos consumidores (<code>then</code>, <code>catch</code>, <code>finally</code>).</p> <p>Sin embargo, existe una sintaxis especial para trabajar con promesas de una forma m\u00e1s c\u00f3moda y menos funcional, llamada async/await.</p>"},{"location":"bloque_i/tema_9/page-6/#funciones-async","title":"Funciones async","text":"<p>Cuando una funci\u00f3n es declarada como async quiere decir que es una funci\u00f3n as\u00edncrona que va a devolver una promesa. Su sintaxis es:</p> <pre><code>async function myAsyncFunction(){\n// ..\n}\nconst myAsyncFunction = async () =&gt; {\n// ..\n}\n</code></pre> <p>La promesa devuelta puede ser retornada de forma expl\u00edcita:</p> <pre><code>const asyncFunc = async () =&gt; {\nreturn Promise.resolve(1)\n}\n</code></pre> <p>Sin embargo, no es necesario retorna una promise expl\u00edcitamente, ya que cualquier cosa que retornemos ser\u00e1 retornado como una promesa:</p> <pre><code>const asyncFunc = async () =&gt; {\nreturn 1\n}\nasyncFunc().then(console.log) // 1\n</code></pre> <p>Entonces, async se asegura de que la funci\u00f3n devuelva una promesa, o envuelve las no promesas y las transforma en una.</p>"},{"location":"bloque_i/tema_9/page-6/#await","title":"Await","text":"<p>La palabra reservada <code>await</code> se utiliza en Javascript para esperar que una promesa sea respondida y obtengamos su resultado. Su sintaxis es:</p> <pre><code>let value = await promise\n</code></pre> <p>await literalmente suspende la ejecuci\u00f3n de la funci\u00f3n hasta que se establezca la promesa, y luego la reanuda con el resultado de la promesa. Eso no cuesta ning\u00fan recurso de CPU, porque el motor de JavaScript puede hacer otros trabajos mientras tanto: ejecutar otros scripts, manejar eventos, etc.</p> <p>Veamos un ejemplo:</p> <pre><code>async function f(){\nconst promise = new Promise((resolve, reject) =&gt; {\nsetTimeout(() =&gt; resolve(\"Done!\"), 1000)\n})\nconst result = await promise // (1)!\nconsole.log(result) // Done!\n}\nf()\n</code></pre> <ol> <li>En esta l\u00ednea, la ejecuci\u00f3n de la funci\u00f3n espera hasta que la promesa sea resulta. Una vez resulta, obtiene su resultado.</li> </ol> <p>Warning</p> <p>Si tratamos de usar <code>await</code> en una funci\u00f3n no <code>async</code>, tendremos un error de sintaxis:</p> <pre><code>function f() {\nlet promise = Promise.resolve(1)\nlet result = await promise // Syntax error\n}\n</code></pre> <p>Es posible que obtengamos este error si olvidamos poner <code>async</code> antes de una funci\u00f3n. </p> <p>Warning</p> <p>En los navegadores modernos, <code>await</code> de nivel superior funciona, siempre que estamos dentro de un m\u00f3dulo.</p> <pre><code>let response = await fetch('/article/promise-chaining/user.json')\nlet user = await response.json()\nconsole.log(user)\n</code></pre> <p>Si no estamos usando m\u00f3dulos, o necesitamos soportar navegadores antiguos, tenemos una receta universal: envolverlos en una funci\u00f3n <code>async</code> an\u00f3nima.</p> <pre><code>(async () =&gt; {\nlet response = await fetch('/article/promise-chaining/user.json');\nlet user = await response.json();\n...\n})();\n</code></pre>"},{"location":"bloque_i/tema_9/page-6/#manejo-de-errores","title":"Manejo de errores","text":"<p>Si una promesa se resuelve normalmente, entonces <code>await promise</code> devuelve el resultado. Sin embargo, en caso de rechazo, dispara un error, tal como si hubiera una instrucci\u00f3n <code>throw</code> en aquella l\u00ednea. Veamos un ejemplo:</p> <pre><code>async function f(){\nawait Promise.reject(new Error(\"Whoops!\"))\n}\n</code></pre> <p>En situaciones reales, la promesa tomar\u00e1 alg\u00fan tiempo antes del rechazo. En tal caso habr\u00e1 un retardo antes de que <code>await</code> dispare un error. Podemos atrapar tal error usando <code>try-catch</code>, de la misma manera que con un <code>throw</code> normal:</p> <pre><code>async function f() {\ntry {\nawait Promise.reject(new Error(\"Whoops!\"))\n} catch(err) {\nconsole.log(err)\n}\n}\nf()\n</code></pre> <p>Tambi\u00e9n podemos utilizar el m\u00e9todo <code>catch</code> de las promesas para capturarlo. En caso de que no se capture la excepci\u00f3n, podemos atrapar tales errores usando un manejador de evento global <code>unhandledrejection</code>.</p>"},{"location":"bloque_i/tema_9/page-7/","title":"7 Generadores e iteradores as\u00edncronos","text":""},{"location":"bloque_i/tema_9/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>Los iteradores as\u00edncronos nos permiten iterar sobre los datos que vienen de forma as\u00edncrona, en una petici\u00f3n. Como, por ejemplo, cuando descargamos algo por partes a trav\u00e9s de una red. Y los generadores as\u00edncronos lo hacen a\u00fan m\u00e1s conveniente.</p>"},{"location":"bloque_i/tema_9/page-7/#iteradores-asincronos","title":"Iteradores as\u00edncronos","text":"<p>La iteraci\u00f3n as\u00edncrona es necesaria cuando los valores vienen as\u00edncronamente, por ejemplo, despu\u00e9s de <code>setTimeout</code> u otra clase de retraso.</p> <p>El caso m\u00e1s com\u00fan es un objeto que necesita hacer un pedido sobre la red para enviar el siguiente valor. Para realizar un iterador as\u00edncrono:</p> <ol> <li>Use <code>Symbol.asyncIterator</code> en lugar de <code>Symbol.iterator</code>.</li> <li>El m\u00e9todo <code>next()</code> debe devolver una promesa (a ser cumplida con el siguiente valor). La palabra clave <code>async</code> lo maneja, nosotros simplemente hacemos <code>async next()</code>.</li> <li>Para iterar sobre tal objeto, debemos usar un bucle <code>for await (let item of iterable)</code>.</li> </ol> <p>Como ejemplo inicial, hagamos iterable un objeto <code>range</code>, similar al que hicimos en los iterables no as\u00edncronos, pero ahora devolver\u00e1 valores as\u00edncronamente, uno por segundo.</p> <pre><code>const range = {\nfrom: 1,\nto: 5,\n[Symbol.asyncIterator]() {\nreturn {\ncurrent: this.from,\nlast: this.to,\nasync next() {\nawait new Promise(resolve =&gt; setTimeout(resolve, 1000)) // (3)\nif (this.current &lt;= this.last) {\nreturn { done: false, value: this.current++ }\n} else {\nreturn { done: true }\n}\n}\n}\n}\n}\n(async () =&gt; {\nfor await (let value of range) {\nalert(value) // 1,2,3,4,5\n}\n})()\n</code></pre> <p>Warning</p> <p>La sintaxis de propagaci\u00f3n o spread (\u2026) no funciona de forma as\u00edncrona. Las caracter\u00edsticas que requieren iteradores normales y sincr\u00f3nicos no funcionan con los as\u00edncronos.</p>"},{"location":"bloque_i/tema_9/page-7/#generadores-asincronos","title":"Generadores as\u00edncronos","text":"<p>Para aplicaciones m\u00e1s pr\u00e1cticas, cuando queremos hacer un objeto que genere una secuencia de valores as\u00edncronamente, podemos usar un generador as\u00edncrono.</p> <p>La sintaxis es simple, anteponer <code>async</code> a <code>function*</code>, esto hace al generador as\u00edncrono. Entonce usamos <code>for await (...)</code> para iterarlo.</p> <p>Veamos un ejemplo:</p> <pre><code>async function* generateSequence(start, end) {\nfor (let i = start; i &lt;= end; i++) {\nawait new Promise(resolve =&gt; setTimeout(resolve, 1000));\nyield i\n}\n}\n(async () =&gt; {\nlet generator = generateSequence(1, 5);\nfor await (let value of generator) {\nconsole.log(value)\n}\n})();\n</code></pre> <p>Como el generador es as\u00edncrono, podemos usar await dentro de \u00e9l, contar con promesas, hacer solicitudes de red y as\u00ed. En los generadores as\u00edncronos, el m\u00e9todo generator.next() es as\u00edncrono, devuelve promesas. En un generador normal usar\u00edamos <code>result = generator.next()</code> para obtener valores. En un generador as\u00edncrono debemos agregar <code>await</code>, as\u00ed:</p> <pre><code>result = await generator.next()\n</code></pre> <p>Veamos el ejemplo <code>range</code>, con iteradores y generadores as\u00edncronos:</p> <pre><code>let range = {\nfrom: 1,\nto: 5,\nasync *[Symbol.asyncIterator]() { // (1)!\nfor(let value = this.from; value &lt;= this.to; value++) {\nawait new Promise(resolve =&gt; setTimeout(resolve, 1000))\nyield value\n}\n}\n};\n(async () =&gt; {\nfor await (let value of range) {\nconsole.log(value)\n}\n})()\n</code></pre> <ol> <li>esta l\u00ednea es la misma que <code>[Symbol.asyncIterator]: async function*() {</code></li> </ol>"},{"location":"bloque_i/tema_9/page-8/","title":"Ejercicios","text":"<p>question \"Ejercicio 1\"</p> <pre><code>Hay muchas \u00e1reas en las que necesitamos datos aleatorios.\n\nUno de ellos es para testeo. Es posible que necesitemos datos aleatorios: texto, n\u00fameros, etc. para probar bien las cosas.\n\nEn JavaScript, podr\u00edamos usar `Math.random()`. Pero si algo sale mal, nos gustar\u00eda poder repetir la prueba utilizando exactamente los mismos datos.\n\nPara eso, se utilizan los denominados \u201cgeneradores pseudoaleatorios con semilla\u201d. Toman una \u201csemilla\u201d como primer valor, y luego generan los siguientes utilizando una f\u00f3rmula; a partir de la misma semilla se produce la misma secuencia y as\u00ed todo el flujo es f\u00e1cilmente reproducible. Solo necesitamos recordar la semilla para repetirla.\n\nUn ejemplo de dicha f\u00f3rmula, que genera valores distribuidos de manera algo uniforme:\n\n```javascript\nnext = previous * 16807 % 2147483647\n```\n\nSi nosotros usamos 1 como semilla, los valores ser\u00e1n:\n\n1. 16807\n2. 282475249\n3. 1622650073\n4. ...\n\nLa tarea es crear una funci\u00f3n generadora `pseudoRandom(seed) `que toma `seed` y crea el generador con esta f\u00f3rmula.\n\nEjemplo de uso\n\n```javascript\nconst generator = pseudoRandom(1);\n\nconsole.log(generator.next().value); // 16807\nconsole.log(generator.next().value); // 282475249\nconsole.log(generator.next().value); // 1622650073\n```\n</code></pre> Ejercicio 2 <p>\u00bfCu\u00e1l es la salida del siguiente c\u00f3digo?</p> <pre><code>const promise = new Promise(function(resolve, reject) {\nresolve(1)\nsetTimeout(() =&gt; resolve(2), 1000)\n})\npromise.then(console.log)\n</code></pre> Ejercicio 3 <p>Crea una funci\u00f3n <code>delay(ms)</code> que devuelva una promesa tras el tiempo dado transcurrido.</p> Ejercicio 4 <p>Explica el siguiente c\u00f3digo</p> <pre><code>new Promise(function(resolve, reject) {\nsetTimeout(() =&gt; {\nthrow new Error(\"Whoops!\")\n}, 1000);\n}).catch(console.log)\n</code></pre> Ejercicio 5 <p>Reescribe el siguiente c\u00f3digo haciendo uso de la estructura <code>async/await</code>:</p> <pre><code>  function loadJson(url) {\nreturn fetch(url)\n.then(response =&gt; {\nif (response.status == 200) {\nreturn response.json()\n} else {\nthrow new Error(response.status)\n}\n})\n}\nloadJson('&lt;https://javascript.info/no-such-user.json&gt;')\n.catch(console.log) // Error: 404\n</code></pre>"}]}