{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"tema_1/page-1/","title":"1 Introducci\u00f3n a Node JS","text":""},{"location":"tema_1/page-1/#que-es-node-js","title":"\u00bfQu\u00e9 es Node JS?","text":"<p>En la manera de programaci\u00f3n actual existen diferentes tipos de herramientas para facilitar el trabajo a la hora de realizar una aplicaci\u00f3n, incluso esas herramientas nos permiten realizar diferentes tipos de aplicaciones y/o proyectos. Por ejemplo, tenemos librer\u00edas que nos facilitan el desarrollo front-end (React), frameworks que nos permiten crear aplicaciones multiplataformas (Flutter), etc.</p> <p>Sin embargo, Node JS no entrar\u00eda en ninguna de estas categor\u00edas, ya que no se considera ni una librer\u00eda, ni un framework. Por el contrario, **Node JS es un entorno de ejecuci\u00f3n para Javascript que permite ejecutar Javascript sin necesidad de hacer uso de un navegador.</p> <p>Algunas de las caracter\u00edsticas que podemos encontrar en este entorno son:</p> <ul> <li>Es de c\u00f3digo abierto, haciendo uso de la licencia MIT.</li> <li>Es multiplataforma.</li> <li>As\u00edncrono y controlado por eventos. Todas las APIs (m\u00f3dulos) de NodeJs son as\u00edncronos, es decir, no realizan operaciones bloqueantes.</li> <li>Es un entorno de ejecuci\u00f3n muy r\u00e1pida.</li> <li>No realiza almacenamiento en buffer.</li> <li>Los procesos se realizan en un solo hilo, ya que Node JS es mono-hilo pero aun as\u00ed es altamente escalable.</li> </ul> <p>Uno de los motivos de que Node JS tenga esas caracter\u00edsticas es que utiliza el motor V8, que es el mismo motor usado en el navegador Chrome. La ventaja de esto es que se puede obtener todas las ventajas de una aplicaci\u00f3n Javascript en el entorno de Chrome pero haciendo uso de ellas en un entorno totalmente diferente.</p> <p>Node JS tambi\u00e9n est\u00e1 orientado a eventos, es decir,va ejecutando tareas mientras espera respuestas de otros tareas, haciendo todo esto en un \u00fanico hilo.</p>"},{"location":"tema_1/page-1/#ventajas-y-desventajas-de-usar-node-js","title":"Ventajas y desventajas de usar Node JS","text":"<p>Algunas de las ventajas que encontramos a la hora de usar Node JS son:</p> <ul> <li>Rendimiento y escalabilidad: Haciendo uso del motor V8 permite gestionar m\u00faltiples conexiones simult\u00e1neas sin bloquear el proceso principal.</li> <li>Facilidad de aprendizaje: Dado que Javascript es un lenguaje f\u00e1cil y popular y con una gran curva de aprendizaje.</li> <li>Gran ecosistema de paquetes y comunidad: Existe un gran ecosistemas de paquetes (Node JS tiene uno de los m\u00e1s grandes actualmente) lo que facilita la reutilizaci\u00f3n y compartici\u00f3n de c\u00f3digo. Adem\u00e1s, la comunidad es activa y colaborativa permitiendo as\u00ed un intercambio de conocimientos y soluciones.</li> <li>Programaci\u00f3n as\u00edncrona: Al usar programaci\u00f3n as\u00edncrona impide que el hilo principal se bloquee.</li> </ul> <p>Por el contrario, Node JS tambi\u00e9n tiene una serie de desventajas:</p> <ul> <li>Programaci\u00f3n as\u00edncrona: La programaci\u00f3n as\u00edncrona requiere puede ser un poco compleja para los desarrolladores acostumbrados a la programaci\u00f3n s\u00edncrona, adem\u00e1s puede ser lioso el manejo de errores.</li> <li>Falta de soporte para la programaci\u00f3n multihilo: Actualmente, no existe m\u00f3dulos dentro de Node JS que traten el tema de los multihilos. Sin embargo, existen diferentes librer\u00edas externas que nos permite poder trabajar con ellas.</li> </ul>"},{"location":"tema_1/page-1/#motivos-para-aprender-node-js","title":"Motivos para aprender Node JS","text":"<ol> <li>Gran demanda en el mercado, ya que Node JS es tan vers\u00e1til que las empresas lo usan para diferentes escenarios. Adem\u00e1s, Node JS pertenece a MERN Stack (**M**ongoDB **E**xpress **R**eact **N**odeJS) y al MEAN Stack, (**M**ongoDB **E**xpress **A**ngular **N**odeJS) que son soluciones de software para desarrollar aplicaciones web de forma r\u00e1pida y sencilla.</li> <li>Se puede usar los conocimientos de Javascript en Node JS.</li> <li>Tiene una gran comunidad y un gran ecosistema.</li> <li>R\u00e1pido, escalable, f\u00e1cil y barato de desplegar.</li> </ol> <p>A pesar de que sea monoproceso, eso en ciertos caso puede llevar una gran ventaja.</p>"},{"location":"tema_1/page-1/#historia","title":"Historia","text":"<p>Node fue creado en 2009 por Ryan Dahl programador en ese entonces de la empresa Joyent (dedicada a ofrecer servicios de c\u00f3mputo en la nube) que a su vez se convirti\u00f3 en la propietaria de la marca Node.js\u2122 y la que le dar\u00eda patrocinio y difusi\u00f3n desde el momento de su creaci\u00f3n.</p> <p>Joyent puso todo su empe\u00f1o para el desarrollo de Node, sin embargo, al ser una empresa del sector privado y no una comunidad o fundaci\u00f3n, los avances de Node comenzaron a ser muy lentos, en comparaci\u00f3n de lo que la comunidad solicitaba y que tambi\u00e9n quer\u00eda contribuir.</p> <p>Con el paso del tiempo y durante los siguientes 5 a\u00f1os (2009 a 2014) se fueron entregando versiones de Node a paso de tortuga pues nunca se llego como tal a una versi\u00f3n 1.0.0 estable, la \u00faltima versi\u00f3n de Node bajo la gobernabilidad de Joyent fue la 0.12.7.</p> <p>La comunidad al ver el brillante futuro que podr\u00eda tener Node en el ecosistema web y la insuficiencia (o incompetencia) de Joyent para sacarlo adelante, decide tomar cartas en el asunto e intenta contribuir al core de Node, sin embargo Joyent se opone a reconocer cualquier cambio no supervisado por ellos bajo el nombre comercial de Node.js\u2122, por lo que la comunidad decide lanzar un fork amigable de Node compatible con npm y liderado bajo un modelo de gobernabilidad abierta con el nombre de io.js.</p> <p>Con io.js el entorno de Node gan\u00f3 mejoras que se ven\u00edan esperando desde hace mucho tiempo tales como:</p> <ul> <li>Soporte para las \u00faltimas versiones de V8 y ES6</li> <li>Desarrollo activo haciendo liberaciones semanales</li> <li>Integraci\u00f3n continua y ejecuci\u00f3n de pruebas al 100%</li> <li>Vinculaci\u00f3n con la comunidad</li> <li>Gobernabilidad abierta por la comunidad y no por empresas</li> <li>Hoja de ruta predecible</li> <li>Versiones compatibles con SemVer</li> <li>Comienza a incrementar su actividad nuevamente</li> </ul> <p>La reacci\u00f3n de Joyent, propietario de Node.js\u2122 fue lanzar la versi\u00f3n 0.12.1 que la comunidad estaba esperando desde hac\u00eda 2 a\u00f1os, sin embargo y por la premura y sorpresa de io.js sali\u00f3 con un par de errores por lo que tuvieron que lanzar una versi\u00f3n 0.12.2 en cuesti\u00f3n de d\u00edas. Con ello Joyent logra mantener la paridad de caracter\u00edsticas con io.js. Es importante mencionar que todo esto sucede en diciembre del 2014 y io.js se libera oficialmente el 13 de enero del 2015. Despu\u00e9s de un par de meses de la liberaci\u00f3n de io.js, ambas partes, comunidad y Joyent manifiestan su intenci\u00f3n de reconciliar los proyectos en uno s\u00f3lo, la fundaci\u00f3n Linux se ofrece como mediador de la situaci\u00f3n y entonces el 8 de mayo del 2015 se crea la Node.js Foundation encargada de reunificar las tecnolog\u00edas en una sola, dicho proyecto lo llamaron Node.js Convergence.</p> <p>Los objetivos de dicha fundaci\u00f3n eran claros:</p> <ul> <li>Crear un consejo de fundaci\u00f3n encargado de la parte legal, marca, mercadotecnia y fondos gestionado por Joyent.</li> <li>Crear un comit\u00e9 t\u00e9cnico que actu\u00e9 de forma independiente y permita el crecimiento del ecosistema JS en el servidor gestionado por la comunidad.</li> <li>Normalizar y unificar las versiones actuales de Node.js\u2122 (0.12.X) y io.js (3.X.X) en una sola tecnolog\u00eda.</li> </ul> <p>Finalmente el 8 de septiembre del 2015 sale a la luz esa convergencia en Node 4.0.0 (estable) y con ello un futuro interesante para JavaScript en el servidor.</p> <p>Desde su nacimiento de io.js se fueron liberando versiones semanales hasta llegar a la versi\u00f3n 3.3.0, en consideraci\u00f3n a esta evoluci\u00f3n y al fuerte compromiso de la comunidad activa que se matuvo viva y fuerte por hacer crecer el ecosistema de JavaScript en el servidor es que se decide relanzar Node en la versi\u00f3n 4.0.0.</p>"},{"location":"tema_1/page-1/#instalacion","title":"Instalaci\u00f3n","text":"<p>Para instalar Node JS existen dos formas para poder realizarlo. La primera de ellas, es ir directamente a la p\u00e1gina oficial de Node JS. En este m\u00e9todo tenemos que tener que diferencias dos tipos de versiones:</p> <ul> <li>Versi\u00f3n LTS (Long-term supported): Esta versi\u00f3n es la recomendada por lo mismo desarrolladores de Node JS, ya que es la versi\u00f3n estable, la cual permite obtener la \u00faltima versi\u00f3n con un mejor soporte y con mayor duraci\u00f3n de la misma.</li> <li>Versi\u00f3n Actual: Esta es la \u00faltima versi\u00f3n oficial de Node JS, pero al ser la \u00faltima y la m\u00e1s nueva puede que algunas funciones no funcionen como deber\u00edan, lo que hace que no sea una versi\u00f3n estable.</li> </ul> <p>A veces, trabajamos con tantos proyectos a la vez que cada uno de ellos se ejecuta en una versi\u00f3n diferente de Node JS, esto puede acarrear problemas, por ello existen diferentes manejadores que permiten tener en un mismo sistema operativo diferentes versiones de Node JS, de esta forma poder tener diferentes proyectos con diferentes versiones.</p> <p>Una de las m\u00e1s conocidas es nvm, que puede ser instalado en Linux y MacOS (para Windows existe una versi\u00f3n espec\u00edfica nvm-windows) y fnm es otra de las recomendadas.</p> <p>Otra forma de poder tener diferentes versiones en diferentes proyectos es haciendo uso de la dockerizaci\u00f3n a trav\u00e9s de contenedores Docker.</p>"},{"location":"tema_1/page-1/#primeros-pasos","title":"Primeros Pasos","text":"<p>Una vez instalada Node JS con el m\u00e9todo elegido, podemos comprobar que todo est\u00e1 correctamente instalado haciendo uso del siguiente comando:</p> <pre><code>node --version # v18.17.0\n</code></pre> <p>Haciendo uso del comando <code>node</code> se nos habilitar\u00e1 la consola de Node JS la cual, a trav\u00e9s del repl (bucle infinito que va tramitando el Javascript que se va solicitando) nos permitir\u00e1 ejecutar c\u00f3digo Javascript sin necesidad de almacenarlo en ning\u00fan fichero.</p> <pre><code>&gt; const saludo = \"Hola Mundo\"\nundefined\n&gt; console.log(saludo)\nhola\nundefined\n&gt; function suma(a,b){ return a + b }\nundefined\n&gt; console.log(suma(1,2))\n3\nundefined\n&gt;\n</code></pre> <p>Haciendo uso del comando <code>node FILE_NAME.js</code>, donde FILE_NAME es el nombre del fichero donde se almacena el c\u00f3digo Javascript, se puede ejecutar el c\u00f3digo incrustado en el fichero desde la misma consola.</p> FicheroConsola <pre><code>const saludo = \"Hola mundo\"\nconst suma = (a, b) =&gt; a + b\nconsole.log(saludo)\nconsole.log(suma(1, 2))\n</code></pre> <pre><code>&gt; node index.js\nHola mundo\n3\n</code></pre>"},{"location":"tema_1/page-1/#variable-globalthis","title":"Variable globalThis","text":"<p>Cuando ejecutamos un archivo Javascript desde el navegador la variable global es la variable <code>window</code>, con la cual podemos acceder a otras variables y m\u00e9todos como <code>console</code>, <code>document</code>, etc. pero cuando se ejecuta Javascript desde la consola Node JS no podemos acceder a la variable<code>window</code> ya que es una variable del navegador. \u00bfEntonces como se puede acceder al objeto <code>console</code> si no se puede acceder a <code>window</code>? La variable global para la consola es <code>global</code>.</p> <p>La variable global <code>globalThis</code> es la variable global que se utiliza para acceder a la variable global del entorno en el que se ejecute Javascript desde Node JS. De esta forma se puede acceder a las propiedades, objetos y m\u00e9todos como <code>console</code>. Si ejecutamos Node JS desde la consola accederemos a la variable global <code>global</code> y si lo ejecutamos en el navegador apuntar\u00e1 a <code>window</code>. Por eso es importante que cada vez que se quiera acceder a la variable global desde Node JS se use <code>globalThis</code>.</p> <p>Warning</p> <p>Si estamos ejecutando una aplicaci\u00f3n de consola con Node JS no es recomendable usar <code>global</code> ya que puede crear confusi\u00f3n con la variable <code>globalThis</code>que es la que se recomienda usar para as\u00ed evitar errores.</p>"},{"location":"tema_1/page-2/","title":"2 Modularizaci\u00f3n","text":""},{"location":"tema_1/page-2/#patron-de-diseno-modulo","title":"Patr\u00f3n de dise\u00f1o m\u00f3dulo","text":"<p>El patr\u00f3n de dise\u00f1o m\u00f3dulo tiene como objetivo separar el c\u00f3digo Javascript en diferentes m\u00f3dulos (a veces en diferentes ficheros), de tal modo que el c\u00f3digo sea m\u00e1s legible, entendible, reusable y f\u00e1cil de acceder.</p> <p>Podemos entender como un m\u00f3dulo una funci\u00f3n que se comporta como un contenedor para un contexto de ejecuci\u00f3n. Dentro de est\u00e1 funci\u00f3n se pueden declarar diferentes variables.</p> <p>Lo primero que debemos hacer es crear una funci\u00f3n global con el c\u00f3digo que quiero reutilizar, por ejemplo variables y otros m\u00e9todos.</p> <pre><code>function myApp() {\nvar number = 0, letter = 'A'\nfunction apply(increment){\nreturn number + increment\n}\n}\n</code></pre> <p>La funci\u00f3n deber\u00e1 devolver un objeto con el nombre de acceso a las variables y a los m\u00e9todos que contiene, de esta manera se podr\u00e1n acceder a ellos fuera de la misma funci\u00f3n:</p> <pre><code>function myApp() {\nvar number = 0, letter = 'A'\nfunction apply(increment){\nreturn number + increment\n}\nreturn {\nnumber: number,\nletter: letter,\napply: apply\n}\n}\n</code></pre> <p>Como se puede observar el objeto debe tener un nombre para poder acceder a \u00e9l fuera de la funci\u00f3n <code>myApp</code>. Si el nombre de la variable y/o m\u00e9todo es el mismo se puede omitir escribi\u00e9ndolo una \u00fanica vez.</p> <pre><code>function myApp() {\nvar number = 0, letter = 'A'\nfunction apply(increment){\nreturn number + increment\n}\nreturn { number, letter, apply }\n}\n</code></pre> <p>De esta forma podemos crear variables y m\u00e9todos que sean p\u00fablicos o privados. Los p\u00fablicos son los que retornamos e incluimos en el objeto y los privados son los que no retornamos.</p> <pre><code>function myApp() {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n}\n</code></pre> <p>Adem\u00e1s para poder acceder al m\u00f3dulo primero habr\u00e1 que invocar la funci\u00f3n:</p> <pre><code>function myApp() {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n}\nconst variable = myApp()\nconsole.log(variable.number) // 0\nconsole.log(variable.letter) // A\nconsole.log(variable.apply(10)) // 10\n</code></pre> <p>Esto se puede simplificar realizando la autoinvocaci\u00f3n, es decir, creando la funci\u00f3n y luego usando <code>()</code> para invocarla. Para ello la funci\u00f3n tiene que estar entre par\u00e9ntesis para que primero se cree y luego se invoque:</p> <pre><code>const variable = (function myApp() {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n})()\nconsole.log(variable.number) // 0\nconsole.log(variable.letter) // A\nconsole.log(variable.apply(10)) // 10\n</code></pre> <p>Se puede reducir m\u00e1s haciendo uso de las arrow functions con autoinvocaci\u00f3n:</p> <pre><code>const myApp = (() =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n})()\nconsole.log(myApp.number) // 0\nconsole.log(myApp.letter) // A\nconsole.log(myApp.apply(10)) // 10\n</code></pre> <p>Una de las ventajas que tiene la modularizaci\u00f3n es que se puede usar la destructuraci\u00f3n para acceder a las variables y m\u00e9todos internos del m\u00f3dulo:</p> <pre><code>const myApp = (() =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n})()\nconst {number, letter, apply} = myApp\nconsole.log(number) // 0\nconsole.log(letter) // A\nconsole.log(apply(10)) // 10\n</code></pre> Ejercicio 1 <p>Realiza una aplicaci\u00f3n con Javascript la cual realice las operaciones b\u00e1sicas: sumar, restar, multiplicar y dividir. Haciendo uso del patr\u00f3n de m\u00f3dulos, pon a prueba las funciones creadas.</p>"},{"location":"tema_1/page-2/#importar-y-exportar","title":"Importar y exportar","text":"<p>Para poder usar las variables y los m\u00e9todos de un fichero Javascript en otro fichero en Node JS es necesario exportar el c\u00f3digo en el fichero de la funci\u00f3n que se desea reutilizar e importarlo en el fichero que se desea usar.</p> <p>En Node JS existen dos maneras de realizar dichas operaciones, una m\u00e1s convencional y antigua pero que a\u00fan as\u00ed sigue en uso actualmente, denominada CommonJS, y otra m\u00e1s moderna que hace uso del ECMAScript 6 (ES6). El problema de la segunda es que de forma nativa no se puede usar con archivos .js si no con archivos .mjs, aunque existe una forma de poder utilizarlo en Node JS que veremos m\u00e1s adelante.</p>"},{"location":"tema_1/page-2/#commonjs","title":"CommonJS","text":"<p>Para poder exportar una funci\u00f3n dentro de un fichero Javascript es necesario usar module.export:</p> <pre><code>const myApp = (() =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n})()\nmodule.exports = myApp\n</code></pre> <p>N\u00f3tese, que la autoinvocaci\u00f3n desaparece ya que se puede realizar posteriormente. Incluso se puede exportar de forma directa:</p> <pre><code>module.exports = () =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n}\n</code></pre> <p>Para importar el m\u00f3dulo se usa la funci\u00f3n require cuyo par\u00e1metro es la ruta relativa en la que se encuentra el fichero:</p> <pre><code>const myApp = require('myApp')\nconst variable = myApp()\nconsole.log(variable.numero) // 0\n</code></pre> <p>Se puede realizar la exportanci\u00f3n de m\u00e1s m\u00f3dulos haciendo indicando el nombre:</p> myApp.jsmain.jsmain.js II <pre><code>module.exports.moduleA = () =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n}\nmodule.exports.moduleB = () =&gt; {\nreturn {\nsum: (a, b) =&gt; a + b,\nmin: (a, b) =&gt; Maths.min(a, b)\n}\n}\n</code></pre> <pre><code>const moduleA = require('myApp.js').moduleA    const moduleB = require('myApp.js').moduleB\nmoduleA()\nmoduleB()\n</code></pre> <pre><code>const { moduleA } = require('myApp.js')    const { moduleB } = require('myApp.js')\nmoduleA()\nmoduleB()\n</code></pre> <p>Hacer esto es lo mismo que unir ambos m\u00f3dulos en uno solo.</p> <pre><code>module.exports = () =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b const min = Maths.min(a, b)\nfunction apply(increment){\nreturn sum(number, increment)\n}\nreturn { moduleA : { number, letter, apply },\nmoduleB : { sum, min }\n}\n}\n</code></pre> <p>En Node JS, cuando todas las funciones son p\u00fablicas y dem\u00e1s se puede crear las funciones de forma independiente y luego exportar un \u00fanico objeto con todas las funciones necesarias. La ventaja de usar este forma es que no ser\u00e1 necesario invocar ninguna funci\u00f3n en el lugar que se use los m\u00e9todos o variables del m\u00f3dulo:</p> myApp.jsindex.js <pre><code>const sum = (a, b) =&gt; a + b\nconst div = (a, b) =&gt; a / b\nconst PI = 3.14\nmodule.exports = { sum, div, pi: PI}\n</code></pre> <pre><code>const { sum, pi } = require(\"myApp.js\")\nconsole.log(sum(1, 2)) // 3\nconsole.log(pi) // 3.14 \n</code></pre> <p>Info</p> <p>Con el uso de <code>require</code> no es obligatorio indicar la extensi\u00f3n del archivo a importar</p> Ejercicio 2 <p>Realiza el mismo ejercicio anterior en fichero myApp, exportalos como creas conveniente haciendo uso del CommonJS y util\u00edzalo dentro del fichero index</p>"},{"location":"tema_1/page-2/#ecmascript-6-es6","title":"ECMAScript 6 (ES6)","text":"<p>En Node JS, en principio, para poder usar la importaci\u00f3n y la exportaci\u00f3n del ECMas Script 6 (ES6) ser\u00e1 necesario usar la extensi\u00f3n del fichero <code>.mjs</code>en lugar de <code>.js</code></p> <p>Para poder exportar una funci\u00f3n, o directamente un objeto como en el apartado anterior, se realizar\u00e1 con la palabra reservada export:</p> <pre><code>const sum = (a, b) =&gt; a + b\nexport { sum }\n</code></pre> <p>Para poder importarla ser\u00eda necesario usar la palabra reservada import ... from ...:</p> <pre><code>import module from 'myApp.msj'\nconsole.log(module.sum(1, 2)) // 3\n</code></pre> <p>En vez de usar el nombre del m\u00f3dulo, tambi\u00e9n se puede destructurar:</p> <pre><code>import { sum } from 'myApp.msj'\nconsole.log(sum(1, 2)) // 3\n</code></pre> <p>Si se desea importar todos los m\u00e9todos y variables del m\u00f3dulo haciendo uso de la destructuraci\u00f3n se puede indicar <code>*</code>:</p> <pre><code>import * from 'myApp.msj'\nconsole.log(sum(1, 2)) // 3\n</code></pre> <p>Warning</p> <p>Ten en cuenta que en la importaci\u00f3n del ES6 SI es obligatorio indicar la extensi\u00f3n del archivo. Esto supone un problema, porque tecnolog\u00edas que usan Node JS como Webpack, React, etc., no hay que indicarlo ya que impl\u00edcitamente se encargan de indicarlo.</p> <p>Tambi\u00e9n se puede mezclar en un mismo proyectos ficheros <code>.js</code> con la exportaci\u00f3n CommonJS con ficheros <code>.mjs</code> con la exportaci\u00f3n ES6, aunque no es recomendable.</p> Ejercicio 3 <p>Realiza el mismo ejercicio anterior en fichero myApp, exportalos como creas conveniente haciendo uso del ES6 y util\u00edzalo dentro del fichero index</p>"},{"location":"tema_1/page-3/","title":"3 M\u00f3dulos Nativos","text":""},{"location":"tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Al instalar Node JS en nuestro ordenador, se instala con \u00e9l una cantidad de m\u00f3dulos predeterminados que podemos usar en nuestros proyectos. Como por ejemplo, un m\u00f3dulo para manejar ficheros, otro m\u00f3dulo para conocer las caracter\u00edsticas del sistema, etc.</p> <p>Cuando se va importar un m\u00f3dulo nativo Node JS, desde la versi\u00f3n 16, se recomienda usar el prefijo <code>node</code> antes del nombre del m\u00f3dulo:</p> CommonJSES6 <pre><code>const variable = require('node:fs')\n</code></pre> <pre><code>import * from 'node:fs'\n</code></pre>"},{"location":"tema_1/page-3/#os-info","title":"OS info","text":"<p>Este m\u00f3dulo permite conocer informaci\u00f3n del sistema operativo en el que se est\u00e1 ejecutando el fichero Javascript. Algunos de sus m\u00e9todos importantes son:</p> <ul> <li><code>arch()</code>: Retorna la arquitectura del sistema en el que se est\u00e1 compilando el fichero Node JS. Puede devolver por ejemplo,arm,arm64,x64, etc.</li> <li><code>cpus()</code>: Retorna un array con la informaci\u00f3n de cada CPU. El array puede estar vac\u00edo si no se puede obtener informaci\u00f3n.</li> <li><code>homedir()</code>: Retorna la ruta de la carpeta principal del usuario actual.</li> <li><code>hostname()</code>: Retorna el nombre del sistema.</li> <li><code>platform()</code>: Retorna la plataforma del sistema operativo en el que se ejecuta, como linux, win32, etc.</li> <li><code>type()</code>: Retorna el tipo de sistema operativo: Linux, Windows_NT.</li> <li><code>uptime()</code>: Retorna en segundos el tiempo en el que el sistema ha estado activo.</li> <li><code>version()</code>: Retorna la versi\u00f3n del kernel.</li> </ul> CommonJSES6 <pre><code>const os = require('node:os') // Importaci\u00f3n con el prefijo node RECOMENDADO\nconsole.log('Informaci\u00f3n del sistema operativo:')\nconsole.log('-------------------')\nconsole.log('Nombre del sistema operativo', os.platform())\nconsole.log('Versi\u00f3n del sistema operativo', os.release())\nconsole.log('Arquitectura', os.arch())\nconsole.log('CPUs', os.cpus())\nconsole.log('Memoria libre', os.freemem() / 1024 / 1024)\nconsole.log('Memoria total', os.totalmem() / 1024 / 1024)\nconsole.log('uptime', os.uptime() / 60 / 60)\n</code></pre> <pre><code>import { platform, release, arch, cpus, freemem, totalmem, uptime } from 'node:os' // Importaci\u00f3n con el prefijo node RECOMENDADO\nconsole.log('Informaci\u00f3n del sistema operativo:')\nconsole.log('-------------------')\nconsole.log('Nombre del sistema operativo', platform())\nconsole.log('Versi\u00f3n del sistema operativo', release())\nconsole.log('Arquitectura', arch())\nconsole.log('CPUs', cpus())\nconsole.log('Memoria libre', freemem() / 1024 / 1024)\nconsole.log('Memoria total', totalmem() / 1024 / 1024)\nconsole.log('uptime', uptime() / 60 / 60)\n</code></pre>"},{"location":"tema_1/page-3/#process","title":"Process","text":"<p>Process es un m\u00f3dulo nativo de Node JS que permite tratar con el proceso actual, es decir, el que ejecuta el archivo Javascript, es decir, el <code>node index.js</code>.</p> <p>Al realizar la ejecuci\u00f3n del archivo js podemos pasarle par\u00e1metros seguidos del nombre del archivo. Con el atributo <code>args</code> se obtiene un array con todos los par\u00e1metros, donde el primer elemento <code>args(0)</code> corresponde a archivo de ejecuci\u00f3n de node, y el segundo elemento <code>args(1)</code> se corresponde a el nombre del archivo que se est\u00e1 ejecutando. A partir de este n\u00famero se puede obtener todos los argumentos que se pueden obtener.</p> ConsolaJavascriptSalida <pre><code>node argv.js Hola mundo\n</code></pre> <pre><code>const { argv } = require('node:process')\nargv.forEach(arg =&gt; console.log(arg))\n</code></pre> <pre><code>C:\\Users\\user\\AppData\\Local\\fnm_multishells\\7824_1691140862198\\node.exe\nD:\\user\\NodeJSProjects\\tests\\05-process\\argv.js\nHola\nmundo\n</code></pre> <p>Con el m\u00e9todo <code>exit(n)</code> se puede terminar el proceso actual con el n\u00famero n que indica como ha finalizado el proceso. Normalmente se usa 0 cuando el proceso ha terminado con \u00e9xito (sin errores), mientras que se elige otro n\u00famero para indicar cualquier error.</p> <p>Al ser Javascript un lenguaje orientado a evento, podemos escuchar el evento <code>exit</code> para poder hacer algo cuando se finalice el proceso actual, como por ejemplo hacer una limpieza de los recursos:</p> <pre><code>const process = require('node:process')\n// Obtenemos un n\u00famero de la consola de comando,\n// si no se indica ninguno obtenemos el n\u00famero 0\nconst num = process.argv[2] ?? 0\nif (num == 0) {\nprocess.on('exit', () =&gt; {\nconsole.error('Ha habido un error ! Tenemos que irnos')\n})\nprocess.exit(1) // Si no se indica n\u00famero se sale del proceso con error\n}\nconsole.log(num)\n</code></pre> <p>Con <code>cwd()</code> podemos obtener la ruta actual de donde estamos ejecutando el archivo Javascript</p> <pre><code>const { cwd } = require('node:process')\nconsole.log(cwd())\n</code></pre> <p>Las variables de entorno son constantes que se utilizan durante la ejecuci\u00f3n de un programa. Para definir una variable de entorno con Node JS hay que preceder <code>NOMBRE=valor</code> antes del <code>node archivo.js</code>, donde NOMBRE es el valor del nombre de la variable, que suele ir en may\u00fasculas al ser una constante, y valor es el valor de dicha variable.</p> <p>Para poder leer una variable de entorno, podemos usar la variable <code>env</code> del m\u00f3dulo process, seguido del nombre de la variable: <code>process.env.NOMBRE</code></p> ConsolaJavascript <pre><code>SALUDO=\"HOLA MUNDO\" index env.js\n</code></pre> <pre><code>const process = require('node:process')\nconsole.log(process.env.SALUDO) // HOLA MUNDO\n</code></pre> Ejercicio <p>Realiza una aplicaci\u00f3n \"info.js\" que pueda recibir hasta 2 par\u00e1metros en su llamada. Si no recibe ning\u00fan par\u00e1metros mostrar\u00e1 una informaci\u00f3n completa del sistema operativo actual.</p> <p>El primer par\u00e1metro a recibir es la palabra -m que mostrar\u00e1 la memoria en GB. El segundo par\u00e1metro a recibir es la palabra -o que mostrar\u00e1 el nombre del sistema operativo y su versi\u00f3n.</p> <p>Se puede utilizar los dos par\u00e1metros a la vez (-m -o), o simplemente uno. Sin embargo, hay que tener en cuenta si recibe como par\u00e1metro algo diferente a lo indicado anteriormente saldr\u00e1 de la aplicaci\u00f3n mostrando un mensaje de error.</p>"},{"location":"tema_1/page-4/","title":"4 Ficheros","text":""},{"location":"tema_1/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>En Javascript no se puede trabajar con ficheros de forma nativa, pero gracias a Node JS y su m\u00f3dulo fs es posible poder trabajar con ficheros.</p> <p>En Node JS se trabaja con ficheros de tres formas diferentes:</p> <ul> <li>Haciendo uso de la programaci\u00f3n s\u00edncrona.</li> <li>Haciendo uso de la programaci\u00f3n as\u00edncrona con callbacks.</li> <li>Haciendo uso de la programaci\u00f3n as\u00edncrona con await.</li> <li>Haciendo uso de la programaci\u00f3n as\u00edncrona con promesas.</li> </ul> <p>Algunos m\u00e9todos del m\u00f3dulo tiene su versi\u00f3n s\u00edncrona y su versi\u00f3n as\u00edncrona: <code>readFile()</code>, <code>readFileSync()</code>.</p>"},{"location":"tema_1/page-4/#informacion-de-un-fichero","title":"Informaci\u00f3n de un fichero","text":"<p>El m\u00e9todo <code>statSync(path)</code> devuelve informaci\u00f3n relativa de un fichero en un objeto de tipo <code>Stat</code> de forma s\u00edncrona, mientras que <code>stat(path)</code> devuelve la misma informaci\u00f3n pero de forma as\u00edncrona. El atributo path es la ruta relativa o absoluta del fichero a comprobar.</p> <p>Algunos m\u00e9todos interesantes de la clase <code>Stat</code>:</p> <ul> <li><code>isDirectory()</code>: Comprueba si la ruta pertenece a un directorio.</li> <li><code>isFile()</code>: Comprueba si la ruta pertenece a un fichero.</li> <li><code>isSymbolicLink()</code>: Comprueba si es un enlace simb\u00f3lico.</li> <li><code>size</code>: Devuelve el tama\u00f1o del fichero en bytes.</li> </ul> <p>Info</p> <p>Para conocer m\u00e1s m\u00e9todos y atributos de la clase <code>Stat</code>: https://nodejs.org/api/fs.html#class-fsstats</p> S\u00edncronoAs\u00edncrono <pre><code>const fs = require('node:fs') // a partir de Node 16, se recomienda poner node:\nconst stats = fs.statSync('../README.md')\nconsole.log(\nstats.isFile(), // si es un fichero\nstats.isDirectory(), // si es un directorio\nstats.isSymbolicLink(), // si es un enlace simb\u00f3lico\nstats.size // tama\u00f1o en bytes\n)\n</code></pre> <pre><code>const fs = require('node:fs') // a partir de Node 16, se recomienda poner node:\nfs.stat('../README.md', (error, stat) =&gt; console.log(\nstat.isFile(), // si es un fichero\nstat.isDirectory(), // si es un directorio\nstat.isSymbolicLink(), // si es un enlace simb\u00f3lico\nstat.size // tama\u00f1o en bytes\n))\n</code></pre>"},{"location":"tema_1/page-4/#leer-un-fichero","title":"Leer un fichero","text":"<p>Para leer un fichero de forma s\u00edncrona existe el m\u00e9todo <code>readFileSync(path)</code>, donde path es la ruta relativa o absoluta del fichero a leer.</p> <p>Danger</p> <p>Si en lugar de indicar un fichero existente, si indica un fichero inexistente o un directorio, lanzar\u00e1 una excepci\u00f3n.</p> <pre><code>const fs = require('node:fs')\nconsole.log('Leyendo el archivo en binario...')\nlet text = fs.readFileSync('./archivo.txt')\nconsole.log(text)\n</code></pre> <p>El m\u00e9todo devuelve la informaci\u00f3n del fichero en binario, para poder evitar esto se puede indicar un segundo par\u00e1metro con el tipo de codificaci\u00f3n, como por ejemplo <code>utf-8</code></p> <pre><code>const fs = require('node:fs')\nconsole.log('Leyendo el archivo...')\nlet text = fs.readFileSync('./archivo2.txt', 'utf-8')\nconsole.log(text)\n</code></pre> <p>Para poder leer una archivo de forma as\u00edncrona se una el m\u00e9todo <code>readFile(path)</code>:</p> <pre><code>const fs = require('node:fs')\nconsole.log('Leyendo el primer archivo...')\nfs.readFile('./archivo.txt', 'utf-8', (err, text) =&gt; { // &lt;---- ejecutas este callback\nconsole.log('primer texto:', text)\n})\nconsole.log('--&gt; Hacer cosas mientras lee el archivo...')\nconsole.log('Leyendo el segundo archivo...')\nfs.readFile('./archivo2.txt', 'utf-8', (err, text) =&gt; {\nconsole.log('segundo texto:', text)\n})\n</code></pre> <p>En la mayor\u00eda de m\u00f3dulos que trabajan de forma as\u00edncrona existe una version con promesas. Para poder usarla es necesario importar el mismo m\u00f3dulo seguido de <code>/promises</code>.</p> CommonJsES6 <pre><code>const { readFile } = require('node:fs/promises')\nasync function init() {\nconsole.log('Leyendo el primer archivo...')\nconst text = await readFile('./archivo.txt', 'utf-8')\nconsole.log('primer texto:', text)\nconsole.log('--&gt; Hacer cosas mientras lee el archivo...')\nconsole.log('Leyendo el segundo archivo...')\nconst secondText = await readFile('./archivo2.txt', 'utf-8')\nconsole.log('segundo texto:', secondText)\n}\ninit()\n</code></pre> <pre><code>// Esto s\u00f3lo en los m\u00f3dulos nativos\n// que no tienen promesas nativas\n// const { promisify } = require('node:util')\n// const readFilePromise = promisify(fs.readFile)\nimport { readFile } from 'node:fs/promises'\nconsole.log('Leyendo el primer archivo...')\nconst text = await readFile('./archivo.txt', 'utf-8')\nconsole.log('primer texto:', text)\nconsole.log('--&gt; Hacer cosas mientras lee el archivo...')\nconsole.log('Leyendo el segundo archivo...')\nconst secondText = await readFile('./archivo2.txt', 'utf-8')\nconsole.log('segundo texto:', secondText)\n</code></pre> <p>Como se puede observar con el CommonJS al usar await se ha tenido que envolver el c\u00f3digo en una funci\u00f3n. Esto se debe porque no existe el soporte con el await en funciones top-level, por lo que es necesario el uso de una funci\u00f3n async que contenga el await. Esta es otra de las mejoras que se tiene con ES6, en el cual no es necesario realizar esa operaci\u00f3n, ya que si existe soporte del await en funciones top-level.</p> <p>El c\u00f3digo de Common JS** se puede mejor haciendo uso del **IIFE (*Immediately Invoked function Expression)**.</p> <pre><code>const { readFile } = require('node:fs/promises')\n// IIFE - Immediately Invoked Function Expression\n; (\nasync () =&gt; {\nconsole.log('Leyendo el primer archivo...')\nconst text = await readFile('./archivo.txt', 'utf-8')\nconsole.log('primer texto:', text)\nconsole.log('--&gt; Hacer cosas mientras lee el archivo...')\nconsole.log('Leyendo el segundo archivo...')\nconst secondText = await readFile('./archivo2.txt', 'utf-8')\nconsole.log('segundo texto:', secondText)\n}\n)()\n</code></pre> <p>Warning</p> <p>Como se puede observar en el ejemplo, antes del uso de la funci\u00f3n IIFE, se ante pone un <code>;</code>. Esto es necesario y obligatorio en este caso, ya que si no s\u00e9 usa el compilar entiende que forma parte de la funci\u00f3n anterior, en este caso <code>require</code>, y por lo tanto dar\u00e1 error.</p> <p>Se puede colocar antes del uso de la funci\u00f3n tal y como aparece en el ejemplo:</p> <pre><code>const { readFile } = require('node:fs/promises')\n;() {\n//...\n}\n</code></pre> <p>O, tambi\u00e9n puede ir con la l\u00ednea anterior:</p> <pre><code>const { readFile } = require('node:fs/promises');\n() {\n//...\n}\n</code></pre> <p>Los m\u00f3dulos que no traen de forma nativa las promesas se puede hacer uso del m\u00e9todo <code>promisify</code> del m\u00f3dulo <code>util</code> que recibe el m\u00e9todo as\u00edncrono, el cual se desea usar con promesas.</p> <pre><code>const { promisify } = require('node:util')\nconst readFilePromise = promisify(fs.readFile)\n</code></pre> <p>Por otro lado, si no se quiere usar await, se puede seguir haciendo uso de promesas utilizando el m\u00e9todo <code>then</code>:</p> <pre><code>const fs = require('node:fs/promises')\nconsole.log('Leyendo el primer archivo...')\nfs.readFile('./archivo.txt', 'utf-8')\n.then(text =&gt; {\nconsole.log('primer texto:', text)\n})\nconsole.log('--&gt; Hacer cosas mientras lee el archivo...')\nconsole.log('Leyendo el segundo archivo...')\nfs.readFile('./archivo2.txt', 'utf-8')\n.then(text =&gt; {\nconsole.log('segundo texto:', text)\n})\n</code></pre> <p>Por \u00faltimo, podemos unir la lectura de m\u00e1s de dos ficheros haciendo uso del m\u00e9todo <code>Promises.all()</code>, de esta forma se ejecutaran de forma paralela:</p>"},{"location":"tema_1/page-4/#escribir-ficheros","title":"Escribir ficheros","text":"<p>Para escribir ficheros de forma s\u00edncrona se utiliza el m\u00e9todo <code>writeFileSync(file, data, options)</code> donde:</p> <ul> <li>file es la ruta del fichero a escribir.</li> <li>data es la informaci\u00f3n que se quiere a\u00f1adir (puede ser una cadena o un buffer).</li> <li>options puede ser una cadena o un objeto con las opciones a indicar, como el encoding, que por defecto es utf-8</li> </ul> <pre><code>const fs = require('node:fs')\nconst msg = \"Esto es un fichero que se ha escrito con Node JS\"\nconsole.log(\"Escribiendo en el fichero\")\nfs.writeFileSync(\"archivo.txt\", msg)\n</code></pre> <p>Si escribimos en el fichero m\u00e1s de una vez, lo que va a ocurrir es que el contenido del fichero va a ser sobrescrito y no a\u00f1adido al final. Para poder solucionar este problema, hay que indicarle como opci\u00f3n <code>a+</code> en el atributo <code>flag</code>:</p> <pre><code>const fs = require('node:fs')\nconst otherText = \"\\nSe esta a\u00f1adiendo otro texto\"\nconsole.log(\"A\u00f1adiendo m\u00e1s texto\")\nfs.writeFileSync(\"archivo.txt\", otherText, { flag: 'a+' })\n</code></pre> <p>La versi\u00f3n as\u00edncrona para escribir archivos es <code>writeFile()</code>, adem\u00e1s tiene su versi\u00f3n en <code>fs/promises</code></p> CallbacksAwait con Common JsAwait con ES 6Promises <pre><code>const fs = require('node:fs')\nconsole.log(\"Escribiendo en el fichero\")\nconst msg = \"Esta l\u00ednea ha sido escrito con Node JS de forma as\u00edncrona\\n\"\nfs.writeFile(\"archivo.txt\", msg, { flag: 'a+' }, console.log)\nconsole.log(\"Terminado de escribir\")\n</code></pre> <pre><code>const { writeFile } = require('node:fs/promises')\n; (async () =&gt; {\nconsole.log(\"Escribiendo en el fichero\")\nconst msg = \"Esta l\u00ednea ha sido escrito con Node JS de forma as\u00edncrona con await y CommonJS\\n\"\nawait writeFile(\"archivo.txt\", msg, { flag: 'a+' })\nconsole.log(\"Terminado de escribir\")\n})()\n</code></pre> <pre><code>import { writeFile } from 'node:fs/promises'\nconsole.log(\"Escribiendo en el fichero\")\nconst msg = \"Esta l\u00ednea ha sido escrito con Node JS de forma as\u00edncrona con await y ES6\\n\"\nawait writeFile(\"archivo.txt\", msg, { flag: 'a+' })\nconsole.log(\"Terminado de escribir\")\n</code></pre> <pre><code>const { writeFile } = require('node:fs/promises')\nconsole.log(\"Escribiendo en el fichero\")\nconst msg = \"Esta l\u00ednea ha sido escrito con Node JS de forma as\u00edncrona con promesas\\n\"\nwriteFile(\"archivo.txt\", msg, { flag: 'a+' }).then(() =&gt; {\nconsole.log(\"Terminado de escribir\")\n})\n</code></pre> Ejercicio 1 <p>Realiza una aplicaci\u00f3n llamada cpFile.js la cual pueda recibir como par\u00e1metros dos rutas de dos ficheros. El objetivo de la aplicaci\u00f3n es copiar el contenido del primer fichero en el segundo fichero. Si el segundo fichero ya existe, sobrescribir\u00e1 el fichero.</p> <p>Si recibe menos de 2 ficheros, se saldr\u00e1 de la aplicaci\u00f3n mostrando un mensaje de error.</p>"},{"location":"tema_1/page-4/#listar-ficheros","title":"Listar ficheros","text":"<p>Para poder mostrar todos los ficheros de un directorio se puede usar el m\u00e9todo <code>readdir()</code> del m\u00f3dulos fs:</p> <pre><code>const { readdir } = require('node:fs')\nconst process = require('node:process')\nreaddir('../', (err, files) =&gt; {\nif (err) {\nconsole.error('Ha habido un error:', err)\nprocess.exit(1)\n}\nfiles.forEach(console.log)\n})\n</code></pre> <p>Info</p> <p>Para conocer m\u00e1s m\u00e9todo que trabajando con ficheros visita https://nodejs.org/api/fs.html</p>"},{"location":"tema_1/page-4/#modulo-path","title":"M\u00f3dulo Path","text":"<p>El m\u00f3dulo Path es un m\u00f3dulo que se trabaja con rutas de formas sencilla. Es m\u00f3dulo incluido entre los m\u00f3dulos nativos de Node JS por lo que no necesita instalaci\u00f3n.</p> <p>Depende del sistema operativo en el que ejecutemos nuestro programa javascript las rutas son separadas de forma diferente. Por ejemplo en Windows se usa el separador <code>\\</code> mientras que en Linux <code>/</code>. Este m\u00f3dulo contiene un atributo <code>sep</code> que obtiene el separador de la ruta.</p> <p>No se recomienda crear una ruta directamente, ya que esto puede suponer un error dependiendo del entorno donde se ejecute, por lo que se recomienda usar esta librer\u00eda con sus m\u00e9todos y atributos. Por ejemplo:</p> <pre><code>const path = require('node:path') // Se importa path\nconst sep = path.sep // Se obtiene el separador del OS\nconsole.log(`files${sep}archivo.txt`)\n</code></pre> <p>En ese ejemplo puede mostrar files/archivo.txt si estamos trabajando en Linux o files\\archivos.txt si estamos trabajando en Windows.</p> <p>El ejemplo anterior se puede optimizar haciendo uso del m\u00e9todo <code>join()</code> que recibe todas las partes de la ruta y devuelve una cadena con la ruta unida junto con el separador:</p> <pre><code>const path = require('node:path') // Se importa path\nconsole.log(path.join('files', 'archivo.txt'))\n</code></pre> <p>Con el m\u00e9todo <code>basename()</code> podemos obtener el nombre base del archivo. Por ejemplo, si nosotros tenemos la ruta de files/archivo.txt, devolver\u00e1 archivos.txt. Tambi\u00e9n recibe un segundo par\u00e1metro para obtener el nombre sin la extensi\u00f3n, debi\u00e9ndose pasar la extensi\u00f3n a eliminar:</p> <pre><code>const path = require('node:path') // Se importa path\nconst myPath = path.join('files', 'archivo.txt')\nconsole.log(path.basename(myPath)) // archivo.txt\nconsole.log(path.basename(myPath), '.txt') // archivo\n</code></pre> <p>Si lo que se desea obtener es la extensi\u00f3n del archivo con el m\u00e9todos <code>extname()</code> se puede visualizar:</p> <pre><code>const path = require('node:path') // Se importa path\nconst myPath = path.join('files', 'archivo.txt')\nconsole.log(path.extname(myPath)) // .txt\n</code></pre> <p>Este m\u00e9todo devolver\u00e1 una cadena vac\u00eda si la extensi\u00f3n del archivo no es v\u00e1lida, por ejemplo archivo., en este caso no devolver\u00e1 nada.</p> <p>Otros m\u00e9todos a tener en cuenta:</p> <ul> <li><code>isAbsolute()</code>: es un m\u00e9todo que comprueba si la ruta es absoluta.</li> <li><code>parse(path)</code>: retorna un objeto con informaci\u00f3n referente al path (string), como su ra\u00edz, el nombre del fichero, la extensi\u00f3n y el nombre base.</li> <li><code>relative(from, to)</code>: obtiene la ruta relative que hay que invocar para llegar desde from hasta to.</li> </ul> Ejercicio 2 <p>Realiza una aplicaci\u00f3n, llamado ls.js, que liste los ficheros y directorios de un directorio indicado como par\u00e1metro.</p>"},{"location":"tema_1/page-5/","title":"5 Proyecto Node Js","text":""},{"location":"tema_1/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Hasta ahora hemos estado creando ficheros sueltos de Javascript y hemos visto como usar unos en otros, pero la realidad es que ninguno de los ficheros que hemos creado han tenido una consistencia y una relaci\u00f3n entre s\u00ed, es decir, no pertenec\u00edan a un mismo proyecto.</p> <p>Un proyecto es un entorno de trabajo que contiene los diferentes ficheros con los que trabajar, pero adem\u00e1s, en caso de Node JS, contiene archivo de configuraciones previas que nos facilitar\u00e1n la vida a la hora de trabajar con Node JS.</p> <p>Para poder crear proyectos Node JS ser\u00e1 necesario el uso de npm.</p>"},{"location":"tema_1/page-5/#npm-node-project-manager","title":"NPM (Node Project Manager)","text":"<p>NPM es un manejador de paquetes para Node que nos permitir\u00e1 instalar paquetes externos a nuestros proyectos, entre otras cosas.</p> <p>NPM tiene dos definiciones principales:</p> <ul> <li>Un repositorio online para publicar paquetes de software libre para ser usado en proyectos Node JS.</li> <li>Una herramienta para terminal para interactuar con dicho repositorio que te ayuda a la instalaci\u00f3n de utilidades, manejo de dependencias y publicaci\u00f3n de paquetes.</li> </ul> <p>Es decir, en tu proyecto basado en Node utilizar\u00e1s la utilidad de linea de comandos (cli) para consumir paquetes desde el repositorio online, un listado gigantesco de soluciones de software para distintos problemas disponibles p\u00fablicamente en npmjs.com y para manejar dependencias, y para ello necesitas un archivo de configuraci\u00f3n que le diga a npm que este es un proyecto node.</p>"},{"location":"tema_1/page-5/#packagejson","title":"package.json","text":"<p>Este archivo indica a npm que el directorio en el que se encuentra es un proyecto o paquete npm. Adem\u00e1s, contiene la informaci\u00f3n del paquete incluyendo la descripci\u00f3n del mismo, versi\u00f3n, autor, dependencias, etc.</p> <p>Este archivo es generado autom\u00e1ticamente mediante la ejecuci\u00f3n del comando <code>npm init</code>, que sirve para inicializar un proyecto. Al ejecutar dicho comando se te har\u00e1 algunas preguntas para crear el paquete y completar la informaci\u00f3n del package.json.</p> <p>La informaci\u00f3n a solicitar es:</p> <ul> <li>name: nombre del paquete que se va a desarrollar.</li> <li>version: corresponde a la versi\u00f3n del proyecto. Se recomienda mantener actualizado este campo cuando modificas algo en tu proyecto o librer\u00eda utilizando semver.</li> <li>description: una breve descripci\u00f3n del proyecto.</li> <li>entry point: es el punto de entrada de tu proyecto, es decir, que archivo se ejecutar\u00e1 cuando se importe tu proyecto dentro de otro.</li> <li>test command: se define el comando que quieres ejecutar para realizar las pruebas de tu proyecto. Este comando ser\u00e1 ejecutado cuando escribas <code>npm run test</code>.</li> <li>git repository: define la url del repositorio git donde se alojar\u00e1 el proyecto. De esta forma se informa a los usuarios donde encontrar el c\u00f3digo fuente del proyecto.</li> <li>author: creador del proyecto. Se puede indicar el nombre, el alias o el email.</li> <li>license: corresponde a la licencia que tiene el proyecto a crear. As\u00ed, se permite a las personas saber que y que no est\u00e1 permitido al usar tu c\u00f3digo. Hecha un vistazo a las licencias soportadas. Normalmente, se suelee indicar la licencia MIT.</li> <li>private: valor booleano, que permitir\u00e1 evitar que el paquete sea publicado en el repositorio. Ser\u00e1 true, si deseas que el proyecto sea privado.</li> <li>keywords: son las palabras claves para que aparezca el repositorio cuando sea buscado por el usuario.</li> </ul> <p>Al completar dicha informaci\u00f3n crear\u00e1 un fichero package.json con toda la informaci\u00f3n almacenada, por ejemplo:</p> <pre><code>{\n\"name\": \"my-first-node-package\",\n\"version\": \"1.0.0\",\n\"description\": \"My first project use node js\",\n\"main\": \"index.js\",\n\"scripts\": {\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"keywords\": [\n\"async\",\n\"example\"\n],\n\"author\": \"irudev\",\n\"license\": \"ISC\"\n}\n</code></pre> <p>Si se quiere obtener todos los valores por defecto se puede ejecutar el comando <code>npm init --yes</code> o <code>npm init -y</code></p>"},{"location":"tema_1/page-5/#npm-scripts","title":"npm scripts","text":"<p>Como puedes observar en el package.json del ejemplo anterior, contiene todos los campos nombrados, pero adem\u00e1s tiene un campo extra llamado scripts. Esta secci\u00f3n define un listado de propiedades que permiten ejecutar comandos dentro del contexto de tu proyecto incluyendo: comandos de otros paquetes listados como dependencias, scripts personalizados, scripts bash, etc.</p> <p>De momento, solo hay un script el especificado por nosotros cuando hemos ejecutado <code>npm init</code>y nos han preguntado por los tests. En caso de no indicar ninguno, se ejecutar\u00e1 <code>echo \\\"Error: no test specified\\\" &amp;&amp; exit 1</code> por defecto,</p> <p>Podemos personalizar los script como creamos. Por ejemplo, podemos crear un script que al ejecutarlo, ejecute el index.js:</p> <pre><code>\"scripts\": {\n\"start\": \"node index.js\",\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n</code></pre>"},{"location":"tema_1/page-5/#dependencias-de-produccion-y-dependencias-de-desarrollo","title":"Dependencias de producci\u00f3n y dependencias de desarrollo","text":"<p>Para poder instalar dependencias se usa el comando <code>npm install LIBRARY</code> donde ^LIBRARY* es la dependencia a instalar. Tambien se puede usar la versi\u00f3n reduciar <code>npm i LIBRARY</code>:</p> <pre><code>npm i picocolors\n</code></pre> <p>El ejemplo anterior instalar\u00e1 en nuestro proyecto la librer\u00edas picocolors, que nos permitir\u00e1 usar colores en nuestra consola de comandos al usar <code>console</code></p> <p>Al instalar un dependencia hay que tener en cuenta dos cosas:</p> <ul> <li>Se crear\u00e1 una carpeta node_modules, si es el primer m\u00f3dulo instalado, el cu\u00e1l contiene todas las dependencias instaladas.</li> <li> <p>Aparecer\u00e1 una nueva secci\u00f3n dependencies, si tambi\u00e9n es la primera instalada, que contendr\u00e1 <code>NOMBRE:VERSION</code>. Donde NOMBRE es el nombre del paquete instalado y VERSION es la version del paquete con el formato semver</p> <pre><code>\"dependencies\": {\n\"picocolors\": \"^1.0.0\"\n}\n</code></pre> <p>Tambi\u00e9n es posible encontrar algunos s\u00edmbolos frente a la numeraci\u00f3n de la versi\u00f3n, estos son:</p> </li> <li> <p><code>^</code>: last minor release. Por ejemplo <code>^1.0.0</code>, indica que 1.0.0 es la versi\u00f3n m\u00e1s baja que se puede instalar pero permite que se instale cualquier versi\u00f3n superar a esa pero se encuentre dentro de la versi\u00f3n 1.</p> </li> <li><code>~</code>: last patch release. Esta es la forma contraria de <code>^</code>. Esta especificaci\u00f3n <code>~1.0.0</code> puede instalar la versi\u00f3n <code>1.0.0</code> si es la \u00faltima versi\u00f3n del patch.</li> </ul> <p>Al usar el comando <code>npm i PACKAGE</code> se instalar\u00e1 las dependencias pero en modo producci\u00f3n, es decir, cuando se despliegue la aplicaci\u00f3n para ser subida a host, o a un servidor, ser\u00e1n instaladas.</p> <p>Existen otro forma de instalar dependencias, <code>npm install PACKAGE -D</code>, de esta forma se instalar\u00e1 en modo desarrollo, es decir, en el momento del despliegue no ser\u00e1n necesaria su instalaci\u00f3n pero durante el desarrollo de la aplicaci\u00f3n si que son necesarias.</p> <p>Al instalar una dependencia en modo desarrollo, se a\u00f1adir\u00e1 otra secci\u00f3n devDependencies al package.json:</p> Consolapackage.json <pre><code>npm i standard -D\n</code></pre> <pre><code>\"devDependencies\": {\n\"standard\": \"^17.1.0\"\n}\n</code></pre> <p>En el ejemplo anterior hemos instalado el package standard que corresponde a JavaScript Standard Style en modo dependencia. Este paquete permite seguir unas reglas de formato para los archivos Javascript. Para saber m\u00e1s visite: https://standardjs.com/readme-esla.html</p>"},{"location":"tema_1/page-5/#package-lockjson","title":"package-lock.json","text":"<p>Este archivo es auto generado por <code>npm install</code> y es una lista descriptiva y exacta de las versiones instaladas durante tu proceso. No esta destinado a ser le\u00eddo ni manipulado por los desarrolladores, si no, para ser un insumo del proceso de manejo de dependencias.</p>"},{"location":"tema_1/page-5/#otros-argumentos-para-npm-install","title":"Otros argumentos para npm install","text":"<p>Puedes usar algunos par\u00e1metros tales como</p> <ul> <li><code>-g</code>: para indicar que quieres que el paquete se instale globalmente, y se mantenga en tu ordenador y no \u00fanicamente en tu proyecto. Esta opci\u00f3n no es muy recomendada.</li> <li><code>--production</code>: indica que la ejecuci\u00f3n de <code>npm install</code> solo instalar\u00e1 las dependencias listadas en el apartado dependencies dejando de lado las dependencias de desarrollo.</li> </ul>"},{"location":"tema_1/page-5/#otros-scripts-de-npm","title":"Otros scripts de npm","text":""},{"location":"tema_1/page-5/#npm-audit","title":"npm audit","text":"<p>npm tiene una cantidad de paquetes disponibles lo que es una gran caracter\u00edstica indicando lo saludable del ecosistema que es capaz de generar nuevas librer\u00edas a gran velocidad, pero tambi\u00e9n puede ser un problema. npm puede albergar paquetes maliciosos o con problema de seguridad.</p> <p>La organizaci\u00f3n detr\u00e1s de npm mantiene una lista de agujeros de seguridad y puedes utilizar este comando para revisar tus dependencias.</p> <p><code>npm audit</code> te entregar\u00e1 informaci\u00f3n de las vulnerabilidades encontradas en tus dependencias junto con una breve descripci\u00f3n de como resolverlo indicando la versi\u00f3n que corrige el defecto.</p>"},{"location":"tema_1/page-5/#npm-publish","title":"npm publish","text":"<p>En el caso de que tu proyecto sea una librer\u00eda de software libre que quieres compartir con otros, este comando ser\u00e1 el que te permitir\u00e1 publicar tu paquete en el repositorio, solo necesitas ejecutar:</p> <ul> <li><code>npm login</code> para ingresar a tu cuenta de npm.</li> <li><code>npm publish</code> para subir tu paquete al repositorio.</li> </ul> <p>Ten en cuenta que necesitas tener bien configurados tu entry point y el script de build.</p> <p>Tambi\u00e9n puedes hacer uso de los scripts del ciclo de vida. Una serie de scripts que se ejecutan en diferentes momentos del proceso de publicaci\u00f3n:</p> <ul> <li>prepare (desde <code>npm@4.0.0</code>): Se ejecuta antes de que el paquete se empaquete (packed) y antes de que se publique. Tambi\u00e9n se ejecuta al correr <code>npm install</code> y despu\u00e9s del script <code>prepublishOnly</code></li> <li>prepublishOnly: Se ejecuta antes de que el paquete sea preparado y empaquetado y solo cuando se ejecuta <code>npm publish</code></li> <li>prepack: Se ejecuta antes de empaquetar, es decir antes de <code>npm pack</code> y <code>npm publish</code></li> <li>postpack: Se ejecuta despu\u00e9s de que el paquete fuese generado y ubicado en su destino final.</li> </ul>"},{"location":"tema_1/page-6/","title":"Proyecto","text":"<p>En este primer proyecto se va a desarrollar una varios comandos para tratar con ficheros, path, procesos, etc. Cada uno de ellos ser\u00e1n ejecutados independientemente.</p>"},{"location":"tema_1/page-6/#comando-ls","title":"Comando ls","text":"<p>Se crear\u00e1 un comando ls que listar\u00e1 la informaci\u00f3n de un directorio, que recibir\u00e1 por par\u00e1metro (en caso de no recibirlo usar\u00e1 el directorio actual). Adem\u00e1s tambi\u00e9n recibir\u00e1 los siguientes par\u00e1metros:</p> <ul> <li>-l: listar\u00e1 informaci\u00f3n adicional sobre los ficheros, como su tama\u00f1o, la fecha de la \u00faltima modificaci\u00f3n, etc.</li> <li>-a: listar\u00e1 todos los ficheros incluidos los ficheros ocultos.</li> <li>-r: listar\u00e1 todos los ficheros de forma recursiva, es decir, si existen directorios tambi\u00e9n se listar\u00e1 su contenido.</li> </ul> <p>Los par\u00e1metros se pueden usar de forma individual o de forma conjunta, sin embargo si se escribe un par\u00e1metro no descrito anteriormente finalizar\u00e1 la aplicaci\u00f3n mostrando un mensaje de error personalizado.</p> <p>Realiza el uso de colores para diferencias los ficheros y directorios, as\u00ed como los ocultos y no ocultos.</p>"},{"location":"tema_1/page-6/#comando-rn","title":"Comando rn","text":"<p>Este comando servir\u00e1 para renombrar un fichero por otro, teniendo en cuenta que el nuevo nombre de puede existir. Si existe el fichero tendr\u00e1 dos opciones, si no indica ning\u00fan par\u00e1metro se mostrar\u00e1 un mensaje de error indicando que ya existe el destino, mientras que si usa el par\u00e1metro -s, sobrescribir\u00e1 el fichero.</p>"},{"location":"tema_1/page-6/#comando-rm","title":"Comando rm","text":"<p>Este comando eliminar\u00e1 el/los ficheros indicados por par\u00e1metros. Debe recibir obligatoriamente un par\u00e1metro, si no mostrar\u00e1 un error. No se podr\u00e1 eliminar ning\u00fan directorio a no ser que use el par\u00e1metro -r.</p>"},{"location":"tema_1/page-6/#comando-port","title":"Comando port","text":"<p>Este comando devolver\u00e1 la variable <code>env</code> llamada PORT en caso de que sea definida, por el contrario, obtendr\u00e1 el primer puerto que este libre. Si est\u00e1 definida, adem\u00e1s, deber\u00e1 comprobar que no est\u00e9 en uso. Usa la librer\u00eda nativa de node <code>net</code>.</p>"},{"location":"tema_2/page-1/","title":"1 M\u00f3dulo HTTP","text":""},{"location":"tema_2/page-1/#protocolo-http","title":"Protocolo HTTP","text":"<p>HTTP (HyperText Transfer Protocol, es decir, Protocolo de transferencia de hipertexto) permite la transferencia de datos entre un servidor web y un receptor, que normalmente suele ser un navegador web.</p> Recuerda Estructura de una URL <p>La estructura de una URL es la siguiente: http://host[:puerto][/ruta][?par\u00e1metros], donde:</p> <ul> <li>http indica el protocolo que utilizamos para conectarnos a un servidor web.</li> <li>host es el nombre de dominio (por ejemplo google.com)</li> <li>puerto es un n\u00famero de puerto donde el servidor escuchara las peticiones. Por lo general, no se suele indicar ya que por defecto suele ser 80, en caso de ser otro s\u00ed habr\u00eda que indicarlo.</li> <li>/ruta indica donde se encuentra el archivo en el servidor.</li> <li>?par\u00e1metros son los datos que se pueden enviar desde el cliente para una mayor identificaci\u00f3n del recurso que solicitamos.</li> </ul> <p>La comunicaci\u00f3n http sucede cuando el usuario realiza un petici\u00f3n desde el navegador, por ejemplo buscar un producto en una tienda online. Esta petici\u00f3n se enviar\u00e1 al servidor web que realizar\u00e1 las operaciones pertinentes para obtener un resultado. Dicho resultado, se mostrar\u00e1 al usuario a trav\u00e9s del navegador con unos c\u00f3digos de estado e informaci\u00f3n relevante, por ejemplo el resultado de que todo ha ido correcto adem\u00e1s del producto buscado, o el resultado de que ha habido un error junto con un mensaje indicativo.</p> <p> Figura 1 - Comunicaci\u00f3n HTTP</p> <p>https</p> <p>El protocolo https es el protocolo http pero haciendo uso del certificado de seguridad.</p> <p>La petici\u00f3n del usuario lleva consigo cierta informaci\u00f3n, que ser\u00e1 tramitada en el servidor, como por ejemplo:</p> <ul> <li>url: ruta que ha usado el usuario para realizar la petici\u00f3n.</li> <li>cabeceras (headers): dan informaci\u00f3n de la petici\u00f3n, como por el ejemplo, el tipo dato que se va a enviar en la petici\u00f3n (texto, html, json, etc), el user-agent, es decir, desde que tipo de dispositivo se est\u00e1 haciendo la petici\u00f3n (navegador Chrome, M\u00f3vil, etc)</li> <li>cuerpo (body): es la informaci\u00f3n que se manda con la petici\u00f3n. A veces simplemente se realiza una petici\u00f3n sin necesidad de mandar ning\u00fan tipo de informaci\u00f3n.</li> </ul> <p>La respuesta que devuelve el servidor contiene los mismos par\u00e1metros que la petici\u00f3n pero en este caso, adem\u00e1s contiene un c\u00f3digo de estado (status code) que representa como ha ido la operaci\u00f3n, si ha sido \u00e9xito, o ha habido un error por parte del cliente, o por parte del servidor, etc.</p>"},{"location":"tema_2/page-1/#servidor-web-con-node-js","title":"Servidor web con Node JS","text":"<p>Una de los proyectos que podemos realizar con Node JS es crear un servidor web haciendo uso del protocolo http, para ello Node JS dispone de un m\u00f3dulo para ello.</p> <p>El m\u00f3dulo <code>http</code> permite realizar solicitudes http haciendo uso del patr\u00f3n emisor, es decir, recibir\u00e1 peticiones que resolver\u00e1 emitiendo una respuesta.</p> <p>Info</p> <p>https://nodejs.org/api/http.html</p> <p>Para crear el servidor hacemos uso del m\u00e9todo <code>createServer(request, response)</code> que recibe dos par\u00e1metros la petici\u00f3n del usuario (request) y la respuesta que devolver\u00e1 el servidor (response). Devuelve un objeto de tipo <code>Server</code>.</p> <p>Una vez creado el objeto <code>Server</code> ser\u00e1 necesario indicar en que puerto debe estar escuchando para recibir peticiones. Para ello, se dispone del m\u00e9todo <code>listen(port, callback)</code>, siendo port el puerto ha escuchar y siendo callback la funci\u00f3n que realizar\u00e1 cuando escuche.</p> <p>\u00a1Cuidado!</p> <p>Se lanzar\u00e1 un error si se intenta escuchar un puerto que ya est\u00e1 escuchando para otro servidor</p> <pre><code>const http = require('node:http')\nconst server = http.createServer((request, response) =&gt; {\nresponse.write(\"Hello world!\")\nresponse.end()\n})\nserver.listen(3000, () =&gt; console.log(\"Escuchando en el puerto 3000...\"))\n</code></pre>"},{"location":"tema_2/page-1/#request-vs-response","title":"Request vs Response","text":"<p><code>Http Request</code> y <code>Http Response</code> son dos conceptos importantes en el mundo del desarrollo de servidores web. Request es la petici\u00f3n que el usuario realiza a trav\u00e9s del navegador web. Dicha petici\u00f3n va a ser tratada en el servidor, y \u00e9ste a su vez mandar\u00e1 una respuesta al usuario. Dicha respuesta es lo que se conoce como response</p>"},{"location":"tema_2/page-1/#request","title":"Request","text":"<p>La estructura de un request es la siguiente:</p> <ul> <li>El m\u00e9todo en el que se realiza la petici\u00f3n (POST, GET, etc).</li> <li>La ruta al fichero al que se realiza la petici\u00f3n (/content/login)</li> <li>Encabezados, donde se indica diferentes aspectos de la petici\u00f3n, como por ejemplo el lenguaje, el tipo de dato con el que se va a realizar la petici\u00f3n (XML, HTML, JSON, etc).</li> <li>El cuerpo de la petici\u00f3n, que aunque es opcional, la informaci\u00f3n que manda el usuario al realizar la petici\u00f3n. Dicha informaci\u00f3n o data tiene que estar escrita de la forma indicada en la cabecera (XML, HTML, JSON, etc)</li> </ul>"},{"location":"tema_2/page-1/#response","title":"Response","text":"<p>En un response podemos encontrar:</p> <ul> <li>status code es el c\u00f3digo del estado de la resoluci\u00f3n de la petici\u00f3n (200, si est\u00e1 todo correcto, 400 si alg\u00fan error etc.)</li> <li>Encabezados, que al igual que en el request describen el contenido.</li> <li>El cuerpo del mensaje, que al igual que el request, es el tipo de dato devuelto por el usuario.</li> </ul>"},{"location":"tema_2/page-1/#metodos-para-peticiones-y-respuesta","title":"M\u00e9todos para peticiones y respuesta","text":"<p>En Node JS se dispone de varios m\u00e9todos para tratar con la petici\u00f3n requerida por el usuario:</p> <ul> <li><code>getHeaders()</code>: obtiene un array con los headers.</li> <li><code>getHeader(name)</code>: obtiene el valor de una de las propiedades (name) de la cabecera.</li> <li><code>hasHeader(name)</code>: comprueba si la cabecera contiene la propiedad indicada.</li> <li><code>path</code>: devuelve la ruta de la petici\u00f3n.</li> <li><code>method</code>: devuelve el m\u00e9todo en el que se ha realizado la petici\u00f3n.</li> <li><code>host</code>: devuelve el host donde se ha realizado la petici\u00f3n.</li> <li><code>writeHead(statusCode, statusMessage, headers)</code>: escribe la cabecera de la respuesta, teniendo en cuenta el c\u00f3digo de estado y como par\u00e1metros voluntarios el mensaje y los headers.</li> <li><code>write()</code>: escribe lo que se debe devolver. Puede recibir el dato a devolver, as\u00ed como su codificaci\u00f3n, adem\u00e1s de un callback.</li> <li><code>end()</code>: es el m\u00e9todo usado para finalizar la respuesta y devolverla al usuario. Puede tener tres par\u00e1metros opcionales:<ul> <li>data: la informaci\u00f3n a devolver. Si se utiliza es similar al m\u00e9todo write.</li> <li>encoding: la codificaci\u00f3n de los datos devueltos.</li> <li>callback: la funci\u00f3n que se realizar\u00e1 cuando finalice la respuesta.</li> </ul> </li> </ul>"},{"location":"tema_2/page-2/","title":"2 HTTP Methods","text":"<p>Los m\u00e9todos HTTP m\u00e1s comunes usados son el m\u00e9todo GET, el m\u00e9todo POST, el m\u00e9todo PUT, el m\u00e9todo PATCH y el m\u00e9todo DELETE.</p> <p>Estos m\u00e9todos indican al servidor que tipo de operaci\u00f3n hay que realizar enviando a trav\u00e9s del cuerpo del request y de los par\u00e1metros de un url informaci\u00f3n a usar.</p> <p>Los m\u00e9todos HTTP tienen una relaci\u00f3n sem\u00e1ntica directa con las operaciones CRUD (Create, Read, Update, Delete).</p> <p>Para poder realizar conexiones a un servidor, haciendo uso de estos m\u00e9todos, se puede usar el m\u00e9todo <code>fetch</code> de Javascript.</p>"},{"location":"tema_2/page-2/#metodo-get","title":"M\u00e9todo GET","text":"<p>El m\u00e9todo GET es usado para recibir informaci\u00f3n y obtener informaci\u00f3n del servidor usando la url dada. Se considera que dicho m\u00e9todo es una operaci\u00f3n de lectura (R).</p> <p>Obtenemos todos los elementos del servidor:</p> <pre><code>fetch('https://jsonplaceholder.typicode.com/todos/')\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n</code></pre> <p>Si no se le indica un m\u00e9todo espec\u00edfico, se usa como defecto el m\u00e9todo GET.</p>"},{"location":"tema_2/page-2/#metodo-post","title":"M\u00e9todo POST","text":"<p>El m\u00e9todo POST es usado para enviar informaci\u00f3n (data) al servidor como un fichero, datos, o a\u00f1adir una nueva fila al final de una tabla. Se podr\u00eda decir, que este m\u00e9todo es usado para a\u00f1adir nuevos items al servidor. Se puede considera a este m\u00e9todo como una operaci\u00f3n de creaci\u00f3n (C).</p> <p>Para crear un nuevo usuario:</p> <pre><code>fetch('https://jsonplaceholder.typicode.com/todos/', {\nmethod: 'POST',\nheaders: { 'content-type': 'application/json' },\nbody: JSON.stringify({\nuserId: 6,\nid: 300,\ntitle: \"Learn fetch api\",\ncompleted: false\n})\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n</code></pre> <p>Note</p> <p>Ten en cuenta que al realizar el POST ha sido necesario pasarle un header y un body. El body contiene la informaci\u00f3n que le enviamos al servidor, mientras que el header contiene en que lenguaje/formato es enviado.</p>"},{"location":"tema_2/page-2/#metodo-put","title":"M\u00e9todo PUT","text":"<p>El m\u00e9todo PUT es usado para actualizar un resource. Si la fuente esta identificada se intenta localizarla, de tal forma que si es un resource existente se actualice, y por el contrario se cree una nueva.</p> <p>Para actualizar el usuario creado actualmente:</p> <pre><code>fetch('https://jsonplaceholder.typicode.com/todos/6', {\nmethod: 'PUT',\nheaders: { 'content-type': 'application/json' },\nbody: JSON.stringify({\nuserId: 1,\nid: 5,\ntitle: \"hello fetch api\",\ncompleted: false\n})\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n</code></pre>"},{"location":"tema_2/page-2/#metodo-patch","title":"M\u00e9todo PATCH","text":"<p>El m\u00e9todo PATCH es usado para actualizar las propiedades de un resource</p> <p>Para modificar la propiedad title y complete:</p> <pre><code>fetch('https://jsonplaceholder.typicode.com/todos/6', {\nmethod: 'PATCH',\nheaders: { 'content-type': 'application/json' },\nbody: JSON.stringify({\ntitle: \"we are going to learn patch method\",\ncompleted: true\n})\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n</code></pre>"},{"location":"tema_2/page-2/#metodo-delete","title":"M\u00e9todo DELETE","text":"<p>El m\u00e9todo DELETE es usado para eliminar un resource especificado en la URL:</p> <p>Para eliminar el usuario creado:</p> <pre><code>fetch('https://jsonplaceholder.typicode.com/todos/6', {\nmethod: 'DELETE',\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n</code></pre>"},{"location":"tema_2/page-2/#realizar-peticion","title":"Realizar petici\u00f3n","text":"<p>Para poder realizar requests en Node JS, podemos usar la API Fetch como en los ejemplos anteriores. El problema es que \u00e9sta es una API reciente y versiones antigua de Node JS no la incorpora.</p> <p>El m\u00f3dulo http trae consigo el m\u00e9todo <code>request()</code> para poder realizar peticiones a un servidor y trabajar con ellos, adem\u00e1s recibe los siguientes par\u00e1metros:</p> <ul> <li><code>url</code> del servidor donde se va a realizar la petici\u00f3n.</li> <li><code>options</code> es un par\u00e1metro opcional que contiene informaci\u00f3n o datos relevantes del request, como por ejemplo los headers, o el m\u00e9todo (por defecto es GET).</li> <li><code>callback</code> que se realizar\u00e1 cuando termine la petici\u00f3n.</li> </ul> <pre><code>const http = require('node:http')\n// GET\nconst get = http.request(\"https://jsonplaceholder.typicode.com/todos/\", {\nmethod: 'GET'\n}, (res) =&gt; {\nconsole.log(\"GET realizado\")\n}).end()\n// POST \nconst post = http.request(\"https://jsonplaceholder.typicode.com/todos/\", {\nmethod: 'POST',\nheaders: { 'content-type': 'application/json' },\n}, (res) =&gt; {\nconsole.log(\"GET realizado\")\n})\npost.write(JSON.stringify({\nuserId: 6,\nid: 300,\ntitle: \"Learn fetch api\",\ncompleted: false\n}))\npost.end()\n</code></pre> <p>Axios</p> <p>Tambi\u00e9n existe la librer\u00eda axios y express compatible con versiones antiguas del NodeJS y que permiten realizar tanto peticiones como respuestas</p>"},{"location":"tema_2/page-2/#http-status-codes","title":"HTTP status codes","text":"<p>Los c\u00f3digos de estado HTTP nos dan informaci\u00f3n de como ha ido la comunicaci\u00f3n con el servidor. Los c\u00f3digos est\u00e1n formados por tres d\u00edgitos, el primer d\u00edgito indica a que grupo pertenece mientras que los otros dos nos indican una informaci\u00f3n m\u00e1s espec\u00edfica sobre el estado.</p> <ul> <li>1XX Respuestas informativas: Esta respuesta significa que el servidor ha recibido los encabezados de la petici\u00f3n, y que el cliente debe proceder a enviar el cuerpo de la mista.</li> <li>2XX Peticiones correctas: Esta clase de c\u00f3digo de estado indica que la petici\u00f3n fue recibida, entendida y aceptada correctamente.</li> <li>3xx Redirecciones: El cliente tiene que tomar una acci\u00f3n adicional para completar la petici\u00f3n. La acci\u00f3n requerida puede ser llevada a cabo por el agente de usuario sin interacci\u00f3n con el usuario si y solo si el m\u00e9todo utilizado en la segunda petici\u00f3n es GET o HEAD. El agente de usuario no debe redirigir autom\u00e1ticamente una petici\u00f3n m\u00e1s de 5 veces, dado que tal funcionamiento indica usualmente un Bucle infinito.</li> <li>4XX Errores del cliente: La solicitud contiene sintaxis incorrecta o no puede procesarse. La intenci\u00f3n de la clase de c\u00f3digos de respuesta 4xx es para casos en los cuales el cliente parece haber errado la petici\u00f3n.</li> <li>5XX Errores del servidor: El servidor fall\u00f3 al completar una solicitud aparentemente v\u00e1lida. Los c\u00f3digos de respuesta que comienzan con el d\u00edgito \"5\" indican casos en los cuales el servidor tiene registrado a\u00fan antes de servir la solicitud, que est\u00e1 errado o es incapaz de ejecutar la petici\u00f3n.</li> </ul> <p>Ahora veamos en profundidad las peticiones m\u00e1s t\u00edpicas:</p> <ul> <li>200 - OK:Petici\u00f3n resulta de forma correcta sin ning\u00fan inconveniente.</li> <li>301 - Moved Permanently: Se ha realizado la conexi\u00f3n correctamente pero el recurso solicitado ha sido movido de forma permanente.</li> <li>400 - Bad Request: Se ha realizado la petici\u00f3n con informaci\u00f3n incorrecta.</li> <li>404 - Not Found: No se encuentra la informaci\u00f3n solicitada.</li> <li>500 - Internal Server Error: Error del servidor</li> </ul> <p>Info</p> <p>Para conocer m\u00e1s espec\u00edficamente los tipos de estados que hay puede visitar la siguiente p\u00e1gina:</p> <p>https://www.restapitutorial.com/httpstatuscodes.html</p> <p>Tambi\u00e9n existe una versi\u00f3n con gatos:</p> <p>https://http.cat/</p> <p>Adem\u00e1s, existen diferentes librer\u00edas que almacenan en constantes los valores de los status code, una de ellas ser\u00eda:</p> <p>https://www.npmjs.com/package/http-status-codes</p>"},{"location":"tema_2/page-3/","title":"3 Introducci\u00f3n a API REST","text":""},{"location":"tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Una REST API, o API RESTFUL, es una interfaz de programaci\u00f3n de aplicaciones que se ajusta a los l\u00edmites de la arquitectura REST y permite la interacci\u00f3n con los servicios web de RESTful.</p> <p> Figura 2 - API REST</p> <p>El usuario realiza una petici\u00f3n que es tratada a trav\u00e9s de la API, que comunica con el servidor para que realice la operaci\u00f3n y devuelva una respuesta, que vuelve a ser tratada por la API y devuelta al usuario.</p>"},{"location":"tema_2/page-3/#apis","title":"APIs","text":"<p>Las API son conjuntos de definiciones y protocolos que se utilizan para dise\u00f1ar e integrar el software de las aplicaciones. Suele considerarse como el contrato entre el proveedor de informaci\u00f3n y el usuario, donde se establece el contenido que se necesita por parte del consumidor (la llamada) y el que requiere el productor (la respuesta).Por ejemplo, el dise\u00f1o de una API de servicio meteorol\u00f3gico podr\u00eda requerir que el usuario escribiera un c\u00f3digo postal y que el productor diera una respuesta en dos partes: la primera ser\u00eda la temperatura m\u00e1xima y la segunda, la m\u00ednima.</p> <p>En otras palabras, las API le permiten interactuar con una computadora o un sistema para obtener datos o ejecutar una funci\u00f3n, de manera que el sistema comprenda la solicitud y la cumpla.</p> <p>Se puede considerar como los mediadores, un camino intermedio, entre los usuarios y los servicios web que se requieren obtener. De esta forma se pueden compartir recursos e informaci\u00f3n mientras se conservan la seguridad, el control y la autentificaci\u00f3n.</p> <p>Otra ventaja de las API es que no se necesita saber c\u00f3mo se recibe el recurso ni de d\u00f3nde proviene.</p>"},{"location":"tema_2/page-3/#rest","title":"REST","text":"<p>REST no es un protocolo ni un est\u00e1ndar, sino m\u00e1s bien un conjunto de l\u00edmites de arquitectura. Los desarrolladores de las API pueden implementarlo de distintas maneras.</p> <p>Cuando el cliente env\u00eda una solicitud a trav\u00e9s de una API de RESTful, esta transfiere una representaci\u00f3n del estado del recurso requerido a quien lo haya solicitado o al extremo. La informaci\u00f3n se entrega por medio de HTTP en uno de estos formatos: JSON (JavaScript Object Notation), HTML, XLT, Python, PHP o texto sin formato. JSON es el lenguaje de programaci\u00f3n m\u00e1s popular, ya que tanto las m\u00e1quinas como las personas lo pueden comprender y no depende de ning\u00fan lenguaje, a pesar de que su nombre indique lo contrario.</p> <p>Tambi\u00e9n es necesario tener en cuenta otros aspectos. Los encabezados y los par\u00e1metros tambi\u00e9n son importantes en los m\u00e9todos HTTP de una solicitud HTTP de la API de RESTful, ya que contienen informaci\u00f3n de identificaci\u00f3n importante con respecto a los metadatos, la autorizaci\u00f3n, el identificador uniforme de recursos (URI), el almacenamiento en cach\u00e9, las cookies y otros elementos de la solicitud. Hay encabezados de solicitud y de respuesta, pero cada uno tiene sus propios c\u00f3digos de estado e informaci\u00f3n de conexi\u00f3n HTTP.</p> <p>Para que una API se considere de RESTful, debe cumplir los siguientes criterios:</p> <ul> <li>Arquitectura cliente-servidor compuesta de clientes, servidores y recursos, con la gesti\u00f3n de solicitudes a trav\u00e9s de HTTP.</li> <li>Comunicaci\u00f3n entre el cliente y el servidor sin estado, lo cual implica que no se almacena la informaci\u00f3n del cliente entre las solicitudes de GET y que cada una de ellas es independiente y est\u00e1 desconectada del resto.</li> <li>Datos que pueden almacenarse en cach\u00e9 y optimizan las interacciones entre el cliente y el servidor.</li> <li>Una interfaz uniforme entre los elementos, para que la informaci\u00f3n se transfiera de forma estandarizada. Para ello deben cumplirse las siguientes condiciones:<ul> <li>Los recursos solicitados deben ser identificables e independientes de las representaciones enviadas al cliente.</li> <li>El cliente debe poder manipular los recursos a trav\u00e9s de la representaci\u00f3n que recibe, ya que esta contiene suficiente informaci\u00f3n para permitirlo</li> <li>Los mensajes autodescriptivos que se env\u00eden al cliente deben contener la informaci\u00f3n necesaria para describir c\u00f3mo debe procesarla.</li> <li>Debe contener hipertexto, lo cual significa que cuando el cliente acceda a alg\u00fan recurso, debe poder utilizar hiperv\u00ednculos para buscar las dem\u00e1s acciones que se encuentren disponibles en ese momento.</li> </ul> </li> <li>Un sistema en capas que organiza en jerarqu\u00edas invisibles para el cliente cada uno de los servidores (los encargados de la seguridad, del equilibrio de carga, etc.) que participan en la recuperaci\u00f3n de la informaci\u00f3n solicitada.</li> <li>C\u00f3digo disponible seg\u00fan se solicite (opcional), es decir, la capacidad para enviar c\u00f3digos ejecutables del servidor al cliente cuando se requiera, lo cual ampl\u00eda las funciones del cliente.</li> </ul> <p>Si bien la API de REST debe cumplir todos estos par\u00e1metros, resulta m\u00e1s f\u00e1cil de usar que un protocolo definido previamente, como SOAP (protocolo simple de acceso a objetos), el cual tiene requisitos espec\u00edficos, como la mensajer\u00eda XML y la seguridad y el cumplimiento integrados de las operaciones, que lo hacen m\u00e1s lento y pesado.</p> <p>Por el contrario, REST es un conjunto de pautas que pueden implementarse seg\u00fan sea necesario. Por esta raz\u00f3n, las API de REST son m\u00e1s r\u00e1pidas y ligeras, cuentan con mayor capacidad de ajuste y, por ende, resultan ideales para el Internet de las cosas (IoT) y el desarrollo de aplicaciones para dispositivos m\u00f3viles.</p>"},{"location":"tema_2/page-3/#creacion-de-una-api-rest-con-node-js","title":"Creaci\u00f3n de una API REST con Node JS","text":"<p>Para crear una API REST, ser\u00e1 necesario crear un servidor. Cuando el servidor esta creado habr\u00e1 que tratar de manejar las diferentes tipos de rutas con las que se va a trabajar.</p> <p>Supongamos que queremos crear una API para trabajar con pokemon, necesitaremos las rutas para acceder a todos los pokemon, crearlos, modificarlos y eliminarlos:</p> <pre><code>const ROUTES = {\nALL: '/api/pokemons',\nONLY: 'api/pokemon'\n}\n</code></pre> <p>La ruta ALL ser\u00e1 usada para aquellas peticiones con las que tenga que trabajar con TODOS los pokemon, como por ejemplo obtener todos los pokemon. Mientras que la ruta ONLY ser\u00e1 necesaria para necesitar realizar operaciones con un pokemon concreto, por ejemplo: obtener un pokemon, eliminar un pokemon, crear un pokemon, actualizar un pokemon.</p> <p>Una vez definidas las rutas creamos nuestro servidor, con un m\u00e9todo callback que se encargar\u00e1 de procesar la informaci\u00f3n:</p> <pre><code>const processRequest = (req, res) =&gt; { }\nconst server = http.createServer(processRequest)\nserver.listen(1234, () =&gt; console.log('server listening on port http://localhost:1234'))\n</code></pre> <p>En el m\u00e9todo <code>processRequest</code> debemos comprobar el m\u00e9todo que se est\u00e1 usando, en este ejemplo vamos a usar el m\u00e9todo GET y el m\u00e9todo POST, para obtener pokemons y crearlos.</p> <pre><code>const processRequest = (req, res) =&gt; {\nconst { method } = req\nswitch (method) {\ncase 'GET':\n// handler get\ncase 'POST':\n// handler post\n}\n}\n</code></pre> <p>Una vez que conocemos el m\u00e9todo que se est\u00e1 llevando a cabo, debemos comprobar si coincide con alguna de las rutas, en caso de que deban coincidir. Por ejemplo, en el m\u00e9todo GET de nuestro proyecto, podr\u00e1 realizar la petici\u00f3n con las dos rutas definidas, para as\u00ed obtener TODOS o UNO solo, mientras que a la hora de hacer el POST solo es necesario una ruta:</p> <pre><code>const processRequest = (req, res) =&gt; {\nconst { method, url } = req\nswitch (method) {\ncase 'GET':\nswitch (url) {\ncase ROUTES.ALL:\nres.setHeader('Content-Type', 'application/json; charset=utf-8')\nreturn res.end(JSON.stringify(pokemons))\ncase ROUTES.ONLY:\nres.setHeader('Content-Type', 'application/json; charset=utf-8')\nreturn res.end(JSON.stringify(pokemons[0]))\n}\ncase 'POST':\n// handler POST\n}\n}\n</code></pre> <p>Al hacer el POST debemos tener en cuenta que es necesario obtener el body de la petici\u00f3n, pero el problema est\u00e1 en que la petici\u00f3n van llegando poco a poco hasta que termine de completarse. Para ello, disponemos del evento <code>data</code> que se ejecuta cada vez que nos va llegando esa informaci\u00f3n, y el evento <code>end</code> que se ejecuta cuando la petici\u00f3n ha terminado de llegar:</p> <pre><code>const processRequest = (req, res) =&gt; {\n// ...\nswitch (method) {\n// ...\ncase 'POST':\nswitch (url) {\ncase ROUTES.ONLY: {\nlet body = '' // Creamos un cuerpo vac\u00edo\n// Escuchamos el evento DATA\nreq.on('data', chunk =&gt; {\nbody += chunk.toString()\n})\n// Escuchamos el evento END que sucede cuando\n// la petici\u00f3n a finalizado de llegar\nreq.on('end', () =&gt; {\nconst data = JSON.parse(body)\nres.writeHead(201, { 'Content-Type': 'application/json; charset=utf-8' })\nres.end(JSON.stringify(data))\n})\n}\n}\n}\n}\n</code></pre> <p>La petici\u00f3n va llegando poco a poco, por lo que se va almacenando a la variable body.Es importante saber que la informaci\u00f3n llega en binario, por eso se usa el m\u00e9todo <code>toString()</code> a la informaci\u00f3n que nos va llegando (chuck). Una vez que la petici\u00f3n ha finalizado su llegada, en el evento <code>end</code>, resolvemos la petici\u00f3n</p> <p>Por \u00faltimo, se indicar\u00eda un caso default para tratar con las rutas o los m\u00e9todos que no se han indicado:</p> <pre><code>default:\nres.setHeader('Content-Type', 'text/html; charset=utf-8')\nreturn res.end('&lt;h1&gt;404&lt;/h1&gt;')\n</code></pre> <p>Ejemplo completo:</p> <pre><code>const http = require('node:http')\nconst pokemons = require('package');\nconst ROUTES = {\nALL: '/api/pokemons',\nONLY: 'api/pokemon'\n}\nconst processRequest = (req, res) =&gt; {\nconst { method, url } = req\nswitch (method) {\ncase 'GET':\nswitch (url) {\ncase ROUTES.ALL:\nres.setHeader('Content-Type', 'application/json; charset=utf-8')\nreturn res.end(JSON.stringify(pokemons))\ncase ROUTES.ONLY:\nres.setHeader('Content-Type', 'application/json; charset=utf-8')\nreturn res.end(JSON.stringify(pokemons[0]))\ndefault:\nres.setHeader('Content-Type', 'text/html; charset=utf-8')\nreturn res.end('&lt;h1&gt;404&lt;/h1&gt;')\n}\ncase 'POST':\nswitch (url) {\ncase ROUTES.ONLY: {\nlet body = '' // Creamos un cuerpo vac\u00edo\n// Escuchamos el evento DATA\n// Cada vez que va llegando la petici\u00f3n poco a poco\n// se va almacenando a la variable body\n// es importante saber que la informaci\u00f3n llega en binario,\n// por eso se usa el m\u00e9todo toString()\nreq.on('data', chunk =&gt; {\nbody += chunk.toString()\n})\n// Escuchamos el evento END que sucede cuando\n// la petici\u00f3n a finalizado de llegar\nreq.on('end', () =&gt; {\nconst data = JSON.parse(body)\nres.writeHead(201, { 'Content-Type': 'application/json; charset=utf-8' })\nres.end(JSON.stringify(data))\n})\n}\ndefault:\nres.setHeader('Content-Type', 'text/html; charset=utf-8')\nreturn res.end('&lt;h1&gt;404&lt;/h1&gt;')\n}\ndefault:\nres.setHeader('Content-Type', 'text/html; charset=utf-8')\nreturn res.end('&lt;h1&gt;404&lt;/h1&gt;')\n}\n}\nconst server = http.createServer(processRequest)\nserver.listen(1234, () =&gt; console.log('server listening on port http://localhost:1234'))\n</code></pre> <p>Sugerencia</p> <p>Cierto es, que cada vez que debemos de a\u00f1adir una ruta o un m\u00e9todo, debemos tener de modificar el c\u00f3digo. Por eso recomienda el uso de m\u00e9todos que maneje cada caso del <code>switch</code> incluso poder usar <code>if</code> con retornos:</p> <p><pre><code>const processRequest = (req, res) =&gt; {\nif(req.method === \"GET\"){\nreturn handlerGET(req, res)\n}\n// ...\n}\nconst handlerGET = (req, res) =&gt;{\nif(req.url === Routes.ALL){\nreturn getAll(req, res)\n}\n// ...\n}\n</code></pre> Adem\u00e1s, tambi\u00e9n, se recomienda crear diferentes ficheros haciendo uso de las importaciones y de las exportaciones para poder trabajar de una forma clara.</p> <p>Info</p> <p>Para poder realizar peticiones a una API REST podemos crearnos un proyecto en cualquier otro lenguaje y crear una aplicaci\u00f3n que consuma nuestra API. Tambi\u00e9n existen aplicaciones como POSTMAN para poder consumirlas.</p>"},{"location":"tema_2/page-4/","title":"Proyecto","text":"<p>En este proyecto se va a llevar a cabo la creaci\u00f3n de una API REST, siendo nuestra fuente de datos un fichero JSON.</p> <p>Se desea realizar todas las operaciones CRUD sobre los alumnos que estudian esta materia. La informaci\u00f3n a almacenar es la siguiente:</p> <ul> <li>ID del alumno.</li> <li>Nombre del alumno.</li> <li>Fecha de nacimiento del alumno.</li> <li>Nota media del curso.</li> </ul> <p>Se debe realizar una API siguiendo la arquitectura REST, definiendo correctamente las rutas y los m\u00e9todos del protocolo HTTP, as\u00ed como sus c\u00f3digos de estado y su cabeceras.</p> <p>La informaci\u00f3n ser\u00e1 a\u00f1adida, modificada o elimina en el mismo fichero.</p>"},{"location":"tema_3/page-1/","title":"1 REST API","text":""},{"location":"tema_3/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya se vi\u00f3 en el tema anterior, API son las siglas de \"Interfaz de Programaci\u00f3n de Aplicaciones\" en ingl\u00e9s, que se traduce como \"Application Programming Interface\". En t\u00e9rminos simples, una API es un conjunto de reglas y definiciones que permite que diferentes aplicaciones se comuniquen entre s\u00ed.</p> <p>Una API define los m\u00e9todos y datos que un desarrollador puede usar para interactuar con un software o servicio espec\u00edfico, sin necesidad de comprender los detalles internos de c\u00f3mo funciona ese software. Las APIs son fundamentales para la creaci\u00f3n de software moderno, ya que permiten la integraci\u00f3n de diferentes sistemas, servicios y aplicaciones, facilitando la interoperabilidad y la creaci\u00f3n de soluciones m\u00e1s complejas.</p> <p>En el contexto de la web, las APIs a menudo se utilizan para permitir que aplicaciones web se comuniquen con servidores, accedan a bases de datos, o integren servicios externos. Por ejemplo, las redes sociales suelen ofrecer APIs que permiten a los desarrolladores crear aplicaciones que interact\u00faan con la plataforma, como aplicaciones para programar publicaciones, acceder a datos de usuarios, entre otras funcionalidades.</p> <p> Figura 1 - API</p>"},{"location":"tema_3/page-1/#diferentes-arquitecturas","title":"Diferentes arquitecturas","text":"<p>Existen diferentes formas de crear una API, a lo largo del tiempo se han determinado diferentes arquitectura para poder dise\u00f1ar una API:</p> <ul> <li>REST (Representational State Transfer). Es una arquitectura que utiliza los m\u00e9todos HTTP para realizar las operaciones en recursos identificados por URLs.</li> <li>SOAP (Simple Object Access Protocol). Es un protocolo basado XML para el intercambio de informaci\u00f3n estructurada en la web. A diferencia de REST, SOAP no est\u00e1 ligado a ning\u00fan protocolo de transporte espec\u00edfico y puede utilizarse sobre HTTP, SMTP, TCP, etc.</li> <li>GraphQL: Es una consulta de datos y un lenguaje de manipulaci\u00f3n de datos desarrollado por Facebook. Permite a los clientes solicitar solo los datos que necesitan y nada m\u00e1s, lo que puede ser m\u00e1s eficiente que las consultas tradicionales de REST.</li> <li>RPC (Remote Procedure Call): Es un modelo de comunicaci\u00f3n que permite a un programa ejecutar c\u00f3digo en otro espacio de direcciones de manera transparente, como si fuera una llamada a una funci\u00f3n local. Protocolos como gRPC se basan en este concepto.</li> <li>JSON-RPC y XML-RPC: Son protocolos que utilizan JSON o XML para la codificaci\u00f3n de datos y permiten la ejecuci\u00f3n remota de funciones.</li> <li>OData (Open Data Protocol): Es un protocolo est\u00e1ndar de la OASIS que permite la creaci\u00f3n y el consumo de servicios web RESTful. Facilita la creaci\u00f3n de servicios web que permiten la consulta y manipulaci\u00f3n de datos utilizando est\u00e1ndares web.</li> </ul> <p>Estas son solo algunas de las arquitecturas comunes, y la elecci\u00f3n de la arquitectura depende de varios factores, como los requisitos del proyecto, la naturaleza de los datos, la escalabilidad y las preferencias del desarrollador. La tendencia actual tiende hacia arquitecturas RESTful debido a su simplicidad y eficiencia en la mayor\u00eda de los casos.</p>"},{"location":"tema_3/page-1/#api-rest","title":"API REST","text":"<p>Una REST API (Interfaz de Programaci\u00f3n de Aplicaciones basada en Transferencia de Estado Representacional) es un conjunto de reglas y convenciones arquitect\u00f3nicas para dise\u00f1ar servicios web que se centran en la transferencia de datos y la manipulaci\u00f3n de recursos a trav\u00e9s de los m\u00e9todos est\u00e1ndar del protocolo HTTP. REST se basa en la idea de que las aplicaciones web pueden comunicarse entre s\u00ed de manera eficiente mediante la manipulaci\u00f3n de representaciones de recursos a trav\u00e9s de URLs.</p> <p>Algunas caracter\u00edsticas clave de una REST API incluyen:</p> <ul> <li>Recursos: En el contexto de REST, un recurso es una entidad o un concepto que puede ser identificado mediante una URL \u00fanica. Pueden ser objetos de la vida real o abstractos, como datos de usuarios, im\u00e1genes, o cualquier otra entidad.</li> <li>Operaciones est\u00e1ndar: REST utiliza los m\u00e9todos HTTP est\u00e1ndar, como GET, POST, PUT y DELETE, para realizar operaciones sobre los recursos. Cada m\u00e9todo tiene un prop\u00f3sito espec\u00edfico: GET para obtener datos, POST para crear nuevos recursos, PUT para actualizar recursos existentes, y DELETE para eliminar recursos.</li> <li>Estado Representacional: La representaci\u00f3n de un recurso (como JSON o XML) se env\u00eda al cliente, y el cliente puede realizar operaciones basadas en esa representaci\u00f3n. Cada recurso puede tener m\u00faltiples representaciones (por ejemplo, JSON y XML), y el cliente puede indicar sus preferencias mediante encabezados HTTP.</li> <li>Sin estado (Stateless): Cada solicitud del cliente al servidor en una REST API debe contener toda la informaci\u00f3n necesaria para entender y procesar la solicitud. La comunicaci\u00f3n entre cliente y servidor no debe depender del estado del servidor; cada solicitud debe ser independiente de las anteriores.</li> <li>Jerarqu\u00eda de URL: Las URLs se utilizan para identificar y acceder a los recursos. La estructura de las URLs suele seguir una jerarqu\u00eda que refleja la organizaci\u00f3n de los recursos.</li> <li>HATEOAS (Hypermedia As The Engine Of Application State): Este principio sugiere que la aplicaci\u00f3n debe ser impulsada por el hiperv\u00ednculo proporcionado din\u00e1micamente por las aplicaciones servidores de los estados de la aplicaci\u00f3n, guiando a los usuarios a trav\u00e9s de las acciones disponibles.</li> </ul> <p>Una REST API es una opci\u00f3n com\u00fan y popular para construir servicios web debido a su simplicidad, escalabilidad y facilidad de comprensi\u00f3n. Es ampliamente utilizada en aplicaciones web y m\u00f3viles para permitir la comunicaci\u00f3n eficiente entre el cliente y el servidor.</p> <p> Figura 2 - REST API</p>"},{"location":"tema_3/page-2/","title":"2 Express","text":""},{"location":"tema_3/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Existen diferente librer\u00edas y frameworks para poder dise\u00f1ar una aplicaci\u00f3n REST API en Node JS, adem\u00e1s de la forma nativa ya vista en el tema anterior. Entre ellas encontramos:</p> <ul> <li>Restify: Es un framework espec\u00edficamente dise\u00f1ado para construir APIs Restful en Node JS. Est\u00e1 optimizado para el rendimiento y tiene funcionalidades incorporadas para la validaci\u00f3n, versionado y manejo de errores en APIs.</li> <li>Hapi.js: Es un framework que se utiliza para construir aplicaciones y servicios en Node.js. Al igual que Express, Hapi.js es vers\u00e1til y se puede utilizar para crear APIs RESTful. Proporciona una arquitectura modular y extensible.</li> <li>Koa.js: Desarrollado por el equipo detr\u00e1s de Express.js, Koa.js es un framework m\u00e1s nuevo y m\u00e1s ligero. Aunque no es espec\u00edficamente un framework para APIs REST, su enfoque modular y su sistema de middleware lo hacen adecuado para construir APIs.</li> <li>Nest.js: Es un framework m\u00e1s completo y basado en TypeScript que utiliza las mejores pr\u00e1cticas de desarrollo y arquitectura. Est\u00e1 construido sobre Express.js y proporciona una estructura modular basada en m\u00f3dulos, inyecci\u00f3n de dependencias y decoradores.</li> </ul> <p>En este tema se trabajara con Express</p>"},{"location":"tema_3/page-2/#express","title":"Express","text":"<p>Express.js, com\u00fanmente conocido como Express, es un framework web para Node.js que facilita la creaci\u00f3n de aplicaciones web y APIs. Es minimalista, flexible y est\u00e1 dise\u00f1ado para ser una capa ligera sobre Node.js, proporcionando una serie de caracter\u00edsticas y herramientas que simplifican el desarrollo web.</p> <p>Algunas caracter\u00edsticas clave de Express incluyen:</p> <ul> <li>Enrutamiento: Express simplifica el manejo de las rutas y las solicitudes HTTP. Puedes definir rutas y especificar c\u00f3mo deben manejarse las solicitudes para esas rutas.</li> <li>Middleware: Express utiliza un sistema de middleware que te permite ejecutar funciones en el ciclo de vida de una solicitud. Esto es \u00fatil para realizar tareas como la autenticaci\u00f3n, la manipulaci\u00f3n de datos de solicitud o respuesta, y m\u00e1s.</li> <li>Plantillas: Express no impone una plantilla espec\u00edfica, pero es compatible con varias, como EJS, Pug (anteriormente conocido como Jade), y Handlebars. Esto facilita la renderizaci\u00f3n de vistas en el servidor.</li> <li>Gesti\u00f3n de sesiones y cookies: Express facilita la implementaci\u00f3n de la gesti\u00f3n de sesiones y el manejo de cookies.</li> <li>Manejo de errores: Proporciona un sistema simple para manejar errores durante el procesamiento de las solicitudes.</li> <li>Middleware de terceros: Puedes aprovechar una gran cantidad de middleware de terceros que simplifican tareas comunes, como la autenticaci\u00f3n con Passport.js, la compresi\u00f3n de respuestas con compression, y muchos otros.</li> </ul>"},{"location":"tema_3/page-2/#proyecto-express","title":"Proyecto Express","text":"<p>Para comenzar a utilizar Express, primero debes instalarlo a trav\u00e9s de npm (el sistema de gesti\u00f3n de paquetes de Node.js). Puedes hacerlo con el siguiente comando: <code>npm install express</code></p> <p>Una vez instalado, importamos el paquete express y creamos una variable para poder trabajar con los m\u00e9todos y variables de express. Con el m\u00e9todo <code>express()</code> se crea una aplicaci\u00f3n de express:</p> <pre><code>const express = require('express')\nconst app = express()\n</code></pre> <p>Para iniciar el servidor se usa el m\u00e9todo <code>listen()</code>, muy parecido al m\u00e9todo nativo, que recibe el puerto que debe escuchar y una callback que ejecutar\u00e1 cuando se inicie el servicio:</p> <pre><code>const PORT = process.env.PORT ?? 1234\napp.listen(PORT, () =&gt; {\nconsole.log(`Server listening http://localhost:${PORT}`)\n})\n</code></pre> <p>Express tiene diferentes m\u00e9todos que nos permite trabajar con los m\u00e9todos HTTP sin necesidad de tener que tratarlo en una estructura condicional. Existe un m\u00e9todo de express para cada m\u00e9todo HTTP, <code>get()</code>, <code>post()</code>, <code>patch()</code>, <code>put()</code>, <code>delete()</code>, etc. Estos m\u00e9todos reciben dos par\u00e1metros, en el primero la ruta que debe actuar, y en el segundo una callback que permite tratar con la request y el response:</p> <pre><code>app.get('/', (req, res) =&gt; {\nres.status(200)\n.send('&lt;h1&gt;Mi p\u00e1gina&lt;/h1&gt;')\n})\n</code></pre> <p>Como se puede observar en el m\u00e9todo anterior, express tiene m\u00e9todos para poder trabajar con el response de manera sencilla:</p> <ul> <li><code>status()</code>: Indica el estado del response, por defecto ser\u00e1 200.</li> <li><code>send()</code>: env\u00eda el response. Una de las ventajas de este m\u00e9todo, es que identifica de forma sencilla el tipo de contenido a retornar, por lo que no ser\u00eda necesario indicarle el header Content-Type.</li> <li><code>json()</code>: env\u00eda el response pero adem\u00e1s con el Content-Type en formato JSON.</li> </ul> <pre><code>app.get('/pokemon', (req, res) =&gt; {\nres.json(pokemon)\n})\n</code></pre>"},{"location":"tema_3/page-2/#tratamiento-de-las-rutas","title":"Tratamiento de las rutas","text":"<p>Como ya se vio en el tema anterior, una ruta puede estar definida de la siguiente manera: <code>https://midominio.es/endpoint/param?queryName=queryValue</code> donde :</p> <ul> <li><code>midominio.es</code> es el dominio de la web.</li> <li><code>endpoint</code> es el nombre del recurso con el que tratar.</li> <li><code>param</code> es el par\u00e1metro para obtener el recurso indicado, como por ejemplo una id</li> <li><code>queryName=queryValue</code> es el par clave-valor, donde la clave es el nombre de la instancia a localizar y el valor es su valor. Puede haber tantas queries como sea necesario, separ\u00e1ndolas con <code>&amp;</code></li> </ul> <p>Por ejemplo, con la url <code>https://midominio.es/users/60?deleted=false</code>, localizamos los usuarios cuya id sea 60, pero los que tengan el atributo deleted a false.</p> <p>Para acceder tanto a los par\u00e1metros como a la query, debemos conocer muy bien la url. Sin embargo, express trabaja con un paquete llamado <code>path-to-regexp</code> que permite indicar expresiones regulares a las rutas y acceder a ellas de forma m\u00e1s sencilla.</p> <p>Una de las caracter\u00edsticas de este paquete son los par\u00e1metros nombrados, donde se indicar\u00eda en la ruta el nombre del par\u00e1metro y se pueda acceder a \u00e9l a trav\u00e9s del objeto <code>params</code> de la request:</p> <pre><code>app.get('/pokemon/:id', (req, res) =&gt; {\nconst { id } = req.params\n//...\n})\n</code></pre> <p>Para poder trabajar con las queries, express tiene una propiedad llamada <code>query</code>que almacena en un objeto todos los pares clave-valor:</p> <pre><code>app.get('/pokemon', (req, res) =&gt; {\nconst { deleted } = req.query\n//...\n})\n</code></pre>"},{"location":"tema_3/page-2/#metodo-use","title":"M\u00e9todo use","text":"<p>Express tiene un m\u00e9todo denominado <code>use()</code>, dicho m\u00e9todo se utiliza para indicar una operaci\u00f3n para todo los tipos de m\u00e9todos. Su uso mayoritario suele ser para trabajar con middlewares en la aplicaci\u00f3n, pero cierto que es que se puede usar para cualquier otra cosa, siempre y cuando se tenga en cuenta que no importa el m\u00e9todo que se realiza en la petici\u00f3n.</p> <p>Por ejemplo, podemos usarlo para la ruta pokemon/all, que mostrar\u00e1 un mensaje de error, por que no es una ruta v\u00e1lida:</p> <pre><code>app.use('/pokemon/all', (req, res) =&gt; {\nres.status(404).send('&lt;h1&gt;Error&lt;/h1&gt;')\n})\n</code></pre> <p>Incluso, se puede usar sin indicar ruta, por lo que se traducir\u00e1 que cualquier ruta indicada en cualquier m\u00e9todo har\u00e1 una llamada al callback:</p> <pre><code>app.use((req, res) =&gt; {\nres.status(404).send('&lt;h1&gt;Error&lt;/h1&gt;')\n})\n</code></pre> <p>Hay que tener en cuenta, que el orden en el que se realizan los m\u00e9todos HTTP, as\u00ed como sus rutas son de total importancia. Cuando us\u00e1bamos la forma nativa, se ve\u00eda de forma m\u00e1s clara, por que us\u00e1bamos varios cases y como default, se mostraba un mensaje de error con c\u00f3digo 404. Sin embargo, con express se pierde la estructura condicional, pero su funcionamiento es bastante similar, va comprobando m\u00e9todo a m\u00e9todo si coincide con lo que ha entrado en la request y en caso de coincidir entra y realiza el response. Por ello, cuando queremos usar el m\u00e9todo <code>use</code> para indicar que una ruta no es correcta, es importante colocar dicha operaci\u00f3n al final de las indicaciones de la ruta, de esta forma, validar\u00e1 todos los m\u00e9todos y rutas y si no coincide con ninguna, entrar\u00e1 en el m\u00e9todo <code>use()</code>. Para ello, el orden recomendado ser\u00eda:</p> <ul> <li>Acceso a los middleware</li> <li>Acceso a los recursos de forma directa, por ejemplo /users.</li> <li>Acceso a los recursos con par\u00e1metros, por ejemplo /users/50. Si se indicase este tipo de ruta antes que las rutas de recursos de forma directa /users, podr\u00edan entrar en estas antes (ya que la id, no es un par\u00e1metro obligatorio), y dar lugar a resultados no deseados.</li> <li>Acceso al m\u00e9todo `use() como \u00faltima opci\u00f3n, para devolver un 404.</li> </ul> <pre><code>app.get('/pokemon', (req, res) =&gt; {\n//...\n})\napp.get('/pokemon/:id', (req, res) =&gt; {\n// ...\n})\napp.post('/pokemon', (req, res) =&gt; {\n//...\n})\n// ...\napp.use((req, res) =&gt; {\n// ...\n})\n</code></pre> <p>Tambi\u00e9n es recomendable agrupar todas las rutas por m\u00e9todos, es decir, poner primero todas las rutas de un m\u00e9todo, por ejemplo GET, y despu\u00e9s de otro m\u00e9todo, por ejemplo POST.</p>"},{"location":"tema_3/page-3/","title":"3 Middlewares","text":""},{"location":"tema_3/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Cuando se recibe una petici\u00f3n a trav\u00e9s del protocolo HTTP, este petici\u00f3n debe ser tratada dentro del m\u00e9todo que se indica. Como ya vimos en el tema anterior, cuando se realiza una petici\u00f3n y se env\u00eda un cuerpo del mismo, este cuerpo va llegando poco a poco a medida que se va recibiendo la informaci\u00f3n, por lo que se deber\u00eda de tratar la informaci\u00f3n una vez que haya finalizado la petici\u00f3n, de tal forma que se vaya recolectando la informaci\u00f3n poco a poco vaya llegando en un buffer:</p> <pre><code>app.post('/pokemon', (req, res) =&gt; {\nlet body = ''\nreq.on('data', chunk =&gt; { //(1)!\nbody += chunk.toString()\n})\nreq.on('end', () =&gt; { //(2)!\nconst data = JSON.parse(body)\nbody = data\n//(3)!\n})\n})\n</code></pre> <ol> <li>Va obteniendo la informaci\u00f3n seg\u00fan va llegando, y almacen\u00e1ndola en la variable body.</li> <li>Una vez finalizada la petici\u00f3n parsea el buffer en JSON</li> <li>Una vez parseada la informaci\u00f3n a JSON se trata como necesitemos, a\u00f1adi\u00e9ndola a la base de datos o devolvi\u00e9ndola como respuesta.</li> </ol> <p>Cada vez que tuvi\u00e9ramos que realizar una operaci\u00f3n en la cual se requiera el cuerpo en la petici\u00f3n, ser\u00eda necesario realizar los mismos pasos que en el ejemplo, incluso parsearlo a otro tipo de contenido si fuese necesario.</p>"},{"location":"tema_3/page-3/#middleware","title":"Middleware","text":"<p>Hasta ahora, cuando se realizaba una petici\u00f3n, esta petici\u00f3n era tratada y procesada por el marco de express, y luego devolv\u00eda una response:</p> <p> Figura 3 - Marco Express</p> <p>Un middleware se considera como un paso intermedio, entre la petici\u00f3n y el proceso de la misma, en la cu\u00e1l se pueden realizar operaciones para cualquiera de los m\u00e9todos indicados. De esta forma, si la petici\u00f3n requiere de un cuerpo en formato JSON, el middleware se encargar\u00eda de realizar el parseo y luego ejecutar\u00eda el proceso en el m\u00e9todo correspondiente.</p> <p>Es importante que la callback de un middleware reciba el m\u00e9todo <code>next()</code>, ya que este m\u00e9todo ser\u00e1 el encargado de mandar la request modificada a la petici\u00f3n necesaria.</p> <p> Figura 3 - Marco Express</p> <p>El middleware se puede usar:</p> <ul> <li>Para cualquier m\u00e9todo y ruta, haciendo uso del m\u00e9todo <code>use(cb)</code></li> <li>Para cualquier m\u00e9todo pero para una ruta espec\u00edfica, usando <code>use(path, cb)</code></li> <li>Para cualquier m\u00e9todo cuya ruta que cumpla un expresi\u00f3n regular, <code>use(pathToRegex, cb)</code></li> <li>Para un m\u00e9todo espec\u00edfico, haciendo uso del m\u00e9todo a usar.</li> </ul> <p>El middleware puede ir colocado en cualquier parte del c\u00f3digo donde sea necesario usarlo. Aunque se recomienda que dependiendo del tipo de acceso que se va a tener, se coloque en el lugar pertinente.</p> <pre><code>app.use((req, res, next) =&gt; {\nconsole.log('mi primer middleware')\nif (req.method !== \"POST\") return next()\nif (req.headers['content-type'] !== \"application/json\") return next()\nlet body = ''\nreq.on('data', chunk =&gt; {\nbody += chunk.toString()\n})\nreq.on('end', () =&gt; {\nconst data = JSON.parse(body)\ndata.timestamp = Date.now()\nreq.body = data\nnext()\n})\nnext() // (1)!\n})\napp.post('/pokemon', (req, res) =&gt; {\nconst { body } = req\n// Procesar body NO ES NECESARIO PARSEAR A JSON\n})\n</code></pre> <ol> <li>\u26a0\ufe0fIMPORTANTE\u26a0\ufe0f, indica que tiene que continuar a la siguiente ruta que le toca</li> </ol> <p>En el ejemplo anterior, creamos un middleware que parsee el cuerpo de una petici\u00f3n a JSON. En este ejemplo, observamos que usamos el m\u00e9todo <code>use()</code> para cualquier ruta y m\u00e9todo. Sin embargo, en su interior solo realiza el parseo si el m\u00e9todo es POST y el tipo de contenido indicado en el header es JSON. Es importante indicar el m\u00e9todo <code>next()</code> para que localice la ruta una vez finaliza el middleware. Una vez finalizado el middleware podemos procesar la petici\u00f3n de una forma m\u00e1s sencilla, ya en formato JSON.</p> <p>Podemos tener tantos middlewares como sea necesarios, y podemos usarlos en los m\u00e9todos y rutas que necesitemos:</p> <pre><code>app.post((res,req, next)=&gt;{\nif (req.headers['content-type'] !== \"application/json\") return next()\nlet body = ''\nreq.on('data', chunk =&gt; {\nbody += chunk.toString()\n})\nreq.on('end', () =&gt; {\nconst data = JSON.parse(body)\ndata.timestamp = Date.now()\nreq.body = data\nnext()\n})\nnext()\n})\n</code></pre> <p>En este ejemplo, hemos creado un middleware para cualquier ruta que realice una petici\u00f3n con m\u00e9todo POST.</p>"},{"location":"tema_3/page-3/#middleware-de-terceros","title":"Middleware de terceros","text":"<p>El uso de middlewares es bastante com\u00fan en el dise\u00f1o de aplicaciones REST API, por lo que existe una gran gama de middleware ya creado que podemos usar sin problema. Express sin ir m\u00e1s lejos, tiene su propio middleware para poder parsear el cuerpo de una petici\u00f3n a JSON. Esto tiene la ventaja de que no es necesario realizar todo lo anterior para poder obtener el cuerpo en formato JSON.</p> <pre><code>app.use(express.json())\napp.post('/pokemon', (req, res) =&gt; {\nconst { body } = req\n// Procesar body NO ES NECESARIO PARSEAR A JSON\n})\n</code></pre>"},{"location":"tema_3/page-3/#seguridad-en-express","title":"Seguridad en Express","text":"<p>Al usar Express, por defecto, se a\u00f1ade una cabecera <code>x-powered-by</code> que indica que estamos usando Express para la creaci\u00f3n de nuestra API. Cierto es, que esto puede suponer un problema de seguridad, por lo que se recomienda su deshabilitaci\u00f3n con el m\u00e9todo <code>disable</code>. El m\u00e9todo deshabilita cualquier cabecera que le indiquemos:</p> <pre><code>app.disable('x-powered-by')\n</code></pre>"},{"location":"tema_3/page-3/#post-vs-patch-vs-put","title":"POST vs PATCH vs PUT","text":"<p>La idempotencia es la propiedad de realizar una acci\u00f3n determinada varias veces y a\u00fan as\u00ed conseguir siempre el mismo resultado que se obtendr\u00eda al realizar una sola vez.</p> <p>Muchas personas no saben diferenciar entre los m\u00e9todos POST, PUT o PATCH, a pesar de que son diferentes entre s\u00ed. A la hora de dise\u00f1ar una API REST es conveniente conocer la diferencia para poder hacer las operaciones necesarias de forma correcta.</p> <p>Con el m\u00e9todo POST creamos un nuevo elemento o recurso en el servidor, adem\u00e1s no es necesario un identificador del elemento a crear. El m\u00e9todo POST no es un m\u00e9todo idempotente ya que cada vez que se ejecuta crea un elemento diferente.</p> <p>El m\u00e9todo PUT sirve para actualizar totalmente un elemento o un recurso, por lo que ser\u00eda necesario tener el identificador del elemento. En caso de que el elemento no exista, lo crea.</p> <p>El m\u00e9todo PATCH sirve para realizar una actualizaci\u00f3n parcial de un elemento o recurso dado su identificador, pero en este caso si no existe el elemento no lo crea.</p> <p>Tanto el m\u00e9todo PUT como el m\u00e9todo PATCH son elementos idempotentes ya que siempre devuelven el mismo resultado cuando se ejecuta. Sin embargo, no lo ser\u00edan en caso de tener una propiedad llamada updateAt que almacene la fecha de actualizaci\u00f3n, entonces no devuelven el mismo resultado en cada ejecuci\u00f3n.</p> <p>Hay que tener en cuenta que siempre que se vaya a crear una nuevo recurso o actualizarlo, ser\u00e1 necesario validar el cuerpo de la petici\u00f3n.</p>"},{"location":"tema_3/page-3/#validaciones","title":"Validaciones","text":"<p>Cuando se realiza una petici\u00f3n de actualizaci\u00f3n o de creaci\u00f3n, es importante validar el cuerpo de dicha petici\u00f3n para que concuerde con la estructura del resto de elementos de la API. Por ejemplo, si tenemos un recurso de estudiantes universitarios se deber\u00eda validar que el campo edad sea un campo num\u00e9rico positivo mayores que 18.</p> <pre><code>app.post('/students', (req, res) =&gt; {\nconst { age } = req.body\nif(!age || typeof age !== \"number\" &amp;&amp; age &lt; 18){\nres.status(400).json({message: \"\"})    }\n})\n</code></pre> <p>Realizar estas validaciones puede ser algo pesado e incluso repetitivo. Hay que tener en cuenta que estos problemas no se solucionar\u00e1n haciendo uso de Typescript.</p> <p>Existen diferentes librer\u00edas que te facilitan dicha tarea. Zod es una de las librer\u00edas m\u00e1s conocidas para dicha tarea:</p> <pre><code>const z = require('zod')\n/*(1)!*/const movieSchema = z.object({ //(2)!\ntitle: z.string({ // (3)!\ninvalid_type_error: 'Movie title must be a string',\nrequired_error: 'Movie title is required'\n}),\nyear: z.number().int().min(1900).max(2024), //(4)!\ndirector: z.string(), // (5)!\nduration: z.number().int().positive(), //(6)!\nrate: z.number().int().min(0).max(10).default(0), //(7)!\nposter: z.string().url({ //(8)!\nmessage: 'Poster must be a valid'\n}),\ngenres: z.enum(['Action', 'Adventure', 'Comedy', 'Drama', 'Fantasy', 'Horror', 'Thriller', 'Sci-Fi', 'Crime']).array({\nrequired_error: 'Movie genre is required',\ninvalid_type_error: 'Movie genre must be an array of enum Genre'\n}) //(9)!\n})\nfunction validateMovie(object) {\nreturn movieSchema.safeParse(object)\n}\napp.post('/students', (req, res) =&gt; {\nconst result = validateMovie(req.body) //(10)!\nif (result.error) { //(11)!\nreturn res.status(400).json({ error: JSON.parse(result.error.message) })\n}\n})\n</code></pre> <ol> <li>Esquema donde se indicar\u00e1 que tipo de elemento se espera.</li> <li>Se indica que el elemento ser\u00e1 de tipo object.</li> <li>Se indica que el titulo debe de ser una cadena. Adem\u00e1s se personaliza los mensajes en caso de que haya un error de tipo o un error de requerimiento.</li> <li>Se indica que el a\u00f1o ha de ser un n\u00famero positivo comprendido entre 1900 y 2024.</li> <li>Se indica que el directo debe ser una cadena.</li> <li>Se indica que la duraci\u00f3n debe ser un n\u00famero positivo.</li> <li>Se indica que la calificaci\u00f3n debe ser un n\u00famero positivo comprendido entre 0 y 10, y en caso de que no se indique su valor por defecto ser\u00e1 0.</li> <li>Se indica que el poster debe ser una cadena con URL y se personaliza el mensaje de error.</li> <li>Se indica que la propiedad g\u00e9nero puede tener un valor comprendido entre los que se encuentra en el enum. Adem\u00e1s se indica que dicha propiedad debe ser un array, por lo que se puede indicar m\u00e1s de uno.</li> <li>Se valida el cuerpo de la petici\u00f3n</li> <li>Se comprueba si existe un error en el resultado de la validaci\u00f3n, y en caso afirmativo se devuelve una respuesta con el mensaje de errorb</li> </ol>"},{"location":"tema_3/page-4/","title":"4 CORS","text":""},{"location":"tema_3/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Cuando se crea un servidor HTTP como podemos hacer con un API REST, y realizamos peticiones a dicho servidor desde otros dominios o servidores, suele ocurrir un error de CORS.</p> <p>Este tipo de error es un error sencillo de manejar pero que mucho desarrolladores obvian e incluso no entienden a la perfecci\u00f3n.</p>"},{"location":"tema_3/page-4/#definicion","title":"Definici\u00f3n","text":"<p>El Cross Origin Resource Sharing (CORS), o bien el cruce de recursos de origen compartido es un mecanismo que te permite que un recurso sea restringido en una p\u00e1gina web para evitar que un origen o un dominio fuera de otro dominio desde que se sirvi\u00f3 ese recurso se pueda acceder a \u00e9l.</p> <p>El navegador recibe la petici\u00f3n del usuario y le pregunta a la API si un dominio que no es el de la propia API puede realizar la petici\u00f3n. Si en la API no se ha configurado ning\u00fan tipo de acceso la API le contesta al navegador que no, por lo que le devuelve al usuario un error de CORS.</p> <p> Figura 5 - ERROR CORS</p>"},{"location":"tema_3/page-4/#dar-permisos-de-control-de-acceso","title":"Dar permisos de Control de Acceso","text":"<p>Para solucionar el problema de CORS debemos modificar la cabecera Access-Control-Allow-Origin. El valor de dicha cabecera se indicar\u00e1 el origen que s\u00ed puede acceder a nuestro dominio:</p> <pre><code>res.header('Access-Control-Allow-Origin', 'tudominio.es')\n</code></pre> <p>Si se desea permitir el acceso desde cualquier dominio se puede indicar con un asterisco (<code>*</code>):</p> <pre><code>res.header('Access-Control-Allow-Origin', '*')\n</code></pre> <p>Hay que tener en cuenta la seguridad a la hora de dar acceso completo a nuestra web, ya que a veces puede ser una operaci\u00f3n peligrosa.</p>"},{"location":"tema_3/page-4/#cabecera-origin","title":"Cabecera Origin","text":"<p>Cuando realizamos una petici\u00f3n podemos comprobar su origen a trav\u00e9s de la cabecera origin. De esta forma podemos filtrar el acceso y comprobar si es un dominio aceptado de una lista de dominios:</p> <pre><code>const ACCEPTED_ORIGINS = [\n'http://localhost:8080',\n'http://localhost:1234',\n'https://movies.com',\n]\napp.get('/movies', (req, res) =&gt; {\nconst origin = req.header('origin')\nif(ACCEPTED_ORIGINS.includes(origin)){\nres.header('Access-Control-Allow-Origin', origin)\n}\n})\n</code></pre> <p>En el ejemplo anterior, tenemos una lista de dominios que si nos interesa que pueda realizar una petici\u00f3n GET, por lo que comprobamos si el origen de la petici\u00f3n coincide con uno de los dominios de la lista. En caso afirmativo, le devolvemos la respuesta con el acceso permitido.</p> <p>Sin embargo, si realizamos la petici\u00f3n desde el mismo dominio que nuestra API, la cabecera origin no s\u00e9 env\u00eda, por lo que se debe controlar. En ese caso, si la cabecera origin no est\u00e1 definida, podemos entender que estamos hablando de nuestro mismo dominio:</p> <pre><code>const ACCEPTED_ORIGINS = [\n'http://localhost:8080',\n'http://localhost:1234',\n'https://movies.com',\n]\napp.get('/movies', (req, res) =&gt; {\nconst origin = req.header('origin')\nif(ACCEPTED_ORIGINS.includes(origin) || !origin){\nres.header('Access-Control-Allow-Origin', origin)\n}\n})\n</code></pre>"},{"location":"tema_3/page-4/#cors-como-middleware","title":"CORS como middleware","text":"<p>El control del acceso a nuestro servidor desde otros dominios se puede manejar en cualquier petici\u00f3n que se realice. Por ejemplo, podemos restringir el acceso solo a todos los dominios que realicen una petici\u00f3n POST desde cualquier recurso, o desde un recurso espec\u00edfico.</p> <p>Tambi\u00e9n se puede usar como middleware, de tal forma que controlemos el acceso para cualquier petici\u00f3n en cualquier m\u00e9todo:</p> <pre><code>const ACCEPTED_ORIGINS = [\n'http://localhost:8080',\n'http://localhost:1234',\n'https://movies.com',\n'https://midu.dev'\n]\napp.use((req, res, next) =&gt; {\nconst origin = req.header('origin')\nif(ACCEPTED_ORIGINS.includes(origin) || !origin){\nres.header('Access-Control-Allow-Origin', origin)\n}\nnext()\n})\n</code></pre>"},{"location":"tema_3/page-4/#peticiones-pre-flight","title":"Peticiones PRE-Flight","text":"<p>Cuando el usuario realiza una petici\u00f3n a nuestra API, hay algunos m\u00e9todos que requieren un m\u00e9todo previo y especial, si ese m\u00e9todo devuelve un OK se ejecutar\u00e1 el m\u00e9todo solicitado. Este proceso se conoce com\u00fanmente como CORS PRE-Flight, y se debe controlar el CORS tanto en la petici\u00f3n compleja como en la especial.  </p> <p>Los m\u00e9todos normales son: HEAD, GET y POST, y por lo tanto solo se validar\u00eda el CORS en dichos m\u00e9todos. Los m\u00e9todos complejos son PUT, PATCH y DELETE, mientras que el m\u00e9todo especial e intermedio es OPTIONS. por lo que se deber\u00eda validar el CORS tanto en dichos m\u00e9todos como en el m\u00e9todo OPTIONS.</p> <pre><code>app.delete('/movies/:id', (req, res) =&gt; {\nconst origin = req.header('origin')\nif (ACCEPTED_ORIGINS.includes(origin) || !origin) {\nres.header('Access-Control-Allow-Origin', origin)\n}\n// ...\n})\n</code></pre> <p>En el ejemplo anterior, comprobamos el origen de la petici\u00f3n, pero en este caso aunque sea un origen aceptado, nos lanzar\u00e1 un error de CORS, ya que antes de la petici\u00f3n DELETE realiza una petici\u00f3n previa OPTIONS, y al no ser controlada la CORS en dicha petici\u00f3n recibiremos igualmente un error de cORS. Para solucionar dicho problema ser\u00e1 necesario comprobarlo en dicho m\u00e9todo:</p> <pre><code>app.delete('/movies/:id', (req, res) =&gt; {\nconst origin = req.header('origin')\nif (ACCEPTED_ORIGINS.includes(origin) || !origin) {\nres.header('Access-Control-Allow-Origin', origin)\n}\n// ...\n})\napp.options('/movies/:id', (req, res) =&gt; {\nconst origin = req.header('origin')\nif (ACCEPTED_ORIGINS.includes(origin) || !origin) {\nres.header('Access-Control-Allow-Origin', origin)\nres.header('Access-Control-Allow-Methods', 'GET, POST, PATCH, DELETE')\n}\nres.send(200)\n})\n</code></pre>"},{"location":"tema_3/page-5/","title":"Proyecto","text":"<p>Se desea crear una API siguiendo la arquitectura REST para almacenar y mostrar las pel\u00edculas y colecciones de una famosa plataforma de streaming. Se considera como una colecci\u00f3n a aquel elemento que dicta caracter\u00edsticas comunes de una serie de pel\u00edculas. Por ejemplo, la colecci\u00f3n Star Wars Collection es una colecci\u00f3n para el universo de pel\u00edculas de Star Wars. Hay que tener en cuenta que una pel\u00edcula no tiene porque pertenecer a una colecci\u00f3n, y que una colecci\u00f3n puede que no tenga ninguna pel\u00edcula de momento.</p> <p>Las operaciones que se pueden realizar sobre la API son las siguientes:</p> <ul> <li>Obtener todas las pel\u00edculas, mostrando el nombre de la colecci\u00f3n.</li> <li>Obtener todas las pel\u00edculas ordenadas por el campo que indique el usuario.</li> <li>Obtener todas las pel\u00edculas filtradas por g\u00e9nero.</li> <li>Obtener todas las pel\u00edculas filtradas por a\u00f1o.</li> <li>Obtener todas las pel\u00edculas filtradas por colecci\u00f3n.</li> <li>Obtener todas las colecciones incluidas las pel\u00edculas que pertenecen a dicha colecci\u00f3n.</li> <li>Obtener una colecci\u00f3n o una pel\u00edcula dado su identificador</li> <li>Poder subir una pel\u00edcula o una colecci\u00f3n.</li> <li>Poder actualizar de forma parcial y de forma completa una pel\u00edcula y una colecci\u00f3n, teniendo en cuenta de que si no existe, debe mostrar un error en el parcial o crearla en el completo.</li> <li>Eliminar una pel\u00edcula por su nombre o su identificador.</li> <li>Eliminar varias pel\u00edculas por g\u00e9nero.</li> <li>Eliminar una colecci\u00f3n.</li> </ul> <p>Los datos previos de la API son los siguientes:</p> MOVIESCollections <pre><code>[\n{\n\"id\": \"dcdd0fad-a94c-4810-8acc-5f108d3b18c3\",\n\"title\": \"The Shawshank Redemption\",\n\"year\": 1994,\n\"director\": \"Frank Darabont\",\n\"duration\": 142,\n\"poster\": \"https://i.ebayimg.com/images/g/4goAAOSwMyBe7hnQ/s-l1200.webp\",\n\"genre\": [\n\"Drama\"\n],\n\"rate\": 9.3\n},\n{\n\"id\": \"c8a7d63f-3b04-44d3-9d95-8782fd7dcfaf\",\n\"title\": \"The Dark Knight\",\n\"year\": 2008,\n\"director\": \"Christopher Nolan\",\n\"duration\": 152,\n\"poster\": \"https://i.ebayimg.com/images/g/yokAAOSw8w1YARbm/s-l1200.jpg\",\n\"genre\": [\n\"Action\",\n\"Crime\",\n\"Drama\"\n],\n\"rate\": 9.0,\n\"collection\": 1\n},\n{\n\"id\": \"5ad1a235-0d9c-410a-b32b-220d91689a08\",\n\"title\": \"Inception\",\n\"year\": 2010,\n\"director\": \"Christopher Nolan\",\n\"duration\": 148,\n\"poster\": \"https://m.media-amazon.com/images/I/91Rc8cAmnAL._AC_UF1000,1000_QL80_.jpg\",\n\"genre\": [\n\"Action\",\n\"Adventure\",\n\"Sci-Fi\"\n],\n\"rate\": 8.8\n},\n{\n\"id\": \"241bf55d-b649-4109-af7c-0e6890ded3fc\",\n\"title\": \"Pulp Fiction\",\n\"year\": 1994,\n\"director\": \"Quentin Tarantino\",\n\"duration\": 154,\n\"poster\": \"https://www.themoviedb.org/t/p/original/vQWk5YBFWF4bZaofAbv0tShwBvQ.jpg\",\n\"genre\": [\n\"Crime\",\n\"Drama\"\n],\n\"rate\": 8.9\n},\n{\n\"id\": \"9e6106f0-848b-4810-a11a-3d832a5610f9\",\n\"title\": \"Forrest Gump\",\n\"year\": 1994,\n\"director\": \"Robert Zemeckis\",\n\"duration\": 142,\n\"poster\": \"https://i.ebayimg.com/images/g/qR8AAOSwkvRZzuMD/s-l1600.jpg\",\n\"genre\": [\n\"Drama\",\n\"Romance\"\n],\n\"rate\": 8.8\n},\n{\n\"id\": \"7e3fd5ab-60ff-4ae2-92b6-9597f0308d1\",\n\"title\": \"Gladiator\",\n\"year\": 2000,\n\"director\": \"Ridley Scott\",\n\"duration\": 155,\n\"poster\": \"https://img.fruugo.com/product/0/60/14417600_max.jpg\",\n\"genre\": [\n\"Action\",\n\"Adventure\",\n\"Drama\"\n],\n\"rate\": 8.5\n},\n{\n\"id\": \"c906673b-3948-4402-ac7f-73ac3a9e3105\",\n\"title\": \"The Matrix\",\n\"year\": 1999,\n\"director\": \"Lana Wachowski\",\n\"duration\": 136,\n\"poster\": \"https://i.ebayimg.com/images/g/QFQAAOSwAQpfjaA6/s-l1200.jpg\",\n\"genre\": [\n\"Action\",\n\"Sci-Fi\"\n],\n\"rate\": 8.7\n},\n{\n\"id\": \"b6e03689-cccd-478e-8565-d92f40813b13\",\n\"title\": \"Interstellar\",\n\"year\": 2014,\n\"director\": \"Christopher Nolan\",\n\"duration\": 169,\n\"poster\": \"https://m.media-amazon.com/images/I/91obuWzA3XL._AC_UF1000,1000_QL80_.jpg\",\n\"genre\": [\n\"Adventure\",\n\"Drama\",\n\"Sci-Fi\"\n],\n\"rate\": 8.6\n},\n{\n\"id\": \"aa391090-b938-42eb-b520-86ea0aa3917b\",\n\"title\": \"The Lord of the Rings: The Return of the King\",\n\"year\": 2003,\n\"director\": \"Peter Jackson\",\n\"duration\": 201,\n\"poster\": \"https://i.ebayimg.com/images/g/0hoAAOSwe7peaMLW/s-l1600.jpg\",\n\"genre\": [\n\"Action\",\n\"Adventure\",\n\"Drama\"\n],\n\"rate\": 8.9,\n\"collection\": 2\n},\n{\n\"id\": \"2e6900e2-0b48-4fb6-ad48-09c7086e54fe\",\n\"title\": \"The Lion King\",\n\"year\": 1994,\n\"director\": \"Roger Allers, Rob Minkoff\",\n\"duration\": 88,\n\"poster\": \"https://m.media-amazon.com/images/I/81BMmrwSFOL._AC_UF1000,1000_QL80_.jpg\",\n\"genre\": [\n\"Animation\",\n\"Adventure\",\n\"Drama\"\n],\n\"rate\": 8.5,\n\"collection\": 3\n},\n{\n\"id\": \"04986507-b3ed-442c-8ae7-4c5df804f896\",\n\"title\": \"The Avengers\",\n\"year\": 2012,\n\"director\": \"Joss Whedon\",\n\"duration\": 143,\n\"poster\": \"https://img.fruugo.com/product/7/41/14532417_max.jpg\",\n\"genre\": [\n\"Action\",\n\"Adventure\",\n\"Sci-Fi\"\n],\n\"rate\": 8.0,\n\"collection\": 4\n},\n{\n\"id\": \"7d2832f8-c70a-410e-8963-4c93bf36cc9c\",\n\"title\": \"Jurassic Park\",\n\"year\": 1993,\n\"director\": \"Steven Spielberg\",\n\"duration\": 127,\n\"poster\": \"https://vice-press.com/cdn/shop/products/Jurassic-Park-Editions-poster-florey.jpg?v=1654518755&amp;width=1024\",\n\"genre\": [\n\"Adventure\",\n\"Sci-Fi\"\n],\n\"rate\": 8.1,\n\"collection\": 5\n},\n{\n\"id\": \"ccf36f2e-8566-47f7-912d-9f4647250bc7\",\n\"title\": \"Titanic\",\n\"year\": 1997,\n\"director\": \"James Cameron\",\n\"duration\": 195,\n\"poster\": \"https://i.pinimg.com/originals/42/42/65/4242658e6f1b0d6322a4a93e0383108b.png\",\n\"genre\": [\n\"Drama\",\n\"Romance\"\n],\n\"rate\": 7.8,\n\"collection\": 6\n},\n{\n\"id\": \"8fb17ae1-bdfe-45e5-a871-4772d7e526b8\",\n\"title\": \"The Social Network\",\n\"year\": 2010,\n\"director\": \"David Fincher\",\n\"duration\": 120,\n\"poster\": \"https://i.pinimg.com/originals/7e/37/b9/7e37b994b613e94cba64f307b1983e39.jpg\",\n\"genre\": [\n\"Biography\",\n\"Drama\"\n],\n\"rate\": 7.7\n},\n{\n\"id\": \"6a360a18-c645-4b47-9a7b-2a71babbf3e0\",\n\"title\": \"Avatar\",\n\"year\": 2009,\n\"director\": \"James Cameron\",\n\"duration\": 162,\n\"poster\": \"https://i.etsystatic.com/35681979/r/il/dfe3ba/3957859451/il_fullxfull.3957859451_h27r.jpg\",\n\"genre\": [\n\"Action\",\n\"Adventure\",\n\"Fantasy\"\n],\n\"rate\": 7.8,\n\"collection\": 6\n}\n]\n</code></pre> <pre><code>[\n{\n\"id\": 1,\n\"title\": \"DC\"\n},\n{\n\"id\": 2,\n\"title\": \"The Lord of the Rings\"\n},\n{\n\"id\": 3,\n\"title\": \"Disney\"\n},\n{\n\"id\": 4,\n\"title\": \"Marvel\"\n},\n{\n\"id\": 5,\n\"title\": \"Jurassic\"\n},\n{\n\"id\": 6,\n\"title\": \"James Cameron\"\n}\n]\n</code></pre>"}]}