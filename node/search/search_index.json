{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"tema_1/page-1/","title":"1 Introducci\u00f3n a Node JS","text":""},{"location":"tema_1/page-1/#que-es-node-js","title":"\u00bfQu\u00e9 es Node JS?","text":"<p>En la manera de programaci\u00f3n actual existen diferentes tipos de herramientas para facilitar el trabajo a la hora de realizar una aplicaci\u00f3n, incluso esas herramientas nos permiten realizar diferentes tipos de aplicaciones y/o proyectos. Por ejemplo, tenemos librer\u00edas que nos facilitan el desarrollo front-end (React), frameworks que nos permiten crear aplicaciones multiplataformas (Flutter), etc.</p> <p>Sin embargo, Node JS no entrar\u00eda en ninguna de estas categor\u00edas, ya que no se considera ni una librer\u00eda, ni un framework. Por el contrario, **Node JS es un entorno de ejecuci\u00f3n para Javascript que permite ejecutar Javascript sin necesidad de hacer uso de un navegador.</p> <p>Algunas de las caracter\u00edsticas que podemos encontrar en este entorno son:</p> <ul> <li>Es de c\u00f3digo abierto, haciendo uso de la licencia MIT.</li> <li>Es multiplataforma.</li> <li>As\u00edncrono y controlado por eventos. Todas las APIs (m\u00f3dulos) de NodeJs son as\u00edncronos, es decir, no realizan operaciones bloqueantes.</li> <li>Es un entorno de ejecuci\u00f3n muy r\u00e1pida.</li> <li>No realiza almacenamiento en buffer.</li> <li>Los procesos se realizan en un solo hilo, ya que Node JS es mono-hilo pero aun as\u00ed es altamente escalable.</li> </ul> <p>Uno de los motivos de que Node JS tenga esas caracter\u00edsticas es que utiliza el motor V8, que es el mismo motor usado en el navegador Chrome. La ventaja de esto es que se puede obtener todas las ventajas de una aplicaci\u00f3n Javascript en el entorno de Chrome pero haciendo uso de ellas en un entorno totalmente diferente.</p> <p>Node JS tambi\u00e9n est\u00e1 orientado a eventos, es decir,va ejecutando tareas mientras espera respuestas de otros tareas, haciendo todo esto en un \u00fanico hilo.</p>"},{"location":"tema_1/page-1/#ventajas-y-desventajas-de-usar-node-js","title":"Ventajas y desventajas de usar Node JS","text":"<p>Algunas de las ventajas que encontramos a la hora de usar Node JS son:</p> <ul> <li>Rendimiento y escalabilidad: Haciendo uso del motor V8 permite gestionar m\u00faltiples conexiones simult\u00e1neas sin bloquear el proceso principal.</li> <li>Facilidad de aprendizaje: Dado que Javascript es un lenguaje f\u00e1cil y popular y con una gran curva de aprendizaje.</li> <li>Gran ecosistema de paquetes y comunidad: Existe un gran ecosistemas de paquetes (Node JS tiene uno de los m\u00e1s grandes actualmente) lo que facilita la reutilizaci\u00f3n y compartici\u00f3n de c\u00f3digo. Adem\u00e1s, la comunidad es activa y colaborativa permitiendo as\u00ed un intercambio de conocimientos y soluciones.</li> <li>Programaci\u00f3n as\u00edncrona: Al usar programaci\u00f3n as\u00edncrona impide que el hilo principal se bloquee.</li> </ul> <p>Por el contrario, Node JS tambi\u00e9n tiene una serie de desventajas:</p> <ul> <li>Programaci\u00f3n as\u00edncrona: La programaci\u00f3n as\u00edncrona requiere puede ser un poco compleja para los desarrolladores acostumbrados a la programaci\u00f3n s\u00edncrona, adem\u00e1s puede ser lioso el manejo de errores.</li> <li>Falta de soporte para la programaci\u00f3n multihilo: Actualmente, no existe m\u00f3dulos dentro de Node JS que traten el tema de los multihilos. Sin embargo, existen diferentes librer\u00edas externas que nos permite poder trabajar con ellas.</li> </ul>"},{"location":"tema_1/page-1/#motivos-para-aprender-node-js","title":"Motivos para aprender Node JS","text":"<ol> <li>Gran demanda en el mercado, ya que Node JS es tan vers\u00e1til que las empresas lo usan para diferentes escenarios. Adem\u00e1s, Node JS pertenece a MERN Stack (**M**ongoDB **E**xpress **R**eact **N**odeJS) y al MEAN Stack, (**M**ongoDB **E**xpress **A**ngular **N**odeJS) que son soluciones de software para desarrollar aplicaciones web de forma r\u00e1pida y sencilla.</li> <li>Se puede usar los conocimientos de Javascript en Node JS.</li> <li>Tiene una gran comunidad y un gran ecosistema.</li> <li>R\u00e1pido, escalable, f\u00e1cil y barato de desplegar.</li> </ol> <p>A pesar de que sea monoproceso, eso en ciertos caso puede llevar una gran ventaja.</p>"},{"location":"tema_1/page-1/#historia","title":"Historia","text":"<p>Node fue creado en 2009 por Ryan Dahl programador en ese entonces de la empresa Joyent (dedicada a ofrecer servicios de c\u00f3mputo en la nube) que a su vez se convirti\u00f3 en la propietaria de la marca Node.js\u2122 y la que le dar\u00eda patrocinio y difusi\u00f3n desde el momento de su creaci\u00f3n.</p> <p>Joyent puso todo su empe\u00f1o para el desarrollo de Node, sin embargo, al ser una empresa del sector privado y no una comunidad o fundaci\u00f3n, los avances de Node comenzaron a ser muy lentos, en comparaci\u00f3n de lo que la comunidad solicitaba y que tambi\u00e9n quer\u00eda contribuir.</p> <p>Con el paso del tiempo y durante los siguientes 5 a\u00f1os (2009 a 2014) se fueron entregando versiones de Node a paso de tortuga pues nunca se llego como tal a una versi\u00f3n 1.0.0 estable, la \u00faltima versi\u00f3n de Node bajo la gobernabilidad de Joyent fue la 0.12.7.</p> <p>La comunidad al ver el brillante futuro que podr\u00eda tener Node en el ecosistema web y la insuficiencia (o incompetencia) de Joyent para sacarlo adelante, decide tomar cartas en el asunto e intenta contribuir al core de Node, sin embargo Joyent se opone a reconocer cualquier cambio no supervisado por ellos bajo el nombre comercial de Node.js\u2122, por lo que la comunidad decide lanzar un fork amigable de Node compatible con npm y liderado bajo un modelo de gobernabilidad abierta con el nombre de io.js.</p> <p>Con io.js el entorno de Node gan\u00f3 mejoras que se ven\u00edan esperando desde hace mucho tiempo tales como:</p> <ul> <li>Soporte para las \u00faltimas versiones de V8 y ES6</li> <li>Desarrollo activo haciendo liberaciones semanales</li> <li>Integraci\u00f3n continua y ejecuci\u00f3n de pruebas al 100%</li> <li>Vinculaci\u00f3n con la comunidad</li> <li>Gobernabilidad abierta por la comunidad y no por empresas</li> <li>Hoja de ruta predecible</li> <li>Versiones compatibles con SemVer</li> <li>Comienza a incrementar su actividad nuevamente</li> </ul> <p>La reacci\u00f3n de Joyent, propietario de Node.js\u2122 fue lanzar la versi\u00f3n 0.12.1 que la comunidad estaba esperando desde hac\u00eda 2 a\u00f1os, sin embargo y por la premura y sorpresa de io.js sali\u00f3 con un par de errores por lo que tuvieron que lanzar una versi\u00f3n 0.12.2 en cuesti\u00f3n de d\u00edas. Con ello Joyent logra mantener la paridad de caracter\u00edsticas con io.js. Es importante mencionar que todo esto sucede en diciembre del 2014 y io.js se libera oficialmente el 13 de enero del 2015. Despu\u00e9s de un par de meses de la liberaci\u00f3n de io.js, ambas partes, comunidad y Joyent manifiestan su intenci\u00f3n de reconciliar los proyectos en uno s\u00f3lo, la fundaci\u00f3n Linux se ofrece como mediador de la situaci\u00f3n y entonces el 8 de mayo del 2015 se crea la Node.js Foundation encargada de reunificar las tecnolog\u00edas en una sola, dicho proyecto lo llamaron Node.js Convergence.</p> <p>Los objetivos de dicha fundaci\u00f3n eran claros:</p> <ul> <li>Crear un consejo de fundaci\u00f3n encargado de la parte legal, marca, mercadotecnia y fondos gestionado por Joyent.</li> <li>Crear un comit\u00e9 t\u00e9cnico que actu\u00e9 de forma independiente y permita el crecimiento del ecosistema JS en el servidor gestionado por la comunidad.</li> <li>Normalizar y unificar las versiones actuales de Node.js\u2122 (0.12.X) y io.js (3.X.X) en una sola tecnolog\u00eda.</li> </ul> <p>Finalmente el 8 de septiembre del 2015 sale a la luz esa convergencia en Node 4.0.0 (estable) y con ello un futuro interesante para JavaScript en el servidor.</p> <p>Desde su nacimiento de io.js se fueron liberando versiones semanales hasta llegar a la versi\u00f3n 3.3.0, en consideraci\u00f3n a esta evoluci\u00f3n y al fuerte compromiso de la comunidad activa que se matuvo viva y fuerte por hacer crecer el ecosistema de JavaScript en el servidor es que se decide relanzar Node en la versi\u00f3n 4.0.0.</p>"},{"location":"tema_1/page-1/#instalacion","title":"Instalaci\u00f3n","text":"<p>Para instalar Node JS existen dos formas para poder realizarlo. La primera de ellas, es ir directamente a la p\u00e1gina oficial de Node JS. En este m\u00e9todo tenemos que tener que diferencias dos tipos de versiones:</p> <ul> <li>Versi\u00f3n LTS (Long-term supported): Esta versi\u00f3n es la recomendada por lo mismo desarrolladores de Node JS, ya que es la versi\u00f3n estable, la cual permite obtener la \u00faltima versi\u00f3n con un mejor soporte y con mayor duraci\u00f3n de la misma.</li> <li>Versi\u00f3n Actual: Esta es la \u00faltima versi\u00f3n oficial de Node JS, pero al ser la \u00faltima y la m\u00e1s nueva puede que algunas funciones no funcionen como deber\u00edan, lo que hace que no sea una versi\u00f3n estable.</li> </ul> <p>A veces, trabajamos con tantos proyectos a la vez que cada uno de ellos se ejecuta en una versi\u00f3n diferente de Node JS, esto puede acarrear problemas, por ello existen diferentes manejadores que permiten tener en un mismo sistema operativo diferentes versiones de Node JS, de esta forma poder tener diferentes proyectos con diferentes versiones.</p> <p>Una de las m\u00e1s conocidas es nvm, que puede ser instalado en Linux y MacOS (para Windows existe una versi\u00f3n espec\u00edfica nvm-windows) y fnm es otra de las recomendadas.</p> <p>Otra forma de poder tener diferentes versiones en diferentes proyectos es haciendo uso de la dockerizaci\u00f3n a trav\u00e9s de contenedores Docker.</p>"},{"location":"tema_1/page-1/#primeros-pasos","title":"Primeros Pasos","text":"<p>Una vez instalada Node JS con el m\u00e9todo elegido, podemos comprobar que todo est\u00e1 correctamente instalado haciendo uso del siguiente comando:</p> <pre><code>node --version # v18.17.0\n</code></pre> <p>Haciendo uso del comando <code>node</code> se nos habilitar\u00e1 la consola de Node JS la cual, a trav\u00e9s del repl (bucle infinito que va tramitando el Javascript que se va solicitando) nos permitir\u00e1 ejecutar c\u00f3digo Javascript sin necesidad de almacenarlo en ning\u00fan fichero.</p> <pre><code>&gt; const saludo = \"Hola Mundo\"\nundefined\n&gt; console.log(saludo)\nhola\nundefined\n&gt; function suma(a,b){ return a + b }\nundefined\n&gt; console.log(suma(1,2))\n3\nundefined\n&gt;\n</code></pre> <p>Haciendo uso del comando <code>node FILE_NAME.js</code>, donde FILE_NAME es el nombre del fichero donde se almacena el c\u00f3digo Javascript, se puede ejecutar el c\u00f3digo incrustado en el fichero desde la misma consola.</p> FicheroConsola <pre><code>const saludo = \"Hola mundo\"\nconst suma = (a, b) =&gt; a + b\nconsole.log(saludo)\nconsole.log(suma(1, 2))\n</code></pre> <pre><code>&gt; node index.js\nHola mundo\n3\n</code></pre>"},{"location":"tema_1/page-1/#variable-globalthis","title":"Variable globalThis","text":"<p>Cuando ejecutamos un archivo Javascript desde el navegador la variable global es la variable <code>window</code>, con la cual podemos acceder a otras variables y m\u00e9todos como <code>console</code>, <code>document</code>, etc. pero cuando se ejecuta Javascript desde la consola Node JS no podemos acceder a la variable<code>window</code> ya que es una variable del navegador. \u00bfEntonces como se puede acceder al objeto <code>console</code> si no se puede acceder a <code>window</code>? La variable global para la consola es <code>global</code>.</p> <p>La variable global <code>globalThis</code> es la variable global que se utiliza para acceder a la variable global del entorno en el que se ejecute Javascript desde Node JS. De esta forma se puede acceder a las propiedades, objetos y m\u00e9todos como <code>console</code>. Si ejecutamos Node JS desde la consola accederemos a la variable global <code>global</code> y si lo ejecutamos en el navegador apuntar\u00e1 a <code>window</code>. Por eso es importante que cada vez que se quiera acceder a la variable global desde Node JS se use <code>globalThis</code>.</p> <p>Warning</p> <p>Si estamos ejecutando una aplicaci\u00f3n de consola con Node JS no es recomendable usar <code>global</code> ya que puede crear confusi\u00f3n con la variable <code>globalThis</code>que es la que se recomienda usar para as\u00ed evitar errores.</p>"},{"location":"tema_1/page-2/","title":"2 Modularizaci\u00f3n","text":""},{"location":"tema_1/page-2/#patron-de-diseno-modulo","title":"Patr\u00f3n de dise\u00f1o m\u00f3dulo","text":"<p>El patr\u00f3n de dise\u00f1o m\u00f3dulo tiene como objetivo separar el c\u00f3digo Javascript en diferentes m\u00f3dulos (a veces en diferentes ficheros), de tal modo que el c\u00f3digo sea m\u00e1s legible, entendible, reusable y f\u00e1cil de acceder.</p> <p>Podemos entender como un m\u00f3dulo una funci\u00f3n que se comporta como un contenedor para un contexto de ejecuci\u00f3n. Dentro de est\u00e1 funci\u00f3n se pueden declarar diferentes variables.</p> <p>Lo primero que debemos hacer es crear una funci\u00f3n global con el c\u00f3digo que quiero reutilizar, por ejemplo variables y otros m\u00e9todos.</p> <pre><code>function myApp() {\nvar number = 0, letter = 'A'\nfunction apply(increment){\nreturn number + increment\n}\n}\n</code></pre> <p>La funci\u00f3n deber\u00e1 devolver un objeto con el nombre de acceso a las variables y a los m\u00e9todos que contiene, de esta manera se podr\u00e1n acceder a ellos fuera de la misma funci\u00f3n:</p> <pre><code>function myApp() {\nvar number = 0, letter = 'A'\nfunction apply(increment){\nreturn number + increment\n}\nreturn {\nnumber: number,\nletter: letter,\napply: apply\n}\n}\n</code></pre> <p>Como se puede observar el objeto debe tener un nombre para poder acceder a \u00e9l fuera de la funci\u00f3n <code>myApp</code>. Si el nombre de la variable y/o m\u00e9todo es el mismo se puede omitir escribi\u00e9ndolo una \u00fanica vez.</p> <pre><code>function myApp() {\nvar number = 0, letter = 'A'\nfunction apply(increment){\nreturn number + increment\n}\nreturn { number, letter, apply }\n}\n</code></pre> <p>De esta forma podemos crear variables y m\u00e9todos que sean p\u00fablicos o privados. Los p\u00fablicos son los que retornamos e incluimos en el objeto y los privados son los que no retornamos.</p> <pre><code>function myApp() {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n}\n</code></pre> <p>Adem\u00e1s para poder acceder al m\u00f3dulo primero habr\u00e1 que invocar la funci\u00f3n:</p> <pre><code>function myApp() {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n}\nconst variable = myApp()\nconsole.log(variable.number) // 0\nconsole.log(variable.letter) // A\nconsole.log(variable.apply(10)) // 10\n</code></pre> <p>Esto se puede simplificar realizando la autoinvocaci\u00f3n, es decir, creando la funci\u00f3n y luego usando <code>()</code> para invocarla. Para ello la funci\u00f3n tiene que estar entre par\u00e9ntesis para que primero se cree y luego se invoque:</p> <pre><code>const variable = (function myApp() {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n})()\nconsole.log(variable.number) // 0\nconsole.log(variable.letter) // A\nconsole.log(variable.apply(10)) // 10\n</code></pre> <p>Se puede reducir m\u00e1s haciendo uso de las arrow functions con autoinvocaci\u00f3n:</p> <pre><code>const myApp = (() =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n})()\nconsole.log(myApp.number) // 0\nconsole.log(myApp.letter) // A\nconsole.log(myApp.apply(10)) // 10\n</code></pre> <p>Una de las ventajas que tiene la modularizaci\u00f3n es que se puede usar la destructuraci\u00f3n para acceder a las variables y m\u00e9todos internos del m\u00f3dulo:</p> <pre><code>const myApp = (() =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n})()\nconst {number, letter, apply} = myApp\nconsole.log(number) // 0\nconsole.log(letter) // A\nconsole.log(apply(10)) // 10\n</code></pre> Ejercicio 1 <p>Realiza una aplicaci\u00f3n con Javascript la cual realice las operaciones b\u00e1sicas: sumar, restar, multiplicar y dividir. Haciendo uso del patr\u00f3n de m\u00f3dulos, pon a prueba las funciones creadas.</p>"},{"location":"tema_1/page-2/#importar-y-exportar","title":"Importar y exportar","text":"<p>Para poder usar las variables y los m\u00e9todos de un fichero Javascript en otro fichero en Node JS es necesario exportar el c\u00f3digo en el fichero de la funci\u00f3n que se desea reutilizar e importarlo en el fichero que se desea usar.</p> <p>En Node JS existen dos maneras de realizar dichas operaciones, una m\u00e1s convencional y antigua pero que a\u00fan as\u00ed sigue en uso actualmente, denominada CommonJS, y otra m\u00e1s moderna que hace uso del ECMAScript 6 (ES6). El problema de la segunda es que de forma nativa no se puede usar con archivos .js si no con archivos .mjs, aunque existe una forma de poder utilizarlo en Node JS que veremos m\u00e1s adelante.</p>"},{"location":"tema_1/page-2/#commonjs","title":"CommonJS","text":"<p>Para poder exportar una funci\u00f3n dentro de un fichero Javascript es necesario usar module.export:</p> <pre><code>const myApp = (() =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n})()\nmodule.exports = myApp\n</code></pre> <p>N\u00f3tese, que la autoinvocaci\u00f3n desaparece ya que se puede realizar posteriormente. Incluso se puede exportar de forma directa:</p> <pre><code>module.exports = () =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n}\n</code></pre> <p>Para importar el m\u00f3dulo se usa la funci\u00f3n require cuyo par\u00e1metro es la ruta relativa en la que se encuentra el fichero:</p> <pre><code>const myApp = require('myApp')\nconst variable = myApp()\nconsole.log(variable.numero) // 0\n</code></pre> <p>Se puede realizar la exportanci\u00f3n de m\u00e1s m\u00f3dulos haciendo indicando el nombre:</p> myApp.jsmain.jsmain.js II <pre><code>module.exports.moduleA = () =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b // Funci\u00f3n privada que no se retorna\nfunction apply(increment){\nreturn sun(number, increment)\n}\nreturn { number, letter, apply }\n}\nmodule.exports.moduleB = () =&gt; {\nreturn {\nsum: (a, b) =&gt; a + b,\nmin: (a, b) =&gt; Maths.min(a, b)\n}\n}\n</code></pre> <pre><code>const moduleA = require('myApp.js').moduleA    const moduleB = require('myApp.js').moduleB\nmoduleA()\nmoduleB()\n</code></pre> <pre><code>const { moduleA } = require('myApp.js')    const { moduleB } = require('myApp.js')\nmoduleA()\nmoduleB()\n</code></pre> <p>Hacer esto es lo mismo que unir ambos m\u00f3dulos en uno solo.</p> <pre><code>module.exports = () =&gt; {\nvar number = 0, letter = 'A'\nconst sum = (a, b) =&gt; a + b const min = Maths.min(a, b)\nfunction apply(increment){\nreturn sum(number, increment)\n}\nreturn { moduleA : { number, letter, apply },\nmoduleB : { sum, min }\n}\n}\n</code></pre> <p>En Node JS, cuando todas las funciones son p\u00fablicas y dem\u00e1s se puede crear las funciones de forma independiente y luego exportar un \u00fanico objeto con todas las funciones necesarias. La ventaja de usar este forma es que no ser\u00e1 necesario invocar ninguna funci\u00f3n en el lugar que se use los m\u00e9todos o variables del m\u00f3dulo:</p> myApp.jsindex.js <pre><code>const sum = (a, b) =&gt; a + b\nconst div = (a, b) =&gt; a / b\nconst PI = 3.14\nmodule.exports = { sum, div, pi: PI}\n</code></pre> <pre><code>const { sum, pi } = require(\"myApp.js\")\nconsole.log(sum(1, 2)) // 3\nconsole.log(pi) // 3.14 \n</code></pre> <p>Info</p> <p>Con el uso de <code>require</code> no es obligatorio indicar la extensi\u00f3n del archivo a importar</p> Ejercicio 2 <p>Realiza el mismo ejercicio anterior en fichero myApp, exportalos como creas conveniente haciendo uso del CommonJS y util\u00edzalo dentro del fichero index</p>"},{"location":"tema_1/page-2/#ecmascript-6-es6","title":"ECMAScript 6 (ES6)","text":"<p>En Node JS, en principio, para poder usar la importaci\u00f3n y la exportaci\u00f3n del ECMas Script 6 (ES6) ser\u00e1 necesario usar la extensi\u00f3n del fichero <code>.mjs</code>en lugar de <code>.js</code></p> <p>Para poder exportar una funci\u00f3n, o directamente un objeto como en el apartado anterior, se realizar\u00e1 con la palabra reservada export:</p> <pre><code>const sum = (a, b) =&gt; a + b\nexport { sum }\n</code></pre> <p>Para poder importarla ser\u00eda necesario usar la palabra reservada import ... from ...:</p> <pre><code>import module from 'myApp.msj'\nconsole.log(module.sum(1, 2)) // 3\n</code></pre> <p>En vez de usar el nombre del m\u00f3dulo, tambi\u00e9n se puede destructurar:</p> <pre><code>import { sum } from 'myApp.msj'\nconsole.log(sum(1, 2)) // 3\n</code></pre> <p>Si se desea importar todos los m\u00e9todos y variables del m\u00f3dulo haciendo uso de la destructuraci\u00f3n se puede indicar <code>*</code>:</p> <pre><code>import * from 'myApp.msj'\nconsole.log(sum(1, 2)) // 3\n</code></pre> <p>Warning</p> <p>Ten en cuenta que en la importaci\u00f3n del ES6 SI es obligatorio indicar la extensi\u00f3n del archivo. Esto supone un problema, porque tecnolog\u00edas que usan Node JS como Webpack, React, etc., no hay que indicarlo ya que impl\u00edcitamente se encargan de indicarlo.</p> <p>Tambi\u00e9n se puede mezclar en un mismo proyectos ficheros <code>.js</code> con la exportaci\u00f3n CommonJS con ficheros <code>.mjs</code> con la exportaci\u00f3n ES6, aunque no es recomendable.</p> Ejercicio 3 <p>Realiza el mismo ejercicio anterior en fichero myApp, exportalos como creas conveniente haciendo uso del ES6 y util\u00edzalo dentro del fichero index</p>"},{"location":"tema_1/page-3/","title":"3 M\u00f3dulos Nativos","text":""},{"location":"tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Al instalar Node JS en nuestro ordenador, se instala con \u00e9l una cantidad de m\u00f3dulos predeterminados que podemos usar en nuestros proyectos. Como por ejemplo, un m\u00f3dulo para manejar ficheros, otro m\u00f3dulo para conocer las caracter\u00edsticas del sistema, etc.</p> <p>Cuando se va importar un m\u00f3dulo nativo Node JS, desde la versi\u00f3n 16, se recomienda usar el prefijo <code>node</code> antes del nombre del m\u00f3dulo:</p> CommonJSES6 <pre><code>const variable = require('node:fs')\n</code></pre> <pre><code>import * from 'node:fs'\n</code></pre>"},{"location":"tema_1/page-3/#os-info","title":"OS info","text":"<p>Este m\u00f3dulo permite conocer informaci\u00f3n del sistema operativo en el que se est\u00e1 ejecutando el fichero Javascript. Algunos de sus m\u00e9todos importantes son:</p> <ul> <li><code>arch()</code>: Retorna la arquitectura del sistema en el que se est\u00e1 compilando el fichero Node JS. Puede devolver por ejemplo,arm,arm64,x64, etc.</li> <li><code>cpus()</code>: Retorna un array con la informaci\u00f3n de cada CPU. El array puede estar vac\u00edo si no se puede obtener informaci\u00f3n.</li> <li><code>homedir()</code>: Retorna la ruta de la carpeta principal del usuario actual.</li> <li><code>hostname()</code>: Retorna el nombre del sistema.</li> <li><code>platform()</code>: Retorna la plataforma del sistema operativo en el que se ejecuta, como linux, win32, etc.</li> <li><code>type()</code>: Retorna el tipo de sistema operativo: Linux, Windows_NT.</li> <li><code>uptime()</code>: Retorna en segundos el tiempo en el que el sistema ha estado activo.</li> <li><code>version()</code>: Retorna la versi\u00f3n del kernel.</li> </ul> CommonJSES6 <pre><code>const os = require('node:os') // Importaci\u00f3n con el prefijo node RECOMENDADO\nconsole.log('Informaci\u00f3n del sistema operativo:')\nconsole.log('-------------------')\nconsole.log('Nombre del sistema operativo', os.platform())\nconsole.log('Versi\u00f3n del sistema operativo', os.release())\nconsole.log('Arquitectura', os.arch())\nconsole.log('CPUs', os.cpus())\nconsole.log('Memoria libre', os.freemem() / 1024 / 1024)\nconsole.log('Memoria total', os.totalmem() / 1024 / 1024)\nconsole.log('uptime', os.uptime() / 60 / 60)\n</code></pre> <pre><code>import { platform, release, arch, cpus, freemem, totalmem, uptime } from 'node:os' // Importaci\u00f3n con el prefijo node RECOMENDADO\nconsole.log('Informaci\u00f3n del sistema operativo:')\nconsole.log('-------------------')\nconsole.log('Nombre del sistema operativo', platform())\nconsole.log('Versi\u00f3n del sistema operativo', release())\nconsole.log('Arquitectura', arch())\nconsole.log('CPUs', cpus())\nconsole.log('Memoria libre', freemem() / 1024 / 1024)\nconsole.log('Memoria total', totalmem() / 1024 / 1024)\nconsole.log('uptime', uptime() / 60 / 60)\n</code></pre>"},{"location":"tema_1/page-3/#process","title":"Process","text":"<p>Process es un m\u00f3dulo nativo de Node JS que permite tratar con el proceso actual, es decir, el que ejecuta el archivo Javascript, es decir, el <code>node index.js</code>.</p> <p>Al realizar la ejecuci\u00f3n del archivo js podemos pasarle par\u00e1metros seguidos del nombre del archivo. Con el atributo <code>args</code> se obtiene un array con todos los par\u00e1metros, donde el primer elemento <code>args(0)</code> corresponde a archivo de ejecuci\u00f3n de node, y el segundo elemento <code>args(1)</code> se corresponde a el nombre del archivo que se est\u00e1 ejecutando. A partir de este n\u00famero se puede obtener todos los argumentos que se pueden obtener.</p> ConsolaJavascriptSalida <pre><code>node argv.js Hola mundo\n</code></pre> <pre><code>const { argv } = require('node:process')\nargv.forEach(arg =&gt; console.log(arg))\n</code></pre> <pre><code>C:\\Users\\user\\AppData\\Local\\fnm_multishells\\7824_1691140862198\\node.exe\nD:\\user\\NodeJSProjects\\tests\\05-process\\argv.js\nHola\nmundo\n</code></pre> <p>Con el m\u00e9todo <code>exit(n)</code> se puede terminar el proceso actual con el n\u00famero n que indica como ha finalizado el proceso. Normalmente se usa 0 cuando el proceso ha terminado con \u00e9xito (sin errores), mientras que se elige otro n\u00famero para indicar cualquier error.</p> <p>Al ser Javascript un lenguaje orientado a evento, podemos escuchar el evento <code>exit</code> para poder hacer algo cuando se finalice el proceso actual, como por ejemplo hacer una limpieza de los recursos:</p> <pre><code>const process = require('node:process')\n// Obtenemos un n\u00famero de la consola de comando,\n// si no se indica ninguno obtenemos el n\u00famero 0\nconst num = process.argv[2] ?? 0\nif (num == 0) {\nprocess.on('exit', () =&gt; {\nconsole.error('Ha habido un error ! Tenemos que irnos')\n})\nprocess.exit(1) // Si no se indica n\u00famero se sale del proceso con error\n}\nconsole.log(num)\n</code></pre> <p>Con <code>cwd()</code> podemos obtener la ruta actual de donde estamos ejecutando el archivo Javascript</p> <pre><code>const { cwd } = require('node:process')\nconsole.log(cwd())\n</code></pre> <p>Las variables de entorno son constantes que se utilizan durante la ejecuci\u00f3n de un programa. Para definir una variable de entorno con Node JS hay que preceder <code>NOMBRE=valor</code> antes del <code>node archivo.js</code>, donde NOMBRE es el valor del nombre de la variable, que suele ir en may\u00fasculas al ser una constante, y valor es el valor de dicha variable.</p> <p>Para poder leer una variable de entorno, podemos usar la variable <code>env</code> del m\u00f3dulo process, seguido del nombre de la variable: <code>process.env.NOMBRE</code></p> ConsolaJavascript <pre><code>SALUDO=\"HOLA MUNDO\" index env.js\n</code></pre> <pre><code>const process = require('node:process')\nconsole.log(process.env.SALUDO) // HOLA MUNDO\n</code></pre> Ejercicio <p>Realiza una aplicaci\u00f3n \"info.js\" que pueda recibir hasta 2 par\u00e1metros en su llamada. Si no recibe ning\u00fan par\u00e1metros mostrar\u00e1 una informaci\u00f3n completa del sistema operativo actual.</p> <p>El primer par\u00e1metro a recibir es la palabra -m que mostrar\u00e1 la memoria en GB. El segundo par\u00e1metro a recibir es la palabra -o que mostrar\u00e1 el nombre del sistema operativo y su versi\u00f3n.</p> <p>Se puede utilizar los dos par\u00e1metros a la vez (-m -o), o simplemente uno. Sin embargo, hay que tener en cuenta si recibe como par\u00e1metro algo diferente a lo indicado anteriormente saldr\u00e1 de la aplicaci\u00f3n mostrando un mensaje de error.</p>"},{"location":"tema_1/page-4/","title":"4 Ficheros","text":""},{"location":"tema_1/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>En Javascript no se puede trabajar con ficheros de forma nativa, pero gracias a Node JS y su m\u00f3dulo fs es posible poder trabajar con ficheros.</p> <p>En Node JS se trabaja con ficheros de tres formas diferentes:</p> <ul> <li>Haciendo uso de la programaci\u00f3n s\u00edncrona.</li> <li>Haciendo uso de la programaci\u00f3n as\u00edncrona con callbacks.</li> <li>Haciendo uso de la programaci\u00f3n as\u00edncrona con await.</li> <li>Haciendo uso de la programaci\u00f3n as\u00edncrona con promesas.</li> </ul> <p>Algunos m\u00e9todos del m\u00f3dulo tiene su versi\u00f3n s\u00edncrona y su versi\u00f3n as\u00edncrona: <code>readFile()</code>, <code>readFileSync()</code>.</p>"},{"location":"tema_1/page-4/#informacion-de-un-fichero","title":"Informaci\u00f3n de un fichero","text":"<p>El m\u00e9todo <code>statSync(path)</code> devuelve informaci\u00f3n relativa de un fichero en un objeto de tipo <code>Stat</code> de forma s\u00edncrona, mientras que <code>stat(path)</code> devuelve la misma informaci\u00f3n pero de forma as\u00edncrona. El atributo path es la ruta relativa o absoluta del fichero a comprobar.</p> <p>Algunos m\u00e9todos interesantes de la clase <code>Stat</code>:</p> <ul> <li><code>isDirectory()</code>: Comprueba si la ruta pertenece a un directorio.</li> <li><code>isFile()</code>: Comprueba si la ruta pertenece a un fichero.</li> <li><code>isSymbolicLink()</code>: Comprueba si es un enlace simb\u00f3lico.</li> <li><code>size</code>: Devuelve el tama\u00f1o del fichero en bytes.</li> </ul> <p>Info</p> <p>Para conocer m\u00e1s m\u00e9todos y atributos de la clase <code>Stat</code>: https://nodejs.org/api/fs.html#class-fsstats</p> S\u00edncronoAs\u00edncrono <pre><code>const fs = require('node:fs') // a partir de Node 16, se recomienda poner node:\nconst stats = fs.statSync('../README.md')\nconsole.log(\nstats.isFile(), // si es un fichero\nstats.isDirectory(), // si es un directorio\nstats.isSymbolicLink(), // si es un enlace simb\u00f3lico\nstats.size // tama\u00f1o en bytes\n)\n</code></pre> <pre><code>const fs = require('node:fs') // a partir de Node 16, se recomienda poner node:\nfs.stat('../README.md', (error, stat) =&gt; console.log(\nstat.isFile(), // si es un fichero\nstat.isDirectory(), // si es un directorio\nstat.isSymbolicLink(), // si es un enlace simb\u00f3lico\nstat.size // tama\u00f1o en bytes\n))\n</code></pre>"},{"location":"tema_1/page-4/#leer-un-fichero","title":"Leer un fichero","text":"<p>Para leer un fichero de forma s\u00edncrona existe el m\u00e9todo <code>readFileSync(path)</code>, donde path es la ruta relativa o absoluta del fichero a leer.</p> <p>Danger</p> <p>Si en lugar de indicar un fichero existente, si indica un fichero inexistente o un directorio, lanzar\u00e1 una excepci\u00f3n.</p> <pre><code>const fs = require('node:fs')\nconsole.log('Leyendo el archivo en binario...')\nlet text = fs.readFileSync('./archivo.txt')\nconsole.log(text)\n</code></pre> <p>El m\u00e9todo devuelve la informaci\u00f3n del fichero en binario, para poder evitar esto se puede indicar un segundo par\u00e1metro con el tipo de codificaci\u00f3n, como por ejemplo <code>utf-8</code></p> <pre><code>const fs = require('node:fs')\nconsole.log('Leyendo el archivo...')\nlet text = fs.readFileSync('./archivo2.txt', 'utf-8')\nconsole.log(text)\n</code></pre> <p>Para poder leer una archivo de forma as\u00edncrona se una el m\u00e9todo <code>readFile(path)</code>:</p> <pre><code>const fs = require('node:fs')\nconsole.log('Leyendo el primer archivo...')\nfs.readFile('./archivo.txt', 'utf-8', (err, text) =&gt; { // &lt;---- ejecutas este callback\nconsole.log('primer texto:', text)\n})\nconsole.log('--&gt; Hacer cosas mientras lee el archivo...')\nconsole.log('Leyendo el segundo archivo...')\nfs.readFile('./archivo2.txt', 'utf-8', (err, text) =&gt; {\nconsole.log('segundo texto:', text)\n})\n</code></pre> <p>En la mayor\u00eda de m\u00f3dulos que trabajan de forma as\u00edncrona existe una version con promesas. Para poder usarla es necesario importar el mismo m\u00f3dulo seguido de <code>/promises</code>.</p> CommonJsES6 <pre><code>const { readFile } = require('node:fs/promises')\nasync function init() {\nconsole.log('Leyendo el primer archivo...')\nconst text = await readFile('./archivo.txt', 'utf-8')\nconsole.log('primer texto:', text)\nconsole.log('--&gt; Hacer cosas mientras lee el archivo...')\nconsole.log('Leyendo el segundo archivo...')\nconst secondText = await readFile('./archivo2.txt', 'utf-8')\nconsole.log('segundo texto:', secondText)\n}\ninit()\n</code></pre> <pre><code>// Esto s\u00f3lo en los m\u00f3dulos nativos\n// que no tienen promesas nativas\n// const { promisify } = require('node:util')\n// const readFilePromise = promisify(fs.readFile)\nimport { readFile } from 'node:fs/promises'\nconsole.log('Leyendo el primer archivo...')\nconst text = await readFile('./archivo.txt', 'utf-8')\nconsole.log('primer texto:', text)\nconsole.log('--&gt; Hacer cosas mientras lee el archivo...')\nconsole.log('Leyendo el segundo archivo...')\nconst secondText = await readFile('./archivo2.txt', 'utf-8')\nconsole.log('segundo texto:', secondText)\n</code></pre> <p>Como se puede observar con el CommonJS al usar await se ha tenido que envolver el c\u00f3digo en una funci\u00f3n. Esto se debe porque no existe el soporte con el await en funciones top-level, por lo que es necesario el uso de una funci\u00f3n async que contenga el await. Esta es otra de las mejoras que se tiene con ES6, en el cual no es necesario realizar esa operaci\u00f3n, ya que si existe soporte del await en funciones top-level.</p> <p>El c\u00f3digo de Common JS** se puede mejor haciendo uso del **IIFE (*Immediately Invoked function Expression)**.</p> <pre><code>const { readFile } = require('node:fs/promises')\n// IIFE - Immediately Invoked Function Expression\n; (\nasync () =&gt; {\nconsole.log('Leyendo el primer archivo...')\nconst text = await readFile('./archivo.txt', 'utf-8')\nconsole.log('primer texto:', text)\nconsole.log('--&gt; Hacer cosas mientras lee el archivo...')\nconsole.log('Leyendo el segundo archivo...')\nconst secondText = await readFile('./archivo2.txt', 'utf-8')\nconsole.log('segundo texto:', secondText)\n}\n)()\n</code></pre> <p>Warning</p> <p>Como se puede observar en el ejemplo, antes del uso de la funci\u00f3n IIFE, se ante pone un <code>;</code>. Esto es necesario y obligatorio en este caso, ya que si no s\u00e9 usa el compilar entiende que forma parte de la funci\u00f3n anterior, en este caso <code>require</code>, y por lo tanto dar\u00e1 error.</p> <p>Se puede colocar antes del uso de la funci\u00f3n tal y como aparece en el ejemplo:</p> <pre><code>const { readFile } = require('node:fs/promises')\n;() {\n//...\n}\n</code></pre> <p>O, tambi\u00e9n puede ir con la l\u00ednea anterior:</p> <pre><code>const { readFile } = require('node:fs/promises');\n() {\n//...\n}\n</code></pre> <p>Los m\u00f3dulos que no traen de forma nativa las promesas se puede hacer uso del m\u00e9todo <code>promisify</code> del m\u00f3dulo <code>util</code> que recibe el m\u00e9todo as\u00edncrono, el cual se desea usar con promesas.</p> <pre><code>const { promisify } = require('node:util')\nconst readFilePromise = promisify(fs.readFile)\n</code></pre> <p>Por otro lado, si no se quiere usar await, se puede seguir haciendo uso de promesas utilizando el m\u00e9todo <code>then</code>:</p> <pre><code>const fs = require('node:fs/promises')\nconsole.log('Leyendo el primer archivo...')\nfs.readFile('./archivo.txt', 'utf-8')\n.then(text =&gt; {\nconsole.log('primer texto:', text)\n})\nconsole.log('--&gt; Hacer cosas mientras lee el archivo...')\nconsole.log('Leyendo el segundo archivo...')\nfs.readFile('./archivo2.txt', 'utf-8')\n.then(text =&gt; {\nconsole.log('segundo texto:', text)\n})\n</code></pre> <p>Por \u00faltimo, podemos unir la lectura de m\u00e1s de dos ficheros haciendo uso del m\u00e9todo <code>Promises.all()</code>, de esta forma se ejecutaran de forma paralela:</p>"},{"location":"tema_1/page-4/#escribir-ficheros","title":"Escribir ficheros","text":"<p>Para escribir ficheros de forma s\u00edncrona se utiliza el m\u00e9todo <code>writeFileSync(file, data, options)</code> donde:</p> <ul> <li>file es la ruta del fichero a escribir.</li> <li>data es la informaci\u00f3n que se quiere a\u00f1adir (puede ser una cadena o un buffer).</li> <li>options puede ser una cadena o un objeto con las opciones a indicar, como el encoding, que por defecto es utf-8</li> </ul> <pre><code>const fs = require('node:fs')\nconst msg = \"Esto es un fichero que se ha escrito con Node JS\"\nconsole.log(\"Escribiendo en el fichero\")\nfs.writeFileSync(\"archivo.txt\", msg)\n</code></pre> <p>Si escribimos en el fichero m\u00e1s de una vez, lo que va a ocurrir es que el contenido del fichero va a ser sobrescrito y no a\u00f1adido al final. Para poder solucionar este problema, hay que indicarle como opci\u00f3n <code>a+</code> en el atributo <code>flag</code>:</p> <pre><code>const fs = require('node:fs')\nconst otherText = \"\\nSe esta a\u00f1adiendo otro texto\"\nconsole.log(\"A\u00f1adiendo m\u00e1s texto\")\nfs.writeFileSync(\"archivo.txt\", otherText, { flag: 'a+' })\n</code></pre> <p>La versi\u00f3n as\u00edncrona para escribir archivos es <code>writeFile()</code>, adem\u00e1s tiene su versi\u00f3n en <code>fs/promises</code></p> CallbacksAwait con Common JsAwait con ES 6Promises <pre><code>const fs = require('node:fs')\nconsole.log(\"Escribiendo en el fichero\")\nconst msg = \"Esta l\u00ednea ha sido escrito con Node JS de forma as\u00edncrona\\n\"\nfs.writeFile(\"archivo.txt\", msg, { flag: 'a+' }, console.log)\nconsole.log(\"Terminado de escribir\")\n</code></pre> <pre><code>const { writeFile } = require('node:fs/promises')\n; (async () =&gt; {\nconsole.log(\"Escribiendo en el fichero\")\nconst msg = \"Esta l\u00ednea ha sido escrito con Node JS de forma as\u00edncrona con await y CommonJS\\n\"\nawait writeFile(\"archivo.txt\", msg, { flag: 'a+' })\nconsole.log(\"Terminado de escribir\")\n})()\n</code></pre> <pre><code>import { writeFile } from 'node:fs/promises'\nconsole.log(\"Escribiendo en el fichero\")\nconst msg = \"Esta l\u00ednea ha sido escrito con Node JS de forma as\u00edncrona con await y ES6\\n\"\nawait writeFile(\"archivo.txt\", msg, { flag: 'a+' })\nconsole.log(\"Terminado de escribir\")\n</code></pre> <pre><code>const { writeFile } = require('node:fs/promises')\nconsole.log(\"Escribiendo en el fichero\")\nconst msg = \"Esta l\u00ednea ha sido escrito con Node JS de forma as\u00edncrona con promesas\\n\"\nwriteFile(\"archivo.txt\", msg, { flag: 'a+' }).then(() =&gt; {\nconsole.log(\"Terminado de escribir\")\n})\n</code></pre> Ejercicio 1 <p>Realiza una aplicaci\u00f3n llamada cpFile.js la cual pueda recibir como par\u00e1metros dos rutas de dos ficheros. El objetivo de la aplicaci\u00f3n es copiar el contenido del primer fichero en el segundo fichero. Si el segundo fichero ya existe, sobrescribir\u00e1 el fichero.</p> <p>Si recibe menos de 2 ficheros, se saldr\u00e1 de la aplicaci\u00f3n mostrando un mensaje de error.</p>"},{"location":"tema_1/page-4/#listar-ficheros","title":"Listar ficheros","text":"<p>Para poder mostrar todos los ficheros de un directorio se puede usar el m\u00e9todo <code>readdir()</code> del m\u00f3dulos fs:</p> <pre><code>const { readdir } = require('node:fs')\nconst process = require('node:process')\nreaddir('../', (err, files) =&gt; {\nif (err) {\nconsole.error('Ha habido un error:', err)\nprocess.exit(1)\n}\nfiles.forEach(console.log)\n})\n</code></pre> <p>Info</p> <p>Para conocer m\u00e1s m\u00e9todo que trabajando con ficheros visita https://nodejs.org/api/fs.html</p>"},{"location":"tema_1/page-4/#modulo-path","title":"M\u00f3dulo Path","text":"<p>El m\u00f3dulo Path es un m\u00f3dulo que se trabaja con rutas de formas sencilla. Es m\u00f3dulo incluido entre los m\u00f3dulos nativos de Node JS por lo que no necesita instalaci\u00f3n.</p> <p>Depende del sistema operativo en el que ejecutemos nuestro programa javascript las rutas son separadas de forma diferente. Por ejemplo en Windows se usa el separador <code>\\</code> mientras que en Linux <code>/</code>. Este m\u00f3dulo contiene un atributo <code>sep</code> que obtiene el separador de la ruta.</p> <p>No se recomienda crear una ruta directamente, ya que esto puede suponer un error dependiendo del entorno donde se ejecute, por lo que se recomienda usar esta librer\u00eda con sus m\u00e9todos y atributos. Por ejemplo:</p> <pre><code>const path = require('node:path') // Se importa path\nconst sep = path.sep // Se obtiene el separador del OS\nconsole.log(`files${sep}archivo.txt`)\n</code></pre> <p>En ese ejemplo puede mostrar files/archivo.txt si estamos trabajando en Linux o files\\archivos.txt si estamos trabajando en Windows.</p> <p>El ejemplo anterior se puede optimizar haciendo uso del m\u00e9todo <code>join()</code> que recibe todas las partes de la ruta y devuelve una cadena con la ruta unida junto con el separador:</p> <pre><code>const path = require('node:path') // Se importa path\nconsole.log(path.join('files', 'archivo.txt'))\n</code></pre> <p>Con el m\u00e9todo <code>basename()</code> podemos obtener el nombre base del archivo. Por ejemplo, si nosotros tenemos la ruta de files/archivo.txt, devolver\u00e1 archivos.txt. Tambi\u00e9n recibe un segundo par\u00e1metro para obtener el nombre sin la extensi\u00f3n, debi\u00e9ndose pasar la extensi\u00f3n a eliminar:</p> <pre><code>const path = require('node:path') // Se importa path\nconst myPath = path.join('files', 'archivo.txt')\nconsole.log(path.basename(myPath)) // archivo.txt\nconsole.log(path.basename(myPath), '.txt') // archivo\n</code></pre> <p>Si lo que se desea obtener es la extensi\u00f3n del archivo con el m\u00e9todos <code>extname()</code> se puede visualizar:</p> <pre><code>const path = require('node:path') // Se importa path\nconst myPath = path.join('files', 'archivo.txt')\nconsole.log(path.extname(myPath)) // .txt\n</code></pre> <p>Este m\u00e9todo devolver\u00e1 una cadena vac\u00eda si la extensi\u00f3n del archivo no es v\u00e1lida, por ejemplo archivo., en este caso no devolver\u00e1 nada.</p> <p>Otros m\u00e9todos a tener en cuenta:</p> <ul> <li><code>isAbsolute()</code>: es un m\u00e9todo que comprueba si la ruta es absoluta.</li> <li><code>parse(path)</code>: retorna un objeto con informaci\u00f3n referente al path (string), como su ra\u00edz, el nombre del fichero, la extensi\u00f3n y el nombre base.</li> <li><code>relative(from, to)</code>: obtiene la ruta relative que hay que invocar para llegar desde from hasta to.</li> </ul> Ejercicio 2 <p>Realiza una aplicaci\u00f3n, llamado ls.js, que liste los ficheros y directorios de un directorio indicado como par\u00e1metro.</p>"},{"location":"tema_1/page-5/","title":"5 Proyecto Node Js","text":""},{"location":"tema_1/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Hasta ahora hemos estado creando ficheros sueltos de Javascript y hemos visto como usar unos en otros, pero la realidad es que ninguno de los ficheros que hemos creado han tenido una consistencia y una relaci\u00f3n entre s\u00ed, es decir, no pertenec\u00edan a un mismo proyecto.</p> <p>Un proyecto es un entorno de trabajo que contiene los diferentes ficheros con los que trabajar, pero adem\u00e1s, en caso de Node JS, contiene archivo de configuraciones previas que nos facilitar\u00e1n la vida a la hora de trabajar con Node JS.</p> <p>Para poder crear proyectos Node JS ser\u00e1 necesario el uso de npm.</p>"},{"location":"tema_1/page-5/#npm-node-project-manager","title":"NPM (Node Project Manager)","text":"<p>NPM es un manejador de paquetes para Node que nos permitir\u00e1 instalar paquetes externos a nuestros proyectos, entre otras cosas.</p> <p>NPM tiene dos definiciones principales:</p> <ul> <li>Un repositorio online para publicar paquetes de software libre para ser usado en proyectos Node JS.</li> <li>Una herramienta para terminal para interactuar con dicho repositorio que te ayuda a la instalaci\u00f3n de utilidades, manejo de dependencias y publicaci\u00f3n de paquetes.</li> </ul> <p>Es decir, en tu proyecto basado en Node utilizar\u00e1s la utilidad de linea de comandos (cli) para consumir paquetes desde el repositorio online, un listado gigantesco de soluciones de software para distintos problemas disponibles p\u00fablicamente en npmjs.com y para manejar dependencias, y para ello necesitas un archivo de configuraci\u00f3n que le diga a npm que este es un proyecto node.</p>"},{"location":"tema_1/page-5/#packagejson","title":"package.json","text":"<p>Este archivo indica a npm que el directorio en el que se encuentra es un proyecto o paquete npm. Adem\u00e1s, contiene la informaci\u00f3n del paquete incluyendo la descripci\u00f3n del mismo, versi\u00f3n, autor, dependencias, etc.</p> <p>Este archivo es generado autom\u00e1ticamente mediante la ejecuci\u00f3n del comando <code>npm init</code>, que sirve para inicializar un proyecto. Al ejecutar dicho comando se te har\u00e1 algunas preguntas para crear el paquete y completar la informaci\u00f3n del package.json.</p> <p>La informaci\u00f3n a solicitar es:</p> <ul> <li>name: nombre del paquete que se va a desarrollar.</li> <li>version: corresponde a la versi\u00f3n del proyecto. Se recomienda mantener actualizado este campo cuando modificas algo en tu proyecto o librer\u00eda utilizando semver.</li> <li>description: una breve descripci\u00f3n del proyecto.</li> <li>entry point: es el punto de entrada de tu proyecto, es decir, que archivo se ejecutar\u00e1 cuando se importe tu proyecto dentro de otro.</li> <li>test command: se define el comando que quieres ejecutar para realizar las pruebas de tu proyecto. Este comando ser\u00e1 ejecutado cuando escribas <code>npm run test</code>.</li> <li>git repository: define la url del repositorio git donde se alojar\u00e1 el proyecto. De esta forma se informa a los usuarios donde encontrar el c\u00f3digo fuente del proyecto.</li> <li>author: creador del proyecto. Se puede indicar el nombre, el alias o el email.</li> <li>license: corresponde a la licencia que tiene el proyecto a crear. As\u00ed, se permite a las personas saber que y que no est\u00e1 permitido al usar tu c\u00f3digo. Hecha un vistazo a las licencias soportadas. Normalmente, se suelee indicar la licencia MIT.</li> <li>private: valor booleano, que permitir\u00e1 evitar que el paquete sea publicado en el repositorio. Ser\u00e1 true, si deseas que el proyecto sea privado.</li> <li>keywords: son las palabras claves para que aparezca el repositorio cuando sea buscado por el usuario.</li> </ul> <p>Al completar dicha informaci\u00f3n crear\u00e1 un fichero package.json con toda la informaci\u00f3n almacenada, por ejemplo:</p> <pre><code>{\n\"name\": \"my-first-node-package\",\n\"version\": \"1.0.0\",\n\"description\": \"My first project use node js\",\n\"main\": \"index.js\",\n\"scripts\": {\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"keywords\": [\n\"async\",\n\"example\"\n],\n\"author\": \"irudev\",\n\"license\": \"ISC\"\n}\n</code></pre> <p>Si se quiere obtener todos los valores por defecto se puede ejecutar el comando <code>npm init --yes</code> o <code>npm init -y</code></p>"},{"location":"tema_1/page-5/#npm-scripts","title":"npm scripts","text":"<p>Como puedes observar en el package.json del ejemplo anterior, contiene todos los campos nombrados, pero adem\u00e1s tiene un campo extra llamado scripts. Esta secci\u00f3n define un listado de propiedades que permiten ejecutar comandos dentro del contexto de tu proyecto incluyendo: comandos de otros paquetes listados como dependencias, scripts personalizados, scripts bash, etc.</p> <p>De momento, solo hay un script el especificado por nosotros cuando hemos ejecutado <code>npm init</code>y nos han preguntado por los tests. En caso de no indicar ninguno, se ejecutar\u00e1 <code>echo \\\"Error: no test specified\\\" &amp;&amp; exit 1</code> por defecto,</p> <p>Podemos personalizar los script como creamos. Por ejemplo, podemos crear un script que al ejecutarlo, ejecute el index.js:</p> <pre><code>\"scripts\": {\n\"start\": \"node index.js\",\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n</code></pre>"},{"location":"tema_1/page-5/#dependencias-de-produccion-y-dependencias-de-desarrollo","title":"Dependencias de producci\u00f3n y dependencias de desarrollo","text":"<p>Para poder instalar dependencias se usa el comando <code>npm install LIBRARY</code> donde ^LIBRARY* es la dependencia a instalar. Tambien se puede usar la versi\u00f3n reduciar <code>npm i LIBRARY</code>:</p> <pre><code>npm i picocolors\n</code></pre> <p>El ejemplo anterior instalar\u00e1 en nuestro proyecto la librer\u00edas picocolors, que nos permitir\u00e1 usar colores en nuestra consola de comandos al usar <code>console</code></p> <p>Al instalar un dependencia hay que tener en cuenta dos cosas:</p> <ul> <li>Se crear\u00e1 una carpeta node_modules, si es el primer m\u00f3dulo instalado, el cu\u00e1l contiene todas las dependencias instaladas.</li> <li> <p>Aparecer\u00e1 una nueva secci\u00f3n dependencies, si tambi\u00e9n es la primera instalada, que contendr\u00e1 <code>NOMBRE:VERSION</code>. Donde NOMBRE es el nombre del paquete instalado y VERSION es la version del paquete con el formato semver</p> <pre><code>\"dependencies\": {\n\"picocolors\": \"^1.0.0\"\n}\n</code></pre> <p>Tambi\u00e9n es posible encontrar algunos s\u00edmbolos frente a la numeraci\u00f3n de la versi\u00f3n, estos son:</p> </li> <li> <p><code>^</code>: last minor release. Por ejemplo <code>^1.0.0</code>, indica que 1.0.0 es la versi\u00f3n m\u00e1s baja que se puede instalar pero permite que se instale cualquier versi\u00f3n superar a esa pero se encuentre dentro de la versi\u00f3n 1.</p> </li> <li><code>~</code>: last patch release. Esta es la forma contraria de <code>^</code>. Esta especificaci\u00f3n <code>~1.0.0</code> puede instalar la versi\u00f3n <code>1.0.0</code> si es la \u00faltima versi\u00f3n del patch.</li> </ul> <p>Al usar el comando <code>npm i PACKAGE</code> se instalar\u00e1 las dependencias pero en modo producci\u00f3n, es decir, cuando se despliegue la aplicaci\u00f3n para ser subida a host, o a un servidor, ser\u00e1n instaladas.</p> <p>Existen otro forma de instalar dependencias, <code>npm install PACKAGE -D</code>, de esta forma se instalar\u00e1 en modo desarrollo, es decir, en el momento del despliegue no ser\u00e1n necesaria su instalaci\u00f3n pero durante el desarrollo de la aplicaci\u00f3n si que son necesarias.</p> <p>Al instalar una dependencia en modo desarrollo, se a\u00f1adir\u00e1 otra secci\u00f3n devDependencies al package.json:</p> Consolapackage.json <pre><code>npm i standard -D\n</code></pre> <pre><code>\"devDependencies\": {\n\"standard\": \"^17.1.0\"\n}\n</code></pre> <p>En el ejemplo anterior hemos instalado el package standard que corresponde a JavaScript Standard Style en modo dependencia. Este paquete permite seguir unas reglas de formato para los archivos Javascript. Para saber m\u00e1s visite: https://standardjs.com/readme-esla.html</p>"},{"location":"tema_1/page-5/#package-lockjson","title":"package-lock.json","text":"<p>Este archivo es auto generado por <code>npm install</code> y es una lista descriptiva y exacta de las versiones instaladas durante tu proceso. No esta destinado a ser le\u00eddo ni manipulado por los desarrolladores, si no, para ser un insumo del proceso de manejo de dependencias.</p>"},{"location":"tema_1/page-5/#otros-argumentos-para-npm-install","title":"Otros argumentos para npm install","text":"<p>Puedes usar algunos par\u00e1metros tales como</p> <ul> <li><code>-g</code>: para indicar que quieres que el paquete se instale globalmente, y se mantenga en tu ordenador y no \u00fanicamente en tu proyecto. Esta opci\u00f3n no es muy recomendada.</li> <li><code>--production</code>: indica que la ejecuci\u00f3n de <code>npm install</code> solo instalar\u00e1 las dependencias listadas en el apartado dependencies dejando de lado las dependencias de desarrollo.</li> </ul>"},{"location":"tema_1/page-5/#otros-scripts-de-npm","title":"Otros scripts de npm","text":""},{"location":"tema_1/page-5/#npm-audit","title":"npm audit","text":"<p>npm tiene una cantidad de paquetes disponibles lo que es una gran caracter\u00edstica indicando lo saludable del ecosistema que es capaz de generar nuevas librer\u00edas a gran velocidad, pero tambi\u00e9n puede ser un problema. npm puede albergar paquetes maliciosos o con problema de seguridad.</p> <p>La organizaci\u00f3n detr\u00e1s de npm mantiene una lista de agujeros de seguridad y puedes utilizar este comando para revisar tus dependencias.</p> <p><code>npm audit</code> te entregar\u00e1 informaci\u00f3n de las vulnerabilidades encontradas en tus dependencias junto con una breve descripci\u00f3n de como resolverlo indicando la versi\u00f3n que corrige el defecto.</p>"},{"location":"tema_1/page-5/#npm-publish","title":"npm publish","text":"<p>En el caso de que tu proyecto sea una librer\u00eda de software libre que quieres compartir con otros, este comando ser\u00e1 el que te permitir\u00e1 publicar tu paquete en el repositorio, solo necesitas ejecutar:</p> <ul> <li><code>npm login</code> para ingresar a tu cuenta de npm.</li> <li><code>npm publish</code> para subir tu paquete al repositorio.</li> </ul> <p>Ten en cuenta que necesitas tener bien configurados tu entry point y el script de build.</p> <p>Tambi\u00e9n puedes hacer uso de los scripts del ciclo de vida. Una serie de scripts que se ejecutan en diferentes momentos del proceso de publicaci\u00f3n:</p> <ul> <li>prepare (desde <code>npm@4.0.0</code>): Se ejecuta antes de que el paquete se empaquete (packed) y antes de que se publique. Tambi\u00e9n se ejecuta al correr <code>npm install</code> y despu\u00e9s del script <code>prepublishOnly</code></li> <li>prepublishOnly: Se ejecuta antes de que el paquete sea preparado y empaquetado y solo cuando se ejecuta <code>npm publish</code></li> <li>prepack: Se ejecuta antes de empaquetar, es decir antes de <code>npm pack</code> y <code>npm publish</code></li> <li>postpack: Se ejecuta despu\u00e9s de que el paquete fuese generado y ubicado en su destino final.</li> </ul>"},{"location":"tema_1/page-6/","title":"Proyecto","text":"<p>En este primer proyecto se va a desarrollar una varios comandos para tratar con ficheros, path, procesos, etc. Cada uno de ellos ser\u00e1n ejecutados independientemente.</p>"},{"location":"tema_1/page-6/#comando-ls","title":"Comando ls","text":"<p>Se crear\u00e1 un comando ls que listar\u00e1 la informaci\u00f3n de un directorio, que recibir\u00e1 por par\u00e1metro (en caso de no recibirlo usar\u00e1 el directorio actual). Adem\u00e1s tambi\u00e9n recibir\u00e1 los siguientes par\u00e1metros:</p> <ul> <li>-l: listar\u00e1 informaci\u00f3n adicional sobre los ficheros, como su tama\u00f1o, la fecha de la \u00faltima modificaci\u00f3n, etc.</li> <li>-a: listar\u00e1 todos los ficheros incluidos los ficheros ocultos.</li> <li>-r: listar\u00e1 todos los ficheros de forma recursiva, es decir, si existen directorios tambi\u00e9n se listar\u00e1 su contenido.</li> </ul> <p>Los par\u00e1metros se pueden usar de forma individual o de forma conjunta, sin embargo si se escribe un par\u00e1metro no descrito anteriormente finalizar\u00e1 la aplicaci\u00f3n mostrando un mensaje de error personalizado.</p> <p>Realiza el uso de colores para diferencias los ficheros y directorios, as\u00ed como los ocultos y no ocultos.</p>"},{"location":"tema_1/page-6/#comando-rn","title":"Comando rn","text":"<p>Este comando servir\u00e1 para renombrar un fichero por otro, teniendo en cuenta que el nuevo nombre de puede existir. Si existe el fichero tendr\u00e1 dos opciones, si no indica ning\u00fan par\u00e1metro se mostrar\u00e1 un mensaje de error indicando que ya existe el destino, mientras que si usa el par\u00e1metro -s, sobrescribir\u00e1 el fichero.</p>"},{"location":"tema_1/page-6/#comando-rm","title":"Comando rm","text":"<p>Este comando eliminar\u00e1 el/los ficheros indicados por par\u00e1metros. Debe recibir obligatoriamente un par\u00e1metro, si no mostrar\u00e1 un error. No se podr\u00e1 eliminar ning\u00fan directorio a no ser que use el par\u00e1metro -r.</p>"},{"location":"tema_1/page-6/#comando-port","title":"Comando port","text":"<p>Este comando devolver\u00e1 la variable <code>env</code> llamada PORT en caso de que sea definida, por el contrario, obtendr\u00e1 el primer puerto que este libre. Si est\u00e1 definida, adem\u00e1s, deber\u00e1 comprobar que no est\u00e9 en uso. Usa la librer\u00eda nativa de node <code>net</code>.</p>"},{"location":"tema_2/page-1/","title":"1 M\u00f3dulo HTTP","text":""},{"location":"tema_2/page-1/#protocolo-http","title":"Protocolo HTTP","text":"<p>HTTP (HyperText Transfer Protocol, es decir, Protocolo de transferencia de hipertexto) permite la transferencia de datos entre un servidor web y un receptor, que normalmente suele ser un navegador web.</p> Recuerda Estructura de una URL <p>La estructura de una URL es la siguiente: http://host[:puerto][/ruta][?par\u00e1metros], donde:</p> <ul> <li>http indica el protocolo que utilizamos para conectarnos a un servidor web.</li> <li>host es el nombre de dominio (por ejemplo google.com)</li> <li>puerto es un n\u00famero de puerto donde el servidor escuchara las peticiones. Por lo general, no se suele indicar ya que por defecto suele ser 80, en caso de ser otro s\u00ed habr\u00eda que indicarlo.</li> <li>/ruta indica donde se encuentra el archivo en el servidor.</li> <li>?par\u00e1metros son los datos que se pueden enviar desde el cliente para una mayor identificaci\u00f3n del recurso que solicitamos.</li> </ul> <p>La comunicaci\u00f3n http sucede cuando el usuario realiza un petici\u00f3n desde el navegador, por ejemplo buscar un producto en una tienda online. Esta petici\u00f3n se enviar\u00e1 al servidor web que realizar\u00e1 las operaciones pertinentes para obtener un resultado. Dicho resultado, se mostrar\u00e1 al usuario a trav\u00e9s del navegador con unos c\u00f3digos de estado e informaci\u00f3n relevante, por ejemplo el resultado de que todo ha ido correcto adem\u00e1s del producto buscado, o el resultado de que ha habido un error junto con un mensaje indicativo.</p> <p> Figura 1 - Comunicaci\u00f3n HTTP</p> <p>https</p> <p>El protocolo https es el protocolo http pero haciendo uso del certificado de seguridad.</p> <p>La petici\u00f3n del usuario lleva consigo cierta informaci\u00f3n, que ser\u00e1 tramitada en el servidor, como por ejemplo:</p> <ul> <li>url: ruta que ha usado el usuario para realizar la petici\u00f3n.</li> <li>cabeceras (headers): dan informaci\u00f3n de la petici\u00f3n, como por el ejemplo, el tipo dato que se va a enviar en la petici\u00f3n (texto, html, json, etc), el user-agent, es decir, desde que tipo de dispositivo se est\u00e1 haciendo la petici\u00f3n (navegador Chrome, M\u00f3vil, etc)</li> <li>cuerpo (body): es la informaci\u00f3n que se manda con la petici\u00f3n. A veces simplemente se realiza una petici\u00f3n sin necesidad de mandar ning\u00fan tipo de informaci\u00f3n.</li> </ul> <p>La respuesta que devuelve el servidor contiene los mismos par\u00e1metros que la petici\u00f3n pero en este caso, adem\u00e1s contiene un c\u00f3digo de estado (status code) que representa como ha ido la operaci\u00f3n, si ha sido \u00e9xito, o ha habido un error por parte del cliente, o por parte del servidor, etc.</p>"},{"location":"tema_2/page-1/#servidor-web-con-node-js","title":"Servidor web con Node JS","text":"<p>Una de los proyectos que podemos realizar con Node JS es crear un servidor web haciendo uso del protocolo http, para ello Node JS dispone de un m\u00f3dulo para ello.</p> <p>El m\u00f3dulo <code>http</code> permite realizar solicitudes http haciendo uso del patr\u00f3n emisor, es decir, recibir\u00e1 peticiones que resolver\u00e1 emitiendo una respuesta.</p> <p>Info</p> <p>https://nodejs.org/api/http.html</p> <p>Para crear el servidor hacemos uso del m\u00e9todo <code>createServer(request, response)</code> que recibe dos par\u00e1metros la petici\u00f3n del usuario (request) y la respuesta que devolver\u00e1 el servidor (response). Devuelve un objeto de tipo <code>Server</code>.</p> <p>Una vez creado el objeto <code>Server</code> ser\u00e1 necesario indicar en que puerto debe estar escuchando para recibir peticiones. Para ello, se dispone del m\u00e9todo <code>listen(port, callback)</code>, siendo port el puerto ha escuchar y siendo callback la funci\u00f3n que realizar\u00e1 cuando escuche.</p> <p>\u00a1Cuidado!</p> <p>Se lanzar\u00e1 un error si se intenta escuchar un puerto que ya est\u00e1 escuchando para otro servidor</p> <pre><code>const http = require('node:http')\nconst server = http.createServer((request, response) =&gt; {\nresponse.write(\"Hello world!\")\nresponse.end()\n})\nserver.listen(3000, () =&gt; console.log(\"Escuchando en el puerto 3000...\"))\n</code></pre>"},{"location":"tema_2/page-1/#request-vs-response","title":"Request vs Response","text":"<p><code>Http Request</code> y <code>Http Response</code> son dos conceptos importantes en el mundo del desarrollo de servidores web. Request es la petici\u00f3n que el usuario realiza a trav\u00e9s del navegador web. Dicha petici\u00f3n va a ser tratada en el servidor, y \u00e9ste a su vez mandar\u00e1 una respuesta al usuario. Dicha respuesta es lo que se conoce como response</p>"},{"location":"tema_2/page-1/#request","title":"Request","text":"<p>La estructura de un request es la siguiente:</p> <ul> <li>El m\u00e9todo en el que se realiza la petici\u00f3n (POST, GET, etc).</li> <li>La ruta al fichero al que se realiza la petici\u00f3n (/content/login)</li> <li>Encabezados, donde se indica diferentes aspectos de la petici\u00f3n, como por ejemplo el lenguaje, el tipo de dato con el que se va a realizar la petici\u00f3n (XML, HTML, JSON, etc).</li> <li>El cuerpo de la petici\u00f3n, que aunque es opcional, la informaci\u00f3n que manda el usuario al realizar la petici\u00f3n. Dicha informaci\u00f3n o data tiene que estar escrita de la forma indicada en la cabecera (XML, HTML, JSON, etc)</li> </ul>"},{"location":"tema_2/page-1/#response","title":"Response","text":"<p>En un response podemos encontrar:</p> <ul> <li>status code es el c\u00f3digo del estado de la resoluci\u00f3n de la petici\u00f3n (200, si est\u00e1 todo correcto, 400 si alg\u00fan error etc.)</li> <li>Encabezados, que al igual que en el request describen el contenido.</li> <li>El cuerpo del mensaje, que al igual que el request, es el tipo de dato devuelto por el usuario.</li> </ul>"},{"location":"tema_2/page-1/#metodos-para-peticiones-y-respuesta","title":"M\u00e9todos para peticiones y respuesta","text":"<p>En Node JS se dispone de varios m\u00e9todos para tratar con la petici\u00f3n requerida por el usuario:</p> <ul> <li><code>getHeaders()</code>: obtiene un array con los headers.</li> <li><code>getHeader(name)</code>: obtiene el valor de una de las propiedades (name) de la cabecera.</li> <li><code>hasHeader(name)</code>: comprueba si la cabecera contiene la propiedad indicada.</li> <li><code>path</code>: devuelve la ruta de la petici\u00f3n.</li> <li><code>method</code>: devuelve el m\u00e9todo en el que se ha realizado la petici\u00f3n.</li> <li><code>host</code>: devuelve el host donde se ha realizado la petici\u00f3n.</li> <li><code>writeHead(statusCode, statusMessage, headers)</code>: escribe la cabecera de la respuesta, teniendo en cuenta el c\u00f3digo de estado y como par\u00e1metros voluntarios el mensaje y los headers.</li> <li><code>write()</code>: escribe lo que se debe devolver. Puede recibir el dato a devolver, as\u00ed como su codificaci\u00f3n, adem\u00e1s de un callback.</li> <li><code>end()</code>: es el m\u00e9todo usado para finalizar la respuesta y devolverla al usuario. Puede tener tres par\u00e1metros opcionales:<ul> <li>data: la informaci\u00f3n a devolver. Si se utiliza es similar al m\u00e9todo write.</li> <li>encoding: la codificaci\u00f3n de los datos devueltos.</li> <li>callback: la funci\u00f3n que se realizar\u00e1 cuando finalice la respuesta.</li> </ul> </li> </ul>"},{"location":"tema_2/page-2/","title":"2 HTTP Methods","text":"<p>Los m\u00e9todos HTTP m\u00e1s comunes usados son el m\u00e9todo GET, el m\u00e9todo POST, el m\u00e9todo PUT, el m\u00e9todo PATCH y el m\u00e9todo DELETE.</p> <p>Estos m\u00e9todos indican al servidor que tipo de operaci\u00f3n hay que realizar enviando a trav\u00e9s del cuerpo del request y de los par\u00e1metros de un url informaci\u00f3n a usar.</p> <p>Los m\u00e9todos HTTP tienen una relaci\u00f3n sem\u00e1ntica directa con las operaciones CRUD (Create, Read, Update, Delete).</p> <p>Para poder realizar conexiones a un servidor, haciendo uso de estos m\u00e9todos, se puede usar el m\u00e9todo <code>fetch</code> de Javascript.</p>"},{"location":"tema_2/page-2/#metodo-get","title":"M\u00e9todo GET","text":"<p>El m\u00e9todo GET es usado para recibir informaci\u00f3n y obtener informaci\u00f3n del servidor usando la url dada. Se considera que dicho m\u00e9todo es una operaci\u00f3n de lectura (R).</p> <p>Obtenemos todos los elementos del servidor:</p> <pre><code>fetch('https://jsonplaceholder.typicode.com/todos/')\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n</code></pre> <p>Si no se le indica un m\u00e9todo espec\u00edfico, se usa como defecto el m\u00e9todo GET.</p>"},{"location":"tema_2/page-2/#metodo-post","title":"M\u00e9todo POST","text":"<p>El m\u00e9todo POST es usado para enviar informaci\u00f3n (data) al servidor como un fichero, datos, o a\u00f1adir una nueva fila al final de una tabla. Se podr\u00eda decir, que este m\u00e9todo es usado para a\u00f1adir nuevos items al servidor. Se puede considera a este m\u00e9todo como una operaci\u00f3n de creaci\u00f3n (C).</p> <p>Para crear un nuevo usuario:</p> <pre><code>fetch('https://jsonplaceholder.typicode.com/todos/', {\nmethod: 'POST',\nheaders: { 'content-type': 'application/json' },\nbody: JSON.stringify({\nuserId: 6,\nid: 300,\ntitle: \"Learn fetch api\",\ncompleted: false\n})\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n</code></pre> <p>Note</p> <p>Ten en cuenta que al realizar el POST ha sido necesario pasarle un header y un body. El body contiene la informaci\u00f3n que le enviamos al servidor, mientras que el header contiene en que lenguaje/formato es enviado.</p>"},{"location":"tema_2/page-2/#metodo-put","title":"M\u00e9todo PUT","text":"<p>El m\u00e9todo PUT es usado para actualizar un resource. Si la fuente esta identificada se intenta localizarla, de tal forma que si es un resource existente se actualice, y por el contrario se cree una nueva.</p> <p>Para actualizar el usuario creado actualmente:</p> <pre><code>fetch('https://jsonplaceholder.typicode.com/todos/6', {\nmethod: 'PUT',\nheaders: { 'content-type': 'application/json' },\nbody: JSON.stringify({\nuserId: 1,\nid: 5,\ntitle: \"hello fetch api\",\ncompleted: false\n})\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n</code></pre>"},{"location":"tema_2/page-2/#metodo-patch","title":"M\u00e9todo PATCH","text":"<p>El m\u00e9todo PATCH es usado para actualizar las propiedades de un resource</p> <p>Para modificar la propiedad title y complete:</p> <pre><code>fetch('https://jsonplaceholder.typicode.com/todos/6', {\nmethod: 'PATCH',\nheaders: { 'content-type': 'application/json' },\nbody: JSON.stringify({\ntitle: \"we are going to learn patch method\",\ncompleted: true\n})\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n</code></pre>"},{"location":"tema_2/page-2/#metodo-delete","title":"M\u00e9todo DELETE","text":"<p>El m\u00e9todo DELETE es usado para eliminar un resource especificado en la URL:</p> <p>Para eliminar el usuario creado:</p> <pre><code>fetch('https://jsonplaceholder.typicode.com/todos/6', {\nmethod: 'DELETE',\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n</code></pre>"},{"location":"tema_2/page-2/#realizar-peticion","title":"Realizar petici\u00f3n","text":"<p>Para poder realizar requests en Node JS, podemos usar la API Fetch como en los ejemplos anteriores. El problema es que \u00e9sta es una API reciente y versiones antigua de Node JS no la incorpora.</p> <p>El m\u00f3dulo http trae consigo el m\u00e9todo <code>request()</code> para poder realizar peticiones a un servidor y trabajar con ellos, adem\u00e1s recibe los siguientes par\u00e1metros:</p> <ul> <li><code>url</code> del servidor donde se va a realizar la petici\u00f3n.</li> <li><code>options</code> es un par\u00e1metro opcional que contiene informaci\u00f3n o datos relevantes del request, como por ejemplo los headers, o el m\u00e9todo (por defecto es GET).</li> <li><code>callback</code> que se realizar\u00e1 cuando termine la petici\u00f3n.</li> </ul> <pre><code>const http = require('node:http')\n// GET\nconst get = http.request(\"https://jsonplaceholder.typicode.com/todos/\", {\nmethod: 'GET'\n}, (res) =&gt; {\nconsole.log(\"GET realizado\")\n}).end()\n// POST \nconst post = http.request(\"https://jsonplaceholder.typicode.com/todos/\", {\nmethod: 'POST',\nheaders: { 'content-type': 'application/json' },\n}, (res) =&gt; {\nconsole.log(\"GET realizado\")\n})\npost.write(JSON.stringify({\nuserId: 6,\nid: 300,\ntitle: \"Learn fetch api\",\ncompleted: false\n}))\npost.end()\n</code></pre> <p>Axios</p> <p>Tambi\u00e9n existe la librer\u00eda axios y express compatible con versiones antiguas del NodeJS y que permiten realizar tanto peticiones como respuestas</p>"},{"location":"tema_2/page-2/#http-status-codes","title":"HTTP status codes","text":"<p>Los c\u00f3digos de estado HTTP nos dan informaci\u00f3n de como ha ido la comunicaci\u00f3n con el servidor. Los c\u00f3digos est\u00e1n formados por tres d\u00edgitos, el primer d\u00edgito indica a que grupo pertenece mientras que los otros dos nos indican una informaci\u00f3n m\u00e1s espec\u00edfica sobre el estado.</p> <ul> <li>1XX Respuestas informativas: Esta respuesta significa que el servidor ha recibido los encabezados de la petici\u00f3n, y que el cliente debe proceder a enviar el cuerpo de la mista.</li> <li>2XX Peticiones correctas: Esta clase de c\u00f3digo de estado indica que la petici\u00f3n fue recibida, entendida y aceptada correctamente.</li> <li>3xx Redirecciones: El cliente tiene que tomar una acci\u00f3n adicional para completar la petici\u00f3n. La acci\u00f3n requerida puede ser llevada a cabo por el agente de usuario sin interacci\u00f3n con el usuario si y solo si el m\u00e9todo utilizado en la segunda petici\u00f3n es GET o HEAD. El agente de usuario no debe redirigir autom\u00e1ticamente una petici\u00f3n m\u00e1s de 5 veces, dado que tal funcionamiento indica usualmente un Bucle infinito.</li> <li>4XX Errores del cliente: La solicitud contiene sintaxis incorrecta o no puede procesarse. La intenci\u00f3n de la clase de c\u00f3digos de respuesta 4xx es para casos en los cuales el cliente parece haber errado la petici\u00f3n.</li> <li>5XX Errores del servidor: El servidor fall\u00f3 al completar una solicitud aparentemente v\u00e1lida. Los c\u00f3digos de respuesta que comienzan con el d\u00edgito \"5\" indican casos en los cuales el servidor tiene registrado a\u00fan antes de servir la solicitud, que est\u00e1 errado o es incapaz de ejecutar la petici\u00f3n.</li> </ul> <p>Ahora veamos en profundidad las peticiones m\u00e1s t\u00edpicas:</p> <ul> <li>200 - OK:Petici\u00f3n resulta de forma correcta sin ning\u00fan inconveniente.</li> <li>301 - Moved Permanently: Se ha realizado la conexi\u00f3n correctamente pero el recurso solicitado ha sido movido de forma permanente.</li> <li>400 - Bad Request: Se ha realizado la petici\u00f3n con informaci\u00f3n incorrecta.</li> <li>404 - Not Found: No se encuentra la informaci\u00f3n solicitada.</li> <li>500 - Internal Server Error: Error del servidor</li> </ul> <p>Info</p> <p>Para conocer m\u00e1s espec\u00edficamente los tipos de estados que hay puede visitar la siguiente p\u00e1gina:</p> <p>https://www.restapitutorial.com/httpstatuscodes.html</p> <p>Tambi\u00e9n existe una versi\u00f3n con gatos:</p> <p>https://http.cat/</p> <p>Adem\u00e1s, existen diferentes librer\u00edas que almacenan en constantes los valores de los status code, una de ellas ser\u00eda:</p> <p>https://www.npmjs.com/package/http-status-codes</p>"},{"location":"tema_2/page-3/","title":"3 Introducci\u00f3n a API REST","text":""},{"location":"tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Una REST API, o API RESTFUL, es una interfaz de programaci\u00f3n de aplicaciones que se ajusta a los l\u00edmites de la arquitectura REST y permite la interacci\u00f3n con los servicios web de RESTful.</p> <p> Figura 2 - API REST</p> <p>El usuario realiza una petici\u00f3n que es tratada a trav\u00e9s de la API, que comunica con el servidor para que realice la operaci\u00f3n y devuelva una respuesta, que vuelve a ser tratada por la API y devuelta al usuario.</p>"},{"location":"tema_2/page-3/#apis","title":"APIs","text":"<p>Las API son conjuntos de definiciones y protocolos que se utilizan para dise\u00f1ar e integrar el software de las aplicaciones. Suele considerarse como el contrato entre el proveedor de informaci\u00f3n y el usuario, donde se establece el contenido que se necesita por parte del consumidor (la llamada) y el que requiere el productor (la respuesta).Por ejemplo, el dise\u00f1o de una API de servicio meteorol\u00f3gico podr\u00eda requerir que el usuario escribiera un c\u00f3digo postal y que el productor diera una respuesta en dos partes: la primera ser\u00eda la temperatura m\u00e1xima y la segunda, la m\u00ednima.</p> <p>En otras palabras, las API le permiten interactuar con una computadora o un sistema para obtener datos o ejecutar una funci\u00f3n, de manera que el sistema comprenda la solicitud y la cumpla.</p> <p>Se puede considerar como los mediadores, un camino intermedio, entre los usuarios y los servicios web que se requieren obtener. De esta forma se pueden compartir recursos e informaci\u00f3n mientras se conservan la seguridad, el control y la autentificaci\u00f3n.</p> <p>Otra ventaja de las API es que no se necesita saber c\u00f3mo se recibe el recurso ni de d\u00f3nde proviene.</p>"},{"location":"tema_2/page-3/#rest","title":"REST","text":"<p>REST no es un protocolo ni un est\u00e1ndar, sino m\u00e1s bien un conjunto de l\u00edmites de arquitectura. Los desarrolladores de las API pueden implementarlo de distintas maneras.</p> <p>Cuando el cliente env\u00eda una solicitud a trav\u00e9s de una API de RESTful, esta transfiere una representaci\u00f3n del estado del recurso requerido a quien lo haya solicitado o al extremo. La informaci\u00f3n se entrega por medio de HTTP en uno de estos formatos: JSON (JavaScript Object Notation), HTML, XLT, Python, PHP o texto sin formato. JSON es el lenguaje de programaci\u00f3n m\u00e1s popular, ya que tanto las m\u00e1quinas como las personas lo pueden comprender y no depende de ning\u00fan lenguaje, a pesar de que su nombre indique lo contrario.</p> <p>Tambi\u00e9n es necesario tener en cuenta otros aspectos. Los encabezados y los par\u00e1metros tambi\u00e9n son importantes en los m\u00e9todos HTTP de una solicitud HTTP de la API de RESTful, ya que contienen informaci\u00f3n de identificaci\u00f3n importante con respecto a los metadatos, la autorizaci\u00f3n, el identificador uniforme de recursos (URI), el almacenamiento en cach\u00e9, las cookies y otros elementos de la solicitud. Hay encabezados de solicitud y de respuesta, pero cada uno tiene sus propios c\u00f3digos de estado e informaci\u00f3n de conexi\u00f3n HTTP.</p> <p>Para que una API se considere de RESTful, debe cumplir los siguientes criterios:</p> <ul> <li>Arquitectura cliente-servidor compuesta de clientes, servidores y recursos, con la gesti\u00f3n de solicitudes a trav\u00e9s de HTTP.</li> <li>Comunicaci\u00f3n entre el cliente y el servidor sin estado, lo cual implica que no se almacena la informaci\u00f3n del cliente entre las solicitudes de GET y que cada una de ellas es independiente y est\u00e1 desconectada del resto.</li> <li>Datos que pueden almacenarse en cach\u00e9 y optimizan las interacciones entre el cliente y el servidor.</li> <li>Una interfaz uniforme entre los elementos, para que la informaci\u00f3n se transfiera de forma estandarizada. Para ello deben cumplirse las siguientes condiciones:<ul> <li>Los recursos solicitados deben ser identificables e independientes de las representaciones enviadas al cliente.</li> <li>El cliente debe poder manipular los recursos a trav\u00e9s de la representaci\u00f3n que recibe, ya que esta contiene suficiente informaci\u00f3n para permitirlo</li> <li>Los mensajes autodescriptivos que se env\u00eden al cliente deben contener la informaci\u00f3n necesaria para describir c\u00f3mo debe procesarla.</li> <li>Debe contener hipertexto, lo cual significa que cuando el cliente acceda a alg\u00fan recurso, debe poder utilizar hiperv\u00ednculos para buscar las dem\u00e1s acciones que se encuentren disponibles en ese momento.</li> </ul> </li> <li>Un sistema en capas que organiza en jerarqu\u00edas invisibles para el cliente cada uno de los servidores (los encargados de la seguridad, del equilibrio de carga, etc.) que participan en la recuperaci\u00f3n de la informaci\u00f3n solicitada.</li> <li>C\u00f3digo disponible seg\u00fan se solicite (opcional), es decir, la capacidad para enviar c\u00f3digos ejecutables del servidor al cliente cuando se requiera, lo cual ampl\u00eda las funciones del cliente.</li> </ul> <p>Si bien la API de REST debe cumplir todos estos par\u00e1metros, resulta m\u00e1s f\u00e1cil de usar que un protocolo definido previamente, como SOAP (protocolo simple de acceso a objetos), el cual tiene requisitos espec\u00edficos, como la mensajer\u00eda XML y la seguridad y el cumplimiento integrados de las operaciones, que lo hacen m\u00e1s lento y pesado.</p> <p>Por el contrario, REST es un conjunto de pautas que pueden implementarse seg\u00fan sea necesario. Por esta raz\u00f3n, las API de REST son m\u00e1s r\u00e1pidas y ligeras, cuentan con mayor capacidad de ajuste y, por ende, resultan ideales para el Internet de las cosas (IoT) y el desarrollo de aplicaciones para dispositivos m\u00f3viles.</p>"},{"location":"tema_2/page-3/#creacion-de-una-api-rest-con-node-js","title":"Creaci\u00f3n de una API REST con Node JS","text":"<p>Para crear una API REST, ser\u00e1 necesario crear un servidor. Cuando el servidor esta creado habr\u00e1 que tratar de manejar las diferentes tipos de rutas con las que se va a trabajar.</p> <p>Supongamos que queremos crear una API para trabajar con pokemon, necesitaremos las rutas para acceder a todos los pokemon, crearlos, modificarlos y eliminarlos:</p> <pre><code>const ROUTES = {\nALL: '/api/pokemons',\nONLY: 'api/pokemon'\n}\n</code></pre> <p>La ruta ALL ser\u00e1 usada para aquellas peticiones con las que tenga que trabajar con TODOS los pokemon, como por ejemplo obtener todos los pokemon. Mientras que la ruta ONLY ser\u00e1 necesaria para necesitar realizar operaciones con un pokemon concreto, por ejemplo: obtener un pokemon, eliminar un pokemon, crear un pokemon, actualizar un pokemon.</p> <p>Una vez definidas las rutas creamos nuestro servidor, con un m\u00e9todo callback que se encargar\u00e1 de procesar la informaci\u00f3n:</p> <pre><code>const processRequest = (req, res) =&gt; { }\nconst server = http.createServer(processRequest)\nserver.listen(1234, () =&gt; console.log('server listening on port http://localhost:1234'))\n</code></pre> <p>En el m\u00e9todo <code>processRequest</code> debemos comprobar el m\u00e9todo que se est\u00e1 usando, en este ejemplo vamos a usar el m\u00e9todo GET y el m\u00e9todo POST, para obtener pokemons y crearlos.</p> <pre><code>const processRequest = (req, res) =&gt; {\nconst { method } = req\nswitch (method) {\ncase 'GET':\n// handler get\ncase 'POST':\n// handler post\n}\n}\n</code></pre> <p>Una vez que conocemos el m\u00e9todo que se est\u00e1 llevando a cabo, debemos comprobar si coincide con alguna de las rutas, en caso de que deban coincidir. Por ejemplo, en el m\u00e9todo GET de nuestro proyecto, podr\u00e1 realizar la petici\u00f3n con las dos rutas definidas, para as\u00ed obtener TODOS o UNO solo, mientras que a la hora de hacer el POST solo es necesario una ruta:</p> <pre><code>const processRequest = (req, res) =&gt; {\nconst { method, url } = req\nswitch (method) {\ncase 'GET':\nswitch (url) {\ncase ROUTES.ALL:\nres.setHeader('Content-Type', 'application/json; charset=utf-8')\nreturn res.end(JSON.stringify(pokemons))\ncase ROUTES.ONLY:\nres.setHeader('Content-Type', 'application/json; charset=utf-8')\nreturn res.end(JSON.stringify(pokemons[0]))\n}\ncase 'POST':\n// handler POST\n}\n}\n</code></pre> <p>Al hacer el POST debemos tener en cuenta que es necesario obtener el body de la petici\u00f3n, pero el problema est\u00e1 en que la petici\u00f3n van llegando poco a poco hasta que termine de completarse. Para ello, disponemos del evento <code>data</code> que se ejecuta cada vez que nos va llegando esa informaci\u00f3n, y el evento <code>end</code> que se ejecuta cuando la petici\u00f3n ha terminado de llegar:</p> <pre><code>const processRequest = (req, res) =&gt; {\n// ...\nswitch (method) {\n// ...\ncase 'POST':\nswitch (url) {\ncase ROUTES.ONLY: {\nlet body = '' // Creamos un cuerpo vac\u00edo\n// Escuchamos el evento DATA\nreq.on('data', chunk =&gt; {\nbody += chunk.toString()\n})\n// Escuchamos el evento END que sucede cuando\n// la petici\u00f3n a finalizado de llegar\nreq.on('end', () =&gt; {\nconst data = JSON.parse(body)\nres.writeHead(201, { 'Content-Type': 'application/json; charset=utf-8' })\nres.end(JSON.stringify(data))\n})\n}\n}\n}\n}\n</code></pre> <p>La petici\u00f3n va llegando poco a poco, por lo que se va almacenando a la variable body.Es importante saber que la informaci\u00f3n llega en binario, por eso se usa el m\u00e9todo <code>toString()</code> a la informaci\u00f3n que nos va llegando (chuck). Una vez que la petici\u00f3n ha finalizado su llegada, en el evento <code>end</code>, resolvemos la petici\u00f3n</p> <p>Por \u00faltimo, se indicar\u00eda un caso default para tratar con las rutas o los m\u00e9todos que no se han indicado:</p> <pre><code>default:\nres.setHeader('Content-Type', 'text/html; charset=utf-8')\nreturn res.end('&lt;h1&gt;404&lt;/h1&gt;')\n</code></pre> <p>Ejemplo completo:</p> <pre><code>const http = require('node:http')\nconst pokemons = require('package');\nconst ROUTES = {\nALL: '/api/pokemons',\nONLY: 'api/pokemon'\n}\nconst processRequest = (req, res) =&gt; {\nconst { method, url } = req\nswitch (method) {\ncase 'GET':\nswitch (url) {\ncase ROUTES.ALL:\nres.setHeader('Content-Type', 'application/json; charset=utf-8')\nreturn res.end(JSON.stringify(pokemons))\ncase ROUTES.ONLY:\nres.setHeader('Content-Type', 'application/json; charset=utf-8')\nreturn res.end(JSON.stringify(pokemons[0]))\ndefault:\nres.setHeader('Content-Type', 'text/html; charset=utf-8')\nreturn res.end('&lt;h1&gt;404&lt;/h1&gt;')\n}\ncase 'POST':\nswitch (url) {\ncase ROUTES.ONLY: {\nlet body = '' // Creamos un cuerpo vac\u00edo\n// Escuchamos el evento DATA\n// Cada vez que va llegando la petici\u00f3n poco a poco\n// se va almacenando a la variable body\n// es importante saber que la informaci\u00f3n llega en binario,\n// por eso se usa el m\u00e9todo toString()\nreq.on('data', chunk =&gt; {\nbody += chunk.toString()\n})\n// Escuchamos el evento END que sucede cuando\n// la petici\u00f3n a finalizado de llegar\nreq.on('end', () =&gt; {\nconst data = JSON.parse(body)\nres.writeHead(201, { 'Content-Type': 'application/json; charset=utf-8' })\nres.end(JSON.stringify(data))\n})\n}\ndefault:\nres.setHeader('Content-Type', 'text/html; charset=utf-8')\nreturn res.end('&lt;h1&gt;404&lt;/h1&gt;')\n}\ndefault:\nres.setHeader('Content-Type', 'text/html; charset=utf-8')\nreturn res.end('&lt;h1&gt;404&lt;/h1&gt;')\n}\n}\nconst server = http.createServer(processRequest)\nserver.listen(1234, () =&gt; console.log('server listening on port http://localhost:1234'))\n</code></pre> <p>Sugerencia</p> <p>Cierto es, que cada vez que debemos de a\u00f1adir una ruta o un m\u00e9todo, debemos tener de modificar el c\u00f3digo. Por eso recomienda el uso de m\u00e9todos que maneje cada caso del <code>switch</code> incluso poder usar <code>if</code> con retornos:</p> <p><pre><code>const processRequest = (req, res) =&gt; {\nif(req.method === \"GET\"){\nreturn handlerGET(req, res)\n}\n// ...\n}\nconst handlerGET = (req, res) =&gt;{\nif(req.url === Routes.ALL){\nreturn getAll(req, res)\n}\n// ...\n}\n</code></pre> Adem\u00e1s, tambi\u00e9n, se recomienda crear diferentes ficheros haciendo uso de las importaciones y de las exportaciones para poder trabajar de una forma clara.</p> <p>Info</p> <p>Para poder realizar peticiones a una API REST podemos crearnos un proyecto en cualquier otro lenguaje y crear una aplicaci\u00f3n que consuma nuestra API. Tambi\u00e9n existen aplicaciones como POSTMAN para poder consumirlas.</p>"},{"location":"tema_2/page-4/","title":"Proyecto","text":"<p>En este proyecto se va a llevar a cabo la creaci\u00f3n de una API REST, siendo nuestra fuente de datos un fichero JSON.</p> <p>Se desea realizar todas las operaciones CRUD sobre los alumnos que estudian esta materia. La informaci\u00f3n a almacenar es la siguiente:</p> <ul> <li>ID del alumno.</li> <li>Nombre del alumno.</li> <li>Fecha de nacimiento del alumno.</li> <li>Nota media del curso.</li> </ul> <p>Se debe realizar una API siguiendo la arquitectura REST, definiendo correctamente las rutas y los m\u00e9todos del protocolo HTTP, as\u00ed como sus c\u00f3digos de estado y su cabeceras.</p> <p>La informaci\u00f3n ser\u00e1 a\u00f1adida, modificada o elimina en el mismo fichero.</p>"},{"location":"tema_3/page-1/","title":"1 REST API","text":""},{"location":"tema_3/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya se vi\u00f3 en el tema anterior, API son las siglas de \"Interfaz de Programaci\u00f3n de Aplicaciones\" en ingl\u00e9s, que se traduce como \"Application Programming Interface\". En t\u00e9rminos simples, una API es un conjunto de reglas y definiciones que permite que diferentes aplicaciones se comuniquen entre s\u00ed.</p> <p>Una API define los m\u00e9todos y datos que un desarrollador puede usar para interactuar con un software o servicio espec\u00edfico, sin necesidad de comprender los detalles internos de c\u00f3mo funciona ese software. Las APIs son fundamentales para la creaci\u00f3n de software moderno, ya que permiten la integraci\u00f3n de diferentes sistemas, servicios y aplicaciones, facilitando la interoperabilidad y la creaci\u00f3n de soluciones m\u00e1s complejas.</p> <p>En el contexto de la web, las APIs a menudo se utilizan para permitir que aplicaciones web se comuniquen con servidores, accedan a bases de datos, o integren servicios externos. Por ejemplo, las redes sociales suelen ofrecer APIs que permiten a los desarrolladores crear aplicaciones que interact\u00faan con la plataforma, como aplicaciones para programar publicaciones, acceder a datos de usuarios, entre otras funcionalidades.</p> <p> Figura 1 - API</p>"},{"location":"tema_3/page-1/#diferentes-arquitecturas","title":"Diferentes arquitecturas","text":"<p>Existen diferentes formas de crear una API, a lo largo del tiempo se han determinado diferentes arquitectura para poder dise\u00f1ar una API:</p> <ul> <li>REST (Representational State Transfer). Es una arquitectura que utiliza los m\u00e9todos HTTP para realizar las operaciones en recursos identificados por URLs.</li> <li>SOAP (Simple Object Access Protocol). Es un protocolo basado XML para el intercambio de informaci\u00f3n estructurada en la web. A diferencia de REST, SOAP no est\u00e1 ligado a ning\u00fan protocolo de transporte espec\u00edfico y puede utilizarse sobre HTTP, SMTP, TCP, etc.</li> <li>GraphQL: Es una consulta de datos y un lenguaje de manipulaci\u00f3n de datos desarrollado por Facebook. Permite a los clientes solicitar solo los datos que necesitan y nada m\u00e1s, lo que puede ser m\u00e1s eficiente que las consultas tradicionales de REST.</li> <li>RPC (Remote Procedure Call): Es un modelo de comunicaci\u00f3n que permite a un programa ejecutar c\u00f3digo en otro espacio de direcciones de manera transparente, como si fuera una llamada a una funci\u00f3n local. Protocolos como gRPC se basan en este concepto.</li> <li>JSON-RPC y XML-RPC: Son protocolos que utilizan JSON o XML para la codificaci\u00f3n de datos y permiten la ejecuci\u00f3n remota de funciones.</li> <li>OData (Open Data Protocol): Es un protocolo est\u00e1ndar de la OASIS que permite la creaci\u00f3n y el consumo de servicios web RESTful. Facilita la creaci\u00f3n de servicios web que permiten la consulta y manipulaci\u00f3n de datos utilizando est\u00e1ndares web.</li> </ul> <p>Estas son solo algunas de las arquitecturas comunes, y la elecci\u00f3n de la arquitectura depende de varios factores, como los requisitos del proyecto, la naturaleza de los datos, la escalabilidad y las preferencias del desarrollador. La tendencia actual tiende hacia arquitecturas RESTful debido a su simplicidad y eficiencia en la mayor\u00eda de los casos.</p>"},{"location":"tema_3/page-1/#api-rest","title":"API REST","text":"<p>Una REST API (Interfaz de Programaci\u00f3n de Aplicaciones basada en Transferencia de Estado Representacional) es un conjunto de reglas y convenciones arquitect\u00f3nicas para dise\u00f1ar servicios web que se centran en la transferencia de datos y la manipulaci\u00f3n de recursos a trav\u00e9s de los m\u00e9todos est\u00e1ndar del protocolo HTTP. REST se basa en la idea de que las aplicaciones web pueden comunicarse entre s\u00ed de manera eficiente mediante la manipulaci\u00f3n de representaciones de recursos a trav\u00e9s de URLs.</p> <p>Algunas caracter\u00edsticas clave de una REST API incluyen:</p> <ul> <li>Recursos: En el contexto de REST, un recurso es una entidad o un concepto que puede ser identificado mediante una URL \u00fanica. Pueden ser objetos de la vida real o abstractos, como datos de usuarios, im\u00e1genes, o cualquier otra entidad.</li> <li>Operaciones est\u00e1ndar: REST utiliza los m\u00e9todos HTTP est\u00e1ndar, como GET, POST, PUT y DELETE, para realizar operaciones sobre los recursos. Cada m\u00e9todo tiene un prop\u00f3sito espec\u00edfico: GET para obtener datos, POST para crear nuevos recursos, PUT para actualizar recursos existentes, y DELETE para eliminar recursos.</li> <li>Estado Representacional: La representaci\u00f3n de un recurso (como JSON o XML) se env\u00eda al cliente, y el cliente puede realizar operaciones basadas en esa representaci\u00f3n. Cada recurso puede tener m\u00faltiples representaciones (por ejemplo, JSON y XML), y el cliente puede indicar sus preferencias mediante encabezados HTTP.</li> <li>Sin estado (Stateless): Cada solicitud del cliente al servidor en una REST API debe contener toda la informaci\u00f3n necesaria para entender y procesar la solicitud. La comunicaci\u00f3n entre cliente y servidor no debe depender del estado del servidor; cada solicitud debe ser independiente de las anteriores.</li> <li>Jerarqu\u00eda de URL: Las URLs se utilizan para identificar y acceder a los recursos. La estructura de las URLs suele seguir una jerarqu\u00eda que refleja la organizaci\u00f3n de los recursos.</li> <li>HATEOAS (Hypermedia As The Engine Of Application State): Este principio sugiere que la aplicaci\u00f3n debe ser impulsada por el hiperv\u00ednculo proporcionado din\u00e1micamente por las aplicaciones servidores de los estados de la aplicaci\u00f3n, guiando a los usuarios a trav\u00e9s de las acciones disponibles.</li> </ul> <p>Una REST API es una opci\u00f3n com\u00fan y popular para construir servicios web debido a su simplicidad, escalabilidad y facilidad de comprensi\u00f3n. Es ampliamente utilizada en aplicaciones web y m\u00f3viles para permitir la comunicaci\u00f3n eficiente entre el cliente y el servidor.</p> <p> Figura 2 - REST API</p>"},{"location":"tema_3/page-2/","title":"2 Express","text":""},{"location":"tema_3/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Existen diferente librer\u00edas y frameworks para poder dise\u00f1ar una aplicaci\u00f3n REST API en Node JS, adem\u00e1s de la forma nativa ya vista en el tema anterior. Entre ellas encontramos:</p> <ul> <li>Restify: Es un framework espec\u00edficamente dise\u00f1ado para construir APIs Restful en Node JS. Est\u00e1 optimizado para el rendimiento y tiene funcionalidades incorporadas para la validaci\u00f3n, versionado y manejo de errores en APIs.</li> <li>Hapi.js: Es un framework que se utiliza para construir aplicaciones y servicios en Node.js. Al igual que Express, Hapi.js es vers\u00e1til y se puede utilizar para crear APIs RESTful. Proporciona una arquitectura modular y extensible.</li> <li>Koa.js: Desarrollado por el equipo detr\u00e1s de Express.js, Koa.js es un framework m\u00e1s nuevo y m\u00e1s ligero. Aunque no es espec\u00edficamente un framework para APIs REST, su enfoque modular y su sistema de middleware lo hacen adecuado para construir APIs.</li> <li>Nest.js: Es un framework m\u00e1s completo y basado en TypeScript que utiliza las mejores pr\u00e1cticas de desarrollo y arquitectura. Est\u00e1 construido sobre Express.js y proporciona una estructura modular basada en m\u00f3dulos, inyecci\u00f3n de dependencias y decoradores.</li> </ul> <p>En este tema se trabajara con Express</p>"},{"location":"tema_3/page-2/#express","title":"Express","text":"<p>Express.js, com\u00fanmente conocido como Express, es un framework web para Node.js que facilita la creaci\u00f3n de aplicaciones web y APIs. Es minimalista, flexible y est\u00e1 dise\u00f1ado para ser una capa ligera sobre Node.js, proporcionando una serie de caracter\u00edsticas y herramientas que simplifican el desarrollo web.</p> <p>Algunas caracter\u00edsticas clave de Express incluyen:</p> <ul> <li>Enrutamiento: Express simplifica el manejo de las rutas y las solicitudes HTTP. Puedes definir rutas y especificar c\u00f3mo deben manejarse las solicitudes para esas rutas.</li> <li>Middleware: Express utiliza un sistema de middleware que te permite ejecutar funciones en el ciclo de vida de una solicitud. Esto es \u00fatil para realizar tareas como la autenticaci\u00f3n, la manipulaci\u00f3n de datos de solicitud o respuesta, y m\u00e1s.</li> <li>Plantillas: Express no impone una plantilla espec\u00edfica, pero es compatible con varias, como EJS, Pug (anteriormente conocido como Jade), y Handlebars. Esto facilita la renderizaci\u00f3n de vistas en el servidor.</li> <li>Gesti\u00f3n de sesiones y cookies: Express facilita la implementaci\u00f3n de la gesti\u00f3n de sesiones y el manejo de cookies.</li> <li>Manejo de errores: Proporciona un sistema simple para manejar errores durante el procesamiento de las solicitudes.</li> <li>Middleware de terceros: Puedes aprovechar una gran cantidad de middleware de terceros que simplifican tareas comunes, como la autenticaci\u00f3n con Passport.js, la compresi\u00f3n de respuestas con compression, y muchos otros.</li> </ul>"},{"location":"tema_3/page-2/#proyecto-express","title":"Proyecto Express","text":"<p>Para comenzar a utilizar Express, primero debes instalarlo a trav\u00e9s de npm (el sistema de gesti\u00f3n de paquetes de Node.js). Puedes hacerlo con el siguiente comando: <code>npm install express</code></p> <p>Una vez instalado, importamos el paquete express y creamos una variable para poder trabajar con los m\u00e9todos y variables de express. Con el m\u00e9todo <code>express()</code> se crea una aplicaci\u00f3n de express:</p> <pre><code>const express = require('express')\nconst app = express()\n</code></pre> <p>Para iniciar el servidor se usa el m\u00e9todo <code>listen()</code>, muy parecido al m\u00e9todo nativo, que recibe el puerto que debe escuchar y una callback que ejecutar\u00e1 cuando se inicie el servicio:</p> <pre><code>const PORT = process.env.PORT ?? 1234\napp.listen(PORT, () =&gt; {\nconsole.log(`Server listening http://localhost:${PORT}`)\n})\n</code></pre> <p>Express tiene diferentes m\u00e9todos que nos permite trabajar con los m\u00e9todos HTTP sin necesidad de tener que tratarlo en una estructura condicional. Existe un m\u00e9todo de express para cada m\u00e9todo HTTP, <code>get()</code>, <code>post()</code>, <code>patch()</code>, <code>put()</code>, <code>delete()</code>, etc. Estos m\u00e9todos reciben dos par\u00e1metros, en el primero la ruta que debe actuar, y en el segundo una callback que permite tratar con la request y el response:</p> <pre><code>app.get('/', (req, res) =&gt; {\nres.status(200)\n.send('&lt;h1&gt;Mi p\u00e1gina&lt;/h1&gt;')\n})\n</code></pre> <p>Como se puede observar en el m\u00e9todo anterior, express tiene m\u00e9todos para poder trabajar con el response de manera sencilla:</p> <ul> <li><code>status()</code>: Indica el estado del response, por defecto ser\u00e1 200.</li> <li><code>send()</code>: env\u00eda el response. Una de las ventajas de este m\u00e9todo, es que identifica de forma sencilla el tipo de contenido a retornar, por lo que no ser\u00eda necesario indicarle el header Content-Type.</li> <li><code>json()</code>: env\u00eda el response pero adem\u00e1s con el Content-Type en formato JSON.</li> </ul> <pre><code>app.get('/pokemon', (req, res) =&gt; {\nres.json(pokemon)\n})\n</code></pre>"},{"location":"tema_3/page-2/#tratamiento-de-las-rutas","title":"Tratamiento de las rutas","text":"<p>Como ya se vio en el tema anterior, una ruta puede estar definida de la siguiente manera: <code>https://midominio.es/endpoint/param?queryName=queryValue</code> donde :</p> <ul> <li><code>midominio.es</code> es el dominio de la web.</li> <li><code>endpoint</code> es el nombre del recurso con el que tratar.</li> <li><code>param</code> es el par\u00e1metro para obtener el recurso indicado, como por ejemplo una id</li> <li><code>queryName=queryValue</code> es el par clave-valor, donde la clave es el nombre de la instancia a localizar y el valor es su valor. Puede haber tantas queries como sea necesario, separ\u00e1ndolas con <code>&amp;</code></li> </ul> <p>Por ejemplo, con la url <code>https://midominio.es/users/60?deleted=false</code>, localizamos los usuarios cuya id sea 60, pero los que tengan el atributo deleted a false.</p> <p>Para acceder tanto a los par\u00e1metros como a la query, debemos conocer muy bien la url. Sin embargo, express trabaja con un paquete llamado <code>path-to-regexp</code> que permite indicar expresiones regulares a las rutas y acceder a ellas de forma m\u00e1s sencilla.</p> <p>Una de las caracter\u00edsticas de este paquete son los par\u00e1metros nombrados, donde se indicar\u00eda en la ruta el nombre del par\u00e1metro y se pueda acceder a \u00e9l a trav\u00e9s del objeto <code>params</code> de la request:</p> <pre><code>app.get('/pokemon/:id', (req, res) =&gt; {\nconst { id } = req.params\n//...\n})\n</code></pre> <p>Para poder trabajar con las queries, express tiene una propiedad llamada <code>query</code>que almacena en un objeto todos los pares clave-valor:</p> <pre><code>app.get('/pokemon', (req, res) =&gt; {\nconst { deleted } = req.query\n//...\n})\n</code></pre>"},{"location":"tema_3/page-2/#metodo-use","title":"M\u00e9todo use","text":"<p>Express tiene un m\u00e9todo denominado <code>use()</code>, dicho m\u00e9todo se utiliza para indicar una operaci\u00f3n para todo los tipos de m\u00e9todos. Su uso mayoritario suele ser para trabajar con middlewares en la aplicaci\u00f3n, pero cierto que es que se puede usar para cualquier otra cosa, siempre y cuando se tenga en cuenta que no importa el m\u00e9todo que se realiza en la petici\u00f3n.</p> <p>Por ejemplo, podemos usarlo para la ruta pokemon/all, que mostrar\u00e1 un mensaje de error, por que no es una ruta v\u00e1lida:</p> <pre><code>app.use('/pokemon/all', (req, res) =&gt; {\nres.status(404).send('&lt;h1&gt;Error&lt;/h1&gt;')\n})\n</code></pre> <p>Incluso, se puede usar sin indicar ruta, por lo que se traducir\u00e1 que cualquier ruta indicada en cualquier m\u00e9todo har\u00e1 una llamada al callback:</p> <pre><code>app.use((req, res) =&gt; {\nres.status(404).send('&lt;h1&gt;Error&lt;/h1&gt;')\n})\n</code></pre> <p>Hay que tener en cuenta, que el orden en el que se realizan los m\u00e9todos HTTP, as\u00ed como sus rutas son de total importancia. Cuando us\u00e1bamos la forma nativa, se ve\u00eda de forma m\u00e1s clara, por que us\u00e1bamos varios cases y como default, se mostraba un mensaje de error con c\u00f3digo 404. Sin embargo, con express se pierde la estructura condicional, pero su funcionamiento es bastante similar, va comprobando m\u00e9todo a m\u00e9todo si coincide con lo que ha entrado en la request y en caso de coincidir entra y realiza el response. Por ello, cuando queremos usar el m\u00e9todo <code>use</code> para indicar que una ruta no es correcta, es importante colocar dicha operaci\u00f3n al final de las indicaciones de la ruta, de esta forma, validar\u00e1 todos los m\u00e9todos y rutas y si no coincide con ninguna, entrar\u00e1 en el m\u00e9todo <code>use()</code>. Para ello, el orden recomendado ser\u00eda:</p> <ul> <li>Acceso a los middleware</li> <li>Acceso a los recursos de forma directa, por ejemplo /users.</li> <li>Acceso a los recursos con par\u00e1metros, por ejemplo /users/50. Si se indicase este tipo de ruta antes que las rutas de recursos de forma directa /users, podr\u00edan entrar en estas antes (ya que la id, no es un par\u00e1metro obligatorio), y dar lugar a resultados no deseados.</li> <li>Acceso al m\u00e9todo `use() como \u00faltima opci\u00f3n, para devolver un 404.</li> </ul> <pre><code>app.get('/pokemon', (req, res) =&gt; {\n//...\n})\napp.get('/pokemon/:id', (req, res) =&gt; {\n// ...\n})\napp.post('/pokemon', (req, res) =&gt; {\n//...\n})\n// ...\napp.use((req, res) =&gt; {\n// ...\n})\n</code></pre> <p>Tambi\u00e9n es recomendable agrupar todas las rutas por m\u00e9todos, es decir, poner primero todas las rutas de un m\u00e9todo, por ejemplo GET, y despu\u00e9s de otro m\u00e9todo, por ejemplo POST.</p>"},{"location":"tema_3/page-3/","title":"3 Middlewares","text":""},{"location":"tema_3/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Cuando se recibe una petici\u00f3n a trav\u00e9s del protocolo HTTP, este petici\u00f3n debe ser tratada dentro del m\u00e9todo que se indica. Como ya vimos en el tema anterior, cuando se realiza una petici\u00f3n y se env\u00eda un cuerpo del mismo, este cuerpo va llegando poco a poco a medida que se va recibiendo la informaci\u00f3n, por lo que se deber\u00eda de tratar la informaci\u00f3n una vez que haya finalizado la petici\u00f3n, de tal forma que se vaya recolectando la informaci\u00f3n poco a poco vaya llegando en un buffer:</p> <pre><code>app.post('/pokemon', (req, res) =&gt; {\nlet body = ''\nreq.on('data', chunk =&gt; { //(1)!\nbody += chunk.toString()\n})\nreq.on('end', () =&gt; { //(2)!\nconst data = JSON.parse(body)\nbody = data\n//(3)!\n})\n})\n</code></pre> <ol> <li>Va obteniendo la informaci\u00f3n seg\u00fan va llegando, y almacen\u00e1ndola en la variable body.</li> <li>Una vez finalizada la petici\u00f3n parsea el buffer en JSON</li> <li>Una vez parseada la informaci\u00f3n a JSON se trata como necesitemos, a\u00f1adi\u00e9ndola a la base de datos o devolvi\u00e9ndola como respuesta.</li> </ol> <p>Cada vez que tuvi\u00e9ramos que realizar una operaci\u00f3n en la cual se requiera el cuerpo en la petici\u00f3n, ser\u00eda necesario realizar los mismos pasos que en el ejemplo, incluso parsearlo a otro tipo de contenido si fuese necesario.</p>"},{"location":"tema_3/page-3/#middleware","title":"Middleware","text":"<p>Hasta ahora, cuando se realizaba una petici\u00f3n, esta petici\u00f3n era tratada y procesada por el marco de express, y luego devolv\u00eda una response:</p> <p> Figura 3 - Marco Express</p> <p>Un middleware se considera como un paso intermedio, entre la petici\u00f3n y el proceso de la misma, en la cu\u00e1l se pueden realizar operaciones para cualquiera de los m\u00e9todos indicados. De esta forma, si la petici\u00f3n requiere de un cuerpo en formato JSON, el middleware se encargar\u00eda de realizar el parseo y luego ejecutar\u00eda el proceso en el m\u00e9todo correspondiente.</p> <p>Es importante que la callback de un middleware reciba el m\u00e9todo <code>next()</code>, ya que este m\u00e9todo ser\u00e1 el encargado de mandar la request modificada a la petici\u00f3n necesaria.</p> <p> Figura 3 - Marco Express</p> <p>El middleware se puede usar:</p> <ul> <li>Para cualquier m\u00e9todo y ruta, haciendo uso del m\u00e9todo <code>use(cb)</code></li> <li>Para cualquier m\u00e9todo pero para una ruta espec\u00edfica, usando <code>use(path, cb)</code></li> <li>Para cualquier m\u00e9todo cuya ruta que cumpla un expresi\u00f3n regular, <code>use(pathToRegex, cb)</code></li> <li>Para un m\u00e9todo espec\u00edfico, haciendo uso del m\u00e9todo a usar.</li> </ul> <p>El middleware puede ir colocado en cualquier parte del c\u00f3digo donde sea necesario usarlo. Aunque se recomienda que dependiendo del tipo de acceso que se va a tener, se coloque en el lugar pertinente.</p> <pre><code>app.use((req, res, next) =&gt; {\nconsole.log('mi primer middleware')\nif (req.method !== \"POST\") return next()\nif (req.headers['content-type'] !== \"application/json\") return next()\nlet body = ''\nreq.on('data', chunk =&gt; {\nbody += chunk.toString()\n})\nreq.on('end', () =&gt; {\nconst data = JSON.parse(body)\ndata.timestamp = Date.now()\nreq.body = data\nnext()\n})\nnext() // (1)!\n})\napp.post('/pokemon', (req, res) =&gt; {\nconst { body } = req\n// Procesar body NO ES NECESARIO PARSEAR A JSON\n})\n</code></pre> <ol> <li>\u26a0\ufe0fIMPORTANTE\u26a0\ufe0f, indica que tiene que continuar a la siguiente ruta que le toca</li> </ol> <p>En el ejemplo anterior, creamos un middleware que parsee el cuerpo de una petici\u00f3n a JSON. En este ejemplo, observamos que usamos el m\u00e9todo <code>use()</code> para cualquier ruta y m\u00e9todo. Sin embargo, en su interior solo realiza el parseo si el m\u00e9todo es POST y el tipo de contenido indicado en el header es JSON. Es importante indicar el m\u00e9todo <code>next()</code> para que localice la ruta una vez finaliza el middleware. Una vez finalizado el middleware podemos procesar la petici\u00f3n de una forma m\u00e1s sencilla, ya en formato JSON.</p> <p>Podemos tener tantos middlewares como sea necesarios, y podemos usarlos en los m\u00e9todos y rutas que necesitemos:</p> <pre><code>app.post((res,req, next)=&gt;{\nif (req.headers['content-type'] !== \"application/json\") return next()\nlet body = ''\nreq.on('data', chunk =&gt; {\nbody += chunk.toString()\n})\nreq.on('end', () =&gt; {\nconst data = JSON.parse(body)\ndata.timestamp = Date.now()\nreq.body = data\nnext()\n})\nnext()\n})\n</code></pre> <p>En este ejemplo, hemos creado un middleware para cualquier ruta que realice una petici\u00f3n con m\u00e9todo POST.</p>"},{"location":"tema_3/page-3/#middleware-de-terceros","title":"Middleware de terceros","text":"<p>El uso de middlewares es bastante com\u00fan en el dise\u00f1o de aplicaciones REST API, por lo que existe una gran gama de middleware ya creado que podemos usar sin problema. Express sin ir m\u00e1s lejos, tiene su propio middleware para poder parsear el cuerpo de una petici\u00f3n a JSON. Esto tiene la ventaja de que no es necesario realizar todo lo anterior para poder obtener el cuerpo en formato JSON.</p> <pre><code>app.use(express.json())\napp.post('/pokemon', (req, res) =&gt; {\nconst { body } = req\n// Procesar body NO ES NECESARIO PARSEAR A JSON\n})\n</code></pre>"},{"location":"tema_3/page-3/#seguridad-en-express","title":"Seguridad en Express","text":"<p>Al usar Express, por defecto, se a\u00f1ade una cabecera <code>x-powered-by</code> que indica que estamos usando Express para la creaci\u00f3n de nuestra API. Cierto es, que esto puede suponer un problema de seguridad, por lo que se recomienda su deshabilitaci\u00f3n con el m\u00e9todo <code>disable</code>. El m\u00e9todo deshabilita cualquier cabecera que le indiquemos:</p> <pre><code>app.disable('x-powered-by')\n</code></pre>"},{"location":"tema_3/page-3/#post-vs-patch-vs-put","title":"POST vs PATCH vs PUT","text":"<p>La idempotencia es la propiedad de realizar una acci\u00f3n determinada varias veces y a\u00fan as\u00ed conseguir siempre el mismo resultado que se obtendr\u00eda al realizar una sola vez.</p> <p>Muchas personas no saben diferenciar entre los m\u00e9todos POST, PUT o PATCH, a pesar de que son diferentes entre s\u00ed. A la hora de dise\u00f1ar una API REST es conveniente conocer la diferencia para poder hacer las operaciones necesarias de forma correcta.</p> <p>Con el m\u00e9todo POST creamos un nuevo elemento o recurso en el servidor, adem\u00e1s no es necesario un identificador del elemento a crear. El m\u00e9todo POST no es un m\u00e9todo idempotente ya que cada vez que se ejecuta crea un elemento diferente.</p> <p>El m\u00e9todo PUT sirve para actualizar totalmente un elemento o un recurso, por lo que ser\u00eda necesario tener el identificador del elemento. En caso de que el elemento no exista, lo crea.</p> <p>El m\u00e9todo PATCH sirve para realizar una actualizaci\u00f3n parcial de un elemento o recurso dado su identificador, pero en este caso si no existe el elemento no lo crea.</p> <p>Tanto el m\u00e9todo PUT como el m\u00e9todo PATCH son elementos idempotentes ya que siempre devuelven el mismo resultado cuando se ejecuta. Sin embargo, no lo ser\u00edan en caso de tener una propiedad llamada updateAt que almacene la fecha de actualizaci\u00f3n, entonces no devuelven el mismo resultado en cada ejecuci\u00f3n.</p> <p>Hay que tener en cuenta que siempre que se vaya a crear una nuevo recurso o actualizarlo, ser\u00e1 necesario validar el cuerpo de la petici\u00f3n.</p>"},{"location":"tema_3/page-3/#validaciones","title":"Validaciones","text":"<p>Cuando se realiza una petici\u00f3n de actualizaci\u00f3n o de creaci\u00f3n, es importante validar el cuerpo de dicha petici\u00f3n para que concuerde con la estructura del resto de elementos de la API. Por ejemplo, si tenemos un recurso de estudiantes universitarios se deber\u00eda validar que el campo edad sea un campo num\u00e9rico positivo mayores que 18.</p> <pre><code>app.post('/students', (req, res) =&gt; {\nconst { age } = req.body\nif(!age || typeof age !== \"number\" &amp;&amp; age &lt; 18){\nres.status(400).json({message: \"\"})    }\n})\n</code></pre> <p>Realizar estas validaciones puede ser algo pesado e incluso repetitivo. Hay que tener en cuenta que estos problemas no se solucionar\u00e1n haciendo uso de Typescript.</p> <p>Existen diferentes librer\u00edas que te facilitan dicha tarea. Zod es una de las librer\u00edas m\u00e1s conocidas para dicha tarea:</p> <pre><code>const z = require('zod')\n/*(1)!*/const movieSchema = z.object({ //(2)!\ntitle: z.string({ // (3)!\ninvalid_type_error: 'Movie title must be a string',\nrequired_error: 'Movie title is required'\n}),\nyear: z.number().int().min(1900).max(2024), //(4)!\ndirector: z.string(), // (5)!\nduration: z.number().int().positive(), //(6)!\nrate: z.number().int().min(0).max(10).default(0), //(7)!\nposter: z.string().url({ //(8)!\nmessage: 'Poster must be a valid'\n}),\ngenres: z.enum(['Action', 'Adventure', 'Comedy', 'Drama', 'Fantasy', 'Horror', 'Thriller', 'Sci-Fi', 'Crime']).array({\nrequired_error: 'Movie genre is required',\ninvalid_type_error: 'Movie genre must be an array of enum Genre'\n}) //(9)!\n})\nfunction validateMovie(object) {\nreturn movieSchema.safeParse(object)\n}\napp.post('/students', (req, res) =&gt; {\nconst result = validateMovie(req.body) //(10)!\nif (result.error) { //(11)!\nreturn res.status(400).json({ error: JSON.parse(result.error.message) })\n}\n})\n</code></pre> <ol> <li>Esquema donde se indicar\u00e1 que tipo de elemento se espera.</li> <li>Se indica que el elemento ser\u00e1 de tipo object.</li> <li>Se indica que el titulo debe de ser una cadena. Adem\u00e1s se personaliza los mensajes en caso de que haya un error de tipo o un error de requerimiento.</li> <li>Se indica que el a\u00f1o ha de ser un n\u00famero positivo comprendido entre 1900 y 2024.</li> <li>Se indica que el directo debe ser una cadena.</li> <li>Se indica que la duraci\u00f3n debe ser un n\u00famero positivo.</li> <li>Se indica que la calificaci\u00f3n debe ser un n\u00famero positivo comprendido entre 0 y 10, y en caso de que no se indique su valor por defecto ser\u00e1 0.</li> <li>Se indica que el poster debe ser una cadena con URL y se personaliza el mensaje de error.</li> <li>Se indica que la propiedad g\u00e9nero puede tener un valor comprendido entre los que se encuentra en el enum. Adem\u00e1s se indica que dicha propiedad debe ser un array, por lo que se puede indicar m\u00e1s de uno.</li> <li>Se valida el cuerpo de la petici\u00f3n</li> <li>Se comprueba si existe un error en el resultado de la validaci\u00f3n, y en caso afirmativo se devuelve una respuesta con el mensaje de errorb</li> </ol>"},{"location":"tema_3/page-4/","title":"4 CORS","text":""},{"location":"tema_3/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Cuando se crea un servidor HTTP como podemos hacer con un API REST, y realizamos peticiones a dicho servidor desde otros dominios o servidores, suele ocurrir un error de CORS.</p> <p>Este tipo de error es un error sencillo de manejar pero que mucho desarrolladores obvian e incluso no entienden a la perfecci\u00f3n.</p>"},{"location":"tema_3/page-4/#definicion","title":"Definici\u00f3n","text":"<p>El Cross Origin Resource Sharing (CORS), o bien el cruce de recursos de origen compartido es un mecanismo que te permite que un recurso sea restringido en una p\u00e1gina web para evitar que un origen o un dominio fuera de otro dominio desde que se sirvi\u00f3 ese recurso se pueda acceder a \u00e9l.</p> <p>El navegador recibe la petici\u00f3n del usuario y le pregunta a la API si un dominio que no es el de la propia API puede realizar la petici\u00f3n. Si en la API no se ha configurado ning\u00fan tipo de acceso la API le contesta al navegador que no, por lo que le devuelve al usuario un error de CORS.</p> <p> Figura 5 - ERROR CORS</p>"},{"location":"tema_3/page-4/#dar-permisos-de-control-de-acceso","title":"Dar permisos de Control de Acceso","text":"<p>Para solucionar el problema de CORS debemos modificar la cabecera Access-Control-Allow-Origin. El valor de dicha cabecera se indicar\u00e1 el origen que s\u00ed puede acceder a nuestro dominio:</p> <pre><code>res.header('Access-Control-Allow-Origin', 'tudominio.es')\n</code></pre> <p>Si se desea permitir el acceso desde cualquier dominio se puede indicar con un asterisco (<code>*</code>):</p> <pre><code>res.header('Access-Control-Allow-Origin', '*')\n</code></pre> <p>Hay que tener en cuenta la seguridad a la hora de dar acceso completo a nuestra web, ya que a veces puede ser una operaci\u00f3n peligrosa.</p>"},{"location":"tema_3/page-4/#cabecera-origin","title":"Cabecera Origin","text":"<p>Cuando realizamos una petici\u00f3n podemos comprobar su origen a trav\u00e9s de la cabecera origin. De esta forma podemos filtrar el acceso y comprobar si es un dominio aceptado de una lista de dominios:</p> <pre><code>const ACCEPTED_ORIGINS = [\n'http://localhost:8080',\n'http://localhost:1234',\n'https://movies.com',\n]\napp.get('/movies', (req, res) =&gt; {\nconst origin = req.header('origin')\nif(ACCEPTED_ORIGINS.includes(origin)){\nres.header('Access-Control-Allow-Origin', origin)\n}\n})\n</code></pre> <p>En el ejemplo anterior, tenemos una lista de dominios que si nos interesa que pueda realizar una petici\u00f3n GET, por lo que comprobamos si el origen de la petici\u00f3n coincide con uno de los dominios de la lista. En caso afirmativo, le devolvemos la respuesta con el acceso permitido.</p> <p>Sin embargo, si realizamos la petici\u00f3n desde el mismo dominio que nuestra API, la cabecera origin no s\u00e9 env\u00eda, por lo que se debe controlar. En ese caso, si la cabecera origin no est\u00e1 definida, podemos entender que estamos hablando de nuestro mismo dominio:</p> <pre><code>const ACCEPTED_ORIGINS = [\n'http://localhost:8080',\n'http://localhost:1234',\n'https://movies.com',\n]\napp.get('/movies', (req, res) =&gt; {\nconst origin = req.header('origin')\nif(ACCEPTED_ORIGINS.includes(origin) || !origin){\nres.header('Access-Control-Allow-Origin', origin)\n}\n})\n</code></pre>"},{"location":"tema_3/page-4/#cors-como-middleware","title":"CORS como middleware","text":"<p>El control del acceso a nuestro servidor desde otros dominios se puede manejar en cualquier petici\u00f3n que se realice. Por ejemplo, podemos restringir el acceso solo a todos los dominios que realicen una petici\u00f3n POST desde cualquier recurso, o desde un recurso espec\u00edfico.</p> <p>Tambi\u00e9n se puede usar como middleware, de tal forma que controlemos el acceso para cualquier petici\u00f3n en cualquier m\u00e9todo:</p> <pre><code>const ACCEPTED_ORIGINS = [\n'http://localhost:8080',\n'http://localhost:1234',\n'https://movies.com',\n'https://midu.dev'\n]\napp.use((req, res, next) =&gt; {\nconst origin = req.header('origin')\nif(ACCEPTED_ORIGINS.includes(origin) || !origin){\nres.header('Access-Control-Allow-Origin', origin)\n}\nnext()\n})\n</code></pre>"},{"location":"tema_3/page-4/#peticiones-pre-flight","title":"Peticiones PRE-Flight","text":"<p>Cuando el usuario realiza una petici\u00f3n a nuestra API, hay algunos m\u00e9todos que requieren un m\u00e9todo previo y especial, si ese m\u00e9todo devuelve un OK se ejecutar\u00e1 el m\u00e9todo solicitado. Este proceso se conoce com\u00fanmente como CORS PRE-Flight, y se debe controlar el CORS tanto en la petici\u00f3n compleja como en la especial.  </p> <p>Los m\u00e9todos normales son: HEAD, GET y POST, y por lo tanto solo se validar\u00eda el CORS en dichos m\u00e9todos. Los m\u00e9todos complejos son PUT, PATCH y DELETE, mientras que el m\u00e9todo especial e intermedio es OPTIONS. por lo que se deber\u00eda validar el CORS tanto en dichos m\u00e9todos como en el m\u00e9todo OPTIONS.</p> <pre><code>app.delete('/movies/:id', (req, res) =&gt; {\nconst origin = req.header('origin')\nif (ACCEPTED_ORIGINS.includes(origin) || !origin) {\nres.header('Access-Control-Allow-Origin', origin)\n}\n// ...\n})\n</code></pre> <p>En el ejemplo anterior, comprobamos el origen de la petici\u00f3n, pero en este caso aunque sea un origen aceptado, nos lanzar\u00e1 un error de CORS, ya que antes de la petici\u00f3n DELETE realiza una petici\u00f3n previa OPTIONS, y al no ser controlada la CORS en dicha petici\u00f3n recibiremos igualmente un error de cORS. Para solucionar dicho problema ser\u00e1 necesario comprobarlo en dicho m\u00e9todo:</p> <pre><code>app.delete('/movies/:id', (req, res) =&gt; {\nconst origin = req.header('origin')\nif (ACCEPTED_ORIGINS.includes(origin) || !origin) {\nres.header('Access-Control-Allow-Origin', origin)\n}\n// ...\n})\napp.options('/movies/:id', (req, res) =&gt; {\nconst origin = req.header('origin')\nif (ACCEPTED_ORIGINS.includes(origin) || !origin) {\nres.header('Access-Control-Allow-Origin', origin)\nres.header('Access-Control-Allow-Methods', 'GET, POST, PATCH, DELETE')\n}\nres.send(200)\n})\n</code></pre>"},{"location":"tema_3/page-5/","title":"Proyecto","text":"<p>Se desea crear una API siguiendo la arquitectura REST para almacenar y mostrar las pel\u00edculas y colecciones de una famosa plataforma de streaming. Se considera como una colecci\u00f3n a aquel elemento que dicta caracter\u00edsticas comunes de una serie de pel\u00edculas. Por ejemplo, la colecci\u00f3n Star Wars Collection es una colecci\u00f3n para el universo de pel\u00edculas de Star Wars. Hay que tener en cuenta que una pel\u00edcula no tiene porque pertenecer a una colecci\u00f3n, y que una colecci\u00f3n puede que no tenga ninguna pel\u00edcula de momento.</p> <p>Las operaciones que se pueden realizar sobre la API son las siguientes:</p> <ul> <li>Obtener todas las pel\u00edculas, mostrando el nombre de la colecci\u00f3n.</li> <li>Obtener todas las pel\u00edculas ordenadas por el campo que indique el usuario.</li> <li>Obtener todas las pel\u00edculas filtradas por g\u00e9nero.</li> <li>Obtener todas las pel\u00edculas filtradas por a\u00f1o.</li> <li>Obtener todas las pel\u00edculas filtradas por colecci\u00f3n.</li> <li>Obtener todas las colecciones incluidas las pel\u00edculas que pertenecen a dicha colecci\u00f3n.</li> <li>Obtener una colecci\u00f3n o una pel\u00edcula dado su identificador</li> <li>Poder subir una pel\u00edcula o una colecci\u00f3n.</li> <li>Poder actualizar de forma parcial y de forma completa una pel\u00edcula y una colecci\u00f3n, teniendo en cuenta de que si no existe, debe mostrar un error en el parcial o crearla en el completo.</li> <li>Eliminar una pel\u00edcula por su nombre o su identificador.</li> <li>Eliminar varias pel\u00edculas por g\u00e9nero.</li> <li>Eliminar una colecci\u00f3n.</li> </ul> <p>Los datos previos de la API son los siguientes:</p> MOVIESCollections <pre><code>[\n{\n\"id\": \"dcdd0fad-a94c-4810-8acc-5f108d3b18c3\",\n\"title\": \"The Shawshank Redemption\",\n\"year\": 1994,\n\"director\": \"Frank Darabont\",\n\"duration\": 142,\n\"poster\": \"https://i.ebayimg.com/images/g/4goAAOSwMyBe7hnQ/s-l1200.webp\",\n\"genre\": [\n\"Drama\"\n],\n\"rate\": 9.3\n},\n{\n\"id\": \"c8a7d63f-3b04-44d3-9d95-8782fd7dcfaf\",\n\"title\": \"The Dark Knight\",\n\"year\": 2008,\n\"director\": \"Christopher Nolan\",\n\"duration\": 152,\n\"poster\": \"https://i.ebayimg.com/images/g/yokAAOSw8w1YARbm/s-l1200.jpg\",\n\"genre\": [\n\"Action\",\n\"Crime\",\n\"Drama\"\n],\n\"rate\": 9.0,\n\"collection\": 1\n},\n{\n\"id\": \"5ad1a235-0d9c-410a-b32b-220d91689a08\",\n\"title\": \"Inception\",\n\"year\": 2010,\n\"director\": \"Christopher Nolan\",\n\"duration\": 148,\n\"poster\": \"https://m.media-amazon.com/images/I/91Rc8cAmnAL._AC_UF1000,1000_QL80_.jpg\",\n\"genre\": [\n\"Action\",\n\"Adventure\",\n\"Sci-Fi\"\n],\n\"rate\": 8.8\n},\n{\n\"id\": \"241bf55d-b649-4109-af7c-0e6890ded3fc\",\n\"title\": \"Pulp Fiction\",\n\"year\": 1994,\n\"director\": \"Quentin Tarantino\",\n\"duration\": 154,\n\"poster\": \"https://www.themoviedb.org/t/p/original/vQWk5YBFWF4bZaofAbv0tShwBvQ.jpg\",\n\"genre\": [\n\"Crime\",\n\"Drama\"\n],\n\"rate\": 8.9\n},\n{\n\"id\": \"9e6106f0-848b-4810-a11a-3d832a5610f9\",\n\"title\": \"Forrest Gump\",\n\"year\": 1994,\n\"director\": \"Robert Zemeckis\",\n\"duration\": 142,\n\"poster\": \"https://i.ebayimg.com/images/g/qR8AAOSwkvRZzuMD/s-l1600.jpg\",\n\"genre\": [\n\"Drama\",\n\"Romance\"\n],\n\"rate\": 8.8\n},\n{\n\"id\": \"7e3fd5ab-60ff-4ae2-92b6-9597f0308d1\",\n\"title\": \"Gladiator\",\n\"year\": 2000,\n\"director\": \"Ridley Scott\",\n\"duration\": 155,\n\"poster\": \"https://img.fruugo.com/product/0/60/14417600_max.jpg\",\n\"genre\": [\n\"Action\",\n\"Adventure\",\n\"Drama\"\n],\n\"rate\": 8.5\n},\n{\n\"id\": \"c906673b-3948-4402-ac7f-73ac3a9e3105\",\n\"title\": \"The Matrix\",\n\"year\": 1999,\n\"director\": \"Lana Wachowski\",\n\"duration\": 136,\n\"poster\": \"https://i.ebayimg.com/images/g/QFQAAOSwAQpfjaA6/s-l1200.jpg\",\n\"genre\": [\n\"Action\",\n\"Sci-Fi\"\n],\n\"rate\": 8.7\n},\n{\n\"id\": \"b6e03689-cccd-478e-8565-d92f40813b13\",\n\"title\": \"Interstellar\",\n\"year\": 2014,\n\"director\": \"Christopher Nolan\",\n\"duration\": 169,\n\"poster\": \"https://m.media-amazon.com/images/I/91obuWzA3XL._AC_UF1000,1000_QL80_.jpg\",\n\"genre\": [\n\"Adventure\",\n\"Drama\",\n\"Sci-Fi\"\n],\n\"rate\": 8.6\n},\n{\n\"id\": \"aa391090-b938-42eb-b520-86ea0aa3917b\",\n\"title\": \"The Lord of the Rings: The Return of the King\",\n\"year\": 2003,\n\"director\": \"Peter Jackson\",\n\"duration\": 201,\n\"poster\": \"https://i.ebayimg.com/images/g/0hoAAOSwe7peaMLW/s-l1600.jpg\",\n\"genre\": [\n\"Action\",\n\"Adventure\",\n\"Drama\"\n],\n\"rate\": 8.9,\n\"collection\": 2\n},\n{\n\"id\": \"2e6900e2-0b48-4fb6-ad48-09c7086e54fe\",\n\"title\": \"The Lion King\",\n\"year\": 1994,\n\"director\": \"Roger Allers, Rob Minkoff\",\n\"duration\": 88,\n\"poster\": \"https://m.media-amazon.com/images/I/81BMmrwSFOL._AC_UF1000,1000_QL80_.jpg\",\n\"genre\": [\n\"Animation\",\n\"Adventure\",\n\"Drama\"\n],\n\"rate\": 8.5,\n\"collection\": 3\n},\n{\n\"id\": \"04986507-b3ed-442c-8ae7-4c5df804f896\",\n\"title\": \"The Avengers\",\n\"year\": 2012,\n\"director\": \"Joss Whedon\",\n\"duration\": 143,\n\"poster\": \"https://img.fruugo.com/product/7/41/14532417_max.jpg\",\n\"genre\": [\n\"Action\",\n\"Adventure\",\n\"Sci-Fi\"\n],\n\"rate\": 8.0,\n\"collection\": 4\n},\n{\n\"id\": \"7d2832f8-c70a-410e-8963-4c93bf36cc9c\",\n\"title\": \"Jurassic Park\",\n\"year\": 1993,\n\"director\": \"Steven Spielberg\",\n\"duration\": 127,\n\"poster\": \"https://vice-press.com/cdn/shop/products/Jurassic-Park-Editions-poster-florey.jpg?v=1654518755&amp;width=1024\",\n\"genre\": [\n\"Adventure\",\n\"Sci-Fi\"\n],\n\"rate\": 8.1,\n\"collection\": 5\n},\n{\n\"id\": \"ccf36f2e-8566-47f7-912d-9f4647250bc7\",\n\"title\": \"Titanic\",\n\"year\": 1997,\n\"director\": \"James Cameron\",\n\"duration\": 195,\n\"poster\": \"https://i.pinimg.com/originals/42/42/65/4242658e6f1b0d6322a4a93e0383108b.png\",\n\"genre\": [\n\"Drama\",\n\"Romance\"\n],\n\"rate\": 7.8,\n\"collection\": 6\n},\n{\n\"id\": \"8fb17ae1-bdfe-45e5-a871-4772d7e526b8\",\n\"title\": \"The Social Network\",\n\"year\": 2010,\n\"director\": \"David Fincher\",\n\"duration\": 120,\n\"poster\": \"https://i.pinimg.com/originals/7e/37/b9/7e37b994b613e94cba64f307b1983e39.jpg\",\n\"genre\": [\n\"Biography\",\n\"Drama\"\n],\n\"rate\": 7.7\n},\n{\n\"id\": \"6a360a18-c645-4b47-9a7b-2a71babbf3e0\",\n\"title\": \"Avatar\",\n\"year\": 2009,\n\"director\": \"James Cameron\",\n\"duration\": 162,\n\"poster\": \"https://i.etsystatic.com/35681979/r/il/dfe3ba/3957859451/il_fullxfull.3957859451_h27r.jpg\",\n\"genre\": [\n\"Action\",\n\"Adventure\",\n\"Fantasy\"\n],\n\"rate\": 7.8,\n\"collection\": 6\n}\n]\n</code></pre> <pre><code>[\n{\n\"id\": 1,\n\"title\": \"DC\"\n},\n{\n\"id\": 2,\n\"title\": \"The Lord of the Rings\"\n},\n{\n\"id\": 3,\n\"title\": \"Disney\"\n},\n{\n\"id\": 4,\n\"title\": \"Marvel\"\n},\n{\n\"id\": 5,\n\"title\": \"Jurassic\"\n},\n{\n\"id\": 6,\n\"title\": \"James Cameron\"\n}\n]\n</code></pre>"},{"location":"tema_4/page-1/","title":"1 Arquitecturas","text":""},{"location":"tema_4/page-1/#migracion-de-un-proyecto","title":"Migraci\u00f3n de un proyecto","text":"<p>Hasta hora en los proyectos realizados se ha utiliza el commonJS. Tal y como se vio en el Tema 1 existe dos formas de utilizar los m\u00f3dulos en Javascript, commonJS, la versi\u00f3n antigua ;y ESModules la versi\u00f3n actual.</p> <p>Para poder crear o migrar un proyecto de Node haciendo uso del ESModules, debemos indicarlo en el package.json. El atributo type por defecto esta en commonJS, si queremos que acepte los archivos javascript como ESModules, debemos indicar dicho atributo como modules:</p> <pre><code>{\n\"name\": \"api-rest-with-express\",\n\"version\": \"1.0.0\",\n\"description\": \"Api REST with Express\",\n\"main\": \"index.js\",\n\"type\": \"module\",\n\"scripts\": {\n\"dev\": \"node --watch app.js\",\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"author\": \"irudev\",\n\"license\": \"ISC\",\n\"dependencies\": {\n\"cors\": \"2.8.5\",\n\"express\": \"4.18.2\",\n\"zod\": \"3.22.4\"\n}\n}\n</code></pre> <p>Una vez realizado este paso, debemos importar las librer\u00edas haciendo uso de la estructura <code>import a from path</code> donde <code>a</code> son los elementos que se importan del <code>path</code>. Observa en el siguiente ejemplo a comparaci\u00f3n de <code>require</code>:</p> ESModulesCommonJS <pre><code>import fs from 'node:fs'\nimport {validateObject} from './validate.js'\n</code></pre> <pre><code>const fs = require('node:fs')\nconst {validateObject} = require('./validate')\n</code></pre> <p>\u00a1Cuidado!</p> <p>Cuando se usa commonJS no es obligatorio indicar la extensi\u00f3n, ya que Node internamente va probando cada una de las posibilidades existentes. Pero, a la hora de realizar la importaci\u00f3n ESModules, es obligatorio indicar la extensi\u00f3n ya que ESModule no realiza las comprobaciones.</p> <p>Cuando se desea importar como un archivo, como ocurre con un JSON hay que indicar el tipo de archivo, adem\u00e1s de su extensi\u00f3n:</p> <pre><code>import movies from './movies.json' assert {type: 'json'}\n</code></pre> <p>El problema de dicha importaci\u00f3n es que no hay un versi\u00f3n estable y probablemente no la haya. Por lo que, hay una nueva indicaci\u00f3n <code>with</code>la cual a\u00fan no est\u00e1 disponible pero s\u00ed ser\u00e1 estable:</p> <pre><code>import movies from './movies.json' with {type: 'json'}\n</code></pre> <p>Mientras tanto, para poder leer un JSON en Node se podr\u00eda hacer de dos maneras</p> <ul> <li> <p>Haciendo uso del m\u00f3dulo <code>fs</code> y su m\u00e9todo <code>readFileSync</code>:</p> <pre><code>const movies = JSON.parse(fs.readFileSync('./movies.json', 'uft-8'))\n</code></pre> </li> <li> <p>Creando nuestro propio <code>require</code>. El <code>require</code> usado en commonJS es una funci\u00f3n que recibe el path de la librer\u00eda, por lo que aunque no podamos usar el <code>require</code> de commonJS podemos crear el nuestro propio para recibir el una path compatible con ESModule, haciendo uso del m\u00e9todo <code>createRequire</code> del m\u00f3dulo nativo <code>module</code> de Node:</p> <pre><code>import {createRequire} from 'node:module'\nconst require = createRequire(import.meta.url)\nconst movies = require('./movies.json')\n</code></pre> <p>Incluso dicha creaci\u00f3n puede ser exportado y reutilizado en cualquier archivo javascript de nuestro proyecto.</p> </li> </ul>"},{"location":"tema_4/page-1/#arquitecturas-de-un-proyecto","title":"Arquitecturas de un proyecto","text":"<p>Cuando creamos un proyecto es conveniente estructurar nuestro proyecto de manera que podamos separar conceptos. Esto consigue que nuestro proyecto sea m\u00e1s eficiente y escalable.</p> <p>Una arquitectura est\u00e1ndar para un proyecto en Node, que hayamos podido realizar hasta ahora,  podr\u00eda ser la siguiente:</p> <pre><code>project/\n    |_ node_modules/\n    |_ src/\n        |_ middlewares/\n        |_ utils/\n        |_ schemas/\n</code></pre> <p>La estructura anterior define una carpeta para nuestros middlewares, que contendr\u00e1 los middlewares que usemos en nuestra aplicaci\u00f3n, utils que contendr\u00e1 los archivos javascript que sirvan de utilidad, y schemas que define los schemas de los tipos de datos a usar.</p>"},{"location":"tema_4/page-1/#patrones-de-arquitectura-y-de-diseno","title":"Patrones de arquitectura y de dise\u00f1o","text":"<p>Un patr\u00f3n de arquitectura es una soluci\u00f3n a un problema com\u00fan de dise\u00f1o de software que es reutilizable. Los patrones de arquitectura se centran en el nivel m\u00e1s alto de abstracci\u00f3n del dise\u00f1o de software, proporcionando una visi\u00f3n general de c\u00f3mo se relacionan los componentes de un sistema.</p> <p>Algunos ejemplos de patrones de arquitectura incluyen:</p> <ul> <li>Arquitectura cliente-servidor: Este patr\u00f3n divide un sistema en dos componentes principales: un cliente que solicita servicios a un servidor.</li> <li>Arquitectura de tres capas: Este patr\u00f3n divide un sistema en tres capas: presentaci\u00f3n, l\u00f3gica de negocio y datos.</li> <li>Arquitectura orientada a servicios: Este patr\u00f3n divide un sistema en un conjunto de servicios independientes que pueden comunicarse entre s\u00ed.</li> </ul> <p>Un patr\u00f3n de dise\u00f1o es una soluci\u00f3n a un problema com\u00fan de implementaci\u00f3n de software que es reutilizable. Los patrones de dise\u00f1o se centran en el nivel de abstracci\u00f3n m\u00e1s bajo del dise\u00f1o de software, proporcionando detalles sobre c\u00f3mo implementar un componente o subsistema de un sistema.</p> <p>Algunos ejemplos de patrones de dise\u00f1o incluyen:</p> <ul> <li>Patr\u00f3n singleton: Este patr\u00f3n asegura que solo exista una instancia de una clase en un momento dado.</li> <li>Patr\u00f3n decorador: Este patr\u00f3n permite agregar funcionalidad a un objeto sin modificar su c\u00f3digo.</li> <li>Patr\u00f3n adaptador: Este patr\u00f3n permite que dos clases incompatibles se comuniquen entre s\u00ed.</li> </ul> <p>La principal diferencia entre patrones de arquitectura y patrones de dise\u00f1o es el nivel de abstracci\u00f3n en el que operan. Los patrones de arquitectura se centran en el nivel m\u00e1s alto de abstracci\u00f3n, proporcionando una visi\u00f3n general de c\u00f3mo se relacionan los componentes de un sistema. Los patrones de dise\u00f1o, por otro lado, se centran en el nivel de abstracci\u00f3n m\u00e1s bajo, proporcionando detalles sobre c\u00f3mo implementar un componente o subsistema de un sistema.</p> <p>Otra diferencia entre patrones de arquitectura y patrones de dise\u00f1o es su alcance. Los patrones de arquitectura suelen ser aplicables a una amplia gama de sistemas, mientras que los patrones de dise\u00f1o suelen ser m\u00e1s espec\u00edficos para un tipo particular de sistema o aplicaci\u00f3n.</p> <p>Finalmente, los patrones de arquitectura suelen ser m\u00e1s dif\u00edciles de aplicar que los patrones de dise\u00f1o. Esto se debe a que los patrones de arquitectura suelen implicar cambios en la estructura de un sistema, mientras que los patrones de dise\u00f1o suelen implicar cambios en la implementaci\u00f3n de un componente o subsistema.</p>"},{"location":"tema_4/page-2/","title":"2 El patr\u00f3n MVC","text":""},{"location":"tema_4/page-2/#rutas","title":"Rutas","text":"<p>Cuando se dise\u00f1a una API REST y tenemos muchos endpoints con diferentes m\u00e9todos nuestra archivo javascript se vuelve engorroso y bastante pesado y dif\u00edcil de leer, por lo que Express nos permite trabajar con diferentes rutas.</p> <p>Una ruta se considera un acceso a nuestro recurso para poder hacer las diferentes tipos de operaciones a trav\u00e9s de los m\u00e9todos. Para crear una ruta se usa el m\u00e9todo <code>Router()</code> de Express, luego haciendo uso de los m\u00e9todos podemos realizar las operaciones necesarias:</p> <pre><code>const movieRouter = Router()\nmovieRouter.get('/', (req, res) =&gt; {\n})\nmovieRouter.get('/:id', (req, res) =&gt; {\n})\nmovieRouter.post('/', (req, res) =&gt; {\n})\nmovieRouter.patch('/:id', (req, res) =&gt; {\n})\nmovieRouter.delete('/:id', (req, res) =&gt; {\n})\nexport default movieRouter\n</code></pre> <p>Una vez creada la ruta, debemos indicar a nuestra app que cada vez que se realice una petici\u00f3n a <code>/movies</code> acceda a la ruta creada:</p> <pre><code>app.use('/movies', moviesRouter)\n</code></pre> <p>Hacemos uso del m\u00e9todo <code>use</code> de nuestra app porque va a utilizar la ruta para cualquiera de los m\u00e9todos de la petici\u00f3n.</p> <p>Sugerencia</p> <p>Se recomienda que las rutas se separen y se introduzcan en una carpeta, que se llame por ejemplo routes.</p>"},{"location":"tema_4/page-2/#patron-mvc","title":"Patr\u00f3n MVC","text":"<p>El patr\u00f3n MVC (Modelo-Vista-Controlador) es un patr\u00f3n  que separa los datos, la l\u00f3gica de negocio y la interfaz de usuario de una aplicaci\u00f3n. Este patr\u00f3n ayuda a mejorar la modularidad, la mantenibilidad y la escalabilidad de las aplicaciones.</p> <p>El patr\u00f3n MVC consta de tres componentes principales:</p> <ul> <li>Modelo: Representa los datos de una aplicaci\u00f3n.</li> <li>Vista: Representa la interfaz de usuario de una aplicaci\u00f3n.</li> <li>Controlador: Se encarga de gestionar las interacciones entre el modelo y la vista.</li> </ul> <p>La siguiente figura ilustra la relaci\u00f3n entre los tres componentes del patr\u00f3n MVC:</p> <p> Figura 1 - Patr\u00f3n MVC</p> <p>El patr\u00f3n MVC ofrece una serie de ventajas, entre las que se incluyen:</p> <ul> <li>Mejora la modularidad: El patr\u00f3n MVC separa los datos, la l\u00f3gica de negocio y la interfaz de usuario en componentes independientes. Esto facilita la reutilizaci\u00f3n de los componentes y la modificaci\u00f3n de la aplicaci\u00f3n sin afectar a otros componentes.</li> <li>Mejora la mantenibilidad: El patr\u00f3n MVC facilita la localizaci\u00f3n de los errores y la realizaci\u00f3n de cambios en la aplicaci\u00f3n.</li> <li>Mejora la escalabilidad: El patr\u00f3n MVC facilita la adici\u00f3n de nuevas caracter\u00edsticas y el aumento de la capacidad de la aplicaci\u00f3n.</li> </ul> <p>El patr\u00f3n MVC se puede considerar tanto como patr\u00f3n de dise\u00f1o como de arquitectura. Los programadores no se poden de acuerdo en c\u00f3mo clasificarlo.</p>"},{"location":"tema_4/page-2/#modelo","title":"Modelo","text":"<p>El modelo es la parte del patr\u00f3n que se encarga de la parte l\u00f3gica del negocio. Se encarga de comunicar directamente con la base de datos en caso de que lo haya.</p> <pre><code>export class MovieModel {\nstatic async getAll({ genre }) {\nif (genre) {\nconst filteredMovies = movies.filter(movie =&gt; movie.genre.some(g =&gt; g.toLowerCase() === genre.toLowerCase()))\nreturn filteredMovies\n}\nreturn movies\n}\nstatic async getById({ id }) {\nreturn movies.find(movie =&gt; movie.id === id)\n}\nstatic async create({ input }) {\nconst newMovie = {\nid: randomUUID(),\n...input\n}\nmovies.push(newMovie)\nreturn newMovie\n}\nstatic async delete({ id }) {\nconst movieIndex = movies.findIndex(movie =&gt; movie.id === id)\nif (movieIndex === -1) return false\nmovies.slice(movieIndex, 1)\nreturn true\n}\nstatic async update({ id, input }) {\nconst movieIndex = movies.findIndex(movie =&gt; movie.id === id)\nif (movieIndex === -1) return false\nmovies[movieIndex] = {\n...movies[movieIndex],\n...input\n}\nreturn movies[movieIndex]\n}\n}\n</code></pre>"},{"location":"tema_4/page-2/#controlador","title":"Controlador","text":"<p>El controlador es la parte del patr\u00f3n que se encarga de hacer la comunicaci\u00f3n entre el modelo y la vista. Se encarga de realizar las peticiones al modelo y mostrarle a la vista los diferentes datos:</p> <pre><code>export class MoviesController {\nstatic async getAll(req, res) {\nconst { genre } = req.query\nconst movies = await MovieModel.getAll({ genre })\nres.send(movies)\n}\nstatic async getById(req, res) {\nconst { id } = req.params\nconst movie = await MovieModel.getById({ id })\nif (movie) return res.json(movie)\nres.status(404).json({ message: 'Movie not found' })\n}\nstatic async create(req, res) {\nconst result = validateMovie(req.body)\nif (result.error) {\nreturn res.status(400).json({ error: JSON.parse(result.error.message) })\n}\nconst newMovie = await MovieModel.create({ input: result.data })\nres.status(201).json(newMovie) // actualizar la cach\u00e9 del cliente\n}\nstatic async delete(req, res) {\nconst { id } = req.params\nconst result = await MovieModel.delete({ id })\nif (result === false) {\nreturn res.status(404).json({ message: 'Movie not found' })\n}\nreturn res.json({ message: 'Movie deleted' })\n}\nstatic async update(req, res) {\nconst { id } = req.params\nconst result = validatePartialMovie(req.body)\nif (!result.success) {\nreturn res.status(400).json({ error: JSON.parse(result.error.message) })\n}\nif (movieIndex === -1) {\nreturn res.status(404).json({ message: 'Movie not found' })\n}\nconst updateMovie = await MovieModel.update({ id, input: result.data })\nreturn res.json(updateMovie)\n}\n}\n</code></pre>"},{"location":"tema_4/page-2/#vista","title":"Vista","text":"<p>La vista es la parte del patr\u00f3n que se encarga de interactuar con el usuario. Desde aqu\u00ed, el usuario solicita peticiones que son procesadas por el controlador que devuelve el resultado a la vista para trabajar con ellas. Un buen ejemplo de una vista, puede ser un formulario para a\u00f1adir los datos a una base de datos.</p>"},{"location":"tema_4/page-2/#validaciones","title":"Validaciones","text":"<p>Cuando se trata de validaciones se recomienda que se realicen en las tres capas de la aplicaci\u00f3n, aunque no las mismas validaciones si no las validaciones que corresponda en cada caso.</p> <p>En el modelo se deber\u00eda validar las partes relacionadas con la seguridad y la base de datos. Mientras que en el controlador se deber\u00eda comprobar si la estructura de los datos es correcta y en la vista se deber\u00eda validar si los campos son requeridos y otras cosas como su rango de valores, etc.</p> <p>Hacerlo as\u00ed, requiere que ciertas peticiones lleguen limpias a su capa correspondiente y no tarden en ser validadas.</p>"},{"location":"tema_4/page-3/","title":"3 Conexi\u00f3n a base de datos NoSQL","text":""},{"location":"tema_4/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Podemos crear una API en Node JS donde la conexi\u00f3n se realice a trav\u00e9s de una base de datos NoSQL. Un base de datos NoSQL es una base de datos no relacional, por la estructura de los datos es m \u00e1s flexible y podemos tener datos con diferentes campos.</p> <p>Un ejemplo de base de datos NoSQL ser\u00eda MongoDB, el cu\u00e1l puedes ver sus apuntes para entender bastante mejor. Hay que tener en cuenta que este tipo de base de datos son demasiado flexibles por lo que no tiene un esquema definido y fijo como si pasa con las bases de datos MySQL.</p>"},{"location":"tema_4/page-3/#paquete-mongodb","title":"Paquete mongodb","text":"<p>Para poder usar MongoDB en un proyecto de Node JS es necesario tener un driver para manager la conexi\u00f3n y las transacciones. El driver oficial es <code>mongodb</code> y se puede instalar haciendo uso de npm:</p> <pre><code>npm install mongodb\n</code></pre> <p>Ahora podemos configurar nuestro proyecto  con mongoDB, creando una conexi\u00f3n con nuestra base de datos. Para poder realizar nuestra conexi\u00f3n necesitamos crear un objeto cliente:</p> <pre><code>const client = new MongoClient(uri, {\nserverApi: {\nversion: ServerApiVersion.v1,\nstrict: true,\ndeprecationErrors: true\n}\n})\n</code></pre> <p>Una vez creado el cliente, necesitamos un m\u00e9todo para que realice las conexiones, si algo fallo cerrar\u00e1 la conexi\u00f3n con el cliente:</p> <pre><code>async function connect() {\ntry {\nawait client.connect()\nconst database = client.db('database')\nreturn database.collection('movies')\n} catch (error) {\nconsole.error('Error connecting to the database')\nconsole.error(error)\nawait client.close()\n}\n}\n</code></pre>"},{"location":"tema_4/page-3/#consulta-de-datos","title":"Consulta de datos","text":"<p>Podemos consultar todos los datos de una colecci\u00f3n e incluso filtrarlos, gracias al m\u00e9todo <code>find</code>.</p> <p>Info</p> <p>Casi todo los m\u00e9todos de estos drivers son bastante parecidos al funcionamiento de dichas funciones dentro del servidor de mongoDB, por lo que si quieres conocer m\u00e1s su funcionamiento visita la p\u00e1gina oficial de MongoDB, o nuestro temario de MongoDB</p> <pre><code>static async getAll({ genre }) {\nconst db = await connect()\nif (genre) {\nreturn db.find({\ngenre: {\n$elemMatch: {\n$regex: genre,\n$options: 'i'\n}\n}\n}).toArray()\n}\nreturn db.find({}).toArray()\n}\n</code></pre>"},{"location":"tema_4/page-3/#objectid","title":"ObjectId","text":"<p>En MongoDB, al insertar un nuevo dato, mongo te crea un ID de forma autom\u00e1tica. Este identificador es de tipo <code>ObjectId</code> por lo que si nosotros deseamos realizar una b\u00fasqueda de un elemento de forma directa no podemos hacer la comparaci\u00f3n en cadena si no como un objeto de tipo <code>ObjectId</code>. El driver de mongodb dispone de una clase <code>ObjectId</code> que nos permite crear objetos de dicho tipo a trav\u00e9s de un valor pasado por par\u00e1metro:</p> <pre><code>static async getById({ id }) {\nconst db = await connect()\nconst objectId = new ObjectId(id)\nreturn db.findOne({ _id: objectId })\n}\n</code></pre>"},{"location":"tema_4/page-3/#crear-un-elemento","title":"Crear un elemento","text":"<p>Para crear un elemento, podemos usar el m\u00e9todo <code>insertOne</code> que recibe el objeto que quiere crear. Dicho m\u00e9todo te devuelve el objeto creado, incluido el id auto-creado, por lo que podemos devolver el objeto completo para que mostr\u00e1rselo al usuario que ha realizado la petici\u00f3n a nuestra API:</p> <pre><code>static async create({ input }) {\nconst db = await connect()\nconst { insertedId } = await db.insertOne(input)\nreturn {\nid: insertedId,\n...input\n}\n}\n</code></pre>"},{"location":"tema_4/page-3/#actualizar-y-eliminar-elementos","title":"Actualizar y eliminar elementos","text":"<p>Para actualizar y eliminar un elemento de la base de datos mongodb, podemos usar los m\u00e9todos <code>deleteOne</code> y <code>findOneAndUpdate</code>, respectivamente. En el caso de eliminar necesitaremos el id del objeto a eliminar, y en el caso de actualizar su id, los cambios a realizar. Adem\u00e1s podemos tener una opci\u00f3n de que se devuelva el nuevo documento creado a la hora de actualizar y de esta forma comprobar que la actualizaci\u00f3n se ha hecho de forma correcta y as\u00ed hac\u00e9rselo saber al usuario.</p> <p>Al eliminar nos devuelve un objeto con el n\u00famero de elementos eliminador, por lo que podemos usar dicho n\u00famero para comprobar si la eliminaci\u00f3n se ha realizado correctamente.</p> <pre><code>static async delete({ id }) {\nconst db = await connect()\nconst objectId = new ObjectId(id)\nconst { deletedCount } = await db.deleteOne({ _id: objectId })\nreturn deletedCount &gt; 0\n}\nstatic async update({ id, input }) {\nconst db = await connect()\nconst objectId = new ObjectId(id)\nconst { ok, value } = await db.findOneAndUpdate({ _id: objectId }, { $set: input }, { returnNewDocument: true })\nif (!ok) return false\nreturn value\n}\n</code></pre>"},{"location":"tema_4/page-4/","title":"4 mongoose","text":""},{"location":"tema_4/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p><code>mongoose</code> es una librer\u00eda para javascript que nos permite trabajar con conexiones a una base de datos de forma m\u00e1s eficiente y sencilla que el driver nativo. Adem\u00e1s, te permite crear esquemas para dicha base de datos lo que te facilita el hecho de salvaguardar la informaci\u00f3n. Podemos instalar dicha librer\u00eda con npm:</p> <pre><code>npm install mongoose\n</code></pre>"},{"location":"tema_4/page-4/#conexion-a-mongodb","title":"Conexi\u00f3n a MongoDB","text":"<p>Para realizar una conexi\u00f3n a MongoDB se una el m\u00e9todo <code>connect(uri, options)</code> que recibe la url de la conexi\u00f3n y opciones del cliente.</p> <pre><code>\n</code></pre>"},{"location":"tema_4/page-4/#esquemas","title":"Esquemas","text":"<p>Una de las mayores ventajas a la usa mongoose, es que nos permite crear esquemas de los elementos que vamos almacenar. En cada esquema, debemos indicar el nombre de la propiedad as\u00ed como su tipo:</p> <pre><code>new mongoose.Schema({\ntitle: String\n})\n</code></pre> <p>Tambi\u00e9n se puede indicar el tipo a trav\u00e9s de un objeto con las opciones referidas a esa propiedad, para poder a\u00f1adirle m\u00e1s opciones a parte del tipo, como por ejemplo, su valor por defecto:</p> <pre><code>new mongoose.Schema({\ntitle: {type: String, default: ''}\n})\n</code></pre> <p>\u00a1Importante!</p> <p>Los esquemas son a nivel de aplicaci\u00f3n, pero si se desea realizar una operaci\u00f3n en otro back-end, se deber\u00e1 volver a definir. Incluso, si se realiza operaciones desde el mismo servidor de MongoDB, no tiene porque cumplir el esquema y puedo tener propiedades de diferentes tipos.</p>"},{"location":"tema_4/page-4/#opciones-para-todos-los-tipos","title":"Opciones para todos los tipos","text":"<p>Podemos encontrar diferentes tipos de opciones para usar en nuestros esquemas:</p> <ul> <li>required: Hace que la propiedad sea requerida. Puede ser de tipo booleano, o de una funci\u00f3n que devuelva un booleano.</li> <li>default: Indica un valor por defecto para la propiedad.</li> <li>validate: Es una funci\u00f3n que se a\u00f1ade para poder validar la propiedad.</li> <li>get: Define un getter personalizado para la propiedad.</li> <li>set: Define un setter personalizado para la propiedad.</li> <li>alias: Define un alias para poder acceder a la propiedad. Es de tipo <code>String</code>.</li> <li>immutable: Indica que la propiedad es inmutable, por lo que mongoose impedir\u00e1 su modificaci\u00f3n a menos que el documento principal tenga la opci\u00f3n <code>isNew: true</code></li> </ul> <pre><code>new Schema({\nintegerOnly: {\ntype: Number,\nget: v =&gt; Math.round(v),\nset: v =&gt; Math.round(v),\nalias: 'i'\n}\n})\n</code></pre>"},{"location":"tema_4/page-4/#indices","title":"Indices","text":"<p>Tambi\u00e9n se pueden definir indices de MongoDB:</p> <ul> <li>index: Indica si la propiedad es un \u00edndice.</li> <li>unique: Indica si la propiedad es \u00fanica.</li> </ul>"},{"location":"tema_4/page-4/#opciones-para-cadenas","title":"Opciones para cadenas","text":"<ul> <li>lowercase: si se debe invocar <code>.toLowerCase()</code> para el valor de la propiedad.</li> <li>uppercase: si siempre se debe invocar <code>.toUpperCase()</code> para el valor de la propiedad.</li> <li>trim: si siempre se debe invocar <code>.trim()</code> para el valor de la propiedad.</li> <li>match: verifica si el valor coincide con la expresi\u00f3n regular dada.</li> <li>enum: verifica si el valor est\u00e1 en el array indicado.</li> <li>minLength: verifica si la longitud del valor no es menor que el n\u00famero dado.</li> <li>maxLength: verifica si la longitud del valor no es mayor que el n\u00famero dado.</li> </ul>"},{"location":"tema_4/page-4/#opciones-para-numeros","title":"Opciones para n\u00fameros","text":"<ul> <li>min: verifica si el valor es mayor o igual al m\u00ednimo dado.</li> <li>max: verifica si el valor es menor o igual al m\u00e1ximo dado.</li> <li>enum: verifica si el valor es estrictamente igual a uno de los valores en el array indicado.</li> </ul>"},{"location":"tema_4/page-4/#opciones-para-fechas","title":"Opciones para fechas","text":"<ul> <li>min: verifica si el valor es mayor o igual al m\u00ednimo dado.</li> <li>max: verifica si el valor es menor o igual al m\u00e1ximo dado.</li> <li>expires: crea un \u00edndice TTL con el valor expresado en segundos.</li> </ul>"},{"location":"tema_4/page-4/#mixed-type","title":"Mixed Type","text":"<p>El tipo <code>Mixed</code> indica que la propiedad puede ser de cualquier tipo.</p>"},{"location":"tema_4/page-4/#arrays","title":"Arrays","text":"<p>Para definir una propiedad como un array, se indica el tipo envuelto en corchetes <code>[]</code>:</p> <pre><code>new Schema({\nvalues: [String]\n})\n</code></pre> <p>Si nuestro array puede contener diferentes tipos, podemos usar el tipo <code>Mixed</code>:</p> <pre><code>new Schema({\nvalues: [Schema.Types.Mixed]\n})\n</code></pre>"},{"location":"tema_4/page-4/#map","title":"Map","text":"<p>El tipo <code>Map</code> es para indicar que la propiedad es un tipo de objeto, por lo que debemos definir un esquema para dicha propiedad:</p> <pre><code> new Schema({\nsocialMediaHandles: {\ntype: Map,\nof: new Schema({\nhandle: String,\noauth: {\ntype: ObjectId,\nref: 'OAuth'\n}\n})\n}\n})\n</code></pre>"},{"location":"tema_4/page-4/#modelos","title":"Modelos","text":"<p>Al definir un esquema, podemos crear modelos para poder crear objetos con dichos esquemas. Para ello usamos el m\u00e9todo <code>model(name, schema)</code> que recibe el nombre del modelo y el esquema a cumplir:</p> <pre><code>const Blog = mongoose.model('Blog', blogSchema);\n</code></pre> <p>Es buena pr\u00e1ctica que el nombre de los modelos est\u00e9n en singular, ya que al crear colecciones autom\u00e1ticas crea dicha colecci\u00f3n con el nombre en plural del modelo.</p>"},{"location":"tema_4/page-4/#ids","title":"Ids","text":"<p>En el esquema no hace falta referencias el <code>_id</code> ya que se mongoose lo hace de forma autom\u00e1tica:</p> <pre><code>const Model = mongoose.model('Test', schema)\nconst doc = new Model()\ndoc._id instanceof mongoose.Types.ObjectId\n</code></pre> <p>\u00a1Cuidado!</p> <p>Aunque si se podr\u00eda sobre escribir el <code>_id</code> por tu propio <code>_id</code> , no es una buena pr\u00e1ctica realizarlo, ya que puede arrojar resultados no deseados:</p> <pre><code>const schema = new Schema({\n_id: Number\n})\nconst Model = mongoose.model('Test', schema);    await doc.save(); // (1)!\n</code></pre> <ol> <li>Lanza una excepci\u00f3n, ya que el documento debe tener un <code>_id</code> antes de ser almacenado.</li> </ol>"},{"location":"tema_4/page-4/#nested-schemas","title":"Nested Schemas","text":"<p>Un esquema puede contar con una propiedad que sigue otro esquema. Por ejemplo, el nuestra colecci\u00f3n artista podemos tener una propiedad que sea canciones que representa una lista de canciones, por lo que podemos usar otro esquema:</p> <pre><code>const nestedSchema = new Schema(\n{ name: String },\n)\nconst schema = new Schema({\nsubdoc: nestedSchema,\ndocArray: [nestedSchema]\n})\nconst Test = mongoose.model('Test', schema);\n</code></pre>"},{"location":"tema_4/page-4/#queries","title":"Queries","text":"<p>El modelo de mongoose dispone de varios m\u00e9todos para poder realizar operaciones CRUD. Cada una de estas operaciones devuelve un objeto <code>Query</code>. Una query puede ser ejecutada de dos formas, la primera se le puede pasar una callback o se puede usar el m\u00e9todo <code>then</code> para ser usadas como promesas. Tambi\u00e9n se puede usar con el <code>await</code>.</p> <p>Al especificar una query, puedes especificar como un documento JSON o el Shell de MongoDB:</p> <pre><code>const Person = mongoose.model('Person', yourSchema);\nconst person = await Person.findOne({ 'name.last': 'Ghost' }, 'name occupation')\nconsole.log('%s %s is a %s.', person.name.first, person.name.last, person.occupation)\n</code></pre> <p>El m\u00e9todo <code>exec()</code> me permite ejecutar una query que se ha ido construyendo o modificando sin ser ejecutada todav\u00eda. Por ejemplo, hagamos el ejemplo anterior haciendo uso de este m\u00e9todo:</p> <pre><code>const query = Person.findOne({ 'name.last': 'Ghost' }) //(1)!\nquery.select('name occupation') //(2)!\nconst person = await query.exec() //(3)!\nconsole.log('%s %s is a %s.', person.name.first, person.name.last, person.occupation);\n</code></pre> <ol> <li>Filtro a las personas, cuyo apellido sea Ghost.</li> <li>Selecciono el nombre y la ocupaci\u00f3n.</li> <li>Se ejecuta la query.</li> </ol> <p>Adem\u00e1s de esta forma se puede concatenar diferentes operaciones en una \u00fanica query:</p> <pre><code>await Person\n.find({ 'name.last': 'Ghost' }) // (1)!\n.where('age') // (2)!\n.gt(10) // (3)!\n.exec() // (4)!\n</code></pre> <ol> <li>Se filtra por apellido.</li> <li>Se localiza la edad.</li> <li>Se filtra aquellas edades mayores que 10.</li> <li>Se ejecuta la query</li> </ol> <p>\u00a1Importante!</p> <p>Las queries NO son promesas, son thenables. Un thenable son funciones en javascript que pueden usar el m\u00e9todo <code>then()</code> para operaciones de <code>async/await</code> seg\u00fan sea conveniente. Sin embargo, a diferencias de las promesas, por lo que no se puede ejecutar <code>then()</code> varias veces. En el caos de las query, si se usa el <code>then</code> despu\u00e9s de una ejecuci\u00f3n, entonces lanzar\u00e1 un error:</p> <pre><code>const q = MyModel.updateMany({}, { isDeleted: true });\nawait q.then(() =&gt; console.log('Update 2'));\nawait q.then(() =&gt; console.log('Update 3'));\n</code></pre> <p>En la siguiente tabla se recoge los m\u00e9todos para poder realizar queries:</p> Nombre Descripci\u00f3n <code>createCollection([options])</code> Crea la colecci\u00f3n asociada al modelo <code>deleteMany(condition, [options])</code> Elimina varios elementos que cumplan la condici\u00f3n <code>deleteOne(condition, [options])</code> Elimina el primer elemento que cumpla la condici\u00f3n <code>distinct(field, [conditions])</code> Devuelve los diferentes valores que tiene la propiedad en una colecci\u00f3n <code>exists(filter, [options])</code> Devuelve un documento con <code>_id</code> si existe al menos un elemento que cumpla el filtro <code>find(filter, [projection], [options])</code> Localiza todos los documentos que coincidan con el filtro <code>findById(id, [projection], [option])</code> Localiza el documento cuya id coincida con el id aportado <code>findByIdAndDelete(id, [options])</code> Encuentra el documento que coincida con la id y lo elimina. <code>findByIdAndUpdate(id, [update], [options])</code> Encuentra el documento que coincida con la id y lo actualiza <code>findOne([conditions], [projection], [options])</code> Encuentra el primer documento que cumpla con las condiciones <code>findOneAndDelete(conditions, [options])</code> Encuentra el primer documento que cumpla las condiciones y lo elimina. <code>findOneAndReplace(filter, [replacement], [options])</code> Encuentra el primer documento que cumpla las condiciones y lo remplaza. <code>findOneAndUpdate(filter, [update], [options])</code> Encuentra el primer documento que cumpla las condiciones y lo actualiza. <code>insertMany(docs, [options])</code> Inserta varios documentos <code>updateMany(filter, update, [options])</code> Actualiza varios documentos que cumplan el filtro indicado <code>updateOne(filter, update, [options])</code> Actualiza el primer documento que cumplan el filtro indicado <code>where(path, [val])</code> Retorna una query con los valores indicados <p>Existen diferentes m\u00e9todos para poder trabajar con las quieres que se pueden anidar al m\u00e9todo <code>where</code> o <code>find</code>:</p> <ul> <li> <p>all([path], value): Comprueba si la query coincide con todos los valores aportados:</p> <pre><code>MyModel.find().where('pets').all(['dog', 'cat', 'ferret']);\n// Equivalent:\nMyModel.find().all('pets', ['dog', 'cat', 'ferret']);\n</code></pre> </li> <li> <p>and(conditions): Permite concatenar varias condiciones.</p> </li> <li>countDocuments([filter], [options]):</li> </ul> <p>M\u00e9todos</p> <p>Para conocer m\u00e1s m\u00e9todos puedes visitar la API</p>"},{"location":"tema_4/page-4/#transformaciones","title":"Transformaciones","text":"<p>Cuando se realiza la b\u00fasqueda de un documento, el servidor devuelve el documento parecido al siguiente:</p> <pre><code>{\n_id: \"ajdkkdfs\",\nname: \"hola\",\n__v: 0\n}\n</code></pre> <p>Nos gustar\u00eda que nos devolvieran el <code>_id</code> como <code>id</code> y que desapareciera <code>_v</code> porque no es importante para nosotros. Podemos hacer uso de la funci\u00f3n <code>map</code> para ello. Aunque esto puede suponer problemas porque no el objeto modelo es m\u00e1s complejo ede lo que a simple vista parece. En nuestro modelo, podemos indicar el tipo de transformaci\u00f3n a realizar cuando queremos que cambie a JSON:</p> <p>```javascript schema.set('toJSON', {     transform: (document, returnedObject) =&gt; {         returnedObject.id = returnedObject._id         delete document._id         delete document.__v     } })</p>"},{"location":"tema_4/page-5/","title":"5 MySQL","text":""},{"location":"tema_4/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Otra de las formas de gestionar nuestros datos en nuestra API, es a trav\u00e9s de una base de datos relacional con SQL. Para ello podemos usar MySQL como gestor y la librer\u00eda <code>mysql2</code> para tratar con ello.</p> <p>Dicho paquete por defecto usa callbacks para resolver la asincron\u00eda, pero tiene una versi\u00f3n del paquete con el que trabaja con promesas: <code>mysql2/promises</code></p>"},{"location":"tema_4/page-5/#conexion","title":"Conexi\u00f3n","text":"<p>Para realizar la conexi\u00f3n de MySQL necesitamos cierta informaci\u00f3n:</p> <ul> <li>host: host del servidor SQL.</li> <li>port: puerto del servidor SQL.</li> <li>user: nombre de usuario.</li> <li>password: contrase\u00f1a del usuario.</li> <li>database: nombre la base de datos.</li> </ul> <p>Esta informaci\u00f3n puede ir toda unida en una URL de acceso a MySQL o por el contrario podemos tratarla como una objeto. Luego, dicha configuraci\u00f3n ser\u00e1 utilizada como par\u00e1metro en el m\u00e9todo <code>createConnection</code> que se utiliza para poder crear la conexi\u00f3n.</p> <pre><code>const DEFAULT_CONFIG = {\nhost: 'localhost',\nuser: 'root',\nport: 3306,\npassword: '',\ndatabase: 'moviesdb'\n}\nconst config = process.env.DATABASE_URL ?? DEFAULT_CONFIG\nconst connection = await mysql.createConnection(config)\n</code></pre>"},{"location":"tema_4/page-5/#queries","title":"Queries","text":"<p>Una vez creada la conexi\u00f3n, se puede usar el m\u00e9todo <code>query(sql)</code> para realizar consultas a la base de datos. Este m\u00e9todo recibe una cadena con la consulta ejecutar y devuelve un array de dos dimensiones, donde la primera dimensi\u00f3n corresponde a los resultados obtenidos de la consulta, y la segunda a la informaci\u00f3n de las columnas devueltas.</p> <pre><code>const sql = 'SELECT HEX(id) id, title, year, director, duration, poster, rate FROM movie'\nconst [movies] = await connection.query(sql)\nreturn movies\n</code></pre> <p>Adem\u00e1s se pueden realizar consultas parametrizadas, es decir, donde se indique un valor despu\u00e9s de la consulta. El mismo m\u00e9todo puede recibir un array con los valores de los par\u00e1metros. De esta forma, el primer valor del array corresponde al primer par\u00e1metro de la consulta. Un par\u00e1metro de la consulta se indica con el signo de interrogaci\u00f3n <code>?</code>:</p> <pre><code>const sql = `select HEX(m.id) id, title, year, director, duration, poster, rate \n        from movie m \n        join movie_genres mg \n            on mg.movie_id = m.id \n        join genre g \n            on mg.genre_id = g.id \n        where g.name = ?`\nconst [movies] = await connection.query(sql, genre)\nreturn movies\n</code></pre> <p>\u00a1Cuidado!</p> <p>NO se recomienda hacer uso de una inyecci\u00f3n manual de los par\u00e1metros, ya que es un error grave de seguridad. Si dependemos de que el usuario nos facilite el valor del par\u00e1metro no es recomendado porque no podemos asegurar lo que nos va a pasar y se pueda evaluar antes de la ejecuci\u00f3n de la consulta. De esta forma, pase lo que pase el usuario, ser\u00e1 convertido a una cadena, por lo que no se valuar\u00e1 antes de la consulta. </p> <p>Cuando realizamos una consulta de cambio en los datos de la tabla (crear, actualizar o eliminar), el m\u00e9todo <code>query</code> retorna la informaci\u00f3n sobre dicha consulta, incluyendo el id que se haya insertado, pero \u00fanicamente si \u00e9ste es auto-incrementable. Si tenemos otro forma de crear una id autom\u00e1tica en la base de datos, no hay forma de recuperarla, por lo que se recomienda gestionar estas claves en el servidor de la API:</p> <pre><code>const [uuidResult] = await connection.query('SELECT UUID() uuid') //(1)!\nconst [{ uuid }] = uuidResult\nawait connection.query(`INSERT INTO movie (id, title, year, director, duration, poster, rate)\nVALUES (hex(?), ?, ?, ?, ?, ?, ?)`,\n[uuid, title, year, director, duration, poster, rate]\n) //(2)!\nconst [movies] = await connection.query(\n`SELECT HEX(id) id, title, year, director, duration, poster, rate\n    FROM movie WHERE id = hex(?)`,\n[uuid]\n) // (3)!\nreturn movies[0]\n</code></pre> <ol> <li>Realizamos una consulta en la base de datos que me devuelva un id creado autom\u00e1ticamente a trav\u00e9s de la funci\u00f3n UUID de MySQL.</li> <li>Insertamos la pel\u00edcula con la id obtenida.</li> <li>Buscamos la pel\u00edcula que tenga dicha id.</li> </ol>"},{"location":"tema_4/page-5/#orms","title":"ORMs","text":"<p>Una ORM es un modelo de programaci\u00f3n que permite mapear las estructuras de una base de datos relacional. Esto es una buena pr\u00e1ctica para las empresas cuyo proyectos incluyan una conexi\u00f3n a las bases de datos, ya que nos ofrece una serie de ventajas:</p> <ul> <li>Abstracci\u00f3n de las complejidades de las bases de datos.</li> <li>Productividad incrementada.</li> <li>Agnosticismo de base de datos.</li> <li>Gesti\u00f3n sencilla de esquemas y relaciones.</li> <li>Seguridad mejorada.</li> </ul> <p>Existen diferentes tipos de ORMs para poder trabajar con Javascript, entre ellos prisma, sequelize, MicroORM, etc.</p>"},{"location":"tema_4/page-6/","title":"Proyecto","text":"<p>Se quiere realizar la creaci\u00f3n de una API para el almacenamiento de las notas de los alumnos de un profesor. Para ello se quiere almacenar la siguiente informaci\u00f3n de los alumnos:</p> <ul> <li>Identificador, debe ser una cadena auto-creada al lado del servidor.</li> <li>Nombre del alumno, no superior a 40 caracteres.</li> <li>Apellidos del alumno, no superior a 100 caracteres.</li> <li>Fecha de nacimiento del alumno, que no puede ser inferior a los 12 a\u00f1os, ni superior a los 18 a\u00f1os.</li> <li>Informaci\u00f3n del contacto del usuario, como su tel\u00e9fono, direcci\u00f3n y e-mail.</li> </ul> <p>Adem\u00e1s, se desea almacenar informaci\u00f3n de las asignaturas que imparte dicho profesor, como el c\u00f3digo identificativo de la asignatura (no superior a 4) y el nombre de la misma (no superior a 25, y adem\u00e1s de \u00fanico), n\u00famero de horas semanales que imparte dicha asignatura.</p> <p>Por \u00faltimo, se desea almacenar las calificaciones que obtiene un alumno en las diferentes asignaturas, deseando almacenar el tipo de ejercicio realizado (ejercicio evaluable, pr\u00e1ctica, examen, etc), t\u00edtulo (no superior a 100), una descripci\u00f3n del mismo (no superior a 60) y fecha de la actividad, y nota obtenida en dicho ejercicio.</p> <p>Desde la API, se deben obtener la siguiente informaci\u00f3n:</p> <ul> <li>Obtener todos los alumnos, incluyendo sus notas (medias) en cada una de las asignaturas. Se podr\u00e1 indicar otros valores, como ordenar por alg\u00fan campo indicado ya sea de forma ascendente o descendente. Tambi\u00e9n se puede obtener los alumnos id.</li> <li>Obtener todas las asignaturas. Tambi\u00e9n se podr\u00e1 indicar una forma de ordenar por el campo indicado, ya sea de forma ascendente o descendente. Tambi\u00e9n se puede obtener una asignatura por id (cod), o nombre de la asignatura.</li> <li>Obtener las calificaciones de un alumno.</li> <li>Realizar operaciones de Creaci\u00f3n, Actualizado y Eliminaci\u00f3n de los alumnos, asignaturas y calificaciones.</li> </ul>"},{"location":"tema_5/page-1/","title":"1 Archivos","text":""},{"location":"tema_5/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>La subida de ficheros a un servidor a trav\u00e9s de Node JS es una de las operaciones m\u00e1s complejas que existen, ya que hay que recibir los datos en binario, comprobar el tipo de archivo y escribirlo con el m\u00e9todo <code>writeFile</code>.</p> <pre><code>import { createServer } from 'http';\nimport { writeFile } from 'fs';\nconst server = createServer((req, res) =&gt; {\nif (req.method === 'POST' &amp;&amp; req.url === '/upload-image') {\nlet data = [];\nconst mimetype = req.headers['content-type'];\nif (!mimetype.startsWith('image/')) {\nres.writeHead(400, { 'Content-Type': 'text/plain' });\nres.end('Solo se admiten im\u00e1genes');\nreturn;\n}\nreq.on('data', (chunk) =&gt; {\ndata.push(chunk);\n});\nreq.on('end', () =&gt; {\nconst buffer = Buffer.concat(data).toString(\"base64\");\nconsole.log(buffer)\nconst filename = `image-${Date.now()}.${mimetype.split('/')[1]}`;\nwriteFile(`./uploads/${filename}`, buffer, (err) =&gt; {\nif (err) {\nres.writeHead(500, { 'Content-Type': 'text/plain' });\nres.end('Error al subir la imagen');\n} else {\nres.writeHead(200, { 'Content-Type': 'text/plain' });\nres.end(`Imagen subida exitosamente: ${filename}`);\n}\n});\n});\n}\n});\nserver.listen(3000, () =&gt; console.log('Server active'));\n</code></pre> <p>Al igual que con express, existen diferentes librer\u00edas para realizar la subida de ficheros, como <code>multer</code>.</p>"},{"location":"tema_5/page-1/#multer","title":"Multer","text":"<p>Multer es un middleware para manejar multipart/form-data, que es lo principal para la subida de ficheros. Al ser una librer\u00eda, primero habr\u00eda que instalarla:</p> <pre><code>npm install multer\n</code></pre> <p>Una vez instalada, ser\u00e1 necesario crear un objeto para su configuraci\u00f3n, especificando el destino (<code>destination</code>) y el nombre del fichero subido (<code>filename</code>).</p> <p>La propiedad <code>destination</code> es una funci\u00f3n que toma el request, el fichero subido file, y una funci\u00f3n callback que ser\u00e1 llamada con un objeto de error y la ruta de la carpeta de destino como par\u00e1metros. La propiedad <code>filename</code> toma los mismos par\u00e1metros que la propiedad <code>destination</code>, pero el callback en lugar de indicar  la ruta de la carpeta de destino, indica el nombre del fichero. Para crear este objeto, utilizaremos el m\u00e9todo <code>diskStorage</code> de la librer\u00eda multer:</p> <pre><code>const multer = require('multer');\nconst storage = multer.diskStorage({\ndestination: (req, file, cb) =&gt; {\ncb(null, './uploads');\n},\nfilename: (req, file, cb) =&gt; {\ncb(null, file.fieldname + '-' + Date.now());\n}\n});\nconst upload = multer({ storage });\n</code></pre> <p>La constante <code>upload</code> es el middleware que ser\u00e1 usado m\u00e1s tarde para manejar la subida de ficheros. Se usa la funci\u00f3n <code>multer</code> para poder crear dicho middleware.</p>"},{"location":"tema_5/page-1/#limites","title":"Limites","text":"<p>Podemos indicar un tama\u00f1o m\u00e1ximo de subida especificando la propiedad <code>limits</code> de la funci\u00f3n <code>multer</code> la cantidad de tama\u00f1o m\u00e1ximo permitido en bytes en la subida:</p> <pre><code>const upload = multer({\nstorage,\nlimits: {\nfileSize: 1000000 // 1MB\n}\n});\n</code></pre>"},{"location":"tema_5/page-1/#validar-tipos","title":"Validar tipos","text":"<p>Otra consideraci\u00f3n importante a la hora de realizar la subida de ficheros, es el tipo de fichero a subir. En ocasiones, nos interesa subir \u00fanicamente un tipo de fichero, por el contrario, no se realizar\u00e1 ninguna subida. Para ello, debemos especificar la propiedad <code>fileFilter</code> del m\u00e9todo <code>multer</code>, que es una funci\u00f3n que recibe tres par\u00e1metros: el request, el file y un callback con el error y el \u00e9xito de la operaci\u00f3n (verdadero o falso) como par\u00e1metros:</p> <pre><code>const upload = multer({\nstorage,\nlimits: {\nfileSize: 1000000 // 1MB\n},\nfileFilter: (req, file, cb) =&gt; {\nconst allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];\nif (!allowedTypes.includes(file.mimetype)) {\nconst error = new Error('Invalid file type');\nerror.code = 'INVALID_FILE_TYPE';\nreturn cb(error, false);\n}\ncb(null, true);\n}\n});\n</code></pre>"},{"location":"tema_5/page-1/#subida-de-ficheros","title":"Subida de ficheros","text":"<p>Una vez realizada la creaci\u00f3n del middleware, dicha funci\u00f3n ser\u00e1 usada en las rutas que nos compete, haciendo uso de diferentes modos:</p> <ul> <li><code>single(name)</code>: Permite la subida de un \u00fanico fichero, donde name es el nombre de acceso al fichero.</li> <li><code>array(name, size)</code>: Permita la subida de varios ficheros, donde name es el nombre de acceso a los ficheros y size el n\u00famero de fichero permitido a subir.</li> <li><code>fields()</code>: Permite una subida de m\u00faltiple de ficheros pero con diferentes nombre de acceso y tama\u00f1os, indicamos como un array de objectos.</li> <li><code>none()</code>: No permite la subida de ning\u00fan fichero.</li> </ul> <pre><code>app.post('/profile', upload.single('avatar'), function (req, res, next) {\n// req.file is the `avatar` file\n// req.body will hold the text fields, if there were any\n})\napp.post('/photos/upload', upload.array('photos', 12), function (req, res, next) {\n// req.files is array of `photos` files\n// req.body will contain the text fields, if there were any\n})\nconst cpUpload = upload.fields([\n{ name: 'avatar', maxCount: 1 }, { name: 'gallery', maxCount: 8 }\n])\napp.post('/cool-profile', cpUpload, function (req, res, next) {\n// req.files is an object (String -&gt; Array) where fieldname is the key, and the value is array of files\n//\n// e.g.\n//  req.files['avatar'][0] -&gt; File\n//  req.files['gallery'] -&gt; Array\n//\n// req.body will contain the text fields, if there were any\n})\napp.post('/profile', upload.none(), function (req, res, next) {\n// req.body contains the text fields\n})\n</code></pre> <p>Desde el lado del front, ser\u00e1 necesario tener acceso a un formulario que permite la subida de fichero, indicando un input con el mismo nombre que le hayamos indicado en la funciones anteriores:</p> <pre><code>&lt;form action=\"/stats\" enctype=\"multipart/form-data\" method=\"post\"&gt;\n&lt;div class=\"form-group\"&gt;\n&lt;input type=\"file\" class=\"form-control-file\" name=\"uploaded_file\"&gt;\n&lt;input type=\"text\" class=\"form-control\" placeholder=\"Number of speakers\" name=\"nspeakers\"&gt;\n&lt;input type=\"submit\" value=\"Get me the stats!\" class=\"btn btn-default\"&gt;            &lt;/div&gt;\n&lt;/form&gt;\n</code></pre> <p>Tambi\u00e9n se puede realizar haciendo uso de <code>fetch</code>:</p> <pre><code>var input = document.querySelector('input[type=\"file\"]')\nvar data = new FormData()\ndata.append('file', input.files[0])\ndata.append('user', 'hubot')\nfetch('/avatars', {\nmethod: 'POST',\nbody: data\n})\n</code></pre> <p>\u00a1Importante!</p> <p>La subida de ficheros debe realizarse siempre desde un m\u00e9todo POST, ya que subir una fichero significar crear un nuevo fichero en el servidor. Un fichero, no puede ser ni actualizado, ni eliminado. Para eliminar un fichero, por ejemplo, no requires la imagen en s\u00ed, simplemente se le solicitar\u00eda el nombre al usuario y ser\u00eda eliminada en el m\u00e9todo DELETE, y a la hora de actualizar una imagen, se le solicitar\u00eda el nombre de la antigua imagen, se eliminar\u00eda, subiendo la nueva imagen con dicho nombre, pero para ello se requiere POST ya que la nueva imagen debe ser subida.</p>"},{"location":"tema_5/page-1/#configuracion-avanzada","title":"Configuraci\u00f3n avanzada","text":"<p>Veamos un ejemplo m\u00e1s avanzado:</p> <pre><code>const express = require('express');\nconst multer = require('multer');\nconst mongoose = require('mongoose');\n// Configuraci\u00f3n de Multer\nconst storage = multer.diskStorage({\ndestination: './uploads/',\nfilename: (req, file, cb) =&gt; {\ncb(null, `${Date.now()}-${file.originalname}`);\n}\n});\nconst upload = multer({ storage });\n// Conexi\u00f3n a MongoDB\nmongoose.connect('mongodb://localhost:27017/mydb', {\nuseNewUrlParser: true,\nuseUnifiedTopology: true,\n});\n// Esquema de usuario\nconst userSchema = new mongoose.Schema({\nnombre: String,\nedad: Number,\nemail: String,\nimagenPerfil: String,\n});\n// Modelo de usuario\nconst User = mongoose.model('User', userSchema);\n// Ruta POST para subir usuario\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use('/uploads', express.static('uploads'));\napp.post('/usuarios', upload.single('imagenPerfil'), async (req, res) =&gt; {\nconst { nombre, edad, email } = req.body;\nconst imagenPerfil = req.file.filename;\nconst user = new User({\nnombre,\nedad,\nemail,\nimagenPerfil,\n});\ntry {\nawait user.save();\nres.status(201).json({ message: 'Usuario creado exitosamente' });\n} catch (error) {\nres.status(500).json({ message: 'Error al crear usuario', error });\n}\n});\napp.listen(3000);\n</code></pre> <p>En el ejemplo anterior, nuestro servidor crea un nuevo usuario en MongoDB, subiendo la imagen al servidor.</p> <p>La l\u00ednea a<code>pp.use(express.urlencoded({ extended: true }))</code> es un middleware de Express que se encarga de parsear el cuerpo de las solicitudes HTTP con formato URL-encoded. Esto significa que convierte los datos enviados en el cuerpo de la solicitud en un objeto JavaScript que puede ser accedido en la ruta.</p> <p>La l\u00ednea <code>app.use('/uploads', express.static('uploads'));</code> en tu c\u00f3digo de Node.js con Express realiza dos funciones:</p> <ol> <li> <p>Define una ruta est\u00e1tica:</p> </li> <li> <p>Especifica una ruta virtual (<code>/uploads</code>) para acceder a archivos est\u00e1ticos.</p> </li> <li> <p>Esta ruta mapea a la carpeta uploads en tu sistema de archivos.</p> </li> <li> <p>Utiliza el middleware express.static:</p> </li> <li> <p>Este middleware sirve archivos est\u00e1ticos desde la carpeta especificada.</p> </li> <li>Permite al servidor web entregar archivos como im\u00e1genes, CSS, JavaScript o - cualquier otro archivo que se encuentre dentro del directorio configurado. Por lo que no ser\u00e1 necesario, crear una ruta con el m\u00e9todo GET para acceder a dichos ficheros.</li> </ol>"},{"location":"tema_5/page-2/","title":"2 Autentificaci\u00f3n","text":""},{"location":"tema_5/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>A la hora de crear un servidor API REST tenemos que tener en cuenta que hay ciertas operaciones susceptibles que no deber\u00edan ser realizar por cualquier usuario. Para ello, es recomendable que exista un sistema de autentificaci\u00f3n que permita verificar que tipo de usuario est\u00e1 realizando dicha operaci\u00f3n y en caso de no permit\u00edrselo, bloquearlo.</p> <p>Para poder realizar esa verificaci\u00f3n existen diferentes t\u00e9cnicas, como:</p> <ul> <li>Acceso a trav\u00e9s de una apiKey: se puede considerar la menos segura, pero es \u00fatil para API REST amplias que requieran operaciones sencillas, como por ejemplo, obtener todos los libros de nuestra base de datos.</li> <li>Acceso a trav\u00e9s de JsonWebToken: Consiste en crear un token, que ser\u00e1 enviado con la petici\u00f3n y se validar\u00e1 en el servidor. Puede ser utilizada para operaciones m\u00e1s vulnerables, como por ejemplo, crea un libro en nuestra base de datos.</li> <li>Acceso a trav\u00e9s de OAuth: Es un protocolo de autorizaci\u00f3n abierto que permite a los usuarios autorizar a aplicaciones de terceros a acceder a sus datos en otros servicios.</li> </ul>"},{"location":"tema_5/page-2/#clave-api","title":"Clave API","text":"<p>Una API key (clave de API) es una cadena alfanum\u00e9rica \u00fanica que se utiliza para identificar y autorizar a un usuario, desarrollador o programa de llamada a una API.</p> <p>Funciona como una credencial que permite el acceso a las funcionalidades o recursos ofrecidos por la API. Se puede utilizar para:</p> <ul> <li>Autenticaci\u00f3n: Verifica la identidad del usuario o aplicaci\u00f3n que realiza la solicitud a la API.</li> <li>Autorizaci\u00f3n: Determina el nivel de acceso que tiene el usuario o aplicaci\u00f3n a los recursos de la API (lectura, escritura, etc.).</li> <li>Rastreo y control: Permite al proveedor de la API identificar y monitorear el uso de la API por parte de diferentes usuarios o aplicaciones.</li> </ul> <p>El usuario deber\u00e1 crear la API Key y est\u00e1 ser\u00e1 almacenada en una base de datos (para hacer esta operaci\u00f3n, quiz\u00e1s se requiera una autentificaci\u00f3n previa). Cuando el usuario realiza una operaci\u00f3n, deber\u00e1 aportar dicha clave, que ser\u00e1 verificada posteriormente.</p>"},{"location":"tema_5/page-2/#proyecto-api-key","title":"Proyecto API Key","text":"<p>En este proyecto, vamos a crear el acceso a una aplicaci\u00f3n de forma sencilla a trav\u00e9s de una API KEY. Para ello, lo primero que hacemos es configurar nuestro proyecto con express:</p> <pre><code>const app = express()\napp.use(express.json())\nconst PORT = process.env.PORT || 1412\napp.listen(PORT, () =&gt; {\nconsole.log(`Server running  on port ${PORT}`)\n})\n</code></pre> <p>Realizamos la conexi\u00f3n a MongoDB:</p> <pre><code>connect(connectionString, { dbName: 'test' }).then(() =&gt; {\nconsole.log('Database connected')\n}).catch(err =&gt; {\nconsole.error(err)\n})\nprocess.on('uncaughtException', error =&gt; {\nconsole.error(error)\ndisconnect()\n})\n</code></pre> <p>Configuramos el modelo:</p> <pre><code>const userSchema = new Schema({\nusername: String,\nname: String,\npassword: String,\ntoken: String,\nadmin: Boolean\n})\nconst User = model('User', userSchema)\n</code></pre> <p>Creamos una ruta que permita crear la API. En este caso, se crea un <code>randomUUID()</code> y se le a\u00f1ade un 1 o un 0 para comprobar si es o no administrador. En un proyecto m\u00e1s elaborado, se deber\u00eda hacer de una forma diferente y crear una API Key a trav\u00e9s de otro m\u00e9todo de autentificaci\u00f3n:</p> <pre><code>app.post('/api', async (req, res) =&gt; {\nconst { username, password, name, admin } = req.body\nconst user = await new User({ username, password, name, token: `${randomUUID()} ${admin ? 1 : 0}` }).save()\nif (!user) {\nres.status(400).json({ error: 'Something went wrong' })\nreturn\n}\nres.status(201).json(user)\n})\n</code></pre> <p>Por \u00faltimo, creamos las rutas donde se requieran la API key, comprobando que:</p> <ul> <li>El usuario ha prove\u00eddo la API key como query de la request.</li> <li>Comprobando si est\u00e1 registrada dicha API Key en la base de datos.</li> <li>Comprobar si el usuario tiene permiso o no. En este ejemplo, solo podr\u00e1 obtener los usuarios aquellos que provean una API key de administrador (con un 1 al final).</li> </ul> <pre><code>app.get('/users', (req, res) =&gt; {\nif (!req.query.apiKey) {\nres.status(401).json({ error: 'API Key is required' })\nreturn\n}\n// Validate API KEY\nconst { apiKey } = req.query\n// Check if user exists\nconst user = User.findOne({ token: apiKey })\nif (!user) {\nres.status(401).json({ error: 'Invalid API Key' })\nreturn\n}\n// Check if admin user\nconst lastChar = apiKey[apiKey.length - 1]\nif (lastChar !== 1) {\nres.status(401).json({ error: 'API Key is provided but its not a admin api key' })\nreturn\n}\nconst users = User.find()\nres.json(users)\n})\n</code></pre> <p>Dicha comprobaci\u00f3n se podr\u00eda extrapolar en una funci\u00f3n middleware y hacer uso de ella en las operaciones necesarias.</p>"},{"location":"tema_5/page-3/","title":"3 JsonWebToken","text":""},{"location":"tema_5/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Un JSON Web Token (JWT) es un est\u00e1ndar abierto (RFC 7519) que define un m\u00e9todo compacto y autocontenido para la transmisi\u00f3n segura de informaci\u00f3n entre dos partes como un objeto JSON. Esta informaci\u00f3n puede ser verificada y ser fiable porque est\u00e1 firmada digitalmente. Entre sus usos, podemos encontrar:</p> <ul> <li>Autenticaci\u00f3n: Se puede usar para autenticar usuarios en APIs y aplicaciones web.</li> <li>Autorizaci\u00f3n: Se puede usar para determinar los permisos de un usuario para acceder a recursos.</li> <li>Intercambio de datos: Se puede usar para compartir informaci\u00f3n de forma segura entre diferentes aplicaciones.</li> </ul> <p>La firma digital protege la integridad del token y evita la falsificaci\u00f3n. Por ello, es importante que la firma sea secreta de esta forma no hay manera de poder desintegrar el token.</p> <p>Al usar el formato JSON nos permite una mayor compacidad ya que es ligero y eficiente. Adem\u00e1s, nos permite almacenar cualquier tipo de informaci\u00f3n, por lo que nos permite una mayor flexibilidad.</p>"},{"location":"tema_5/page-3/#funcionamiento","title":"Funcionamiento","text":"<p>Un JWT se compone de tres partes separadas por puntos (.):</p> <ul> <li>Cabecera (Header): Contiene informaci\u00f3n sobre el token, como el algoritmo de firma utilizado y el tipo de token.</li> <li>Carga \u00fatil (Payload): Contiene la informaci\u00f3n que se desea transmitir, como la identidad del usuario, roles, permisos y tiempo de expiraci\u00f3n.</li> <li>Firma (Signature): Se utiliza para verificar la integridad del token y garantizar que no ha sido modificado. Es importante que para salvaguardar la integridad del token dicha firma sea secreta.</li> </ul> <p> Figura 1- Componentes de un JWT</p> <p>Para poder crear el token, en primer lugar, el emisor del token (por ejemplo, un servidor de autenticaci\u00f3n) crea un objeto JSON con la informaci\u00f3n que desea transmitir. El objeto JSON es firmado digitalmente con un algoritmo espec\u00edfico (por ejemplo, RSA o HMAC) y se codifica en Base64. Luego, el token se env\u00eda al destinatario (por ejemplo, un cliente web o una aplicaci\u00f3n m\u00f3vil) y \u00e9ste verifica la firma del token y decodifica la informaci\u00f3n contenida en \u00e9l. Si la firma es v\u00e1lida, el destinatario puede usar la informaci\u00f3n del token para tomar decisiones sobre la solicitud del usuario.</p> <p> Figura 2 - JWT flow</p>"},{"location":"tema_5/page-3/#creacion-del-token","title":"Creaci\u00f3n del token","text":"<p>Para poder crear el token, es necesario primero que el cliente realice un login con los datos de credenciales, luego con la informaci\u00f3n requerida crear el parseo del token. Para realizar todo este proceso, ser\u00e1 necesario usar la librer\u00eda <code>jsonwebtoken</code>.</p> <pre><code>app.post('/login', async (request, response) =&gt; {\nconst { body } = request\nconst { username, password } = body\nconst user = await User.findOne({ username })\nconst passwordCorrect = user === null\n? false\n: await compare(password, user.passwordHash)\nif (!(user &amp;&amp; passwordCorrect)) {\nresponse.status(401).json({\nerror: 'invalid user or password'\n})\n}\n// Informaci\u00f3n para el token\nconst userForToken = {\nid: user.id,\nusername: user.username\n}\nconst token = jwt.sign(\nuserForToken,\nprocess.env.SECRET,\n{\nexpiresIn: 60 * 60 * 24 * 7\n}\n)\nresponse.send({\nname: user.name,\nusername: user.username,\ntoken\n})\n})\n</code></pre> <p>Con el m\u00e9todo <code>sign</code>, podemos firmar la informaci\u00f3n y crear el token. Dicho m\u00e9todo recibe el payload que quiere almacenar, y la firma del token. Adem\u00e1s puede recibir un objeto con diferentes opciones, como por ejemplo:</p> <ul> <li>algorithms: permite indicar el algoritmo a usar para el cifrado.</li> <li>complete: retorna el objeto completo del token a la hora de verificar, con el header, payload y la firma, en lugar de solo el payload.</li> <li>expiresIn: indica un tiempo de expiraci\u00f3n del token. Una vez pasado dicho el tiempo, el token no ser\u00e1 v\u00e1lido.</li> </ul>"},{"location":"tema_5/page-3/#verificacion-del-token","title":"Verificaci\u00f3n del token","text":"<p>Para verificar el token, usamos el m\u00e9todo <code>verify</code> de la librer\u00eda. Dicho m\u00e9todo recibe el valor del token, y la firma secreta a usar. Podemos usar el token a la hora de realizar una petici\u00f3n, a trav\u00e9s del header Authorization de tipo Bearer (el tipo de autorizaci\u00f3n permitida para las JWT) o como API Key. Lo recomendable, es crear un middleware que realice la verificaci\u00f3n y devuelva a la siguiente operaci\u00f3n el valor deseado a trav\u00e9s de la petici\u00f3n.</p> <pre><code>export const userExtractor = (request, response, next) =&gt; {\nconst authorization = request.get('authorization') //(1)!\nlet token = ''\nif (authorization &amp;&amp; authorization.toLowerCase().startsWith('bearer')) { //(2)!\ntoken = authorization.substring(7)\n}\nconst decodedToken = jwt.verify(token, process.env.SECRET) //(3)!\nif (!token || !decodedToken.id) { //(4)!\nreturn response.status(401).json({ error: 'token missing or invalid' })\n}\nconst { id: userId } = decodedToken //(5)!\nrequest.userId = userId //(6)!\nnext()\n}\n</code></pre> <ol> <li>Se obtiene el header authorization</li> <li>Se comprueba que dicho header es de tipo bearer</li> <li>Se verifica el token con el m\u00e9todo <code>verify</code>, devuelve un undefined si el token no es v\u00e1lido, por el contrario retorna el valor del payload.</li> <li>Se obtiene los datos requeridos del payload.</li> <li>Se a\u00f1ade dichos datos a la request para pasarla a la siguiente petici\u00f3n con el m\u00e9todo <code>next</code></li> </ol> <p>Por \u00faltimo, podemos usar la informaci\u00f3n requerida, as\u00ed como verificar ciertas operaciones, como por ejemplo, si el usuario es administrador, tiene los permisos suficientes, etc., de la siguiente forma:</p> <pre><code>app.post('/notes', userExtractor, async (request, response, next) =&gt; {\nconst {\ncontent,\nimportant = false\n} = request.body\nconst { userId } = request\nconst user = await User.findById(userId)\nif (!content) {\nreturn response.status(400).json({\nerror: 'required \"content\" field is missing'\n})\n}\nconst newNote = new Note({\ncontent,\ndate: new Date(),\nimportant,\nuser: user.id\n})\ntry {\nconst savedNote = await newNote.save()\nuser.notes = user.notes.concat(savedNote.id)\nawait user.save()\nresponse.json({ ...savedNote })\n} catch (error) {\nnext(error)\n}\n})\n</code></pre>"},{"location":"tema_5/page-4/","title":"4 OAuth2.0","text":""},{"location":"tema_5/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>OAuth 2.0 es un protocolo de autorizaci\u00f3n abierto que permite a los usuarios compartir informaci\u00f3n privada, como fotos o datos de contacto, con aplicaciones de terceros sin revelar sus contrase\u00f1as.</p> <p>Con este tipo de autorizaci\u00f3n, se protege las contrase\u00f1as de los usuarios y adem\u00e1s les permite controlar que informaci\u00f3n se comparte con las aplicaciones de tercero. Tambi\u00e9n, es un m\u00e9todo que permite flexibilidad ya que se puede usar en una gran cantidad de aplicaciones y plataformas, adem\u00e1s de asegurar su compatibilidad.</p> <p>El uso que se puede dar a esta autentificaci\u00f3n puede ser:</p> <ul> <li>Inicio de sesi\u00f3n \u00fanico (SSO): Permite a los usuarios iniciar sesi\u00f3n en una aplicaci\u00f3n con sus credenciales de otra aplicaci\u00f3n.</li> <li>Acceso a APIs: Permite a las aplicaciones acceder a datos de usuario de otros servicios.</li> <li>Redes sociales: Permite a las aplicaciones compartir informaci\u00f3n con redes sociales.</li> </ul>"},{"location":"tema_5/page-4/#funcionamiento","title":"Funcionamiento","text":"<p>El usuario inicia un proceso de autorizaci\u00f3n en una aplicaci\u00f3n de terceros (cliente OAuth), y redirige al usuario al servidor de autorizaci\u00f3n (por ejemplo, Google, Facebook, Twitter) para que se autentique. El usuario introduce sus credenciales en el servidor de autorizaci\u00f3n y si la autenticaci\u00f3n es correcta, el servidor de autorizaci\u00f3n env\u00eda un c\u00f3digo de autorizaci\u00f3n al cliente OAuth. El cliente OAuth canjea el c\u00f3digo de autorizaci\u00f3n por un token de acceso en el servidor de autorizaci\u00f3n y utiliza el token de acceso para acceder a los recursos del usuario en el servidor de recursos (por ejemplo, API de Google, API de Facebook).</p> <p> Figura 3 - Flow OAuth2</p> <p>OAuth 2.0 define cuatro flujos de autorizaci\u00f3n para diferentes casos de uso:</p> <ul> <li>Flujo de c\u00f3digo de autorizaci\u00f3n: Este es el flujo m\u00e1s com\u00fan y se utiliza para aplicaciones web y m\u00f3viles.</li> <li>Flujo de token de acceso impl\u00edcito: Este flujo se utiliza para aplicaciones web que no pueden almacenar secretos de forma segura.</li> <li>Flujo de contrase\u00f1a de usuario: Este flujo se utiliza para aplicaciones que necesitan acceso a los datos del usuario en nombre del usuario.</li> <li>Flujo de credenciales de cliente: Este flujo se utiliza para aplicaciones que necesitan acceder a los datos del usuario sin la intervenci\u00f3n del usuario.</li> </ul>"},{"location":"tema_5/page-4/#libreria","title":"Librer\u00eda","text":"<p>Para poder simplificar la operaci\u00f3n de autentificaci\u00f3n de este tipo, podemos usar la librer\u00eda <code>node-oauth2-server</code>, un m\u00f3dulo independiente del marco para implementar un servidor OAuth 2 en Node.js. <code>node-oauth2-server</code> es de c\u00f3digo abierto, simple y f\u00e1cil de integrar con sus aplicaciones de Node, incluso si ya se han estado ejecutando por un tiempo.</p> <p>En su documentaci\u00f3n, podemos encontrar la especificaci\u00f3n del modelo que indica, que se debe anular las funciones predeterminadas de OAuth 2 para brindar una experiencia personalizada.</p> <pre><code>const model = {\n// We support returning promises.\ngetAccessToken: function() {\nreturn new Promise('works!');\n},\n// Or, calling a Node-style callback.\ngetAuthorizationCode: function(done) {\ndone(null, 'works!');\n},\n// Or, using generators.\ngetClient: function*() {\nyield somethingAsync();\nreturn 'works!';\n},\n// Or, async/wait (using Babel).\ngetUser: async function() {\nawait somethingAsync();\nreturn 'works!';\n}\n};\nconst OAuth2Server = require('oauth2-server');\nlet oauth = new OAuth2Server({model: model});\n</code></pre> <p>Con el objeto <code>oauth</code> puede anular el modelo predeterminado del servidor express.</p> <p>Coming soon...</p>"}]}