{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"tema_1/page-1/","title":"1 Introducci\u00f3n a React","text":""},{"location":"tema_1/page-1/#que-es-react","title":"\u00bfQu\u00e9 es react?","text":"<p>React es una biblioteca de Javascript utilizada para construir interfaces de usuario (UI) interactivas y componentes reutilizables en aplicaciones web. Fue desarrollada y es mantenida por Facebook, y es ampliamente  utilizada en la industria para crear aplicaciones web de una sola p\u00e1gina (Single Page Applications) y aplicaciones m\u00f3viles utilizando React Native.</p> <p>Algunas de las caracter\u00edsticas clave de React incluyen:</p> <ul> <li>Componentes: React se basa en el concepto de componentes, que son piezas independientes de la interfaz de usuario que pueden ser reutilizadas en diferentes partes de una aplicaci\u00f3n.</li> <li>Virtual DOM: React utiliza un Virtual DOM (DOM virtual) para optimizar el rendimiento. En lugar de actualizar directamente el DOM del navegador cada vez que cambia el estado de una aplicaci\u00f3n, React actualiza primero el Virtual DOM y luego compara las diferencias (diffing) para actualizar solo las partes del DOM que han cambiado. Esto mejora la eficiencia y la velocidad de la aplicaci\u00f3n.</li> <li>Unidireccionalidad de datos: React promueve el flujo de datos en una sola direcci\u00f3n, lo que significa que los datos fluyen desde un componente principal hacia sus componentes secundarios. Esto hace que sea m\u00e1s f\u00e1cil de entender y depurar c\u00f3mo los datos afectan a la interfaz de usuario.</li> <li>JSX: React utiliza una extensi\u00f3n de JavaScript llamada JSX (JavaScript XML) que permite definir la estructura de la interfaz de usuario de manera similar al HTML, pero dentro de JavaScript. Esto facilita la creaci\u00f3n de componentes de manera declarativa.</li> <li>Amplia comunidad y ecosistema: React tiene una comunidad activa y un amplio ecosistema de bibliotecas y herramientas complementarias que lo hacen a\u00fan m\u00e1s poderoso y vers\u00e1til.</li> </ul> <p>En resumen, React es una herramienta popular y poderosa para crear interfaces de usuario din\u00e1micas y eficientes en aplicaciones web y m\u00f3viles, y ha sido ampliamente adoptada en la industria del desarrollo de software.</p> <p>React es agn\u00f3stica de la plataforma, es decir, no est\u00e1 vinculado a una plataforma espec\u00edfica de desarrollo o de tecnolog\u00eda. React tiene la capacidad de trabajar de manera afectiva en diferentes entornos y plataformas.</p> <p>React es utilizado com\u00fanmente para construir interfaces de usuario en aplicaciones web, pero su dise\u00f1o modular y su arquitectura permiten que se utilice en una variedad de contextos. Por ejemplo, puede ser usado para construir aplicaciones web de una sola p\u00e1gina (SPA), aplicaciones m\u00f3viles, e incluso aplicaciones de escritorio.</p> <p>Uno de los principales motivos para usar React es que usa Javascript de forma declarativa, y no de forma imperativa, y adem\u00e1s est\u00e1 basado en componentes lo que permite reutilizar y escalar c\u00f3digo.</p>"},{"location":"tema_1/page-1/#por-que-react","title":"\u00bfPor qu\u00e9 React?","text":"<p>React fue lanzada por primera vez en 2013 y desde entonces ha experimentado un r\u00e1pido crecimiento en popularidad debido a su enfoque en la creaci\u00f3n de componentes reutilizables y su paradigma de programaci\u00f3n declarativa. Meta, la empresa detr\u00e1s de React, la utiliza en todos sus productos (Facebook, Instagram, Whatsapp, etc)</p> <p>Aunque al principio no se consideraba open source, Meta decidi\u00f3 liberar el c\u00f3digo fuente, pero a\u00fan as\u00ed tiene una licencia permisiva.</p> <p>React es una de las librer\u00edas m\u00e1s demandadas y con mayor salida laboral. Adem\u00e1s, en su versi\u00f3n React Native permite crear aplicaciones para m\u00f3viles, y tambi\u00e9n aplicaciones para escritorio Windows y macOS.</p> <p>React tiene un gran soporte y es un gran ecosistema, adem\u00e1s te ayudar\u00e1, en caso de que quieras migrar, a otras librer\u00edas o frameworks como Angular, Vue y Svelt. Tambi\u00e9n, cuenta con una API estable (en varios idiomas) y tiene un gran soporte ya que cuenta con una gran comunidad.</p>"},{"location":"tema_1/page-1/#javascript-vs-react","title":"Javascript vs React","text":"<p>El uso de Javascript nativo (vainilla Javascript) es diferente a como se usa en React. En el primer caso, se usa de forma imperativo, es decir, indica COMO lo tiene que hacer, lo que imposibilita la escalabilidad, mientras que en React, se usa de forma declarativa.</p> <p>React define un elemento ra\u00edz, el cual contendr\u00e1 toda el contenido de nuestra aplicaci\u00f3n. Dicha ra\u00edz estar\u00e1 formada por diferentes componentes, con los elementos que se desee mostrar.</p> <p>Importante</p> <p>Es importante resaltar que en React TODO se considera un componente, desde el elemento m\u00e1s primario hasta el elemento m\u00e1s compuesto.</p> <p>React recibe los diferentes elementos que desea renderizar. La renderizaci\u00f3n es el proceso de generar la representaci\u00f3n visual de un elemento o conjunto de elementos para que pueda ser percibido por los usuarios.</p> <p>Veamos un ejemplo en el que se renderice un bot\u00f3n con javascript nativo. Para ello, necesitamos un elemento HTML:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n&lt;title&gt;&lt;/title&gt;\n&lt;style&gt;\nbutton {\nbackground-color: #09f;\ncolor: #fff;\nborder: 0;\npadding: 4px 8px;\nfont-size: 18px;\ncursor: pointer;\n}\nbody {\nbackground-color: #222;\ncolor: #f0f0f0;\n}\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;button data-id=\"123\"&gt;Me gusta&lt;/button&gt;\n&lt;script&gt;\n// Recuperamos el bot\u00f3n\nconst button = document.querySelector('button')\n// al hacer click en el bot\u00f3n, tenemos que ejecutar una funci\u00f3n\nbutton.addEventListener('click', function () {\n// recuperar el id del atributo del HTML\nconst id = button.getAttribute('data-id')\n// llamar a un servicio para actualizar si me gusta\n// toggleLike(id) // no necesario\nif (button.classList.contains('liked')) {\nbutton.classList.remove('liked')\nbutton.innerText = 'Me gusta'\n} else {\nbutton.classList.add('liked')\nbutton.innerText = 'Quitar me gusta'\n}\n})\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>En el ejemplo anterior, podemos observamos como tenemos un elemento HTML que representa un bot\u00f3n. Al hacer clic en ese bot\u00f3n, recuperamos su id (data-id) y modificamos su contenido de me gusta a no me gusta o viceversa. Pero, \u00bfy si a\u00f1adimos m\u00e1s botones al c\u00f3digo HTML?:</p> <pre><code>&lt;!-- ... --&gt;\n&lt;button data-id=\"123\"&gt;Me gusta&lt;/button&gt;\n&lt;button data-id=\"456\"&gt;Me gusta&lt;/button&gt;\n&lt;button data-id=\"789\"&gt;Me gusta&lt;/button&gt;\n&lt;script&gt;\n// al hacer click en el bot\u00f3n, tenemos que ejecutar una funci\u00f3n\nbutton.addEventListener('click', function () {\n// recuperar el id del atributo del HTML\nconst id = button.getAttribute('data-id')\n// llamar a un servicio para actualizar si me gusta\n// toggleLike(id) // no necesario\nif (button.classList.contains('liked')) {\nbutton.classList.remove('liked')\nbutton.innerText = 'Me gusta'\n} else {\nbutton.classList.add('liked')\nbutton.innerText = 'Quitar me gusta'\n}\n})\n&lt;/script&gt;\n</code></pre> <p>En este caso, el c\u00f3digo javascript no funcionar\u00e1, por lo que habr\u00e1 que modificar el c\u00f3digo javascript para implementar este cambio:</p> <pre><code>&lt;!-- ... --&gt;\n&lt;button data-id=\"123\"&gt;Me gusta&lt;/button&gt;\n&lt;button data-id=\"456\"&gt;Me gusta&lt;/button&gt;\n&lt;button data-id=\"789\"&gt;Me gusta&lt;/button&gt;\n&lt;script&gt;\n// Recuperamos todos los botones\nconst buttons = document.querySelectorAll('button')\nbuttons.forEach(button =&gt; {\n// al hacer click en el bot\u00f3n, tenemos que ejecutar una funci\u00f3n\nbutton.addEventListener('click', function () {\n// recuperar el id del atributo del HTML\nconst id = button.getAttribute('data-id')\n// llamar a un servicio para actualizar si me gusta\n// toggleLike(id) // no necesario\nif (button.classList.contains('liked')) {\nbutton.classList.remove('liked')\nbutton.innerText = 'Me gusta'\n} else {\nbutton.classList.add('liked')\nbutton.innerText = 'Quitar me gusta'\n}\n})\n})\n&lt;/script&gt;\n</code></pre> <p>Esto a la larga puede convertirse un trabajo pesado y no es nada eficiente si queremos crear diferentes elemento y cada uno con una funcionalidad diferente. Para eso y m\u00e1s, React nos facilitar\u00e1 la tarea.</p> <p>Info</p> <p>En este enlace, https://es.react.dev/, se encuentra la API de React oficial y en espa\u00f1ol.</p>"},{"location":"tema_1/page-1/#trabajando-con-react","title":"Trabajando con React","text":"<p>Para trabajar con React, ser\u00e1 necesario usar la librer\u00eda <code>React</code>, que contiene los m\u00e9todos para crear elementos y componentes, y la librer\u00eda <code>ReactDOM</code> para poder trabajar con el DOM de forma sencilla.</p> <p>En primer lugar, para poder trabajar con React necesito un fichero HTML que defina el elemento ra\u00edz de nuestra aplicaci\u00f3n:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n&lt;title&gt;React&lt;/title&gt;\n&lt;style&gt;\nbutton {\nbackground-color: #09f;\ncolor: #fff;\nborder: 0;\npadding: 4px 8px;\nfont-size: 18px;\ncursor: pointer;\n}\nbody {\nbackground-color: #222;\ncolor: #f0f0f0;\n}\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"app\"&gt;&lt;/div&gt;\n&lt;script src=\"react.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>En este ejemplo, tenemos un contenedor que hemos definido con la clase <code>app</code>. Desde nuestro archivo javascript, obtenemos ese elemento HTML que funciona como ra\u00edz y con el m\u00e9todo <code>createRoot(element)</code>, de la librer\u00eda <code>ReactDOM</code>:</p> <pre><code>import ReactDOM from \"https://esm.sh/react-dom@18.2.0/client\"\nimport React from \"https://esm.sh/react@18.2.0\"\nconst app = document.getElementById('app') // Obtenemos el elemento HTML que funcionar\u00e1 como ra\u00edz\nconst root = ReactDOM.createRoot(app) // Indicamos que elemento es la ra\u00edz\n</code></pre> <p>Para poder renderizar el contenido usamos el m\u00e9todo <code>render(elemento)</code> de la librer\u00eda <code>React</code>:</p> <pre><code>import ReactDOM from \"https://esm.sh/react-dom@18.2.0/client\"\nimport React from \"https://esm.sh/react@18.2.0\"\nconst app = document.getElementById('app') // Obtenemos el elemento HTML que funcionar\u00e1 como ra\u00edz\nconst root = ReactDOM.createRoot(app) // Indicamos que elemento es la ra\u00edz\nroot.render('Hola mundo')\n</code></pre>"},{"location":"tema_1/page-1/#renderizar-elementos","title":"Renderizar elementos","text":"<p>Si se intenta renderizar un elemento HTML sin comillas (\"\"), eso no funcionar\u00e1 ya que dar\u00e1 un error y no se renderizar\u00e1, y si se usa con las comillas los renderizar\u00e1 como textos. Los elementos HTML NO se puede renderizar de forma directa, habr\u00e1 que crearlos primero como elementos en React y luego ya se podr\u00e1n renderizar.</p> <p>Para poder crear elementos en React, existe la funci\u00f3n <code>createElement()</code> que recibe tres par\u00e1metros:</p> <ul> <li>El primero de ellos, hace referencia al elemento HTML que debe crear.</li> <li>El segundo, es un objeto con los atributos del elemento, como por ejemplo, su clase o su id.</li> <li>El tercero, es el contenido de dicho elemento. Puede ser un simple dato primitivo (por ejemplo una cadena), o uno o varios elementos de React.</li> </ul> <pre><code>import ReactDOM from \"https://esm.sh/react-dom@18.2.0/client\"\nimport React from \"https://esm.sh/react@18.2.0\"\nconst app = document.getElementById('app') // Obtenemos el elemento HTML que funcionar\u00e1 como ra\u00edz\nconst root = ReactDOM.createRoot(app) // Indicamos que elemento es la ra\u00edz\nconst button = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nroot.render(button)\n</code></pre> <p>La funci\u00f3n <code>render</code> solo puede renderizar un \u00fanico elemento a la vez. Si quisi\u00e9ramos renderizar por ejemplo varios botones, ser\u00eda necesario envolverlos en un elemento superior y renderizar dicho elemento:</p> <pre><code>import ReactDOM from \"https://esm.sh/react-dom@18.2.0/client\"\nimport React from \"https://esm.sh/react@18.2.0\"\nconst app = document.getElementById('app') // Obtenemos el elemento HTML que funcionar\u00e1 como ra\u00edz\nconst root = ReactDOM.createRoot(app) // Indicamos que elemento es la ra\u00edz\nconst button1 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst button2 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst button3 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst wrapped = React.createElement('div', null, [button1, button2, button3]);\nroot.render(wrapped)\n</code></pre>"},{"location":"tema_1/page-1/#react-fragment","title":"React Fragment","text":"<p>React a la hora de renderizar los elementos, los transforma a elementos de HTML, por lo que los a\u00f1ade al \u00e1rbol DOM de la p\u00e1gina. De esa forma, el ejemplo anterior pasar\u00eda a ser de la siguiente forma:</p> <pre><code>html\n    head\n        title\n        metas\n    body\n        div.root\n            div\n                button\n                button\n                button\n</code></pre> <p>De forma innecesario ha creado un div para envolver a los tres botones. Esta peque\u00f1a molestia puede provocar errores a cu\u00e1nto los estilos de CSS o incluso en la interactividad con el usuario, sino se tiene en cuenta. Pero, si tenemos que envolver los elementos React en un elemento superior para poder renderizar un solo elemento, \u00bfc\u00f3mo podemos evitar este peque\u00f1o inconveniente?</p> <p>React posee un elemento que puede ser usado como elemento superior pero a la hora de transformarlo a elementos HTML y a\u00f1adirlos al DOM, no crea un elemento innecesario. Este elemento se conoce como <code>Fragment</code>, por lo que de esta manera podemos hacer el ejemplo anterior de una forma mucho m\u00e1s limpia:</p> <pre><code>import ReactDOM from \"https://esm.sh/react-dom@18.2.0/client\"\nimport React from \"https://esm.sh/react@18.2.0\"\nconst app = document.getElementById('app') // Obtenemos el elemento HTML que funcionar\u00e1 como ra\u00edz\nconst root = ReactDOM.createRoot(app) // Indicamos que elemento es la ra\u00edz\nconst button1 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst button2 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst button3 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst wrapped = React.createElement(React.Fragment, null, [button1, button2, button3]);\nroot.render(wrapped)\n</code></pre> <p>De esta manera, el \u00e1rbol DOM queda m\u00e1s limpio y precavido de incidentes:</p> <pre><code>html\n    head\n        title\n        metas\n    body\n        div.root\n           button\n           button\n           button\n</code></pre> <p>A\u00fan as\u00ed, los ejemplos que hemos ido desarrollando usan una peculiaridad que quer\u00edamos evitar, la imperatividad. Para poder evitarla, ser\u00e1 necesario hacer JSX y crearnos un proyecto que nos facilite el trabajo.</p>"},{"location":"tema_1/page-1/#proyecto-react","title":"Proyecto React","text":"<p>Para poder hacer uso de la librer\u00eda ser\u00e1 necesario tener instalado NodeJS y un manejador de paquetes (npn, yarn, etc)</p> <p>Podemos crear react a trav\u00e9s de comandos diferentes: <code>npx create-react-app</code> o haciendo uso de <code>vite</code>. La primera opci\u00f3n es la forma nativa y recomendada por React en su API, pero cierto es que es una forma m\u00e1s anticuada y mucho m\u00e1s lenta</p> <pre><code>npx create-react-app example\ncd example\n</code></pre> <p>Para ejecutar el proyecto se usa el siguiente comando:</p> <pre><code>npm start\n</code></pre> <p>Vite ha creado un comando que hace que la creaci\u00f3n de un proyecto sea m\u00e1s sencillo y m\u00e1s r\u00e1pido:</p> <pre><code>npm  create vite@latest\ncd project\n</code></pre> <p>Para poder ejecutar el proyecto creado:</p> <pre><code>npm run dev\n</code></pre> <p>Una vez ejecutado el navegador predeterminado deber\u00e1 ser ejecutado con el proyecto en marcha. En caso de que no lo haga, se puede acceder a \u00e9l a trav\u00e9s de la URL http://localhost:<code>PORT</code>, donde el valor del puerto ser\u00e1 por defecto 3000, en caso de usar el comando oficial, y 5173 si se usa el gestor de vite.</p> <p>Adem\u00e1s al ejecutar el comando de creaci\u00f3n, se habr\u00e1 creado una estructura de proyecto similar a la siguiente (varia dependiendo de la versi\u00f3n del proyecto creado):</p> <p> Figura I - Estructura del proyecto</p> <p>Los ficheros y carpetas m\u00e1s importantes son:</p> <ul> <li>Carpeta node_modules: Esta carpeta contiene todas las librer\u00edas de React y las que vayamos instalando a trav\u00e9s de Node JS.</li> <li>public: En esta carpeta aparecen los archivos p\u00fablicos del proyecto, as\u00ed como las im\u00e1genes, las plantillas html, etc.</li> <li>src: Esta carpeta es la carpeta principal del proyecto y contiene todos los archivos necesarios para el desarrollo de nuestro proyecto, as\u00ed como los componentes y el archivo principal (<code>index.js</code> para el comando oficial y <code>main.jsx</code> para vite).</li> </ul> index.htmlindex.js/main.jsx <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\" /&gt;\n&lt;link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" /&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt;\n&lt;meta name=\"theme-color\" content=\"#000000\" /&gt;\n&lt;meta\nname=\"description\"\ncontent=\"Web site created using create-react-app\"\n/&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" /&gt;\n&lt;!--\n      manifest.json provides metadata used when your web app is installed on a\n      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/\n    --&gt;\n&lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" /&gt;\n&lt;!--\n      Notice the use of %PUBLIC_URL% in the tags above.\n      It will be replaced with the URL of the `public` folder during the build.\n      Only files inside the `public` folder can be referenced from the HTML.\n      Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will\n      work correctly both with client-side routing and a non-root public URL.\n      Learn how to configure a non-root public URL by running `npm run build`.\n    --&gt;\n&lt;title&gt;React App&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;\n&lt;div id=\"root\"&gt;&lt;/div&gt;\n&lt;!--\n      This HTML file is a template.\n      If you open it directly in the browser, you will see an empty page.\n      You can add webfonts, meta tags, or analytics to this file.\n      The build step will place the bundled scripts into the &lt;body&gt; tag.\n      To begin the development, run `npm start` or `yarn start`.\n      To create a production bundle, use `npm run build` or `yarn build`.\n    --&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals'; // (1)!\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n&lt;React.StrictMode&gt;\n&lt;App /&gt;\n&lt;/React.StrictMode&gt;\n);\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: &lt;https://bit.ly/CRA-vitals&gt;\nreportWebVitals(); // (1)!\n</code></pre> <ol> <li>Estas l\u00edneas han de ser eliminadas en caso de que no se vaya a usar los ficheros reportWebVitals.js y setUp.js</li> <li>Estas l\u00edneas han de ser eliminadas en caso de que no se vaya a usar los ficheros reportWebVitals.js y setUp.js</li> </ol>"},{"location":"tema_1/page-2/","title":"2 JSX","text":""},{"location":"tema_1/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>JSX es una extensi\u00f3n de sintaxis para JavaScript que permite escribir marcado similar a HTML dentro de una archivo JavaScript. Aunque hay otras formas de escribir componentes, la mayor\u00eda de los desarrolladores de React prefieren la concisi\u00f3n de JSX, y la mayor\u00eda de las bases de c\u00f3digo lo usan.</p> <pre><code>const element = &lt;h1&gt;Soy un elemento escrito en JSX&lt;/h1&gt;\n</code></pre> <p>Esta l\u00ednea de c\u00f3digo ser\u00eda equivalente a lo siguiente haciendo uso de React imperativo:</p> <pre><code>const element = React.createElement(h1, null, \"Soy un elemento escrito en JSX\")\n</code></pre>"},{"location":"tema_1/page-2/#poniendo-marcado-dentro-de-javascript","title":"Poniendo marcado dentro de Javascript","text":"<p>La Web se ha construido com\u00fanmente sobre archivos HTML, CSS y Javascript, de forma separada o en un \u00fanico fichero HTML. De esta forma, el contenido de la p\u00e1gina queda marcado con HTML, los estilos est\u00e1n indicados con CSS y la l\u00f3gica y funcionalidad de la p\u00e1gina en Javascript</p> <p>Al volverse las web m\u00e1s interactivas, el contenido de un p\u00e1gina se ve\u00eda determinado cada vez m\u00e1s por la l\u00f3gica, por ejemplo, al hacer clic en diferentes botones se muestra diferentes contenidos dentro de la misma p\u00e1gina.</p> <p>Esto supone una gran desventaja, y es que al no estar relacionados pierde seguridad y a\u00f1ade m\u00e1s trabajo y funcionalidad. Para ello, se implemento JSX.</p> <p>Los componentes de React contienen una funci\u00f3n de Javascript que puede contener alg\u00fan marcado que React muestra en el navegador. Dichos componentes usan la extensi\u00f3n <code>.jxs</code></p> <p>La sintaxis de JSX es muy parecida a la de HTML, pero con la diferencia que \u00e9sta es m\u00e1s estricta y puede mostrar informaci\u00f3n din\u00e1mica de una forma sencilla y segura.</p> <p>Note</p> <p>JSX y React son independientes. A menudo se usan en conjunto, pero se pueden usar de forma separada. JSX es una extensi\u00f3n de sintaxis, mientras React es una biblioteca de JavaScript.</p>"},{"location":"tema_1/page-2/#convertir-html-a-jsx","title":"Convertir HTML a JSX","text":"<p>Si queremos convertir un HTML a un JSX, no se puede hacer de forma literal, es decir, no podemos copiar los elementos HTML en un fichero JSX, ya que es m\u00e1s estricto y requiere de ciertas modificaciones. Por ejemplo, en el siguiente c\u00f3digo, dar\u00e1 un error en caso de querer ejecutarlo:</p> HTMLJSX <pre><code>&lt;h1&gt;Tareas Pendientes de Hedy Lamarr&lt;/h1&gt;\n&lt;img\nsrc=\"&lt;https://i.imgur.com/yXOvdOSs.jpg&gt;\"\nalt=\"Hedy Lamarr\"\nclass=\"photo\"\n&gt;\n&lt;ul&gt;\n&lt;li&gt;Inventar nuevo sem\u00e1foro\n    &lt;li&gt;Ensayar la escena de la pel\u00edcula\n    &lt;li&gt;Mejorar la tecnolog\u00eda del espectro\n&lt;/ul&gt;\n</code></pre> <pre><code>const element = // \u274c\u274c\u00a1Esto no funciona!\u274c\u274c\n&lt;h1&gt;Tareas Pendientes Hedy Lammar&lt;/h1&gt;\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclass=\"photo\"\n&gt;\n&lt;ul&gt;\n&lt;li&gt;Inventar nuevo sem\u00e1foro\n&lt;li&gt;Ensayar la escena de la pel\u00edcula\n&lt;li&gt;Mejorar la tecnolog\u00eda del espectro\n&lt;/ul&gt;\n</code></pre> <p>Para convertir un HTML a un JSX hay que seguir ciertas reglas de sintaxis:</p> <ol> <li> <p>Devolver un solo elemento ra\u00edz. Para devolver m\u00faltiples elementos de un componente, envu\u00e9lvelos con solo una etiqueta principal.</p> <pre><code>&lt;div&gt;\n&lt;h1&gt;Tareas pendientes Hedy Lammar&lt;/h1&gt;\n&lt;img src=\"https://i.imgur.com/yXOvdOSs.jpg\" alt=\"Hedy Lamarr\" class=\"photo\"\n&gt;\n&lt;ul&gt;\n//...\n&lt;/ul&gt;\n&lt;/div&gt;\n</code></pre> <p>En caso de que no quieras crear un elemento <code>div</code> para englobar el resto de elementos puedes hacer uso del Fragment, como hemos visto anteriormente.</p> <pre><code>&lt;React.Fragment&gt;\n&lt;h1&gt;Tareas pendientes Hedy Lammar&lt;/h1&gt;\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclass=\"photo\"\n&gt;\n&lt;ul&gt;\n//...\n&lt;/ul&gt;\n&lt;/React.Fragment&gt;\n</code></pre> <p>A la hora de usarlo con JSX no es necesario indicar <code>React.Fragment</code>, sino que se puede usar las etiquetas vac\u00edas <code>&lt;&gt;</code>:</p> <pre><code>&lt;&gt;\n&lt;h1&gt;Tareas pendientes Hedy Lammar&lt;/h1&gt;\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclass=\"photo\"\n&gt;\n&lt;ul&gt;\n//...\n&lt;/ul&gt;\n&lt;/&gt;\n</code></pre> <p>Warning</p> <p>JSX parece HTML, pero por debajo se transforma en objetos planos de JavaScript. No puedes devolver dos objetos desde una funci\u00f3n sin envolverlos en un array. Esto explica por qu\u00e9 tampoco puedes devolver dos etiquetas JSX sin envolverlas en otra etiqueta o Fragmento.</p> </li> <li> <p>Cerrar todas las etiquetas. JSX requiere que todas las etiquetas se cierren de forma expl\u00edcita, as\u00ed c\u00f3mo las etiquetas de cierre autom\u00e1tico como <code>&lt;img&gt;</code> deben convertirse en <code>&lt;img/&gt;</code>, y las etiquetas envolventes deben ser cerradas, como<code>&lt;li&gt;&lt;/li&gt;</code></p> <pre><code>&lt;&gt;\n&lt;h1&gt;Tareas Pendientes&lt;/h1&gt;\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclass=\"photo\"\n/&gt;\n&lt;ul&gt;\n&lt;li&gt;Inventar nuevo sem\u00e1foro&lt;/li&gt;\n&lt;li&gt;Ensayar la escena de la pel\u00edcula&lt;/li&gt;\n&lt;li&gt;Mejorar la tecnolog\u00eda del espectro&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/&gt;\n</code></pre> </li> <li> <p>Uso de lowerCamelCase: JSX se convierte en Javascript, por lo que los atributos de una etiqueta se convertir\u00e1n en keys de objetos Javascript as\u00ed como en variables. \u00c9sta tiene limitaciones en los nombres de las variables, como por ejemplo, no admite guiones ni puede contener palabras reservadas. Para evitar estos errores, los nombre de los atributos tendr\u00e1n que ser usados con la anotaci\u00f3n lowerCamelCase, y en caso de las palabras reservadas, como por ejemplo <code>class</code> tiene que haber un equivalente parecido como <code>className</code>. De esta forma, por ejemplo el atributo <code>stroke-width</code> pasar\u00e1 a ser <code>strokeWidth</code>.</p> <pre><code>//...\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclassName=\"photo\"\n/&gt;\n//...\n</code></pre> <p>Info</p> <p>Puedes encontrar todos estos atributos en la lista de props de los componentes DOM</p> </li> </ol> <p>Una vez realizado estos cambios nuestro HTML puede ser convertido exitosamente a JSX:</p> <pre><code>const elemento = &lt;&gt;\n// \u2705\u2705\u00a1Esto ya funciona!\u2705\u2705\n&lt;h1&gt;Tareas Pendientes Hedy Lammar&lt;/h1&gt;\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclassName=\"photo\"\n/&gt;\n&lt;ul&gt;\n&lt;li&gt;Inventar nuevo sem\u00e1foro&lt;/li&gt;\n&lt;li&gt;Ensayar la escena de la pel\u00edcula&lt;/li&gt;\n&lt;li&gt;Mejorar la tecnolog\u00eda del espectro&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/&gt;\n</code></pre> <p>Para a\u00f1adir c\u00f3digo Javascript dentro de los elementos JSX es necesario envolverlos en llaves <code>{}</code>:</p> <pre><code>const user = \"R\"\n&lt;h1&gt;Hello {user}&lt;/h1&gt;\n</code></pre> <p>Info</p> <p>Tambi\u00e9n puedes usar un convertidor online. Aunque es aconsejable ir practic\u00e1ndolo primero.</p>"},{"location":"tema_1/page-2/#expresiones","title":"Expresiones","text":"<p>Si queremos valuar alguna expresi\u00f3n en un elemento JSX ser\u00e1 necesario el uso de llaves <code>{}</code>:</p> <pre><code>const name = number % 2 == 0 ? 'isEven' : 'isOdd'\nconst element = &lt;h1 className={name}&gt;Este elemento tiene una clase llamada {name}&lt;/h1&gt;\n</code></pre> <p>Incluso se puede evitar la creaci\u00f3n de la variable:</p> <pre><code>const element = &lt;h1 className={number % 2 == 0 ? 'isEven' : 'isOdd'}&gt;Este elemento tiene una clase llamada {number % 2 == 0 ? 'isEven' : 'isOdd'}&lt;/h1&gt;\n</code></pre>"},{"location":"tema_1/page-3/","title":"3 Componentes","text":""},{"location":"tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Un componente es un funci\u00f3n renderizadora que puede ser reutilizada en otros componentes. Pueden estar separados en diferentes ficheros o estar incluidos en el mismo fichero.</p> <p>Un componente es una funci\u00f3n que devuelve c\u00f3digo JSX, por lo que se puede crear de forma habitual o de forma arrow functions:</p> <pre><code>const MyFirstComponent = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h2&gt;This is my first component&lt;/h2&gt;\n&lt;div&gt;This is my first component&lt;/div&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>La ventaja de usar componentes es que se puede reutilizar y escalar el c\u00f3digo de forma sencilla y segura. Por ejemplo, la p\u00e1gina web de twitter contiene much\u00edsimos elementos tweets, en ese caso, ser\u00eda l\u00f3gico pensar que cada tweet es un componente que recibe diferente tipo de informaci\u00f3n.</p>"},{"location":"tema_1/page-3/#componentes-de-clase","title":"Componentes de clase","text":"<p>Un componente de clase es una forma de definir componentes haciendo uso de la orientaci\u00f3n a objetos. Este m\u00e9todo est\u00e1 actualmente anticuado debido a las implementaciones de React 16.8, pero siguen siendo v\u00e1lidas.</p> <pre><code>import React, { Component } from 'react';\nclass MiComponenteDeClase extends Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\n// estado inicial\n};\n}\ncomponentDidMount() {\n// l\u00f3gica a ejecutar despu\u00e9s de que el componente se monta en el DOM\n}\ncomponentDidUpdate(prevProps, prevState) {\n// l\u00f3gica a ejecutar despu\u00e9s de que el componente se actualiza\n}\ncomponentWillUnmount() {\n// l\u00f3gica a ejecutar antes de que el componente sea desmontado\n}\nhandleClick = () =&gt; {\n// m\u00e9todo de clase\n};\nrender() {\n// m\u00e9todo obligatorio que devuelve el JSX a renderizar\nreturn (\n&lt;div&gt;\n{/* contenido del componente */}\n&lt;/div&gt;\n);\n}\n}\nexport default MiComponenteDeClase;\n</code></pre> <p>En el ejemplo anterior vemos un componente creado como clase, deriva de la clase <code>Component</code> adem\u00e1s hereda y sobrescribe m\u00e9todos de la misma clase para tratar con el estado, siendo el \u00fanico m\u00e9todo obligatorio el m\u00e9todo <code>render()</code>, encargado de la renderizaci\u00f3n del componente.</p> <p>Aunque no se recomienda su uso, si es bueno tener conocimientos de ellas por si debes tratar alg\u00fan d\u00eda con ellas.</p>"},{"location":"tema_1/page-3/#nomenclatura","title":"Nomenclatura","text":"<p>Los componentes est\u00e1n obligados a ser escritos en PascalCase (UpperCamelCase). React entiende a los elementos escrito de en min\u00fasculas como elementos HTML, por lo que si un componente est\u00e1 escrito de esa forma nunca lo reconocer\u00e1 como tal, sino como un elemento HTML, incluso si el elemento no existe, pero como el cat\u00e1logo HTML es tan amplio y puede seguir creciendo con el paso de los a\u00f1os, React no tiene forma de diferencias entre un componente y elemento HTML.</p> <pre><code>function myComponente() {\n// \u274c\u274c ESTO NO SE HACE\n}\nfunction MyComponents(){\n// \u2705\u2705 ESTA ES LA FORMA CORRECTA\n}\n</code></pre>"},{"location":"tema_1/page-3/#componentes-multiples","title":"Componentes m\u00faltiples","text":"<p>Un componente, al ser reutilizable, puede ser usado en varias ocasiones. Por ejemplo, el componente anterior puede ser usado en otro componente:</p> <pre><code>const App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Esta es mi app&lt;/h1&gt;\n&lt;MyFirstComponent /&gt;\n&lt;MyFirstComponent /&gt;\n&lt;MyFirstComponent /&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>A su vez, cada componente puede llamar otros componentes, generando as\u00ed un gran \u00e1rbol de componentes que puede interactuar entre ellos, facilit\u00e1ndonos as\u00ed el desarrollo de nuestra aplicaci\u00f3n web.</p>"},{"location":"tema_1/page-3/#atributos-de-los-componentes","title":"Atributos de los componentes","text":"<p>Para poder pasar datos a los componentes hacemos usos de los llamados props. Un props es un par\u00e1metro que se a\u00f1ade a la funci\u00f3n principal del componente e indica que permite recibir datos desde fuera de \u00e9l.</p> <pre><code>const MyComponent = (props) =&gt; {\n//...\n}\n</code></pre> <p>Dicho par\u00e1metro recibe un objeto que tiene como campos a los correspondientes que el usuario ha definido en la llamada del componente.</p> <pre><code>const App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Hola, bienvenido&lt;/h1&gt;\n&lt;MyComponent name=\"Rub\u00e9n\"/&gt;\n&lt;/&gt;\n)\n}\nconst MyComponent = (props) =&gt; {\nreturn (\n&lt;span&gt;Este es tu usuario {props.name}&lt;/span&gt;\n)\n}\n</code></pre> <p>Importante</p> <p>Es importante recalcar que el nombre de los componentes deben estar en may\u00fasculas capitalizada si no React los interpretar\u00e1 como c\u00f3digo HTML y mostrar\u00e1 un c\u00f3digo inexistente completamente vac\u00edo.</p> <p>Es importante destacar que el valor de los componente vayan entre comillas si se trata de un dato de tipo cadena, por el contrario, ya sea de otro tipo de dato u otro componente deber\u00eda usarse entre llave <code>{}</code>:</p> <pre><code>const App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Hola, bienvenido&lt;/h1&gt;\n&lt;MyComponent name=\"Rub\u00e9n\" isTrue={true} number={2} otherComponent={&lt;MyComponent/&gt;} /&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>Si el tipo de atributo que va a recibir el componente es booleano, se puede evitar el <code>param={true}</code> y poner directamente <code>param</code> como los atributos en HTML, por lo contrario si el valor es false se debe seguir usando las llaves <code>{}</code>:</p> <pre><code>const App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Hola, bienvenido&lt;/h1&gt;\n&lt;MyComponent name=\"Rub\u00e9n\" isTrue number={2} otherComponent={&lt;MyComponent/&gt;} /&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>Los props de los componentes tambi\u00e9n pueden ser pasados como un objeto nombrado para una mayor seguridad, incluso se puede indicar alg\u00fan valor por defecto para cada uno de ellos:</p> <pre><code>const MyComponent = ({name = ''}) =&gt; {\n//...\n}\n</code></pre> <p>OJO</p> <p>Si al componente se le indica un prop y \u00e9ste es usado por el componente, pero a la hora de usarlo no se indica, su valor por defecto es undefined y si esto no es controlado por el componente en ciertas ocasiones puede dar lugar a resultados no deseados.</p> <p>Se recomienda que los props en React sean inmutables, es decir, que no se puedan cambiar su valor dentro de ellos, para as\u00ed poder evitar problemas a la hora de escalar el componente. En su lugar se deber\u00eda crear un variable que contenga el valor de prop, y en caso de modificaci\u00f3n de modifique dicha variable:</p> <pre><code>const MyComponent = ({name = '', age}) =&gt; {\n// age = 30 \u274c\u274c No se deber\u00eda hacer esto\nconst copyAge = age // \u2705\u2705 En su lugar, se debe hacer esto\n}\n</code></pre> <p>Diferencia entre elemento y componente</p> <p>Llegados a este punto es importante recalcar que un elemento de React es lo que se renderiza para que interact\u00fae con el usuario, mientras que un componente es un funci\u00f3n factor\u00eda que se encarga de crear los elementos.</p> <p>Por otro lugar, se puede pasar los props de los componentes como una variable haciendo uso del spread-operator <code>...</code>, de esta forma har\u00e1 la transformaci\u00f3n correcto a varios props en lugar de un prop cuyo valor sea un objeto:</p> <pre><code>const props = {isFollowing, name='Sergio'}\nconst App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Hola, bienvenido&lt;/h1&gt;\n&lt;MyComponent props /&gt; // (1)! \n&lt;MyComponent {..props} /&gt; // (2)!\n&lt;/&gt;\n)\n}\n</code></pre> <ol> <li>\u274c\u274c De est\u00e1 forma crea un \u00fanico prop cuyo valor es el objeto</li> <li>\u2705\u2705 De est\u00e1 forma a\u00f1ade a los props, un prop por cada elemento del objeto</li> </ol>"},{"location":"tema_1/page-3/#hijos-de-un-componente","title":"Hijos de un componente","text":"<p>Un componente puede contener hijos y para ello debe recibir un prop llamado <code>children</code>:</p> <pre><code>const MyComponent = ({children, name = '', age}) =&gt; {\nreturn (\n&lt;div&gt;\n{children}\n&lt;/div&gt;\n)\n}\nconst App = () =&gt; {\n&lt;MyComponent&gt;\n&lt;h1&gt;Esto es un hijo del componente MyComponent&lt;/h1&gt;\n&lt;h2&gt;Esto es un otro hijo del componente MyComponent&lt;/h2&gt;\n&lt;/MyComponent&gt;\n}\n</code></pre> <p>En este caso, al tener hijos, no se puede usar la etiqueta auto-cierre (<code>&lt;MyComponent/&gt;</code>), en su lugar debe utilizar la etiqueta de apertura y cierre.</p>"},{"location":"tema_1/page-4/","title":"Proyecto","text":"<p>Haciendo uso de componentes, JSX, y estilos CSS crea la siguiente interfaz de Usuario:</p> <p> Soluci\u00f3n del proyecto</p>"},{"location":"tema_2/page-1/","title":"1 Introducci\u00f3n a los Hooks","text":""},{"location":"tema_2/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Un componente en React puede sufrir cambios. Podemos tener un bot\u00f3n con el mensaje de Seguir para comenzar a seguir una persona en una red social. Una vez clicado el bot\u00f3n comenzamos a seguir a dicha persona,por lo que no tiene sentido que siga apareciendo el mensaje de Seguir si no uno que indique que ya se est\u00e1 siguiente. Podemos realizar este cambio en la interfaz haciendo uso de una nueva renderizaci\u00f3n.</p> <p> Figura 1 - Cambios de un elemento</p> <p>Debemos tener en cuenta que cuando queremos que una renderizaci\u00f3n se haga es para poder reflejar los cambios en la interfaz de usuario. Supongamos que tenemos un componente que contiene otro componente que retorna el bot\u00f3n, el mensaje de texto lo recibe un prop, pero se puede cambiar y se realiza en el componente padre.</p> <pre><code>const App = () =&gt;{\nconst changeText = () =&gt; {\ntext = \"Mensaje nuevo\"\n// ...\n}\nreturn (\n&lt;p onClick={changeText}&gt;Si clicas aqu\u00ed cambias el texto del bot\u00f3n&lt;/p&gt;\n&lt;Button text=\"Mensaje del bot\u00f3n\"/&gt;\n)\n}\n</code></pre> <p>Al querer que ese cambio se vea reflejado, podemos hacer que se vuelva a renderizar. Por el contrario, si el cambio de texto de un bot\u00f3n sucede dentro desde el mismo bot\u00f3n, podemos hacer uso de la propiedad <code>target</code> del evento asociado, de esta forma no ser\u00e1 necesaria una renderizaci\u00f3n.</p> <pre><code>const App = () =&gt; {\nconst toggleFollow = e =&gt; {\nconst target = e.target\nif(target.innerText === 'Seguir'){\ntarget.innerText = 'Siguiendo'\n} else {\ntarget.innerText = 'Seguir'\n}\n}\nreturn (\n&lt;&gt;\n&lt;button onClick={toggleFollow}&gt;Seguir&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre>"},{"location":"tema_2/page-1/#ciclo-de-vida-de-un-componente","title":"Ciclo de vida de un componente","text":"<p>En React, los componentes pasan por diferentes fases durante su ciclo de vida. Sin embargo, con la introducci\u00f3n de los hooks en React 16.8, el t\u00e9rmino ciclo de vida ha cambiado un poco. Antes, los componentes de clase ten\u00edan m\u00e9todos de ciclo de vida, pero con los hooks, los componentes de funci\u00f3n tambi\u00e9n pueden tener un ciclo de vida.</p> <p> Figura 2 - Ciclo de vida de un componente</p> <ol> <li>Inicializaci\u00f3n. Sucede cuando se crea una instancia del componente e inicializa su estado. En los componente de clase ser\u00eda la llamada al <code>constructor()</code>.</li> <li>Montaje. Adapta las propiedades del componente y lo renderiza. Tambi\u00e9n se realiza las operaciones iniciales que sean requeridas por el DOM. Por ejemplo, hacer una llamada a una API. En los componente de clase se llamar\u00eda a los siguientes m\u00e9todos en este orden: <code>static getDerivedStateFromProps()</code>, <code>render()</code>, <code>componentDidMount()</code>.</li> <li>Actualizaci\u00f3n. Sucede cuando se produce un cambio en el estado del componente, es decir, en algunas de sus propiedades. Se va renderizando cada uno de los elementos que sea necesario, si no se produce ning\u00fan cambio se evita la actualizaci\u00f3n para as\u00ed optimizar el rendimiento. Los m\u00e9todos de los componentes de clase a llamar son: <code>static getDerivedStateFromProps()</code>, <code>shouldComponentUpdate()</code>, <code>render()</code>, <code>getSnapshotBeforeUpdate()</code>, <code>componentDidUpdate()</code>.</li> <li>Desmontaje. Sucede justo antes de que el componente sea eliminado del \u00e1rbol DOM. <code>componentWillUnmount()</code></li> </ol>"},{"location":"tema_2/page-1/#hooks","title":"Hooks","text":"<p>Un hook es una funci\u00f3n especial de React que te permite llevar a cabo ciertas tareas, como por ejemplo, manejar el estado de un componente, compartir el contexto, etc.</p> <p>Los hooks fueron a\u00f1adidos en la versi\u00f3n 16.8 de React, para poder tratar con el tema de los estados de una forma m\u00e1s sencilla en los componentes de funci\u00f3n. Los hooks no funcionan con los componentes de clases ya que estos manejan el estado de una forma m\u00e1s diferente y ya implementada.</p> <p>Algunos de los hooks m\u00e1s comunes son:</p> <ul> <li><code>useRef()</code>: Sirve para referenciar un elemento.</li> <li><code>useState()</code>: Sirve para manejar estados de un componente.</li> <li><code>useEffect()</code>: Permite realizar efectos secundarios en componentes de funci\u00f3n, como solicitudes de red o manipulaciones DOM.</li> <li><code>useContext()</code>: Permite acceder al contexto de React dentro de un componente.</li> <li><code>useReducer()</code>: Es una alternativa a <code>useState()</code>, por lo que tambi\u00e9n, sirve para gestionar el estado de un componente.</li> </ul>"},{"location":"tema_2/page-1/#useref","title":"useRef","text":"<p><code>useRef</code> es un hook de React que te permite referenciar un valor que no es necesario renderizarlo. Se trata de una herramienta poderosa que ofrece una gran flexibilidad y unas capacidades inmensas, pero los desarrolladores a menudo lo malinterpretan y lo utilizan incorrectamente.</p> <p>El hook <code>useRef</code> tiene dos prop\u00f3sitos principales:</p> <ul> <li>Almacenar valores mutables que no provocan una nueva renderizaci\u00f3n cuando se actualizan.</li> <li>Almacenar referencias a elementos DOM.</li> </ul> <p>Cuando un componente se renderiza en React, normalmente se restablecen su estado y otras variables. Sin embargo, hay casos en los que necesitas conservar ciertos valores incluso cuando el componente se vuelva a renderizar a un valor que persistir\u00e1 entre renderizaciones, asegurando que ell valor permanece intacto aunque cambien otras partes del componente. Adem\u00e1s, es fundamental para trabajar con elementos DOM.</p> <p>En React, acceder a los elementos del DOM y modificarlos directamente puede resultar complicado, especialmente sin el Hook <code>useRef</code>. Con \u00e9l, puedes obtener una referencia a un elemento DOM concreto y realizar operaciones sobre \u00e9l. Esto elimina la necesidad de bibliotecas externas o de complicadas soluciones.</p> <p>Para usar el hook, ser\u00e1 necesario primero importarlo de la librer\u00eda de <code>react</code>, y luego crear una constante que almacene dicha referencia:</p> <pre><code>import {useRef} from 'react'\nconst myRef = useRef()\n</code></pre> <p>Una vez creado el objeto ref se puede utilizar para almacenar valores y acceder a ellos. Se le puede asignar a la prop <code>ref</code> del elemento que nos interese:</p> <pre><code>&lt;div ref={myRef}&gt;This is an element&lt;/div&gt;\n</code></pre> <p>Para acceder al valor de la referencia, se usa la propiedad <code>current</code> del objeto ref:</p> <pre><code>const value = myRef.current\nconsole.log(value) // &lt;div&gt;This is an element&lt;/div&gt;\n</code></pre> <p>Manipular el DOM es una tarea habitual en el desarrollo web porque te permite cambiar y actualizar din\u00e1micamente el contenido, la estructura y la apariencia de una p\u00e1gina web. En el desarrollo tradicional de JavaScript, acceder y manipular elementos del DOM requer\u00eda utilizar m\u00e9todos como <code>getElementById</code>, <code>querySelector</code>, o <code>getElementsByClassName</code> para seleccionar elementos espec\u00edficos del documento. Una vez seleccionados, puedes actualizar el contenido, modificar los estilos o adjuntar escuchadores de eventos.</p> <pre><code>// HTML\n&lt;div&gt;\n&lt;input type=\"text\" id=\"myInput\" /&gt;\n&lt;button id=\"focusButton\"&gt;Focus Input&lt;/button&gt;\n&lt;/div&gt;\n// JavaScript\n&lt;script&gt;\nconst inputRef = document.getElementById('myInput');\nconst focusButton = document.getElementById('focusButton');\nconst handleFocus = function() {\ninputRef.focus();\n};\nfocusButton.addEventListener('click', handleFocus);\n&lt;/script&gt;\n</code></pre> <p>Sin embargo, cuando se trabaja con elementos del DOM en un componente React, el proceso no es el mismo debido al DOM virtual del componente y a la necesidad de gestionar las actualizaciones de forma eficiente. A menudo, los desarrolladores recurren a diversos enfoques, como el uso de <code>refs</code> o librer\u00edas externas como <code>jQuery</code>, para acceder a los elementos del DOM y manipularlos.</p> <p>Con la introducci\u00f3n del Hook <code>useRef</code> en React, el proceso de trabajar con elementos DOM dentro de los componentes se ha agilizado significativamente. El Hook useRef proporciona una forma directa de crear una referencia a un elemento DOM, haci\u00e9ndolo f\u00e1cilmente accesible y manipulable dentro del contexto del componente.</p> <pre><code>import { useRef } from 'react';\nconst FocusComponent = () =&gt; {\nconst inputRef = useRef(null);\nconst handleFocus = () =&gt; {\n// accessing the input element\nlet inputElement = inputRef.current;\n// modify the DOM element\ninputElement.focus();\n};\nreturn (\n&lt;div&gt;\n&lt;input type=\"text\" ref={inputRef} /&gt;\n&lt;button onClick={handleFocus}&gt;Focus Input&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre>"},{"location":"tema_2/page-1/#proyecto-twitterfollowcard","title":"Proyecto TwitterFollowCard","text":"<p>En este proyecto vamos a crear una tarjeta de usuario de twitter, en la cual, se va modificar el bot\u00f3n cada vez que se interact\u00fae sobre \u00e9l.</p> <p> Figura 3 - Proyecto useRef</p> <p>En nuestro archivo principal, <code>main.js</code>, hacemos nuestra llamada a nuestro componente principal <code>App</code>:</p> <pre><code>import ReactDOM from 'react-dom/client'\nimport { App } from './App'\nimport './index.css'\nconst root = ReactDOM.createRoot(document.getElementById('root'))\nroot.render(\n&lt;App /&gt;\n)\n</code></pre> <p>Nuestro componente principal hace una llamada a nuestro componente <code>TwitterFollowCard</code>, 5 veces:</p> <pre><code>import './App.css'\nimport { TwitterFollowCard } from './TwitterFollowCard'\nexport function App() {\nreturn (\n&lt;section className='App'&gt;\n&lt;TwitterFollowCard isFollowing username=\"selenagomez\" name=\"Selena Gomez\" /&gt;\n&lt;TwitterFollowCard username=\"taylorswift13\" name=\"Taylor Swift\" /&gt;\n&lt;TwitterFollowCard isFollowing username=\"midudev\" name=\"Miguel \u00c1ngel Duran\" /&gt;\n&lt;TwitterFollowCard isFollowing username=\"irubenboy\" name=\"Rub\u00e9n Moreno Narbona\" /&gt;\n&lt;TwitterFollowCard isFollowing name=\"Desconocido\" /&gt;\n&lt;/section&gt;\n)\n}\n</code></pre> <p>El componente <code>TwitterFollowCard</code> contiene los elementos principales para tratar con los elementos, incluido una referencia para trabajar con el bot\u00f3n:</p> <pre><code>import { useRef } from 'react'\nexport function TwitterFollowCard({ username = 'unknown', name, isFollowing = false }) {\nconst buttonRef = useRef()\nconst followedClassName = 'tw-followCard-button-followed'\nconst handlerButtonClick = () =&gt; {\nif (buttonRef.current.classList.contains(followedClassName)) {\nbuttonRef.current.classList.remove(followedClassName)\nbuttonRef.current.innerText = 'Seguir'\n} else {\nbuttonRef.current.classList.add(followedClassName)\nbuttonRef.current.innerHTML = ''\n}\n}\nreturn (\n&lt;article className='tw-followCard'&gt;\n&lt;header className='tw-followCard-header'&gt;\n&lt;img className='tw-followCard-avatar' src={`https://unavatar.io/twitter/${username}`} alt=\"Avatar\" /&gt;\n&lt;div className='tw-followCard-info'&gt;\n&lt;strong&gt;{name}&lt;/strong&gt;\n&lt;span className='tw-followCard-infoUsername'&gt;@{username}&lt;/span&gt;\n&lt;/div&gt;\n&lt;/header&gt;\n&lt;aside&gt;\n&lt;button\nref={buttonRef}\nclassName={`tw-followCard-button${isFollowing ? (' ' + followedClassName) : ''}`}\nonClick={handlerButtonClick}\n&gt;\n{isFollowing ? \"\" : \"Seguir\"}\n&lt;/button&gt;\n&lt;/aside&gt;\n&lt;/article&gt;\n)\n}\n</code></pre> <p>M\u00e1s detalladamente, el elemento <code>button</code> es el que contiene la referencia:</p> <pre><code>const buttonRef = useRef()\n//...\nreturn (\n//...\n&lt;button ref={buttonRef}&gt;//...&lt;/button&gt;\n)\n</code></pre> <p>Manejaremos el contenido haciendo uso de la clase <code>tw-followCard-button-followed</code> si es seguido, por el contrario el elemento, no contendr\u00e1 dicha clase. Este ser\u00eda el CSS del bot\u00f3n:</p> <pre><code>.tw-followCard-button {\nmargin-left: 16px;\nborder: 0;\nborder-radius: 999px;\npadding: 6px 16px;\nfont-weight: bold;\ncursor: pointer;\n}\n.tw-followCard-button:hover {\nbackground-color: #a3a3a3;\ntransition: .3s ease background-color;\n}\n.tw-followCard-button-followed {\nbackground-color: transparent;\ncolor: white;\nborder: 0.5px solid white;\n}\n.tw-followCard-button-followed::after {\ncontent: 'Siguiendo';\n}\n.tw-followCard-button-followed:hover {\ncolor: rgb(190, 47, 47);\nborder-color: rgb(190, 47, 47);\nbackground-color: rgb(190, 47, 47, .25);\n}\n.tw-followCard-button-followed:hover::after {\ncontent: 'Dejar de seguir';\ntransition: background-color 0.1s linear 0.1s;\n}\n</code></pre> <p>Y con el m\u00e9todo <code>handleButtonClick</code> manejamos la acci\u00f3n de hacer clic al bot\u00f3n:</p> <pre><code>const handlerButtonClick = () =&gt; {\nif (buttonRef.current.classList.contains(followedClassName)) {\nbuttonRef.current.classList.remove(followedClassName)\nbuttonRef.current.innerText = 'Seguir'\n} else {\nbuttonRef.current.classList.add(followedClassName)\nbuttonRef.current.innerHTML = ''\n}\n}\n</code></pre> <p>En el c\u00f3digo anterior, gracias a la propiedad <code>current</code> de la referencia, podemos acceder a la propiedad <code>classList</code> que devuelve la lista de clases del elemento. De esta manera, comprobando si contiene o no la clase <code>tw-followCard-button-followed</code> se le eliminar\u00e1 o a\u00f1adir\u00e1 dicha clase, respectivamente, adem\u00e1s de que se le indique un texto Seguir en caso de que la contenga, y nada en caso de que no la contenga (en ese caso, el texto es manejado con CSS que al a\u00f1adir la clase trabajar\u00e1 con las propiedad <code>hover</code> y <code>after</code>)</p>"},{"location":"tema_2/page-2/","title":"2 Estados","text":""},{"location":"tema_2/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>El estado de un componente son las diferentes formas en las que se puede presentar un componente. Supongamos que tenemos un componente llamado l\u00e1mpara y su estado puede ser apagado o encendido. Para que se produzca dicho cambio de estado necesitamos tener un desencadenante, en el caso de la l\u00e1mpara ser\u00eda un interruptor.</p> <p>En React existen varias formas para poder trabajar con los estados. Si usamos componentes de clase, existe un atributo <code>state</code> que controlar\u00e1 esas variables que funcionen como desencadenante, pero para los componentes funci\u00f3n tienen un hook.</p>"},{"location":"tema_2/page-2/#usestate","title":"useState","text":"<p>El <code>useState</code> es un hook en React que controla el estado de un componente. Dicho hook puede recibir un estado inicial:</p> <pre><code>const state = useState(false)\n</code></pre> <p>El m\u00e9todo <code>useState([initial])</code> devuelve un array de tama\u00f1o dos, siendo la primera posici\u00f3n el valor del estado y el segundo el m\u00e9todo que desencadena el cambio, por lo que para un mayor entendimiento se puede usar la destructuraci\u00f3n:</p> <pre><code>const [light, setLight] = useState(false)\n</code></pre> <p>El cambio de estado de un componente produce que se vuelva a renderizar. Cuando se cambia el estado el DOM Virtual de React solo actualizar\u00e1 aquella parte que cambia, salt\u00e1ndose las partes que no sufren cambio ninguno. Para ello, busca las diferentes entre el componente antes del cambio y despu\u00e9s del cambio, lo que se diferente despu\u00e9s del cambio es lo \u00fanico que se va a actualizar.</p> <pre><code>const App = () =&gt; {\nconst [count, setCount] = useState(0)\nreturn (\n&lt;&gt;\n&lt;h1&gt;Has clicado el bot\u00f3n {count} veces&lt;/h1&gt;\n&lt;button onClick={() =&gt; setCount(count+1)}&gt;Cambiar estado&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>En el ejemplo anterior, al hacer clic en el bot\u00f3n, cambia el valor de la variable <code>count</code>, haciendo que el componente se renderice, actualizando \u00fanicamente el elemento <code>h1</code>.</p> <p>Cuando React renderiza elementos en el DOM, utiliza un algoritmo de conciliaci\u00f3n (reconciliaci\u00f3n) para comparar el nuevo \u00e1rbol de elementos con el \u00e1rbol anterior y determinar las diferencias. El prop\u00f3sito de las keys es ayudar a React a identificar de manera \u00fanica cada elemento y realizar operaciones de manera eficiente.</p> <p>Cuando se renderiza un componente por un cambio de estado, estos cambios se propagan hacia abajo, es decir, van desde los componentes padres a los componentes hijos. Otra forma de decirlo, cuando se renderiza un componente padre se vuelve a renderizar un componente hijo independientemente de que en el componente hijo nada haya cambiado y por lo tanto no se actualice nada. Sin embargo, no sucede al rev\u00e9s, si se renderiza un hijo por el cambio de estado, no se va a renderizar el padre.</p> <pre><code>const App = () =&gt; {\nconst [count, setCount] = useState(0)\nreturn (\n&lt;&gt;\n&lt;H1Componente count={count} /&gt;\n&lt;button onClick={() =&gt; setCount(count+1)}&gt;Cambiar estado&lt;/button&gt;\n&lt;/&gt;\n)\n}\nconst H1Componente = ({count = 0}) =&gt; {\nreturn (\n&lt;h1&gt;Has clicado el bot\u00f3n {count} veces&lt;/h1&gt;\n)\n}\n</code></pre> <p>En el ejemplo anterior, al hacer clic al bot\u00f3n del componente <code>App</code> se renderizar\u00e1 el componente <code>App</code>, as\u00ed como su componente hijo <code>H1Componente</code>. En este caso los cambios se ver\u00e1 reflejado en el hijo ya que la variable que cambia si se hace referencia en el componente hijo, aunque no tiene porque ser as\u00ed, el renderizado SI se hace pero la actualizaci\u00f3n s\u00f3lo si es necesaria.</p> <p>Si el componente hijo tambi\u00e9n tiene un estado, se puede inicializar dicho estado a trav\u00e9s de la props y realizar el cambio desde el interior del componente.</p> <pre><code>const App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;Component initialCount={0} /&gt;\n&lt;/&gt;\n)\n}\nconst Component = ({initialCount = 0}) =&gt; {\nconst [count, setCount] = useState(initialCount)\nreturn (\n&lt;h1&gt;Has clicado el bot\u00f3n {count} veces&lt;/h1&gt;\n&lt;button onClick={() =&gt; setCount(count+1)}&gt;Cambiar estado&lt;/button&gt;\n)\n}\n</code></pre> <p>\u00a1Cuidad!</p> <p>El estado de un componente solo se inicializa una sola vez, por lo que si en el padre se cambia el estado de una variable y dicha variable inicializa el estado del hijo, SOLO se inicializa en la primera renderizaci\u00f3n. Cada vez que se vuelva a renderizar no sufrir\u00e1 cambios.</p> <pre><code>const App = () =&gt; {\nconst [count, setCount] = useState(0) return (\n&lt;&gt;\n&lt;Component initialCount={count} /&gt;\n&lt;button onClick={() =&gt; setCount(count+1)}&gt;Cambiar inicializaci\u00f3n&lt;/button&gt;\n&lt;/&gt;\n)\n}\nconst Component = ({initialCount = 0}) =&gt; {\nconst [count, setCount] = useState(initialCount) //(1)!\nreturn (\n&lt;h1&gt;Has clicado el bot\u00f3n {count} veces&lt;/h1&gt;\n&lt;button onClick={() =&gt; setCount(count+1)}&gt;Cambiar estado&lt;/button&gt;\n)\n}\n</code></pre> <ol> <li>Solo se inicializa una vez</li> </ol>"},{"location":"tema_2/page-2/#clave-de-un-elemento","title":"Clave de un elemento","text":"<p>\u00bfC\u00f3mo puede React identificar los elemento para saber que son diferentes? Si tenemos un componente con 5 elementos <code>h1</code>, \u00bfc\u00f3mo sabe que el primero no es el mismo que el segundo? Ambos elementos podr\u00edan tener el mismo contenido, pero a\u00fan as\u00ed son elementos diferentes.</p> <p>React sabe diferencia un elemento de otro gracias a su posici\u00f3n en el DOM Virtual, lo que no suponen problema a la hora de una nueva renderizaci\u00f3n, por lo que React puede seguir gestionando la reconciliaci\u00f3n de manera eficiente sin necesidad de nada que identifique al elemento.</p> <p>Pero, supongamos que tenemos una lista de usuarios y cada usuario queremos mostrarlo en un componente. Ser\u00e1 necesario hacer un ciclo que recorra dicha lista y crear el elemento del componente con los datos necesarios:</p> <pre><code>const App = () =&gt; {\nconst users = [\n{id: 1, name: 'Nerea'},\n{id: 2, name: 'Sofia'},\n{id: 3, name: 'Leticia'},\n{id: 4, name: 'Marcos'},\n]\nreturn (\nusers.map(user =&gt; &lt;UserComponent name={user.name}/&gt;)\n)\n}\nconst UserComponent = ({name = ''}) =&gt; {\n&lt;h1&gt;Hello {name}&lt;/h1&gt;\n}\n</code></pre> <p>Recuerda</p> <p>No se puede usar estructuras dentro de c\u00f3digo JSX (if, for, etc). Se debe usar funciones que devuelvan elementos o datos, como <code>map</code>, o una ternaria. </p> <p>Si se cambiase el estado de el componente <code>App</code> renderizar\u00eda una vez m\u00e1s la lista, lo que no asegura que el orden se mantenga igual antes que el cambio de estado. Por lo que, para React es m\u00e1s complicado identificar la diferencia cada uno de los elementos del DOM Virtual.</p> <p>Para evitar este problema, React dispone de un atributo llamado <code>key</code> que sirve como identificador de los elementos de React, que se recomienda su uso en los elementos que est\u00e9n dentro de un ciclo, para poder identificarlos y en caso de renderizaci\u00f3n comprobar si han sufridos cambios para actualizarlos. El valor de dicho atributo debe ser un valor \u00fanico y est\u00e1tico, por lo que no se recomienda el uso de funciones como <code>Math.random()</code> o <code>Symbol()</code> (que pueden cambiar con cada renderizaci\u00f3n), ni propiedades que puedan cambiar (como el nombre de un usuario).</p> <pre><code>const App = () =&gt; {\nconst users = [\n{id: 1, name: 'Nerea'},\n{id: 2, name: 'Sofia'},\n{id: 3, name: 'Leticia'},\n{id: 4, name: 'Marcos'},\n]\nreturn (\nusers.map(user =&gt; &lt;UserComponent key={id} name={user.name}/&gt;)\n)\n}\nconst UserComponent = ({name = ''}) =&gt; {\n&lt;h1&gt;Hello {name}&lt;/h1&gt;\n}\n</code></pre> <p>El uso del atributo <code>key</code> NO es obligatorio, pero es una buena pr\u00e1ctica proporcionar keys \u00fanicas siempre que sea posible, incluso para elementos individuales que no provienen de un ciclo. Esto se debe a que puede haber casos en los que, en el futuro, el componente o el elemento pueda cambiar de manera din\u00e1mica, y tener una key \u00fanica puede ayudar a React a optimizar la actualizaci\u00f3n y renderizaci\u00f3n del componente de manera m\u00e1s eficiente.</p>"},{"location":"tema_2/page-2/#proyecto-twitterfollowcard-con-usestate","title":"Proyecto TwitterFollowCard con useState","text":"<p>En este proyecto vamos a mejorar el proyecto TwitterFollowCard, pero en lugar de usar <code>useRef</code> usaremos <code>useState</code>. Es m\u00e1s, en este proyecto tiene m\u00e1s sentido el uso de <code>useState</code> en lugar de <code>useRef</code>, ya que una de las caracter\u00edsticas de React es que usa la programaci\u00f3n declarativa, y el <code>useRef</code> nos obligaba en parte a utilizar la programaci\u00f3n imperativa.</p> <p>En primer lugar, creamos una lista con los usuarios que queremos mostrar y haciendo uso de la funci\u00f3n <code>map</code> transformamos dicha lista en el componente <code>TwitterFollowCard</code>, identificando dicho componente con el nombre de usuario. Adem\u00e1s, en lugar de recibir si se est\u00e1 siguiendo o no al usuario, sino que se le pasa el estado inicial, ya que puede ser cambiado.</p> <pre><code>const users = [\n{\nusername: 'selenagomez',\nname: 'Selena Gomez',\nisFollowing: true\n},\n{\nusername: 'taylorswift13',\nname: 'Taylor Swift',\nisFollowing: false\n},\n{\nusername: 'midudev',\nname: 'Miguel \u00c1ngel Duran',\nisFollowing: true\n},\n{\nusername: 'irubenboy',\nname: 'Rub\u00e9n Moreno Narbona',\nisFollowing: false\n},\n{\nname: 'Desconocido',\n}\n]\nexport function App() {\nreturn (\n&lt;section className='App'&gt;\n{\nusers.map(({ username, isFollowing, name }) =&gt; (&lt;TwitterFollowCard\nkey={username}\nusername={username}\ninitialIsFollowing={isFollowing}\nname={name}\n/&gt;))\n}\n&lt;/section&gt;\n)\n}\n</code></pre> <p>Ahora en el componente <code>TwitterFollowCard</code>, se tratar\u00e1 el estado, forzando el cambio cada vez que se clique el bot\u00f3n, y se jugar\u00e1 con las clases del bot\u00f3n, pero usando la programaci\u00f3n declarativa, en lugar de la imperativa.</p> <pre><code>export function TwitterFollowCard({ username = 'unknown', name, initialIsFollowing = false }) {\nconst [isFollowing, setIsFollowing] = useState(initialIsFollowing)\nconst text = isFollowing ? '' : 'Seguir'\nconst buttonClassName = isFollowing ? 'tw-followCard-button is-following' : 'tw-followCard-button'\nconst handleClick = () =&gt; {\nsetIsFollowing(!isFollowing)\n}\nreturn (\n&lt;article className='tw-followCard'&gt;\n&lt;header className='tw-followCard-header'&gt;\n&lt;img className='tw-followCard-avatar' src={`https://unavatar.io/twitter/${username}`} alt=\"Avatar\" /&gt;\n&lt;div className='tw-followCard-info'&gt;\n&lt;strong&gt;{name}&lt;/strong&gt;\n&lt;span className='tw-followCard-infoUsername'&gt;@{username}&lt;/span&gt;\n&lt;/div&gt;\n&lt;/header&gt;\n&lt;aside&gt;\n&lt;button className={buttonClassName} onClick={handleClick}&gt;{text}&lt;/button&gt;\n&lt;/aside&gt;\n&lt;/article&gt;\n)\n}\n</code></pre> <p>Importante</p> <p>El estado no se puede mutar de forma directa, es decir, no puedes cambiar su valor directamente. Por ejemplo, si usamos el useState con una lista, no se aconseja a\u00f1adir elementos de forma manual:</p> <pre><code>const [list, setList] = useState([])\nconst update = () =&gt; {\nlist.push('a') // \u274c \u00a1NO!  \n}\n</code></pre> <p>Esto puede provocar resultados no deseados e incluso puede que no se renderice el componente, lo que puede desembocar en discrepancias con el estado. En su lugar, se recomienda hacer el spread operator dentro del m\u00e9todo <code>set</code> del estado:</p> <pre><code>const [list, setList] = useState([])\nconst update = () =&gt; {\nsetList([...list, 'a']) // \u2705 \n}\n</code></pre>"},{"location":"tema_2/page-2/#estado-asincrono","title":"Estado as\u00edncrono","text":"<p>La actualizaci\u00f3n de los estados en React son as\u00edncronos, es decir, no bloquean el renderizado ni el c\u00f3digo que viene a continuaci\u00f3n del cambio de estado. Por ese motivo, si se cambia el estado y autom\u00e1ticamente se accede al mismo, puede que el estado a\u00fan no haya sido actualizado y estemos accediendo a un valor anterior:</p> <pre><code>const [isFollowing, setIsFollowing] = useState(false)\nconst handleClick = () =&gt; {\nsetIsFollowing(true)\nconsole.log(isFollowing) // false\n}\n</code></pre> <p>Aunque sea as\u00edncrono NO se puede usar el await porque no se debe romper el flujo.</p> <p>El m\u00e9todo de actualizaci\u00f3n de un estado puede recibir un callback cuyo par\u00e1metro sea el valor anterior, y retorne el nuevo valor.</p> <pre><code>const [isFollowing, setIsFollowing] = useState(false)\nconst update = () =&gt; {\nuseState((prev) =&gt; {\nconsole.log(prev) // Se accede al valor anterior\nreturn !prev // actualiza estado\n})\n}\n</code></pre> <p>Los estados tambi\u00e9n pueden recibir un callback en sus inicializaci\u00f3n, para inicializar el estado a trav\u00e9s de una l\u00f3gica, o inicializarlo con una operaci\u00f3n lenta que queramos que se haga una sola vez:</p> <pre><code>const [state, setState] = useState(() =&gt; {\nconst random = Math.random()\nif(random % 2 === 0){\nreturn random\n}\nreturn 0\n})\n</code></pre>"},{"location":"tema_2/page-3/","title":"3 Efectos","text":""},{"location":"tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>En React, los efectos son acciones que ocurren fuera del flujo de renderizado normal y que generalmente est\u00e1n relacionadas con la interacci\u00f3n con el DOM, llamadas a servicios web, suscripciones a eventos o cualquier otra operaci\u00f3n as\u00edncrona.</p> <p>En versiones anteriores de React, para manejar efectos secundarios, se utilizaban principalmente los m\u00e9todos de ciclo de vida de los componentes de clase, como <code>componentDidMount</code> y <code>componentDidUpdate</code>. Sin embargo, con la introducci\u00f3n de React Hooks en React 16.8, la gesti\u00f3n de efectos secundarios se ha vuelto m\u00e1s sencilla y flexible.</p> <p>En el contexto de React Hooks, el hook <code>useEffect</code> se utiliza para manejar efectos secundarios en componentes funcionales.</p>"},{"location":"tema_2/page-3/#useeffect","title":"useEffect","text":"<p>El <code>useEffect</code> es un hook que nos permite ejecutar c\u00f3digo arbitrario cuando el componente se monta en el DOM y cada vez que se actualiza las dependencias que le indiquemos. El <code>useEffect</code> es un m\u00e9todo que recibe dos par\u00e1metros: un callback que se ejecutar\u00e1 cuando se monta el DOM, ya sea al principio o a cambiar el estado de alguna de las dependencias (este par\u00e1metro es obligatorio); y una lista de dependencias de las que depender\u00e1 el <code>useEffect</code>, que en caso de que cambien de estado producir\u00e1 una nueva llamada del callback:</p> <pre><code>useEffect(callback, [dependencias])\n</code></pre> <p>El <code>useEffect</code> se ejecuta m\u00ednimo una vez, cuando el componente se monta por primera vez en el DOM.</p> <pre><code>useEffect(() =&gt; {\nconsole.log('Probando use effect')\n})\nconst App = () =&gt; {\nreturn (\n&lt;h1&gt;Prueba del efecto&lt;/h1&gt;\n)\n}\n</code></pre>"},{"location":"tema_2/page-3/#dependencias","title":"Dependencias","text":"<p>Las dependencias del <code>useEffect</code> son las variables de las que depende el efecto en s\u00ed, es decir, las variables que si cambian de valor producir\u00e1n que el callback del efecto se vuelva a ejecutar.</p> <pre><code>const App = () =&gt; {\nconst [state, setState] = useState(false)\nuseEffect(() =&gt; {\nconsole.log('Ejecutando')    }, [state])\nreturn (\n&lt;&gt;\n&lt;h1&gt;Ejemplo de useEffect&lt;/h1&gt;\n&lt;button onClick={() =&gt; setState(!state)}&gt;Cambiar estado&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>En el ejemplo anterior se mostrar\u00e1 el <code>console.log</code> cada vez que cambie el estado de la variable <code>state</code>. La primera ejecuci\u00f3n se hace cuando se monta el componente en el DOM.</p> <p>En caso de que no se indiquen dependencias, el efecto ser\u00e1 ejecutado cada vez que se renderice el componente, lo que a veces puede ser contraproducente para nuestro proyecto:</p> <pre><code>const App = () =&gt; {\nconst [state, setState] = useState(false)\nuseEffect(() =&gt; {\nconsole.log('Ejecutando')    })\nreturn (\n&lt;&gt;\n&lt;h1&gt;Ejemplo de useEffect&lt;/h1&gt;\n&lt;button onClick={() =&gt; setState(!state)}&gt;Cambiar estado&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>Para ejecutar el efecto una \u00fanica vez y evitar que se realice en cada renderizado sin que dependa de ning\u00fan estado, es conveniente que la lista de las dependencias este vac\u00edo.</p> <pre><code>const App = () =&gt; {\nconst [state, setState] = useState(false)\nuseEffect(() =&gt; {\nconsole.log('Ejecutando')    }, [])\nreturn (\n&lt;&gt;\n&lt;h1&gt;Ejemplo de useEffect&lt;/h1&gt;\n&lt;button onClick={() =&gt; setState(!state)}&gt;Cambiar estado&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre>"},{"location":"tema_2/page-3/#proyecto-mouseeffect","title":"Proyecto MouseEffect","text":"<p>En este proyecto vamos a crear un componente que muestre una bola que persiga al puntero por toda la pantalla. En nuestro componente principal vamos a introducir el componente dentro de un main:</p> <pre><code>function App() {\nreturn (\n&lt;main&gt;\n&lt;FollowMouse /&gt;\n&lt;/main&gt;\n)\n}\nexport default App\n</code></pre> <p>En nuestro componente <code>FollowMouse</code> vamos a tener los elementos necesarios para crear la bola, as\u00ed como un bot\u00f3n que cambie el estado.</p> <pre><code>const FollowMouse = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;div style={{\nposition: 'absolute',\nbackgroundColor: 'rgba(0, 0, 0, 0.5)',\nborder: '3px solid #fff',\nborderRadius: '50%',\nopacity: 0.8,\npointerEvents: 'none',\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\ntransform: `translate(0px, 0px)`\n}}/&gt;\n&lt;button&gt;Activar seguir puntero&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>A continuaci\u00f3n, se indica los estilos de los ficheros index.css para estilos globales y App.css para el estilo de nuestro componente:</p> index.cssApp.css <pre><code>:root {\nfont-family: Inter, Avenir, Helvetica, Arial, sans-serif;\nfont-size: 16px;\nline-height: 24px;\nfont-weight: 400;\ncolor-scheme: light dark;\ncolor: rgba(255, 255, 255, 0.87);\nbackground-color: #242424;\nfont-synthesis: none;\ntext-rendering: optimizeLegibility;\n-webkit-font-smoothing: antialiased;\n-moz-osx-font-smoothing: grayscale;\n-webkit-text-size-adjust: 100%;\n}\na {\nfont-weight: 500;\ncolor: #646cff;\ntext-decoration: inherit;\n}\na:hover {\ncolor: #535bf2;\n}\nbody {\nmargin: 0;\ndisplay: grid;\nplace-items: center;\nmin-width: 320px;\nmin-height: 100vh;\n}\nh1 {\nfont-size: 3.2em;\nline-height: 1.1;\n}\nbutton {\nborder-radius: 8px;\nborder: 1px solid transparent;\npadding: 0.6em 1.2em;\nfont-size: 1em;\nfont-weight: 500;\nfont-family: inherit;\nbackground-color: #1a1a1a;\ncursor: pointer;\ntransition: border-color 0.25s;\n}\nbutton:hover {\nborder-color: #646cff;\n}\nbutton:focus,\nbutton:focus-visible {\noutline: 4px auto -webkit-focus-ring-color;\n}\n@media (prefers-color-scheme: light) {\n:root {\ncolor: #213547;\nbackground-color: #ffffff;\n}\na:hover {\ncolor: #747bff;\n}\nbutton {\nbackground-color: #f9f9f9;\n}\n}\nbody.no-cursor {\ncursor: none;\n}\n</code></pre> <pre><code>#root {\nmax-width: 1280px;\nmargin: 0 auto;\npadding: 2rem;\ntext-align: center;\n}\n.logo {\nheight: 6em;\npadding: 1.5em;\nwill-change: filter;\n}\n.logo:hover {\nfilter: drop-shadow(0 0 2em #646cffaa);\n}\n.logo.react:hover {\nfilter: drop-shadow(0 0 2em #61dafbaa);\n}\n@keyframes logo-spin {\nfrom {\ntransform: rotate(0deg);\n}\nto {\ntransform: rotate(360deg);\n}\n}\n@media (prefers-reduced-motion: no-preference) {\na:nth-of-type(2) .logo {\nanimation: logo-spin infinite 20s linear;\n}\n}\n.card {\npadding: 2em;\n}\n.read-the-docs {\ncolor: #888;\n}\n</code></pre> <p>Controlamos si se desea seguir o no el puntero con un estado que se cambiar\u00e1 al hacer clic en el bot\u00f3n (el mensaje del bot\u00f3n tambi\u00e9n cambiar\u00e1):</p> <pre><code>const FollowMouse = () =&gt; {\nconst [enabled, setEnabled] = useState(false)\nreturn (\n&lt;&gt;\n{/*...*/}\n&lt;button onClick={() =&gt; setEnabled(!enabled)}&gt;{enabled ? 'Desactivar' : 'Activar'} seguir puntero&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>Para poder indicar la posici\u00f3n de la bola tendremos un estado position de tipo objecto con dos atributos, uno para la posici\u00f3n X y otro para la posici\u00f3n Y:</p> <pre><code>const FollowMouse = () =&gt; {\n//...\nconst [position, setPosition] = useState({ x: 0, y: 0 })\nreturn (\n&lt;&gt;\n&lt;div style={{\n//...\ntransform: `translate(${position.x}px, ${position.y}px)`\n}} /&gt;\n{/*...*/}\n&lt;/&gt;\n)\n}\n</code></pre> <p>El estado de la posici\u00f3n se cambiar\u00e1 cada vez que el puntero se mueva, por lo que debemos suscribirnos al evento <code>pointermove</code>, para ello usamos el <code>useEffect</code> con la dependencia enabled:</p> <pre><code>const FollowMouse = () =&gt; {\nuseEffect(() =&gt; {\nconsole.log('effect ', { enabled })\nconst handleMove = event =&gt; {\nconst { clientX, clientY } = event\nconsole.log('handleMove', { clientX, clientY })\nsetPosition({ x: clientX, y: clientY })\n}\nif (enabled) {\nwindow.addEventListener('pointermove', handleMove)\n}\n}, [enabled])\n// ..\n}\n</code></pre> <p>Como podemos comprobar si est\u00e1 activado veremos la bola en lugar del puntero, pero al desactivarlo seguimos viendo la bola. Esto ocurre porque nos estamos suscribiendo a un evento pero en ning\u00fan momento dejamos de suscribirnos.</p>"},{"location":"tema_2/page-3/#retorno-de-un-useeffect","title":"Retorno de un useEffect","text":"<p>El <code>useEffect</code> puede retornar un callback, dicho m\u00e9todo ser\u00e1 ejecutado cuando:</p> <ul> <li>Se desmonta el componente</li> <li>Cada vez que se cambia una dependencia y se va a volver a ejecutar el <code>useEffect</code>, es decir, al cambiar la dependencia el efecto deja de producirse ejecutando el m\u00e9todo y vuelve a ejecutarlo.</li> </ul> <p>Este <code>return</code> no es obligatorio, pero si es l\u00f3gico usarlo cuando realizamos ciertas operaciones que queremos limpiar, como por ejemplo eliminar la suscripci\u00f3n a un evento, por lo que el problema del proyecto anterior se puede evitar retornando un m\u00e9todo que elimine la suscripci\u00f3n al evento:</p> <pre><code>const FollowMouse = () =&gt; {\nuseEffect(() =&gt; {\nconsole.log('effect ', { enabled })\nconst handleMove = event =&gt; {\nconst { clientX, clientY } = event\nconsole.log('handleMove', { clientX, clientY })\nsetPosition({ x: clientX, y: clientY })\n}\nif (enabled) {\nwindow.addEventListener('pointermove', handleMove)\n}\nreturn () =&gt; {\nconsole.log('cleanup')\nwindow.removeEventListener('pointermove', handleMove)\n}\n}, [enabled])\n// ...\n}\n</code></pre> <p>El retorno tambi\u00e9n se va a realizar cuando se desmonta el componente, es decir, cuando se elimine del DOM. Vamos a modificar nuestro proyecto, a\u00f1adiendo un bot\u00f3n y un estado para montar y desmontar el componente <code>FollowMouse</code>. En caso de no tener el <code>return</code> en el <code>useEffect</code> nunca eliminar\u00edamos la suscripci\u00f3n del puntero por lo que seguir\u00edamos registrando dicho evento, a pesar de no poder ejecutar nada en el momento. Por eso, para evitar esto es conveniente usarlo</p> <pre><code>function App() {\nconst [mounted, setMounted] = useState(true)\nreturn (\n&lt;main&gt;\n{mounted &amp;&amp; &lt;div&gt;&lt;FollowMouse /&gt;&lt;/div&gt;}\n&lt;button onClick={() =&gt; setMounted(!mounted)}&gt;Toggle mounted FollowMouse component&lt;/button&gt;\n&lt;/main&gt;\n)\n}\n</code></pre>"},{"location":"tema_2/page-3/#multiples-useeffect","title":"M\u00faltiples useEffect","text":"<p>Se recomienda crear varios <code>useEffect</code> para poder realizar operaciones completamente diferentes, adem\u00e1s de ser una buena pr\u00e1ctica hace que el c\u00f3digo sea m\u00e1s legible. En nuestro proyecto MouseEffect vamos a ocultar nuestro puntero cuando la bola est\u00e9 en movimiento:</p> <pre><code>const FollowMouse = () =&gt; {\n// ...\nuseEffect(() =&gt; {\ndocument.body.classList.toggle('no-cursor', enabled)\nreturn () =&gt; {\ndocument.body.classList.remove('no-cursor')\n}\n}, [enabled])\n//...\n}\n</code></pre> <p>Para eso creamos un nuevo efecto que dependa del estado enabled, es decir, si est\u00e1 activado o no el seguir al puntero, vamos a indicar una clase al <code>body</code> de nuestra p\u00e1gina (<code>no-cursor</code>). Como funci\u00f3n de retorno, devolveremos un m\u00e9todo para que elimine esa clase del <code>body</code>, ya que el <code>body</code> es una etiqueta global y si desmontamos nuestro componente seguir\u00e1 existiendo.</p>"},{"location":"tema_2/page-3/#reactstrictmode","title":"React.StrictMode","text":"<p>Cuando estamos desarrollando un proyecto React decimos que estamos en modo desarrollo. Cuando construimos un proyecto, ya sea con el comando <code>create-react-app</code> o con <code>vite</code>, nuestro componente est\u00e1 en vuelto en un componente de React, <code>StrictMode</code>:</p> <pre><code>ReactDOM.createRoot(document.getElementById('root')).render(\n&lt;React.StrictMode&gt;\n&lt;App /&gt;\n&lt;/React.StrictMode&gt;,\n)\n</code></pre> <p><code>React.StrictMode</code> es un componente especial de React que se utiliza para ayudar a encontrar y corregir problemas en la aplicaci\u00f3n relacionados con el rendimiento y las pr\u00e1cticas no seguras en el c\u00f3digo en modo desarrollo. Puedes envolver partes de tu aplicaci\u00f3n con React.StrictMode para activar un conjunto de comprobaciones adicionales de tiempo de desarrollo que te alertar\u00e1n sobre posibles problemas.</p> <p>Al utilizar <code>React.StrictMode</code>, se habilitan las siguientes comprobaciones:</p> <ul> <li>Detecci\u00f3n de efectos secundarios no deseados: <code>React.StrictMode</code> ayuda a identificar efectos secundarios no intencionales en tus funciones de renderizado. Por ejemplo, si una funci\u00f3n de renderizado tiene efectos secundarios y se llama m\u00e1s de una vez, <code>StrictMode</code> emitir\u00e1 una advertencia. De ah\u00ed que, en modo desarrollo, nuestro <code>useEffect</code> se ejecute dos veces al inicializar el componente.</li> <li>Advertencias sobre el uso de funciones de ciclo de vida obsoletas: Si tu c\u00f3digo utiliza funciones de ciclo de vida de componentes de clase que est\u00e1n obsoletas o se han eliminado en versiones futuras de React, StrictMode te dar\u00e1 advertencias sobre su uso.</li> <li>Detecci\u00f3n de renderizados redundantes: <code>StrictMode</code> puede detectar renderizados redundantes en tus componentes, lo que puede ayudarte a optimizar el rendimiento.</li> <li>Advertencias sobre el uso de FindDOMNode: Si tu aplicaci\u00f3n utiliza <code>findDOMNode</code> para acceder al DOM directamente, <code>StrictMode</code> emitir\u00e1 advertencias. En lugar de usar <code>findDOMNode</code>, se recomienda utilizar <code>ref</code> para acceder a los nodos del DOM.</li> </ul> <p>Es importante destacar que las comprobaciones realizadas por <code>React.StrictMode</code> solo se aplican en el entorno de desarrollo y no afectar\u00e1n a la producci\u00f3n. Por lo tanto, es seguro utilizar <code>React.StrictMode</code> durante el desarrollo para identificar y solucionar problemas potenciales, y luego puedes retirarlo en el entorno de producci\u00f3n para evitar el impacto en el rendimiento.</p> <p>Cuando desplegamos nuestra aplicaci\u00f3n y entramos en modo producci\u00f3n, el <code>React.StrictMode</code> no entra en juego, por lo que esas comprobaciones quedar\u00e1n deshabilitadas, y por ejemplo, el <code>useEffect</code> solo se realizar\u00e1 una vez al inicializar el componente.</p>"},{"location":"tema_2/page-3/#problemas-useeffect","title":"Problemas useEffect","text":"<p>Uno de los problemas de <code>useEffect</code> es que si no se realiza correctamente puede provocar un bucle infinito. Esto adem\u00e1s de ser peligroso y de ejecutar infinitamente una funci\u00f3n, es una mala pr\u00e1ctica.</p> <p>El <code>useEffect</code> se puede ejecutar de forma infinita:</p> <ul> <li> <p>Cuando no se indica dependencia (ni una lista vac\u00eda) y se ejecuta un cambio de estado:</p> <p><code>`javascript useEffect(() =&gt; {     setState(10) })</code></p> </li> <li> <p>Cuando se indica una dependencia y se hace cambio del estado de dicha dependencia:</p> <p>```javascript useEffect(() =&gt; {     setState(10) }, [state])</p> </li> </ul> <p>Otro de los problemas de <code>useEffect</code> es que no puede recibir par\u00e1metros en su callback, por lo que si se desea pasarle alguna variable, debemos crear la variable fuera y acceder a ella dentro del <code>useEffect</code>:</p> <pre><code>const value = 10\nuseEffect(() =&gt; {\nconsole.log(value)\n}, [])\n</code></pre>"},{"location":"tema_2/page-4/","title":"Proyecto","text":"<p>Crea un tres en raya que tenga una apariencia similar a lo siguiente:</p> <p> Figura 4 - Soluci\u00f3n</p> <p>El juego constar\u00e1 de dos forma de juego, una forma manual, en el que el usuario podr\u00e1 interactuar con ambas formas y un modo de inteligencia artificial, en la cual el usuario solo podr\u00e1 jugar con <code>\u274c</code> mientras que la m\u00e1quina elegir\u00e1 el movimiento de <code>\u26aa</code>.</p> <p>El usuario podr\u00e1 elegir el modo de juego clicando en el bot\u00f3n. El mensaje del bot\u00f3n cambiar\u00e1 de forma din\u00e1mica, mostrando Player game si est\u00e1 en modo jugador vs jugador o IA game si est\u00e1 en modo jugador vs m\u00e1quina. Una vez elegida la opci\u00f3n no podr\u00e1 cambiarla hasta que no finalice la partida.</p> <p> Figura 5 - Soluci\u00f3n Bot\u00f3n Modo Juego</p> <p>Se deben controlar aspectos b\u00e1sicos de la l\u00f3gica del juego, como por ejemplo, no se puede seleccionar una casilla que ya tiene un valor, o el juego no puede continuar si hay un empate, o hay un ganador.</p> <p>Debajo de la tabla de un juego aparece las dos opciones de turnos posibles, seleccionado siempre el turno que va a empezar el juego.</p> <p> Figura 6 - Turnos</p> <p>Aparecer\u00e1 un banner que indique el ganador del juego, una vez finalizado, o por el contrario un empate. Contendr\u00e1 un bot\u00f3n para empezar de nuevo en ambos casos.</p> <p> Figura 7 - Ganador</p> <p>Adem\u00e1s, se podr\u00e1 resetear el juego con un bot\u00f3n de reseteo:</p> <p> Figura 7 - Bot\u00f3n de reseteo</p>"}]}