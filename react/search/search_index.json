{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"tema_1/page-1/","title":"1 Introducci\u00f3n a React","text":""},{"location":"tema_1/page-1/#que-es-react","title":"\u00bfQu\u00e9 es react?","text":"<p>React es una biblioteca de Javascript utilizada para construir interfaces de usuario (UI) interactivas y componentes reutilizables en aplicaciones web. Fue desarrollada y es mantenida por Facebook, y es ampliamente  utilizada en la industria para crear aplicaciones web de una sola p\u00e1gina (Single Page Applications) y aplicaciones m\u00f3viles utilizando React Native.</p> <p>Algunas de las caracter\u00edsticas clave de React incluyen:</p> <ul> <li>Componentes: React se basa en el concepto de componentes, que son piezas independientes de la interfaz de usuario que pueden ser reutilizadas en diferentes partes de una aplicaci\u00f3n.</li> <li>Virtual DOM: React utiliza un Virtual DOM (DOM virtual) para optimizar el rendimiento. En lugar de actualizar directamente el DOM del navegador cada vez que cambia el estado de una aplicaci\u00f3n, React actualiza primero el Virtual DOM y luego compara las diferencias (diffing) para actualizar solo las partes del DOM que han cambiado. Esto mejora la eficiencia y la velocidad de la aplicaci\u00f3n.</li> <li>Unidireccionalidad de datos: React promueve el flujo de datos en una sola direcci\u00f3n, lo que significa que los datos fluyen desde un componente principal hacia sus componentes secundarios. Esto hace que sea m\u00e1s f\u00e1cil de entender y depurar c\u00f3mo los datos afectan a la interfaz de usuario.</li> <li>JSX: React utiliza una extensi\u00f3n de JavaScript llamada JSX (JavaScript XML) que permite definir la estructura de la interfaz de usuario de manera similar al HTML, pero dentro de JavaScript. Esto facilita la creaci\u00f3n de componentes de manera declarativa.</li> <li>Amplia comunidad y ecosistema: React tiene una comunidad activa y un amplio ecosistema de bibliotecas y herramientas complementarias que lo hacen a\u00fan m\u00e1s poderoso y vers\u00e1til.</li> </ul> <p>En resumen, React es una herramienta popular y poderosa para crear interfaces de usuario din\u00e1micas y eficientes en aplicaciones web y m\u00f3viles, y ha sido ampliamente adoptada en la industria del desarrollo de software.</p> <p>React es agn\u00f3stica de la plataforma, es decir, no est\u00e1 vinculado a una plataforma espec\u00edfica de desarrollo o de tecnolog\u00eda. React tiene la capacidad de trabajar de manera afectiva en diferentes entornos y plataformas.</p> <p>React es utilizado com\u00fanmente para construir interfaces de usuario en aplicaciones web, pero su dise\u00f1o modular y su arquitectura permiten que se utilice en una variedad de contextos. Por ejemplo, puede ser usado para construir aplicaciones web de una sola p\u00e1gina (SPA), aplicaciones m\u00f3viles, e incluso aplicaciones de escritorio.</p> <p>Uno de los principales motivos para usar React es que usa Javascript de forma declarativa, y no de forma imperativa, y adem\u00e1s est\u00e1 basado en componentes lo que permite reutilizar y escalar c\u00f3digo.</p>"},{"location":"tema_1/page-1/#por-que-react","title":"\u00bfPor qu\u00e9 React?","text":"<p>React fue lanzada por primera vez en 2013 y desde entonces ha experimentado un r\u00e1pido crecimiento en popularidad debido a su enfoque en la creaci\u00f3n de componentes reutilizables y su paradigma de programaci\u00f3n declarativa. Meta, la empresa detr\u00e1s de React, la utiliza en todos sus productos (Facebook, Instagram, Whatsapp, etc)</p> <p>Aunque al principio no se consideraba open source, Meta decidi\u00f3 liberar el c\u00f3digo fuente, pero a\u00fan as\u00ed tiene una licencia permisiva.</p> <p>React es una de las librer\u00edas m\u00e1s demandadas y con mayor salida laboral. Adem\u00e1s, en su versi\u00f3n React Native permite crear aplicaciones para m\u00f3viles, y tambi\u00e9n aplicaciones para escritorio Windows y macOS.</p> <p>React tiene un gran soporte y es un gran ecosistema, adem\u00e1s te ayudar\u00e1, en caso de que quieras migrar, a otras librer\u00edas o frameworks como Angular, Vue y Svelt. Tambi\u00e9n, cuenta con una API estable (en varios idiomas) y tiene un gran soporte ya que cuenta con una gran comunidad.</p>"},{"location":"tema_1/page-1/#javascript-vs-react","title":"Javascript vs React","text":"<p>El uso de Javascript nativo (vainilla Javascript) es diferente a como se usa en React. En el primer caso, se usa de forma imperativo, es decir, indica COMO lo tiene que hacer, lo que imposibilita la escalabilidad, mientras que en React, se usa de forma declarativa.</p> <p>React define un elemento ra\u00edz, el cual contendr\u00e1 toda el contenido de nuestra aplicaci\u00f3n. Dicha ra\u00edz estar\u00e1 formada por diferentes componentes, con los elementos que se desee mostrar.</p> <p>Importante</p> <p>Es importante resaltar que en React TODO se considera un componente, desde el elemento m\u00e1s primario hasta el elemento m\u00e1s compuesto.</p> <p>React recibe los diferentes elementos que desea renderizar. La renderizaci\u00f3n es el proceso de generar la representaci\u00f3n visual de un elemento o conjunto de elementos para que pueda ser percibido por los usuarios.</p> <p>Veamos un ejemplo en el que se renderice un bot\u00f3n con javascript nativo. Para ello, necesitamos un elemento HTML:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n&lt;title&gt;&lt;/title&gt;\n&lt;style&gt;\nbutton {\nbackground-color: #09f;\ncolor: #fff;\nborder: 0;\npadding: 4px 8px;\nfont-size: 18px;\ncursor: pointer;\n}\nbody {\nbackground-color: #222;\ncolor: #f0f0f0;\n}\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;button data-id=\"123\"&gt;Me gusta&lt;/button&gt;\n&lt;script&gt;\n// Recuperamos el bot\u00f3n\nconst button = document.querySelector('button')\n// al hacer click en el bot\u00f3n, tenemos que ejecutar una funci\u00f3n\nbutton.addEventListener('click', function () {\n// recuperar el id del atributo del HTML\nconst id = button.getAttribute('data-id')\n// llamar a un servicio para actualizar si me gusta\n// toggleLike(id) // no necesario\nif (button.classList.contains('liked')) {\nbutton.classList.remove('liked')\nbutton.innerText = 'Me gusta'\n} else {\nbutton.classList.add('liked')\nbutton.innerText = 'Quitar me gusta'\n}\n})\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>En el ejemplo anterior, podemos observamos como tenemos un elemento HTML que representa un bot\u00f3n. Al hacer clic en ese bot\u00f3n, recuperamos su id (data-id) y modificamos su contenido de me gusta a no me gusta o viceversa. Pero, \u00bfy si a\u00f1adimos m\u00e1s botones al c\u00f3digo HTML?:</p> <pre><code>&lt;!-- ... --&gt;\n&lt;button data-id=\"123\"&gt;Me gusta&lt;/button&gt;\n&lt;button data-id=\"456\"&gt;Me gusta&lt;/button&gt;\n&lt;button data-id=\"789\"&gt;Me gusta&lt;/button&gt;\n&lt;script&gt;\n// al hacer click en el bot\u00f3n, tenemos que ejecutar una funci\u00f3n\nbutton.addEventListener('click', function () {\n// recuperar el id del atributo del HTML\nconst id = button.getAttribute('data-id')\n// llamar a un servicio para actualizar si me gusta\n// toggleLike(id) // no necesario\nif (button.classList.contains('liked')) {\nbutton.classList.remove('liked')\nbutton.innerText = 'Me gusta'\n} else {\nbutton.classList.add('liked')\nbutton.innerText = 'Quitar me gusta'\n}\n})\n&lt;/script&gt;\n</code></pre> <p>En este caso, el c\u00f3digo javascript no funcionar\u00e1, por lo que habr\u00e1 que modificar el c\u00f3digo javascript para implementar este cambio:</p> <pre><code>&lt;!-- ... --&gt;\n&lt;button data-id=\"123\"&gt;Me gusta&lt;/button&gt;\n&lt;button data-id=\"456\"&gt;Me gusta&lt;/button&gt;\n&lt;button data-id=\"789\"&gt;Me gusta&lt;/button&gt;\n&lt;script&gt;\n// Recuperamos todos los botones\nconst buttons = document.querySelectorAll('button')\nbuttons.forEach(button =&gt; {\n// al hacer click en el bot\u00f3n, tenemos que ejecutar una funci\u00f3n\nbutton.addEventListener('click', function () {\n// recuperar el id del atributo del HTML\nconst id = button.getAttribute('data-id')\n// llamar a un servicio para actualizar si me gusta\n// toggleLike(id) // no necesario\nif (button.classList.contains('liked')) {\nbutton.classList.remove('liked')\nbutton.innerText = 'Me gusta'\n} else {\nbutton.classList.add('liked')\nbutton.innerText = 'Quitar me gusta'\n}\n})\n})\n&lt;/script&gt;\n</code></pre> <p>Esto a la larga puede convertirse un trabajo pesado y no es nada eficiente si queremos crear diferentes elemento y cada uno con una funcionalidad diferente. Para eso y m\u00e1s, React nos facilitar\u00e1 la tarea.</p> <p>Info</p> <p>En este enlace, https://es.react.dev/, se encuentra la API de React oficial y en espa\u00f1ol.</p>"},{"location":"tema_1/page-1/#trabajando-con-react","title":"Trabajando con React","text":"<p>Para trabajar con React, ser\u00e1 necesario usar la librer\u00eda <code>React</code>, que contiene los m\u00e9todos para crear elementos y componentes, y la librer\u00eda <code>ReactDOM</code> para poder trabajar con el DOM de forma sencilla.</p> <p>En primer lugar, para poder trabajar con React necesito un fichero HTML que defina el elemento ra\u00edz de nuestra aplicaci\u00f3n:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n&lt;title&gt;React&lt;/title&gt;\n&lt;style&gt;\nbutton {\nbackground-color: #09f;\ncolor: #fff;\nborder: 0;\npadding: 4px 8px;\nfont-size: 18px;\ncursor: pointer;\n}\nbody {\nbackground-color: #222;\ncolor: #f0f0f0;\n}\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"app\"&gt;&lt;/div&gt;\n&lt;script src=\"react.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>En este ejemplo, tenemos un contenedor que hemos definido con la clase <code>app</code>. Desde nuestro archivo javascript, obtenemos ese elemento HTML que funciona como ra\u00edz y con el m\u00e9todo <code>createRoot(element)</code>, de la librer\u00eda <code>ReactDOM</code>:</p> <pre><code>import ReactDOM from \"https://esm.sh/react-dom@18.2.0/client\"\nimport React from \"https://esm.sh/react@18.2.0\"\nconst app = document.getElementById('app') // Obtenemos el elemento HTML que funcionar\u00e1 como ra\u00edz\nconst root = ReactDOM.createRoot(app) // Indicamos que elemento es la ra\u00edz\n</code></pre> <p>Para poder renderizar el contenido usamos el m\u00e9todo <code>render(elemento)</code> de la librer\u00eda <code>React</code>:</p> <pre><code>import ReactDOM from \"https://esm.sh/react-dom@18.2.0/client\"\nimport React from \"https://esm.sh/react@18.2.0\"\nconst app = document.getElementById('app') // Obtenemos el elemento HTML que funcionar\u00e1 como ra\u00edz\nconst root = ReactDOM.createRoot(app) // Indicamos que elemento es la ra\u00edz\nroot.render('Hola mundo')\n</code></pre>"},{"location":"tema_1/page-1/#renderizar-elementos","title":"Renderizar elementos","text":"<p>Si se intenta renderizar un elemento HTML sin comillas (\"\"), eso no funcionar\u00e1 ya que dar\u00e1 un error y no se renderizar\u00e1, y si se usa con las comillas los renderizar\u00e1 como textos. Los elementos HTML NO se puede renderizar de forma directa, habr\u00e1 que crearlos primero como elementos en React y luego ya se podr\u00e1n renderizar.</p> <p>Para poder crear elementos en React, existe la funci\u00f3n <code>createElement()</code> que recibe tres par\u00e1metros:</p> <ul> <li>El primero de ellos, hace referencia al elemento HTML que debe crear.</li> <li>El segundo, es un objeto con los atributos del elemento, como por ejemplo, su clase o su id.</li> <li>El tercero, es el contenido de dicho elemento. Puede ser un simple dato primitivo (por ejemplo una cadena), o uno o varios elementos de React.</li> </ul> <pre><code>import ReactDOM from \"https://esm.sh/react-dom@18.2.0/client\"\nimport React from \"https://esm.sh/react@18.2.0\"\nconst app = document.getElementById('app') // Obtenemos el elemento HTML que funcionar\u00e1 como ra\u00edz\nconst root = ReactDOM.createRoot(app) // Indicamos que elemento es la ra\u00edz\nconst button = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nroot.render(button)\n</code></pre> <p>La funci\u00f3n <code>render</code> solo puede renderizar un \u00fanico elemento a la vez. Si quisi\u00e9ramos renderizar por ejemplo varios botones, ser\u00eda necesario envolverlos en un elemento superior y renderizar dicho elemento:</p> <pre><code>import ReactDOM from \"https://esm.sh/react-dom@18.2.0/client\"\nimport React from \"https://esm.sh/react@18.2.0\"\nconst app = document.getElementById('app') // Obtenemos el elemento HTML que funcionar\u00e1 como ra\u00edz\nconst root = ReactDOM.createRoot(app) // Indicamos que elemento es la ra\u00edz\nconst button1 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst button2 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst button3 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst wrapped = React.createElement('div', null, [button1, button2, button3]);\nroot.render(wrapped)\n</code></pre>"},{"location":"tema_1/page-1/#react-fragment","title":"React Fragment","text":"<p>React a la hora de renderizar los elementos, los transforma a elementos de HTML, por lo que los a\u00f1ade al \u00e1rbol DOM de la p\u00e1gina. De esa forma, el ejemplo anterior pasar\u00eda a ser de la siguiente forma:</p> <pre><code>html\n    head\n        title\n        metas\n    body\n        div.root\n            div\n                button\n                button\n                button\n</code></pre> <p>De forma innecesario ha creado un div para envolver a los tres botones. Esta peque\u00f1a molestia puede provocar errores a cu\u00e1nto los estilos de CSS o incluso en la interactividad con el usuario, sino se tiene en cuenta. Pero, si tenemos que envolver los elementos React en un elemento superior para poder renderizar un solo elemento, \u00bfc\u00f3mo podemos evitar este peque\u00f1o inconveniente?</p> <p>React posee un elemento que puede ser usado como elemento superior pero a la hora de transformarlo a elementos HTML y a\u00f1adirlos al DOM, no crea un elemento innecesario. Este elemento se conoce como <code>Fragment</code>, por lo que de esta manera podemos hacer el ejemplo anterior de una forma mucho m\u00e1s limpia:</p> <pre><code>import ReactDOM from \"https://esm.sh/react-dom@18.2.0/client\"\nimport React from \"https://esm.sh/react@18.2.0\"\nconst app = document.getElementById('app') // Obtenemos el elemento HTML que funcionar\u00e1 como ra\u00edz\nconst root = ReactDOM.createRoot(app) // Indicamos que elemento es la ra\u00edz\nconst button1 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst button2 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst button3 = React.createElement('button', {\n'data-id': 123\n}, 'Button')\nconst wrapped = React.createElement(React.Fragment, null, [button1, button2, button3]);\nroot.render(wrapped)\n</code></pre> <p>De esta manera, el \u00e1rbol DOM queda m\u00e1s limpio y precavido de incidentes:</p> <pre><code>html\n    head\n        title\n        metas\n    body\n        div.root\n           button\n           button\n           button\n</code></pre> <p>A\u00fan as\u00ed, los ejemplos que hemos ido desarrollando usan una peculiaridad que quer\u00edamos evitar, la imperatividad. Para poder evitarla, ser\u00e1 necesario hacer JSX y crearnos un proyecto que nos facilite el trabajo.</p>"},{"location":"tema_1/page-1/#proyecto-react","title":"Proyecto React","text":"<p>Para poder hacer uso de la librer\u00eda ser\u00e1 necesario tener instalado NodeJS y un manejador de paquetes (npn, yarn, etc)</p> <p>Podemos crear react a trav\u00e9s de comandos diferentes: <code>npx create-react-app</code> o haciendo uso de <code>vite</code>. La primera opci\u00f3n es la forma nativa y recomendada por React en su API, pero cierto es que es una forma m\u00e1s anticuada y mucho m\u00e1s lenta</p> <pre><code>npx create-react-app example\ncd example\n</code></pre> <p>Para ejecutar el proyecto se usa el siguiente comando:</p> <pre><code>npm start\n</code></pre> <p>Vite ha creado un comando que hace que la creaci\u00f3n de un proyecto sea m\u00e1s sencillo y m\u00e1s r\u00e1pido:</p> <pre><code>npm  create vite@latest\ncd project\n</code></pre> <p>Para poder ejecutar el proyecto creado:</p> <pre><code>npm run dev\n</code></pre> <p>Una vez ejecutado el navegador predeterminado deber\u00e1 ser ejecutado con el proyecto en marcha. En caso de que no lo haga, se puede acceder a \u00e9l a trav\u00e9s de la URL http://localhost:<code>PORT</code>, donde el valor del puerto ser\u00e1 por defecto 3000, en caso de usar el comando oficial, y 5173 si se usa el gestor de vite.</p> <p>Adem\u00e1s al ejecutar el comando de creaci\u00f3n, se habr\u00e1 creado una estructura de proyecto similar a la siguiente (varia dependiendo de la versi\u00f3n del proyecto creado):</p> <p> Figura I - Estructura del proyecto</p> <p>Los ficheros y carpetas m\u00e1s importantes son:</p> <ul> <li>Carpeta node_modules: Esta carpeta contiene todas las librer\u00edas de React y las que vayamos instalando a trav\u00e9s de Node JS.</li> <li>public: En esta carpeta aparecen los archivos p\u00fablicos del proyecto, as\u00ed como las im\u00e1genes, las plantillas html, etc.</li> <li>src: Esta carpeta es la carpeta principal del proyecto y contiene todos los archivos necesarios para el desarrollo de nuestro proyecto, as\u00ed como los componentes y el archivo principal (<code>index.js</code> para el comando oficial y <code>main.jsx</code> para vite).</li> </ul> index.htmlindex.js/main.jsx <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\" /&gt;\n&lt;link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" /&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt;\n&lt;meta name=\"theme-color\" content=\"#000000\" /&gt;\n&lt;meta\nname=\"description\"\ncontent=\"Web site created using create-react-app\"\n/&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" /&gt;\n&lt;!--\n      manifest.json provides metadata used when your web app is installed on a\n      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/\n    --&gt;\n&lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" /&gt;\n&lt;!--\n      Notice the use of %PUBLIC_URL% in the tags above.\n      It will be replaced with the URL of the `public` folder during the build.\n      Only files inside the `public` folder can be referenced from the HTML.\n      Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will\n      work correctly both with client-side routing and a non-root public URL.\n      Learn how to configure a non-root public URL by running `npm run build`.\n    --&gt;\n&lt;title&gt;React App&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;\n&lt;div id=\"root\"&gt;&lt;/div&gt;\n&lt;!--\n      This HTML file is a template.\n      If you open it directly in the browser, you will see an empty page.\n      You can add webfonts, meta tags, or analytics to this file.\n      The build step will place the bundled scripts into the &lt;body&gt; tag.\n      To begin the development, run `npm start` or `yarn start`.\n      To create a production bundle, use `npm run build` or `yarn build`.\n    --&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals'; // (1)!\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n&lt;React.StrictMode&gt;\n&lt;App /&gt;\n&lt;/React.StrictMode&gt;\n);\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: &lt;https://bit.ly/CRA-vitals&gt;\nreportWebVitals(); // (1)!\n</code></pre> <ol> <li>Estas l\u00edneas han de ser eliminadas en caso de que no se vaya a usar los ficheros reportWebVitals.js y setUp.js</li> <li>Estas l\u00edneas han de ser eliminadas en caso de que no se vaya a usar los ficheros reportWebVitals.js y setUp.js</li> </ol>"},{"location":"tema_1/page-2/","title":"2 JSX","text":""},{"location":"tema_1/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>JSX es una extensi\u00f3n de sintaxis para JavaScript que permite escribir marcado similar a HTML dentro de una archivo JavaScript. Aunque hay otras formas de escribir componentes, la mayor\u00eda de los desarrolladores de React prefieren la concisi\u00f3n de JSX, y la mayor\u00eda de las bases de c\u00f3digo lo usan.</p> <pre><code>const element = &lt;h1&gt;Soy un elemento escrito en JSX&lt;/h1&gt;\n</code></pre> <p>Esta l\u00ednea de c\u00f3digo ser\u00eda equivalente a lo siguiente haciendo uso de React imperativo:</p> <pre><code>const element = React.createElement(h1, null, \"Soy un elemento escrito en JSX\")\n</code></pre>"},{"location":"tema_1/page-2/#poniendo-marcado-dentro-de-javascript","title":"Poniendo marcado dentro de Javascript","text":"<p>La Web se ha construido com\u00fanmente sobre archivos HTML, CSS y Javascript, de forma separada o en un \u00fanico fichero HTML. De esta forma, el contenido de la p\u00e1gina queda marcado con HTML, los estilos est\u00e1n indicados con CSS y la l\u00f3gica y funcionalidad de la p\u00e1gina en Javascript</p> <p>Al volverse las web m\u00e1s interactivas, el contenido de un p\u00e1gina se ve\u00eda determinado cada vez m\u00e1s por la l\u00f3gica, por ejemplo, al hacer clic en diferentes botones se muestra diferentes contenidos dentro de la misma p\u00e1gina.</p> <p>Esto supone una gran desventaja, y es que al no estar relacionados pierde seguridad y a\u00f1ade m\u00e1s trabajo y funcionalidad. Para ello, se implemento JSX.</p> <p>Los componentes de React contienen una funci\u00f3n de Javascript que puede contener alg\u00fan marcado que React muestra en el navegador. Dichos componentes usan la extensi\u00f3n <code>.jxs</code></p> <p>La sintaxis de JSX es muy parecida a la de HTML, pero con la diferencia que \u00e9sta es m\u00e1s estricta y puede mostrar informaci\u00f3n din\u00e1mica de una forma sencilla y segura.</p> <p>Note</p> <p>JSX y React son independientes. A menudo se usan en conjunto, pero se pueden usar de forma separada. JSX es una extensi\u00f3n de sintaxis, mientras React es una biblioteca de JavaScript.</p>"},{"location":"tema_1/page-2/#convertir-html-a-jsx","title":"Convertir HTML a JSX","text":"<p>Si queremos convertir un HTML a un JSX, no se puede hacer de forma literal, es decir, no podemos copiar los elementos HTML en un fichero JSX, ya que es m\u00e1s estricto y requiere de ciertas modificaciones. Por ejemplo, en el siguiente c\u00f3digo, dar\u00e1 un error en caso de querer ejecutarlo:</p> HTMLJSX <pre><code>&lt;h1&gt;Tareas Pendientes de Hedy Lamarr&lt;/h1&gt;\n&lt;img\nsrc=\"&lt;https://i.imgur.com/yXOvdOSs.jpg&gt;\"\nalt=\"Hedy Lamarr\"\nclass=\"photo\"\n&gt;\n&lt;ul&gt;\n&lt;li&gt;Inventar nuevo sem\u00e1foro\n    &lt;li&gt;Ensayar la escena de la pel\u00edcula\n    &lt;li&gt;Mejorar la tecnolog\u00eda del espectro\n&lt;/ul&gt;\n</code></pre> <pre><code>const element = // \u274c\u274c\u00a1Esto no funciona!\u274c\u274c\n&lt;h1&gt;Tareas Pendientes Hedy Lammar&lt;/h1&gt;\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclass=\"photo\"\n&gt;\n&lt;ul&gt;\n&lt;li&gt;Inventar nuevo sem\u00e1foro\n&lt;li&gt;Ensayar la escena de la pel\u00edcula\n&lt;li&gt;Mejorar la tecnolog\u00eda del espectro\n&lt;/ul&gt;\n</code></pre> <p>Para convertir un HTML a un JSX hay que seguir ciertas reglas de sintaxis:</p> <ol> <li> <p>Devolver un solo elemento ra\u00edz. Para devolver m\u00faltiples elementos de un componente, envu\u00e9lvelos con solo una etiqueta principal.</p> <pre><code>&lt;div&gt;\n&lt;h1&gt;Tareas pendientes Hedy Lammar&lt;/h1&gt;\n&lt;img src=\"https://i.imgur.com/yXOvdOSs.jpg\" alt=\"Hedy Lamarr\" class=\"photo\"\n&gt;\n&lt;ul&gt;\n//...\n&lt;/ul&gt;\n&lt;/div&gt;\n</code></pre> <p>En caso de que no quieras crear un elemento <code>div</code> para englobar el resto de elementos puedes hacer uso del Fragment, como hemos visto anteriormente.</p> <pre><code>&lt;React.Fragment&gt;\n&lt;h1&gt;Tareas pendientes Hedy Lammar&lt;/h1&gt;\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclass=\"photo\"\n&gt;\n&lt;ul&gt;\n//...\n&lt;/ul&gt;\n&lt;/React.Fragment&gt;\n</code></pre> <p>A la hora de usarlo con JSX no es necesario indicar <code>React.Fragment</code>, sino que se puede usar las etiquetas vac\u00edas <code>&lt;&gt;</code>:</p> <pre><code>&lt;&gt;\n&lt;h1&gt;Tareas pendientes Hedy Lammar&lt;/h1&gt;\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclass=\"photo\"\n&gt;\n&lt;ul&gt;\n//...\n&lt;/ul&gt;\n&lt;/&gt;\n</code></pre> <p>Warning</p> <p>JSX parece HTML, pero por debajo se transforma en objetos planos de JavaScript. No puedes devolver dos objetos desde una funci\u00f3n sin envolverlos en un array. Esto explica por qu\u00e9 tampoco puedes devolver dos etiquetas JSX sin envolverlas en otra etiqueta o Fragmento.</p> </li> <li> <p>Cerrar todas las etiquetas. JSX requiere que todas las etiquetas se cierren de forma expl\u00edcita, as\u00ed c\u00f3mo las etiquetas de cierre autom\u00e1tico como <code>&lt;img&gt;</code> deben convertirse en <code>&lt;img/&gt;</code>, y las etiquetas envolventes deben ser cerradas, como<code>&lt;li&gt;&lt;/li&gt;</code></p> <pre><code>&lt;&gt;\n&lt;h1&gt;Tareas Pendientes&lt;/h1&gt;\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclass=\"photo\"\n/&gt;\n&lt;ul&gt;\n&lt;li&gt;Inventar nuevo sem\u00e1foro&lt;/li&gt;\n&lt;li&gt;Ensayar la escena de la pel\u00edcula&lt;/li&gt;\n&lt;li&gt;Mejorar la tecnolog\u00eda del espectro&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/&gt;\n</code></pre> </li> <li> <p>Uso de lowerCamelCase: JSX se convierte en Javascript, por lo que los atributos de una etiqueta se convertir\u00e1n en keys de objetos Javascript as\u00ed como en variables. \u00c9sta tiene limitaciones en los nombres de las variables, como por ejemplo, no admite guiones ni puede contener palabras reservadas. Para evitar estos errores, los nombre de los atributos tendr\u00e1n que ser usados con la anotaci\u00f3n lowerCamelCase, y en caso de las palabras reservadas, como por ejemplo <code>class</code> tiene que haber un equivalente parecido como <code>className</code>. De esta forma, por ejemplo el atributo <code>stroke-width</code> pasar\u00e1 a ser <code>strokeWidth</code>.</p> <pre><code>//...\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclassName=\"photo\"\n/&gt;\n//...\n</code></pre> <p>Info</p> <p>Puedes encontrar todos estos atributos en la lista de props de los componentes DOM</p> </li> </ol> <p>Una vez realizado estos cambios nuestro HTML puede ser convertido exitosamente a JSX:</p> <pre><code>const elemento = &lt;&gt;\n// \u2705\u2705\u00a1Esto ya funciona!\u2705\u2705\n&lt;h1&gt;Tareas Pendientes Hedy Lammar&lt;/h1&gt;\n&lt;img\nsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt=\"Hedy Lamarr\"\nclassName=\"photo\"\n/&gt;\n&lt;ul&gt;\n&lt;li&gt;Inventar nuevo sem\u00e1foro&lt;/li&gt;\n&lt;li&gt;Ensayar la escena de la pel\u00edcula&lt;/li&gt;\n&lt;li&gt;Mejorar la tecnolog\u00eda del espectro&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/&gt;\n</code></pre> <p>Para a\u00f1adir c\u00f3digo Javascript dentro de los elementos JSX es necesario envolverlos en llaves <code>{}</code>:</p> <pre><code>const user = \"R\"\n&lt;h1&gt;Hello {user}&lt;/h1&gt;\n</code></pre> <p>Info</p> <p>Tambi\u00e9n puedes usar un convertidor online. Aunque es aconsejable ir practic\u00e1ndolo primero.</p>"},{"location":"tema_1/page-2/#expresiones","title":"Expresiones","text":"<p>Si queremos valuar alguna expresi\u00f3n en un elemento JSX ser\u00e1 necesario el uso de llaves <code>{}</code>:</p> <pre><code>const name = number % 2 == 0 ? 'isEven' : 'isOdd'\nconst element = &lt;h1 className={name}&gt;Este elemento tiene una clase llamada {name}&lt;/h1&gt;\n</code></pre> <p>Incluso se puede evitar la creaci\u00f3n de la variable:</p> <pre><code>const element = &lt;h1 className={number % 2 == 0 ? 'isEven' : 'isOdd'}&gt;Este elemento tiene una clase llamada {number % 2 == 0 ? 'isEven' : 'isOdd'}&lt;/h1&gt;\n</code></pre>"},{"location":"tema_1/page-3/","title":"3 Componentes","text":""},{"location":"tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Un componente es un funci\u00f3n renderizadora que puede ser reutilizada en otros componentes. Pueden estar separados en diferentes ficheros o estar incluidos en el mismo fichero.</p> <p>Un componente es una funci\u00f3n que devuelve c\u00f3digo JSX, por lo que se puede crear de forma habitual o de forma arrow functions:</p> <pre><code>const MyFirstComponent = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h2&gt;This is my first component&lt;/h2&gt;\n&lt;div&gt;This is my first component&lt;/div&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>La ventaja de usar componentes es que se puede reutilizar y escalar el c\u00f3digo de forma sencilla y segura. Por ejemplo, la p\u00e1gina web de twitter contiene much\u00edsimos elementos tweets, en ese caso, ser\u00eda l\u00f3gico pensar que cada tweet es un componente que recibe diferente tipo de informaci\u00f3n.</p>"},{"location":"tema_1/page-3/#componentes-de-clase","title":"Componentes de clase","text":"<p>Un componente de clase es una forma de definir componentes haciendo uso de la orientaci\u00f3n a objetos. Este m\u00e9todo est\u00e1 actualmente anticuado debido a las implementaciones de React 16.8, pero siguen siendo v\u00e1lidas.</p> <pre><code>import React, { Component } from 'react';\nclass MiComponenteDeClase extends Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\n// estado inicial\n};\n}\ncomponentDidMount() {\n// l\u00f3gica a ejecutar despu\u00e9s de que el componente se monta en el DOM\n}\ncomponentDidUpdate(prevProps, prevState) {\n// l\u00f3gica a ejecutar despu\u00e9s de que el componente se actualiza\n}\ncomponentWillUnmount() {\n// l\u00f3gica a ejecutar antes de que el componente sea desmontado\n}\nhandleClick = () =&gt; {\n// m\u00e9todo de clase\n};\nrender() {\n// m\u00e9todo obligatorio que devuelve el JSX a renderizar\nreturn (\n&lt;div&gt;\n{/* contenido del componente */}\n&lt;/div&gt;\n);\n}\n}\nexport default MiComponenteDeClase;\n</code></pre> <p>En el ejemplo anterior vemos un componente creado como clase, deriva de la clase <code>Component</code> adem\u00e1s hereda y sobrescribe m\u00e9todos de la misma clase para tratar con el estado, siendo el \u00fanico m\u00e9todo obligatorio el m\u00e9todo <code>render()</code>, encargado de la renderizaci\u00f3n del componente.</p> <p>Aunque no se recomienda su uso, si es bueno tener conocimientos de ellas por si debes tratar alg\u00fan d\u00eda con ellas.</p>"},{"location":"tema_1/page-3/#nomenclatura","title":"Nomenclatura","text":"<p>Los componentes est\u00e1n obligados a ser escritos en PascalCase (UpperCamelCase). React entiende a los elementos escrito de en min\u00fasculas como elementos HTML, por lo que si un componente est\u00e1 escrito de esa forma nunca lo reconocer\u00e1 como tal, sino como un elemento HTML, incluso si el elemento no existe, pero como el cat\u00e1logo HTML es tan amplio y puede seguir creciendo con el paso de los a\u00f1os, React no tiene forma de diferencias entre un componente y elemento HTML.</p> <pre><code>function myComponente() {\n// \u274c\u274c ESTO NO SE HACE\n}\nfunction MyComponents(){\n// \u2705\u2705 ESTA ES LA FORMA CORRECTA\n}\n</code></pre>"},{"location":"tema_1/page-3/#componentes-multiples","title":"Componentes m\u00faltiples","text":"<p>Un componente, al ser reutilizable, puede ser usado en varias ocasiones. Por ejemplo, el componente anterior puede ser usado en otro componente:</p> <pre><code>const App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Esta es mi app&lt;/h1&gt;\n&lt;MyFirstComponent /&gt;\n&lt;MyFirstComponent /&gt;\n&lt;MyFirstComponent /&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>A su vez, cada componente puede llamar otros componentes, generando as\u00ed un gran \u00e1rbol de componentes que puede interactuar entre ellos, facilit\u00e1ndonos as\u00ed el desarrollo de nuestra aplicaci\u00f3n web.</p>"},{"location":"tema_1/page-3/#atributos-de-los-componentes","title":"Atributos de los componentes","text":"<p>Para poder pasar datos a los componentes hacemos usos de los llamados props. Un props es un par\u00e1metro que se a\u00f1ade a la funci\u00f3n principal del componente e indica que permite recibir datos desde fuera de \u00e9l.</p> <pre><code>const MyComponent = (props) =&gt; {\n//...\n}\n</code></pre> <p>Dicho par\u00e1metro recibe un objeto que tiene como campos a los correspondientes que el usuario ha definido en la llamada del componente.</p> <pre><code>const App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Hola, bienvenido&lt;/h1&gt;\n&lt;MyComponent name=\"Rub\u00e9n\"/&gt;\n&lt;/&gt;\n)\n}\nconst MyComponent = (props) =&gt; {\nreturn (\n&lt;span&gt;Este es tu usuario {props.name}&lt;/span&gt;\n)\n}\n</code></pre> <p>Importante</p> <p>Es importante recalcar que el nombre de los componentes deben estar en may\u00fasculas capitalizada si no React los interpretar\u00e1 como c\u00f3digo HTML y mostrar\u00e1 un c\u00f3digo inexistente completamente vac\u00edo.</p> <p>Es importante destacar que el valor de los componente vayan entre comillas si se trata de un dato de tipo cadena, por el contrario, ya sea de otro tipo de dato u otro componente deber\u00eda usarse entre llave <code>{}</code>:</p> <pre><code>const App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Hola, bienvenido&lt;/h1&gt;\n&lt;MyComponent name=\"Rub\u00e9n\" isTrue={true} number={2} otherComponent={&lt;MyComponent/&gt;} /&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>Si el tipo de atributo que va a recibir el componente es booleano, se puede evitar el <code>param={true}</code> y poner directamente <code>param</code> como los atributos en HTML, por lo contrario si el valor es false se debe seguir usando las llaves <code>{}</code>:</p> <pre><code>const App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Hola, bienvenido&lt;/h1&gt;\n&lt;MyComponent name=\"Rub\u00e9n\" isTrue number={2} otherComponent={&lt;MyComponent/&gt;} /&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>Los props de los componentes tambi\u00e9n pueden ser pasados como un objeto nombrado para una mayor seguridad, incluso se puede indicar alg\u00fan valor por defecto para cada uno de ellos:</p> <pre><code>const MyComponent = ({name = ''}) =&gt; {\n//...\n}\n</code></pre> <p>OJO</p> <p>Si al componente se le indica un prop y \u00e9ste es usado por el componente, pero a la hora de usarlo no se indica, su valor por defecto es undefined y si esto no es controlado por el componente en ciertas ocasiones puede dar lugar a resultados no deseados.</p> <p>Se recomienda que los props en React sean inmutables, es decir, que no se puedan cambiar su valor dentro de ellos, para as\u00ed poder evitar problemas a la hora de escalar el componente. En su lugar se deber\u00eda crear un variable que contenga el valor de prop, y en caso de modificaci\u00f3n de modifique dicha variable:</p> <pre><code>const MyComponent = ({name = '', age}) =&gt; {\n// age = 30 \u274c\u274c No se deber\u00eda hacer esto\nconst copyAge = age // \u2705\u2705 En su lugar, se debe hacer esto\n}\n</code></pre> <p>Diferencia entre elemento y componente</p> <p>Llegados a este punto es importante recalcar que un elemento de React es lo que se renderiza para que interact\u00fae con el usuario, mientras que un componente es un funci\u00f3n factor\u00eda que se encarga de crear los elementos.</p> <p>Por otro lugar, se puede pasar los props de los componentes como una variable haciendo uso del spread-operator <code>...</code>, de esta forma har\u00e1 la transformaci\u00f3n correcto a varios props en lugar de un prop cuyo valor sea un objeto:</p> <pre><code>const props = {isFollowing, name='Sergio'}\nconst App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Hola, bienvenido&lt;/h1&gt;\n&lt;MyComponent props /&gt; // (1)! \n&lt;MyComponent {..props} /&gt; // (2)!\n&lt;/&gt;\n)\n}\n</code></pre> <ol> <li>\u274c\u274c De est\u00e1 forma crea un \u00fanico prop cuyo valor es el objeto</li> <li>\u2705\u2705 De est\u00e1 forma a\u00f1ade a los props, un prop por cada elemento del objeto</li> </ol>"},{"location":"tema_1/page-3/#hijos-de-un-componente","title":"Hijos de un componente","text":"<p>Un componente puede contener hijos y para ello debe recibir un prop llamado <code>children</code>:</p> <pre><code>const MyComponent = ({children, name = '', age}) =&gt; {\nreturn (\n&lt;div&gt;\n{children}\n&lt;/div&gt;\n)\n}\nconst App = () =&gt; {\n&lt;MyComponent&gt;\n&lt;h1&gt;Esto es un hijo del componente MyComponent&lt;/h1&gt;\n&lt;h2&gt;Esto es un otro hijo del componente MyComponent&lt;/h2&gt;\n&lt;/MyComponent&gt;\n}\n</code></pre> <p>En este caso, al tener hijos, no se puede usar la etiqueta auto-cierre (<code>&lt;MyComponent/&gt;</code>), en su lugar debe utilizar la etiqueta de apertura y cierre.</p>"},{"location":"tema_1/page-4/","title":"Proyecto","text":"<p>Haciendo uso de componentes, JSX, y estilos CSS crea la siguiente interfaz de Usuario:</p> <p> Soluci\u00f3n del proyecto</p>"},{"location":"tema_2/page-1/","title":"1 Introducci\u00f3n a los Hooks","text":""},{"location":"tema_2/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Un componente en React puede sufrir cambios. Podemos tener un bot\u00f3n con el mensaje de Seguir para comenzar a seguir una persona en una red social. Una vez clicado el bot\u00f3n comenzamos a seguir a dicha persona,por lo que no tiene sentido que siga apareciendo el mensaje de Seguir si no uno que indique que ya se est\u00e1 siguiente. Podemos realizar este cambio en la interfaz haciendo uso de una nueva renderizaci\u00f3n.</p> <p> Figura 1 - Cambios de un elemento</p> <p>Debemos tener en cuenta que cuando queremos que una renderizaci\u00f3n se haga es para poder reflejar los cambios en la interfaz de usuario. Supongamos que tenemos un componente que contiene otro componente que retorna el bot\u00f3n, el mensaje de texto lo recibe un prop, pero se puede cambiar y se realiza en el componente padre.</p> <pre><code>const App = () =&gt;{\nconst changeText = () =&gt; {\ntext = \"Mensaje nuevo\"\n// ...\n}\nreturn (\n&lt;p onClick={changeText}&gt;Si clicas aqu\u00ed cambias el texto del bot\u00f3n&lt;/p&gt;\n&lt;Button text=\"Mensaje del bot\u00f3n\"/&gt;\n)\n}\n</code></pre> <p>Al querer que ese cambio se vea reflejado, podemos hacer que se vuelva a renderizar. Por el contrario, si el cambio de texto de un bot\u00f3n sucede dentro desde el mismo bot\u00f3n, podemos hacer uso de la propiedad <code>target</code> del evento asociado, de esta forma no ser\u00e1 necesaria una renderizaci\u00f3n.</p> <pre><code>const App = () =&gt; {\nconst toggleFollow = e =&gt; {\nconst target = e.target\nif(target.innerText === 'Seguir'){\ntarget.innerText = 'Siguiendo'\n} else {\ntarget.innerText = 'Seguir'\n}\n}\nreturn (\n&lt;&gt;\n&lt;button onClick={toggleFollow}&gt;Seguir&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre>"},{"location":"tema_2/page-1/#ciclo-de-vida-de-un-componente","title":"Ciclo de vida de un componente","text":"<p>En React, los componentes pasan por diferentes fases durante su ciclo de vida. Sin embargo, con la introducci\u00f3n de los hooks en React 16.8, el t\u00e9rmino ciclo de vida ha cambiado un poco. Antes, los componentes de clase ten\u00edan m\u00e9todos de ciclo de vida, pero con los hooks, los componentes de funci\u00f3n tambi\u00e9n pueden tener un ciclo de vida.</p> <p> Figura 2 - Ciclo de vida de un componente</p> <ol> <li>Inicializaci\u00f3n. Sucede cuando se crea una instancia del componente e inicializa su estado. En los componente de clase ser\u00eda la llamada al <code>constructor()</code>.</li> <li>Montaje. Adapta las propiedades del componente y lo renderiza. Tambi\u00e9n se realiza las operaciones iniciales que sean requeridas por el DOM. Por ejemplo, hacer una llamada a una API. En los componente de clase se llamar\u00eda a los siguientes m\u00e9todos en este orden: <code>static getDerivedStateFromProps()</code>, <code>render()</code>, <code>componentDidMount()</code>.</li> <li>Actualizaci\u00f3n. Sucede cuando se produce un cambio en el estado del componente, es decir, en algunas de sus propiedades. Se va renderizando cada uno de los elementos que sea necesario, si no se produce ning\u00fan cambio se evita la actualizaci\u00f3n para as\u00ed optimizar el rendimiento. Los m\u00e9todos de los componentes de clase a llamar son: <code>static getDerivedStateFromProps()</code>, <code>shouldComponentUpdate()</code>, <code>render()</code>, <code>getSnapshotBeforeUpdate()</code>, <code>componentDidUpdate()</code>.</li> <li>Desmontaje. Sucede justo antes de que el componente sea eliminado del \u00e1rbol DOM. <code>componentWillUnmount()</code></li> </ol>"},{"location":"tema_2/page-1/#hooks","title":"Hooks","text":"<p>Un hook es una funci\u00f3n especial de React que te permite llevar a cabo ciertas tareas, como por ejemplo, manejar el estado de un componente, compartir el contexto, etc.</p> <p>Los hooks fueron a\u00f1adidos en la versi\u00f3n 16.8 de React, para poder tratar con el tema de los estados de una forma m\u00e1s sencilla en los componentes de funci\u00f3n. Los hooks no funcionan con los componentes de clases ya que estos manejan el estado de una forma m\u00e1s diferente y ya implementada.</p> <p>Algunos de los hooks m\u00e1s comunes son:</p> <ul> <li><code>useRef()</code>: Sirve para referenciar un elemento.</li> <li><code>useState()</code>: Sirve para manejar estados de un componente.</li> <li><code>useEffect()</code>: Permite realizar efectos secundarios en componentes de funci\u00f3n, como solicitudes de red o manipulaciones DOM.</li> <li><code>useContext()</code>: Permite acceder al contexto de React dentro de un componente.</li> <li><code>useReducer()</code>: Es una alternativa a <code>useState()</code>, por lo que tambi\u00e9n, sirve para gestionar el estado de un componente.</li> </ul>"},{"location":"tema_2/page-1/#useref","title":"useRef","text":"<p><code>useRef</code> es un hook de React que te permite referenciar un valor que no es necesario renderizarlo. Se trata de una herramienta poderosa que ofrece una gran flexibilidad y unas capacidades inmensas, pero los desarrolladores a menudo lo malinterpretan y lo utilizan incorrectamente.</p> <p>El hook <code>useRef</code> tiene dos prop\u00f3sitos principales:</p> <ul> <li>Almacenar valores mutables que no provocan una nueva renderizaci\u00f3n cuando se actualizan.</li> <li>Almacenar referencias a elementos DOM.</li> </ul> <p>Cuando un componente se renderiza en React, normalmente se restablecen su estado y otras variables. Sin embargo, hay casos en los que necesitas conservar ciertos valores incluso cuando el componente se vuelva a renderizar a un valor que persistir\u00e1 entre renderizaciones, asegurando que ell valor permanece intacto aunque cambien otras partes del componente. Adem\u00e1s, es fundamental para trabajar con elementos DOM.</p> <p>En React, acceder a los elementos del DOM y modificarlos directamente puede resultar complicado, especialmente sin el Hook <code>useRef</code>. Con \u00e9l, puedes obtener una referencia a un elemento DOM concreto y realizar operaciones sobre \u00e9l. Esto elimina la necesidad de bibliotecas externas o de complicadas soluciones.</p> <p>Para usar el hook, ser\u00e1 necesario primero importarlo de la librer\u00eda de <code>react</code>, y luego crear una constante que almacene dicha referencia:</p> <pre><code>import {useRef} from 'react'\nconst myRef = useRef()\n</code></pre> <p>Una vez creado el objeto ref se puede utilizar para almacenar valores y acceder a ellos. Se le puede asignar a la prop <code>ref</code> del elemento que nos interese:</p> <pre><code>&lt;div ref={myRef}&gt;This is an element&lt;/div&gt;\n</code></pre> <p>Para acceder al valor de la referencia, se usa la propiedad <code>current</code> del objeto ref:</p> <pre><code>const value = myRef.current\nconsole.log(value) // &lt;div&gt;This is an element&lt;/div&gt;\n</code></pre> <p>Manipular el DOM es una tarea habitual en el desarrollo web porque te permite cambiar y actualizar din\u00e1micamente el contenido, la estructura y la apariencia de una p\u00e1gina web. En el desarrollo tradicional de JavaScript, acceder y manipular elementos del DOM requer\u00eda utilizar m\u00e9todos como <code>getElementById</code>, <code>querySelector</code>, o <code>getElementsByClassName</code> para seleccionar elementos espec\u00edficos del documento. Una vez seleccionados, puedes actualizar el contenido, modificar los estilos o adjuntar escuchadores de eventos.</p> <pre><code>// HTML\n&lt;div&gt;\n&lt;input type=\"text\" id=\"myInput\" /&gt;\n&lt;button id=\"focusButton\"&gt;Focus Input&lt;/button&gt;\n&lt;/div&gt;\n// JavaScript\n&lt;script&gt;\nconst inputRef = document.getElementById('myInput');\nconst focusButton = document.getElementById('focusButton');\nconst handleFocus = function() {\ninputRef.focus();\n};\nfocusButton.addEventListener('click', handleFocus);\n&lt;/script&gt;\n</code></pre> <p>Sin embargo, cuando se trabaja con elementos del DOM en un componente React, el proceso no es el mismo debido al DOM virtual del componente y a la necesidad de gestionar las actualizaciones de forma eficiente. A menudo, los desarrolladores recurren a diversos enfoques, como el uso de <code>refs</code> o librer\u00edas externas como <code>jQuery</code>, para acceder a los elementos del DOM y manipularlos.</p> <p>Con la introducci\u00f3n del Hook <code>useRef</code> en React, el proceso de trabajar con elementos DOM dentro de los componentes se ha agilizado significativamente. El Hook useRef proporciona una forma directa de crear una referencia a un elemento DOM, haci\u00e9ndolo f\u00e1cilmente accesible y manipulable dentro del contexto del componente.</p> <pre><code>import { useRef } from 'react';\nconst FocusComponent = () =&gt; {\nconst inputRef = useRef(null);\nconst handleFocus = () =&gt; {\n// accessing the input element\nlet inputElement = inputRef.current;\n// modify the DOM element\ninputElement.focus();\n};\nreturn (\n&lt;div&gt;\n&lt;input type=\"text\" ref={inputRef} /&gt;\n&lt;button onClick={handleFocus}&gt;Focus Input&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre>"},{"location":"tema_2/page-1/#proyecto-twitterfollowcard","title":"Proyecto TwitterFollowCard","text":"<p>En este proyecto vamos a crear una tarjeta de usuario de twitter, en la cual, se va modificar el bot\u00f3n cada vez que se interact\u00fae sobre \u00e9l.</p> <p> Figura 3 - Proyecto useRef</p> <p>En nuestro archivo principal, <code>main.js</code>, hacemos nuestra llamada a nuestro componente principal <code>App</code>:</p> <pre><code>import ReactDOM from 'react-dom/client'\nimport { App } from './App'\nimport './index.css'\nconst root = ReactDOM.createRoot(document.getElementById('root'))\nroot.render(\n&lt;App /&gt;\n)\n</code></pre> <p>Nuestro componente principal hace una llamada a nuestro componente <code>TwitterFollowCard</code>, 5 veces:</p> <pre><code>import './App.css'\nimport { TwitterFollowCard } from './TwitterFollowCard'\nexport function App() {\nreturn (\n&lt;section className='App'&gt;\n&lt;TwitterFollowCard isFollowing username=\"selenagomez\" name=\"Selena Gomez\" /&gt;\n&lt;TwitterFollowCard username=\"taylorswift13\" name=\"Taylor Swift\" /&gt;\n&lt;TwitterFollowCard isFollowing username=\"midudev\" name=\"Miguel \u00c1ngel Duran\" /&gt;\n&lt;TwitterFollowCard isFollowing username=\"irubenboy\" name=\"Rub\u00e9n Moreno Narbona\" /&gt;\n&lt;TwitterFollowCard isFollowing name=\"Desconocido\" /&gt;\n&lt;/section&gt;\n)\n}\n</code></pre> <p>El componente <code>TwitterFollowCard</code> contiene los elementos principales para tratar con los elementos, incluido una referencia para trabajar con el bot\u00f3n:</p> <pre><code>import { useRef } from 'react'\nexport function TwitterFollowCard({ username = 'unknown', name, isFollowing = false }) {\nconst buttonRef = useRef()\nconst followedClassName = 'tw-followCard-button-followed'\nconst handlerButtonClick = () =&gt; {\nif (buttonRef.current.classList.contains(followedClassName)) {\nbuttonRef.current.classList.remove(followedClassName)\nbuttonRef.current.innerText = 'Seguir'\n} else {\nbuttonRef.current.classList.add(followedClassName)\nbuttonRef.current.innerHTML = ''\n}\n}\nreturn (\n&lt;article className='tw-followCard'&gt;\n&lt;header className='tw-followCard-header'&gt;\n&lt;img className='tw-followCard-avatar' src={`https://unavatar.io/twitter/${username}`} alt=\"Avatar\" /&gt;\n&lt;div className='tw-followCard-info'&gt;\n&lt;strong&gt;{name}&lt;/strong&gt;\n&lt;span className='tw-followCard-infoUsername'&gt;@{username}&lt;/span&gt;\n&lt;/div&gt;\n&lt;/header&gt;\n&lt;aside&gt;\n&lt;button\nref={buttonRef}\nclassName={`tw-followCard-button${isFollowing ? (' ' + followedClassName) : ''}`}\nonClick={handlerButtonClick}\n&gt;\n{isFollowing ? \"\" : \"Seguir\"}\n&lt;/button&gt;\n&lt;/aside&gt;\n&lt;/article&gt;\n)\n}\n</code></pre> <p>M\u00e1s detalladamente, el elemento <code>button</code> es el que contiene la referencia:</p> <pre><code>const buttonRef = useRef()\n//...\nreturn (\n//...\n&lt;button ref={buttonRef}&gt;//...&lt;/button&gt;\n)\n</code></pre> <p>Manejaremos el contenido haciendo uso de la clase <code>tw-followCard-button-followed</code> si es seguido, por el contrario el elemento, no contendr\u00e1 dicha clase. Este ser\u00eda el CSS del bot\u00f3n:</p> <pre><code>.tw-followCard-button {\nmargin-left: 16px;\nborder: 0;\nborder-radius: 999px;\npadding: 6px 16px;\nfont-weight: bold;\ncursor: pointer;\n}\n.tw-followCard-button:hover {\nbackground-color: #a3a3a3;\ntransition: .3s ease background-color;\n}\n.tw-followCard-button-followed {\nbackground-color: transparent;\ncolor: white;\nborder: 0.5px solid white;\n}\n.tw-followCard-button-followed::after {\ncontent: 'Siguiendo';\n}\n.tw-followCard-button-followed:hover {\ncolor: rgb(190, 47, 47);\nborder-color: rgb(190, 47, 47);\nbackground-color: rgb(190, 47, 47, .25);\n}\n.tw-followCard-button-followed:hover::after {\ncontent: 'Dejar de seguir';\ntransition: background-color 0.1s linear 0.1s;\n}\n</code></pre> <p>Y con el m\u00e9todo <code>handleButtonClick</code> manejamos la acci\u00f3n de hacer clic al bot\u00f3n:</p> <pre><code>const handlerButtonClick = () =&gt; {\nif (buttonRef.current.classList.contains(followedClassName)) {\nbuttonRef.current.classList.remove(followedClassName)\nbuttonRef.current.innerText = 'Seguir'\n} else {\nbuttonRef.current.classList.add(followedClassName)\nbuttonRef.current.innerHTML = ''\n}\n}\n</code></pre> <p>En el c\u00f3digo anterior, gracias a la propiedad <code>current</code> de la referencia, podemos acceder a la propiedad <code>classList</code> que devuelve la lista de clases del elemento. De esta manera, comprobando si contiene o no la clase <code>tw-followCard-button-followed</code> se le eliminar\u00e1 o a\u00f1adir\u00e1 dicha clase, respectivamente, adem\u00e1s de que se le indique un texto Seguir en caso de que la contenga, y nada en caso de que no la contenga (en ese caso, el texto es manejado con CSS que al a\u00f1adir la clase trabajar\u00e1 con las propiedad <code>hover</code> y <code>after</code>)</p>"},{"location":"tema_2/page-2/","title":"2 Estados","text":""},{"location":"tema_2/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>El estado de un componente son las diferentes formas en las que se puede presentar un componente. Supongamos que tenemos un componente llamado l\u00e1mpara y su estado puede ser apagado o encendido. Para que se produzca dicho cambio de estado necesitamos tener un desencadenante, en el caso de la l\u00e1mpara ser\u00eda un interruptor.</p> <p>En React existen varias formas para poder trabajar con los estados. Si usamos componentes de clase, existe un atributo <code>state</code> que controlar\u00e1 esas variables que funcionen como desencadenante, pero para los componentes funci\u00f3n tienen un hook.</p>"},{"location":"tema_2/page-2/#usestate","title":"useState","text":"<p>El <code>useState</code> es un hook en React que controla el estado de un componente. Dicho hook puede recibir un estado inicial:</p> <pre><code>const state = useState(false)\n</code></pre> <p>El m\u00e9todo <code>useState([initial])</code> devuelve un array de tama\u00f1o dos, siendo la primera posici\u00f3n el valor del estado y el segundo el m\u00e9todo que desencadena el cambio, por lo que para un mayor entendimiento se puede usar la destructuraci\u00f3n:</p> <pre><code>const [light, setLight] = useState(false)\n</code></pre> <p>El cambio de estado de un componente produce que se vuelva a renderizar. Cuando se cambia el estado el DOM Virtual de React solo actualizar\u00e1 aquella parte que cambia, salt\u00e1ndose las partes que no sufren cambio ninguno. Para ello, busca las diferentes entre el componente antes del cambio y despu\u00e9s del cambio, lo que se diferente despu\u00e9s del cambio es lo \u00fanico que se va a actualizar.</p> <pre><code>const App = () =&gt; {\nconst [count, setCount] = useState(0)\nreturn (\n&lt;&gt;\n&lt;h1&gt;Has clicado el bot\u00f3n {count} veces&lt;/h1&gt;\n&lt;button onClick={() =&gt; setCount(count+1)}&gt;Cambiar estado&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>En el ejemplo anterior, al hacer clic en el bot\u00f3n, cambia el valor de la variable <code>count</code>, haciendo que el componente se renderice, actualizando \u00fanicamente el elemento <code>h1</code>.</p> <p>Cuando React renderiza elementos en el DOM, utiliza un algoritmo de conciliaci\u00f3n (reconciliaci\u00f3n) para comparar el nuevo \u00e1rbol de elementos con el \u00e1rbol anterior y determinar las diferencias. El prop\u00f3sito de las keys es ayudar a React a identificar de manera \u00fanica cada elemento y realizar operaciones de manera eficiente.</p> <p>Cuando se renderiza un componente por un cambio de estado, estos cambios se propagan hacia abajo, es decir, van desde los componentes padres a los componentes hijos. Otra forma de decirlo, cuando se renderiza un componente padre se vuelve a renderizar un componente hijo independientemente de que en el componente hijo nada haya cambiado y por lo tanto no se actualice nada. Sin embargo, no sucede al rev\u00e9s, si se renderiza un hijo por el cambio de estado, no se va a renderizar el padre.</p> <pre><code>const App = () =&gt; {\nconst [count, setCount] = useState(0)\nreturn (\n&lt;&gt;\n&lt;H1Componente count={count} /&gt;\n&lt;button onClick={() =&gt; setCount(count+1)}&gt;Cambiar estado&lt;/button&gt;\n&lt;/&gt;\n)\n}\nconst H1Componente = ({count = 0}) =&gt; {\nreturn (\n&lt;h1&gt;Has clicado el bot\u00f3n {count} veces&lt;/h1&gt;\n)\n}\n</code></pre> <p>En el ejemplo anterior, al hacer clic al bot\u00f3n del componente <code>App</code> se renderizar\u00e1 el componente <code>App</code>, as\u00ed como su componente hijo <code>H1Componente</code>. En este caso los cambios se ver\u00e1 reflejado en el hijo ya que la variable que cambia si se hace referencia en el componente hijo, aunque no tiene porque ser as\u00ed, el renderizado SI se hace pero la actualizaci\u00f3n s\u00f3lo si es necesaria.</p> <p>Si el componente hijo tambi\u00e9n tiene un estado, se puede inicializar dicho estado a trav\u00e9s de la props y realizar el cambio desde el interior del componente.</p> <pre><code>const App = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;Component initialCount={0} /&gt;\n&lt;/&gt;\n)\n}\nconst Component = ({initialCount = 0}) =&gt; {\nconst [count, setCount] = useState(initialCount)\nreturn (\n&lt;h1&gt;Has clicado el bot\u00f3n {count} veces&lt;/h1&gt;\n&lt;button onClick={() =&gt; setCount(count+1)}&gt;Cambiar estado&lt;/button&gt;\n)\n}\n</code></pre> <p>\u00a1Cuidad!</p> <p>El estado de un componente solo se inicializa una sola vez, por lo que si en el padre se cambia el estado de una variable y dicha variable inicializa el estado del hijo, SOLO se inicializa en la primera renderizaci\u00f3n. Cada vez que se vuelva a renderizar no sufrir\u00e1 cambios.</p> <pre><code>const App = () =&gt; {\nconst [count, setCount] = useState(0) return (\n&lt;&gt;\n&lt;Component initialCount={count} /&gt;\n&lt;button onClick={() =&gt; setCount(count+1)}&gt;Cambiar inicializaci\u00f3n&lt;/button&gt;\n&lt;/&gt;\n)\n}\nconst Component = ({initialCount = 0}) =&gt; {\nconst [count, setCount] = useState(initialCount) //(1)!\nreturn (\n&lt;h1&gt;Has clicado el bot\u00f3n {count} veces&lt;/h1&gt;\n&lt;button onClick={() =&gt; setCount(count+1)}&gt;Cambiar estado&lt;/button&gt;\n)\n}\n</code></pre> <ol> <li>Solo se inicializa una vez</li> </ol>"},{"location":"tema_2/page-2/#clave-de-un-elemento","title":"Clave de un elemento","text":"<p>\u00bfC\u00f3mo puede React identificar los elemento para saber que son diferentes? Si tenemos un componente con 5 elementos <code>h1</code>, \u00bfc\u00f3mo sabe que el primero no es el mismo que el segundo? Ambos elementos podr\u00edan tener el mismo contenido, pero a\u00fan as\u00ed son elementos diferentes.</p> <p>React sabe diferencia un elemento de otro gracias a su posici\u00f3n en el DOM Virtual, lo que no suponen problema a la hora de una nueva renderizaci\u00f3n, por lo que React puede seguir gestionando la reconciliaci\u00f3n de manera eficiente sin necesidad de nada que identifique al elemento.</p> <p>Pero, supongamos que tenemos una lista de usuarios y cada usuario queremos mostrarlo en un componente. Ser\u00e1 necesario hacer un ciclo que recorra dicha lista y crear el elemento del componente con los datos necesarios:</p> <pre><code>const App = () =&gt; {\nconst users = [\n{id: 1, name: 'Nerea'},\n{id: 2, name: 'Sofia'},\n{id: 3, name: 'Leticia'},\n{id: 4, name: 'Marcos'},\n]\nreturn (\nusers.map(user =&gt; &lt;UserComponent name={user.name}/&gt;)\n)\n}\nconst UserComponent = ({name = ''}) =&gt; {\n&lt;h1&gt;Hello {name}&lt;/h1&gt;\n}\n</code></pre> <p>Recuerda</p> <p>No se puede usar estructuras dentro de c\u00f3digo JSX (if, for, etc). Se debe usar funciones que devuelvan elementos o datos, como <code>map</code>, o una ternaria. </p> <p>Si se cambiase el estado de el componente <code>App</code> renderizar\u00eda una vez m\u00e1s la lista, lo que no asegura que el orden se mantenga igual antes que el cambio de estado. Por lo que, para React es m\u00e1s complicado identificar la diferencia cada uno de los elementos del DOM Virtual.</p> <p>Para evitar este problema, React dispone de un atributo llamado <code>key</code> que sirve como identificador de los elementos de React, que se recomienda su uso en los elementos que est\u00e9n dentro de un ciclo, para poder identificarlos y en caso de renderizaci\u00f3n comprobar si han sufridos cambios para actualizarlos. El valor de dicho atributo debe ser un valor \u00fanico y est\u00e1tico, por lo que no se recomienda el uso de funciones como <code>Math.random()</code> o <code>Symbol()</code> (que pueden cambiar con cada renderizaci\u00f3n), ni propiedades que puedan cambiar (como el nombre de un usuario).</p> <pre><code>const App = () =&gt; {\nconst users = [\n{id: 1, name: 'Nerea'},\n{id: 2, name: 'Sofia'},\n{id: 3, name: 'Leticia'},\n{id: 4, name: 'Marcos'},\n]\nreturn (\nusers.map(user =&gt; &lt;UserComponent key={id} name={user.name}/&gt;)\n)\n}\nconst UserComponent = ({name = ''}) =&gt; {\n&lt;h1&gt;Hello {name}&lt;/h1&gt;\n}\n</code></pre> <p>El uso del atributo <code>key</code> NO es obligatorio, pero es una buena pr\u00e1ctica proporcionar keys \u00fanicas siempre que sea posible, incluso para elementos individuales que no provienen de un ciclo. Esto se debe a que puede haber casos en los que, en el futuro, el componente o el elemento pueda cambiar de manera din\u00e1mica, y tener una key \u00fanica puede ayudar a React a optimizar la actualizaci\u00f3n y renderizaci\u00f3n del componente de manera m\u00e1s eficiente.</p>"},{"location":"tema_2/page-2/#proyecto-twitterfollowcard-con-usestate","title":"Proyecto TwitterFollowCard con useState","text":"<p>En este proyecto vamos a mejorar el proyecto TwitterFollowCard, pero en lugar de usar <code>useRef</code> usaremos <code>useState</code>. Es m\u00e1s, en este proyecto tiene m\u00e1s sentido el uso de <code>useState</code> en lugar de <code>useRef</code>, ya que una de las caracter\u00edsticas de React es que usa la programaci\u00f3n declarativa, y el <code>useRef</code> nos obligaba en parte a utilizar la programaci\u00f3n imperativa.</p> <p>En primer lugar, creamos una lista con los usuarios que queremos mostrar y haciendo uso de la funci\u00f3n <code>map</code> transformamos dicha lista en el componente <code>TwitterFollowCard</code>, identificando dicho componente con el nombre de usuario. Adem\u00e1s, en lugar de recibir si se est\u00e1 siguiendo o no al usuario, sino que se le pasa el estado inicial, ya que puede ser cambiado.</p> <pre><code>const users = [\n{\nusername: 'selenagomez',\nname: 'Selena Gomez',\nisFollowing: true\n},\n{\nusername: 'taylorswift13',\nname: 'Taylor Swift',\nisFollowing: false\n},\n{\nusername: 'midudev',\nname: 'Miguel \u00c1ngel Duran',\nisFollowing: true\n},\n{\nusername: 'irubenboy',\nname: 'Rub\u00e9n Moreno Narbona',\nisFollowing: false\n},\n{\nname: 'Desconocido',\n}\n]\nexport function App() {\nreturn (\n&lt;section className='App'&gt;\n{\nusers.map(({ username, isFollowing, name }) =&gt; (&lt;TwitterFollowCard\nkey={username}\nusername={username}\ninitialIsFollowing={isFollowing}\nname={name}\n/&gt;))\n}\n&lt;/section&gt;\n)\n}\n</code></pre> <p>Ahora en el componente <code>TwitterFollowCard</code>, se tratar\u00e1 el estado, forzando el cambio cada vez que se clique el bot\u00f3n, y se jugar\u00e1 con las clases del bot\u00f3n, pero usando la programaci\u00f3n declarativa, en lugar de la imperativa.</p> <pre><code>export function TwitterFollowCard({ username = 'unknown', name, initialIsFollowing = false }) {\nconst [isFollowing, setIsFollowing] = useState(initialIsFollowing)\nconst text = isFollowing ? '' : 'Seguir'\nconst buttonClassName = isFollowing ? 'tw-followCard-button is-following' : 'tw-followCard-button'\nconst handleClick = () =&gt; {\nsetIsFollowing(!isFollowing)\n}\nreturn (\n&lt;article className='tw-followCard'&gt;\n&lt;header className='tw-followCard-header'&gt;\n&lt;img className='tw-followCard-avatar' src={`https://unavatar.io/twitter/${username}`} alt=\"Avatar\" /&gt;\n&lt;div className='tw-followCard-info'&gt;\n&lt;strong&gt;{name}&lt;/strong&gt;\n&lt;span className='tw-followCard-infoUsername'&gt;@{username}&lt;/span&gt;\n&lt;/div&gt;\n&lt;/header&gt;\n&lt;aside&gt;\n&lt;button className={buttonClassName} onClick={handleClick}&gt;{text}&lt;/button&gt;\n&lt;/aside&gt;\n&lt;/article&gt;\n)\n}\n</code></pre> <p>Importante</p> <p>El estado no se puede mutar de forma directa, es decir, no puedes cambiar su valor directamente. Por ejemplo, si usamos el useState con una lista, no se aconseja a\u00f1adir elementos de forma manual:</p> <pre><code>const [list, setList] = useState([])\nconst update = () =&gt; {\nlist.push('a') // \u274c \u00a1NO!  \n}\n</code></pre> <p>Esto puede provocar resultados no deseados e incluso puede que no se renderice el componente, lo que puede desembocar en discrepancias con el estado. En su lugar, se recomienda hacer el spread operator dentro del m\u00e9todo <code>set</code> del estado:</p> <pre><code>const [list, setList] = useState([])\nconst update = () =&gt; {\nsetList([...list, 'a']) // \u2705 \n}\n</code></pre>"},{"location":"tema_2/page-2/#estado-asincrono","title":"Estado as\u00edncrono","text":"<p>La actualizaci\u00f3n de los estados en React son as\u00edncronos, es decir, no bloquean el renderizado ni el c\u00f3digo que viene a continuaci\u00f3n del cambio de estado. Por ese motivo, si se cambia el estado y autom\u00e1ticamente se accede al mismo, puede que el estado a\u00fan no haya sido actualizado y estemos accediendo a un valor anterior:</p> <pre><code>const [isFollowing, setIsFollowing] = useState(false)\nconst handleClick = () =&gt; {\nsetIsFollowing(true)\nconsole.log(isFollowing) // false\n}\n</code></pre> <p>Aunque sea as\u00edncrono NO se puede usar el await porque no se debe romper el flujo.</p> <p>El m\u00e9todo de actualizaci\u00f3n de un estado puede recibir un callback cuyo par\u00e1metro sea el valor anterior, y retorne el nuevo valor.</p> <pre><code>const [isFollowing, setIsFollowing] = useState(false)\nconst update = () =&gt; {\nuseState((prev) =&gt; {\nconsole.log(prev) // Se accede al valor anterior\nreturn !prev // actualiza estado\n})\n}\n</code></pre> <p>Los estados tambi\u00e9n pueden recibir un callback en sus inicializaci\u00f3n, para inicializar el estado a trav\u00e9s de una l\u00f3gica, o inicializarlo con una operaci\u00f3n lenta que queramos que se haga una sola vez:</p> <pre><code>const [state, setState] = useState(() =&gt; {\nconst random = Math.random()\nif(random % 2 === 0){\nreturn random\n}\nreturn 0\n})\n</code></pre>"},{"location":"tema_2/page-3/","title":"3 Efectos","text":""},{"location":"tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>En React, los efectos son acciones que ocurren fuera del flujo de renderizado normal y que generalmente est\u00e1n relacionadas con la interacci\u00f3n con el DOM, llamadas a servicios web, suscripciones a eventos o cualquier otra operaci\u00f3n as\u00edncrona.</p> <p>En versiones anteriores de React, para manejar efectos secundarios, se utilizaban principalmente los m\u00e9todos de ciclo de vida de los componentes de clase, como <code>componentDidMount</code> y <code>componentDidUpdate</code>. Sin embargo, con la introducci\u00f3n de React Hooks en React 16.8, la gesti\u00f3n de efectos secundarios se ha vuelto m\u00e1s sencilla y flexible.</p> <p>En el contexto de React Hooks, el hook <code>useEffect</code> se utiliza para manejar efectos secundarios en componentes funcionales.</p>"},{"location":"tema_2/page-3/#useeffect","title":"useEffect","text":"<p>El <code>useEffect</code> es un hook que nos permite ejecutar c\u00f3digo arbitrario cuando el componente se monta en el DOM y cada vez que se actualiza las dependencias que le indiquemos. El <code>useEffect</code> es un m\u00e9todo que recibe dos par\u00e1metros: un callback que se ejecutar\u00e1 cuando se monta el DOM, ya sea al principio o a cambiar el estado de alguna de las dependencias (este par\u00e1metro es obligatorio); y una lista de dependencias de las que depender\u00e1 el <code>useEffect</code>, que en caso de que cambien de estado producir\u00e1 una nueva llamada del callback:</p> <pre><code>useEffect(callback, [dependencias])\n</code></pre> <p>El <code>useEffect</code> se ejecuta m\u00ednimo una vez, cuando el componente se monta por primera vez en el DOM.</p> <pre><code>useEffect(() =&gt; {\nconsole.log('Probando use effect')\n})\nconst App = () =&gt; {\nreturn (\n&lt;h1&gt;Prueba del efecto&lt;/h1&gt;\n)\n}\n</code></pre>"},{"location":"tema_2/page-3/#dependencias","title":"Dependencias","text":"<p>Las dependencias del <code>useEffect</code> son las variables de las que depende el efecto en s\u00ed, es decir, las variables que si cambian de valor producir\u00e1n que el callback del efecto se vuelva a ejecutar.</p> <pre><code>const App = () =&gt; {\nconst [state, setState] = useState(false)\nuseEffect(() =&gt; {\nconsole.log('Ejecutando')    }, [state])\nreturn (\n&lt;&gt;\n&lt;h1&gt;Ejemplo de useEffect&lt;/h1&gt;\n&lt;button onClick={() =&gt; setState(!state)}&gt;Cambiar estado&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>En el ejemplo anterior se mostrar\u00e1 el <code>console.log</code> cada vez que cambie el estado de la variable <code>state</code>. La primera ejecuci\u00f3n se hace cuando se monta el componente en el DOM.</p> <p>En caso de que no se indiquen dependencias, el efecto ser\u00e1 ejecutado cada vez que se renderice el componente, lo que a veces puede ser contraproducente para nuestro proyecto:</p> <pre><code>const App = () =&gt; {\nconst [state, setState] = useState(false)\nuseEffect(() =&gt; {\nconsole.log('Ejecutando')    })\nreturn (\n&lt;&gt;\n&lt;h1&gt;Ejemplo de useEffect&lt;/h1&gt;\n&lt;button onClick={() =&gt; setState(!state)}&gt;Cambiar estado&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>Para ejecutar el efecto una \u00fanica vez y evitar que se realice en cada renderizado sin que dependa de ning\u00fan estado, es conveniente que la lista de las dependencias este vac\u00edo.</p> <pre><code>const App = () =&gt; {\nconst [state, setState] = useState(false)\nuseEffect(() =&gt; {\nconsole.log('Ejecutando')    }, [])\nreturn (\n&lt;&gt;\n&lt;h1&gt;Ejemplo de useEffect&lt;/h1&gt;\n&lt;button onClick={() =&gt; setState(!state)}&gt;Cambiar estado&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre>"},{"location":"tema_2/page-3/#proyecto-mouseeffect","title":"Proyecto MouseEffect","text":"<p>En este proyecto vamos a crear un componente que muestre una bola que persiga al puntero por toda la pantalla. En nuestro componente principal vamos a introducir el componente dentro de un main:</p> <pre><code>function App() {\nreturn (\n&lt;main&gt;\n&lt;FollowMouse /&gt;\n&lt;/main&gt;\n)\n}\nexport default App\n</code></pre> <p>En nuestro componente <code>FollowMouse</code> vamos a tener los elementos necesarios para crear la bola, as\u00ed como un bot\u00f3n que cambie el estado.</p> <pre><code>const FollowMouse = () =&gt; {\nreturn (\n&lt;&gt;\n&lt;div style={{\nposition: 'absolute',\nbackgroundColor: 'rgba(0, 0, 0, 0.5)',\nborder: '3px solid #fff',\nborderRadius: '50%',\nopacity: 0.8,\npointerEvents: 'none',\nleft: -20,\ntop: -20,\nwidth: 40,\nheight: 40,\ntransform: `translate(0px, 0px)`\n}}/&gt;\n&lt;button&gt;Activar seguir puntero&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>A continuaci\u00f3n, se indica los estilos de los ficheros index.css para estilos globales y App.css para el estilo de nuestro componente:</p> index.cssApp.css <pre><code>:root {\nfont-family: Inter, Avenir, Helvetica, Arial, sans-serif;\nfont-size: 16px;\nline-height: 24px;\nfont-weight: 400;\ncolor-scheme: light dark;\ncolor: rgba(255, 255, 255, 0.87);\nbackground-color: #242424;\nfont-synthesis: none;\ntext-rendering: optimizeLegibility;\n-webkit-font-smoothing: antialiased;\n-moz-osx-font-smoothing: grayscale;\n-webkit-text-size-adjust: 100%;\n}\na {\nfont-weight: 500;\ncolor: #646cff;\ntext-decoration: inherit;\n}\na:hover {\ncolor: #535bf2;\n}\nbody {\nmargin: 0;\ndisplay: grid;\nplace-items: center;\nmin-width: 320px;\nmin-height: 100vh;\n}\nh1 {\nfont-size: 3.2em;\nline-height: 1.1;\n}\nbutton {\nborder-radius: 8px;\nborder: 1px solid transparent;\npadding: 0.6em 1.2em;\nfont-size: 1em;\nfont-weight: 500;\nfont-family: inherit;\nbackground-color: #1a1a1a;\ncursor: pointer;\ntransition: border-color 0.25s;\n}\nbutton:hover {\nborder-color: #646cff;\n}\nbutton:focus,\nbutton:focus-visible {\noutline: 4px auto -webkit-focus-ring-color;\n}\n@media (prefers-color-scheme: light) {\n:root {\ncolor: #213547;\nbackground-color: #ffffff;\n}\na:hover {\ncolor: #747bff;\n}\nbutton {\nbackground-color: #f9f9f9;\n}\n}\nbody.no-cursor {\ncursor: none;\n}\n</code></pre> <pre><code>#root {\nmax-width: 1280px;\nmargin: 0 auto;\npadding: 2rem;\ntext-align: center;\n}\n.logo {\nheight: 6em;\npadding: 1.5em;\nwill-change: filter;\n}\n.logo:hover {\nfilter: drop-shadow(0 0 2em #646cffaa);\n}\n.logo.react:hover {\nfilter: drop-shadow(0 0 2em #61dafbaa);\n}\n@keyframes logo-spin {\nfrom {\ntransform: rotate(0deg);\n}\nto {\ntransform: rotate(360deg);\n}\n}\n@media (prefers-reduced-motion: no-preference) {\na:nth-of-type(2) .logo {\nanimation: logo-spin infinite 20s linear;\n}\n}\n.card {\npadding: 2em;\n}\n.read-the-docs {\ncolor: #888;\n}\n</code></pre> <p>Controlamos si se desea seguir o no el puntero con un estado que se cambiar\u00e1 al hacer clic en el bot\u00f3n (el mensaje del bot\u00f3n tambi\u00e9n cambiar\u00e1):</p> <pre><code>const FollowMouse = () =&gt; {\nconst [enabled, setEnabled] = useState(false)\nreturn (\n&lt;&gt;\n{/*...*/}\n&lt;button onClick={() =&gt; setEnabled(!enabled)}&gt;{enabled ? 'Desactivar' : 'Activar'} seguir puntero&lt;/button&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>Para poder indicar la posici\u00f3n de la bola tendremos un estado position de tipo objecto con dos atributos, uno para la posici\u00f3n X y otro para la posici\u00f3n Y:</p> <pre><code>const FollowMouse = () =&gt; {\n//...\nconst [position, setPosition] = useState({ x: 0, y: 0 })\nreturn (\n&lt;&gt;\n&lt;div style={{\n//...\ntransform: `translate(${position.x}px, ${position.y}px)`\n}} /&gt;\n{/*...*/}\n&lt;/&gt;\n)\n}\n</code></pre> <p>El estado de la posici\u00f3n se cambiar\u00e1 cada vez que el puntero se mueva, por lo que debemos suscribirnos al evento <code>pointermove</code>, para ello usamos el <code>useEffect</code> con la dependencia enabled:</p> <pre><code>const FollowMouse = () =&gt; {\nuseEffect(() =&gt; {\nconsole.log('effect ', { enabled })\nconst handleMove = event =&gt; {\nconst { clientX, clientY } = event\nconsole.log('handleMove', { clientX, clientY })\nsetPosition({ x: clientX, y: clientY })\n}\nif (enabled) {\nwindow.addEventListener('pointermove', handleMove)\n}\n}, [enabled])\n// ..\n}\n</code></pre> <p>Como podemos comprobar si est\u00e1 activado veremos la bola en lugar del puntero, pero al desactivarlo seguimos viendo la bola. Esto ocurre porque nos estamos suscribiendo a un evento pero en ning\u00fan momento dejamos de suscribirnos.</p>"},{"location":"tema_2/page-3/#retorno-de-un-useeffect","title":"Retorno de un useEffect","text":"<p>El <code>useEffect</code> puede retornar un callback, dicho m\u00e9todo ser\u00e1 ejecutado cuando:</p> <ul> <li>Se desmonta el componente</li> <li>Cada vez que se cambia una dependencia y se va a volver a ejecutar el <code>useEffect</code>, es decir, al cambiar la dependencia el efecto deja de producirse ejecutando el m\u00e9todo y vuelve a ejecutarlo.</li> </ul> <p>Este <code>return</code> no es obligatorio, pero si es l\u00f3gico usarlo cuando realizamos ciertas operaciones que queremos limpiar, como por ejemplo eliminar la suscripci\u00f3n a un evento, por lo que el problema del proyecto anterior se puede evitar retornando un m\u00e9todo que elimine la suscripci\u00f3n al evento:</p> <pre><code>const FollowMouse = () =&gt; {\nuseEffect(() =&gt; {\nconsole.log('effect ', { enabled })\nconst handleMove = event =&gt; {\nconst { clientX, clientY } = event\nconsole.log('handleMove', { clientX, clientY })\nsetPosition({ x: clientX, y: clientY })\n}\nif (enabled) {\nwindow.addEventListener('pointermove', handleMove)\n}\nreturn () =&gt; {\nconsole.log('cleanup')\nwindow.removeEventListener('pointermove', handleMove)\n}\n}, [enabled])\n// ...\n}\n</code></pre> <p>El retorno tambi\u00e9n se va a realizar cuando se desmonta el componente, es decir, cuando se elimine del DOM. Vamos a modificar nuestro proyecto, a\u00f1adiendo un bot\u00f3n y un estado para montar y desmontar el componente <code>FollowMouse</code>. En caso de no tener el <code>return</code> en el <code>useEffect</code> nunca eliminar\u00edamos la suscripci\u00f3n del puntero por lo que seguir\u00edamos registrando dicho evento, a pesar de no poder ejecutar nada en el momento. Por eso, para evitar esto es conveniente usarlo</p> <pre><code>function App() {\nconst [mounted, setMounted] = useState(true)\nreturn (\n&lt;main&gt;\n{mounted &amp;&amp; &lt;div&gt;&lt;FollowMouse /&gt;&lt;/div&gt;}\n&lt;button onClick={() =&gt; setMounted(!mounted)}&gt;Toggle mounted FollowMouse component&lt;/button&gt;\n&lt;/main&gt;\n)\n}\n</code></pre>"},{"location":"tema_2/page-3/#multiples-useeffect","title":"M\u00faltiples useEffect","text":"<p>Se recomienda crear varios <code>useEffect</code> para poder realizar operaciones completamente diferentes, adem\u00e1s de ser una buena pr\u00e1ctica hace que el c\u00f3digo sea m\u00e1s legible. En nuestro proyecto MouseEffect vamos a ocultar nuestro puntero cuando la bola est\u00e9 en movimiento:</p> <pre><code>const FollowMouse = () =&gt; {\n// ...\nuseEffect(() =&gt; {\ndocument.body.classList.toggle('no-cursor', enabled)\nreturn () =&gt; {\ndocument.body.classList.remove('no-cursor')\n}\n}, [enabled])\n//...\n}\n</code></pre> <p>Para eso creamos un nuevo efecto que dependa del estado enabled, es decir, si est\u00e1 activado o no el seguir al puntero, vamos a indicar una clase al <code>body</code> de nuestra p\u00e1gina (<code>no-cursor</code>). Como funci\u00f3n de retorno, devolveremos un m\u00e9todo para que elimine esa clase del <code>body</code>, ya que el <code>body</code> es una etiqueta global y si desmontamos nuestro componente seguir\u00e1 existiendo.</p>"},{"location":"tema_2/page-3/#reactstrictmode","title":"React.StrictMode","text":"<p>Cuando estamos desarrollando un proyecto React decimos que estamos en modo desarrollo. Cuando construimos un proyecto, ya sea con el comando <code>create-react-app</code> o con <code>vite</code>, nuestro componente est\u00e1 en vuelto en un componente de React, <code>StrictMode</code>:</p> <pre><code>ReactDOM.createRoot(document.getElementById('root')).render(\n&lt;React.StrictMode&gt;\n&lt;App /&gt;\n&lt;/React.StrictMode&gt;,\n)\n</code></pre> <p><code>React.StrictMode</code> es un componente especial de React que se utiliza para ayudar a encontrar y corregir problemas en la aplicaci\u00f3n relacionados con el rendimiento y las pr\u00e1cticas no seguras en el c\u00f3digo en modo desarrollo. Puedes envolver partes de tu aplicaci\u00f3n con React.StrictMode para activar un conjunto de comprobaciones adicionales de tiempo de desarrollo que te alertar\u00e1n sobre posibles problemas.</p> <p>Al utilizar <code>React.StrictMode</code>, se habilitan las siguientes comprobaciones:</p> <ul> <li>Detecci\u00f3n de efectos secundarios no deseados: <code>React.StrictMode</code> ayuda a identificar efectos secundarios no intencionales en tus funciones de renderizado. Por ejemplo, si una funci\u00f3n de renderizado tiene efectos secundarios y se llama m\u00e1s de una vez, <code>StrictMode</code> emitir\u00e1 una advertencia. De ah\u00ed que, en modo desarrollo, nuestro <code>useEffect</code> se ejecute dos veces al inicializar el componente.</li> <li>Advertencias sobre el uso de funciones de ciclo de vida obsoletas: Si tu c\u00f3digo utiliza funciones de ciclo de vida de componentes de clase que est\u00e1n obsoletas o se han eliminado en versiones futuras de React, StrictMode te dar\u00e1 advertencias sobre su uso.</li> <li>Detecci\u00f3n de renderizados redundantes: <code>StrictMode</code> puede detectar renderizados redundantes en tus componentes, lo que puede ayudarte a optimizar el rendimiento.</li> <li>Advertencias sobre el uso de FindDOMNode: Si tu aplicaci\u00f3n utiliza <code>findDOMNode</code> para acceder al DOM directamente, <code>StrictMode</code> emitir\u00e1 advertencias. En lugar de usar <code>findDOMNode</code>, se recomienda utilizar <code>ref</code> para acceder a los nodos del DOM.</li> </ul> <p>Es importante destacar que las comprobaciones realizadas por <code>React.StrictMode</code> solo se aplican en el entorno de desarrollo y no afectar\u00e1n a la producci\u00f3n. Por lo tanto, es seguro utilizar <code>React.StrictMode</code> durante el desarrollo para identificar y solucionar problemas potenciales, y luego puedes retirarlo en el entorno de producci\u00f3n para evitar el impacto en el rendimiento.</p> <p>Cuando desplegamos nuestra aplicaci\u00f3n y entramos en modo producci\u00f3n, el <code>React.StrictMode</code> no entra en juego, por lo que esas comprobaciones quedar\u00e1n deshabilitadas, y por ejemplo, el <code>useEffect</code> solo se realizar\u00e1 una vez al inicializar el componente.</p>"},{"location":"tema_2/page-3/#problemas-useeffect","title":"Problemas useEffect","text":"<p>Uno de los problemas de <code>useEffect</code> es que si no se realiza correctamente puede provocar un bucle infinito. Esto adem\u00e1s de ser peligroso y de ejecutar infinitamente una funci\u00f3n, es una mala pr\u00e1ctica.</p> <p>El <code>useEffect</code> se puede ejecutar de forma infinita:</p> <ul> <li> <p>Cuando no se indica dependencia (ni una lista vac\u00eda) y se ejecuta un cambio de estado:</p> <p><code>`javascript useEffect(() =&gt; {     setState(10) })</code></p> </li> <li> <p>Cuando se indica una dependencia y se hace cambio del estado de dicha dependencia:</p> <p>```javascript useEffect(() =&gt; {     setState(10) }, [state])</p> </li> </ul> <p>Otro de los problemas de <code>useEffect</code> es que no puede recibir par\u00e1metros en su callback, por lo que si se desea pasarle alguna variable, debemos crear la variable fuera y acceder a ella dentro del <code>useEffect</code>:</p> <pre><code>const value = 10\nuseEffect(() =&gt; {\nconsole.log(value)\n}, [])\n</code></pre>"},{"location":"tema_2/page-4/","title":"Proyecto","text":"<p>Crea un tres en raya que tenga una apariencia similar a lo siguiente:</p> <p> Figura 4 - Soluci\u00f3n</p> <p>El juego constar\u00e1 de dos forma de juego, una forma manual, en el que el usuario podr\u00e1 interactuar con ambas formas y un modo de inteligencia artificial, en la cual el usuario solo podr\u00e1 jugar con <code>\u274c</code> mientras que la m\u00e1quina elegir\u00e1 el movimiento de <code>\u26aa</code>.</p> <p>El usuario podr\u00e1 elegir el modo de juego clicando en el bot\u00f3n. El mensaje del bot\u00f3n cambiar\u00e1 de forma din\u00e1mica, mostrando Player game si est\u00e1 en modo jugador vs jugador o IA game si est\u00e1 en modo jugador vs m\u00e1quina. Una vez elegida la opci\u00f3n no podr\u00e1 cambiarla hasta que no finalice la partida.</p> <p> Figura 5 - Soluci\u00f3n Bot\u00f3n Modo Juego</p> <p>Se deben controlar aspectos b\u00e1sicos de la l\u00f3gica del juego, como por ejemplo, no se puede seleccionar una casilla que ya tiene un valor, o el juego no puede continuar si hay un empate, o hay un ganador.</p> <p>Debajo de la tabla de un juego aparece las dos opciones de turnos posibles, seleccionado siempre el turno que va a empezar el juego.</p> <p> Figura 6 - Turnos</p> <p>Aparecer\u00e1 un banner que indique el ganador del juego, una vez finalizado, o por el contrario un empate. Contendr\u00e1 un bot\u00f3n para empezar de nuevo en ambos casos.</p> <p> Figura 7 - Ganador</p> <p>Adem\u00e1s, se podr\u00e1 resetear el juego con un bot\u00f3n de reseteo:</p> <p> Figura 7 - Bot\u00f3n de reseteo</p>"},{"location":"tema_2/page-5/","title":"4 Obtenci\u00f3n de datos","text":""},{"location":"tema_2/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>En el mundo del dise\u00f1o de las aplicaciones es buena pr\u00e1ctica separar el dise\u00f1o y propia del usuario (front-end) de la aplicaci\u00f3n de la l\u00f3gica o funcionalidad (back-end). De esta forma ser\u00eda m\u00e1s escalable. Adem\u00e1s existen formas diversas de conectar la parte del usuario con el servidor, como las APIs.</p> <p>En React, es aconsejable realizar est\u00e1 separaci\u00f3n siempre y cuando sea posible y desde el mismo React realizar peticiones al servidor y cuya respuestas tratarlas en React.</p> <p>Para ello en Javascript existe la funci\u00f3n <code>fetch</code> que devuelve una promesa con las respuesta del servidor.</p>"},{"location":"tema_2/page-5/#fetching-de-datos-para-cambiar-estados","title":"Fetching de datos para cambiar estados","text":"<p>El tratamiento del <code>fetch</code> en React se puede hacer en cualquier parte de la aplicaci\u00f3n. Supongamos que tenemos una APP y queremos mostrar una cita gatuna aleatoria. Para ello existe una API a la cual se le puede realizar peticiones GET para que te devuelva una cita aleatoria:</p> <pre><code>const CAT_ENDPOINT_RANDOM_FACT = 'https://catfact.ninja/fact'\nexport const getRandomFact = async () =&gt; {\nconst res = await fetch(CAT_ENDPOINT_RANDOM_FACT)\nconst data = await res.json()\nreturn data.fact\n}\n</code></pre> <p>En el c\u00f3digo anterior vemos como hacemos un fetch a la API deseada y tratamos la respuesta hasta devolver un hecho, haciendo uso del async/await. Dicho m\u00e9todo puede ser usado en nuestro componente <code>App</code>, que contiene un estado para  mostrar la cita deseada. Adem\u00e1s existir\u00e1 un bot\u00f3n que volver\u00e1 a realizar la petici\u00f3n cada vez que se clique en \u00e9l:</p> <pre><code>const App = () =&gt; {\nconst [fact, setFact] = useState()\ngetRandomFact()\n.then(fact =&gt; setFact(fact))\nconst handleClick = () =&gt; {\ngetRandomFact()\n.then(fact =&gt; setFact(fact))\n}\nreturn (\n&lt;main&gt;\n&lt;h1&gt;App de gatitos&lt;/h1&gt;\n&lt;button onClick={handleClick}&gt;Get new fact&lt;/button&gt;\n{fact &amp;&amp; &lt;p&gt;{fact}&lt;/p&gt;}\n&lt;/main&gt;\n)\n}\n</code></pre> <p>En el ejemplo anterior, el m\u00e9todo <code>fetch</code> es usado al hacer click en el bot\u00f3n como al principio del componente. Esto no es una buena pr\u00e1ctica, ya que se va a ejecutar cada vez que se renderice la vista, o se recargue la p\u00e1gina sin importar si hay o no un cambio de estado, lo que puede producir resultados no deseados para nuestra App.</p>"},{"location":"tema_2/page-5/#fetching-de-datos-como-efecto","title":"Fetching de datos como efecto","text":"<p>Por el contrario de lo anterior, se recomienda realizar el fetching de datos como efecto de nuestra aplicaci\u00f3n y que se ejecute solamente cuando sea necesario, ya sea cuando tengamos un cambio de estado de una dependencia o al principio.</p> <pre><code>const App = () =&gt; {\nconst [fact, setFact] = useState()\nuseEffect(() =&gt; {\ngetRandomFact()\n.then(fact =&gt; setFact(fact))\n}, [])\nconst handleClick = () =&gt; {\ngetRandomFact()\n.then(fact =&gt; setFact(fact))\n}\nreturn (\n&lt;main&gt;\n&lt;h1&gt;App de gatitos&lt;/h1&gt;\n&lt;button onClick={handleClick}&gt;Get new fact&lt;/button&gt;\n{fact &amp;&amp; &lt;p&gt;{fact}&lt;/p&gt;}\n&lt;/main&gt;\n)\n}\n</code></pre> <p>Recuerda</p> <p>Recuerda que dentro del hook <code>useEffect</code> no se puede realizar un await ya que el callback del <code>useEffect</code> no puede ser as\u00edncrono, por lo que aunque se haya tratado el <code>fetch</code> con async/await se ha consumido como una promesa.</p>"},{"location":"tema_2/page-6/","title":"5 Custom Hooks","text":""},{"location":"tema_2/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>En ciertas ocasiones es muy com\u00fan querer realizar ciertas operaciones de forma repetitiva. Supongamos que el ejemplo del punto anterior, donde ten\u00edamos un componente para realizar una petici\u00f3n a la API y nos devolviera un hecho random sobre un gato, fuese utilizado en diferentes ocasiones. En dicho caso, podr\u00edamos copiar y pegar, pero deber\u00edas tener en cuenta ciertas cosas, como el cambio de estado, o incluso el mismo <code>useEffect</code>.</p>"},{"location":"tema_2/page-6/#definicion","title":"Definici\u00f3n","text":"<p>Los custom hooks son funciones reutilizables que permiten acceder al estado y a otras caracter\u00edsticas de React sin escribir una clase. Los custom hooks se introdujeron en React 16.8 y han revolucionado la forma en que los desarrolladores construyen aplicaciones React.</p> <p>Los custom hooks son funciones reutilizables que permiten acceder al estado y a otras caracter\u00edsticas de React sin escribir una clase. Los custom hooks se introdujeron en React 16.8 y han revolucionado la forma en que los desarrolladores construyen aplicaciones React.</p> <p>Los custom hooks se pueden utilizar para cualquier tipo de l\u00f3gica que desee reutilizar en varios componentes. Por ejemplo, puede crear un custom hook para:</p> <ul> <li>Realizar un fetch de datos</li> <li>Administrar un formulario</li> <li>Crear animaciones</li> <li>Implementar un patr\u00f3n de dise\u00f1o</li> </ul> <p>Los custom hooks son una herramienta poderosa que puede ayudarle a escribir c\u00f3digo React m\u00e1s limpio, eficiente y mantenible.</p>"},{"location":"tema_2/page-6/#funcionalidad","title":"Funcionalidad","text":"<p>Los custom hooks se basan en la funci\u00f3n <code>useState</code> y <code>useEffect</code> de React. La funci\u00f3n <code>useState</code> le permite acceder al estado de un componente, y la funci\u00f3n <code>useEffect</code> le permite ejecutar c\u00f3digo cuando se monta o desmonta un componente.</p> <p>Los custom hooks se definen como funciones que comienzan con la palabra clave <code>use</code>. Por ejemplo:</p> <pre><code>const useCatFact = () =&gt; {\n//...\n}\n</code></pre>"},{"location":"tema_2/page-6/#retorno-de-un-custom-hook","title":"Retorno de un Custom Hook","text":"<p>Un custom hook puede devolver o no un valor, aunque siempre que sea posible es recomendado que devuelva un valor. Si se desea devolve m\u00e1s de un valor, se puede devolver un objeto con los valores deseados. Por ejemplo, en el ejemplo de querer obtener un hecho aleatorio de un gato, lo l\u00f3gico ser\u00eda devolver tanto el estado como el m\u00e9todo para cambiarlo:</p> <pre><code>const useCatFact = () =&gt; {\nconst [fact, setFact] = useState()\nconst refreshFact = () =&gt; {\ngetRandomFact().then(setFact)\n}\n// efecto para recuperar la cita al recargar la p\u00e1gina\nuseEffect(refreshFact, [])\nreturn { fact, refreshFact }\n}\n</code></pre> <p>No es recomendable devolver el m\u00e9todo de cambio de estado, pero en este caso es necesario, ya que dicho estado puede ser cambiado fuera del hook:</p> <pre><code>function App() {\nconst { fact, refreshFact } = useCatFact()\nconst handleClick = () =&gt; {\nrefreshFact()\n}\nreturn (\n&lt;main&gt;\n&lt;h1&gt;App de gatitos&lt;/h1&gt;\n&lt;button onClick={handleClick}&gt;Get new fact&lt;/button&gt;\n{fact &amp;&amp; &lt;p&gt;{fact}&lt;/p&gt;}\n&lt;/main&gt;\n)\n}\n</code></pre>"},{"location":"tema_2/page-6/#parametros","title":"Par\u00e1metros","text":"<p>Un custom hook puede recibir todos los par\u00e1metros que sea necesario para su uso. Supongamos ahora que queremos hacer una llamada a una segunda API, que nos devuelve la imagen de un gato dado un texto:</p> <pre><code>export const getImageFromFact = async (threeFirstWords) =&gt; {\nconst url = `https://cataas.com/cat/says/${threeFirstWords}?size=50&amp;color=red&amp;json=true`\ntry {\nconst res = await fetch(url)\nconst response = await res.json()\nconst { url: url_1 } = response\nreturn url_1 ?? '/cat'\n} catch (_) {\nreturn \"/cat\"\n}\n}\n</code></pre> <p>Creamos un custom hook que solo retornar\u00e1 la url de la imagen a trav\u00e9s de un estado que ser\u00e1 actualizado cada vez que la variable fact cambie de estado:</p> <pre><code>export function useCatImage(fact) {\nconst CAT_PREFIX_IMAGE_URL = 'https://cataas.com'\nconst [imageURL, setImageUrl] = useState()\n// Para recuperar la imagen cada vez que tenemos una cita nueva\nuseEffect(() =&gt; {\nif (!fact) return\nconst threeFirstWords = fact.split(' ', 3)\ngetImageFromFact(threeFirstWords).then(setImageUrl)\n}, [fact])\nreturn { imageURL: `${CAT_PREFIX_IMAGE_URL}${imageURL}` }\n}\n</code></pre> <p>Por lo que en nuestro componente se ver\u00eda de la siguiente forma:</p> <pre><code>function App() {\nconst { fact, refreshFact } = useCatFact()\nconst { imageURL } = useCatImage({ fact })\nconst handleClick = () =&gt; {\nrefreshFact()\n}\nreturn (\n&lt;main&gt;\n&lt;h1&gt;App de gatitos&lt;/h1&gt;\n&lt;button onClick={handleClick}&gt;Get new fact&lt;/button&gt;\n{fact &amp;&amp; &lt;p&gt;{fact}&lt;/p&gt;}\n{imageURL &amp;&amp; &lt;img src={` ${imageURL}`} alt={`Image extracted using the first three word for ${fact}`} /&gt;}\n&lt;/main&gt;\n)\n}\n</code></pre>"},{"location":"tema_2/page-6/#ventajas","title":"Ventajas","text":"<p>Los custom hooks ofrecen una serie de beneficios, entre los que se incluyen:</p> <ul> <li>Reutilizaci\u00f3n: Los custom hooks permiten reutilizar la l\u00f3gica entre varios componentes. Esto puede ayudar a reducir el c\u00f3digo duplicado y mejorar la mantenibilidad de su aplicaci\u00f3n.</li> <li>Eficiencia: Los custom hooks se ejecutan solo cuando es necesario, lo que puede ayudar a mejorar el rendimiento de su aplicaci\u00f3n.</li> <li>Organizaci\u00f3n: Los custom hooks pueden ayudar a organizar su c\u00f3digo y hacerlo m\u00e1s f\u00e1cil de entender.</li> </ul>"},{"location":"tema_2/page-7/","title":"Proyecto","text":"<p>Reactify es una aplicaci\u00f3n cuyo objetivo es poner a disposici\u00f3n de los usuarios informaci\u00f3n sobre sus artistas favoritos. Para realizar est\u00e1 aplicaci\u00f3n se usar\u00e1 la API de LastFM.</p> <p>La aplicaci\u00f3n  mostrar\u00e1 principalmente los artistas m\u00e1s escuchados. Tambi\u00e9n habr\u00e1 un buscador donde el usuario podr\u00e1 buscar el artista que quiera.</p> <p>Al tener un artista, se deber\u00e1 mostrar informaci\u00f3n de sus \u00e1lbumes y sus canciones, as\u00ed c\u00f3mo otra informaci\u00f3n relevante del artista.</p>"},{"location":"tema_3/page-1/","title":"1 Formularios","text":""},{"location":"tema_3/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Los formularios en react son bastantes parecidos a HTML, igual que cualquier otro elemento de React. Los atributos son iguales y sus eventos m\u00e1s comunes son <code>onClick</code>, <code>onChange</code> y <code>onSubmit</code>.</p> <p>El uso de formularios en desarrollo web es fundamental a la hora de crear aplicaciones interactivas ya que con ellos podemos validar y enviar informaci\u00f3n a nuestros servidores. La verdad es que trabajar con formularios puede ser m\u00e1s desafiante de lo que pudi\u00e9ramos creer.</p> <p>Para crear un buen formulario, debemos tener en cuenta los siguientes aspectos:</p> <ul> <li>Accesibilidad: Millones de usuarios en el mundo sufren alg\u00fan tipo de discapacidad y navegan los sitios web a trav\u00e9s de herramientas diferentes al mouse y el teclado, por lo tanto, debemos tener en cuenta la sem\u00e1ntica de los elementos HTML que usemos para crear el formulario, adem\u00e1s no ser\u00e1 suficiente usar las estrategias de validaci\u00f3n convencionales propuestas por los navegadores.</li> <li>Validaci\u00f3n: Cada campo que existe en el formulario puede tener unas reglas particulares. Unos campos pueden ser opcionales, otros obligatorios, tambi\u00e9n permiten ingresar correos electr\u00f3nicos, pueden requieren valores m\u00ednimos o m\u00e1ximos, entre otros. Comunicar a todos los usuarios acerca de los valores permitidos en un campo espec\u00edfico es una funci\u00f3n fundamental de las validaciones de campos.</li> <li>Serializaci\u00f3n: Cuando un usuario ha terminado de diligenciar el formulario, su informaci\u00f3n se encuentra en alg\u00fan espacio de memoria en el que usa la aplicaci\u00f3n. Obtener esa informaci\u00f3n, manipularla y enviarla adecuadamente puede ser un reto en algunas ocasiones.</li> </ul> <p>Existen dos formas de trabajar con formularios en React, de forma controlada y de forma no controlada. Ambas tiene sus ventajas y sus inconvenientes dependiendo del proyecto y las necesidades a desarrollar.</p>"},{"location":"tema_3/page-1/#formularios-no-controlados","title":"Formularios No Controlados","text":"<p>Un formulario no controlado es aquel formulario que se valida o se trabaja con sus elementos sin la intervenci\u00f3n y el control nativo de React. Esta es la forma est\u00e1ndar de trabajar con formularios en Javascript Vanilla. Se refiere a trabajar con los elementos del formulario haciendo uso de las referencias de sus elementos:</p> <pre><code>&lt;form&gt;\n&lt;input type=\"text\" id=\"name\" placeholder=\"name\" /&gt;\n&lt;button type=\"submit\"&gt;Enviar&lt;/button&gt;\n&lt;/form&gt;\n&lt;script&gt;\nconst inputName = document.getElementById('name')\ninput.addEventListener('change', event =&gt; {\nconsole.log(event.target.value)\n})\ndocument.getElementByTags('button')[0].addEventListener('click', () =&gt; {\nconsole.log(input.value)\n})\n&lt;/script&gt;\n</code></pre> <p>Para poder trabajar de forma no controlada en React existen diferentes formas:</p> <ul> <li>Accediendo al identificador de los elemento (exactamente igual que Javascript Vanilla)</li> <li>Accediendo al elemento a trav\u00e9s la propiedad <code>target</code> del <code>event</code> del evento deseado.</li> </ul> <p>Esto a veces puede suponer problemas ya que es de forma imperativa y adem\u00e1s, en el caso del evento, solo ponemos acceder al elemento que realiza el evento. Por lo que existe una forma no controlada pero m\u00e1s eficiente, haciendo uso del hook <code>useRef()</code>, referenciando al elemento del formulario con el que se desea trabajar.</p> <pre><code>function Form() {\nconst [error, setError] = useState(null)\nconst searchRef = useRef()\nconst handleFormSubmit = event =&gt; {\nevent.preventDefault()\nconst search = searchRef.current\nif (search === '') {\nsetError('No se puede buscar una pel\u00edcula vac\u00eda')\nreturn\n}\nif (search.match(/^\\d+$/)) {\nsetError('La b\u00fasqueda debe tener al menos 3 caracteres')\nreturn\n}\nif (search.length &lt; 3) {\nsetError('La b\u00fasqueda debe tener al menos 3 caracteres')\nreturn\n}\nsetError(null)\n}\nreturn (\n&lt;form&gt;\n&lt;input ref={searchRef} name='query' placeholder='Type a word...' /&gt;\n&lt;button type='submit'&gt;Buscar&lt;/button&gt;\n&lt;/form&gt;\n{error &amp;&amp; &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}\n)\n}\n</code></pre> <p>Sugerencia</p> <p>Cuando se maneja un formulario se recomienda hacerlo dentro del elemento <code>&lt;form&gt;&lt;/form&gt;</code>, as\u00ed como manejar el submit con el evento <code>onSubmit</code> y no con el <code>onClick</code> del bot\u00f3n.</p>"},{"location":"tema_3/page-1/#formularios-controlados","title":"Formularios Controlados","text":"<p>Cuando nos referimos a trabajar con los elementos un formularios de forma controlada, estamos hablando de poder realizar el control a trav\u00e9s de React, es decir, pudiendo controlar su estado, por lo que se trabajar\u00eda con el <code>useState</code>:</p> <pre><code>function Form() {\nconst [error, setError] = useState(null)\nconst [search, updateSearch] = useState('')\nconst handleFormSubmit = event =&gt; {\nevent.preventDefault()\nif (search === '') {\nsetError('No se puede buscar una pel\u00edcula vac\u00eda')\nreturn\n}\nif (search.match(/^\\d+$/)) {\nsetError('La b\u00fasqueda debe tener al menos 3 caracteres')\nreturn\n}\nif (search.length &lt; 3) {\nsetError('La b\u00fasqueda debe tener al menos 3 caracteres')\nreturn\n}\nsetError(null)\n}\nconst handleChange = event =&gt; {\nconst newSearch = event.target.value\nupdateSearch(newSearch)\n}\nreturn (\n&lt;form&gt;\n&lt;input ref={searchRef} name='query' placeholder='Type a word...' onChange={handleChange} value={search} /&gt; // (1)!\n&lt;button type='submit'&gt;Buscar&lt;/button&gt;\n&lt;/form&gt;\n{error &amp;&amp; &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}\n)\n}\n</code></pre> <ol> <li>\u26a0\ufe0f \u00a1Cuidado! Al usar el estado hay que indicar que la propiedad <code>value</code> con el valor del estado creado, as\u00ed como manejar el evento <code>onChange</code></li> </ol> <p>Incluso, en el ejemplo anterior, se puede manejar la validaci\u00f3n con un <code>useEffect</code>:</p> <pre><code>function Form() {\nconst [error, setError] = useState(null)\nconst [search, updateSearch] = useState('')\nconst handleFormSubmit = event =&gt; {\nevent.preventDefault()\n//...\n}\nuseEffect(() =&gt; {\nif (search === '') {\nsetError('No se puede buscar una pel\u00edcula vac\u00eda')\nreturn\n}\nif (search.match(/^\\d+$/)) {\nsetError('La b\u00fasqueda debe tener al menos 3 caracteres')\nreturn\n}\nif (search.length &lt; 3) {\nsetError('La b\u00fasqueda debe tener al menos 3 caracteres')\nreturn\n}\nsetError(null)\n}, [search])\nconst handleChange = event =&gt; {\nconst newSearch = event.target.value\nupdateSearch(newSearch)\n}\nreturn (\n&lt;form&gt;\n&lt;input ref={searchRef} name='query' placeholder='Type a word...' onChange={handleChange} value={search} /&gt; // (1)!\n&lt;button type='submit'&gt;Buscar&lt;/button&gt;\n&lt;/form&gt;\n{error &amp;&amp; &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}\n)\n}\n</code></pre> <p>El problema de realizar estas validaciones con el estado es que al renderizar por primera vez el componente se validar\u00e1 el valor del elemento, algo que no se desea. La soluci\u00f3n ser\u00eda controlar si estamos ante la primera renderizaci\u00f3n o no para controlarlo, para ello se puede usar el <code>useRef()</code>\ud83e\uddee</p> <pre><code>function Form() {\nconst [error, setError] = useState(null)\nconst [search, updateSearch] = useState('')\nconst isFirstRender = useRef(true)\nconst handleFormSubmit = event =&gt; {\nevent.preventDefault()\n//...\n}\nuseEffect(() =&gt; {\nif(isFirstRender.current){ //(1)!\nisFirstRender.current = search === ''\nreturn\n}\nif (search === '') {\nsetError('No se puede buscar una pel\u00edcula vac\u00eda')\nreturn\n}\nif (search.match(/^\\d+$/)) {\nsetError('La b\u00fasqueda debe tener al menos 3 caracteres')\nreturn\n}\nif (search.length &lt; 3) {\nsetError('La b\u00fasqueda debe tener al menos 3 caracteres')\nreturn\n}\nsetError(null)\n}, [search])\nconst handleChange = event =&gt; {\nconst newSearch = event.target.value\nupdateSearch(newSearch)\n}\nreturn (\n&lt;form&gt;\n&lt;input ref={searchRef} name='query' placeholder='Type a word...' onChange={handleChange} value={search} /&gt;\n&lt;button type='submit'&gt;Buscar&lt;/button&gt;\n&lt;/form&gt;\n{error &amp;&amp; &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}\n)\n}\n</code></pre> <ol> <li>Detecta si es la primera vez que se renderiza el componente, de esta forma si es as\u00ed hago un <code>return</code> y no es necesario realizar las validaciones. Tambi\u00e9n se cambia el valor a <code>false</code> (si no hay texto en el search) para que en las pr\u00f3ximas renderizaciones si se haga la validaci\u00f3n</li> </ol>"},{"location":"tema_3/page-1/#usememo","title":"useMemo","text":"<p>El hook <code>useMemo</code> sirve para poder memorizar c\u00e1lculos y realizarlos solo cuando se produce un cambio de estado. <code>useMemo</code> recibe dos par\u00e1metros, un callback que se ejecutar\u00e1 cada vez que cambie el estado de una dependencia, y un array con las dependencias. Adem\u00e1s retorna el valor calculado. Supongamos que tenemos un funci\u00f3n que calcule cu\u00e1ntos elementos hay en un array de dos dimensiones:</p> <pre><code>const calc = myArray =&gt; {\nlet c = 0\nfor(let i = 0; i &lt; myArray.length; i++){\nfor(let j = 0; j &lt; myArray.length; j++){\nc += 1\n}\n}\nreturn c\n}\nfunction MyComponent({list}) {\nconst result = calc(list)\nreturn (\n&lt;p&gt;result: {result}&lt;/p&gt;\n)\n}\n</code></pre> <p>En el ejemplo anterior, cada vez que se produzca una renderizaci\u00f3n del componente se volver\u00e1 a ejecutar la funci\u00f3n. Esto puede provocar una sobrecarga de rendimiento en nuestro proyecto, por lo que el hook <code>useMemo</code> solo ejecutar\u00e1 la funci\u00f3n cuando cambia la lista:</p> <pre><code>function MyComponent({list}) {\nconst result = useMemo(() =&gt; calc(list), [list])\nreturn (\n&lt;p&gt;result: {result}&lt;/p&gt;\n)\n}\n</code></pre>"},{"location":"tema_3/page-1/#usecallback","title":"useCallback","text":"<p>El hook <code>useCallback</code> es bastante similar al <code>useMemo</code> con la diferencia que en lugar de calcular el valor, a trav\u00e9s del callback indicado, retorna la funci\u00f3n que va a calcular el valor. Es m\u00e1s, el <code>useCallback</code>  utiliza internamente el <code>useMemo</code>:</p> <pre><code>function MyComponent({list}) {\nconst result = useMemo(myArray =&gt; {\nlet c = 0\nfor(let i = 0; i &lt; myArray.length; i++){\nfor(let j = 0; j &lt; myArray.length; j++){\nc += 1\n}\n}\nreturn c\n}, [list])\nreturn (\n&lt;p&gt;result: {result}&lt;/p&gt;\n)\n}\n</code></pre>"},{"location":"tema_3/page-1/#debounce","title":"Debounce","text":"<p>El debounce es una operaci\u00f3n en Javascript que se produce durante el cambio de un input pero no inmediatamente en dicho cambio. Por ejemplo, si queremos realizar una b\u00fasqueda en una API y queremos que la b\u00fasqueda se realice mientras escribimos, esto puede dar lugar a resultados no deseados, ya que podemos obtener un resultado que haya tardado m\u00e1s en ejecutarse o incluso que se cargue de m\u00e1s la memoria. El debounce soluciona esto de la siguiente forma: comprueba cuando el usuario deja de escribir, y si no vuelve a escribir en X milisegundos se realiza la b\u00fasqueda. En React existen varios paquetes para trabajar con el debounce, el siguiente ejemplo se ha realizado con el paquete <code>just-debounce-it</code>:</p> <pre><code>const calledAPI = useCallback(debounce(value =&gt; {\nconsole.log(\"I'm here\")\ncallAPI(value)\n}, 300), [dependency])\n</code></pre>"},{"location":"tema_3/page-2/","title":"Proyecto Formularios","text":"<p>Crea una aplicaci\u00f3n para buscar pel\u00edculas en la siguiente API https://www.omdbapi.com/, realizando la investigaci\u00f3n previa a dicha API.</p> <p>Requerimientos:</p> <ul> <li>Necesita mostrar un input para buscar la pel\u00edcula y un bot\u00f3n para buscar.</li> <li>Lista las pel\u00edculas encontradas y muestra el t\u00edtulo, a\u00f1o y poster.</li> <li>Funcionamiento del formulario</li> <li>Haz que las pel\u00edculas se muestren en un grid responsive.</li> <li>Evitar que se haga la misma b\u00fasqueda dos veces seguidas.</li> <li>Hacer que la b\u00fasqueda se haga autom\u00e1ticamente al escribir.</li> <li>Evita que se haga la b\u00fasqueda continuamente al escribir (debounce).</li> </ul>"},{"location":"tema_3/page-3/","title":"2 Contexto","text":""},{"location":"tema_3/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>A veces tenemos un proyecto con varios componentes y que se desea pasar informaci\u00f3n de un componente a otro. Para ello, tenemos las props, donde podemos pasarle la informaci\u00f3n deseada para cada componente.</p> <p>Aunque esto, en ciertas ocasiones ese paso de props pueda estar obligado por ciertas circunstancias.</p>"},{"location":"tema_3/page-3/#prop-drilling","title":"Prop drilling","text":"<p>El prop drilling es un fen\u00f3meno que ocurre cuando un componente debe de pasar una cierta informaci\u00f3n o acci\u00f3n a un componente pero no puede hacerlo directamente porque este est\u00e1 dentro de otro componente, por lo que para que \u00e9ste pueda recibir debe recibirlo todos los componentes anteriores a \u00e9l.</p> <p> Figura 1 - Props drilling</p> <p>La imagen anterior representa como tenemos el estado de una variable en la el componente <code>App</code>, dicha variable es usada tanto en <code>App</code> como en <code>Componente 2</code>, por lo que necesitamos pasar la informaci\u00f3n al segundo componente, pero con la desventaja que estamos obligado a pasar tambi\u00e9n por <code>Componente 1</code>.</p>"},{"location":"tema_3/page-3/#context","title":"Context","text":"<p>Por lo general, hacer uso del props drilling puede ser una operaci\u00f3n innecesaria para ciertos componentes, porque si tengo un \u00e1rbol de componentes (como la imagen anterior) pero el componente a recibir la informaci\u00f3n es un componente muy profundo, el resto de componentes tienen informaci\u00f3n a unos datos que no le corresponden. Para poder evitar esto, se hace uso del context.</p> <p>El contexto permite que un componente principal proporcione datos a todos los componentes del \u00e1rbol debajo de \u00e9l. De esta forma se puede compartir informaci\u00f3n sin necesidad de tener que pas\u00e1rsela como una prop.</p> <p> Figura 2 - Context</p> <p>En la imagen anterior se puede ver representado como tenemos un Context que maneja un estado. Dicho estado se utiliza tanto en el <code>Header</code>  como en el <code>Componente 2</code>, en este caso se envuelve todo nuestro \u00e1rbol por el proveedor del contexto para que se pueda acceder desde los componentes deseados, sin necesidad de hacer props drilling.</p> <p>El proveedor del contexto es un componente que contendr\u00e1 los estados y variables que desea que sean accesible para el resto de componentes. Dicho componente se utilizar\u00e1 como el componente padre de los componentes que puedan acceder a dicha informaci\u00f3n.</p> <p>Primero de todo, se debe crear el contexto. Para ello se usa el m\u00e9todo <code>createContext()</code>, recibe el valor inicial del contexto, en caso de ser necesario:</p> <pre><code>export const Context = createContext()\n</code></pre> <p>Luego, se crea el proveedor. Ten en cuenta que dicho componente debe recibir los componentes children. Adem\u00e1s tiene una prop llamada value con los valores a pasar (en formato objeto):</p> <pre><code>export const Context = createContext()\nexport function Provider({children}){\nreturn &lt;Context.Provider value={{}}&gt;\n{children}\n&lt;/Context.Provider&gt;\n}\n</code></pre> <p>Despu\u00e9s, dicho componente debe colocarse donde deseemos. Puede ser colocado de forma global (en la ra\u00edz de nuestro proyecto), o de forma local agrupando los componentes que puedan acceder a nuestro contexto. Esto depender\u00e1 de donde se desea mostrar los datos pasados en el componente, por lo que hay que tener mucho cuidado de que componente tiene acceso o no.</p> <pre><code>const App () =&gt; {\nreturn (\n&lt;Provider&gt;\n&lt;Component1/&gt;\n&lt;Component2/&gt;\n&lt;Component3/&gt;\n&lt;/Provider&gt;\n)\n}\n</code></pre> <p>Por \u00faltimo, en el componente deseado, se consume el contexto, haciendo uso del hook <code>useContext</code>:</p> <pre><code>const Component1 = () =&gt; {\nconst context = useContext(Context) // (1)!\nreturn (\n{/* */}\n)\n}\n</code></pre> <ol> <li>Se puede utilizar la destructuraci\u00f3n para acceder a los valores deseado directamente</li> </ol>"},{"location":"tema_3/page-3/#contexto-estatico-vs-dinamico","title":"Contexto est\u00e1tico vs din\u00e1mico","text":"<p>El contexto est\u00e1tico es aquel contexto que contiene valores que no se pueden cambiar, y por lo que no sufren cambios de estados, mientras que el contexto din\u00e1mico esto si procede, s\u00ed se produce el cambio de estado.</p> <p>El uso de un contexto est\u00e1tico no es mala pr\u00e1ctica, ya que siempre no vamos a querer producir un cambio de estado, pero si almacenar valores que queramos acceder desde cualquier parte de la aplicaci\u00f3n, como por ejemplo, colores, traducciones, etc.</p>"},{"location":"tema_3/page-4/","title":"3 Cambios de estados complejos","text":""},{"location":"tema_3/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>Entendemos como cambio de estado complejo, un estado que puede ser cambiado de diferentes formas por diferentes motivos. Por ejemplo, para manejar el estado de objetos, o varios estados dependientes uno de otros.</p> <p>Supongamos que tenemos un componente para mostrar el post de una red social. Este componente puede tener tres estados diferentes, cargando para cuando se est\u00e1 localizando el post, post cuando se muestra el post en caso de encontrarse y error para cuando se muestra un error en caso de que no se encuentre el post solicitado. En este caso, los estados son dependientes uno de otros, es decir, no pueden coexistir los 3 a la vez para un mismo componente:</p> <pre><code>function Component() {\nconst [loading, setLoading] = useState(false)\nconst [error, setError] = useState(false)\nconst [post, setPost] = useState({})\nconst loadPost = () =&gt; {\nsetLoading(true)\nsetPost({})\nsetError(false)\n}\nreturn (\npost ? &lt;div&gt;{post}&lt;/div&gt;\n: loading ? &lt;span&gt;Loading...&lt;/span&gt;\n: error\n? &lt;span&gt;{error}&lt;/span&gt;\n: &lt;&gt;&lt;/&gt;\n)\n}\n</code></pre> <p>En el ejemplo anterior, debemos tener en cuenta que cada vez que se cambie el estado de una de las variables, debe obligatoriamente cambiarse el estado del resto.</p>"},{"location":"tema_3/page-4/#usereducer","title":"useReducer","text":"<p><code>useReducer</code> es un hook que nos permite manejar el estado de forma escalable, sobretodo, estados complejos. El hook <code>useReducer</code> recibe dos par\u00e1metros, el un m\u00e9todo, <code>reducer</code> que transformar\u00e1 el estado a trav\u00e9s de una acci\u00f3n y devuelve un nuevo estado. Este m\u00e9todo, debe recibir el estado actual y la acci\u00f3n a realizar. Por ejemplo, podemos tener un estado con una lista de elementos, para que puede cambiar seg\u00fan si se desea a\u00f1adir elementos, eliminar elementos, o limpiar la lista. A\u00f1adir, eliminar y limpiar, ser\u00edan las acciones del m\u00e9todo reducer; y el segundo par\u00e1metro el estado inicial.</p> <p>El <code>useReducer</code> devuelve un array con dos valores, el primer valor corresponde al valor del estado, y el segundo valor corresponde al m\u00e9todo que desencadenar\u00e1 el cambio de estado dada una acci\u00f3n, com\u00fanmente llamado <code>dispatch</code>.</p> <p> Figura 3 - useReducer</p> <p>Como podemos observar en el esquema anterior, tenemos un componente que producir\u00e1 el cambio de estado a trav\u00e9s de un evento. Al producirse dicho evento, realiza una llamada al m\u00e9todo <code>dispatch()</code> que recibe un objeto de tipo action. Este objeto puede tener como propiedades, el tipo de acci\u00f3n, y alg\u00fan par\u00e1metro que sea necesario usar (payload). Dicha acci\u00f3n ejecutar\u00e1 el m\u00e9todo <code>reducer</code> que producir\u00e1 el cambio de estado, provocando as\u00ed una renderizaci\u00f3n del componente.</p> <pre><code>function Component(){\nconst initialState = []\nconst reducer = (state, action) =&gt; {\nconst {type, payload} = action\nswitch(type){\ncase 'ADD':\nconst newState = [...state, payload]\nreturn newState\ncase 'REMOVE':\nconst newState = state.filter(el =&gt; el != payload)\nreturn newState\ncase 'CLEAR':\nreturn initialState\n}\n}\nconst [state, dispatch] = useState(reducer, initialState)\nconst add = () =&gt; {\ndispatch({type: 'ADD', payload: 10})\n}\nconst remove = () =&gt; {\ndispatch({type: 'REMOVE', payload: 10})\n}\nconst clear = () =&gt; {\ndispatch({type: 'CLEAR'})\n}\nreturn (\n&lt;div&gt;\n{\nstate.map(el =&gt; (\n&lt;div&gt;{el}&lt;/div&gt;\n))\n}\n&lt;button onClick={add}&gt;Add&lt;/button&gt;\n&lt;button onClick={remove}&gt;Remove&lt;/button&gt;\n&lt;button onClick={clear}&gt;Clear&lt;/button&gt;\n&lt;/div&gt;\n)\n}\n</code></pre>"},{"location":"tema_3/page-5/","title":"Proyecto Context","text":"<p>Realiza una aplicaci\u00f3n que muestre una lista de productos para ser a\u00f1adida a un carrito de la compra. El proyecto consta de dos partes principales:</p> <ol> <li> <p>E-commerce</p> <ul> <li>Muestra una lista de productos que vienen de un JSON</li> <li>A\u00f1ade un filtro por categor\u00eda</li> <li>A\u00f1ade un filtro por precio</li> <li>Haz uso de useContext para evitar pasar props innecesarias</li> </ul> </li> <li> <p>Shopping Cart</p> <ul> <li>Haz que se puedan a\u00f1adir los productos a un carrito.</li> <li>Haz que se puedan eliminar los productos del carrito.</li> <li>Haz que se puedan modificar la cantidad de productos del carrito.</li> <li>Sincroniza los cambios del carrito con la lista de productos.</li> <li>Guarda en un localStorage el carrito para que se recupere al recargar la p\u00e1gina.</li> </ul> </li> </ol>"},{"location":"tema_3/page-6/","title":"4 Navegaci\u00f3n","text":""},{"location":"tema_3/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>En React para poder realizar navegaciones se puede realizar de la misma forma que Javascript Vanilla. A trav\u00e9s de un enlace podemos indicar la ruta a la que queremos acceder, teniendo en cuenta que en nuestro componente principal debemos tratar dicha ruta para saber que componente poder renderizar:</p> <pre><code>function HomePage() {\nreturn (\n&lt;&gt;\n&lt;h1&gt;Home&lt;/h1&gt;\n&lt;p&gt;Esta es una p\u00e1gina de ejemplo para crear un React Router desde cero&lt;/p&gt;\n&lt;a href='/about'&gt;Ir a sobre nosotros&lt;/a&gt;\n&lt;/&gt;\n)\n}\nfunction AboutPage() {\nreturn (\n&lt;&gt;\n&lt;h1&gt;About&lt;/h1&gt;\n&lt;div&gt;\n&lt;img src='https://pbs.twimg.com/profile_images/1737906083207720961/53U-hMUE_400x400.jpg' alt='Foto' /&gt;\n&lt;p&gt;\u00a1Hola! Me llamo Miguel \u00c1ngel y estoy creando un clon de React Router&lt;/p&gt;\n&lt;/div&gt;\n&lt;a href='/'&gt;Ir a la hombre&lt;/a&gt;\n&lt;/&gt;\n)\n}\nfunction App() {\nconst [currentPath, setCurrentPath] = useState(window.location.pathname)\nreturn (\n&lt;main&gt;\n{currentPath === '/' &amp;&amp; &lt;HomePage /&gt;}\n{currentPath === '/about' &amp;&amp; &lt;AboutPage /&gt;}\n&lt;/main&gt;\n)\n}\n</code></pre> <p>En el ejemplo anterior tenemos un estado <code>currentPath</code> cuya inicializaci\u00f3n es la ruta actual, dependiendo de si la ruta es <code>'/'</code> o <code>'/about'</code> renderizar\u00e1 un componente u otro. En cada uno de los componentes hay un enlace para redirigirse al otro componente.</p>"},{"location":"tema_3/page-6/#multiple-page-application-vs-single-page-application","title":"Multiple Page Application vs Single Page Application","text":"<p>Un Multi Page Application (MPA) es un tipo de aplicaci\u00f3n basado en varias p\u00e1ginas, cada una de las cu\u00e1les se carga por separado. Esta es la forma que usa por defecto en cualquier proyecto nativo de HTML o Javascript. En React, este tipo de aplicaci\u00f3n puede dar problemas ya que cada vez que realicemos una navegaci\u00f3n se realizar\u00e1 una carga de todos los componentes y utilidades de nuestro proyecto, lo que no ser\u00eda eficiente.</p> <p>Para poder evitar eso, podemos hacer que nuestra aplicaci\u00f3n sea de tipo Single Page Application (SPA). Una SPA es un tipo de aplicaci\u00f3n donde s\u00f3lo existe una \u00fanica p\u00e1gina y se va cambiando el contenido de la misma seg\u00fan la navegaci\u00f3n.</p> <p>Para poder conseguir esto en React, creamos una funci\u00f3n <code>navigate(href)</code> que reciba la ruta, y realizamos un <code>pushstate</code> al historial de navegaci\u00f3n. Podemos acceder al historial de navegaci\u00f3n con la variable global <code>window.history</code>. <code>pushState</code> es un m\u00e9todo de <code>window.history</code> que a\u00f1ade al historia una nueva ruta sin necesidad de tener que hacer una nueva carga. El m\u00e9todo recibe tres par\u00e1metros:</p> <ul> <li>Objeto del estado: informaci\u00f3n que se desea mantener entre navegaciones.</li> <li>T\u00edtulo: t\u00edtulo de la p\u00e1gina (normalmente se suele indicar vac\u00edo).</li> <li>Path: ruta que a\u00f1adir al historial.</li> </ul> <pre><code>function navigate(href){\nwindow.history.pushState({}, '', href)\nconst navigationEvent = new Event('pushstate')\nwindows.dispatchEvent(navigationEvent)\n}\n</code></pre> <p>Adem\u00e1s, dicho m\u00e9todo despacha un nuevo evento que ser\u00e1 escuchado por nuestro componente cada vez que se haga una nueva navegaci\u00f3n:</p> <pre><code>//...\nfunction App(){\nconst [currentPath, setCurrentPath] = useState(window.location.pathname)\nuseEffect(() =&gt; {\nconst onLocationChange = () =&gt; {\nsetCurrentPath(window.location.pathname)\n}\nwindow.addEventListener('pushstate', onLocationChange)\nreturn () =&gt; {\nwindow.removeEventListener('pushstate', onLocationChange)\n}\n}, [])\n}\n</code></pre> <p>Hay que tener en cuenta que en los componente <code>HomePage</code> y <code>AboutPage</code> hay que quitarle el valor por defecto del anchor y poder realizar la navegaci\u00f3n con nuestra funci\u00f3n <code>navigate</code>:</p> <pre><code>function HomePage() {\nconst handleClick = event =&gt; {\nevent.preventDefault()\nconst href = event.target.getAttribute('href')\nnavigate(href)\n}\nreturn (\n&lt;&gt;\n&lt;h1&gt;Home&lt;/h1&gt;\n&lt;p&gt;Esta es una p\u00e1gina de ejemplo para crear un React Router desde cero&lt;/p&gt;\n&lt;a href='/about' onClick={handleClick}&gt;Ir a sobre nosotros&lt;/a&gt;\n&lt;/&gt;\n)\n}\nfunction AboutPage() {\nconst handleClick = event =&gt; {\nevent.preventDefault()\nconst href = event.target.getAttribute('href')\nnavigate(href)\n}\nreturn (\n&lt;&gt;\n&lt;h1&gt;About&lt;/h1&gt;\n&lt;div&gt;\n&lt;img src='https://pbs.twimg.com/profile_images/1737906083207720961/53U-hMUE_400x400.jpg' alt='Foto' /&gt;\n&lt;p&gt;\u00a1Hola! Me llamo Rub\u00e9n y estoy creando un clon de React Router&lt;/p&gt;\n&lt;/div&gt;\n&lt;a href='/' onClick={handleClick}&gt;Ir a la hombre&lt;/a&gt;\n&lt;/&gt;\n)\n}\n</code></pre>"},{"location":"tema_3/page-6/#back-navigation","title":"Back Navigation","text":"<p>Otro de los problemas que nos podemos encontrar en nuestra navegaci\u00f3n SPA es que al hacer clic en el bot\u00f3n de atr\u00e1s del navegador, no ocurre nada. Por lo que, en el efecto de nuestro componente, debemos escuchar el evento popstate y cambiar el estado de nuestra variable <code>currentPath</code>:</p> <pre><code>//...\nfunction App(){\nconst [currentPath, setCurrentPath] = useState(window.location.pathname)\nuseEffect(() =&gt; {\nconst onLocationChange = () =&gt; {\nsetCurrentPath(window.location.pathname)\n}\nwindow.addEventListener('pushstate', onLocationChange)\nwindow.addEventListener('popstate', onLocationChange)\nreturn () =&gt; {\nwindow.removeEventListener('pushstate', onLocationChange)\nwindow.removeEventListener('popstate', onLocationChange)\n}\n}, [])\n}\n</code></pre>"},{"location":"tema_3/page-6/#otras-formas-de-navegacion","title":"Otras formas de navegaci\u00f3n","text":"<p>Existen otras formas de realizar una navegaci\u00f3n, a parte de hacer clic con el bot\u00f3n derecho del rat\u00f3n. Por ejemplo, con Ctrl y clic derecho del rat\u00f3n se puede abrir el enlace en otra pesta\u00f1a, con Alt y clic derecho del rat\u00f3n se puede abrir el enlace en otra ventana, con el clic izquierdo del rat\u00f3n se abre en otra pesta\u00f1a, etc.</p> <p>Para poder manejar esto, vamos a crear un componente <code>Link</code> que renderice un enlace, con la ruta a seguir y el target como props.</p> <pre><code>function Link({target, to, ...props}) {\nconst handleClick = () =&gt; { //(1)!\nevent.preventDefault()\nnavigate(to)\n}\nreturn &lt;a onClick={handleClick} href={to} target={target} {...props} /&gt; }\n</code></pre> <ol> <li>Con <code>...props</code> indicamos que puede recibir m\u00e1s props, de los cu\u00e1les no tenemos porque conocerlos. Esto sirve para poder recibir atributos HTML sin tener que declararlos, como el <code>className</code> o los hijos envueltos por el elemento; luego, se inyecta en el elemento deseado</li> </ol> <p>Luego, podemos usar ese componente en nuestros componentes Home y About en lugar del enlace:</p> <pre><code>function HomePage() {\nreturn (\n&lt;&gt;\n{/* ... */}\n&lt;Link to='/about'&gt;Ir a sobre nosotros&lt;/Link&gt;\n&lt;/&gt;\n)\n}\nfunction AboutPage() {\nreturn (\n&lt;&gt;\n{/* ... */}\n&lt;Link to='/'&gt;Ir a la hombre&lt;/Link&gt;\n&lt;/&gt;\n)\n}\n</code></pre> <p>De esta forma, el resto de tipos de navegaci\u00f3n no se puede realizar, ya que ha sido anulado por el <code>preventDefault</code>. A trav\u00e9s del evento podemos comprobar si se ha usado alguna tecla o que bot\u00f3n del rat\u00f3n se ha clicado. Por lo que, el m\u00e9todo <code>handleClick</code> del component <code>Link</code> quedar\u00eda:</p> <pre><code>function Link({target, to, ...props}){\nconst handleClick = event =&gt; {\nconst isMainEvent = event.button === 0 //(1)!\nconst isModifiedEvent = event.metaKey || event.altKey || event.ctrlKey || event.shiftKey // (2)!\nconst isManageableEvent = target === undefined || target = '_self' // (3)!\nif (isMainEvent &amp;&amp; isManageableEvent &amp;&amp; !isModifiedEvent) {\nevent.preventDefault()\nnavigate(to)        }\n}\n//...\n}\n</code></pre> <ol> <li>Se comprueba que se ha clicado el bot\u00f3n principal del rat\u00f3n</li> <li>Comprueba si se ha clicado un tecla especial</li> <li>Se comprueba si el target no esta definido o por el contrario es _self</li> </ol> <p>Como se puede observar, se realiza las comprobaciones pertinente y luego se navega con nuestro m\u00e9todo <code>navigate</code> haciendo el <code>preventDefault</code> si se ha clicado con el bot\u00f3n principal del rat\u00f3n y si se debe abrir el enlace en la misma p\u00e1gina y no se ha clicado ning\u00fan bot\u00f3n especial. Para cualquier otro caso, se deja la navegaci\u00f3n por defecto.</p>"},{"location":"tema_3/page-6/#componente-router","title":"Componente Router","text":"<p>Podemos crear un componente <code>Router</code> que pueda manejar de forma m\u00e1s sencilla todo lo que hemos creado hasta ahora. Este componente recibir\u00e1 adem\u00e1s, un objeto con las rutas y los componentes a usar.</p> <pre><code>function Router({ routes = [], defaultComponent: DefaultComponent = () =&gt; &lt;h1&gt;404&lt;/h1&gt; }) {\nconst [currentPath, setCurrentPath] = useState(window.location.pathname)\nuseEffect(() =&gt; {\nconst onLocationChange = () =&gt; {\nsetCurrentPath(window.location.pathname)\n}\nwindow.addEventListener(EVENTS.PUSH_STATE, onLocationChange)\nwindow.addEventListener(EVENTS.POP_STATE, onLocationChange)\nreturn () =&gt; {\nwindow.removeEventListener(EVENTS.PUSH_STATE, onLocationChange)\nwindow.removeEventListener(EVENTS.POP_STATE, onLocationChange)\n}\n}, [])\nconst Page = routes.find(({ path }) =&gt; path === currentPath)?.Component\nreturn Page ? &lt;Page /&gt; : &lt;DefaultComponent /&gt;\n}\n</code></pre> <p>En dicho componente, recibe un lista con las rutas a renderizar y un componente por defecto (para cuando se indica una ruta no incluida en nuestras rutas). Adem\u00e1s, manejamos el estado de la variable <code>currentPath</code> y a trav\u00e9s del <code>useEffect</code> manejamos las escuchas a los eventos. Nuestro componente principal quedar\u00e1 as\u00ed:</p> <pre><code>function App() {\nconst routes = const routes = [\n{\npath: '/',\nComponent: HomePage\n},\n{\npath: '/about',\nComponent: AboutPage\n}\n]\nreturn (\n&lt;main&gt;\n&lt;Router routes={routes} /&gt;\n&lt;/main&gt;\n)\n}\n</code></pre>"},{"location":"tema_3/page-6/#rutas-con-parametros","title":"Rutas con par\u00e1metros","text":"<p>En ciertas ocasiones las rutas pueden contener cierta informaci\u00f3n que queremos renderizar, como por ejemplo, el id de un elemento para hacer un fetching de datos, el valor para realizar una b\u00fasqueda, realizar la internacionalizaci\u00f3n de nuestra App, etc. Para poder tratarlo hacemos uso del paquete <code>path-to-regex</code> que haciendo uso de par\u00e1metros con el formato <code>:value</code> podemos acceder a dicho valor indicado.</p> <pre><code>function Router({ routes = [], defaultComponent: DefaultComponent = () =&gt; &lt;h1&gt;404&lt;/h1&gt; }) {\nlet routeParams\nconst isValidPath = (path) =&gt; {\nif (path === currentPath) return true\nconst matcherURL = match(path, { decode: decodeURIComponent })\nconst matched = matcherURL(currentPath)\nif (!matched) return false\nrouteParams = matched.params\nreturn true\n}\n// ...\nconst Page = routes.find(({ path }) =&gt; isValid(path))?.Component\nreturn Page ? &lt;Page routeParams={routeParams} /&gt; : &lt;DefaultComponent routeParams={routeParams} /&gt;\n}\n</code></pre> <p>En el m\u00e9todo <code>isValidPath</code> lo primero que se comprueba es si la ruta coincide exactamente con la ruta actual, de esta forma nos saltamos el resto de navegaciones. Luego se decodifica la ruta, de tal forma que podamos relacionarlo con la ruta de tipo <code>/ruta/:param</code> ya que el valor de <code>:param</code> puede ser cualquiera, comprobamos si coincide de forma parcial y adem\u00e1s valida que hay un par\u00e1metro. El m\u00e9todo <code>matcherURL</code> me devuelve un objeto con la informaci\u00f3n de la ruta, entre ellas los par\u00e1metros, que se le env\u00eda a los componentes para que puedan utilizarlo.</p> <p>Enviar los par\u00e1metros como props del componente quiz\u00e1s no sea la mejor pr\u00e1ctica, pero se puede evitar haciendo uso del Context o de custom hooks.</p>"},{"location":"tema_3/page-6/#componente-route","title":"Componente Route","text":"<p>En nuestra aplicaci\u00f3n controlamos la navegaci\u00f3n a trav\u00e9s del componente <code>Router</code> y le inyectamos las rutas a trav\u00e9s de un prop. Podemos crear un componente para que defina una ruta y reciba como prop la ruta y el componente a renderizar, este componente NO va a renderizar nada, simplemente me va a servir para manejar las rutas de una forma diferente:</p> <pre><code>function Route({ path, Component }) {\nreturn null\n}\n</code></pre> <p>En nuestro componente <code>Router</code> podemos trabajar con los children, de tal forma que podemos extraer informaci\u00f3n de estas a trav\u00e9s de la utilidad <code>Children</code> que nos ofrece React para poder iterar con los hijos de un componente:</p> <pre><code>function Router({ routes = [], defaultComponent: DefaultComponent = () =&gt; &lt;h1&gt;404&lt;/h1&gt; }) {\nlet routeParams\n// ...\nconst routesFromChildren = Children.map(children, ({ props, type }) =&gt; {\nconst { name } = type\nconst isRoute = name === 'Route'\nreturn isRoute ? props : null\n})\nconst routeToUse = routes.concat(routesFromChildren)\nconst Page = routeToUse.find(({ path }) =&gt; isValid(path))?.Component\nreturn Page ? &lt;Page routeParams={routeParams} /&gt; : &lt;DefaultComponent routeParams={routeParams} /&gt;\n}\n</code></pre> <p>En el componente anterior, transformamos cada children de nuestro componente en un objeto donde obtenemos la ruta y el componente a renderizar, comprobando antes si el children indicado es del tipo Route. Posteriormente, dicho array de objetos se a\u00f1ade a nuestras rutas indicadas por par\u00e1metros (en caso de que se quiera mantener la opci\u00f3n con el array de rutas en el prop), y luego se validan funcionando como hasta ahora.</p> <p>Nuestro componente principal quedar\u00eda de la siguiente forma:</p> <pre><code>//...\nfunction App() {\nconst routes = const routes = [\n{\npath: '/search/:query',\nComponent: SearchPage\n}\n]\nreturn (\n&lt;main&gt;\n&lt;Router routes={routes} defaultComponent={Page404}&gt;\n&lt;Route path='/' Component={HomePage} /&gt;\n&lt;Route path='/about' Component={AboutPage} /&gt;\n&lt;/Router&gt;\n&lt;/main&gt;\n)\n}\n</code></pre>"},{"location":"tema_3/page-6/#carga-perezosa-de-componente","title":"Carga perezosa de componente","text":"<p>A la hora de realizar las rutas cargamos todos los componentes que forma parte de nuestra aplicaci\u00f3n. Lo malo de esto es que cargamos componentes en momentos que no vamos a usar en este momento. Por ejemplo, si estamos en la ruta <code>\\</code> se carga el componente <code>HomePage</code> (el utilizado), pero adem\u00e1s se carga el componente <code>AboutPage</code> (el no utilizado). Este \u00faltimo no es necesario hacer una carga en este caso.</p> <p>React nos ofrece el m\u00e9todo <code>lazy</code> para poder realizar importaciones din\u00e1micas (con el m\u00e9todo <code>import</code>) para poder cargar los componentes necesarios en el momento que vayan a ser usados y no antes:</p> <pre><code>const LazyHomePage = lazy(() =&gt; import('./pages/Home.jsx'))\nconst LazyAboutPage = lazy(() =&gt; import('./pages/About.jsx'))\n</code></pre> <p>Para que nuestro componente principal pueda importarlo cuando sea necesario, se debe volver en un componente <code>Suspend</code> que puede recibir en una prop llamada <code>fallback</code> un componente para indicar que se est\u00e1 cargando:</p> <pre><code>function App() {\n//...\nreturn (\n&lt;main&gt;\n&lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n&lt;Router routes={routes} defaultComponent={Page404}&gt;\n&lt;Route path='/' Component={HomePage} /&gt;\n&lt;Route path='/about' Component={AboutPage} /&gt;\n&lt;/Router&gt;\n&lt;/Suspense&gt;\n&lt;/main&gt;\n)\n}\n</code></pre>"},{"location":"tema_3/page-7/","title":"5 React Router","text":""},{"location":"tema_3/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>Existen varios paquetes que manejan todo el tema de las rutas, de forma muy parecido a la forma en la que la hemos realizado. Uno de los m\u00e1s conocidos es <code>react-router</code> y su versi\u00f3n m\u00e1s reciente es la v6. Otra de las librer\u00edas es <code>wouter</code>. La ventaja de esta con la de rect-router-dom es que es m\u00e1s liviana. Ambas librer\u00edas te permiten crear enrutados de forma declarativa, sencilla y de forma eficiente.</p> <p>El paquete React Router es una librer\u00eda para realizar navegaciones, pero es muy limitada a en cuanto el navegador, por lo que existe una versi\u00f3n m\u00e1s espec\u00edfica y con el acceso a la API del navegador React Router Dom que debe ser instalada:</p> <pre><code>npm install react-router-dom\n</code></pre>"},{"location":"tema_3/page-7/#browserrouter","title":"BrowserRouter","text":"<p><code>BrowserRouter</code> es un componente de React Router DOM que se utiliza para conectar la aplicaci\u00f3n React a la URL del navegador. Esto significa que, cuando un usuario cambia la URL en el navegador, el componente <code>BrowserRouter</code> actualizar\u00e1 la interfaz de usuario de la aplicaci\u00f3n para que coincida con la nueva ruta.</p> <p>En concreto, <code>BrowserRouter</code> utiliza la API History de HTML5 para mantener la sincronizaci\u00f3n entre la URL del navegador y la interfaz de usuario de la aplicaci\u00f3n. Cuando un usuario cambia la URL, la API History llama a un m\u00e9todo en el componente BrowserRouter para que actualice la interfaz de usuario.</p> <p><code>BrowserRouter</code> es el componente de enrutador m\u00e1s utilizado en React Router DOM. Se recomienda utilizarlo en la mayor\u00eda de las aplicaciones React, ya que proporciona una forma sencilla y eficaz de conectar la aplicaci\u00f3n a la URL del navegador.</p> <pre><code>ReactDOM.createRoot(document.getElementById('root')).render(\n&lt;BrowserRouter&gt;\n&lt;App /&gt;\n&lt;/BrowserRouter&gt;\n)\n</code></pre> <p>Aqu\u00ed hay algunos ejemplos de c\u00f3mo se puede utilizar BrowserRouter:</p> <ul> <li>Para crear una aplicaci\u00f3n web que se comporte como una aplicaci\u00f3n web progresiva (PWA).</li> <li>Para crear una aplicaci\u00f3n web que se pueda utilizar en dispositivos m\u00f3viles y de escritorio.</li> <li>Para crear una aplicaci\u00f3n web que utilice la navegaci\u00f3n por historial para permitir a los usuarios volver a p\u00e1ginas anteriores.</li> </ul> <p>Tiene un comportamiento muy parecido a nuestro componente <code>Router</code> del ejemplo anterior.</p>"},{"location":"tema_3/page-7/#routes","title":"Routes","text":"<p>El componente <code>Routes</code> es un componente de React Router DOM que se utiliza para definir las rutas de una aplicaci\u00f3n React. Cada ruta tiene un nombre y un componente asociado que se indica a trav\u00e9s del componente <code>Route</code>. Cuando un usuario navega a una ruta, el componente asociado se renderiza en la interfaz de usuario de la aplicaci\u00f3n.</p> <p>El componente <code>Route</code> tiene dos propiedades principales:</p> <ul> <li>path: La ruta que debe coincidir con la URL del navegador.</li> <li>element: El componente que se debe renderizar cuando la ruta coincide.</li> </ul> <p>El componente <code>Routes</code> hace otra de las funcionalidades de nuestro componente <code>Router</code>, y el componente <code>Route</code> es muy parecido al de nuestro ejemplo anterior, pero el componente <code>Route</code> de esta librer\u00eda recibe el elemento (componente ejecutado) mientras que en nuestro ejemplo le pas\u00e1bamos el componente para luego ejecutarlo internamente.</p> <pre><code>function App() {\nreturn (\n&lt;div className='App'&gt;\n&lt;Routes&gt;\n&lt;Route path='/' element={&lt;HomePage /&gt;} /&gt;\n&lt;Route path='/search' element={&lt;SearchPage /&gt;} /&gt;\n&lt;/Routes&gt;\n&lt;/div&gt;\n)\n}\n</code></pre> <p>Fuera del componente <code>Routes</code> se puede tener otros componentes o elementos. Esto puede ser \u00fatil para elementos que se repita en todas las rutas, como por ejemplo un men\u00fa de navegaci\u00f3n:</p> <pre><code>function App() {\nreturn (\n&lt;div className='App'&gt;\n&lt;header&gt;\n&lt;h1&gt;Chollos&lt;/h1&gt;\n&lt;nav&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href='/search'&gt;Search Page&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href='/'&gt;Home&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/nav&gt;\n&lt;/header&gt;\n&lt;Routes&gt;\n&lt;Route path='/' element={&lt;HomePage /&gt;} /&gt;\n&lt;Route path='/search' element={&lt;SearchPage /&gt;} /&gt;\n&lt;/Routes&gt;\n&lt;/div&gt;\n)\n}\n</code></pre>"},{"location":"tema_3/page-7/#spa-con-react-router-dom","title":"SPA con React Router Dom","text":"<p>Al ejecutar ele ejemplo anterior, comprobamos que no se cumple el prop\u00f3sito de una SPA, si no que se sigue recargando cada vez que se hace clic en un anchor. Por lo que debemos cambiar la url, sin necesidad de hacer la navegaci\u00f3n. Para ello, podemos usar el componente <code>Link</code> de la librer\u00eda. De esta forma conseguimos nuestro objetivo:</p> <pre><code>function App() {\nreturn (\n&lt;div className='App'&gt;\n&lt;header&gt;\n&lt;h1&gt;Chollos&lt;/h1&gt;\n&lt;nav&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;Link to='/search'&gt;Search Page&lt;/Link&gt;&lt;/li&gt;\n&lt;li&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/nav&gt;\n&lt;/header&gt;\n&lt;Routes&gt;\n&lt;Route path='/' element={&lt;HomePage /&gt;} /&gt;\n&lt;Route path='/search' element={&lt;SearchPage /&gt;} /&gt;\n&lt;/Routes&gt;\n&lt;/div&gt;\n)\n}\n</code></pre> <p>El componente <code>Link</code> funciona de forma muy parecida a nuestro componente del ejemplo anterior.</p>"},{"location":"tema_3/page-7/#rutas-con-parametros","title":"Rutas con par\u00e1metros","text":"<p>React router dom usa path-to-regex para las rutas con par\u00e1metros, por lo que si se desea indicar una ruta que puede recibir par\u00e1metros se indicar\u00eda <code>:name-of-parameter</code>.</p> <pre><code>function App() {\nreturn (\n&lt;div className='App'&gt;\n{/* ... */}\n&lt;Routes&gt;\n&lt;Route path='/' element={&lt;HomePage /&gt;} /&gt;\n&lt;Route path='/search' element={&lt;SearchPage /&gt;} /&gt;\n&lt;Route path='/product/:name' element={&lt;ProductPage /&gt;} /&gt;\n&lt;/Routes&gt;\n&lt;/div&gt;\n)\n}\n</code></pre> <p>Para recuperar dicho valor en el componente, React router dom nos pone a nuestra disposici\u00f3n el hook <code>useParams</code>, que nos devuelve un objeto con los nombre de los par\u00e1metros que le hemos indicado:</p> <pre><code>function ProductPage() {\nconst { name } = useParams()\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Product {name}&lt;/h1&gt;\n&lt;/div&gt;\n)\n}\n</code></pre>"},{"location":"tema_3/page-7/#nested-routes","title":"Nested Routes","text":"<p>Una nested routes (rutas anidadas) es una ruta que en su interior quiere otro tipos de rutas:</p> <pre><code>function ProductDetails() {\nconst { name } = useParams()\nreturn (\n&lt;h1&gt;Details from {name}&lt;/h1&gt;\n)\n}\nfunction App() {\nreturn (\n&lt;div className='App'&gt;\n{/* ... */}\n&lt;Routes&gt;\n&lt;Route path='/' element={&lt;HomePage /&gt;} /&gt;\n&lt;Route path='/search' element={&lt;SearchPage /&gt;} /&gt;\n&lt;Route path='/product/:name' element={&lt;ProductPage /&gt;}&gt;\n&lt;Route path='details' element={&lt;ProductDetails /&gt;} /&gt;\n&lt;/Route&gt;\n&lt;/Routes&gt;\n&lt;/div&gt;\n)\n}\n</code></pre> <p>Hay que tener en cuenta, que \u00f1as rutas indicadas debe ser de forma relativas, para que no haya incompatibilidad con el resto de rutas y me parta desde la ruta absoluta indicada. Para que el componente anidado se renderice debo indicarle donde se debe realizar, para ellos usamos el componente <code>&lt;Outlet/&gt;</code>. Indicamos dicho componente donde queremos que se renderice nuestro componente:</p> <pre><code>function ProductPage() {\nconst { name } = useParams()\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Product {name}&lt;/h1&gt;\n&lt;Link to='details'&gt;Go to the details&lt;/Link&gt;\n&lt;Outlet /&gt;\n&lt;/div&gt;\n)\n}\n</code></pre> <p>Cuando se usa rutas anidadas se puede indicar un \u00edndice como elemento principal de la ruta, renderizando de esa forma el componente de la ruta padre y el componente \u00edndice:</p> <pre><code>&lt;Routes&gt;\n&lt;Route path='/product' element={&lt;h1&gt;Product&lt;/h1&gt;}&gt;\n&lt;Route index element={&lt;h2&gt;Esto es un \u00edndice&lt;/h2&gt;} /&gt;\n&lt;/Route&gt;\n&lt;/Routes&gt;\n</code></pre>"},{"location":"tema_3/page-7/#ruta-por-defecto","title":"Ruta por defecto","text":"<p>React router dom no admite las rutas por defecto como en nuestro ejemplo anterior, pero podemos usar el <code>path-to-regex</code> para poder trabajar con ellas. La ruta por defecto, ser\u00eda una ruta que renderizar\u00e1 un componente para cualquiera de los casos no contemplado, en regex ser\u00eda la ruta <code>/*</code>:</p> <pre><code>function App() {\nreturn (\n&lt;div className='App'&gt;\n{/* ... */}\n&lt;Routes&gt;\n&lt;Route path='/' element={&lt;HomePage /&gt;} /&gt;\n&lt;Route path='/search' element={&lt;SearchPage /&gt;} /&gt;\n&lt;Route path='/product/:name' element={&lt;ProductPage /&gt;}&gt;\n&lt;Route path='details' element={&lt;ProductDetails /&gt;} /&gt;\n&lt;/Route&gt;\n&lt;Route path='*' element={&lt;h1&gt;Not found&lt;/h1&gt;} /&gt;\n&lt;/Routes&gt;\n&lt;/div&gt;\n)\n}\n</code></pre> <p>Hay que tener en cuenta que en versiones anterior de react router dom, las rutas eran comprobadas de arriba a abajo, pero desde la versi\u00f3n 6 existe un algoritmo que intenta averiguar que ruta es m\u00e1s importante. Al entrar solo en uno, si yo tengo dos rutas parecidas, pero con componentes diferentes entrar\u00eda en el primero que encuentre mayor coincidencia. Por ejemplo:</p> <pre><code>&lt;Routes&gt;\n&lt;Route path='/products/pc' element={/*...*/&gt;} /&gt;\n&lt;Route path='/products/:name' element={/*...*/&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre> <p>En este caso, cuando hagamos una navegaci\u00f3n a <code>/products/pc</code> entrar\u00eda en la primera ruta ya que es la que m\u00e1s coincide con la ruta, por lo que renderizar\u00e1 ese componente. Es importante que hay que tener en cuenta que son dos rutas muy parecidas pero con elementos diferentes, y es importante saber que querer renderizar en cada caso. Si se desea entrar en <code>/products/other</code>, en este caso, si entrar\u00eda en el segundo.</p>"},{"location":"tema_3/page-7/#navlink","title":"NavLink","text":"<p>El componente <code>NavLink</code> es un componente de React Router DOM que se utiliza para crear enlaces de navegaci\u00f3n. Los enlaces de navegaci\u00f3n son elementos de la interfaz de usuario que permiten a los usuarios navegar entre diferentes rutas de una aplicaci\u00f3n React. Se diferencias de <code>Link</code> es que <code>NavLink</code> tiene la capacidad de determinar si est\u00e1 activo, por lo que estos se suelen usar en el men\u00fa de navegaci\u00f3n.</p> <p>En versiones anteriores de la librer\u00eda, el componente <code>Link</code> recib\u00eda una prop para indicar el estilo de un enlace cuando nos encontr\u00e1bamos en dicha ruta (<code>activeClassName</code>), pero esto fue eliminado en la versi\u00f3n 6. Ahora el prop <code>className</code> puede recibir, o el nombre de la clase que le quieres indicar, o una funci\u00f3n. Dicha funci\u00f3n recibe informaci\u00f3n sobre el enlace, entre ellos si esta activo (<code>isActive</code>) y devuelve el nombre de la clase dependiendo de la l\u00f3gica que le deseas aplicar:</p> <pre><code>function App() {\nreturn (\n&lt;div className='App'&gt;\n&lt;header&gt;\n&lt;h1&gt;Chollos&lt;/h1&gt;\n&lt;nav&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;NavLink\nto='/search'\nclassName={({ isActive }) =&gt; {\nreturn isActive ? 'isActive' : ''\n}}\n&gt;\nSearch Page\n&lt;/NavLink&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;NavLink to='/'&gt;Home&lt;/NavLink&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/nav&gt;\n&lt;/header&gt;\n{/* ... */}\n&lt;/div&gt;\n)\n}\n</code></pre> <p>En caso de que no s\u00e9 indique, se le a\u00f1ade por defecto la clase <code>active</code> cuando este activo. Tambi\u00e9n podemos evitar pasarle una funci\u00f3n, creando un componente que trabaje con ello:</p> <pre><code>function NavLink({ to, children, ...props }) {\nreturn (\n&lt;NavLinkReactRouter\n{...props}\nclassName={({ isActive }) =&gt; isActive ? 'isActive' : undefined}\nto={to}\n&gt;\n{children}\n&lt;/NavLinkReactRouter&gt;\n)\n}\n</code></pre> <p>El componente <code>NavLinkReactRouter</code> es un al\u00edas al componente <code>NavLink</code> de React Router dom, para evitar la incompatibilidad. De esta forma, podemos usar nuestro componente sin tener que repetir el className para cuando est\u00e9 activo. Esto se puede modificar de muchas formas, por ejemplo, puede recibir un nombre para la clase cuando est\u00e9 activo y hacerlo m\u00e1s din\u00e1mico.</p>"},{"location":"tema_3/page-7/#useroutes","title":"useRoutes","text":"<p><code>useRoutes</code> es un hook de react router dom que es equivalente al componente <code>Routes</code>, es decir, sirve para indicar las rutas de nuestra aplicaci\u00f3n. Sin embargo, usa un array de objetos en lugar del componente <code>Route</code>. Tanto el objeto como el componente <code>Route</code> tienen las mismas propiedad: path para indicar la ruta y element para indicar el elemento a renderizar. Este hook retorna el elemento que debe ser renderizado seg\u00fan nuestra ruta:</p> <pre><code>const routes = [\n{\npath:'/',\nelement: &lt;HomePage/&gt;\n},\n{\npath:'/search',\nelement: &lt;SearchPage/&gt;   },\n{\npath:'/product/:name',\nelement: &lt;ProductPage/&gt;,\nchildren: {\npath: 'details',\nelement: &lt;ProductDetails /&gt;\n}\n},\n{\npath: '*',\nelement: &lt;h1&gt;Not found&lt;/h1&gt;\n}\n]\nfunction App() {\nconst element = useRoutes(routes)\nreturn (\n&lt;div className='App'&gt;\n&lt;header&gt;\n&lt;h1&gt;Chollos&lt;/h1&gt;\n&lt;nav&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;NavLink to='/search'&gt;Search Page&lt;/NavLink&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;NavLink to='/'&gt;Home&lt;/NavLink&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;NavLink to='/adios'&gt;Not found&lt;/NavLink&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/nav&gt;\n&lt;/header&gt;\n{element}\n&lt;/div&gt;\n)\n}\n</code></pre>"},{"location":"tema_3/page-7/#rutas-protegidas","title":"Rutas protegidas","text":"<p>Una ruta protegida es aquella ruta que solo podemos acceder en caso de realizar alg\u00fan tipo de acceso (login). Para ello debemos renderizar nuestros elementos dependiendo de si estamos o no autenticados. Para ello vamos a usar un contexto que lo comprueba:</p> <pre><code>const AuthContext = createContext()\nexport const useAuth = () =&gt; {\nconst auth = useContext(AuthContext)\nreturn auth\n}\nexport const AuthProvider = ({ children }) =&gt; {\nconst [isAuthenticated, setIsAuthenticated] = useState(false)\nconst login = () =&gt; {\nsetIsAuthenticated(true)\n}\nconst logout = () =&gt; {\nsetIsAuthenticated(false)\n}\nreturn (\n&lt;AuthContext.Provider value={{\nisAuthenticated,\nlogin,\nlogout\n}}\n&gt;\n{children}\n&lt;/AuthContext.Provider&gt;\n)\n}\n</code></pre> <p>El hook <code>useNavigate</code> es un hook que permite cambiar la localizaci\u00f3n cuando se necesario, por ejemplo, cuando se hace clic en un bot\u00f3n que no sea un anchor.</p> <p>El componente <code>&lt;Navigate&gt;</code> permite cambiar de localizaci\u00f3n cuando es renderizado. Internamente, dicho componente envuelve el hook <code>useNavigate</code>. Tanto el componente como el hook recibe la ruta a la cual quiere ser enviada, adem\u00e1s puede recibir informaci\u00f3n extra en una propiedad de objeto de llamado state.</p> <p>Vamos a envolver el componente que queremos renderizar cuando estemos en una ruta privada, en un componente que comprueba si estamos logueado, en caso de estarlo, devuelve el componente que deseemos renderizar, y si no el componente que se encarga del login.</p> <pre><code>function Login() {\nconst { login } = useAuth()\nconst navigate = useNavigate()\nconst handleClick = () =&gt; {\nlogin()\nnavigate('/search')\n}\nreturn (\n&lt;button onClick={handleClick}&gt;Login&lt;/button&gt;\n)\n}\nconst ProtectedRoute = ({ children }) =&gt; {\nconst { isAuthenticated } = useAuth()\nif (!isAuthenticated) return &lt;Navigate to='/login' /&gt;\nreturn children\n}\nfunction App() {\nreturn (\n&lt;AuthProvider&gt;\n&lt;div className='App'&gt;\n{/*  */}\n&lt;Routes&gt;\n{/* ... */}\n&lt;Route path='/search' element={&lt;ProtectedRoute&gt;&lt;SearchPage /&gt;&lt;/ProtectedRoute&gt;} /&gt;\n{/* ... */}\n&lt;/Routes&gt;\n&lt;/div&gt;\n&lt;/AuthProvider&gt;\n)\n}\n</code></pre> <p>A la hora hacer el login, le podemos indicar la ruta desde la que viene, para volver a navegar a ella cuando realicemos el login. Para ello, usaremos el hook <code>useLocation</code>, que se encarga de la informaci\u00f3n sobre la localizaci\u00f3n y se lo mandaremos desde el objeto state, que es el objeto donde se le puede mandar informaci\u00f3n entre navegaciones.</p> <pre><code>const ProtectedRoute = ({ children }) =&gt; {\nconst { isAuthenticated } = useAuth()\nconst location = useLocation()\nif (!isAuthenticated) return &lt;Navigate to='/login' state={{ location }} /&gt;\nreturn children\n}\nfunction Login() {\nconst { login } = useAuth()\nconst navigate = useNavigate()\nconst { state } = useLocation()\nconst handleClick = () =&gt; {\nlogin()\nnavigate(state?.location?.pathname ?? '/')\n}\nreturn (\n&lt;button onClick={handleClick}&gt;Login&lt;/button&gt;\n)\n}\nfunction App(){\n// ...\n}\n</code></pre>"},{"location":"tema_3/page-8/","title":"Proyecto Router","text":"<p>Se desea crear una aplicaci\u00f3n para ver pokemons y poder insertarlos en una pokedex virtual. Para ello, el men\u00fa de navegaci\u00f3n de nuestra aplicaci\u00f3n es la siguiente:</p> <ul> <li>Home: P\u00e1gina de inicio de nuestra aplicaci\u00f3n. En ella se mostrar\u00e1 informaci\u00f3n relevante para nuestro proyecto. (libre)</li> <li>Pokemons: En ella, se mostrar\u00e1 una lista con varios pokemons por defecto adem\u00e1s, tendr\u00e1 un buscador para buscar pokemons.</li> <li>Login: Navegar\u00e1 al login de la p\u00e1gina. Para hacer un login, solo es necesario el nombre del usuario. Solo se mostrar\u00e1 si el usuario no ha hecho login.</li> <li>Logout: Sirve para cerrar sesi\u00f3n. Al navegar aqu\u00ed, se volver\u00e1 a la p\u00e1gina de inicio cuando se cierre sesi\u00f3n. Adem\u00e1s, solo se podr\u00e1 visualizar si el usuario ha realizado login.</li> <li>Pokedex: El usuario puede indicar los pokemons que sean sus favoritos. En esta p\u00e1gina, dichos pokemons se visualizar\u00e1n y podr\u00e1n ser eliminados tambi\u00e9n. Solo se puede mostrar si el usuario est\u00e1 logueado.</li> </ul> <p>Adem\u00e1s, existe una p\u00e1gina m\u00e1s que no aparece en el men\u00fa, que me permitir\u00e1 ver m\u00e1s informaci\u00f3n de los pokemons. Los pokemons solo pueden ser a\u00f1adidos como favoritos si el usuario ha sido logueado correctamente.</p> <p>Hacer uso de la librer\u00eda react-router-dom, as\u00ed como del contexto y de custom hooks. Usa <code>localStorage</code> para mantener la informaci\u00f3n de usuario en el navegador.</p>"}]}