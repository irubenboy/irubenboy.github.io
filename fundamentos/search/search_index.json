{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"tema_1/page-1/","title":"1 Conceptos b\u00e1sicos","text":""},{"location":"tema_1/page-1/#computadora","title":"Computadora","text":"<p>Una computadora. o como se le conoce com\u00fan mente, un ordenador, es una m\u00e1quina electr\u00f3nica, anal\u00f3gica o digital, dotada de una memoria de gran capacidad y de m\u00e9todos de tratamiento de la informaci\u00f3n, capaz de resolver problemas matem\u00e1ticos y l\u00f3gicos mediante la utilizaci\u00f3n autom\u00e1tica de programas inform\u00e1ticos.</p>"},{"location":"tema_1/page-1/#informatica","title":"Inform\u00e1tica","text":"<p>Conjunto de conocimientos cient\u00edficos y t\u00e9cnicas que hacen posible el tratamiento autom\u00e1tico de la informaci\u00f3n por medio de ordenadores.</p>"},{"location":"tema_1/page-1/#hardware","title":"Hardware","text":"<p>Componentes f\u00edsicos que conforman parte de un ordenador (o de otro dispositivo electr\u00f3nico): procesador, RAM, impresora, teclado, rat\u00f3n,...</p>"},{"location":"tema_1/page-1/#software","title":"Software","text":"<p>Es el conjunto de programas de c\u00f3mputo, procedimientos, reglas, documentaci\u00f3n y datos asociados, que forman parte de las operaciones de un sistema de computaci\u00f3n.</p>"},{"location":"tema_1/page-1/#sistema-operativo","title":"Sistema Operativo","text":"<p>Se trata del software encargado de gestionar el ordenador. Es la aplicaci\u00f3n que oculta la f\u00edsica real del ordenador para mostrarnos una interfaz que permita al usuario un mejor y m\u00e1s f\u00e1cil manejo de la computadora. Por ejemplo: Windows, Linux, MacOS, etc.</p>"},{"location":"tema_1/page-1/#algoritmo","title":"Algoritmo","text":"<p>Conjunto ordenado y finito de operaciones que permite hallar la soluci\u00f3n de un problema.</p>"},{"location":"tema_1/page-1/#programa-informatico","title":"Programa inform\u00e1tico","text":"<p>Es una secuencia de instrucciones escritas para realizar una tarea espec\u00edfica en una computadora.</p>"},{"location":"tema_1/page-1/#aplicacion-informatica","title":"Aplicaci\u00f3n Inform\u00e1tica","text":"<p>Software formado por uno o m\u00e1s programas, la documentaci\u00f3n de los mismos y los archivos necesarios para su funcionamiento, de modo que el conjunto completo forma una herramienta de trabajo en un ordenador.</p>"},{"location":"tema_1/page-2/","title":"2 Codificaci\u00f3n de la informaci\u00f3n","text":""},{"location":"tema_1/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Un ordenador maneja informaci\u00f3n de todo tipo. Nuestra perspectiva humana nos permite r\u00e1pidamente diferenciar lo que no son n\u00fameros, de lo que es texto, imagen, ... Sin embargo al tratarse de una m\u00e1quina digital, el ordenador s\u00f3lo es capaz de representar n\u00fameros en forma binaria. Por ello todos los ordenadores necesitan codificar la informaci\u00f3n del mundo real al equivalente binario entendible por el ordenador.</p>"},{"location":"tema_1/page-2/#sistemas-numericos","title":"Sistemas Num\u00e9ricos","text":"<p>Existen dos tipos de sistemas num\u00e9ricos:</p> <ol> <li>Sistemas no posicionales. En ellos se utilizan s\u00edmbolos cuyo valor num\u00e9rico es siempre el mismo independientemente de donde se sit\u00faen.Es lo que ocurre con la numeraci\u00f3n romana. En esta numeraci\u00f3n el s\u00edmbolo <code>I</code> significa siempre <code>uno</code> independientemente de su posici\u00f3n.</li> <li>Sistemas posicionales. En ellos los s\u00edmbolos num\u00e9ricos cambian de valor en funci\u00f3n de la posici\u00f3n que ocupe. Es el caso de nuestra numeraci\u00f3n, el s\u00edmbolo 2, en la cifra 12 vale 2; mientra que en la cifra 21 vale viente.</li> </ol> <p>La historia ha demostrado que los sistemas posicionales son mucho mejores para los c\u00e1lculos matem\u00e1ticos ya que las operaciones matem\u00e1ticas son m\u00e1s sencillas. Todos los sistemas posicionales tienen una base, que es el n\u00famero total de s\u00edmbolos que utiliza el sistema.</p>"},{"location":"tema_1/page-2/#sistemas-posicionales","title":"Sistemas posicionales","text":"<ul> <li>Sistema decimal: la base es 10, ya que utiliza 10 s\u00edmbolos, desde el 0 hasta el 9.</li> <li>Sistema binario: la base es 2, utiliza 0 y 1.</li> <li>Sistema octal: la base es 8, desde el 0 hasta el 7.</li> <li>Sistema hexadecimal: la base es 16, donde el 0 al 9 y desde la A a la F</li> </ul> <p>Para convertir un n\u00famero octal en binario, se representa cada d\u00edgito en octal por tres d\u00edgitos binarios seg\u00fan la siguiente tabla de conversi\u00f3n:</p> Octal Binario 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 <p>Por lo tanto, el n\u00famero 467 en octal ser\u00eda 100110111 en binario.</p> <p>Los mismo podemos hacer con el binario y el hexadecimal pero con 4 d\u00edgitos.</p> Octal Binario 0 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111 8 1000 9 1001 A 1010 B 1011 C 1100 D 1101 E 1110 F 1111 <p>El n\u00famero B3F en hexadecimal es 1011001111111 en binario</p>"},{"location":"tema_1/page-2/#representacion-de-texto-en-el-sistema-binario","title":"Representaci\u00f3n de texto en el sistema binario","text":"<p>Puesto que una computadora no s\u00f3lo maneja n\u00fameros, habr\u00e1 d\u00edgitos binarios que contengan informaci\u00f3n que no es traducible a decimal. Todo depende de c\u00f3mo se interprete esa traducci\u00f3n. Por ejemplo en el caso del texto, lo que se hace es codificar cada car\u00e1cter en una serie de n\u00fameros binarios. El c\u00f3digo ASCII es un est\u00e1ndar que ha sido durante mucho tiempo el m\u00e1s utilizado. Inicialmente era un c\u00f3digo que utilizaba 7 bits para representar texto, lo que significaba que era capaz de codificar 127 caracteres. Por ejemplo el n\u00famero 65 (1000001 en binario) se utiliza para la A may\u00fascula. Poco despu\u00e9s apareci\u00f3 un problema: este c\u00f3digo es suficiente para los caracteres del ingl\u00e9s, pero no para otras lenguas. Entonces se a\u00f1adi\u00f3 el octavo bit para representar otros 128 caracteres que son distintos seg\u00fan idiomas(Europa Occidental usa unos c\u00f3digos que no utiliza Europa Oriental). Eso provoca que un c\u00f3digo como el 190 signifique cosas diferentes si cambiamos de pa\u00eds. Por ello cuando un ordenador necesita mostrar texto, tiene que saber qu\u00e9 juego de c\u00f3digos debe de utilizar (lo cual supone un tremendo problema). Una ampliaci\u00f3n de este m\u00e9todo de codificaci\u00f3n de caracteres es el est\u00e1ndar Unicode que puede utilizar hasta 4 bytes (32 bits) con lo que es capaz de codificar cualquier car\u00e1cter en cualquier lengua del planeta utilizando el mismo conjunto de c\u00f3digos. Poco a poco es el c\u00f3digo que se va extendiendo, siendo actualmente utilizado en un n\u00famero considerable de tecnolog\u00edas recientes, como XML, Java y sistemas operativos modernos.</p> <p>La descripci\u00f3n completa del est\u00e1ndar est\u00e1 disponible en la p\u00e1gina web de Unicode https://unicode.org/. En <code>Quick Links -&gt; Code Charts</code> encontraremos las tablas de caracteres. Los caracteres b\u00e1sicos del espa\u00f1ol los encontraremos en <code>Latin -&gt; Basic Latin (ASCII)</code> y los caracteres especiales del espa\u00f1ol por ejemplo, las vocales acentuadas y la \u00f1, en <code>Latin1 -&gt; Supplement</code>.</p>"},{"location":"tema_1/page-2/#representacion-binaria-de-datos-no-numericos-ni-de-texto","title":"Representaci\u00f3n binaria de datos no num\u00e9ricos ni de texto","text":"<p>En el caso de datos m\u00e1s complejos (im\u00e1genes, v\u00eddeo, audio) se necesita una codificaci\u00f3n m\u00e1s compleja. En el caso, por ejemplo de las im\u00e1genes, una forma b\u00e1sica de codificarlas en binario es la que graba cada p\u00edxel (cada punto distinguible en la imagen) mediante tres bytes: el primero graba el nivel de rojo, el segundo el nivel de azul y el tercero el nivel de verde. Y as\u00ed por cada p\u00edxel. Esto se conoce como modelo de color RGB donde es posible representar un color mediante la mezcla por adici\u00f3n de los tres colores de luz primarios. Por ejemplo un punto en una imagen de color rojo puro: <code>11111111 00000000 00000000</code>. Naturalmente en una imagen no solo se graban los p\u00edxeles sino el tama\u00f1o de la imagen, el modelo de color,... de ah\u00ed que representar estos datos sea tan complejo para el ordenador (y tan complejo entenderlo para nosotros).</p>"},{"location":"tema_1/page-2/#multiplos-para-medir-digitos-binarios","title":"M\u00faltiplos para medir d\u00edgitos binarios","text":"<p>Puesto que toda la informaci\u00f3n de un ordenador se representa de forma binaria, se hizo indispensable el utilizar unidades de medida para poder indicar la capacidad de los dispositivos:</p> <ul> <li>Bit (de binary digit). Representa un d\u00edgito binario. Por ejemplo, se dice que el n\u00famero binario 1001 tiene cuatro bits.</li> <li>Byte. Es el conjunto de 8 bits.</li> <li>Kilobyte. Son 1024 bytes.</li> <li>Megabyte. Son 1024 Kilobytes.</li> <li>Gigabyte. Son 1024 Megabytes.</li> <li>Terabyte. Son 1024 Gigabytes.</li> <li>Petabyte. Son 1024 Terabytes.</li> </ul>"},{"location":"tema_1/page-3/","title":"3 Arquitectura de Von Newmann","text":""},{"location":"tema_1/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>La mayor\u00eda de los sistemas inform\u00e1ticos actuales se basan en la arquitectura propuesta por Von Newmann. Esta arquitectura se caracteriza porque el programa que ejecuta el sistema inform\u00e1tico est\u00e1 almacenado internamente en el propio sistema.</p> <p> Figura 1 - Arquitectura de Von Newmann</p> <p>Los buses transportan la informaci\u00f3n entre los diferentes elementos.</p> <p> Figura 2 - Buses</p> <ul> <li>Buses de datos: Como su nombre indica transporta datos. Estos datos pueden ser la informaci\u00f3n que se est\u00e1 procesando o las instrucciones del programa que se ejecuta. El ancho en bits del bus de datos define el tama\u00f1o de la palabra del sistema inform\u00e1tico, por ejemplo, 32 bits \u00f3 64 bits.</li> <li>Bus de direcciones: El bus de direcciones se utiliza para indicar el origen y/o el destino de los datos. En el bus de direcciones se indica la posici\u00f3n de memoria a la que se est\u00e1 accediendo en cada momento. Puede tratarse de una direcci\u00f3n de la memoria principal o puede tratarse de una direcci\u00f3n de memoria de un perif\u00e9rico. El ancho en bits del bus de direcciones determina el tama\u00f1o del espacio de memoria direccionable. Un ancho de 16 bits puede almacenar 2 elevado a 16 (65.536) valores diferentes.</li> <li>Bus de control: El bus de control proporciona se\u00f1ales para coordinar las diferentes tareas que se realizan en el sistema inform\u00e1tico. Por ejemplo, R/W indica si es una operaci\u00f3n de lectura o escritura.</li> </ul>"},{"location":"tema_1/page-4/","title":"4 Historia del Software","text":"<p>Los primeros ordenadores cumpl\u00edan una \u00fanica programaci\u00f3n que estaba definida en los componentes el\u00e9ctricos que formaban el ordenador. La idea de que el ordenador hiciera varias tareas (ordenador programable o multiprop\u00f3sito) hizo que se idearan las tarjetas perforadas. En ellas se utilizaba c\u00f3digo binario, de modo que se hac\u00edan agujeros en ellas para indicar el c\u00f3digo 1 o el cero. Estos \u201cprimeros programas\u201d l\u00f3gicamente serv\u00edan para hacer tareas muy concretas.</p> <p>La llegada de ordenadores electr\u00f3nicos m\u00e1s potentes hizo que los ordenadores se convirtieran en verdaderas m\u00e1quinas digitales que segu\u00edan utilizando el 1 y el 0 del c\u00f3digo binario pero que eran capaces de leer miles de unos y ceros. Empezaron a aparecer los primeros lenguajes de programaci\u00f3n que escrib\u00edan c\u00f3digo m\u00e1s entendible por los humanos que posteriormente era convertido al c\u00f3digo entendible por la m\u00e1quina.</p> <p>Inicialmente la creaci\u00f3n de aplicaciones requer\u00eda escribir pocas l\u00edneas de c\u00f3digo en el ordenador, por lo que no hab\u00eda una t\u00e9cnica especificar a la hora de crear programas. Cada programador se defend\u00eda como pod\u00eda generando el c\u00f3digo a medida que se le ocurr\u00eda. Poco a poco las funciones que se requer\u00edan a los programas fueron aumentando produciendo miles de l\u00edneas de c\u00f3digo que al estar desorganizada hac\u00edan casi imposible su mantenimiento. S\u00f3lo el programador que hab\u00eda escrito el c\u00f3digo era capaz de entenderlo y eso no era en absoluto pr\u00e1ctico.</p> <p>La llamada crisis del software ocurri\u00f3 cuando se percibi\u00f3 que se gastaba m\u00e1s tiempo en hacer las modificaciones a los programas que en volver a crear el software. La raz\u00f3n era que ya se hab\u00edan codificado millones de l\u00edneas de c\u00f3digo antes de que se definiera un buen m\u00e9todo para crear los programas. La soluci\u00f3n a esta crisis ha sido la definici\u00f3n de la Ingenier\u00eda del software como un oficio que requer\u00eda un m\u00e9todo de trabajo similar al del resto de ingenier\u00edas. La b\u00fasqueda de una metodolog\u00eda de trabajo que elimine esta crisis parece que a\u00fan no est\u00e1 resuelta, de hecho los m\u00e9todos de trabajo siguen redefini\u00e9ndose una y otra vez.</p>"},{"location":"tema_1/page-5/","title":"5 Ciclo de vida de una aplicaci\u00f3n","text":"<p> Figura 3 - Ciclo de vida</p> <p>Una de las cosas que se han definido tras el nacimiento de la ingenier\u00eda del software ha sido el ciclo de vida de una aplicaci\u00f3n. El ciclo de vida define los pasos que sigue el proceso de creaci\u00f3n de una aplicaci\u00f3n desde que se propone hasta que finaliza su construcci\u00f3n. Los pasos son:</p> <ol> <li>An\u00e1lisis. En esta fase se determinan los requisitos que tiene que cumplir la aplicaci\u00f3n. Se anota todo aquello que afecta al futuro funcionamiento de la aplicaci\u00f3n. Este paso le realiza un analista.</li> <li>Dise\u00f1o. Se especifican los esquemas de dise\u00f1o de la aplicaci\u00f3n. Estos esquemas forman los planos del programador, los realiza el analista y representan todos los aspectos que requiere la creaci\u00f3n de la aplicaci\u00f3n.</li> <li>Codificaci\u00f3n. En esta fase se pasa el dise\u00f1o a c\u00f3digo escrito en alg\u00fan lenguaje de programaci\u00f3n. Esta es la primera labor que realiza el programador.</li> <li>Pruebas. Se trata de comprobar que el funcionamiento de la aplicaci\u00f3n es la adecuada. Se realiza en varias fases:<ol> <li>Prueba del c\u00f3digo. Las realizan programadores. Normalmente programadores distintos a los que crearon el c\u00f3digo, de ese modo la prueba es m\u00e1s independiente y generar\u00e1 resultados m\u00e1s \u00f3ptimos.</li> <li>Versi\u00f3n alfa. Es una primera versi\u00f3n terminada que se revisa a fin de encontrar errores. Estas pruebas conviene que sean hechas por personal no inform\u00e1tico. El producto s\u00f3lo tiene cierta apariencia de acabado.</li> <li>Versi\u00f3n beta. Versi\u00f3n casi definitiva del software en la que no se estiman fallos, pero que se distribuye a los clientes para que encuentren posibles problemas. A veces est\u00e1 versi\u00f3n acaba siendo la definitiva.</li> </ol> </li> <li>Mantenimiento. Tiene lugar una vez que la aplicaci\u00f3n ha sido ya distribuida. En esta fase se asegura que el sistema siga funcionando aunque cambien los requisitos o el sistema para el que fue dise\u00f1ado el software. Antes esos cambios se hacen los arreglos pertinentes, por lo que habr\u00e1 que retroceder a fases anteriores del ciclo de vida.</li> </ol>"},{"location":"tema_1/page-6/","title":"6 Errores","text":"<p>Cuando un programa obtiene una salida que no es la esperada, se dice que posee errores. Los errores son uno de los caballos de batalla de los programadores ya que a veces son muy dif\u00edciles de encontrar (de ah\u00ed que hoy en d\u00eda en muchas aplicaciones se distribuyan parches para subsanar errores no encontrados en la creaci\u00f3n de la aplicaci\u00f3n). Tipos de errores:</p> <ul> <li>Error del usuario. Errores que se producen cuando el usuario realiza algo inesperado y el programa no reacciona apropiadamente (se entiende por usuario la persona que utiliza la aplicaci\u00f3n inform\u00e1tica).</li> <li>Errores de documentaci\u00f3n. Ocurren cuando la documentaci\u00f3n del programa no es correcta y provoca fallos en el manejo.</li> <li>Error de interfaz. Se entiende por interfaz el medio con que el usuario se comunica con la m\u00e1quina, como ventanas, men\u00fas, etc. El error de interfaz ocurre si la interfaz de usuario de la aplicaci\u00f3n es enrevesada para el usuario impidiendo su manejo normal. Tambi\u00e9n se llaman as\u00ed los errores de protocolo entre dispositivos.</li> <li>Error de entrada / salida o de comunicaciones. Ocurre cuando falla la comunicaci\u00f3n entre el programa y un dispositivo (se desea imprimir y no hay papel, falla el teclado,...)</li> <li>Error fatal. Ocurre cuando el hardware produce una situaci\u00f3n inesperada que el software no puede controlar (el ordenador se cuelga, errores en la grabaci\u00f3n de datos,...)</li> <li>Error de sintaxis. Ocurre cuando una instrucci\u00f3n del c\u00f3digo no est\u00e1 bien escrita, es decir, tiene un error de sintaxis. Por lo tanto, no puede ser traducida a c\u00f3digo binario.</li> <li>Error de ejecuci\u00f3n. Se produce cuando el ordenador no puede ejecutar alguna instrucci\u00f3n de forma correcta. Por ejemplo, la instrucci\u00f3n c = 5 / 0; es correcta sint\u00e1cticamente y ser\u00e1 traducida a c\u00f3digo binario. Sin embargo, cuando la computadora intente realizar la divisi\u00f3n 5 / 0 se producir\u00e1 un error de ejecuci\u00f3n, ya que, matem\u00e1ticamente, no se puede dividir entre cero.</li> <li>Error de l\u00f3gica. En cuanto a los errores de l\u00f3gica son los m\u00e1s dif\u00edciles de detectar. Cuando un programa no tiene errores de sintaxis ni de ejecuci\u00f3n, pero a\u00fan as\u00ed, no funciona bien, esto es debido a la existencia de alg\u00fan error l\u00f3gico. De manera que, un error de l\u00f3gica se produce cuando los resultados obtenidos no son los esperados.</li> </ul>"},{"location":"tema_1/page-7/","title":"7 Lenguajes de programaci\u00f3n","text":""},{"location":"tema_1/page-7/#historia","title":"Historia","text":""},{"location":"tema_1/page-7/#inicio-en-la-programacion","title":"Inicio en la programaci\u00f3n","text":"<p>Charles Babbage defini\u00f3 a mediados del siglo XIX lo que \u00e9l llam\u00f3 la m\u00e1quina anal\u00edtica. Se considera a esta m\u00e1quina el dise\u00f1o del primer ordenador. La realidad es que no se pudo construir hasta el siglo siguiente. El caso es que su colaboradora Ada Lovelace escribi\u00f3 en tarjetas perforadas una serie de instrucciones que la m\u00e1quina iba a ser capaz de ejecutar. Se dice que eso signific\u00f3 el inicio de la ciencia de la programaci\u00f3n de ordenadores. En la segunda guerra mundial debido a las necesidades militares, la ciencia de la computaci\u00f3n prospera y con ella aparece el famoso ENIAC (Electronic Numerical Integrator And Calculator), que se programaba cambiando su circuiter\u00eda. Esa es la primera forma de programar (que a\u00fan se usa en numerosas m\u00e1quinas) que s\u00f3lo vale para m\u00e1quinas de \u00fanico prop\u00f3sito. Si se cambia el prop\u00f3sito, hay que modificar la m\u00e1quina.</p>"},{"location":"tema_1/page-7/#codigo-maquina-primera-generacion-de-lenguajes-1gl","title":"C\u00f3digo m\u00e1quina. Primera generaci\u00f3n de lenguajes (1GL)","text":"<p>No mucho m\u00e1s tarde apareci\u00f3 la idea de que las m\u00e1quinas fueran capaces de realizar m\u00e1s de una aplicaci\u00f3n. Para lo cual se ide\u00f3 el hecho de que hubiera una memoria donde se almacenaran esas instrucciones. Esa memoria se pod\u00eda rellenar con datos procedentes del exterior. Inicialmente se utilizaron tarjetas perforadas para introducir las instrucciones. Durante mucho tiempo esa fue la forma de programar, que teniendo en cuenta que las m\u00e1quinas entend\u00edan s\u00f3lo c\u00f3digo binario, consist\u00eda en introducir la programaci\u00f3n de la m\u00e1quina mediante unos y ceros, el llamado c\u00f3digo m\u00e1quina. Todav\u00eda los ordenadores es el \u00fanico c\u00f3digo que entienden, por lo que cualquier forma de programar debe de ser convertida a c\u00f3digo m\u00e1quina. S\u00f3lo se ha utilizado por los programadores en los inicios de la inform\u00e1tica. Su incomodidad de trabajo hace que sea impensable para ser utilizado hoy en d\u00eda. Pero cualquier programa de ordenador debe, finalmente, ser convertido a este c\u00f3digo para que un ordenador puede ejecutar las instrucciones de dicho programa. Un detalle a tener en cuenta es que el c\u00f3digo m\u00e1quina es distinto para cada tipo de procesador. Lo que hace que los programas en c\u00f3digo m\u00e1quina no sean portables entre distintas m\u00e1quinas.</p>"},{"location":"tema_1/page-7/#lenguaje-ensamblador-segunda-generacion-de-lenguajes-2gl","title":"Lenguaje ensamblador. Segunda generaci\u00f3n de lenguajes (2GL)","text":"<p>En los a\u00f1os 40 se intent\u00f3 concebir un lenguaje m\u00e1s simb\u00f3lico que permitiera no tener que programar utilizando c\u00f3digo m\u00e1quina. Poco m\u00e1s tarde se ide\u00f3 el lenguaje ensamblador, que es la traducci\u00f3n del c\u00f3digo m\u00e1quina a una forma m\u00e1s textual. Cada tipo de instrucci\u00f3n se asocia a una palabra mnemotecnia (como SUM para sumar por ejemplo), de forma que cada palabra tiene traducci\u00f3n directa en el c\u00f3digo m\u00e1quina. Tras escribir el programa en c\u00f3digo ensamblador, un programa (llamado tambi\u00e9n ensamblador) se encargar\u00e1 de traducir el c\u00f3digo ensamblador a c\u00f3digo m\u00e1quina. Esta traducci\u00f3n es r\u00e1pida puesto que cada l\u00ednea en ensamblador tiene equivalente directo en c\u00f3digo m\u00e1quina (en los lenguajes modernos no ocurre esto). La idea es la siguiente: si en el c\u00f3digo m\u00e1quina el n\u00famero binario 0000 significa sumar, una instrucci\u00f3n m\u00e1quina que sumara el n\u00famero 8 (00001000 en binario) al n\u00famero 16 (00010000 en binario) ser\u00eda <code>00000000100000010000</code>. El ordenador entender\u00eda que los primeros cuatro bits representan la instrucci\u00f3n y los 8 siguientes el primer n\u00famero y los ocho siguientes el segundo n\u00famero (suponiendo que los n\u00fameros ocupan 8 bits). L\u00f3gicamente trabajar de esta forma es muy complicado. Por eso se podr\u00eda utilizar la siguiente traducci\u00f3n en ensamblador: <code>SUM 8 16</code> , que ya se entiende mucho mejor. Puesto que el ensamblador es una representaci\u00f3n textual pero exacta del c\u00f3digo m\u00e1quina, cada programa s\u00f3lo funcionar\u00e1 para la m\u00e1quina en la que fue concebido el programa, es decir, no es portable. La ventaja de este lenguaje es que se puede controlar absolutamente el funcionamiento de la m\u00e1quina, lo que permite crear programas muy eficientes. Lo malo es precisamente que hay que conocer muy bien el funcionamiento de la computadora para crear programas con esta t\u00e9cnica. Adem\u00e1s las l\u00edneas requeridas para realizar una tarea se disparan ya que las instrucciones de la m\u00e1quina son excesivamente simples.</p>"},{"location":"tema_1/page-7/#lenguajes-de-alto-nivel-lenguajes-de-tercera-generacion-3gl","title":"Lenguajes de alto nivel. Lenguajes de tercera generaci\u00f3n (3GL)","text":"<p>Aunque el ensamblador signific\u00f3 una notable mejora sobre el c\u00f3digo m\u00e1quina, segu\u00eda siendo excesivamente cr\u00edptico. De hecho para hacer un programa sencillo, se necesitaban miles y miles l\u00edneas de c\u00f3digo. Para evitar los problemas del ensamblador apareci\u00f3 la tercera generaci\u00f3n de lenguajes de programaci\u00f3n, la de los lenguajes de alto nivel. En este caso el c\u00f3digo vale para cualquier m\u00e1quina pero deber\u00e1 ser traducido mediante software especial que adaptar\u00e1 el c\u00f3digo de alto nivel al c\u00f3digo m\u00e1quina correspondiente. Esta traducci\u00f3n es necesaria ya que el c\u00f3digo en un lenguaje de alto nivel no se parece en absoluto al c\u00f3digo m\u00e1quina. Tras varios intentos de representar lenguajes, en 1957 aparece el que se considera el primer lenguaje de alto nivel, el FORTRAN (FORmula TRANslation), lenguaje orientado a resolver f\u00f3rmulas matem\u00e1ticas. Poco a poco fueron evolucionando los lenguajes formando lenguajes cada vez mejores. As\u00ed en 1958 se crea LISP como lenguaje declarativo para expresiones matem\u00e1ticas, en 1960 se cre\u00f3 el COBOL como lenguaje de gesti\u00f3n y en 1963 se cre\u00f3 PL/I el primer lenguaje que admit\u00eda la multitarea y la programaci\u00f3n modular. BASIC se cre\u00f3 en el a\u00f1o 1964 como lenguaje de programaci\u00f3n sencillo de aprender y ha sido uno de los lenguajes m\u00e1s populares. En 1968 se crea LOGO para ense\u00f1ar a programar a los ni\u00f1os. Pascal se cre\u00f3 con la misma idea acad\u00e9mica pero siendo ejemplo de lenguaje estructurado para programadores avanzados. El creador del Pascal (Niklaus Wirdth) cre\u00f3 Modula en 1977 siendo un lenguaje estructurado para la programaci\u00f3n de sistemas (intentando sustituir al C). C es un lenguaje de programaci\u00f3n originalmente desarrollado por Dennis Ritchie entre 1969 y 1972 como evoluci\u00f3n del anterior lenguaje B a su vez basado en BCPL. Al igual que B, es un lenguaje orientado a la implementaci\u00f3n de Sistemas operativos, concretamente Unix. C es apreciado por la eficiencia del c\u00f3digo que produce y es el lenguaje de programaci\u00f3n m\u00e1s popular para crear software de sistemas, aunque tambi\u00e9n se utiliza para crear aplicaciones. Es un lenguaje de medio nivel ya que dispone de las estructuras t\u00edpicas de los lenguajes de alto nivel pero a su vez dispone de construcciones del lenguaje que permiten un control a muy bajo nivel pudiendo acceder directamente a memoria o dispositivos perif\u00e9ricos.</p>"},{"location":"tema_1/page-7/#lenguajes-de-cuarta-generacion-4gl","title":"Lenguajes de cuarta generaci\u00f3n (4GL)","text":"<p>En los a\u00f1os 70 se empez\u00f3 a utilizar \u00e9ste t\u00e9rmino para hablar de lenguajes en los que apenas hay c\u00f3digo y en su lugar aparecen indicaciones sobre qu\u00e9 es lo que el programa debe de obtener. Se consideraba que el lenguaje SQL (muy utilizado en las bases de datos) y sus derivados eran de cuarta generaci\u00f3n. Los lenguajes de consulta de datos, creaci\u00f3n de formularios, informes,... son lenguajes de cuarta generaci\u00f3n. Aparecieron con los sistemas de base de datos. Actualmente se consideran lenguajes de \u00e9ste tipo a aquellos lenguajes que se programan sin escribir casi c\u00f3digo (lenguajes visuales), mientras que tambi\u00e9n se propone que este nombre se reserve a los lenguajes orientados a objetos.</p>"},{"location":"tema_1/page-7/#lenguaje-orientado-a-objetos","title":"Lenguaje orientado a objetos","text":"<p>En los 80 llegan los lenguajes preparados para la programaci\u00f3n orientada a objetos todos procedentes de Simula (1964) considerado el primer lenguaje con facilidades de uso de objetos. De estos destac\u00f3 inmediatamente C++. A partir de C++ aparecieron numerosos lenguajes que convirtieron los lenguajes cl\u00e1sicos en lenguajes orientados a objetos y adem\u00e1s con mejoras en el entorno de programaci\u00f3n, son los llamados lenguajes visuales: Visual Basic, Delphi (versi\u00f3n orientada a objetos de Pascal), Visual C++,...En 1995 aparece Java como lenguaje totalmente orientado a objetos y en el a\u00f1o 2000 aparece C# un lenguaje que toma la forma de trabajar de C++ y del propio Java.</p>"},{"location":"tema_1/page-7/#lenguajes-para-la-web","title":"Lenguajes para la web","text":"<p>La popularidad de Internet ha producido lenguajes h\u00edbridos que se mezclan con el c\u00f3digo HTML con el que se crean las p\u00e1ginas web. HTML no es un lenguaje en s\u00ed sino un formato de texto pensado para crear p\u00e1ginas web. Estos lenguajes se usan para poder realizar p\u00e1ginas web m\u00e1s potentes. Son lenguajes interpretados como JavaScript o VB Script, o lenguajes especiales para uso en servidores como ASP, JSP o PHP. Todos ellos permiten crear p\u00e1ginas web usando c\u00f3digo mezcla de p\u00e1ginas web y lenguajes de programaci\u00f3n sencillos.</p>"},{"location":"tema_1/page-7/#tipos-de-lenguajes","title":"Tipos de lenguajes","text":"<p>Seg\u00fan el estilo de programaci\u00f3n se puede hacer esta divisi\u00f3n:</p> <ul> <li>Lenguajes imperativos. Son lenguajes que se centran en c\u00f3mo resolver el problema. Las instrucciones se ejecutan secuencialmente y van modificando la memoria del ordenador para producir las salidas requeridas. La mayor\u00eda de lenguajes (C, Pascal, Basic, Cobol, ...) son de este tipo. Dentro de estos lenguajes est\u00e1n tambi\u00e9n los lenguajes orientados a objetos (C++, Java, C#,...).</li> <li>Lenguajes declarativos. Son lenguajes que se centran en el qu\u00e9 queremos resolver en lugar de en c\u00f3mo resolverlo. El m\u00e1s conocido de ellos es el SQL, lenguaje de consulta de Bases de datos.</li> <li>Lenguajes funcionales. Definen funciones que nos responden a trav\u00e9s de una serie de argumentos. Son lenguajes que usan expresiones matem\u00e1ticas. El m\u00e1s conocido de ellos es el LISP.</li> <li>Lenguajes l\u00f3gicos. Lenguajes utilizados para resolver expresiones l\u00f3gicas. Utilizan la l\u00f3gica para producir resultados. El m\u00e1s conocido es el PROLOG.</li> </ul>"},{"location":"tema_1/page-7/#interpretes","title":"Int\u00e9rpretes","text":"<p>Se convierte cada l\u00ednea a c\u00f3digo m\u00e1quina y se ejecuta ese c\u00f3digo m\u00e1quina antes de convertir la siguiente l\u00ednea. De esa forma si las dos primeras l\u00edneas son correctas y la tercera tiene un fallo de sintaxis, ver\u00edamos el resultado de las dos primeras l\u00edneas y al llegar a la tercera se nos notificar\u00eda el fallo y finalizar\u00eda la ejecuci\u00f3n. El int\u00e9rprete hace una simulaci\u00f3n de modo que parece que la m\u00e1quina entiende directamente las instrucciones del lenguaje, pareciendo que ejecuta cada instrucci\u00f3n (como si fuese c\u00f3digo m\u00e1quina directo). El BASIC era un lenguaje interpretado, se traduc\u00eda l\u00ednea a l\u00ednea. Hoy en d\u00eda la mayor\u00eda de los lenguajes integrados en p\u00e1ginas web son interpretados, la raz\u00f3n es que como la descarga de Internet es lenta, es mejor que las instrucciones se vayan traduciendo seg\u00fan van llegando en lugar de cargar todas en el ordenador. Por eso lenguajes como JavaScript son interpretados.</p> <p>Un programa que se convierte a c\u00f3digo m\u00e1quina mediante un int\u00e9rprete sigue estos pasos:</p> <ol> <li>Lee la primera instrucci\u00f3n</li> <li>Comprueba si es correcta</li> <li>Convierte esa instrucci\u00f3n al c\u00f3digo m\u00e1quina equivalente</li> <li>Lee la siguiente instrucci\u00f3n</li> <li>Vuelve al paso 2 hasta terminar con todas las instrucciones</li> </ol> <p>Ventajas de los int\u00e9rpretes</p> <ul> <li>Se tarda menos en crear el primer c\u00f3digo m\u00e1quina. El programa se ejecuta antes.</li> <li>No hace falta cargar todas las l\u00edneas para empezar a ver resultados (lo que hace que sea una t\u00e9cnica id\u00f3nea para programas que se cargan desde Internet)</li> </ul> <p>Desventajas de los int\u00e9rpretes:</p> <ul> <li>El c\u00f3digo m\u00e1quina producido es peor ya que no se optimiza al valorar una sola l\u00ednea cada vez. El c\u00f3digo optimizado permite estudiar varias l\u00edneas a la vez para producir el mejor c\u00f3digo m\u00e1quina posible, por ello no es posible mediante el uso de int\u00e9rpretes.</li> <li>Todos los errores son errores en tiempo de ejecuci\u00f3n, no se pueden detectar antes de lanzar el programa. Esto hace que la depuraci\u00f3n de los errores sea m\u00e1s compleja.</li> <li>El c\u00f3digo m\u00e1quina resultante gasta m\u00e1s espacio.</li> <li>Hay errores dif\u00edcilmente detectables, ya que para que los errores se produzcan, las l\u00edneas de errores hay que ejecutarlas. Si la l\u00ednea es condicional, hasta que no probemos todas las posibilidades del programa, no sabremos todos los errores de sintaxis cometidos.</li> </ul>"},{"location":"tema_1/page-7/#compiladores","title":"Compiladores","text":"<p>Se trata de software que traduce las instrucciones de un lenguaje de programaci\u00f3n de alto nivel a c\u00f3digo m\u00e1quina. La diferencia con los int\u00e9rpretes reside en que se analizan todas las l\u00edneas antes de empezar la traducci\u00f3n. Durante muchos a\u00f1os, los lenguajes potentes han sido compilados. El uso masivo de Internet ha propiciado que esta t\u00e9cnica a veces no sea adecuada y haya lenguajes modernos interpretados o semi-interpretados, mitad se compila hacia un c\u00f3digo intermedio y luego se interpreta l\u00ednea a l\u00ednea (esta t\u00e9cnica la siguen Java y los lenguajes de la plataforma .NET de Microsoft).</p> <p>Ventajas de los compiladores:</p> <ul> <li>Se detectan errores antes de ejecutar el programa (errores de compilaci\u00f3n).</li> <li>El c\u00f3digo m\u00e1quina generado es m\u00e1s r\u00e1pido (ya que se optimiza).</li> <li>Es m\u00e1s f\u00e1cil hacer procesos de depuraci\u00f3n de c\u00f3digo.</li> </ul> <p>Desventajas de los compiladores:</p> <ul> <li>El proceso de compilaci\u00f3n del c\u00f3digo es lento.</li> <li>No es \u00fatil para ejecutar programas desde Internet ya que hay que descargar todo el programa antes de traducirle, lo que ralentiza mucho su uso.</li> </ul>"},{"location":"tema_1/page-7/#interpretes-y-compiladores","title":"Int\u00e9rpretes y compiladores","text":"<p>Existen otros lenguajes que usan ambas t\u00e9cnicas de traducci\u00f3n de m\u00e1quinas, es decir, que compilan su c\u00f3digo a un lenguaje intermedio y dicho lenguaje es interpretado a c\u00f3digo m\u00e1quina. Por ejemplo, Java utiliza est\u00e1 t\u00e9cnica para sus programas y este proceso es posible gracias a una m\u00e1quina virtual propia del lenguaje.</p>"},{"location":"tema_1/page-8/","title":"8 Tipos de paradigmas de programaci\u00f3n","text":""},{"location":"tema_1/page-8/#introduccion","title":"Introducci\u00f3n","text":"<p>Un paradigma de programaci\u00f3n es un modelo b\u00e1sico de dise\u00f1o y desarrollo de programas que permite generar programas con un conjunto de normas espec\u00edficas.</p> <p>En general, la mayor\u00eda de paradigmas son variantes de los dos tipos principales de programaci\u00f3n, imperativa y declarativa. En la programaci\u00f3n imperativa se describe paso a paso un conjunto de instrucciones que deben ejecutarse para variar el estado del programa y hallar la soluci\u00f3n, es decir, un algoritmo en el que se describen los pasos necesarios para solucionar el problema.</p> <p>En la programaci\u00f3n declarativa las sentencias que se utilizan lo que hacen es describir el problema que se quiere solucionar; se programa diciendo lo que se quiere resolver pero no las instrucciones necesarias para solucionarlo. Esto \u00faltimo se realizar\u00e1 mediante mecanismos internos de deducci\u00f3n de informaci\u00f3n a partir de la descripci\u00f3n realizada.</p> <p>A continuaci\u00f3n se describen algunas de las distintas variantes de paradigmas de programaci\u00f3n:</p>"},{"location":"tema_1/page-8/#programacion-imperativa","title":"Programaci\u00f3n imperativa","text":"<p>Es uno de los paradigmas de programaci\u00f3n de computadoras m\u00e1s utilizados. Bajo este paradigma, la programaci\u00f3n se describe en t\u00e9rminos del estado del programa y de sentencias que cambian dicho estado.</p> <p>Dentro de esta categor\u00eda se engloban la programaci\u00f3n estructurada y la programaci\u00f3n orientada a objetos, las cuales han permitido mejorar la mantenibilidad y la calidad de los programas imperativos.</p>"},{"location":"tema_1/page-8/#programacion-estructurada","title":"Programaci\u00f3n estructurada","text":"<p>Est\u00e1 orientada a mejorar la claridad, calidad y tiempo de desarrollo de un programa de computadora recurriendo \u00fanicamente a subrutinas y tres estructuras b\u00e1sicas: secuencia, selecci\u00f3n (if y switch) e iteraci\u00f3n(bucles for y while).</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p>"},{"location":"tema_1/page-8/#programacion-orientada-a-objetos","title":"Programaci\u00f3n orientada a objetos","text":"<p>La programaci\u00f3n orientada a objetos encapsula elementos denominados objetos.</p> <p>Bajo este paradigma, la programaci\u00f3n se describe como una serie de objetos independientes que se comunican entre s\u00ed. Java es un lenguaje orientado a objetos.</p>"},{"location":"tema_1/page-8/#programacion-orientada-a-eventos","title":"Programaci\u00f3n orientada a eventos","text":"<p>La programaci\u00f3n dirigida por eventos es un paradigma de programaci\u00f3n en el que tanto la estructura como la ejecuci\u00f3n de los programas van determinados por los sucesos que ocurran en el sistema, definidos por el usuario o lo que sea que est\u00e9 accionando el programa.</p> <p>Mientras que en la programaci\u00f3n estructurada es el programador el que define cu\u00e1l va a ser el flujo del programa, en la programaci\u00f3n dirigida por eventos ser\u00e1 el propio usuario, o lo que sea que est\u00e9 accionando el programa, el que dirija el flujo del programa. Aunque en la programaci\u00f3n estructurada puede haber intervenci\u00f3n de un agente externo al programa, estas intervenciones ocurrir\u00e1n cuando el programador lo haya determinado, y no en cualquier momento como puede ser en el caso de la programaci\u00f3n dirigida por eventos.</p>"},{"location":"tema_1/page-8/#programacion-declarativa","title":"Programaci\u00f3n declarativa","text":"<p>Est\u00e1 basada en describir el problema declarando propiedades y reglas que deben cumplirse, en lugar de instrucciones. La soluci\u00f3n es obtenida mediante mecanismos internos de control, sin especificar exactamente c\u00f3mo encontrarla (tan solo se le indica a la computadora qu\u00e9 es lo que se desea obtener o qu\u00e9 es lo que se est\u00e1 buscando). Los lenguajes declarativos tienen la ventaja de ser razonados matem\u00e1ticamente, lo que permite el uso de mecanismos matem\u00e1ticos para optimizar el rendimiento de los programas.</p> <p>Dentro de esta categor\u00eda se engloban la programaci\u00f3n funcional y la programaci\u00f3n l\u00f3gica.</p>"},{"location":"tema_1/page-8/#programacion-funcional","title":"Programaci\u00f3n funcional","text":"<p>Es un paradigma de programaci\u00f3n en el que el resultado de un programa deriva de la aplicaci\u00f3n de distintas funciones a la entrada, sin cambiar el estado interno del programa. En la programaci\u00f3n funcional los bloques principales de construcci\u00f3n de nuestros programas son las funciones, y no los objetos.</p> <p>Al aplicar programaci\u00f3n funcional se produce normalmente un c\u00f3digo m\u00e1s corto y m\u00e1s sencillo de entender que aplicando programaci\u00f3n imperativa.</p>"},{"location":"tema_1/page-8/#programacion-logica","title":"Programaci\u00f3n l\u00f3gica","text":"<p>Es un paradigma de programaci\u00f3n basado en la definici\u00f3n de relaciones l\u00f3gicas.</p>"},{"location":"tema_1/page-8/#programacion-multiparadigma","title":"Programaci\u00f3n multiparadigma","text":"<p>Es el uso de dos o m\u00e1s paradigmas dentro de un programa. Por ejemplo, Java es imperativo y orientado a objetos</p>"},{"location":"tema_2/page-1/","title":"1 Algoritmos","text":"<p>Un algoritmo es una secuencia de pasos que describen el m\u00e9todo para resolver un problema. La ejecuci\u00f3n de un algoritmo implica la ejecuci\u00f3n de cada uno de sus pasos.</p> <p>Para solucionar un problema es exigente dise\u00f1ar un algoritmo adecuado. Como ya vimos en el tema anterior, el proceso de ciclo de vida de una aplicaci\u00f3n es:</p> <ol> <li>An\u00e1lisis del problema</li> <li>Dise\u00f1o del algoritmo</li> <li>Codificaci\u00f3n</li> <li>Pruebas</li> <li>Mantenimiento</li> </ol> <p>El algoritmo debe ser independiente del lenguaje de programaci\u00f3n a utilizar (codificaci\u00f3n) y del ordenador en el que se ejecute. Para que un algoritmo resuelva el problema de forma eficiente debe tener las acciones bien definidas, as\u00ed como debe ser una secuencia finita de operaciones en un orden determinado y con una duraci\u00f3n limitada, es decir, que sea finito. Adem\u00e1s, debe tener el cuenta los factores de tiempo de ejecuci\u00f3n (entre dos algoritmos que resuelvan el mismo problema, es m\u00e1s eficiente el que menos tiempo tarda en ejecutarse) y los recursos en memoria (en este caso, ocurre lo mismo, ser\u00eda m\u00e1s eficiente el que menos memoria ocupa).</p>"},{"location":"tema_2/page-2/","title":"2 An\u00e1lisis de un problema","text":"<p>Para obtener el algoritmo m\u00e1s eficiente, en primer lugar ser\u00eda correspondiente tener un an\u00e1lisis exhaustivo del problema y de como poder solucionarlo. Es importante conocer el \u00e1rea del problema que se desea solucionar. Por ejemplo, si se desea crear una programa en el \u00e1mbito de la f\u00edsica, es conveniente tener conocimientos sobre f\u00edsica, o sobre el tema de f\u00edsica que trata el problema. Por lo que, se recomienda investigar en caso de que sea necesario para conocer mejor el problema a ejecutar.</p> <p>Veamos un ejemplo: Un cliente realiza un pedido a una f\u00e1brica. La f\u00e1brica realizar\u00e1 el pedido siempre y cuando el cliente sea solvente.</p> <ol> <li>Inicio del programa. El inicio del programa es una secuencia obligatoria en el algoritmo ya que indica cuando el algoritmo comienza.</li> <li>Leer pedido. Se lee el pedido que ha realizado el cliente.</li> <li>Examinar cliente. Comprobar si el cliente es solvente o no en los registros de la f\u00e1brica.</li> <li>Soluci\u00f3n. Si el cliente es solvente, se acepta el pedido, por el contrario, se rechaza.</li> <li>Fin del programa. El fin del programa tambi\u00e9n es un secuencia obligatorio al indicar el fin del algoritmo.</li> </ol> <p>En el an\u00e1lisis del problema anterior, se detalla como deber\u00eda funcionar el algoritmo, es decir, cu\u00e1l deber\u00eda ser su funci\u00f3n, para as\u00ed dise\u00f1ar correctamente el algoritmo.</p>"},{"location":"tema_2/page-3/","title":"3 Dise\u00f1o de algoritmos","text":""},{"location":"tema_2/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Una vez realizado el an\u00e1lisis del problema es conveniente realizar el dise\u00f1o del algoritmo, es decir, determinar su funcionamiento. Este dise\u00f1o debe ser independiente del lenguaje de programaci\u00f3n y del ordenador a usar.</p>"},{"location":"tema_2/page-3/#requisitos","title":"Requisitos","text":"<p>El principal objetivo del dise\u00f1o de algoritmo es analizar en detalle y comprender la naturaleza del problema. Esto es primordial para obtener una idea general y certera de lo que realmente hay que hacer o lo que se solicita. Otro punto a tener en cuenta es que los algoritmos son independientes tanto del lenguaje de programaci\u00f3n como del ordenador donde se ejecuta.</p> <p>A la hora de dise\u00f1ar algoritmos hay que cumplir con una serie de requisitos que son clave para no cometer errores:</p> <ul> <li>Deben tener un principio y un fin. La finitud es una caracter\u00edstica clave en los procesos matem\u00e1ticos, y como ya hemos visto en el concepto de algoritmo, una algoritmo deber ser finito, por eso es importante reflejar su comienzo y su fin.</li> <li>Deben ser precisos. Los algoritmos deben precisar el orden de realizaci\u00f3n de cada acci\u00f3n, de forma clara, sin ambig\u00fcedades.</li> <li>Secuencia clara. Esta sucesi\u00f3n de pasos debe tener un orden inalterable.</li> <li>Ser repetibles. Estos procesos se pueden repetir tantas veces como se desea, pero es necesario que devuelvan siempre los mismos resultados frente a la misma solicitud.</li> </ul> <p>Cuando una algoritmo es dise\u00f1ado se debe verificar que cumple con ciertos requisitos, complementarios a los anteriores:</p> <ul> <li>Validez. El algoritmo dise\u00f1ado responde exactamente a la solicitud concreta que se ha realizado, es decir, hace lo que se le pide que haga.</li> <li>Eficiencia. Debe solucionar el problema en el menor tiempo posible y con la cantidad de memoria m\u00e1s baja.</li> <li>Optimizaci\u00f3n. El algoritmo que se ha desarrollado es el mejor para resolver el problema que se desea.</li> </ul>"},{"location":"tema_2/page-3/#partes","title":"Partes","text":"<p>Un algoritmo se puede dividir en tres partes principales:</p> <p> Figura 1 - Dise\u00f1o de algoritmos</p> <ul> <li>Entrada. Conjunto de datos con los que el algoritmo procesa la informaci\u00f3n.</li> <li>Proceso. C\u00e1lculos necesarios para llegar a resolver el problema.</li> <li>Salidas. Es el resultado o resultados finales obtenidos despu\u00e9s de procesar c\u00e1lculos.</li> </ul> <p>Existen varias t\u00e9cnicas para realizar el dise\u00f1o de un algoritmo, entre ellas pseudoc\u00f3digo y diagramas de flujos. Adem\u00e1s, tambi\u00e9n existen diferentes t\u00e9cnicas para la estructura de los datos y su funcionamiento dentro del algoritmo, como los diagramas UML.</p>"},{"location":"tema_2/page-3/#diagramas-de-flujos","title":"Diagramas de flujos","text":"<p>Un diagrama de flujo es un diagrama que describe un proceso, sistema o algoritmo inform\u00e1tico. Se usan ampliamente en numerosos campos para documentar, estudiar, planificar, mejorar y comunicar procesos que suelen ser complejos en diagramas claros y f\u00e1ciles de comprender. Los diagramas de flujo emplean rect\u00e1ngulos, \u00f3valos, diamantes y otras numerosas figuras para definir el tipo de paso, junto con flechas conectoras que establecen el flujo y la secuencia. Pueden variar desde diagramas simples y dibujados a mano hasta diagramas exhaustivos creados por computadora que describen m\u00faltiples pasos y rutas. Si tomamos en cuenta todas las diversas figuras de los diagramas de flujo, son uno de los diagramas m\u00e1s comunes del mundo, usados por personas con y sin conocimiento t\u00e9cnico en una variedad de campos. Los diagramas de flujo a veces se denominan con nombres m\u00e1s especializados, como \"diagrama de flujo de procesos\", \"mapa de procesos\", \"diagrama de flujo funcional\", \"mapa de procesos de negocios\", \"notaci\u00f3n y modelado de procesos de negocio (BPMN)\" o \"diagrama de flujo de procesos (PFD)\". Est\u00e1n relacionados con otros diagramas populares, como los diagramas de flujo de datos (DFD) y los diagramas de actividad de lenguaje unificado de modelado (UML).</p> <p>El uso de los diagramas de flujo para documentar procesos de negocios se inici\u00f3 entre las d\u00e9cadas de 1920 y 1930. En 1921, los ingenieros industriales Frank y Lillian Gilbreth presentaron el \"diagrama de flujo de procesos\" en la Sociedad Americana de Ingenieros Mec\u00e1nicos (ASME \u2013 American Society of Mechanical Engineers).  A principios de la d\u00e9cada de 1930, el ingeniero industrial Allan H. Morgensen emple\u00f3 las herramientas de Gilbreth para presentar conferencias sobre c\u00f3mo aumentar la eficiencia en el trabajo a personas de negocios en su empresa.  En la d\u00e9cada de 1940, dos estudiantes de Morgensen, Art Spinanger y Ben S. Graham, difundieron los m\u00e9todos m\u00e1s ampliamente. Spinanger introdujo los m\u00e9todos de simplificaci\u00f3n del trabajo en Procter &amp; Gamble. Graham, director de Standard Register Industrial, adapt\u00f3 los diagramas de flujo de procesos al procesamiento de informaci\u00f3n. En 1947, ASME adopt\u00f3 un sistema de s\u00edmbolos para los diagramas de flujo de procesos derivado del trabajo original de Gilbreth.</p> <p>Adem\u00e1s, a fines de la d\u00e9cada de 1940, Herman Goldstine y John Van Neumann usaron diagramas de flujo para desarrollar programas inform\u00e1ticos. Pronto la creaci\u00f3n de diagramas se volvi\u00f3 cada vez m\u00e1s popular para los programas inform\u00e1ticos y algoritmos de todo tipo. Los diagramas de flujo se contin\u00faan usando para la programaci\u00f3n hoy en d\u00eda. Sin embargo, el pseudoc\u00f3digo, una combinaci\u00f3n de palabras y lenguaje de codificaci\u00f3n pensado para lectura humana, a menudo se usa para representar niveles m\u00e1s espec\u00edficos de detalle y para tener una versi\u00f3n m\u00e1s cercana al producto final.</p> <p>En Jap\u00f3n, Kaoru Ishikawa (1915-1989), una personalidad clave en las iniciativas de calidad en manufactura, afirm\u00f3 que los diagramas de flujo eran una de las herramientas fundamentales en el \u00e1rea de control de calidad, junto a otras complementarias, como el histograma, la ficha de control y el diagrama de causa-efecto, tambi\u00e9n llamado Diagrama de Ishikawa.</p> <p>Como una representaci\u00f3n visual del flujo de datos, los diagramas de flujo son \u00fatiles para escribir un programa o algoritmo y explic\u00e1rselo a otros o colaborar con otros en el mismo. Puedes usar un diagrama de flujo para explicar detalladamente la l\u00f3gica detr\u00e1s de un programa antes de empezar a codificar el proceso automatizado. Puede ayudar a organizar una perspectiva general y ofrecer una gu\u00eda cuando llega el momento de codificar. M\u00e1s espec\u00edficamente, los diagramas de flujo pueden:</p> <ul> <li>Demostrar c\u00f3mo el c\u00f3digo est\u00e1 organizado.</li> <li>Visualizar la ejecuci\u00f3n de un c\u00f3digo dentro de un programa.</li> <li>Mostrar la estructura de un sitio web o aplicaci\u00f3n.</li> <li>Comprender c\u00f3mo los usuarios navegan por un sitio web o programa.</li> </ul> <p>A menudo, los programadores pueden escribir un pseudoc\u00f3digo, una combinaci\u00f3n de lenguaje natural y lenguaje inform\u00e1tico que puede ser le\u00eddo por personas. Esto puede permitir m\u00e1s detalle que el diagrama de flujo y servir como reemplazo del diagrama de flujo o como el pr\u00f3ximo paso del c\u00f3digo mismo.</p> <p>Los diagramas relacionados que se emplean en el software inform\u00e1tico incluyen:</p> <ul> <li>Lenguaje unificado de modelado (UML): este es el lenguaje de prop\u00f3sito general usado en la ingenier\u00eda de software para el modelado.</li> <li>Diagramas Nassi-Shneiderman (NSD): usados para la programaci\u00f3n inform\u00e1tica estructurada. Llevan el nombre de sus creadores: Isaac Nassi y Ben Shneiderman, quienes los desarrollaron en 1972 en la Universidad Estatal de Nueva York en Stony Brook. Tambi\u00e9n se denominan \"estructogramas\".</li> <li>Diagramas DRAKON: DRAKON es un lenguaje de programaci\u00f3n visual de algoritmos empleado para crear diagramas de flujo.</li> </ul> <p>Distintos autores describen numerosos tipos de diagramas de flujo en diferentes t\u00e9rminos. Estas personas incluyen a expertos publicados, como Alan B. Sterneckert, Andrew Veronis, Marilyn Bohl y Mark A. Fryman.</p> <p>Sterneckert, en su libro escrito en 2003 Critical Incident Management, mencion\u00f3 cuatro tipos de diagramas de flujo populares, enmarcados en el concepto de controles de flujos en vez del flujo en s\u00ed mismo:</p> <ul> <li>Diagramas de flujo de documentos: Estos tienen el prop\u00f3sito de mostrar los controles existentes en el flujo de documentos a trav\u00e9s de los componentes de un sistema. El diagrama se lee de izquierda a derecha y detalla el flujo de documentos a trav\u00e9s de numerosas unidades de negocio.</li> <li>Diagramas de flujo de datos: Estos indican los controles que rigen los flujos de datos en un sistema. Los diagramas de flujo de datos se usan principalmente para mostrar los canales donde se transmiten los datos a trav\u00e9s del sistema en lugar de c\u00f3mo se controla el flujo.</li> <li>Diagramas de flujo de sistemas: Estos indican el flujo de datos que pasa hacia los componentes principales de un sistema, o a trav\u00e9s de ellos, tales como entrada de datos, programas, medios de almacenamiento, procesadores y redes de comunicaci\u00f3n.</li> <li>Diagramas de flujo de programas: Estos muestran los controles ubicados internamente en un programa dentro de un sistema.</li> </ul> <p>Veronis , en su libro escrito en 1978, Microprocessors: Design and Applications, describi\u00f3 tres tipos de diagramas de flujo en funci\u00f3n del alcance y nivel de detalle:</p> <ul> <li>Diagrama de flujo de sistema: identifica los dispositivos que se emplear\u00e1n.</li> <li>Diagrama de flujo general: vista general.</li> <li>Diagrama de flujo detallado: m\u00e1s detalles.</li> </ul> <p>Bohl, en su libro escrito en 1978 llamado A Guide for Programmers, enumera solo dos: Diagrama de flujo de sistemas y Diagrama de flujo de programas.</p> <p>But Fryman, en su libro escrito en 2001 titulado Quality and Process Improvement, distingui\u00f3 los tipos de muchas maneras, m\u00e1s desde una perspectiva orientada a los negocios que a la inform\u00e1tica:</p> <ul> <li>Diagrama de flujo de decisiones.</li> <li>Diagrama de flujo l\u00f3gico.</li> <li>Diagrama de flujo de sistemas.</li> <li>Diagrama de flujo de productos.</li> <li>Diagrama de flujo de procesos.</li> </ul> <p>Otros tipos de diagramas de flujo definidos por otros incluyen:</p> <ul> <li>**Diagrama de carrile**s, tambi\u00e9n conocido como \"diagrama de flujo de carriles\": detalla los roles de cada participante en procesos que se realizan entre equipos.</li> <li>Diagrama de flujo de trabajo: documenta flujos de trabajo, a menudo involucra tareas, documentos e informaci\u00f3n en las oficinas.</li> <li>Diagrama de cadena de procesos impulsada por eventos (EPC): documenta o planifica un proceso de negocio.</li> <li>Diagrama de flujo de lenguaje de descripci\u00f3n y especificaci\u00f3n (SDL): realiza un lluvia de ideas sobre los algoritmos inform\u00e1ticos mediante tres componentes b\u00e1sicos: proceso, bloqueo y definici\u00f3n de sistema.</li> </ul> <p>Para planificar el diagrama de flujo es importante:</p> <ol> <li>Definir tu prop\u00f3sito y alcance, es decir, qu\u00e9 se desea logar. Realiza una investigaci\u00f3n lo suficientemente detallada, pero lo suficientemente simple a la hora de crear tus diagramas para comunicarte con tu audiencia.</li> <li>Identificar las tareas en orden cronol\u00f3gico. Esto puede involucrar las conversaciones con los participantes, la observaci\u00f3n de un proceso o la revisi\u00f3n de cualquier documentaci\u00f3n existente. Puedes escribir los pasos en forma de notas o comenzar con un diagrama en versi\u00f3n borrador.</li> <li>Organizar por tipo y figura correspondiente, como procesos, decisiones, datos, entradas o salidas.</li> <li>Crear tu diagrama, ya sea dibuj\u00e1ndolo a mano o usando un programa como Lucidchart, u otros.</li> <li>Confirma tu diagrama de flujo, verificando todos los pasos con las personas que participan en el proceso. Observa el proceso para asegurarte de no dejar de lado nada que sea importante para tu prop\u00f3sito.</li> </ol> <p>Para indicar el principio y/o final de un algoritmo, se utiliza un rect\u00e1ngulo con bordes redondeados. Adem\u00e1s, la relaciones entre los elementos se indican a trav\u00e9s de la flechas.</p> <pre><code>flowchart TD\n    inicio([Inicio])\n    fin([Fin])\n\n    inicio--&gt;fin</code></pre> Figura 2 - Diagrama de flujos"},{"location":"tema_2/page-3/#pseudocodigo","title":"Pseudoc\u00f3digo","text":"<p>El pseudoc\u00f3digo es una forma de expresar los distintos pasos que va a realizar un programa, de la forma m\u00e1s parecida a un lenguaje de programaci\u00f3n. Su principal funci\u00f3n es la de representar por pasos la soluci\u00f3n a un problema o algoritmo, de la forma m\u00e1s detallada posible, utilizando un lenguaje cercano al de programaci\u00f3n. El pseudoc\u00f3digo no puede ejecutarse en un ordenador ya que entonces dejar\u00eda de ser pseudoc\u00f3digo, como su propio nombre indica, se trata de un c\u00f3digo falso (pseudo = falso), es un c\u00f3digo escrito para que lo entienda el ser humano y no la m\u00e1quina.</p> <p>Aprender a escribir pseudoc\u00f3digo para la resoluci\u00f3n de un problema permite hacer mucho m\u00e1s sencilla su programaci\u00f3n en un lenguaje convencional, por lo que si est\u00e1s interesado en comenzar tu formaci\u00f3n como programador y no tienes conocimientos previos, resulta muy recomendable y conveniente formarse en pseudoc\u00f3digo antes de empezar a estudiar cualquier lenguaje de programaci\u00f3n.</p> <p>Podemos considerar al pseudoc\u00f3digo como un lenguaje intermedio, que se encuentra en medio de nuestro propio lenguaje y el lenguaje de programaci\u00f3n que entiende el ordenador.</p> <p>Podemos entender el pseudoc\u00f3digo como los planos de una casa, que ayudan a definir como ser\u00eda la casa, mientras que el c\u00f3digo ser\u00eda la casa en s\u00ed.</p> <p>Su principal caracter\u00edstica es la de representar un m\u00e9todo que facilita la programaci\u00f3n y soluci\u00f3n del algoritmo del programa. Tambi\u00e9n se caracteriza por ser una forma de representaci\u00f3n, f\u00e1cil de utilizar y de manipular, que simplifica el paso del programa, al lenguaje de programaci\u00f3n.</p> <p>Otra caracter\u00edstica que tiene el pseudoc\u00f3digo es su independencia al c\u00f3digo en el que se va a escribir el programa, proporcionando un m\u00e9todo que facilita la posterior programaci\u00f3n y la resoluci\u00f3n del algoritmo del programa.</p> <p>Las tareas m\u00e1s complejas o repetitivas pueden representarse de forma m\u00e1s sencilla ya que est\u00e1 escrito en un lenguaje sencillo y no estructurado que permite una transici\u00f3n sencilla al lenguaje de programaci\u00f3n, m\u00e1s complejo y estructurado. Tener un programa escrito en pseudoc\u00f3digo facilita la tarea de programar en un lenguaje formal y mejora la calidad en la resoluci\u00f3n de problemas, adem\u00e1s de reducir el espacio necesario a la hora de desarrollar un problema.</p> <p>El pseudoc\u00f3digo llega donde el diagrama de flujo no lo hace. La soluci\u00f3n de un diagrama de flujo suele ser la ideal, pero no suele ser f\u00e1cil de implementar al crear el programa. El pseudoc\u00f3digo permite que el dise\u00f1o del programa y su implementaci\u00f3n sean muy parecidos.</p> <p>La curva de aprendizaje del pseudoc\u00f3digo es baja por lo que facilitan enormemente el aprendizaje de la programaci\u00f3n y la iniciaci\u00f3n a lenguajes de programaci\u00f3n m\u00e1s avanzados y complejos. Por lo tanto, se trata de una herramienta educativa interesante.</p> <p>El pseudoc\u00f3digo, al ser independiente del lenguaje de programaci\u00f3n, permite que su uso se pueda aplicar utilizando diferentes lenguajes y permitiendo que el programador no tenga que ser la misma persona que escribi\u00f3 el pseudoc\u00f3digo.</p> <p>Una de las desventajas del uso de pseudoc\u00f3digo es la falta de normas, que puede hacer que la l\u00f3gica de un programa, resulte complicada de ver por el programador que va a implementar este pseudoc\u00f3digo. Adem\u00e1s, en el caso de problemas muy extensos, puede llegar a ser dif\u00edcil de entender.</p> <p>Para escribir programas utilizando pseudoc\u00f3digo es necesario seguir unas pautas o normas de sintaxis para que puedan ser le\u00eddos y comprendidos por los programadores a la hora de pasarlos a un lenguaje de programaci\u00f3n. Es muy \u00fatil utilizar herramientas que faciliten esta escritura de pseudoc\u00f3digo, como es el caso de PSeInt, que asiste con un simple e intuitivo pseudolenguaje en espa\u00f1ol y que adem\u00e1s incluye un editor de diagramas de flujo.</p> <p>Un programa escrito en pseudoc\u00f3digo debe permitir instrucciones primitivas, de proceso, de control, de descripci\u00f3n y compuestas.</p> <p>El lenguaje que utilizamos para construir el pseudoc\u00f3digo no es est\u00e1ndar. Podemos a\u00f1adir o eliminar algunas reglas de sintaxis sin ning\u00fan problema. En la opci\u00f3n <code>Configurar-Opciones del Lenguaje (perfiles)</code>, en el programa PSeInt, podemos escoger las caracter\u00edsticas del pseudoc\u00f3digo que vamos a utilizar. Tenemos tres alternativas:</p> <ul> <li>Escoger un perfil que define un pseudoc\u00f3digo utilizado en distintos centros educativos y universidades.</li> <li>Perfil flexible: Est\u00e1 escogido por defecto, y no es muy exigente con las reglas que hay que utilizar para escribir el pseudoc\u00f3digo.</li> <li>Perfil estricto: Establece una reglas que hacen que el pseudoc\u00f3digo se parezca m\u00e1s a un lenguaje de programaci\u00f3n: se debe definir las variables y sus tipos, las instrucciones deben terminar en punto y coma,\u2026</li> </ul> <p>La estructura de un algoritmo es la siguientes:</p> <pre><code>Proceso SinTitulo\n    acci\u00f3n 1;\n    acci\u00f3n 2;\n    ...\n    acci\u00f3n n;\nFinProceso\n</code></pre> <ul> <li>Comienza con la palabra clave <code>Proceso</code> (o alternativamente <code>Algoritmo</code>, son sin\u00f3nimos) seguida del nombre del programa.</li> <li>Le sigue una secuencia (Estructura de control secuencial) de instrucciones. Una secuencia de instrucciones es una lista de una o m\u00e1s instrucciones y/o estructuras de control.</li> <li>Finaliza con la palabra <code>FinProceso</code> (o <code>FinAlgoritmo</code>).</li> <li>La identaci\u00f3n no es significativo, pero se recomienda para que el c\u00f3digo sea m\u00e1s legible.</li> <li>No se diferencia entre may\u00fasculas y min\u00fasculas. Preferible las min\u00fasculas, aunque a veces se a\u00f1aden autom\u00e1ticamente los nombres con la primera letra en may\u00fasculas.</li> </ul> <p>Se pueden introducir comentarios luego de una instrucci\u00f3n, o en l\u00edneas separadas, mediante el uso de la doble barra (<code>//</code>). Todo lo que precede a <code>//</code>, hasta el fin de la l\u00ednea, no ser\u00e1 tomado en cuenta al interpretar el algoritmo. Suelen usarse para realizar explicaciones del c\u00f3digo.</p>"},{"location":"tema_2/page-4/","title":"4 Primeros conceptos","text":""},{"location":"tema_2/page-4/#sentencia","title":"Sentencia","text":"<p>Una sentencia es la unidad m\u00ednima de ejecuci\u00f3n de un algoritmo. Un algoritmo se compone de conjunto de sentencias que acaban resolviendo un problema. En algunos lenguajes, las sentencias terminan con <code>;</code>, mientras que en otros no es obligatorio su uso. Algunos tipos de sentencias existentes son:</p> <ul> <li>Sentencias de declaraci\u00f3n: son las sentencias donde se declaran las variables a usar.</li> <li>Invocaci\u00f3n o llamadas a procedimientos</li> <li>Sentencias de control de flujo: alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</li> </ul> <p>En diagramas de flujo, una sentencia se representa con un rect\u00e1ngulo, mientras que en pseudoc\u00f3digo es una simple l\u00ednea:</p> Pseudoc\u00f3digoDiagrama de flujos <pre><code>INICIO\n    This is a sentence\nFIN\n</code></pre> <p> <pre><code>flowchart\n    id[This is a sentence]</code></pre> <p>Figura 3 - Sentencia </p>"},{"location":"tema_2/page-4/#expresiones","title":"Expresiones","text":"<p>Una expresi\u00f3n es una combinaci\u00f3n de operadores y operandos que se eval\u00faa gener\u00e1ndose un \u00fanico resultado de un tipo determinado.</p> <p>La diferencia entre las sentencias y los operadores es que las expresiones devuelven un valor y las sentencias no devuelven nada. Su uso en diagrama de flujos o en pseudoc\u00f3digo es el mismo:</p> Pseudoc\u00f3digoDiagrama de flujos <pre><code>INICIO\n    2 + 3\nFIN\n</code></pre> <p> <pre><code>flowchart\n    id[2 + 3]</code></pre> <p>Figura 4 - Expresiones </p> <p>Un conjunto de sentencias y/o expresiones se entienden como un bloque de c\u00f3digo.</p>"},{"location":"tema_2/page-4/#variables-y-constantes","title":"Variables y constantes","text":"<p>Las variables son contenedores que sirven para almacenar los datos que utiliza un algoritmo. Dicho m\u00e1s sencillamente, son nombres que asociamos a determinados datos. La realidad es que cada variable ocupa un espacio en la memoria RAM del ordenador para almacenar el dato al que se refiere, es decir, cuando utilizamos el nombre de la variable realmente estamos haciendo referencia a un dato que est\u00e1 en memoria.</p> <p>Las variables tienen un nombre (un identificador) que se escribe en min\u00fascula, y si consta de varias palabras, se utiliza la notaci\u00f3n lowerCamelCase. Ejemplo: <code>myFirstVariable</code>. Adem\u00e1s, deben cumplir lo siguiente:</p> <ul> <li>No deben comenzar con los caracteres guion bajo (<code>_</code>) o el signo de d\u00f3lar (<code>$</code>), aunque ambos se admiten en algunos lenguajes.</li> <li>Se admiten los n\u00fameros pero no como primer car\u00e1cter.</li> <li>Deben ser cortos pero significativos. La elecci\u00f3n de un nombre de variable debe ser mnem\u00f3nico, es decir, dise\u00f1ado para indicar al observador casual la intenci\u00f3n de su uso. Por ejemplo, si queremos usar una variable para almacenar una edad, la llamaremos edad.</li> <li>Se deben evitar los nombres de variables de un solo car\u00e1cter excepto para las variables temporales usar y tirar. Los nombres comunes de las variables temporales son <code>i</code>, <code>j</code>, <code>k</code>, <code>m</code>, y <code>n</code> para enteros; <code>c</code>, <code>d</code>, y <code>e</code> para los caracteres.</li> </ul>"},{"location":"tema_2/page-4/#declaracion-definicion-asignacion-e-inicializacion","title":"Declaraci\u00f3n, definici\u00f3n, asignaci\u00f3n e inicializaci\u00f3n","text":"<p>La asignaci\u00f3n de una variable es darle valor a dicha variable en cualquier momento del algoritmo. En pseudoc\u00f3digo, se representa con el nombre de la variable y una flecha hacia la derecha y su valor, mientras que en el diagrama de flujo se representa dentro de una sentencia de la misma forma que en pseudoc\u00f3digo.</p> Pseudoc\u00f3digoDiagrama de flujos <pre><code>INICIO\n    variable \u2190 value\nFIN\n</code></pre> <p> <pre><code>flowchart\n    id[variable \u2190 value]</code></pre> <p>Figura 5 - Asignaci\u00f3n </p> <p>La inicializaci\u00f3n de una variable es el primer valor que se le otorga a una variable, es decir, es su primera asignaci\u00f3n.</p> <p>La definici\u00f3n de variables es la parte del algoritmo donde se indican las variables a usar, algunas pueden ser inicializadas y otras no. En pseudoc\u00f3digo y en diagramas de flujo es recomendable implementar un bloque que comience con la palabra var con todas las variables a usar.</p> Pseudoc\u00f3digoDiagrama de flujos <pre><code>INICIO\n    var\n        variable\n        otra \u2190 10 // Variable asignada\nFIN\n</code></pre> <p> <pre><code>flowchart\n     id[\"`var\n        variable\n        otra \u2190 10 // Variable asignada`\"]</code></pre> <p>Figura 6 - Definici\u00f3n </p> <p>Por \u00faltimo, una declaraci\u00f3n es la definici\u00f3n de la variable con su primer valor. Por ejemplo, en la variable <code>otra</code> del ejemplo anterior se est\u00e1 declarando la variable porque se define y se inicializa.</p>"},{"location":"tema_2/page-4/#constantes","title":"Constantes","text":"<p>Una constante es un valor que no puede ser modificado durante la ejecuci\u00f3n de un programa, \u00fanicamente puede ser le\u00eddo.</p> <p>Para declarar una constante, se hace con un bloque de declaraciones, donde se indica la palabra <code>const</code>. El nombre de las constantes usualmente suelen ser escritas en may\u00fasculas y pueden contener guiones bajos <code>_</code> como separaci\u00f3n de palabras, como por ejemplo <code>MAX_STUDENTS</code>.</p> <p>Cuando un mismo valor se utilice en varias partes del c\u00f3digo, entonces hay que declararlo como una constante ya que si en alg\u00fan momento de la vida de la aplicaci\u00f3n, ese valor var\u00eda, solamente hay que cambiar el valor de la constante y no estar cambi\u00e1ndolo en todos los sitios del c\u00f3digo donde aparezca.</p> Pseudoc\u00f3digoDiagrama de flujos <pre><code>INICIO\n    const\n       MAX_STUDENTS \u2190 10 \nFIN\n</code></pre> <p> <pre><code>flowchart\n     id[\"`const \n            MAX_STUDENTS \u2190 10`\"]</code></pre> <p>Figura 7 - Definici\u00f3n </p>"},{"location":"tema_2/page-5/","title":"5 Tipos de datos","text":""},{"location":"tema_2/page-5/#introduccion","title":"Introducci\u00f3n","text":"<p>Los datos son los objetos con los que opera un ordenador. El dise\u00f1o de la estructura de datos es tan importante como el dise\u00f1o del algoritmo.</p> <p>Podemos clasificar los tipos de datos en dos grandes grupos, datos simples y datos estructurados. Como datos simple, encontramos num\u00e9ricos (entero y real), l\u00f3gico y car\u00e1cter. Los datos simples se consideran como las unidades m\u00ednimas de datos, mientras que los estructurados son datos m\u00e1s complejos compuestos por los datos simples y otros estructurados.</p> <p>Al declarar o definir una variable es importante indicar su tipo, con el siguiente formato: <code>tipo: variable</code>. Veamos un ejemplo:</p> Pseudoc\u00f3digoDiagrama de flujos <pre><code>INICIO\n    var\n       entero: n\u00famero\nFIN\n</code></pre> <p> <pre><code>flowchart\n     id[\"`var \n            entero: n\u00famero`\"]</code></pre> <p>Figura 8 - Tipos de datos </p>"},{"location":"tema_2/page-5/#datos-numericos","title":"Datos num\u00e9ricos","text":"<p>Los datos num\u00e9ricos abarcan los n\u00fameros, diferenciando entre n\u00fameros enteros y reales. Como conjunto de enteros, como norma general, se entiende el rango desde \\(-32768\\) hasta \\(32768\\).</p>"},{"location":"tema_2/page-5/#datos-logicos","title":"Datos l\u00f3gicos","text":"<p>Los datos l\u00f3gicos son los tipos de datos que abarcan el valor verdadero o falso.</p>"},{"location":"tema_2/page-5/#datos-tipo-caracter","title":"Datos tipo car\u00e1cter","text":"<p>Los datos de tipo car\u00e1cter abarcan cualquier tipo de car\u00e1cter, se expresan entre comillas simples <code>''</code>. Podemos clasificar los caracteres en:</p> <ul> <li>Caracteres alfab\u00e9ticos. Conjunto de letras, tanto en may\u00fasculas y min\u00fasculas (A, B, C,..., Z - a, b, c, ..., c).</li> <li>Caracteres num\u00e9ricos. Representan n\u00fameros como caracteres (1, 2, ..., 9).</li> <li>Caracteres especiales, como, <code>&amp;</code>, <code>$</code>, <code>%</code>, <code>.</code>, etc.</li> <li>Caracteres UNICODE, como \u23fa, \u23fb, \u23ea, etc.</li> </ul>"},{"location":"tema_2/page-5/#datos-estructurados","title":"Datos estructurados","text":"<p>Los tipos de datos estructurados son aquellos datos que est\u00e1n formados por tipos de datos simples u otros tipos de datos estructurados.</p> <p>Uno de los m\u00e1s comunes es el tipo cadena, que por su definici\u00f3n, se considera un conjunto de caracteres (tipo de datos simples). Los valores del tipo cadena se escriben entre comillas dobles <code>\"\"</code>. Por ejemplo, <code>\"hola\"</code>.</p>"},{"location":"tema_2/page-6/","title":"6 Operadores","text":""},{"location":"tema_2/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Como ya hemos visto, una expresi\u00f3n es un tipo de sentencia que es evaluada devolviendo un resultado. Para resolver una expresi\u00f3n, \u00e9sta debe contener alg\u00fan tipo de operador.</p> <p>Un operador lleva a cabo operaciones sobre uno (operador unario), dos (operador binario) o tres (operador ternario) datos u operandos de tipo primitivo devolviendo un valor determinado tambi\u00e9n de un tipo primitivo. El tipo de valor devuelto tras la evaluaci\u00f3n depende del operador y del tipo de los operandos. Por ejemplo, los operadores aritm\u00e9ticos trabajan con operandos num\u00e9ricos, llevan a cabo operaciones aritm\u00e9ticas b\u00e1sicas y devuelven el valor num\u00e9rico correspondiente.</p>"},{"location":"tema_2/page-6/#operacion-de-asignacion","title":"Operaci\u00f3n de asignaci\u00f3n","text":"<p>La operaci\u00f3n de asignaci\u00f3n <code>\u2190</code> es un operador binario que es utilizado para darle valor a una variable. Funciona de la siguiente manera: en primer lugar, se obtiene el valor de la derecha (se eval\u00faa en caso de que sea una expresi\u00f3n) y se almacena dicho valor en la variable cuyo identificador est\u00e1 a la derecha del operador. Veamos un ejemplo, en pseudoc\u00f3digo:</p> <pre><code>var\n    entero: x, y\n\nx \u2190 10 // (1)!\ny \u2190 x + 2 // (2)!\n</code></pre> <ol> <li>En el primer caso, se obtiene el valor 10 y se a\u00f1ade a la variable <code>x</code>.</li> <li>En este caso, se eval\u00faa la expresi\u00f3n <code>x + 2</code> y su resultado (<code>12</code>) se a\u00f1ade a la variable <code>y</code>.</li> </ol>"},{"location":"tema_2/page-6/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Como operadores aritm\u00e9ticos, podemos encontrar de forma general:</p> Operador Descripci\u00f3n Tipo Ejemplo -/+ Signo Unario <code>-4</code><code>+5</code> + Suma Binario <code>5 + 5 = 10</code> - Resta Binario <code>5 - 5 = 0</code> * Multiplicaci\u00f3n Binario <code>5 * 5 = 25</code> / Divisi\u00f3n real Binario <code>5 / 5 = 1</code> div Divisi\u00f3n entera Binario <code>5 div 5 = 1</code> % M\u00f3dulo (resto) Binario <code>5 % 5 = 0</code>"},{"location":"tema_2/page-6/#operador-de-concatenacion","title":"Operador de concatenaci\u00f3n","text":"<p>El operador de concatenaci\u00f3n es un operador binario id\u00e9ntico a la suma. Su funci\u00f3n es unir en una sola cadena uno o m\u00e1s valores. Para que esto funcione uno de los valores debe ser una cadena. Por ejemplo, si se tiene las cadenas <code>\"Hola\"</code>, <code>\"mundo\"</code> y el n\u00famero <code>2</code>, se puede unir con el operador <code>+</code>: <code>\"Hola\" + \" \" + \"mundo\" + \" y el n\u00famero \" + 2</code>, obteniendo como resultado <code>\"Hola mundo y el n\u00famero 2\"</code> </p>"},{"location":"tema_2/page-6/#operadores-relaciones","title":"Operadores relaciones","text":"<p>Los operadores relacionales son operadores binarios que comparan valores del mismo tipo devolviendo un valor l\u00f3gico (verdadero o falso). Podemos encontrar:</p> Operador Descripci\u00f3n Ejemplo &lt; Menor que <code>2 &lt; 4</code> (Verdadero) &gt; Mayor que <code>2 &gt; 4</code> (Falso) = Igual que <code>5 = 5</code> (Verdadero) \u2a7d Menor o igual que <code>5 \u2a7d 10</code> (Verdadero) \uf0b3 Mayor o igual que <code>5 \uf0b3 5</code> (Verdadero) \u2260 Distinto que <code>5 \u2260 5</code> (Falso) <p>Cuando se comparan datos de tipo num\u00e9ricos sigue la l\u00f3gica matem\u00e1tica. Mientras que, si se comparan los valores l\u00f3gicos, se considera que <code>falso</code> es menor que <code>verdadero</code>, por ejemplo <code>falso &gt; verdadero</code> devolver\u00eda <code>falso</code>.</p> <p>Al comparar caracteres se ordenan de la siguiente manera:</p> <ul> <li>Los caracteres num\u00e9ricos son menores que los caracteres alfab\u00e9ticos. Entre ellos, se respetan el orden n\u00famero, es decir, <code>0 &lt; 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9</code>.</li> <li>Los caracteres alfab\u00e9ticos en may\u00fasculas son menores que los min\u00fasculas y entre ellos se respetan el orden alfab\u00e9tico: <code>A &lt; B &lt; ... &lt; Z</code>.</li> </ul> <p>Esto sucede gracias a su representaci\u00f3n en el c\u00f3digo ASCII. El c\u00f3digo ASCII (American Standard Code for Information Interchange) es un sistema de codificaci\u00f3n que asigna un valor num\u00e9rico \u00fanico a diferentes caracteres utilizados en la comunicaci\u00f3n electr\u00f3nica. Fue desarrollado en la d\u00e9cada de 1960 como un est\u00e1ndar para la transferencia de datos entre diferentes dispositivos inform\u00e1ticos.</p> <p>El c\u00f3digo ASCII utiliza 7 bits para representar 128 caracteres diferentes. Estos caracteres incluyen letras may\u00fasculas y min\u00fasculas, d\u00edgitos num\u00e9ricos, signos de puntuaci\u00f3n, s\u00edmbolos matem\u00e1ticos y una serie de caracteres de control utilizados para el formateo de texto y el control de dispositivos. Los primeros 32 caracteres son caracteres de control no imprimibles, como el retorno de carro (enter, o salto de l\u00ednea) y el avance de l\u00ednea.</p> <p>Este c\u00f3digo ASCII se convirti\u00f3 en un est\u00e1ndar ampliamente utilizado en la industria inform\u00e1tica y sent\u00f3 las bases para la comunicaci\u00f3n entre diferentes sistemas inform\u00e1ticos. Sin embargo, a medida que la tecnolog\u00eda avanz\u00f3, el sistema ASCII se qued\u00f3 corto para representar todos los caracteres necesarios en diferentes idiomas y alfabetos. Esto llev\u00f3 al desarrollo de codificaciones m\u00e1s amplias, como el est\u00e1ndar Unicode, que utiliza m\u00e1s bits para representar una gama m\u00e1s amplia de caracteres.</p> <p>A pesar de sus limitaciones, el c\u00f3digo ASCII sigue siendo relevante y se utiliza ampliamente en la programaci\u00f3n y la comunicaci\u00f3n de datos. Comprender c\u00f3mo se asignan los caracteres a valores num\u00e9ricos en el c\u00f3digo ASCII es fundamental para trabajar con datos en entornos inform\u00e1ticos.</p> <p>Por lo que, cada car\u00e1cter tiene una representaci\u00f3n num\u00e9rica gracias al c\u00f3digo ASCII, de manera que si queremos comparar un car\u00e1cter especial con alguno car\u00e1cter alfanum\u00e9rico u otro especial, se deber\u00eda comparar su representaci\u00f3n num\u00e9rica en el c\u00f3digo ASCII. Veamos un ejemplo, el car\u00e1cter <code>A</code> es representado por el n\u00famero 65, mientras que el car\u00e1cter <code>%</code> es representado por el 37, por lo que al ser \\(37 &lt; 65\\), podemos concluir que <code>'%' &lt; 'A'</code>.</p>"},{"location":"tema_2/page-6/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Los operadores l\u00f3gicos son operadores cuyo factores son expresiones o valores l\u00f3gicos, devolviendo tambi\u00e9n un valor l\u00f3gico. Entre ellos encontramos:</p> <ul> <li>Negaci\u00f3n NO. Sirve para negar un valor l\u00f3gico, devolviendo el valor contrario. Por ejemplo si evaluamos <code>NO falso</code> retornar\u00e1 <code>verdadero</code>.</li> <li>Suma l\u00f3gica u operador y (y). Es la conjunci\u00f3n de dos valores l\u00f3gicos (\\(\\land\\)), devolviendo <code>verdadero</code> si y solo si ambos valores son verdaderos.</li> <li>Producto l\u00f3gico u operador o (\u00f3). Es la disyunci\u00f3n de dos valores l\u00f3gicos (\\(\\lor\\)), devolviendo <code>verdadero</code> si alguno de los dos valores, o ambos, son verdaderos.</li> </ul> <p>Veamos las tablas de verdad, dado dos valores l\u00f3gicos <code>p</code> y <code>q</code> en cada uno de los casos:</p> Negaci\u00f3nSuma l\u00f3gicaProducto l\u00f3gico p no p verdadero falso falso verdadero p q p y q verdadero verdadero verdadero verdadero falso falso falso verdadero falso falso falso falso p q p \u00f3 q verdadero verdadero verdadero verdadero falso verdadero falso verdadero verdadero falso falso falso <p>En algunos lenguajes existe el concepto de corto circuito. El corto circuito es una t\u00e9cnica en la cual no comprueba el seg\u00fan valor de la expresi\u00f3n si ya con el primero sabe con certeza el valor que devuelve. Por ejemplo, supongamos que tenemos dos expresi\u00f3n l\u00f3gicas, <code>p</code> y <code>q</code>, siendo <code>p = falsa</code> y <code>q = verdadera</code>, se quiere evaluar la expresi\u00f3n <code>p y q</code>, al ser <code>p</code> falsa sabemos de antemano que la expresi\u00f3n <code>p y q</code> ser\u00e1 falsa tambi\u00e9n por que para que sea verdadera ambas deben de serlo, y como la primera ya no lo es conocemos de antemano que devolver\u00e1 falso. En este caso, se puede implementar la t\u00e9cnica de corto circuito evaluando la primera expresi\u00f3n (<code>p</code>) ver que se obtiene falso y directamente devolver falso sin necesidad de devolver verdadero.</p>"},{"location":"tema_2/page-6/#operador-condicional","title":"Operador condicional","text":"<p>El operador condicional es un operador ternario permite devolver valores en funci\u00f3n de una expresi\u00f3n l\u00f3gica. Su sintaxis es la siguiente: \\(expresi\u00f3nL\u00f3gica \\ ? \\ expresi\u00f3n_1 : expresi\u00f3n_2\\)</p> <p>Si el resultado de evaluar la expresi\u00f3n l\u00f3gica es verdadera devuelve el valor de la primera expresi\u00f3n, y en caso contrario, devuelve el valor de la segunda expresi\u00f3n. Por ejemplo:</p> <pre><code>var\n    cadena: resultado\n    entero: edad\n\nedad \u2190 10\n\nresultado \u2190 edad &gt; 18 ? \"Eres mayor de edad\" : \"No eres mayor de edad\"\n</code></pre> <p>El valor de la variable resultado ser\u00eda <code>No eres mayor de edad</code> debido a que la variable <code>edad</code> tiene como valor 10.</p>"},{"location":"tema_2/page-6/#precedencia-de-los-operadores","title":"Precedencia de los operadores","text":"<p>A veces hay expresiones con operadores que resultan confusas. Por ejemplo: $8 + 4 / 2 $. Es dif\u00edcil saber el resultado. \u00bfCu\u00e1l es? \u00bfseis o diez? La respuesta es 10 y la raz\u00f3n es que el operador de divisi\u00f3n siempre precede en el orden de ejecuci\u00f3n al de la suma. Es decir, siempre se ejecuta antes la divisi\u00f3n que la suma. Siempre se pueden usar par\u00e9ntesis para forzar el orden deseado: \\((8+4)/2\\). hora no hay duda, el resultado es seis.</p> <p>\u00bfC\u00f3mo podemos saber en qu\u00e9 orden se van a ejecutar los operadores en una expresi\u00f3n en Java? Pues se ejecutan en funci\u00f3n de una prioridad, es decir, primero se ejecuta el que tenga m\u00e1s prioridad. La siguiente tabla muestra todos los operadores Java ordenados de mayor a menor prioridad. La primera l\u00ednea de la tabla contiene los operadores de mayor prioridad y la \u00faltima los de menor prioridad. Los operadores que aparecen en la misma l\u00ednea tienen la misma prioridad.</p> Nivel Operador Descripci\u00f3n Asociatividad 1 [].() acceso elementos arrayacceso miembros objetospar\u00e9ntesis de izquierda a derecha 2 nuevo creaci\u00f3n objetos de derecha a izquierda 3 +-NO unario m\u00e1sunario menosunario l\u00f3gico NO de derecha a izquierda 4 */, div% multiplicaci\u00f3ndivisi\u00f3nm\u00f3dulo de izquierda a derecha 5 +-+ sumarestaconcatenaci\u00f3n cadenas de izquierda a derecha 6 &lt;\u2a7d&gt;\uf0b3 relacionales no asociativos 7 =  \u2260 igualdistinto de izquierda a derecha 8 y AND de izquierda a derecha 9 \u00f3 OR de izquierda a derecha 10 ?: Condicional de derecha a izquierda 11 \u2190 Asignaci\u00f3n de derecha a izquierda <p>Cuando una expresi\u00f3n tenga dos operadores con la misma prioridad, la expresi\u00f3n se eval\u00faa seg\u00fan su asociatividad. Por ejemplo: \\(9 / 3 * 3\\). En este caso, la multiplicaci\u00f3n y la divisi\u00f3n tienen la misma prioridad y su asociatividad es de izquierda a derecha por lo que se realiza primero la operaci\u00f3n que est\u00e9 m\u00e1s a la izquierda, que en este caso es la divisi\u00f3n. El resultado por lo tanto es nueve. Si se desea que se haga primero la multiplicaci\u00f3n, habr\u00eda que utilizar un par\u00e9ntesis: \\(9 / (3 * 3)\\). En este caso, el resultado ser\u00eda 1.</p> <p>Otro ejemplo \\(x \\xleftarrow{} y \\xleftarrow{} z \\xleftarrow{} 17\\). Como la asociatividad de la asignaci\u00f3n es de derecha a izquierda, primero se asigna el valor 17 a <code>z</code>, luego <code>a</code> y y por \u00faltimo a <code>x</code>.Esto se puede realizar porque el operador de asignaci\u00f3n devuelve el valor asignado.</p> <p>Algunos operadores son no asociativos, por ejemplo, la expresi\u00f3n \\(x \\le y \\le z\\) es inv\u00e1lida ya que el valor devuelto por estos operadores es de un tipo diferente (booleano) al de los operandos que necesita (num\u00e9rico o car\u00e1cter).</p> <p>En algunos lenguajes de programaci\u00f3n, se utilizan m\u00e1s operadores, por lo que es conveniente conocer la precedencia de los mismos.</p>"},{"location":"tema_2/page-7/","title":"7 Operaciones de entrada y salida","text":""},{"location":"tema_2/page-7/#introduccion","title":"Introducci\u00f3n","text":"<p>Las operaciones de entrada y salida son operaciones b\u00e1sicas para cualquier lenguaje de programaci\u00f3n. En cualquier programa, se puede requerir que el usuario introduzca un valor y que dicho valor se muestre posteriormente por pantalla.</p> <p>El uso de ambos m\u00e9todos depende del lenguaje del programaci\u00f3n a usar. Sin embargo, en pseudoc\u00f3digo y en los diagramas de flujos, existe una generalizaci\u00f3n</p>"},{"location":"tema_2/page-7/#operacion-de-entrada","title":"Operaci\u00f3n de entrada","text":"<p>Una operaci\u00f3n de entrada es aquella operaci\u00f3n que solicita que los datos sean introducidos por el usuario, normalmente, a trav\u00e9s del teclado.</p> <p>En pseudoc\u00f3digo se utiliza la expresi\u00f3n <code>leer(var)</code> siendo <code>var</code> la variable cuyo valor se desea leer. En diagramas de flujo, se utiliza un romboide y dentro se escribe <code>leer(var)</code> veamos un ejemplo:</p> Pseudoc\u00f3digoDiagrama de flujo <pre><code>var\n    entero: edad\n\nleer(edad)\n</code></pre> <p><pre><code>flowchart TD\n    inicio([Inicio])\n    fin([Fin])\n\n    process1[\"`var\n        entero: edad\n    `\"]\n\n    es1[/\"leer(edad)\"/]\n\n    inicio--&gt;process1\n    process1--&gt;es1\n    es1--&gt;fin</code></pre> Figura 8 - Operaci\u00f3n de entrada</p>"},{"location":"tema_2/page-7/#operacion-de-salida","title":"Operaci\u00f3n de salida","text":"<p>Una operaci\u00f3n de salida es aquella operaci\u00f3n en la cu\u00e1l se muestra la salida, normalmente, la consola.</p> <p>En pseudoc\u00f3digo se utiliza la expresi\u00f3n <code>escribir(msg)</code> siendo <code>msg</code> el mensaje a mostrar. En diagramas de flujo, tambi\u00e9n se utiliza un romboide y dentro se escribe <code>escribir(var)</code> veamos un ejemplo:</p> Pseudoc\u00f3digoDiagrama de flujo <pre><code>var\n    entero: edad\n\nedad \u2190 10\n\nescribir(\"La edad es \" + 10)\n</code></pre> <p><pre><code>flowchart TD\n    inicio([Inicio])\n    fin([Fin])\n\n    process1[\"`var\n        entero: edad\n\n        edad \u2190 10\n    `\"]\n\n    es1[/\"escribir(\"La edad es \" + 10)\"/]\n\n    inicio--&gt;process1\n    process1--&gt;es1\n    es1--&gt;fin</code></pre> Figura 9 - Operaci\u00f3n de salida</p>"},{"location":"tema_2/page-7/#principal","title":"Principal","text":"<p>La mayor\u00eda de los lenguajes utilizan una funci\u00f3n <code>main</code> con el c\u00f3digo que debe ejecutarse. En otros, esta funci\u00f3n es innecesaria y se omite. En pseudoc\u00f3digo se debe indicar el inicio de esta funci\u00f3n como <code>InicioMain</code> o <code>InicioPrincipio</code> para indicar el comienzo del c\u00f3digo a ejecutar. En diagramas de flujo, esto se omite.</p> <pre><code>Inicio\nInicioPrincipal\n\n    var\n        entero: edad\n        cadena: mensaje\n\n    escribir(\"Introduce la edad: \")\n    leer(edad)\n\n    mensaje \u2190 edad ? \"Eres mayor de edad\" : \"No eres mayor de edad\"\n\n    escribir(mensaje)\n\nFinPrincipal\nFin\n</code></pre>"},{"location":"tema_3/page-1/","title":"1 Programaci\u00f3n estructurada","text":""},{"location":"tema_3/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Los programas se construyen para procesar datos, manipul\u00e1ndolos de formas diferentes dependiendo de los valores que tengan. Los lenguajes de programaci\u00f3n deben proveer estructuras que les permitan a los programadores controlar el flujo de ejecuci\u00f3n de un programa dependiendo de los datos que procesan. Para ello, se incluyen las sentencias de control de flujo, que alteran el flujo de ejecuci\u00f3n para tomar decisiones o repetir sentencias.</p> <p>La programaci\u00f3n estructurada es un paradigma de programaci\u00f3n orientado a mejorar la claridad, calidad y tiempo de desarrollo de un programa de computadora recurriendo \u00fanicamente a subrutinas y tres estructuras b\u00e1sicas: secuencia, sentencias condicionales y bucles.</p> <p>Una subrutina o subprograma, como idea general, se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica. Por ejemplo, los m\u00e9todos en Java.</p>"},{"location":"tema_3/page-1/#estructura-secuencial","title":"Estructura secuencial","text":"<p>La ejecuci\u00f3n secuencial es el m\u00e1s b\u00e1sico de los mecanismos de control de flujo y consiste en la ejecuci\u00f3n de instrucciones en el orden en que se encuentran en el c\u00f3digo fuente del programa.</p> <p>Hasta ahora las instrucciones que hemos visto, son instrucciones que se ejecutan secuencialmente; es decir, podemos saber lo que hace el programa leyendo las l\u00edneas de izquierda a derecha y de arriba abajo.</p> <p>En pseudoc\u00f3digo se va escribiendo l\u00ednea a l\u00ednea:</p> <pre><code>Instrucci\u00f3n1\nInstrucci\u00f3n2\nInstrucci\u00f3n3\n...\nInstrucci\u00f3nN\n</code></pre> <p>En diagramas de flujo cada secuencia se escribe como un proceso:</p> <pre><code>flowchart\n\n    instrucci\u00f3n1[\"Instrucci\u00f3n 1\"]\n    instrucci\u00f3n2[\"Instrucci\u00f3n 2\"]\n    instrucci\u00f3n3[\"Instrucci\u00f3n 3\"]\n    instrucci\u00f3nP[\"...\"]\n    instrucci\u00f3nN[\"Instrucci\u00f3n N\"]\n\n    instrucci\u00f3n1--&gt;instrucci\u00f3n2\n    instrucci\u00f3n2--&gt;instrucci\u00f3n3\n    instrucci\u00f3n3--&gt;instrucci\u00f3nP\n    instrucci\u00f3nP--&gt;instrucci\u00f3nN</code></pre> Figura 1 - Estructura secuencial"},{"location":"tema_3/page-2/","title":"2 Condicionales","text":""},{"location":"tema_3/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>La sentencia condicional consiste en ejecutar instrucciones diferentes dependiendo del resultado de evaluar una expresi\u00f3n l\u00f3gica. Una expresi\u00f3n l\u00f3gica es cualquier tipo de expresi\u00f3n que devuelva un resultado booleano. Las expresiones l\u00f3gicas se construyen por medio de variables booleanas o bien a trav\u00e9s de los operadores relacionales y/o l\u00f3gicos.</p>"},{"location":"tema_3/page-2/#condicional-simple","title":"Condicional simple","text":"<p>Se ejecutan una serie de instrucciones en el caso de que la expresi\u00f3n l\u00f3gica sea verdadera. Su estructura es:</p> Diagramas de flujoPseudoc\u00f3digo <pre><code>flowchart\n    id1{condici\u00f3n}\n    true[\"Verdadero\"]\n    otra[\"Otro\"]\n\n    id1 --verdadero --&gt; true\n    true --&gt;otra\n    id1 --falso --&gt; otra</code></pre> <p>Figura 2 - Condicional simple </p> <pre><code>Si condici\u00f3n:\n    Instrucci\u00f3nVerdadera\nFin_Si\n</code></pre>"},{"location":"tema_3/page-2/#condicional-doble","title":"Condicional doble","text":"<p>Es igual que la anterior, s\u00f3lo que se a\u00f1ade un apartado  que contiene instrucciones que se ejecutar\u00e1n si la expresi\u00f3n evaluada es falsa. Su estructura es:</p> Diagramas de flujoPseudoc\u00f3digo <pre><code>flowchart\n    id1{condici\u00f3n}\n    true[\"Verdadero\"]\n    false[\"Falso\"]\n    otra[\"Otro\"]\n\n    id1 --verdadero --&gt; true\n    true --&gt;otra\n    id1 --falso --&gt;false\n    false --&gt; otra</code></pre> <p>Figura 3 - Condicional doble </p> <pre><code>Si condici\u00f3n:\n    Instrucci\u00f3nVerdadera\nSi no:\n    Instrucci\u00f3nFalsa\nFin_Si\n</code></pre>"},{"location":"tema_3/page-2/#condicional-multiple","title":"Condicional M\u00faltiple","text":""},{"location":"tema_3/page-2/#anidacion","title":"Anidaci\u00f3n","text":"<p>Dentro de una sentencia if se puede colocar otra sentencia if. A esto se le llama anidaci\u00f3n y permite crear programas donde se valoren expresiones complejas. La nueva sentencia puede ir tanto en la parte if como en la parte else.</p> <p>Las anidaciones se utilizan much\u00edsimo al programar. Solo hay que tener en cuenta que siempre se debe cerrar primero el \u00faltimo if que se abri\u00f3. Es muy importante tambi\u00e9n tabular el c\u00f3digo correctamente para que las anidaciones sean legibles.</p> Diagramas de flujoPseudoc\u00f3digo <pre><code>flowchart\n    condicion1{condici\u00f3n1}\n    condicion2{condici\u00f3n2}\n    condicionN{condici\u00f3nN}\n    v1[\"Verdadero1\"]\n    v2[\"Verdadero2\"]\n\n\n    condicion1 --verdadero --&gt;v1\n    condicion1 --falso --&gt; condicion2\n    condicion2 --verdadero --&gt;v2\n    condicion2 --falso --&gt;condicionN</code></pre> <p>Figura 3 - Condicional doble </p> <pre><code>Si condici\u00f3n1:\n    Instrucci\u00f3nVerdadera\nSi no:\n    si condici\u00f3n2:\n        Instrucci\u00f3nVerdadera\n    si no:\n        Instrucci\u00f3nFalsa\n    fin_si\nFin_Si\n</code></pre> <p>En pseudoc\u00f3digo una anidaci\u00f3n de ese tipo es de dif\u00edcil lectura, por lo se recomienda usar en el algoritmo una estructura similar a la siguiente:</p> <pre><code>Si condici\u00f3n1:\n    Instrucci\u00f3nVerdadera\nSi no si condici\u00f3n2:\n    Instrucci\u00f3n2Verdadera\nSi no:\n    Instrucci\u00f3nFalsa\nFin_Si\n</code></pre>"},{"location":"tema_3/page-2/#seleccion-unica","title":"Selecci\u00f3n \u00fanica","text":"<p>Existe otra estructura similar denominada <code>seg\u00fan sea</code>, que dada una expresi\u00f3n, dependiendo del valor de la expresi\u00f3n realizar\u00e1 una condici\u00f3n u otra. Su estructura es la siguiente:</p> Diagramas de flujoPseudoc\u00f3digo <pre><code>flowchart\n    condicion1{condici\u00f3n1}\n    i1[\"instrucci\u00f3n1\"]\n    i2[\"instrucci\u00f3n3\"]\n    iN[\"instrucci\u00f3nN\"]\n    otro[\"Instrucci\u00f3n por defecto\"]\n\n\n    condicion1 --1--&gt;i1\n    condicion1 --2--&gt;i2\n    condicion1 --N--&gt;iN\n    condicion1 --en otro caso--&gt;otro</code></pre> <p>Figura 4 - Seg\u00fan sea </p> <pre><code>seg\u00fan sea (expresi\u00f3n) hacer\n    1: Instrucci\u00f3n1\n    2: Instrucci\u00f3n2\n    ...\n    N: Instrucci\u00f3nN\n    en otro caso: Instrucci\u00f3n Por defecto\nfin seg\u00fan\n</code></pre>"},{"location":"tema_3/page-3/","title":"3 Estructuras repetitivas","text":""},{"location":"tema_3/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>En programaci\u00f3n, un bucle o instrucci\u00f3n de control repetitiva (o iterativa) permite ejecutar una o m\u00e1s instrucciones varias veces, es decir, permite ejecutar un bloque de instrucciones repetidamente, escribi\u00e9ndolas una sola vez en el programa, reduciendo de este modo el c\u00f3digo del mismo. Cada vuelta que da el bucle se conoce como iteraci\u00f3n.</p> <p>Las variables que se utilizan en los bucles pueden tener distintas funciones:</p> <ul> <li>\u00edndice: es una variable que apunta a un recurso concreto. En los bucles, apunta al n\u00famero de iteraci\u00f3n. Se suelen utilizar por convenio los identificadores de variables i, j y k.</li> <li>contador: cuenta cu\u00e1ntas veces ocurre algo.</li> <li>acumulador: acumula operaciones parciales. Las instrucciones b\u00e1sicas que permiten construir este tipo de estructuras son while, do-while y for.</li> </ul> <p>Existen, en general, tres tipos de estructuras repetitivas: mientras, repetir_hasta, desde.</p>"},{"location":"tema_3/page-3/#estructura-mientras","title":"Estructura mientras","text":"<p>El bucle mientras agrupa instrucciones las cuales se ejecutan continuamente mientras una condici\u00f3n que se eval\u00faa sea verdadera. La condici\u00f3n se eval\u00faa antes de entrar dentro del while y cada vez que se termina de ejecutar las instrucciones del while.</p> <p>El programa se ejecuta siguiendo estos pasos:</p> <ol> <li>Se eval\u00faa la expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera ejecuta las instrucciones, sino el programa abandona la sentencia mientras.</li> <li>Tras ejecutar las instrucciones, volvemos al paso 1.</li> </ol> <p>Veamos su estructura:</p> Diagramas de flujoPseudoc\u00f3digo <pre><code>flowchart\n    condici\u00f3n{Condici\u00f3n}\n    instrucciones[\"Instrucciones\"]\n\n    condici\u00f3n--verdadera--&gt;instrucciones\n    instrucciones--&gt;condici\u00f3n\n    condici\u00f3n--falsa--&gt;END:::hidden</code></pre> <p>Figura 5 - Bucle mientras </p> <pre><code>mientras (condici\u00f3n) hacer\n    instrucci\u00f3n1\n    instrucci\u00f3n2\n    ...\n    instrucci\u00f3nN\nfin_mientras\n</code></pre>"},{"location":"tema_3/page-3/#estructura-repetir-mientras","title":"Estructura repetir mientras","text":"<p>El bucle repetir mientras es muy similar al bucle repetir. La \u00fanica diferencia respecto al mientras est\u00e1 en que la expresi\u00f3n l\u00f3gica se eval\u00faa despu\u00e9s de haber ejecutado las instrucciones, es decir, el bucle al menos se ejecuta una vez. Los pasos son los siguientes:</p> <ol> <li>Ejecutar instrucciones.</li> <li>Evaluar expresi\u00f3n l\u00f3gica.</li> <li>Si la expresi\u00f3n es verdadera, volver al paso 1. Si es falsa, salir del bucle.</li> </ol> <p>Veamos su estructura:</p> Diagramas de flujoPseudoc\u00f3digo <pre><code>flowchart\n    instrucciones[\"Instrucciones\"]\n    condici\u00f3n{Condici\u00f3n}\n\n    instrucciones--&gt;condici\u00f3n\n    condici\u00f3n--verdadera--&gt;instrucciones\n    condici\u00f3n--falsa--&gt;END:::hidden</code></pre> <p>Figura 6 - Bucle repetir mientras </p> <pre><code>repetir\n    instrucci\u00f3n1\n    instrucci\u00f3n2\n    ...\n    instrucci\u00f3nN\nmientras que (condici\u00f3n)\n</code></pre>"},{"location":"tema_3/page-3/#estructura-repetir-desde","title":"Estructura Repetir desde","text":"<p>El bucle repetir desde ejecuta las instrucciones desde una variable acumulador hasta un l\u00edmite (por ejemplo, de 1 a 10). Su funcionamiento es el siguiente:</p> <ol> <li>Se ejecuta la instrucci\u00f3n de inicializaci\u00f3n.</li> <li>Se comprueba la condici\u00f3n.</li> <li>Si la condici\u00f3n es cierta, entonces se ejecutan las instrucciones. Si la condici\u00f3n es falsa, se abandona el bloque for.</li> <li>Tras ejecutar las instrucciones, se ejecuta la instrucci\u00f3n de incremento y se vuelve al paso.</li> </ol> <p>Veamos su estructura:</p> Diagramas de flujoPseudoc\u00f3digo <p> Figura 8 - Bucle repetir desde </p> <pre><code>desde i \u2190 Vi hasta Vf hacer\n    instrucciones\nfin desde\n</code></pre>"},{"location":"tema_3/page-3/#diferencias","title":"Diferencias","text":"<p>Todos los problemas que requieren una estructura repetitiva se pueden solucionar con las estructuras mencionadas, entonces, \u00bfcu\u00e1l se debe usar? Es importante que le programador utilice la estructura m\u00e1s adecuada en cada caso:</p> <ul> <li>Un bucle repetir desde se utiliza cuando se conozca el n\u00famero de veces que se va a ejecutar el bucle, es decir, cuando se conozcan el n\u00famero de iteraciones de antemano.</li> <li>Si no se sabe de antemano el n\u00famero de iteraciones, entonces hay que utilizar mientras o repetir mientras:<ul> <li>Un bucle repetir mientras se utiliza cuando las instrucciones del bucle se van a ejecutar al menos una vez.</li> <li>Un bucle mientras se utiliza, entonces, cuando las instrucciones del bucle pueden no ejecutarse nunca si la condici\u00f3n es falsa desde un principio.</li> </ul> </li> </ul> <p>Tambi\u00e9n es conveniente saber, que todas las estructuras repetitivas y condicionales se pueden anidar, siempre y cuando sea una dentro de otras.</p> <p>Veamos un ejemplo: Se desea mostrar todos los n\u00fameros del 1 al 100. En este caso, como se conoce el n\u00famero de interacciones, se debe utilizar el bucle repetir desde:</p> <pre><code>var\n    entero: i\n\ndesde i \u2190 1 hasta 100 hacer:\n    escribir(i)\nfin desde\n</code></pre> <p>Ahora, supongamos que queremos obtener la edad de una persona. La edad es un n\u00famero entero, pero ese n\u00famero ha de ser positivo, no puede ser negativo, por lo que se deber\u00eda solicitar hasta que introduzca un valor correcto, es decir, mientras no se cumpla la condici\u00f3n:</p> <pre><code>var\n    entero: edad\n\nrepetir:\n    escribir(\"Introduzca su edad: \")\n    leer(edad)\n\n    si edad &lt; 0\n        escribir(\"La edad debe ser positiva y mayor que cero.\")\n    fin si\nmientras que (entero &lt;= 0)\n</code></pre> <p>Ahora, supongamos que se desea recorrer los n\u00fameros desde 1 hasta el primer n\u00famero que sea divisor de 10. No conocemos el n\u00famero de iteraciones, no es obligatorio que se ejecute la primera vez, por lo que se usar\u00e1 el bucle mientras:</p> <pre><code>var\n    entero: i\n\ni \u2190 1\n\nmientras (i % 10 != 0) hacer:\n    escribir(i)\n    i \u2190 i + 1\nfin mientras\n</code></pre>"},{"location":"tema_4/page-1/","title":"1 Modularidad","text":""},{"location":"tema_4/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>El dise\u00f1o modular es una metodolog\u00eda de desarrollo de algoritmos basada en la descomposici\u00f3n del problema en subproblemas mediante abstracciones y resoluci\u00f3n separada de cada uno de ellos.</p> <p>Esta t\u00e9cnica realiza dos nuevas aportaciones:</p> <ol> <li>Ampl\u00eda y completa la t\u00e9cnica de desarrollo de algoritmos dise\u00f1o descendente (top down design and step wise refinement).</li> <li>Protege la informaci\u00f3n necesaria de cada uno de los m\u00f3dulos, ocultando informaci\u00f3n pertinente.</li> </ol>"},{"location":"tema_4/page-1/#modulo","title":"M\u00f3dulo","text":"<p>Un m\u00f3dulo es una unidad de organizaci\u00f3n de un algoritmo que realiza funciones espec\u00edficas con un objetivo diferenciado del de otros m\u00f3dulos. En un m\u00f3dulo podemos encontrar definici\u00f3n de tipos, constantes, variables y subalgoritmos (funciones y procedimientos).</p> <p>Un m\u00f3dulo tiene dos secciones principales: importaci\u00f3n y exportaci\u00f3n. En la secci\u00f3n de importaci\u00f3n se indican elementos de los m\u00f3dulos externos que se van a utilizar en el m\u00f3dulo actual. Mientras que, en el m\u00f3dulo de exportaci\u00f3n se indica los elementos del m\u00f3dulo actual que van a ser utilizados en otros m\u00f3dulos.</p> <p>Los elementos exportados de un m\u00f3dulo se consideran elementos p\u00fablicos ya que cualquiera que importe nuestro m\u00f3dulo podr\u00e1n acceder a ellos. Sin embargo, no podr\u00e1n acceder a aquellos elementos que NO han sido exportados, por lo que ser\u00e1 elementos privados.</p> <p>En ciertas ocasiones, esta t\u00e9cnica es bastante \u00fatil, por que hay informaci\u00f3n que no interesa que pueda ser accedida desde otros m\u00f3dulos por diversas causas, como por ejemplo, la vulnerabilidad con respecto al proyecto.</p> <p>Esta t\u00e9cnica da lugar a dos perfiles del programador:</p> <ol> <li>Como usuario, conoce los elementos exportados por un m\u00f3dulo, es decir, los elementos p\u00fablicos. Mas no puede decidir ni conocer  ni modificar el dise\u00f1o o implementaci\u00f3n.</li> <li>Como creador, debe decidir cu\u00e1les ser\u00e1n los elementos p\u00fablicos que pueden ser usadas en el exterior del m\u00f3dulo, y cu\u00e1les ser\u00e1n los privados que se queden ocultos en el interior del m\u00f3dulo y no puedan ser usados a fueras de \u00e9l.</li> </ol> <p>Como ventajas del m\u00f3dulo podemos entender:</p> <ul> <li>Mayor legibilidad de los programas.</li> <li>La legibilidad favorece mejor mantenimiento de los programas.</li> <li>Facilita la depuraci\u00f3n, actualizaci\u00f3n y modificaci\u00f3n.</li> <li>Implementaci\u00f3n m\u00e1s f\u00e1cil y menos compleja.</li> <li>Reutilizaci\u00f3n de m\u00f3dulos.</li> </ul>"},{"location":"tema_4/page-1/#criterios-de-descomposicion","title":"Criterios de descomposici\u00f3n","text":"<p>Para descomponer un problema en subproblemas, se puede seguir alguno de estos criterios (o ambos):</p> <ul> <li>Descomposici\u00f3n de tareas: Se identifican las distintas operaciones a realizar con los datos y se define un m\u00f3dulo para cada una.</li> <li>Descomposici\u00f3n por datos: Se identifican los tipos de datos que intervienen en el problemas y las operaciones asociadas a ellos. Se crea un m\u00f3dulo para cada tipo de dato y sus operaciones.</li> </ul>"},{"location":"tema_4/page-1/#relacion-entre-modulos","title":"Relaci\u00f3n entre m\u00f3dulos","text":"<p>Para determinar la relaci\u00f3n objetiva entre m\u00f3dulos se definen dos criterios cualitativos:</p> <ul> <li>Cohesi\u00f3n: Relaci\u00f3n funcional entre los elementos de un mismo m\u00f3dulo.</li> <li>Acoplamiento: Grado de interdependencia entre los m\u00f3dulos.</li> </ul> <p>Uno de los objetivos de la programaci\u00f3n es configurar m\u00f3dulos que no necesiten mucha modificaci\u00f3n en caso de cambios en el programa, es decir, dise\u00f1ar m\u00f3dulos con alta cohesi\u00f3n y bajo acoplamiento.</p>"},{"location":"tema_4/page-1/#modulos-en-pseudocodigo","title":"M\u00f3dulos en pseudoc\u00f3digo","text":"<p>La estructura en pseudoc\u00f3digo a la hora de definir un m\u00f3dulo es la siguiente</p> <pre><code>m\u00f3dulo nombre\n    importa\n        // Lista de los elementos de los m\u00f3dulos a usar si procede\n    fin_importa\n\n    exporta\n        // Elementos a exportar\n    fin_exporta\n\n    cuerpo\n        // Cuerpo del m\u00f3dulo\n    fin_cuerpo\nfin_m\u00f3dulo\n</code></pre>"},{"location":"tema_4/page-2/","title":"2 Abstracci\u00f3n operacional","text":""},{"location":"tema_4/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>La abstracci\u00f3n operacional es la t\u00e9cnica de dividir un problema en diferentes m\u00f3dulos y subproblemas. La abstracci\u00f3n operacional permite a los programadores realizar sus propias abstracciones en forma de subalgoritmos, a trav\u00e9s de funciones y procedimientos.</p> <p>Una funci\u00f3n o un procedimiento se presenta como un subalgoritmo que forma parte del algoritmo principal, el cual permite resolver una tarea espec\u00edfica.</p> <p>En una abstracci\u00f3n operacional debemos distinguir las siguientes partes:</p> <ul> <li>Cabecera: informaci\u00f3n sint\u00e1ctica que indica que hay que hacer para proceder a la ejecuci\u00f3n del subalgoritmo. <code>entero maximo(E entero: a, E entero: b)</code></li> <li>Precondici\u00f3n: Condiciones que se deben de cumplir con los valores de enteradas. Por ejemplo, a y b deben (estar inicializados.</li> <li>Postcondici\u00f3n: Efecto producido por el subalgoritmo, es decir, las condiciones que se cumple al finalizarlo. Por ejemplo: obtener el m\u00e1ximo entre a y b.</li> <li>Implementaci\u00f3n: C\u00f3digo que resuelve el problema.</li> </ul> <p>La cabecera, precondici\u00f3n y postcondici\u00f3n tambi\u00e9n se le conoce como especificaci\u00f3n. La especificaci\u00f3n debe ser diferente a la implementaci\u00f3n, y una misma especificaci\u00f3n puede tener varias implementaciones.</p> <pre><code>//Cabecera: entero maximo(E entero: a, E entero b)\n//Precondici\u00f3n: a y b han de estar inicializados\n//Postcondici\u00f3n: devuelve el m\u00e1ximo entre a y b\n\nentero funci\u00f3n maximo(E entero: a, E entero: b)\n    var entero: max\n    inicio\n    si a &gt; b entonces\n        max \u2190 a\n    si no\n        max \u2190 b\n    fin si\n\n    devolver max\nfin funci\u00f3n\n</code></pre>"},{"location":"tema_4/page-2/#funciones-y-procedimientos","title":"Funciones y procedimientos","text":"<p>Una funci\u00f3n es una operaci\u00f3n que recibe uno o m\u00e1s valores llamados argumentos y devuelve un valor como resultado. En un programa de software podemos encontrar funciones internas, que son incorporadas por el lenguaje, y funciones externas que son desarrolladas por el programador.</p> <pre><code>//Cabecera: entero maximo(E entero: a, E entero b)\n//Precondici\u00f3n: a y b han de estar inicializados\n//Postcondici\u00f3n: devuelve el m\u00e1ximo entre a y b\n\nentero funci\u00f3n maximo(E entero: a, E entero: b)\n    var entero: max\n    inicio\n    si a &gt; b entonces\n        max \u2190 a\n    si no\n        max \u2190 b\n    fin si\n\n    devolver max\nfin funci\u00f3n\n</code></pre> <p>Un procedimiento es un tipo de funci\u00f3n que NO retorna ning\u00fan valor. Por ejemplo:</p> <pre><code>procedimiento maximo(E entero: a, E entero: b)\n    var entero: max\n    inicio\n    si a &gt; b entonces\n        escribir(\"El m\u00e1ximo es \", a)\n    si no\n        escribir(\"El m\u00e1ximo es \", b)\n    fin si\n\nfin procedimiento\n</code></pre>"},{"location":"tema_4/page-2/#ambito-y-persistencia-de-las-variables","title":"\u00c1mbito y persistencia de las variables","text":"<p>Se considera \u00e1mbito aquella parte de c\u00f3digo en el que se puede referenciar una variable. Una variable puede tener \u00e1mbito local o \u00e1mbito global.</p> <p>Como \u00e1mbito local entendemos aquellas variables que pueden ser declaradas dentro de cualquier funci\u00f3n o procedimiento (incluido el Principal), ya sea como par\u00e1metro formal o en la secci\u00f3n correspondiente a la definici\u00f3n de variables. Una variable declarada en \u00e1mbito local, no podr\u00e1 ser accedida fuera de dicho \u00e1mbito. Veamos un ejemplo:</p> <pre><code>procedimiento sayHi()\n    var cadena: msg\n\n    msg \u2190 \"Hola mundo\"\n\n    escribir(msg)\nfin procedimiento\n\nprincipal\n    sayHi()\n\n    escribir(msg) // \u274c NO \u274c\n</code></pre> <p>Como \u00e1mbito global entendemos las variables que fueran declaradas fuera del principal y de cualquier subalgoritmo. Una variable tiene \u00e1mbito global cuando puede ser referenciada en cualquier punto del principal y cualquiera de subalgoritmos.</p> <p>La persistencia de las variables es la duraci\u00f3n de la variable en memoria. Podemos entender dos tipos de persistencia indefinida, permanece en memoria durante toda la ejecuci\u00f3n de un programa, y din\u00e1mica cuando la variable existe solo durante la ejecuci\u00f3n de un fragmento de c\u00f3digo. Por ejemplo, persiste en memoria durante la ejecuci\u00f3n de un procedimiento o funci\u00f3n y posteriormente desaparece.</p> <p>Por lo general, se asocia la persistencia indefinida al \u00e1mbito global de las variables y la persistencia din\u00e1mica al \u00e1mbito local. Sin embargo, en algunos lenguajes de programaci\u00f3n se permite modificar el \u00e1mbito y persistencia de las variables a trav\u00e9s de determinadas instrucciones siendo posible que existan las cuatro combinaciones posibles: \u00e1mbito global y persistencia indefinida, \u00e1mbito global y persistencia din\u00e1mica, \u00e1mbito local y persistencia indefinida, \u00e1mbito local y persistencia din\u00e1mica.</p>"},{"location":"tema_4/page-3/","title":"3 Argumentos y par\u00e1metros","text":""},{"location":"tema_4/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>El paso de par\u00e1metros es el m\u00e9todo mediante el cual los distintos subalgoritmos de un algoritmo pueden comunicarse, compartir valores y variables sin perder su independencia.</p> <p>Distinguimos dos tipos de par\u00e1metros seg\u00fan el momento de uso, formales y actuales. Los par\u00e1metros formales son los par\u00e1metros que se definen en la especificaci\u00f3n del subalgoritmo, mientras que los actuales son los valores que se les dan en las llamadas de los mismos. Veamos un ejemplo:</p> <pre><code>entero funci\u00f3n m\u00e1ximo(E entero: a, E entero: b)\n    var entero: max\n    inicio\n    si a &gt; b entonces\n        max \u2190 a\n    si no\n        max \u2190 b\n    fin si\n\n    devolver max\nfin funci\u00f3n\n\nPrincipal\n    var\n        entero: a, b, max\n\n    a \u2190 5\n    b \u2190 10\n\n    max \u2190 m\u00e1ximo(a, b)\nFin_principal\n</code></pre> <p>Existe una correspondencia autom\u00e1tica entre los par\u00e1metros formales y los par\u00e1metros actuales, y existen de dos tipos:</p> <ul> <li>Posicional: la correspondencia se establece de izquierda a derecha entre par\u00e1metros formales y actuales.</li> <li>Por nombre: se indica de forma expl\u00edcita en la llamada del subalgoritmo c\u00f3mo ha de realizarse esta correspondencia. Por ejemplo, <code>proc(a \u2190 10, b \u2190 5)</code></li> </ul> <p>Adem\u00e1s, existen dos formas de pasar los par\u00e1metros, por valor o por referencia.</p>"},{"location":"tema_4/page-3/#pasos-por-valor","title":"Pasos por valor","text":"<p>Cuando se produce un paso de par\u00e1metros por valor se produce una copia del valor de los par\u00e1metros actuales en los par\u00e1metros formales. Los par\u00e1metros actuales pueden ser constantes, variables o expresiones. Los par\u00e1metros formales ser\u00e1n variables locales al procedimiento que ser\u00e1n inicializadas con el valor que el par\u00e1metro actual les pasa en la llamada.</p> <p>Los par\u00e1metros pasados por valor ser\u00e1n siempre par\u00e1metros de entradas y se indicar\u00e1n en la funci\u00f3n como E antes del tipo del par\u00e1metro. A trav\u00e9s de estos par\u00e1metros no se devuelve ninguna informaci\u00f3n al algoritmo desde el cual se realiz\u00f3 la llamada.</p> <pre><code>entero funci\u00f3n m\u00e1ximo(E entero: a, E entero: b)\n// ...\nfin funci\u00f3n\n</code></pre> <p>Cuando el subalgoritmo devuelve el control al algoritmo que realiza la llamada los par\u00e1metros actuales conservar\u00e1n exactamente el valor que ten\u00edan antes de realizar la llamada.</p>"},{"location":"tema_4/page-3/#pasos-por-referencia","title":"Pasos por referencia","text":"<p>Podemos pasar los par\u00e1metros como paso por referencia, de tal manera, que se recibe una referencia del par\u00e1metro actual, es decir, la direcci\u00f3n de memoria de dicho par\u00e1metro. As\u00ed, los par\u00e1metros y formales comparten la misma direcci\u00f3n de memoria por tanto todo cambio en el par\u00e1metro formal tendr\u00e1 efecto en el par\u00e1metro actual.</p> <p>Los par\u00e1metros pasador por valor ser\u00e1n siempre par\u00e1metros de salida (S) o entrada/salida (E/S) y se indicar\u00e1n, al igual que los de entrada, antes de la declaraci\u00f3n del tipo del par\u00e1metro formal.</p> <p>Este paso de par\u00e1metros se puede usar para que un subalgoritmo devuelva valores al algoritmo que realiza la llamada. Veamos un ejemplo:</p> <pre><code>procedimiento max(E entero: a, E entero: b, S entero: max)\n    si a &gt; b, entonces:\n        max \u2190 a\n    si no, entonces:\n        max \u2190 b\n    fin si\nfin procedimiento\n</code></pre>"},{"location":"tema_4/page-3/#efectos-laterales","title":"Efectos laterales","text":"<p>Los efectos laterales son los cambios o modificaciones que se producen en las variables de un m\u00f3dulo como consecuencia de una instrucci\u00f3n de otro m\u00f3dulo. La comunicaci\u00f3n de un m\u00f3dulo con el resto del algoritmo se debe realizar siempre a trav\u00e9s del paso de par\u00e1metros. Cualquier otra comunicaci\u00f3n puede provocar efectos laterales. Una funci\u00f3n o procedimiento puede cambiar el contenido de una variable global y provocar\u00e1 un efecto lateral. Si se necesita una variable temporal en un procedimiento o funci\u00f3n se debe utilizar una variable local, nunca global.</p> <p>Si se desea que el programa modifique el valor de una variable global es mejor utilizar un par\u00e1metro formal pasado por referencia (E/S o S) en la declaraci\u00f3n del procedimiento y utilizar la variable global como par\u00e1metro actual en la llamada al procedimiento.</p> <p>Los efectos laterales est\u00e1n considerados como una mala t\u00e9cnica de programaci\u00f3n, pues disminuyen la legibilidad del c\u00f3digo, resultando m\u00e1s complicada la depuraci\u00f3n y detecci\u00f3n de errores, as\u00ed como el mantenimiento de los programas.</p>"},{"location":"tema_4/page-3/#funciones-como-parametros","title":"Funciones como par\u00e1metros","text":"<p>Algunos lenguajes de programaci\u00f3n admiten la posibilidad de pasar como par\u00e1metros de funciones o procedimientos, otros nombres de funciones o procedimientos, aumentando as\u00ed el nivel de abstracci\u00f3n.</p> <p>Para ello, primero hay que definir el tipo de funci\u00f3n a pasar, es decir, que devolver\u00e1 y que tipo de par\u00e1metros pasarle:</p> <pre><code>tipo entero funci\u00f3n (E entero: x, E entero: y): func\n</code></pre> <p>En el ejemplo anterior, se ha definido la funci\u00f3n func y se puede utilizar como par\u00e1metro de otra funci\u00f3n:</p> <pre><code>entero funci\u00f3n operaci\u00f3n(E entero: x, E entero: y, E func: op)\n    devolver op(x, y)\nfin funci\u00f3n\n\nentero funci\u00f3n sumar(E entero: x, E entero: y)\n    devolver x + y\nfin funci\u00f3n\n\nPrincipal\n    var\n        entero: x, y, resultado\n\n    x \u2190 10\n    y \u2190 10\n\n    resultado \u2190 operaci\u00f3n(c, y, sumar)\nfin principal\n</code></pre> <p>Adem\u00e1s, tambi\u00e9n se puede utilizar como retorno en otras funciones o procedimientos.</p>"},{"location":"tema_4/page-4/","title":"4 Recursividad","text":""},{"location":"tema_4/page-4/#introduccion","title":"Introducci\u00f3n","text":"<p>La recursividad es una t\u00e9cnica de programaci\u00f3n que aparece de forma natural en programaci\u00f3n, tanto en la definici\u00f3n de tipos como en el dise\u00f1o de algoritmos. Consiste en que el algoritmo se llama a s\u00ed mismo con un problema de menor tama\u00f1o y as\u00ed sucesivamente hasta que la soluci\u00f3n es inmediata. Son algoritmos m\u00e1s simples y compactos que los iterativos pero es m\u00e1s lenta y consume m\u00e1s recursos.</p> <p>Pueden utilizarse para resolver casi cualquier problema. Sin embargo, es recomendable utilizarlo para resolver problemas de forma directa a partir de ciertos tama\u00f1os del problema planteado. Adem\u00e1s, puede ser un buen sustituto para algoritmos iterativos que requieran una soluci\u00f3n compleja, ofreciendo as\u00ed una soluci\u00f3n elegante o simple. La asignaci\u00f3n de memoria durante la recursividad, es una asignaci\u00f3n din\u00e1mica.</p> <p>Las funciones recursivas se autoinvocan, es decir, se llaman as\u00ed mismas durante su proceso. Debe tener un caso base que pueda resolverse sin necesidad de la autoinvocaci\u00f3n, para as\u00ed evitar autoinvocaciones infinitas. Adem\u00e1s, dentro de una funci\u00f3n recursiva se puede combinar con otras llamadas a otras funciones o con otras sentencias no recursivas.</p> <p>Veamos un ejemplo, para el calculo de un n\u00famero factorial, tanto con iteratividad como con recursividad</p> Soluci\u00f3n iterativaSoluci\u00f3n recursividad <pre><code>entero funci\u00f3n factorial(E entero: n)\n    var\n        entero: resultado\n\n    desde i \u2190 1 hasta n hacer\n        resultado \u2190 resultado * (n - i)\n    fin desde\n\n    devolver resultado\nfin funci\u00f3n\n</code></pre> <pre><code>entero funci\u00f3n factorial(E entero: n)\n    si n = 1, entonces\n        devolver 1\n\n    devolver factorial(n - 1)\nfin funci\u00f3n\n</code></pre>"},{"location":"tema_4/page-4/#pila","title":"Pila","text":"<p>Una pila(stack) es una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del ingl\u00e9s Last In, First Out, \u00faltimo en entrar, primero en salir) de supuestos en el \u00e1rea de inform\u00e1tica debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.</p> <p>Para el manejo de los datos cuenta con dos operaciones b\u00e1sicas: apilar (push), que coloca un objeto en la pila, y su operaci\u00f3n inversa, desapilar (pop), que retira el \u00faltimo elemento apilado.</p> <p>En cada momento s\u00f3lo se tiene acceso a la parte superior de la pila, es decir, al \u00faltimo objeto apilado (denominado TOS, Top of Stack). La operaci\u00f3n desapilar permite la obtenci\u00f3n de este elemento, que es retirado de la pila permitiendo el acceso al anterior (apilado con anterioridad), que pasa a ser el \u00faltimo, el nuevo TOS.</p> <p> Figura 1 - Pila (Stack)</p> <p>Para las llamadas entre funciones, se utiliza una estructura de tipo pila: supongamos que se est\u00e1 procesando una funci\u00f3n y en su interior llama a otra funci\u00f3n. La funci\u00f3n se abandona para procesar la funci\u00f3n de la llamada, pero antes se almacena en una pila la direcci\u00f3n que apunta a la funci\u00f3n. Ahora supongamos que esa nueva funci\u00f3n llama a su vez a otra funci\u00f3n. Igualmente, se almacena su direcci\u00f3n, se abandona y se atiende la petici\u00f3n. As\u00ed en tantos casos como existan peticiones. La ventaja de la pila es que no requiere definir ninguna estructura de control ni conocer las veces que el programa estar\u00e1 saltando entre funciones para despu\u00e9s retomarlas, con la \u00fanica limitaci\u00f3n de la capacidad de almacenamiento de la pila. Conforme se van cerrando las funciones, se van rescatando las funciones precedentes mediante sus direcciones almacenadas en la pila y se va concluyendo su proceso, esto hasta llegar a la primera.</p> <p>En el caso de una funci\u00f3n recursiva, esto es posible implementarlo con sencillez mediante una pila. La funci\u00f3n se llama a s\u00ed misma tantas veces como sea necesario hasta que el resultado de la funci\u00f3n cumpla la condici\u00f3n de retorno; entonces, todas las funciones abiertas van completando su proceso en cascada. No se necesita saber cuantas veces se anidar\u00e1 y, por tanto, tampoco cuando se cumplir\u00e1 la condici\u00f3n, con la \u00fanica limitaci\u00f3n de la capacidad de la pila. De sobrepasarse ese l\u00edmite, normalmente porque se entra en un bucle sin final, se produce el error de desbordamiento de la pila (stack overflow).</p>"},{"location":"tema_4/page-5/","title":"5 Tipos de recursividad","text":"<p>Existen varios tipos de recursividad que se pueden utilizar en la programaci\u00f3n, dependiendo de c\u00f3mo una funci\u00f3n se llame a s\u00ed misma y de c\u00f3mo se estructuren las llamadas recursivas.</p>"},{"location":"tema_4/page-5/#recursividad-directa","title":"Recursividad directa","text":"<p>En la recursividad directa, una funci\u00f3n se llama as\u00ed misma directamente:</p> <pre><code>procedimiento cuentaRegresiva(E entero: n)\n    si n &gt; 0, entonces\n        escribir(n)\n        cuentaRegresiva(n - 1)\n    fin si\nfin procedimiento\n</code></pre>"},{"location":"tema_4/page-5/#recursividad-indirecta","title":"Recursividad indirecta","text":"<p>En la recursividad indirecta, una funci\u00f3n llama a otra funci\u00f3n, y esa otra funci\u00f3n puede llamar nuevamente a la primera. Este tipo de recursividad involucra m\u00faltiples funciones que se llaman entre s\u00ed de manera c\u00edclica.</p> <pre><code>procedimiento funci\u00f3nA(E entero: n):\n    si n &gt; 0, entonces:\n        escribir(\"A\", n)\n        funci\u00f3nB(n - 1)\n    fin si\nfin procedimiento\n\nprocedimiento funci\u00f3nB(E entero: n)\n    si n &gt; 0, entonces:\n        escribir(\"B\", n)\n        funci\u00f3nA(n - 1)\n    fin si\nfin procedimiento\n</code></pre>"},{"location":"tema_4/page-5/#recursividad-no-final","title":"Recursividad no final","text":"<p>En la recursividad no final, la llamada recursiva no es la \u00faltima operaci\u00f3n que se realiza en la funci\u00f3n. Esto es t\u00edpico cuando, despu\u00e9s de hacer la llamada recursiva, hay alguna operaci\u00f3n pendiente que debe ser resuelta, como una multiplicaci\u00f3n, adici\u00f3n o concatenaci\u00f3n.</p> <pre><code>entero funci\u00f3n factorial(E entero: n)\n    si n = 1, entonces\n        devolver 1\n\n    devolver factorial(n - 1)\nfin funci\u00f3n\n</code></pre>"},{"location":"tema_4/page-5/#recursividad-final","title":"Recursividad final","text":"<p>La recursividad final (tail recursion) es una forma especial de recursividad en la que una funci\u00f3n recursiva hace su llamada recursiva como la \u00faltima operaci\u00f3n antes de regresar su resultado. Esto significa que no hay m\u00e1s trabajo que hacer despu\u00e9s de que la llamada recursiva devuelve su resultado.</p> <p>El beneficio de la recursividad final es que muchos compiladores e int\u00e9rpretes pueden optimizar este tipo de recursividad mediante una t\u00e9cnica llamada optimizaci\u00f3n de recursividad final (tail call optimization, TCO), donde la llamada recursiva no a\u00f1ade un nuevo marco al stack (pila) de llamadas, sino que reutiliza el actual. Esto evita que el programa consuma m\u00e1s memoria con cada llamada recursiva, permitiendo que algoritmos recursivos funcionen de manera eficiente incluso en casos con un n\u00famero muy grande de recursiones.</p> <p>Veamos el caso del factorial como recursiva final:</p> <pre><code>entero funci\u00f3n factorial(E entero: n)\n    devolver factorialFinal(n, 1)\nfin funci\u00f3n \n\nentero funci\u00f3n factorialFinal(E entero: n)\n    si n = 1, entonces\n        devolver acumulador\n\n    devolver factorialFinal(n - 1, n * acumulador)\nfin funci\u00f3n\n</code></pre> <p>Aqu\u00ed, la llamada a <code>factorialFinal(n - 1)</code> es la \u00faltima operaci\u00f3n que se realiza en la funci\u00f3n. La multiplicaci\u00f3n ya est\u00e1 resuelta antes de la llamada, y el resultado se pasa a la siguiente iteraci\u00f3n, permitiendo que el int\u00e9rprete reutilice el marco de la pila y optimice el uso de memoria.</p> <p>La optimizaci\u00f3n de recursividad final es importante en lenguajes que la soportan, ya que permite que ciertos algoritmos recursivos puedan ejecutarse de manera m\u00e1s eficiente.</p>"},{"location":"tema_4/page-5/#recursividad-simple","title":"Recursividad simple","text":"<p>La recursividad simple es cuando una funci\u00f3n hace una \u00fanica llamada recursiva dentro de su cuerpo.</p> <pre><code>entero funci\u00f3n factorial(E entero: n)\n    si n = 1, entonces\n        devolver 1\n\n    devolver factorial(n - 1)\nfin funci\u00f3n\n</code></pre>"},{"location":"tema_4/page-5/#recursividad-multiple","title":"Recursividad m\u00faltiple","text":"<p>La recursividad m\u00faltiple es cuando una funci\u00f3n hace m\u00e1s de una llamada recursiva. Este tipo de recursividad es com\u00fan en algoritmos que involucran \u00e1rboles o divisiones de problemas en partes m\u00e1s peque\u00f1as.</p> <pre><code>entero funci\u00f3n multiple(E entero: n)\n    si n &gt; 0, entonces\n        devolver multiple(n - 1) + multiple(n - 5)\n    fin si\nfin funci\u00f3n\n</code></pre>"},{"location":"tema_4/page-5/#recursividad-anidada","title":"Recursividad anidada","text":"<p>La recursividad anidada un caso en el que la funci\u00f3n recursiva llama a s\u00ed misma m\u00e1s de una vez dentro de otra llamada recursiva.</p> <pre><code>procedimiento funci\u00f3n(E entero: n)\n    si n &gt; 0, entonces\n        escribir(n)\n        funci\u00f3n(funci\u00f3n(n))\n    fin si\nfin procedimiento\n</code></pre>"},{"location":"tema_4/page-5/#recursividad-mutua","title":"Recursividad mutua","text":"<p>La recursividad mutua es una variante de la recursividad indirecta, pero en este caso implica que las funciones recursivas se llaman entre s\u00ed de manera estrictamente alterna o c\u00edclica.</p> <pre><code>booleano funci\u00f3n par(E entero: n)\n    si n = 0, entonces\n        devolver verdadero\n    si no, entonces\n        devolver impar(n - 1)\nfin funci\u00f3n\n\nbooleano funci\u00f3n impar(n):\n    si n = 0, entonces\n        devolver falso\n    si no, entonces:\n        devolver par(n - 1)\nfin funci\u00f3n\n</code></pre>"},{"location":"tema_4/page-6/","title":"6 Documentaci\u00f3n","text":""},{"location":"tema_4/page-6/#introduccion","title":"Introducci\u00f3n","text":"<p>Cuando en un proyecto se definen varios m\u00f3dulo es importante realizar una buena documentaci\u00f3n. Podemos encontrar dos tipos de documentaci\u00f3n:</p> <ul> <li>Interna: Se refiere a los comentarios en el c\u00f3digo.</li> <li>Externa: Se refiere a los aspectos del dise\u00f1o, desarrollo y estructura del programa.</li> </ul> <p>Dentro de la documentaci\u00f3n externa podemos hacer dos distinciones:</p> <ul> <li>Documentaci\u00f3n de usuario: Describe como usar el programa tanto para los usuarios finales como para los administradores del sistema.</li> <li>Documentaci\u00f3n del sistema: Describe el sistema en s\u00ed mismo, es decir, su dise\u00f1o, su implementaci\u00f3n y pruebas del sistema.</li> </ul>"},{"location":"tema_4/page-6/#documentacion-interna","title":"Documentaci\u00f3n interna","text":"<p>Se refiere a los comentarios en el c\u00f3digo. Hay que tener en cuenta:</p> <ul> <li>Usar identificadores representativos.</li> <li>No usar abreviaturas no est\u00e1ndar</li> <li>Si existe alguna convenci\u00f3n sobre c\u00f3mo nombrar a variables, m\u00e9todos, clases, etc debe usarse.</li> <li>Breve comentario acompa\u00f1ando a las declaraciones de constantes, variables, estructuras, etc, explicando su prop\u00f3sito.</li> <li>Secciones m\u00e1s complejas, que necesiten m\u00e1s explicaciones, comentarlas justo antes de su comienzo o entre el c\u00f3digo.</li> </ul>"},{"location":"tema_4/page-6/#documentacion-de-usuario","title":"Documentaci\u00f3n de usuario","text":"<p>Describe como usar el programa al usuario indicado. Hay que tener en cuenta:</p> <ul> <li>Descripci\u00f3n funcional del sistema. Describe requisitos del sistema para su funcionamiento y proporcionar una visi\u00f3n general del sistema.</li> <li>Instalaci\u00f3n del sistema. Proporcionar detalles sobre instalaci\u00f3n del sistema y describir requisitos m\u00ednimos de hardware.</li> <li>Manual introductorio. Describir c\u00f3mo iniciarse en el sistema, c\u00f3mo hacer uso del mismo, como recuperar el sistema cuando se produzca un error y c\u00f3mo salir de \u00e9l.</li> <li>Manual de referencia. Describir con detalle las ventajas del sistema disponibles para el usuario y c\u00f3mo se pueden usar.</li> <li>Gu\u00eda general del sistema para el administrador. Describir los mensajes generados cuando el sistema interact\u00faa con otro sistema y c\u00f3mo reaccionar ante los mismos.</li> </ul>"},{"location":"tema_4/page-6/#documentacion-del-sistema","title":"Documentaci\u00f3n del sistema","text":"<p>Est\u00e1 destinada a los ingenieros de mantenimiento. Describe detalles del dise\u00f1o, implementaci\u00f3n y pruebas del sistema. Hay que tener en cuenta:</p> <ul> <li>Definici\u00f3n de requisitos.</li> <li>Descomposici\u00f3n del problema en distintos subproblemas y los m\u00f3dulos asociados a cada uno, acompa\u00f1ados de su especificaci\u00f3n.</li> <li>Documentaci\u00f3n por cada m\u00f3dulo, describiendo lo que hace, su funcionalidad e interfaz.</li> <li>Listado del c\u00f3digo fuente del programa.</li> <li>Plan de pruebas de cada uno de los m\u00f3dulos, c\u00f3mo se llev\u00f3 a cabo la integraci\u00f3n de los mismos y las pruebas de integraci\u00f3n.</li> <li>Plan de pruebas de aceptaci\u00f3n. Describir las pruebas realizadas para la aceptaci\u00f3n del mismo, comprobando que se cumple los requisitos descritos en la especificaci\u00f3n del sistema.</li> </ul>"},{"location":"tema_5/page-1/","title":"1 Introducci\u00f3n al Testing","text":""},{"location":"tema_5/page-1/#introduccion","title":"Introducci\u00f3n","text":"<p>Como hemos visto hasta ahora, las etapas del ciclo de vida de un software se compone de an\u00e1lisis y especificaci\u00f3n (Tema 1), dise\u00f1o (Tema 2), implementaci\u00f3n o codificaci\u00f3n (depende del lenguaje a usar), prueba y mantenimiento.</p>"},{"location":"tema_5/page-1/#errores","title":"Errores","text":"<p>Un hecho habitual a la hora de programar son la aparici\u00f3n de errores. Estos errores pueden parecer inofensivos y de f\u00e1cil soluci\u00f3n, o pueden ser errores verdaderamente graves que impidan que nuestro programa se comporte de la forma en la que se require.</p> <p>La palabra error es una palabra con connotaci\u00f3n negativa que implica que algo va mal, y en cierta parte es as\u00ed. Sin embargo, los errores nos ayudan a entender y comprender mejor el c\u00f3digo que se est\u00e1 realizando, as\u00ed como poder encontrar una forma de mejorarlo.</p> <p>Por ello, se recomienda intentar provocar ciertos errores en nuestro programa, para que poder mejorar su funcionamiento y comprobar si nuestro c\u00f3digo es funcional en todos los casos posibles.</p> <p>Adem\u00e1s, tambi\u00e9n nos permite definir el funcionamiento de nuestro programa con la entrada de un dato del usuario inesperado o err\u00f3neo. Por ejemplo, supongamos que tenemos una funci\u00f3n que calcule la ra\u00edz cuadrada de un n\u00famero. Si el usuario introduce un n\u00famero positivo, el comportamiento es el esperado y devolver\u00e1 la ra\u00edz cuadrada de dicho n\u00famero. Sin embargo, al utilizar un n\u00famero negativo, \u00bfcu\u00e1l ser\u00eda su comportamiento? El comportamiento por defecto, depende del lenguaje de programaci\u00f3n en el que se ejecute. En caso de que estemos ejecutando en C, el comportamiento es impredecible, mientras que en Java puede llegar a lanzar una excepci\u00f3n <code>IllegalArgumentException</code>. En nuestro programa, debemos de decidir, si deseamos que el comportamiento sea el de por defecto que realice el lenguaje, o por el contrario, un comportamiento diferente, como por ejemplo, volver a solicitar el usuario un n\u00famero positivo, tener el valor 0 definido por defecto y en caso de que sea negativo devolver ese valor defecto, utilizar los n\u00fameros complejos (no definido por defecto en la mayor\u00eda de lenguajes) para poder solucionar este dilema matem\u00e1tico, etc.</p> <p>En resumen, conocer donde falla nuestro programa, y ponerlo a prueba, nos puede ayudar a entender mejor el c\u00f3digo y el programa en s\u00ed, as\u00ed como mejorar su comportamiento y eficiencia.</p>"},{"location":"tema_5/page-2/","title":"2 T\u00e9cnicas de pruebas de software","text":""},{"location":"tema_5/page-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Para detectar los posibles errores de nuestro algoritmo, ser\u00eda necesario realizar pruebas sobre el mismo y as\u00ed observar cu\u00e1l es su comportamiento.</p> <p>Las pruebas a realizar para comprobar el funcionamiento del software han de estar bien planificadas, dado el alto coste econ\u00f3mico que puede con llevar consigo un fallo.</p> <p>Para las pruebas se ejecuta el programa utilizando datos similares a los datos reales, detectando si se genera error. Adem\u00e1s, para poder confirmar que su funcionamiento es correcto se deber\u00edan probar todos los datos posibles de entrada</p>"},{"location":"tema_5/page-2/#depuracion","title":"Depuraci\u00f3n","text":"<p>El proceso de depuraci\u00f3n (debugging) es el proceso de identificar, analizar y corregir errores o fallos en un programa de software. Estos errores, tambi\u00e9n conocidos como bugs, pueden causar que el programa funcione incorrectamente o de manera inesperada.</p> <p>El proceso de depuraci\u00f3n implica varias etapas:</p> <ol> <li>Identificaci\u00f3n del error: El primer paso es detectar que algo no est\u00e1 funcionando como se esperaba, ya sea porque el programa no produce los resultados correctos o porque se comporta de manera inesperada. A menudo, los errores son descubiertos por los propios programadores o por los usuarios durante el uso del software.</li> <li>Reproducci\u00f3n del error: Una vez que se detecta el fallo, es importante poder reproducirlo de manera consistente. Esto permite analizar bajo qu\u00e9 condiciones se presenta el error y facilita su resoluci\u00f3n.</li> <li>An\u00e1lisis del c\u00f3digo: El programador revisa el c\u00f3digo fuente para encontrar la causa del error. Esto puede involucrar la lectura del c\u00f3digo, el uso de herramientas como depuradores (herramientas que permiten ejecutar el programa paso a paso), y la inserci\u00f3n de mensajes o registros que ayuden a rastrear el comportamiento del programa.</li> <li>Correcci\u00f3n del error: Una vez identificado el origen del fallo, el programador modifica el c\u00f3digo para corregirlo. Esto puede implicar cambiar una l\u00f3gica incorrecta, corregir una declaraci\u00f3n mal escrita, o ajustar la estructura del programa para evitar el problema.</li> <li>Pruebas: Despu\u00e9s de realizar la correcci\u00f3n, el programa se prueba nuevamente para asegurarse de que el error ha sido solucionado y que no ha causado nuevos problemas (llamados regresiones).</li> <li>Prevenci\u00f3n de futuros errores: En algunos casos, el proceso de depuraci\u00f3n tambi\u00e9n puede llevar a la implementaci\u00f3n de pruebas adicionales o mejoras en el c\u00f3digo para prevenir que errores similares ocurran en el futuro.</li> </ol> <p>Sin embargo, hay que tener en cuenta que el proceso de prueba de software y la depuraci\u00f3n no son el mismo proceso. La depuraci\u00f3n sirve para encontrar un error en el algoritmo y as\u00ed corregirlo, mientras que la prueba de software es un an\u00e1lisis del algoritmo para comprobar la existencias de errores.</p>"},{"location":"tema_5/page-2/#proceso-de-prueba-de-software","title":"Proceso de prueba de software","text":"<p>Para dise\u00f1ar un plan de prueba de software eficiente, el tester debe ser una persona diferente al dise\u00f1ador del algoritmo.</p> <p>El proceso de prueba de software permite detectar la presencia de errores. Las pruebas consisten:</p> <ol> <li>Realizar la ejecuci\u00f3n utilizando datos similares a los datos reales.</li> <li>Observar los resultados obtenidos y compararlos con resultados deseados.</li> <li>A partir de este estudio, se concluye la existencia de errores o insuficiencias del programa para posteriormente subsanarlos en el proceso de depuraci\u00f3n.</li> </ol> <p>Las tareas de pruebas se consideras exitosas si con ellas se detecta la presencia de errores. Si se obtienen errores se pueden poner en duda la calidad y fiabilidad del software. Sin embargo, la ausencia de las mismas no significa que el programa sea correcto y completamente funcional, si no que puede deberse a que el plan de pruebas dise\u00f1ado no es el adecuado.</p> <p>Cada caso de la prueba debe ir acompa\u00f1ado del resultado o comportamiento deseado. Adem\u00e1s, el programa debe ser probado por personas diferentes a los programadores. Al dise\u00f1ar el plan de prueba se deben seleccionar casos de entrada v\u00e1lidos y no v\u00e1lidos y deben dise\u00f1arse con el pensamiento de que existen errores y en que hay que detectarlos.</p> <p>Se debe probar tanto si el software hace lo que debe hacer como lo que no debe hacer.</p>"},{"location":"tema_5/page-3/","title":"3 T\u00e9cnicas de dise\u00f1o de casos de pruebas","text":""},{"location":"tema_5/page-3/#introduccion","title":"Introducci\u00f3n","text":"<p>Dado que es imposible probar el programa para todos los posibles datos de entradas, se eligen algunos representativos del resto.</p> <p>Existen dos tipos de pruebas: pruebas de caja negra y pruebas de caja blanca.</p>"},{"location":"tema_5/page-3/#pruebas-de-caja-negra","title":"Pruebas de caja negra","text":"<p>Las pruebas de caja negra son pruebas para determinar que cada funci\u00f3n realiza la tarea para la que ha sido construida. Se analiza la especificaci\u00f3n de las funciones, su entrada y salida, y partir de esa informaci\u00f3n se seleccionan las posibles entradas al programa y se comprueba que las salidas son las esperadas. Estas pruebas pueden dise\u00f1arse para lograr algunos objetivos diferentes, incluyendo:</p> <p> Figura 1 - Prueba de Caja Negra</p> <ul> <li>Pruebas funcionales: Las pruebas funcionales tienen como objetivo validar que una aplicaci\u00f3n hace lo que se supone que debe hacer. Por ejemplo, las pruebas funcionales pueden probar el mecanismo de autenticaci\u00f3n de una aplicaci\u00f3n para verificar que los usuarios leg\u00edtimos puedan autenticarse exitosamente mientras se rechazan los intentos de inicio de sesi\u00f3n no v\u00e1lidos. Los tipos comunes de pruebas funcionales incluyen comprobaciones de cordura, pruebas de integraci\u00f3n y pruebas de sistema.</li> <li>Pruebas no funcionales: Las pruebas no funcionales eval\u00faan qu\u00e9 tan bien una aplicaci\u00f3n realiza sus funciones principales. Ejemplos de pruebas incluyen pruebas de rendimiento, usabilidad, escalabilidad y seguridad.</li> <li>Pruebas de regresi\u00f3n: Las pruebas de regresi\u00f3n est\u00e1n dise\u00f1adas para garantizar que un cambio en una aplicaci\u00f3n no afecte la funcionalidad. Por ejemplo, las pruebas de regresi\u00f3n deben realizarse despu\u00e9s de parchear una vulnerabilidad en una aplicaci\u00f3n para garantizar que el parche no haya provocado que la aplicaci\u00f3n falle las pruebas funcionales o no funcionales.</li> </ul> <p>Las pruebas de caja negra no se centra en la soluci\u00f3n del problema en s\u00ed, es decir, no se enfocan en el algoritmo, si no en las posibles entradas y sus posibles salidas. Sin conocimiento interno de una aplicaci\u00f3n, la estructura es importante para garantizar que la prueba cubra todos los casos necesarios.</p> <p>Los casos de prueba suelen estar basados en las especificaciones funcionales, requerimientos del software o los escenarios que los usuarios finales encontrar\u00edan.</p> <p>Entre las t\u00e9cnicas comunes de las pruebas de caja negra podemos encontrar:</p> <ul> <li>Partici\u00f3n de equivalencia: Se divide el conjunto de entradas posibles en clases de equivalencia, y se prueba al menos un caso de cada clase, asumiendo que todos los casos dentro de una clase producir\u00e1n resultados similares.</li> <li>An\u00e1lisis de valores l\u00edmite: Se prueban los valores en los bordes de los rangos de entrada v\u00e1lidos, ya que los errores a menudo ocurren en los l\u00edmites.</li> <li>Pruebas basadas en casos de uso: Se dise\u00f1an casos de prueba que simulan el comportamiento de los usuarios, verificando si el software responde correctamente.</li> </ul> <p>Debemos tener en cuenta dos tipos de casos:</p> <ul> <li>Casos v\u00e1lidos: Son los posibles casos que permiten un comportamiento normal del programa. Por ejemplo, si tenemos un algoritmo que calcula la ra\u00edz cuadrada, el caso v\u00e1lido para dicho algoritmo ser\u00eda cualquier n\u00famero positivo.</li> <li>Casos no v\u00e1lidos: Son los posibles casos que no dan lugar a un comportamiento normal del programa. En el ejemplo anterior, como casos no v\u00e1lidos tendr\u00edamos los n\u00fameros negativos.</li> </ul> <p>Para cada tipo de caso se recomienda definir sus posibles salidas, y luego probar (test) el algoritmo y comprobar si coincide con lo que se ha definido.</p> <p>Para hacer una buena prueba de caja negra es importante que:</p> <ul> <li>En caso de que los casos v\u00e1lidos y no v\u00e1lidos tiendan a infinito (como el ejemplo de la ra\u00edz cuadrada), se pondr\u00e1 a prueba un valor extremo de cada caso y un valor m\u00e1s separado.</li> <li>En caso de que los casos v\u00e1lidos y no v\u00e1lidos tengan l\u00edmites, ser\u00e1 correspondiente realizar pruebas en cada extremo del l\u00edmite as\u00ed como un caso intermedio.</li> </ul> <p>Supongamos que tenemos una funci\u00f3n que eval\u00faa si una persona es elegible para votar. La regla es la siguiente: una persona es elegible para votar si tiene 18 a\u00f1os o m\u00e1s. Veamos el algoritmo, aunque no es necesario para realizar las pruebas:</p> <pre><code>funci\u00f3n esElegibleParaVotar(E entero: edad): cadena\n    si edad &gt;= 18, entonces:\n        devolver \"Elegible\"\n    si no:\n        devolver \"No Elegible\"\n    fin_si\n</code></pre> <p>Por lo siguiente:</p> <ul> <li>el caso v\u00e1lido ser\u00eda \\(\\{x \\ge 18 \\}\\)</li> <li>el caso no v\u00e1lido \\(\\{x \\lt 18 \\}\\).</li> </ul> <p>Los l\u00edmites que podemos obtener, entonces:</p> <ul> <li>L\u00edmite inferior: 18</li> <li>L\u00edmite superior del caso no v\u00e1lido: 17</li> </ul> <p>Por lo tanto, los casos de prueba de caja negra ser\u00edan:</p> Entrada Salida 1 <code>edad=18</code> <code>Elegible</code> 2 <code>edad=25</code> <code>Elegible</code> 3 <code>edad=17</code> <code>No Elegible</code> 4 <code>edad=10</code> <code>No Elegible</code> 5 <code>edad=-1</code> <code>No Elegible</code>"},{"location":"tema_5/page-3/#pruebas-de-caja-blanca","title":"Pruebas de caja blanca","text":"<p>Las pruebas de caja blanca son pruebas que aseguren que la integraci\u00f3n de todos los componentes del programa es correcta, es decir, que cada uno de estos componentes cumple con sus especificaciones y ha sido probado adecuadamente. Para ello se centra en la implementaci\u00f3n del programa, eligiendo los casos de prueba que garanticen todo los posibles caminos de ejecuci\u00f3n que pueden trazarse.</p> <p> Figura 2 - Prueba de Caja Blanca</p> <p>Las pruebas de caja blanca revisan la estructura interna del software para detectar brechas de seguridad que la hacen vulnerable a ciberataques. Lo hace de forma extensa, y para ello se vale de tres t\u00e9cnicas:</p> <ul> <li>Path coverage (prueba de cobertura de ruta): Se prueban las diferentes rutas de ejecuci\u00f3n de un software en busca de vulnerabilidades. Este m\u00e9todo de prueba estructural de caja blanca analiza el c\u00f3digo fuente y permite confirmar que cada ruta posible en el flujo de control de un programa se ha probado al menos en una ocasi\u00f3n.</li> <li>Statement coverage (cobertura de declaraci\u00f3n o cobertura de sentencia): Se eval\u00faan todas las declaraciones ejecutables en el c\u00f3digo fuente por, al menos, una vez. Permiten identificar si hay partes del c\u00f3digo que no se usan, cu\u00e1les faltaron y eliminar el c\u00f3digo muerto sobrante.</li> <li>Branch coverage (cobertura de sucursales): Tiene como objetivo probar todas las ramas posibles en un c\u00f3digo base para verificar que ninguna produzca un comportamiento anormal en la aplicaci\u00f3n de software. Con esta t\u00e9cnica de prueba de caja blanca se eval\u00faa que cada l\u00ednea de c\u00f3digo se ejecuta al menos una vez.</li> </ul> <p>Las pruebas de caja blanca se deben centrar en cubrir el control de flujo del programa. Una t\u00e9cnica de prueba de caja blanca es la Prueba de Ruta B\u00e1sica. Esta t\u00e9cnica permite definir un conjunto b\u00e1sico de rutas de ejecuci\u00f3n, permitiendo as\u00ed obtener un conjunto de casos de prueba que garanticen la ejecuci\u00f3n de cada instrucci\u00f3n al menos una vez durante la prueba. El n\u00famero de caminos independientes viene calculado por la complejidad ciclom\u00e1tica \\(V(G)\\)</p> <p>Supongamos el siguiente pseudoc\u00f3digo:</p> <pre><code>funci\u00f3n contar_letras(E cadena: cad, E letra: char): entero\n    var\n        entero: contador, n, longitud\n\n    n &lt;- 0\n    contador &lt;- 0\n    longitud &lt;- tama\u00f1o(cadena)\n\n    si longitud &gt; 0:\n        repetir\n            si cadena[contador] = letra, entonces:\n                n &lt;- n + 1\n            fin_si\n\n            contador &lt;- contador + 1\n            longitud &lt;- longitud - 1\n        hasta_que (longitud &gt; 0)\n    fin_si\n\n    devolver n\n</code></pre> <p>En primer lugar, se representa el flujo del programa como un grafo de control, donde los nodos representan los puntos de decisi\u00f3n o instrucciones y las aristas (l\u00edneas) indican el flujo de ejecuci\u00f3n entre esos nodos, obteniendo as\u00ed el siguiente grafo:</p> <pre><code>flowchart TD\n    idI((I))\n    id1((1))\n    id2((2))\n    id3((3))\n    id4((4))\n    id5((5))\n    idF((F))\n\n    idI--&gt;id1\n    id1--true--&gt;id2\n    id1--false--&gt;idF\n    id2--true--&gt;id3\n    id2--false--&gt;id4\n    id3--&gt;id5\n    id4--&gt;id5\n    id5--true--&gt;id2\n    id5--false--&gt;idF</code></pre> Figura 3 - Grafo del pseudoc\u00f3digo <p>Una vez obtenido la complejidad ciclom\u00e1tica se calcula a trav\u00e9s del n\u00famero de aristas (l\u00edneas) (\\(NA\\)), el n\u00famero de nodos (\\(NN\\)) o el n\u00famero de nodos predicados (\\(NNP\\)), es decir, aquellos que contienen una condici\u00f3n.</p> <p>Se puede calcular \\(V(G) = NA - NN + 2\\), o \\(V(G) = NNP + 1\\). Tambi\u00e9n se puede obtener a trav\u00e9s del n\u00famero de regiones.</p> <p>En el ejemplo anterior, tenemos que el n\u00famero de aristas es 9, y el n\u00famero de nodos es 7, por lo que \\(V(G) = 9 - 7 + 2 = 4\\). Tambi\u00e9n sabemos que existes 3 nodos predicados, por lo que tambi\u00e9n se cumple \\(V(G) = 3 + 1 = 4\\). Adem\u00e1s, observamos que en el grafo existen 4 regiones, por lo que podemos concluir que \\(V(G) = 4\\).</p> <p>\u00bfQu\u00e9 quiere decir que la complejidad ciclom\u00e1tica sea de 4? Quiere decir que el n\u00famero de caminos independientes son 4. Un camino independiente es aquel trazo del grafo el cu\u00e1l siempre se a\u00f1ade al menos una nueva arista.</p> <p>Una vez calculada la complejidad, se deben definir los caminos independientes. En n\u00famero de caminos independientes son siempre fijos y no var\u00edan, sin embargo, pueden existir diferentes tipos de caminos.</p> <p>En el ejemplo anterior, podemos definir los siguientes caminos independientes:</p> <ul> <li>I-1-F. Al ser el primer camino, es obvio que a\u00f1ade m\u00e1s de una arista.</li> <li>I-1-2-3-4-5-6-F. Partiendo del nodo I, definimos nuevas aristas.</li> <li>I-1-2-4-5-F. Partiendo de nodos anteriores, se definen nuevas aristas.</li> <li>I-1-2-3-4-5-2-4-5-F. No es un camino \u00fanico, ya que el camino I-1-2-4-5-2-3-4-5-F tambi\u00e9n a\u00f1ade la arista 5-2, pero al llegar a los 4 caminos independientes, no es necesario generar m\u00e1s caminos.</li> </ul> <p>Una vez obtenido el grafo y la complejidad, debemos construir los casos de pruebas siguiendo los caminos independientes:</p> Camino Entrada Salida 1 I-1-F `cadena=\"\"   letra='a' 0 2 I-1-2-3-4-5-6-F `cadena=\"a\"  letra='a' 1 3 I-1-2-4-5-F `cadena=\"b\"  letra='a' 0 4 I-1-2-3-4-5-2-4-5-F `cadena=\"ab\" letra='a' 1 <p>Una vez obtenido los casos de prueba, ser\u00e1 necesario ejecutar el c\u00f3digo y comprobar, las posibles entradas, si coinciden las salidas.</p> <p>Gracias a la t\u00e9cnica del camino b\u00e1sico podemos garantizar que estamos recorriendo y verificando que todas las aristas del grafo llegan a ejecutarse en alg\u00fan momento (no es un trozo de c\u00f3digo innecesario) y se ejecutan todas las posibilidades seg\u00fan las condiciones. A\u00fan as\u00ed, se recuerda que, no se puede garantizar que el c\u00f3digo haya quedado libre de errores.</p>"},{"location":"tema_5/page-3/#estrategias-de-pruebas-del-software","title":"Estrategias de pruebas del software","text":"<p>Una estrategia de software integra las t\u00e9cnicas de dise\u00f1o de casos de prueba en una serie de pasos bien planificados que dan como resultados una correcta construcci\u00f3n del software. De esta manera, se proporciona una gu\u00eda tanto para el programador como para la organizaci\u00f3n de control de calidad y el cliente.</p> <p>Las etapas que se deben seguir en el proceso de prueba de software son las siguientes:</p> <ul> <li>Prueba de unidad (o unitaria): Se prueba cada componente y su funcionamiento.</li> <li>Prueba de integraci\u00f3n: Una vez probado cada componente de forma individual, se integran para comprobar las interfaces entre los componentes del software.</li> <li>Prueba de funcional o de validaci\u00f3n: El software completamente ensamblado se prueba como un todo, se comprueba si se cumple o no los requisitos funcionales, requisitos de rendimiento, de comportamiento, de seguridad, etc. Por lo que, se comprueba que no haya diferencias entre el software y los requisitos especificados para su funcionamiento.</li> <li>Prueba de sistema: El software ya validado se integra con el resto de los componentes del sistema (elementos mec\u00e1nicos, interfaces electr\u00f3nicas, etc.). Se prueba que funciona el software con el resto de elementos del sistema en su conjunto, alcanzando la funcionalidad y rendimiento que se espera del sistema.</li> <li>Prueba de aceptaci\u00f3n: Esta prueba la efect\u00faa los usuarios finales en su propio entorno, con datos reales, y son qui\u00e9nes deciden si el software cumple los requisitos fijados. En definitiva, deciden si lo aceptan o no.</li> </ul>"}]}